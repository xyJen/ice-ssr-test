"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getImportPath = exports.globSourceFiles = void 0;
var path = require("path");
var fs = require("fs-extra");
var glob = require("fast-glob");
var es_module_lexer_1 = require("es-module-lexer");
var esbuild_1 = require("esbuild");
var defaultRuntimeRules = {
    'build-plugin-ice-request': ['request', 'useRequest'],
    'build-plugin-ice-auth': ['useAuth', 'withAuth'],
};
function globSourceFiles(sourceDir) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, glob('**/*.{js,ts,jsx,tsx}', {
                        cwd: sourceDir,
                        ignore: [
                            '**/node_modules/**',
                            'src/apis/**',
                            '**/__tests__/**',
                        ],
                        absolute: true,
                    })];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
exports.globSourceFiles = globSourceFiles;
function addLastSlash(filePath) {
    return filePath.endsWith('/') ? filePath : "".concat(filePath, "/");
}
function getWebpackAliasedPath(filePath, alias) {
    var aliasedPath = filePath;
    // eslint-disable-next-line no-restricted-syntax
    for (var _i = 0, _a = Object.keys(alias || {}); _i < _a.length; _i++) {
        var aliasKey = _a[_i];
        var isStrict = aliasKey.endsWith('$');
        var strictKey = isStrict ? aliasKey.slice(0, -1) : aliasKey;
        var aliasValue = alias[aliasKey];
        if (aliasValue.match(/.(j|t)s(x)?$/)) {
            if (aliasedPath === strictKey) {
                aliasedPath = aliasValue;
                break;
            }
        }
        else {
            // case: { xyz: '/some/dir' }, { xyz$: '/some/dir' }
            // import xyz from 'xyz';   // resolved as '/some/dir'
            if (aliasedPath === strictKey) {
                aliasedPath = aliasValue;
                break;
            }
            else if (isStrict) {
                // case: { xyz$: '/some/dir' }
                // import xyz from 'xyz/file.js'; // resolved as /abc/node_modules/xyz/file.js
                // eslint-disable-next-line no-continue
                continue;
            }
            // case: { xyz: '/some/dir' }
            // import xyz from 'xyz/file.js'; // resolved as /some/dir/file.js
            var slashedKey = addLastSlash(strictKey);
            if (aliasedPath.startsWith(slashedKey)) {
                aliasedPath = aliasedPath.replace(new RegExp("^".concat(slashedKey)), addLastSlash(aliasValue));
                break;
            }
        }
    }
    return aliasedPath;
}
function getViteAliasedPath(filePath, alias) {
    // apply aliases
    var aliasedPath = filePath;
    // eslint-disable-next-line no-restricted-syntax
    for (var _i = 0, _a = (alias || []); _i < _a.length; _i++) {
        var _b = _a[_i], find = _b.find, replacement = _b.replacement;
        var matches = typeof find === 'string' ? aliasedPath.startsWith(find) : find.test(aliasedPath);
        if (matches) {
            aliasedPath = aliasedPath.replace(find, replacement);
            break;
        }
    }
    return aliasedPath;
}
function getImportPath(importSpecifier, importer, options) {
    var alias = options.alias, rootDir = options.rootDir, mode = options.mode;
    var aliasedPath = mode === 'webpack'
        ? getWebpackAliasedPath(importSpecifier, alias)
        : getViteAliasedPath(importSpecifier, alias);
    if (!path.isAbsolute(aliasedPath)) {
        try {
            // 检测是否可以在 node_modules 下找到依赖，如果可以直接使用该依赖
            aliasedPath = require.resolve(aliasedPath, { paths: [rootDir] });
        }
        catch (e) {
            // ignore errors
            aliasedPath = path.resolve(path.dirname(importer), aliasedPath);
        }
    }
    // filter path with node_modules
    if (aliasedPath.includes('node_modules')) {
        return '';
    }
    else if (!path.extname(aliasedPath)) {
        // get index file of 
        var basename = path.basename(aliasedPath);
        var patterns = ["".concat(basename, ".{js,ts,jsx,tsx}"), "".concat(basename, "/index.{js,ts,jsx,tsx}")];
        return glob.sync(patterns, {
            cwd: path.dirname(aliasedPath),
            absolute: true,
        })[0];
    }
    return aliasedPath;
}
exports.getImportPath = getImportPath;
function analyzeRuntime(files, options) {
    return __awaiter(this, void 0, void 0, function () {
        function analyzeFile(filePath) {
            return __awaiter(this, void 0, void 0, function () {
                var source, lang, loader, imports, err_2;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            analyzedSet.add(filePath);
                            source = fs.readFileSync(filePath, 'utf-8');
                            lang = path.extname(filePath).slice(1);
                            if (lang === 'ts' || lang === 'tsx' || lang === 'jsx') {
                                // if file includes syntax of JSX, it need to be ends with extension .jsx / .tsx
                                loader = lang;
                            }
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 6, , 7]);
                            if (!loader) return [3 /*break*/, 3];
                            return [4 /*yield*/, (0, esbuild_1.transform)(source, { loader: loader })];
                        case 2:
                            // transform content first since es-module-lexer can't handle ts file
                            source = (_a.sent()).code;
                            _a.label = 3;
                        case 3: return [4 /*yield*/, es_module_lexer_1.init];
                        case 4:
                            _a.sent();
                            imports = (0, es_module_lexer_1.parse)(source)[0];
                            return [4 /*yield*/, Promise.all(imports.map(function (importSpecifier) {
                                    return (function () { return __awaiter(_this, void 0, void 0, function () {
                                        var importName, importStr_1, importPath;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    importName = importSpecifier.n;
                                                    if (!(importName === 'ice')) return [3 /*break*/, 1];
                                                    importStr_1 = source.substring(importSpecifier.ss, importSpecifier.se);
                                                    checkPlugins.forEach(function (pluginName) {
                                                        var apiList = runtimeRules[pluginName];
                                                        if (apiList.some(function (apiName) { return importStr_1.includes(apiName); })) {
                                                            checkMap[pluginName] = true;
                                                        }
                                                    });
                                                    return [3 /*break*/, 3];
                                                case 1:
                                                    if (!analyzeRelativeImport) return [3 /*break*/, 3];
                                                    importPath = importName;
                                                    if (!path.isAbsolute(importPath)) {
                                                        importPath = getImportPath(importPath, filePath, { rootDir: rootDir, alias: alias, mode: mode });
                                                    }
                                                    if (!(importPath
                                                        && !analyzedSet.has(importPath)
                                                        && fs.existsSync(importPath)
                                                        && importPath.match(/\.(j|t)sx?$/))) return [3 /*break*/, 3];
                                                    return [4 /*yield*/, analyzeFile(importPath)];
                                                case 2:
                                                    _a.sent();
                                                    _a.label = 3;
                                                case 3: return [2 /*return*/];
                                            }
                                        });
                                    }); })();
                                }))];
                        case 5:
                            _a.sent();
                            return [3 /*break*/, 7];
                        case 6:
                            err_2 = _a.sent();
                            console.log('[WARN]', "optimize runtime failed when analyze ".concat(filePath));
                            throw err_2;
                        case 7: return [2 /*return*/];
                    }
                });
            });
        }
        var analyzeRelativeImport, rootDir, alias, _a, mode, parallel, _b, customRuntimeRules, parallelNum, sourceFiles, checkMap, analyzedSet, runtimeRules, checkPlugins, i, err_1;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    analyzeRelativeImport = options.analyzeRelativeImport, rootDir = options.rootDir, alias = options.alias, _a = options.mode, mode = _a === void 0 ? 'webpack' : _a, parallel = options.parallel, _b = options.customRuntimeRules, customRuntimeRules = _b === void 0 ? {} : _b;
                    parallelNum = parallel !== null && parallel !== void 0 ? parallel : 10;
                    sourceFiles = __spreadArray([], files, true);
                    checkMap = {};
                    analyzedSet = new Set();
                    runtimeRules = __assign(__assign({}, defaultRuntimeRules), customRuntimeRules);
                    checkPlugins = Object.keys(runtimeRules);
                    checkPlugins.forEach(function (pluginName) {
                        checkMap[pluginName] = false;
                    });
                    _c.label = 1;
                case 1:
                    _c.trys.push([1, 6, , 7]);
                    i = 0;
                    _c.label = 2;
                case 2:
                    if (!(i * parallelNum < sourceFiles.length && checkPlugins.some(function (pluginName) { return checkMap[pluginName] === false; }))) return [3 /*break*/, 5];
                    // eslint-disable-next-line no-await-in-loop
                    return [4 /*yield*/, Promise.all(sourceFiles.slice(i * parallelNum, i * parallelNum + parallelNum).map(function (filePath) {
                            return analyzeFile(filePath);
                        }))];
                case 3:
                    // eslint-disable-next-line no-await-in-loop
                    _c.sent();
                    _c.label = 4;
                case 4:
                    i++;
                    return [3 /*break*/, 2];
                case 5: return [3 /*break*/, 7];
                case 6:
                    err_1 = _c.sent();
                    // 如果发生错误，兜底启用所有自动检测的运行时插件，防止错误地移除
                    checkPlugins.forEach(function (pluginName) {
                        checkMap[pluginName] = true;
                    });
                    return [2 /*return*/, checkMap];
                case 7: return [2 /*return*/, checkMap];
            }
        });
    });
}
exports.default = analyzeRuntime;
//# sourceMappingURL=analyzeRuntime.js.map