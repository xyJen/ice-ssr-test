"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("@testing-library/jest-dom/extend-expect");

var _everDevTest = require("@ali/4ever-dev-test");

var _react = require("@testing-library/react");

var _everCangjie = require("@ali/4ever-cangjie");

var _everMo = require("@ali/4ever-mo");

var _everBamboo = require("@ali/4ever-bamboo");

var _serializer = _interopRequireDefault(require("../serializer"));

var _editor = _interopRequireDefault(require("../editor"));

var _helpers = require("./helpers");

/* eslint-disable import/no-extraneous-dependencies */

/** @jsx jsx */
const {
  DEFAULT_TOTAL_WIDTH_FOR_AUTOFIT
} = _everBamboo.TablePlugin.constants;
const {
  convertFromPercentToPixel
} = _everBamboo.TablePlugin.utils;

const delay = ms => () => new Promise(r => setTimeout(() => r(), ms));

describe('table paste', () => {
  it('选定选区并粘贴更大表格，获取的表格大小不会超过当前表格', async () => {
    const {
      controller,
      editor,
      content
    } = await (0, _helpers.createEditorWithTable)([['A', 'B'], ['C', 'D']], {
      startColIndex: 0,
      startRowIndex: 0,
      endColIndex: 1,
      endRowIndex: 1
    });
    await delay(100);
    const tableSelection = controller.query('tableSelection'); // 选中目前表格所有单元格

    expect(tableSelection).toEqual(expect.objectContaining({
      startRowIndex: 0,
      endRowIndex: 1,
      startColIndex: 0,
      endColIndex: 1
    }));

    _everDevTest.fireEvent.paste(editor, 'text/html', `
      <table>
        <tr><td>A</td><td>B</td><td>C</td><td>D</td></tr>
        <tr><td>E</td><td>F</td><td>G</td><td>H</td></tr>
        <tr><td>I</td><td>J</td><td>K</td><td>L</td></tr>
        <tr><td>M</td><td>N</td><td>O</td><td>P</td></tr>
      </table>
    `);

    await (0, _react.wait)(); // 执行粘贴后，依旧是成2x2的表格，因为选区就那么大，不会超过选区

    expect(content.getElementsByTagName('td').length).toBe(4);
    expect(content.getElementsByTagName('td')[3].textContent).toBe('F');
  });
  it('点击单元格并粘贴更大表格，所得表格大小会超过当前表格', async () => {
    const value = (0, _helpers.createTable)([['A', 'B'], ['C', 'D']]);
    const {
      editor,
      content
    } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
      defaultValue: value
    }));

    _everDevTest.fireEvent.mouseDown(content.getElementsByTagName('td')[0]);

    _everDevTest.fireEvent.paste(editor, 'text/html', `
      <table>
        <tr><td>A</td><td>B</td><td>C</td><td>D</td></tr>
        <tr><td>E</td><td>F</td><td>G</td><td>H</td></tr>
        <tr><td>I</td><td>J</td><td>K</td><td>L</td></tr>
        <tr><td>M</td><td>N</td><td>O</td><td>P</td></tr>
      </table>
    `);

    await (0, _react.wait)(); // 执行粘贴后，拓充成4x4的表格了

    expect(content.getElementsByTagName('td').length).toBe(16);
    expect(content.getElementsByTagName('td')[4 * 4 - 1].textContent).toBe('P');
  });
  it('在合并单元格上粘贴合并单元格，正确处理', async () => {
    const value = _serializer.default.htmlToValue(`
      <table>
        <tr>
          <td rowspan="2" colspan="2">123</td>
          <td rowspan="1" colspan="1"></td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1"></td>
          <td rowspan="1" colspan="1"></td>
        </tr>
      </table>
    `);

    const {
      editor,
      content
    } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
      defaultValue: value
    }));

    _everDevTest.fireEvent.mouseDown(content.getElementsByTagName('td')[0]);

    _everDevTest.fireEvent.paste(editor, 'text/html', `
      <table>
        <tr>
          <td rowspan="2" colspan="1">321</td>
          <td rowspan="2" colspan="1">666</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1"></td>
          <td rowspan="1" colspan="1"></td>
        </tr>
      </table>
    `);

    await (0, _react.wait)();
    expect(content.getElementsByTagName('td')[1].textContent).toBe('666');
  });
  it('选中多个单元格粘贴文本，选中的所有单元格内容替换为该文本', async () => {
    const {
      controller,
      editor,
      content
    } = await (0, _helpers.createEditorWithTable)([['A', 'B', 'C'], ['D', 'E', 'F\nNF'], ['G', 'H', 'I']], {
      startColIndex: 1,
      startRowIndex: 1,
      endColIndex: 2,
      endRowIndex: 2
    });

    _everDevTest.fireEvent.paste(editor, 'text/html', `
      <p>test</p>
    `);

    await (0, _react.wait)(); // 执行粘贴后，拓充成4x4的表格了

    const tds = content.getElementsByTagName('td');

    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 3; j++) {
        if (i > 0 && j > 0) {
          expect(tds[3 * i + j].textContent).toBe('test');
        }
      }
    }
  });
  it('有表格选区时，选中包含表格的内容，粘贴至其他表格时过滤粘贴板内的表格', async () => {
    const {
      editor,
      content
    } = await (0, _helpers.createEditorWithTable)([['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']], {
      startColIndex: 1,
      startRowIndex: 1,
      endColIndex: 2,
      endRowIndex: 2
    });

    _everDevTest.fireEvent.paste(editor, 'text/html', `
      <p>test0</p>
      <table><colgroup><col width="100"></colgroup><tbody><tr><td>123</td></tr></tbody></table>
      <p>test1</p>
    `);

    await (0, _react.wait)();
    const tds = content.getElementsByTagName('td');

    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 3; j++) {
        if (i > 0 && j > 0) {
          expect(tds[3 * i + j].textContent?.trim()).toBe('test0test1');
        }
      }
    }
  });
  it('光标在单元格内时，选中包含表格的内容，粘贴至其他表格时过滤粘贴板内的表格', async () => {
    const {
      editor,
      content
    } = await (0, _helpers.createEditorWithTable)([['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]);
    await (0, _react.wait)();

    _everDevTest.fireEvent.paste(editor, 'text/html', `
      <p>test2</p>
      <table><colgroup><col width="100"></colgroup><tbody><tr><td>123</td></tr></tbody></table>
      <p>test3</p>
    `);

    await (0, _react.wait)();
    const tds = content.getElementsByTagName('td');
    expect(tds[0].textContent).toBe('test2test3A');
  });
  ['cut', 'copy'].forEach(cutOrCopy => {
    it(`表格只包含一个单元格：选中单元格${cutOrCopy}，粘贴出整个表格`, async () => {
      const table = (0, _helpers.createTableInstance)({
        table: [['A']],
        colsWidth: [40]
      });
      const {
        editor
      } = await (0, _helpers.createEditorWithTable)(table, {
        startColIndex: 0,
        startRowIndex: 0,
        endColIndex: 0,
        endRowIndex: 0
      });
      const setData = jest.fn();

      _everDevTest.fireEvent[cutOrCopy](editor, {
        nativeEvent: {
          clipboardData: {
            setData
          },

          preventDefault() {}

        }
      });

      const fragment = _everCangjie.transferUtils.decodeFragment(setData.mock.calls[0][1]);

      const copyTable = fragment.findDescendant(_everMo.Table.isTable);
      expect(_everMo.Table.isTable(copyTable)).toBe(true);
    });
    it(`表格只包含一个单元格：选中单元格内文字${cutOrCopy}，粘贴出纯文本`, async () => {
      const table = (0, _helpers.createTableInstance)({
        table: [['A']],
        colsWidth: [40]
      });
      const {
        editor,
        controller
      } = await (0, _helpers.createEditorWithTable)(table);
      const setData = jest.fn();
      const {
        selection
      } = controller.value;
      const p = (0, _helpers.getTableFromController)(controller).findDescendant(_everMo.Paragraph.isParagraph);
      controller.command(_everCangjie.Commands.select, selection.moveToRangeOfNode(p, controller));

      _everDevTest.fireEvent[cutOrCopy](editor, {
        nativeEvent: {
          clipboardData: {
            setData
          },

          preventDefault() {}

        }
      });

      const fragment = _everCangjie.transferUtils.decodeFragment(setData.mock.calls[0][1]);

      const copyTable = fragment.findDescendant(_everMo.Table.isTable);
      expect(copyTable).toBeNull();
      expect(fragment.text).toBe('A');
    });
    it(`存在表格选区时${cutOrCopy}自适应宽度表格，粘贴的表格 colsWidth 值是像素`, async () => {
      const originColsWidth = [20, 30, 50];
      const table = (0, _helpers.createTableInstance)({
        table: [['A', 'A'], ['A', 'A']],
        colsWidth: originColsWidth,
        isAutofit: true
      });
      const {
        editor
      } = await (0, _helpers.createEditorWithTable)(table, {
        startColIndex: 0,
        startRowIndex: 0,
        endColIndex: 1,
        endRowIndex: 1
      });
      const setData = jest.fn();

      _everDevTest.fireEvent[cutOrCopy](editor, {
        nativeEvent: {
          clipboardData: {
            setData
          },

          preventDefault() {}

        }
      });

      const fragment = _everCangjie.transferUtils.decodeFragment(setData.mock.calls[0][1]);

      const copyTable = fragment.findDescendant(_everMo.Table.isTable);
      const expectCoslWidth = convertFromPercentToPixel(copyTable, DEFAULT_TOTAL_WIDTH_FOR_AUTOFIT);
      expect(copyTable.data.colsWidth).toEqual(expectCoslWidth);
      expect(_everMo.Table.isAutofitWidth(copyTable)).toBe(true);
    });
    it(`没有表格选区时${cutOrCopy}自适应宽度表格，粘贴的表格 colsWidth 值是像素`, async () => {
      const originColsWidth = [20, 30, 50];
      const table = (0, _helpers.createTableInstance)({
        table: [['A', 'A'], ['A', 'A']],
        colsWidth: originColsWidth,
        isAutofit: true
      });
      const {
        editor,
        controller
      } = await (0, _helpers.createEditor)({
        table,
        extra: {
          before: 'before',
          after: 'after'
        }
      });
      const {
        document,
        selection
      } = controller.value;
      const firstP = document.nodes[0];
      const lastP = document.nodes[document.nodes.length - 1];
      const newSelection = selection.moveAnchorToStartOfNode(firstP, controller).moveFocusToEndOfNode(lastP, controller);
      controller.command(_everCangjie.Commands.select, newSelection);
      const setData = jest.fn();

      _everDevTest.fireEvent[cutOrCopy](editor, {
        nativeEvent: {
          clipboardData: {
            setData
          },

          preventDefault() {}

        }
      });

      const fragment = _everCangjie.transferUtils.decodeFragment(setData.mock.calls[0][1]);

      const copyTable = fragment.findDescendant(_everMo.Table.isTable);
      const expectCoslWidth = convertFromPercentToPixel(copyTable, DEFAULT_TOTAL_WIDTH_FOR_AUTOFIT);
      expect(copyTable.data.colsWidth).toEqual(expectCoslWidth);
      expect(_everMo.Table.isAutofitWidth(copyTable)).toBe(true);
      expect(fragment.nodes[0].text).toBe('before');
      expect(fragment.nodes[fragment.nodes.length - 1].text).toBe('after');
    });
  });
});
//# sourceMappingURL=paste.test.js.map