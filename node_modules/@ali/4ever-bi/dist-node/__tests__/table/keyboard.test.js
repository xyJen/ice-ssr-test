"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("@testing-library/jest-dom/extend-expect");

var _react = require("@testing-library/react");

var _everDevTest = require("@ali/4ever-dev-test");

var _everCangjie = require("@ali/4ever-cangjie");

var _everMo = require("@ali/4ever-mo");

var _lodash = require("lodash");

var _serializer = _interopRequireDefault(require("../serializer"));

var _editor = _interopRequireDefault(require("../editor"));

var _helpers = require("./helpers");

var _helper = require("../helper");

/* eslint-disable import/no-extraneous-dependencies */

/** @jsx jsx */
async function createFullSelectedTableWithSiblings() {
  const tableSelection = {
    startColIndex: 0,
    startRowIndex: 0,
    endColIndex: 1,
    endRowIndex: 1
  };
  const value = (0, _helpers.createTable)([['A', 'B'], ['C', 'D']], {
    before: '<p>123</p>',
    after: '<p>abc</p>'
  });
  const controllerRef = jest.fn();
  const {
    content,
    editor
  } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
    defaultValue: value,
    controllerRef: controllerRef
  }));
  const controller = (0, _lodash.last)(controllerRef.mock.calls)[0];
  const tableNode = controller.value.document.findDescendant(_everMo.Table.isTable);
  controller.command('selectTableSelection', tableNode, { ...tableSelection,
    key: tableNode.key
  });
  const tbSelection = controller.query('tableSelection');
  expect(tbSelection).toEqual(expect.objectContaining(tableSelection));
  return {
    editor,
    content,
    controller
  };
}

function createFullSelectedTable() {
  const tableSelection = {
    startColIndex: 0,
    startRowIndex: 0,
    endColIndex: 1,
    endRowIndex: 1
  };
  return (0, _helpers.createEditorWithTable)([['A', 'B'], ['C', 'D']], tableSelection);
}

const createRangeDescriptor = Object.getOwnPropertyDescriptor(document, 'createRange');
beforeAll(() => {
  Object.defineProperty(document, 'createRange', {
    configurable: true,

    value() {
      const range = createRangeDescriptor ? createRangeDescriptor.value() : {};
      return { ...range,

        getClientRects() {
          return [{
            top: 0,
            left: 0,
            right: 1,
            bottom: 1,
            width: 1,
            height: 1
          }];
        }

      };
    }

  });
});
afterAll(() => {
  Object.defineProperty(document, 'createRange', createRangeDescriptor || {
    value() {
      return {};
    }

  });
});

var _ref = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("cursor", null))));

describe('table keyboard', () => {
  describe('tab', () => {
    it('表格内按 tab 跳到下一个单元格', async () => {
      const value = (0, _helpers.createTable)([['A', 'B']]);
      const controllerRef = jest.fn();
      const {
        editor
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
        defaultValue: value,
        controllerRef: controllerRef
      }));
      const controller = (0, _lodash.last)(controllerRef.mock.calls)[0];

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('tab'));

      await (0, _react.wait)();
      const target = controller.value.document.getNodeByPath([0, 0, 1, 0]);
      expect(controller.value.startBlock).toBe(target);
    });
    it('表格行末按 tab 跳到下一行第一个单元格', async () => {
      const value = (0, _helpers.createTable)([['A'], ['B']]);
      const controllerRef = jest.fn();
      const {
        editor
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
        defaultValue: value,
        controllerRef: controllerRef
      }));
      const controller = (0, _lodash.last)(controllerRef.mock.calls)[0];

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('tab'));

      await (0, _react.wait)();
      const target = controller.value.document.getNodeByPath([0, 1, 0, 0]);
      expect(controller.value.startBlock).toBe(target);
    });
    it('表格最后一个单元格按 tab，插入一行，并跳到新行第一个单元格', async () => {
      const value = (0, _helpers.createTable)([['A']]);
      const controllerRef = jest.fn();
      const {
        editor
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
        defaultValue: value,
        controllerRef: controllerRef
      }));
      const controller = (0, _lodash.last)(controllerRef.mock.calls)[0];

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('tab'));

      await (0, _react.wait)();
      expect(controller.value.document.nodes[0].nodes.length).toBe(2);
      const target = controller.value.document.getNodeByPath([0, 1, 0, 0]);
      expect(controller.value.startBlock).toBe(target);
    });
    it('表格内按 shift+tab 跳到上一个单元格', async () => {
      const value = (0, _helpers.createTable)([['A', 'B']]);
      const controllerRef = jest.fn();
      const {
        editor
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
        defaultValue: value,
        controllerRef: controllerRef
      }));
      const controller = (0, _lodash.last)(controllerRef.mock.calls)[0];

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('tab+shift'));

      await (0, _react.wait)();
      const target = controller.value.document.getNodeByPath([0, 0, 0, 0]);
      expect(controller.value.startBlock).toBe(target);
    });
    it('表格行首按 shift+tab 跳到上一行最后一个单元格', async () => {
      const value = (0, _helpers.createTable)([['A'], ['B']]);
      const controllerRef = jest.fn();
      const {
        editor
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
        defaultValue: value,
        controllerRef: controllerRef
      }));
      const controller = (0, _lodash.last)(controllerRef.mock.calls)[0];
      const tableNode = controller.value.document.findDescendant(node => node.isElement() && node.type === 'table');
      controller.command(_everCangjie.Commands.moveToEndOfNode, tableNode.getLastNode());
      const cursor = controller.value.document.getNodeByPath([0, 1, 0, 0]);
      expect(controller.value.startBlock).toBe(cursor);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('tab+shift'));

      await (0, _react.wait)();
      const target = controller.value.document.getNodeByPath([0, 0, 0, 0]);
      expect(controller.value.startBlock).toBe(target);
    });
    it('表格第一个单元格按 shift+tab 不作任何处理', async () => {
      const value = (0, _helpers.createTable)([['A']]);
      const controllerRef = jest.fn();
      const {
        editor
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
        defaultValue: value,
        controllerRef: controllerRef
      }));
      const controller = (0, _lodash.last)(controllerRef.mock.calls)[0];

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('tab+shift'));

      await (0, _react.wait)();
      const target = controller.value.document;
      expect(controller.value.document).toBe(target);
    });
    it('选中整个表格后，选中第一个 cell', async () => {
      const {
        controller,
        editor
      } = await createFullSelectedTable();

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('tab'));

      await (0, _react.wait)();
      const {
        selection
      } = controller.value;
      expect(selection.anchor.offset).toBe(0);
      expect(selection.focus.offset).toBe(1);
      const path = controller.value.document.getPath(selection.anchor.key);
      expect(path).toEqual([0, 0, 0, 0, 0]);
    });
    it('存在 tableSlection 时，选中左上角单元格', async () => {
      const {
        controller,
        editor
      } = await (0, _helpers.createEditorWithTable)([['A', 'B'], ['C', 'D']], {
        startColIndex: 0,
        startRowIndex: 1,
        endColIndex: 1,
        endRowIndex: 1
      });

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('tab'));

      await (0, _react.wait)();
      const {
        selection
      } = controller.value;
      expect(selection.anchor.offset).toBe(0);
      expect(selection.focus.offset).toBe(1);
      const path = controller.value.document.getPath(selection.anchor.key);
      expect(path).toEqual([0, 1, 0, 0, 0]);
    });
  });
  describe('arrowUp', () => {
    it('按方向键上把光标移动到上方单元格', async () => {
      const value = (0, _helpers.createTable)([['A', 'B'], ['C', 'D']]);
      const controllerRef = jest.fn();
      const {
        editor
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
        defaultValue: value,
        controllerRef: controllerRef
      }));
      const controller = (0, _lodash.last)(controllerRef.mock.calls)[0];
      const tableNode = controller.value.document.findDescendant(node => node.isElement() && node.type === 'table');
      controller.command(_everCangjie.Commands.moveToEndOfNode, tableNode.getLastNode());

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ArrowUp'));

      await (0, _react.wait)();
      const target = controller.value.document.getNodeByPath([0, 0, 1, 0]);
      expect(controller.value.startBlock).toBe(target);
      const tableSelection = controller.query('tableSelection');
      expect(tableSelection).toEqual(null);
    });
    it('选中整个表格后，光标移动至表格上一个 block 的起点', async () => {
      const {
        controller,
        editor
      } = await createFullSelectedTableWithSiblings();

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ArrowUp'));

      await (0, _react.wait)();
      const {
        selection
      } = controller.value;
      const {
        anchor
      } = selection;
      expect(selection.isCollapsed).toBe(true);
      expect(anchor.offset).toBe(0);
      const path = controller.value.document.getPath(selection.anchor.key);
      expect(path).toEqual([0, 0]);
      const tableSelection = controller.query('tableSelection');
      expect(tableSelection).toEqual(null);
    });
    it('选中整个表格后，若不存在上一个 block 光标移动至表格左侧', async () => {
      const {
        controller,
        editor
      } = await createFullSelectedTable();

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ArrowUp'));

      await (0, _react.wait)();
      const {
        selection
      } = controller.value;
      const {
        anchor
      } = selection;
      expect(selection.isCollapsedAtEdge).toBe(true);
      expect(anchor.edge).toBe('before');
      const path = controller.value.document.getPath(selection.anchor.key);
      expect(path).toEqual([0]);
      const tableSelection = controller.query('tableSelection');
      expect(tableSelection).toEqual(null);
    });
    it('存在 tableSlection 时，focus 左上角的正上方单元格起点', async () => {
      const {
        controller,
        editor
      } = await (0, _helpers.createEditorWithTable)([['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']], {
        startColIndex: 1,
        startRowIndex: 2,
        endColIndex: 2,
        endRowIndex: 2
      });

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ArrowUp'));

      await (0, _react.wait)();
      const {
        selection
      } = controller.value;
      expect(selection.anchor.offset).toBe(0);
      expect(selection.focus.offset).toBe(0);
      const path = controller.value.document.getPath(selection.anchor.key);
      expect(path).toEqual([0, 1, 1, 0, 0]);
      const tableSelection = controller.query('tableSelection');
      expect(tableSelection).toEqual(null);
    });
    it('存在 tableSlection 时，且选中了第一行，则 focus 左上角单元格起点', async () => {
      const {
        controller,
        editor
      } = await (0, _helpers.createEditorWithTable)([['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']], {
        startColIndex: 1,
        startRowIndex: 0,
        endColIndex: 2,
        endRowIndex: 0
      });

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ArrowUp'));

      await (0, _react.wait)();
      const {
        selection
      } = controller.value;
      expect(selection.anchor.offset).toBe(0);
      expect(selection.focus.offset).toBe(0);
      const path = controller.value.document.getPath(selection.anchor.key);
      expect(path).toEqual([0, 0, 1, 0, 0]);
      const tableSelection = controller.query('tableSelection');
      expect(tableSelection).toEqual(null);
    });
  });
  describe('arrowDown', () => {
    it('按方向键下把光标移动到下方单元格', async () => {
      const value = (0, _helpers.createTable)([['A', 'B'], ['C', 'D']]);
      const controllerRef = jest.fn();
      const {
        editor
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
        defaultValue: value,
        controllerRef: controllerRef
      }));
      const controller = (0, _lodash.last)(controllerRef.mock.calls)[0];

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ArrowDown'));

      await (0, _react.wait)();
      const target = controller.value.document.getNodeByPath([0, 1, 0, 0]);
      expect(controller.value.startBlock).toBe(target);
      const tableSelection = controller.query('tableSelection');
      expect(tableSelection).toEqual(null);
    });
    it('选中整个表格后，光标移动至表格下一个 block 的起点', async () => {
      const {
        controller,
        editor
      } = await createFullSelectedTableWithSiblings();

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ArrowDown'));

      await (0, _react.wait)();
      const {
        selection
      } = controller.value;
      const {
        anchor
      } = selection;
      expect(selection.isCollapsed).toBe(true);
      expect(anchor.offset).toBe(0);
      const path = controller.value.document.getPath(selection.anchor.key);
      expect(path).toEqual([2, 0]);
      const tableSelection = controller.query('tableSelection');
      expect(tableSelection).toEqual(null);
    });
    it('选中整个表格后，若不存在下一个 block 光标移动至表格右侧', async () => {
      const {
        controller,
        editor
      } = await createFullSelectedTable();

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ArrowDown'));

      await (0, _react.wait)();
      const {
        selection
      } = controller.value;
      const {
        anchor
      } = selection;
      expect(selection.isCollapsedAtEdge).toBe(true);
      expect(anchor.edge).toBe('after');
      const path = controller.value.document.getPath(selection.anchor.key);
      expect(path).toEqual([0]);
      const tableSelection = controller.query('tableSelection');
      expect(tableSelection).toEqual(null);
    });
    it('存在 tableSlection 时，focus 选区左下角下方', async () => {
      const {
        controller,
        editor
      } = await (0, _helpers.createEditorWithTable)([['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']], {
        startColIndex: 1,
        startRowIndex: 0,
        endColIndex: 2,
        endRowIndex: 0
      });

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ArrowDown'));

      await (0, _react.wait)();
      const {
        selection
      } = controller.value;
      expect(selection.anchor.offset).toBe(0);
      expect(selection.focus.offset).toBe(0);
      const path = controller.value.document.getPath(selection.anchor.key);
      expect(path).toEqual([0, 1, 1, 0, 0]);
      const tableSelection = controller.query('tableSelection');
      expect(tableSelection).toEqual(null);
    });
    it('存在 tableSlection 时，且选中了最后一行，则 focus 左下角单元格起点', async () => {
      const {
        controller,
        editor
      } = await (0, _helpers.createEditorWithTable)([['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']], {
        startColIndex: 1,
        startRowIndex: 0,
        endColIndex: 2,
        endRowIndex: 2
      });

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ArrowDown'));

      await (0, _react.wait)();
      const {
        selection
      } = controller.value;
      expect(selection.anchor.offset).toBe(0);
      expect(selection.focus.offset).toBe(0);
      const path = controller.value.document.getPath(selection.anchor.key);
      expect(path).toEqual([0, 2, 1, 0, 0]);
      const tableSelection = controller.query('tableSelection');
      expect(tableSelection).toEqual(null);
    });
  });
  describe('arrowRight', () => {
    it('按方向键右把光标移动到右侧单元格', async () => {
      const value = (0, _helpers.createTable)([['', '']]);
      const controllerRef = jest.fn();
      const {
        editor
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
        defaultValue: value,
        controllerRef: controllerRef
      }));
      const controller = (0, _lodash.last)(controllerRef.mock.calls)[0];

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ArrowRight'));

      await (0, _react.wait)();
      const target = controller.value.document.getNodeByPath([0, 0, 1, 0]);
      expect(controller.value.startBlock).toBe(target);
      const tableSelection = controller.query('tableSelection');
      expect(tableSelection).toEqual(null);
    });
    it('选中整个表格后，光标移动至表格下一个 block 的起点', async () => {
      const {
        controller,
        editor
      } = await createFullSelectedTableWithSiblings();

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ArrowRight'));

      await (0, _react.wait)();
      const {
        selection
      } = controller.value;
      const {
        anchor
      } = selection;
      expect(selection.isCollapsed).toBe(true);
      expect(anchor.offset).toBe(0);
      const path = controller.value.document.getPath(selection.anchor.key);
      expect(path).toEqual([2, 0]);
      const tableSelection = controller.query('tableSelection');
      expect(tableSelection).toEqual(null);
    });
    it('选中整个表格后，若不存在下一个 block 光标移动至表格右侧', async () => {
      const {
        controller,
        editor
      } = await createFullSelectedTable();

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ArrowRight'));

      await (0, _react.wait)();
      const {
        selection
      } = controller.value;
      const {
        anchor
      } = selection;
      expect(selection.isCollapsedAtEdge).toBe(true);
      expect(anchor.edge).toBe('after');
      const path = controller.value.document.getPath(selection.anchor.key);
      expect(path).toEqual([0]);
      const tableSelection = controller.query('tableSelection');
      expect(tableSelection).toEqual(null);
    });
    it('存在 tableSlection 时，focus 选区左下角下方', async () => {
      const {
        controller,
        editor
      } = await (0, _helpers.createEditorWithTable)([['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']], {
        startColIndex: 0,
        startRowIndex: 1,
        endColIndex: 0,
        endRowIndex: 2
      });

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ArrowRight'));

      await (0, _react.wait)();
      const {
        selection
      } = controller.value;
      expect(selection.anchor.offset).toBe(0);
      expect(selection.focus.offset).toBe(0);
      const path = controller.value.document.getPath(selection.anchor.key);
      expect(path).toEqual([0, 1, 1, 0, 0]);
      const tableSelection = controller.query('tableSelection');
      expect(tableSelection).toEqual(null);
    });
    it('存在 tableSlection 时，且选中了最后一列，则 focus 右上角单元格起点', async () => {
      const {
        controller,
        editor
      } = await (0, _helpers.createEditorWithTable)([['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']], {
        startColIndex: 1,
        startRowIndex: 1,
        endColIndex: 2,
        endRowIndex: 2
      });

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ArrowRight'));

      await (0, _react.wait)();
      const {
        selection
      } = controller.value;
      expect(selection.anchor.offset).toBe(0);
      expect(selection.focus.offset).toBe(0);
      const path = controller.value.document.getPath(selection.anchor.key);
      expect(path).toEqual([0, 1, 2, 0, 0]);
      const tableSelection = controller.query('tableSelection');
      expect(tableSelection).toEqual(null);
    });
  });
  describe('arrowLeft', () => {
    it('按方向键左把光标移动到左侧单元格', async () => {
      const value = (0, _helpers.createTable)([['', '']]);
      const controllerRef = jest.fn();
      const {
        editor
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
        defaultValue: value,
        controllerRef: controllerRef
      }));
      const controller = (0, _lodash.last)(controllerRef.mock.calls)[0];
      const tableNode = controller.value.document.findDescendant(node => node.isElement() && node.type === 'table');
      controller.command(_everCangjie.Commands.moveToEndOfNode, tableNode.getLastNode());

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ArrowLeft'));

      const target = controller.value.document.getNodeByPath([0, 0, 0, 0]);
      expect(controller.value.startBlock).toBe(target);
      const tableSelection = controller.query('tableSelection');
      expect(tableSelection).toEqual(null);
    });
    it('选中整个表格后，光标移动至表格第一个 cell 的起点', async () => {
      const {
        controller,
        editor
      } = await createFullSelectedTable();

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ArrowLeft'));

      await (0, _react.wait)();
      const {
        selection
      } = controller.value;
      const {
        anchor
      } = selection;
      expect(selection.isCollapsed).toBe(true);
      expect(anchor.offset).toBe(0);
      const path = controller.value.document.getPath(selection.anchor.key);
      expect(path).toEqual([0, 0, 0, 0, 0]);
      const tableSelection = controller.query('tableSelection');
      expect(tableSelection).toEqual(null);
    });
    it('存在 tableSlection 时，focus 选区左上角', async () => {
      const {
        controller,
        editor
      } = await (0, _helpers.createEditorWithTable)([['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']], {
        startColIndex: 1,
        startRowIndex: 1,
        endColIndex: 2,
        endRowIndex: 2
      });

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ArrowLeft'));

      await (0, _react.wait)();
      const {
        selection
      } = controller.value;
      expect(selection.anchor.offset).toBe(0);
      expect(selection.focus.offset).toBe(0);
      const path = controller.value.document.getPath(selection.anchor.key);
      expect(path).toEqual([0, 1, 1, 0, 0]);
      const tableSelection = controller.query('tableSelection');
      expect(tableSelection).toEqual(null);
    });
    it('存在 tableSlection 时，且选中了第一列内容，则 focus 左上角单元格起点', async () => {
      const {
        controller,
        editor
      } = await (0, _helpers.createEditorWithTable)([['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']], {
        startColIndex: 0,
        startRowIndex: 1,
        endColIndex: 2,
        endRowIndex: 2
      });

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ArrowLeft'));

      await (0, _react.wait)();
      const {
        selection
      } = controller.value;
      expect(selection.anchor.offset).toBe(0);
      expect(selection.focus.offset).toBe(0);
      const path = controller.value.document.getPath(selection.anchor.key);
      expect(path).toEqual([0, 1, 0, 0, 0]);
      const tableSelection = controller.query('tableSelection');
      expect(tableSelection).toEqual(null);
    });
  });
  describe('cmd+c', () => {
    it('复制选中区域表格数据', async () => {
      const tableSelection = {
        startRowIndex: 0,
        startColIndex: 0,
        endRowIndex: 0,
        endColIndex: 1
      };
      const {
        editor,
        controller
      } = await (0, _helpers.createEditorWithTable)([['A', 'B'], ['C', 'D']], tableSelection);
      const table = controller.value.document.nodes[0];
      const tableJs = table.toJSON(); // 切掉第二行，只留第一行
      // eslint-disable-next-line no-unused-expressions

      tableJs.nodes?.splice(1, 1);

      const fragment = _everCangjie.Document.create({
        data: {
          copyFrom: expect.anything()
        },
        nodes: [_everCangjie.Block.fromJSON(tableJs)]
      });

      await (0, _react.wait)();
      const setData = jest.fn();

      _everDevTest.fireEvent.copy(editor, {
        nativeEvent: {
          clipboardData: {
            setData
          },

          preventDefault() {}

        }
      }); // 只测试 text 和 fragment，html 暂时忽略


      expect(_everCangjie.transferUtils.decodeFragment(setData.mock.calls[0][1]).toJSON()).toEqual(fragment.toJSON());
      expect(setData.mock.calls[2]).toEqual(['text/plain', 'A\nB']);
    });
  });
  describe('cmd+x', () => {
    it('剪切选中区域表格数据', async () => {
      const tableSelection = {
        startRowIndex: 0,
        startColIndex: 0,
        endRowIndex: 0,
        endColIndex: 1
      };
      const {
        editor,
        content
      } = await (0, _helpers.createEditorWithTable)([['A', 'B'], ['C', 'D']], tableSelection);
      await (0, _react.wait)();
      const originalRequestAnimationFrame = window.requestAnimationFrame;
      const mockRequestAnimationFrame = jest.fn();
      window.requestAnimationFrame = mockRequestAnimationFrame;

      _everDevTest.fireEvent.cut(editor, {
        clipboardData: {
          setData: () => null
        }
      });

      mockRequestAnimationFrame.mock.calls.forEach(([fn]) => fn());
      window.requestAnimationFrame = originalRequestAnimationFrame;
      await (0, _react.wait)();
      expect(content.getElementsByTagName('td')[0].textContent).toBe('\uFEFF');
      expect(content.getElementsByTagName('td')[1].textContent).toBe('\uFEFF');
      expect(content.getElementsByTagName('td')[2].textContent).toBe('C');
      expect(content.getElementsByTagName('td')[3].textContent).toBe('D');
    });
  });
  describe('cmd+v', () => {
    it('光标在单元格内粘贴表格', async () => {
      const value = (0, _helpers.createTable)([['1', '2']]);
      const {
        editor,
        content
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
        defaultValue: value
      }));

      _everDevTest.fireEvent.paste(editor, 'text/html', `
        <table>
          <tr><td>A</td><td>B</td></tr>
        </table>
      `);

      await (0, _react.wait)();
      expect(content.getElementsByTagName('td')[0].textContent).toBe('A');
      expect(content.getElementsByTagName('td')[1].textContent).toBe('B');
    });
    it('选中一个选区粘贴表格', async () => {
      const tableSelection = {
        startRowIndex: 0,
        startColIndex: 0,
        endRowIndex: 0,
        endColIndex: 1
      };
      const {
        editor,
        content
      } = await (0, _helpers.createEditorWithTable)([['1', '2'], ['3', '4']], tableSelection);

      _everDevTest.fireEvent.paste(editor, 'text/html', `
        <table>
          <tr><td>A</td><td>B</td></tr>
          <tr><td>C</td><td>D</td></tr>
        </table>
      `);

      await (0, _react.wait)();
      expect(content.getElementsByTagName('td')[0].textContent).toBe('A');
      expect(content.getElementsByTagName('td')[1].textContent).toBe('B');
      expect(content.getElementsByTagName('td')[2].textContent).toBe('3');
      expect(content.getElementsByTagName('td')[3].textContent).toBe('4');
    });
    it('拷贝单元格内的内容粘贴', async () => {
      const value = _ref;
      const {
        editor,
        content
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
        defaultValue: value
      }));

      _everDevTest.fireEvent.paste(editor, 'text/html', `
        <table>
          <tr><td>A</td></tr>
        </table>
      `);

      await (0, _react.wait)();
      expect(content.getElementsByTagName('table').length).toBe(1);
      expect(content.querySelector('table [data-type="paragraph"]').textContent).toBe('A');
    });
  });
  describe('cmd+a', () => {
    it('单元格内按 cmd+a 全选单元格内容', async () => {
      const value = (0, _helpers.createTable)([['1', '2']]);
      const controllerRef = jest.fn();
      const {
        editor
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
        defaultValue: value,
        controllerRef: controllerRef
      }));
      const controller = (0, _lodash.last)(controllerRef.mock.calls)[0];

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ctrl+a'));

      const targetCell = controller.value.document.getNodeByPath([0, 0, 0]);
      const {
        selection,
        document
      } = controller.value;
      const start = selection?.getStart(document);
      const end = selection?.getEnd(document);
      expect(start?.isAtStartOfNode(targetCell)).toBe(true);
      expect(end?.isAtEndOfNode(targetCell)).toBe(true);
    });
    it('空单元格内按 cmd+a 全选表格', async () => {
      const value = (0, _helpers.createTable)([['', '']]);
      const controllerRef = jest.fn();
      const {
        editor
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
        defaultValue: value,
        controllerRef: controllerRef
      }));
      const controller = (0, _lodash.last)(controllerRef.mock.calls)[0];

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ctrl+a'));

      const table = (0, _helpers.getTableFromController)(controller);
      const isSelectTable = controller.query('isSelectWholeTable', {
        node: table
      });
      expect(isSelectTable).toBe(true);
    });
    it('选中单元格后 cmd+a 全选表格', async () => {
      const value = (0, _helpers.createTable)([['1', '2']]);
      const controllerRef = jest.fn();
      const {
        editor
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
        defaultValue: value,
        controllerRef: controllerRef
      }));
      const controller = (0, _lodash.last)(controllerRef.mock.calls)[0];

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ctrl+a'));

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ctrl+a'));

      const table = (0, _helpers.getTableFromController)(controller);
      const isSelectTable = controller.query('isSelectWholeTable', {
        node: table
      });
      expect(isSelectTable).toBe(true);
    });
    it('选中表格后 cmd+a 全选文档', async () => {
      const value = (0, _helpers.createTable)([['1', '2']], {
        before: 'start',
        after: 'end'
      });
      const controllerRef = jest.fn();
      const {
        editor
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
        defaultValue: value,
        controllerRef: controllerRef
      }));
      const controller = (0, _lodash.last)(controllerRef.mock.calls)[0];
      const firstCell = controller.value.document.findDescendant(_everMo.TableCell.isTableCell);
      controller.command(_everCangjie.Commands.moveToStartOfNode, firstCell);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ctrl+a'));

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ctrl+a'));

      const table = (0, _helpers.getTableFromController)(controller);
      const isSelectTable = controller.query('isSelectWholeTable', {
        node: table
      });
      expect(isSelectTable).toBe(true);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('ctrl+a'));

      const {
        selection,
        document
      } = controller.value;
      const start = selection?.getStart(document);
      const end = selection?.getEnd(document);
      expect(start?.isAtStartOfNode(document)).toBe(true);
      expect(end?.isAtEndOfNode(document)).toBe(true);
    });
  });
  describe('delete', () => {
    it('用户拖选中多个单元格后，按 delete 将选中表格内容删除', async () => {
      const tableSelection = {
        startRowIndex: 0,
        startColIndex: 0,
        endRowIndex: 0,
        endColIndex: 1
      };
      const {
        editor,
        content
      } = await (0, _helpers.createEditorWithTable)([['A', 'B', 'C']], tableSelection);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('delete'));

      await (0, _react.wait)();
      expect(content.getElementsByTagName('td')[0].textContent).toBe('\uFEFF');
      expect(content.getElementsByTagName('td')[1].textContent).toBe('\uFEFF');
    });
    it('用户全选表格后，按 delete 将表格本体删除', async () => {
      const tableSelection = {
        startRowIndex: 0,
        startColIndex: 0,
        endRowIndex: 0,
        endColIndex: 1
      };
      const {
        editor,
        content
      } = await (0, _helpers.createEditorWithTable)([['A', 'B']], tableSelection);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('delete'));

      await (0, _react.wait)();
      expect(content.getElementsByTagName('table').length).toBe(0);
    });
    it('在单元格内容前按 backspace 不做任何处理', async () => {
      const value = (0, _helpers.createTable)([['A', 'B']]);
      const controllerRef = jest.fn();
      const {
        editor
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
        defaultValue: value,
        controllerRef: controllerRef
      }));
      const controller = (0, _lodash.last)(controllerRef.mock.calls)[0];
      controller.command(_everCangjie.Commands.moveForward, 2);
      const targetDocument = controller.value.document;

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('backspace'));

      expect(controller.value.document).toEqual(targetDocument);
    });
    it('单元格内按delete，能删除文本内容', async () => {
      const value = (0, _helpers.createTable)([['A', 'B']]);
      const controllerRef = jest.fn();
      const {
        editor,
        content
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
        defaultValue: value,
        controllerRef: controllerRef
      }));
      const controller = (0, _lodash.last)(controllerRef.mock.calls)[0];
      controller.command(_everCangjie.Commands.moveForward, 2);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('delete'));

      await (0, _react.wait)();
      const {
        textContent
      } = content.getElementsByTagName('td')[1];
      expect((0, _helper.removeInvisibleChars)(textContent)).toEqual('');
    }); // TODO：不稳定，暂时 skip

    it.skip('单元格第一行为分割线时，选中分割线按 delete 可以正常删除', async () => {
      const value = _serializer.default.htmlToValue(`
        <p></p>
        <table>
          <tr><td><hr /></td></tr>
        </table>
      `);

      const controllerRef = jest.fn();
      const {
        editor,
        content,
        queryByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
        defaultValue: value,
        controllerRef: controllerRef
      }));
      const controller = (0, _lodash.last)(controllerRef.mock.calls)[0];
      controller.command(_everCangjie.Commands.moveForward, 1);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('delete'));

      await (0, _react.waitForElementToBeRemoved)(() => queryByTestId('cangjie-caret'));

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('delete'));

      await (0, _react.wait)();
      expect(content.getElementsByTagName('hr').length).toBe(0);
    });
    it('在表格后一行行首按 delete，不会删除表格，段落删除前一个字母', async () => {
      const value = (0, _helpers.createTable)([['A', 'B']], {
        after: '<p>Hello World!</p>'
      });
      const paragraph = (0, _lodash.last)(value.document.nodes);
      const controllerRef = jest.fn();
      const {
        editor,
        content
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
        defaultValue: value,
        controllerRef: controllerRef
      }));
      const controller = (0, _lodash.last)(controllerRef.mock.calls)[0];
      controller.command(_everCangjie.Commands.moveToStartOfNode, paragraph);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('delete'));

      await (0, _react.wait)();
      expect(content.querySelectorAll('*[data-type=paragraph]')[2].textContent).toBe('ello World!');
    });
    it.skip('表格后一行为分割线时，选中分割线按 delete 可以正常删除', async () => {
      const value = (0, _helpers.createTable)([['A', 'B']], {
        after: '<hr />'
      });
      const controllerRef = jest.fn();
      const {
        editor,
        content,
        queryByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
        defaultValue: value,
        controllerRef: controllerRef
      }));
      const controller = (0, _lodash.last)(controllerRef.mock.calls)[0];
      const hr = (0, _lodash.last)(value.document.nodes);
      controller.command(_everCangjie.Commands.moveToStartOfNode, hr);
      expect(hr.type).toBe('hr');

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('delete'));

      await (0, _react.waitForElementToBeRemoved)(() => queryByTestId('cangjie-caret'));

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('delete'));

      await (0, _react.wait)();
      expect(content.getElementsByTagName('hr').length).toBe(0);
    });
    it('表格后一个为普通段落时，全选按 delete 可以正常删除', async () => {
      const value = (0, _helpers.createTable)([['A', 'B']], {
        after: '<p></p>'
      });
      const controllerRef = jest.fn();
      const {
        editor,
        content
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
        defaultValue: value,
        controllerRef: controllerRef
      }));
      const controller = (0, _lodash.last)(controllerRef.mock.calls)[0];
      controller.command(_everCangjie.Commands.moveToRangeOfDocument);
      expect(content.getElementsByTagName('table').length).toBe(1);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('delete'));

      await (0, _react.wait)();
      expect(content.getElementsByTagName('table').length).toBe(0);
      expect(content.querySelector('*[data-type="paragraph"]').textContent).toBe('\uFEFF');
    });
    it('表格前一个为普通段落时，全选按 delete 可以正常删除', async () => {
      const value = (0, _helpers.createTable)([['A', 'B']], {
        before: '<p></p>'
      });
      const controllerRef = jest.fn();
      const {
        editor,
        content
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
        defaultValue: value,
        controllerRef: controllerRef
      }));
      const controller = (0, _lodash.last)(controllerRef.mock.calls)[0];
      controller.command(_everCangjie.Commands.moveToRangeOfDocument);
      expect(content.getElementsByTagName('table').length).toBe(1);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('delete'));

      await (0, _react.wait)();
      expect(content.getElementsByTagName('table').length).toBe(0);
      expect(content.querySelector('*[data-type="paragraph"]').textContent).toBe('\uFEFF');
    });
    it('只有一个表格时，全选按 delete 可以正常删除', async () => {
      const value = (0, _helpers.createTable)([['A', 'B']]);
      const controllerRef = jest.fn();
      const {
        editor,
        content
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.default, {
        defaultValue: value,
        controllerRef: controllerRef
      }));
      const controller = (0, _lodash.last)(controllerRef.mock.calls)[0];
      controller.command(_everCangjie.Commands.moveToRangeOfDocument);
      expect(content.getElementsByTagName('table').length).toBe(1);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('delete'));

      await (0, _react.wait)();
      expect(content.getElementsByTagName('table').length).toBe(0);
      expect(content.querySelector('*[data-type="paragraph"]').textContent).toBe('\uFEFF');
    });
  });
});
//# sourceMappingURL=keyboard.test.js.map