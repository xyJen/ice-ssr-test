"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var fs = _interopRequireWildcard(require("fs"));

var path = _interopRequireWildcard(require("path"));

var _jestFileSnapshot = require("jest-file-snapshot");

var _everCangjie = require("@ali/4ever-cangjie");

var _everPluginClipboard = require("@ali/4ever-plugin-clipboard");

var _everMo = require("@ali/4ever-mo");

expect.extend({
  toMatchFile: _jestFileSnapshot.toMatchFile
});
describe('ccp', () => {
  describe('Paste normalize with strict schema', () => {
    const fixturesPath = path.join(__dirname, 'normalize');
    const fixtures = fs.readdirSync(fixturesPath);
    fixtures.forEach(fixture => {
      const fixturePath = path.join(fixturesPath, fixture);
      const inputPath = path.join(fixturePath, 'input.json');
      const outputPath = path.join(fixturePath, 'output.json');
      const input = fs.readFileSync(inputPath).toString();

      const fragment = _everCangjie.Document.fromJSON(JSON.parse(input));

      const fragmentNormalized = (0, _everPluginClipboard.filterAndNormalize)({
        fragment,
        schema: _everMo.strictSchema
      });
      const fragmentStr = JSON.stringify(fragmentNormalized.toJSON(), null, 2);
      it(fixture, () => {
        expect(fragmentStr).toMatchFile(outputPath);
      });
    });
  });
  describe('Paste normalize filter rules', () => {
    const fixturesPath = path.join(__dirname, 'filter');
    const fixtures = fs.readdirSync(fixturesPath);
    fixtures.forEach(fixture => {
      const fixturePath = path.join(fixturesPath, fixture);
      const inputPath = path.join(fixturePath, 'input.json');
      const outputPath = path.join(fixturePath, 'output.json');
      const rulePath = path.join(fixturePath, 'rules.json');
      const input = fs.readFileSync(inputPath).toString();
      const filterRule = JSON.parse(fs.readFileSync(rulePath).toString());

      const fragment = _everCangjie.Document.fromJSON(JSON.parse(input));

      const rules = {
        block: {},
        inline: {}
      };

      if (filterRule) {
        for (const blockType in filterRule) {
          const block = filterRule[blockType];

          for (const ruleType in block) {
            rules[blockType][ruleType] = new RegExp(block[ruleType]);
          }
        }
      }

      const fragmentNormalized = (0, _everPluginClipboard.filterAndNormalize)({
        fragment,
        rules,
        schema: _everMo.strictSchema
      });
      const fragmentStr = JSON.stringify(fragmentNormalized.toJSON(), null, 2);
      it(fixture, () => {
        expect(fragmentStr).toMatchFile(outputPath);
      });
    });
  });
});
//# sourceMappingURL=index.test.js.map