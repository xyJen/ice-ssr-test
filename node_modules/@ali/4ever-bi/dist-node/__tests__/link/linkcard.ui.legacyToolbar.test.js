"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("@testing-library/jest-dom/extend-expect");

var _react = require("@testing-library/react");

var _everDevTest = require("@ali/4ever-dev-test");

var _serializer = _interopRequireDefault(require("../serializer"));

var _everCangjie = require("@ali/4ever-cangjie");

var React = _interopRequireWildcard(require("react"));

var _link = _interopRequireDefault(require("../../plugins/link"));

var _ = require("../..");

var _zh_CN = _interopRequireDefault(require("../../locales/zh_CN"));

var _editor = require("../editor");

/* eslint-disable import/no-extraneous-dependencies */

/** @jsx jsx */
const createBiPlugins = (0, _.createCustomizedBiPlugins)({
  link: _link.default
});
const LOCALE = _zh_CN.default.link.locale;
const createRangeDescriptor = Object.getOwnPropertyDescriptor(document, 'createRange');
beforeAll(() => {
  Object.defineProperty(document, 'createRange', {
    configurable: true,

    value() {
      const range = createRangeDescriptor ? createRangeDescriptor.value() : {};
      return { ...range,

        getClientRects() {
          return [{
            width: 100,
            height: 60,
            top: 100,
            right: 200,
            left: 200,
            bottom: 400
          }];
        }

      };
    }

  });
});
afterAll(() => {
  Object.defineProperty(document, 'createRange', createRangeDescriptor || {
    value() {
      return {};
    }

  });
});

var _ref = (0, _everDevTest.jsx)("cursor", null);

const createTextLink = (text = 'DingTalk', href = 'https://www.dingtalk.com', prefix = ' ', suffix = ' ') => {
  const value = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
    type: "paragraph"
  }, prefix, (0, _everDevTest.jsx)("inline", {
    key: "link",
    type: "link",
    data: {
      href
    }
  }, text), suffix, _ref)));
  return value;
};

var _ref2 = (0, _everDevTest.jsx)("cursor", null);

const createLinkCard = (text = 'DingTalk', href = 'https://www.dingtalk.com', prefix = ' ', suffix = ' ') => {
  const value = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
    type: "paragraph"
  }, prefix, (0, _everDevTest.jsx)("inline", {
    key: "link",
    type: "link",
    data: {
      href,
      cardInfo: {
        displayType: 'card'
      }
    }
  }, text), suffix, _ref2)));
  return value;
};

var _ref3 = (0, _everDevTest.jsx)("cursor", null);

const createPureLink = (href = 'https://www.dingtalk.com', prefix = 'before', suffix = 'after') => {
  const value = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
    type: "paragraph"
  }, `${prefix} ${href} ${suffix}`, _ref3)));
  return value;
};

var _ref4 = (0, _everDevTest.jsx)(_.Content, {
  tabIndex: 0
});

const Editor = props => {
  const {
    defaultValue,
    linkConfig = {}
  } = props;
  const [value, setValue] = React.useState(defaultValue);
  const plugins = React.useMemo(() => {
    const config = {
      getLinkInfo: () => Promise.resolve({}),
      enableCard: true,
      hotkey: 'mod+k',
      locale: LOCALE,
      protocolAllowList: ['xxx:', 'http:', 'https:'],
      ...linkConfig
    };
    return createBiPlugins({
      link: config
    });
  }, [linkConfig]);
  const handleChange = React.useCallback(changed => {
    setValue(changed.value);
  }, []);
  return (0, _everDevTest.jsx)(_.Provider, {
    plugins: plugins,
    value: value,
    onChange: handleChange,
    autoFocus: true
  }, (0, _everDevTest.jsx)(_.Toolbar, {
    autoFolding: false,
    singleLayout: [{
      toolButtons: [{
        name: 'link'
      }]
    }]
  }), _ref4);
};

var _ref5 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
})));

var _ref6 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "12", (0, _everDevTest.jsx)("anchor", null), "34567", (0, _everDevTest.jsx)("focus", null), "890")));

var _ref15 = (0, _everDevTest.jsx)("cursor", null);

var _ref16 = (0, _everDevTest.jsx)("cursor", null);

var _ref17 = (0, _everDevTest.jsx)("anchor", null);

var _ref18 = (0, _everDevTest.jsx)("focus", null);

var _ref19 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
})));

var _ref22 = (0, _everDevTest.jsx)("anchor", null);

var _ref23 = (0, _everDevTest.jsx)("cursor", null);

var _ref24 = (0, _everDevTest.jsx)("cursor", null);

var _ref26 = (0, _everDevTest.jsx)("cursor", null);

var _ref27 = (0, _everDevTest.jsx)("cursor", null);

describe('bi/link/ui', () => {
  const openLink = jest.fn();
  let spiedWindowOpen;
  let spiedConsoleError;
  beforeAll(() => {
    // 防止被 componentDidCatch catch 的 error 被控制台输出
    spiedConsoleError = jest.spyOn(console, 'error');
    spiedConsoleError.mockImplementation(() => {});
    spiedWindowOpen = jest.spyOn(window, 'open');
    spiedWindowOpen.mockImplementation(openLink);
  });
  afterAll(() => {
    spiedConsoleError.mockRestore();
    spiedWindowOpen.mockRestore();
  });
  afterEach(() => {
    (0, _react.cleanup)();
    openLink.mockReset();
  });
  describe('插入链接', () => {
    const initValue = _ref5;
    const initValueWithSelection = _ref6;

    var _ref7 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: initValue
    });

    test('快捷键插入空链接后光标 focus 到「标题地址」中', async () => {
      const {
        queryByTestId,
        editor
      } = await (0, _everDevTest.renderEditor)(_ref7);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('mod+k'));

      const linkEditor = await (0, _react.waitForElement)(() => queryByTestId('link-editor')); // 插入空链接时，光标应该在标题地址中

      const {
        activeElement
      } = linkEditor.ownerDocument || {};
      expect(activeElement && activeElement.nodeName === 'INPUT' && activeElement.name === 'text').toBe(true);
    });

    var _ref8 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: initValue
    });

    test('工具栏插入空链接后光标 focus 到「标题地址」中', async () => {
      const {
        queryByTestId,
        container
      } = await (0, _everDevTest.renderEditor)(_ref8);
      const linkButton = container.querySelector('[data-testid="bi-toolbar-link"] > div');

      _everDevTest.fireEvent.click(linkButton);

      const linkEditor = await (0, _react.waitForElement)(() => queryByTestId('link-editor')); // 插入空链接时，光标应该在标题地址中

      const {
        activeElement
      } = linkEditor.ownerDocument || {};
      expect(activeElement && activeElement.nodeName === 'INPUT' && activeElement.name === 'text').toBe(true);
    });

    var _ref9 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: initValue
    });

    test('首次插入空链接，再次点击编辑器，光标回归编辑器', async () => {
      const {
        queryByTestId,
        editor
      } = await (0, _everDevTest.renderEditor)(_ref9);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('mod+k'));

      const link = await (0, _react.waitForElement)(() => queryByTestId('link'));
      await (0, _react.waitForElement)(() => queryByTestId('link-editor'));

      _everDevTest.fireEvent.click(editor);

      await (0, _react.waitForElement)(() => queryByTestId('link-editor'));
      const {
        activeElement
      } = link.ownerDocument || {};
      expect(activeElement && activeElement.nodeName === 'TEXTAREA').toBe(true);
    });

    var _ref10 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: initValue
    });

    test('首次插入空链接，再次点击链接，focus 到「标题地址」中', async () => {
      const {
        queryByTestId,
        editor
      } = await (0, _everDevTest.renderEditor)(_ref10);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('mod+k'));

      const link = await (0, _react.waitForElement)(() => queryByTestId('link'));
      await (0, _react.waitForElement)(() => queryByTestId('link-editor'));

      _everDevTest.fireEvent.click(link);

      await (0, _react.waitForElement)(() => queryByTestId('link-editor'));
      const {
        activeElement
      } = link.ownerDocument || {};
      expect(activeElement && activeElement.nodeName === 'INPUT' && activeElement.name === 'text').toBe(true);
    });

    var _ref11 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: initValue
    });

    test('快捷键插入链接', async () => {
      const {
        queryByTestId,
        editor
      } = await (0, _everDevTest.renderEditor)(_ref11);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('mod+k'));

      const link = await (0, _react.waitForElement)(() => queryByTestId('link'));
      expect(link?.textContent).toBe('添加网页链接');
    });

    var _ref12 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: initValueWithSelection
    });

    test('有选区状态下快捷键插入链接，光标 focus 到「链接地址」中', async () => {
      const {
        queryByTestId,
        editor
      } = await (0, _everDevTest.renderEditor)(_ref12);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('mod+k'));

      const linkEditor = await (0, _react.waitForElement)(() => queryByTestId('link-editor'));
      const {
        activeElement
      } = linkEditor.ownerDocument || {};
      expect(activeElement && activeElement.nodeName === 'INPUT' && activeElement.name === 'href').toBe(true);
    });

    var _ref13 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: initValue
    });

    test('工具栏插入链接', async () => {
      const {
        queryByTestId,
        container
      } = await (0, _everDevTest.renderEditor)(_ref13);
      const linkButton = container.querySelector('[data-testid="bi-toolbar-link"] > div');

      _everDevTest.fireEvent.click(linkButton);

      const link = await (0, _react.waitForElement)(() => queryByTestId('link'));
      expect(link?.textContent).toBe('添加网页链接');
    });

    var _ref14 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: initValueWithSelection
    });

    test('有选区状态下工具栏插入链接，光标 focus 到「链接地址」中', async () => {
      const {
        queryByTestId,
        container
      } = await (0, _everDevTest.renderEditor)(_ref14);
      const linkButton = container.querySelector('[data-testid="bi-toolbar-link"] > div');

      _everDevTest.fireEvent.click(linkButton);

      const linkEditor = await (0, _react.waitForElement)(() => queryByTestId('link-editor'));
      const {
        activeElement
      } = linkEditor.ownerDocument || {};
      expect(activeElement && activeElement.nodeName === 'INPUT' && activeElement.name === 'href').toBe(true);
    });
    test('自定义预置链接文案', async () => {
      const {
        queryByTestId,
        container
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: initValue,
        linkConfig: {
          locale: { ...LOCALE,
            addLinkPlaceholder: 'link'
          }
        }
      }));
      const linkButton = container.querySelector('[data-testid="bi-toolbar-link"] > div');

      _everDevTest.fireEvent.click(linkButton);

      const link = await (0, _react.waitForElement)(() => queryByTestId('link'));
      expect(link?.textContent).toBe('link');
    });
    test('不允许在链接中插入链接', async done => {
      const value = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "paragraph"
      }, (0, _everDevTest.jsx)("inline", {
        key: "link",
        type: "link",
        data: {
          href: 'https://www.dingtalk.com'
        }
      }, "Ding", _ref15, "Talk"))));
      const {
        editor,
        findByText
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: value
      }));

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('mod+k'));

      try {
        await findByText(/Ding链接Talk/, {}, {
          timeout: 1000
        });
      } catch (e) {
        done();
      }
    });
    test('光标 focus 在链接中时，工具栏链接按钮展示为取消链接', async () => {
      const value = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "paragraph"
      }, (0, _everDevTest.jsx)("inline", {
        key: "link",
        type: "link",
        data: {
          href: 'https://www.dingtalk.com'
        }
      }, "Ding", _ref16, "Talk"))));
      const {
        container
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: value
      }));
      const linkButton = container.querySelector('[data-testid="bi-toolbar-unlink"]'); // TODO @淼淼 需要修改单测

      expect(linkButton).toBeInTheDocument();
    });
    test('选中 image 时，工具栏链接按钮展示为正常链接', async () => {
      const value = _serializer.default.jsonMLToValue(['root', {}, ['p', ['img', {
        src: 'https://cn.bing.com/az/hprichbg/rb/TeslaCoil_EN-CN1604235004_1920x1080.jpg',
        width: 1920,
        height: 1080,
        opacity: 0.5,
        outline: {
          width: 1,
          type: 'solid',
          color: '#002060'
        },
        type: 'jpg'
      }]]]);

      const {
        container,
        content,
        findByTestId,
        editor
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.EditorWidthLegacyToolbar, {
        defaultValue: value
      }));
      let img = content.querySelector('[data-type="image"]');

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('control+A'));

      await _everCangjie.domUtils.getCaretDom(content);
      const linkButton = container.querySelector('.icon-button-layout > [data-testid="bi-toolbar-link_wrap"]');
      expect(linkButton.parentElement.hasAttribute('disabled')).toBeFalsy();
    });
    test('选中其他 inline 时，工具栏链接按钮展示为禁用', async () => {
      const value = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "paragraph"
      }, "11", _ref17, (0, _everDevTest.jsx)("inline", {
        type: "emoji",
        data: {
          code: 'smile'
        }
      }), _ref18, "22")));
      const {
        container,
        debug,
        content
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(_editor.EditorWidthLegacyToolbar, {
        defaultValue: value
      }));
      const linkButton = container.querySelector('.icon-button-layout > [data-testid="bi-toolbar-link_wrap"]');
      expect(linkButton.parentElement.hasAttribute('disabled')).toBeTruthy();
    });
  });
  describe('链接工具栏', () => {
    const blankValue = _ref19;
    test('点击链接后，弹出工具栏', async () => {
      const {
        queryByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createTextLink()
      }));
      const link = await (0, _react.waitFor)(() => queryByTestId('link'));

      _everDevTest.fireEvent.mouseDown(link);

      await (0, _react.waitFor)(() => queryByTestId('link-toolbar'));
    });
    test('focus 文档时，hover 链接，弹出工具栏', async () => {
      const {
        queryByTestId,
        queryByText,
        content
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createTextLink('DingTalk', 'https://www.dingtalk.com', 'aaa')
      }));
      const link = await (0, _react.waitFor)(() => queryByTestId('link'));
      const prefix = await (0, _react.waitFor)(() => queryByText('aaa'));

      _everDevTest.fireEvent.mouseDown(prefix);

      _everDevTest.fireEvent.mouseOver(link);

      await (0, _react.waitFor)(() => queryByTestId('link-toolbar'));
    });

    var _ref20 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: blankValue
    });

    test('创建链接时，弹出编辑框', async () => {
      const {
        queryByTestId,
        editor
      } = await (0, _everDevTest.renderEditor)(_ref20);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('mod+k'));

      await (0, _react.waitFor)(() => queryByTestId('link-editor'));
    });

    var _ref21 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: blankValue
    });

    test('插入占位链接，点击「取消链接」，空连接被删除', async () => {
      const {
        queryByTestId,
        editor,
        debug,
        content
      } = await (0, _everDevTest.renderEditor)(_ref21);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('mod+k'));

      await (0, _react.waitFor)(() => queryByTestId('link-editor'));
      const cancelButton = queryByTestId('link-editor-unlink');

      _everDevTest.fireEvent.mouseDown(cancelButton); // 空连接已删除


      await (0, _react.waitForElementToBeRemoved)(() => queryByTestId('link'));
    });
    test('扩展选区选中链接时，不弹出工具栏', async () => {
      const {
        queryByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createTextLink()
      }));
      expect(queryByTestId('link-toolbar')).not.toBeInTheDocument();
    });
    test('点击链接后，若地址为空，则直接弹出编辑框', async () => {
      const {
        queryByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createTextLink('baidu', '')
      }));
      const link = await (0, _react.waitFor)(() => queryByTestId('link'));

      _everDevTest.fireEvent.mouseDown(link);

      await (0, _react.waitFor)(() => queryByTestId('link-editor'));
    });
    test('点击 pure link 后，弹出工具栏', async () => {
      const {
        queryByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createPureLink()
      }));
      const link = await (0, _react.waitFor)(() => queryByTestId('pure-link'));

      _everDevTest.fireEvent.mouseDown(link);

      await (0, _react.waitFor)(() => queryByTestId('link-toolbar'));
    });
    test('mouseleave，关闭 toolbar，并 focus 回编辑器', async () => {
      const {
        queryByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createPureLink()
      }));
      const link = await (0, _react.waitFor)(() => queryByTestId('pure-link'));

      _everDevTest.fireEvent.mouseDown(link);

      await (0, _react.waitFor)(() => queryByTestId('link-toolbar'));

      _everDevTest.fireEvent.mouseLeave(link);

      expect(queryByTestId('link-toolbar')).not.toBeInTheDocument();
    });
    test('选中链接后复制，粘贴的卡片有标题', async () => {
      const value = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "paragraph"
      }, (0, _everDevTest.jsx)("inline", {
        key: "link",
        type: "link",
        data: {
          href: 'http://www.baidu.com',
          cardInfo: {
            displayType: 'card'
          }
        }
      }, 'dingtalk', _ref22), _ref23)));
      const {
        queryByTestId,
        editor
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: value
      }));
      const setData = jest.fn();
      const link = await (0, _react.waitFor)(() => queryByTestId('link-card'));

      _everDevTest.fireEvent.click(link);

      _everDevTest.fireEvent.copy(editor, {
        nativeEvent: {
          clipboardData: {
            setData
          },

          preventDefault() {}

        }
      });

      const fragment = _everCangjie.transferUtils.decodeFragment(setData.mock.calls[0][1]);

      const fragmentString = JSON.stringify(fragment); // 从 fragment 的字符串中找到 text 节点的内容

      const isContainsTitle = fragmentString.indexOf('dingtalk') > 0;
      expect(isContainsTitle).toEqual(true);
    });
  });
  describe('链接占位符', () => {
    const value = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
      type: "paragraph"
    }, (0, _everDevTest.jsx)("inline", {
      key: "link",
      type: "link",
      data: {
        href: ''
      }
    }, LOCALE.addLinkPlaceholder), _ref24)));

    var _ref25 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: value
    });

    test('移动光标进入链接占位符，弹出编辑框；点击 esc，光标移出占位符', async () => {
      const {
        queryByTestId,
        editor,
        debug,
        container
      } = await (0, _everDevTest.renderEditor)(_ref25);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('arrowleft'));

      await (0, _react.waitFor)(() => queryByTestId('link-editor')); // 插入空链接时，光标应该在标题地址中

      let input = await (0, _react.waitFor)(() => queryByTestId('link-editor-input-text'));
      expect(input).toHaveFocus(); // 第一次 esc 输入框失去光标

      _everDevTest.fireEvent.keyDown(queryByTestId('link-editor'), (0, _everDevTest.getHotkeyEvent)('esc')); // 第二次 esc 编辑框消失


      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('esc'));

      await (0, _react.waitForElementToBeRemoved)(() => queryByTestId('link-editor')); // 选区渲染不在 node 中了，所以无需再 check
      // await waitFor(() => queryByTestId('cangjie-caret'));
      // expect(container.querySelector('[data-testid="link"] [data-testid="cangjie-caret"]')).toBeNull();
    });
  });
  describe('删除链接', () => {
    test('向前删除', async () => {
      const value = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "paragraph"
      }, (0, _everDevTest.jsx)("inline", {
        key: "link",
        type: "link",
        data: {
          href: 'https://www.dingtalk/com',
          cardInfo: {
            title: 'baidu',
            displayType: 'card'
          }
        }
      }, "DingTalk"), _ref26)));
      const {
        queryByTestId,
        editor
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: value
      }));
      await (0, _react.waitForElement)(() => queryByTestId('link-card'));

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)(_everDevTest.HOTKEYS.deleteBackward));

      await (0, _react.waitForElementToBeRemoved)(() => queryByTestId('link-card'));
    });
    test('向后删除', async () => {
      const value = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "paragraph"
      }, _ref27, (0, _everDevTest.jsx)("inline", {
        key: "link",
        type: "link",
        data: {
          href: 'https://www.dingtalk/com',
          cardInfo: {
            title: 'baidu',
            displayType: 'card'
          }
        }
      }, "DingTalk"))));
      const {
        queryByTestId,
        editor
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: value
      }));
      await (0, _react.waitForElement)(() => queryByTestId('link-card'));

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)(_everDevTest.HOTKEYS.deleteForward));

      await (0, _react.waitForElementToBeRemoved)(() => queryByTestId('link-card'));
    });
  });
});
//# sourceMappingURL=linkcard.ui.legacyToolbar.test.js.map