"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

require("@testing-library/jest-dom/extend-expect");

var _react = require("@testing-library/react");

var _everDevTest = require("@ali/4ever-dev-test");

var _everCangjie = require("@ali/4ever-cangjie");

var React = _interopRequireWildcard(require("react"));

var _link = _interopRequireDefault(require("../../plugins/link"));

var _ = require("../..");

var _zh_CN = _interopRequireDefault(require("../../locales/zh_CN"));

var _weDesignNext = require("@ali/we-design-next");

var _everMo = require("@ali/4ever-mo");

/* eslint-disable import/no-extraneous-dependencies */

/** @jsx jsx */
let origin_value;
beforeAll(() => {
  origin_value = process.env.RUNTIME_ENV;
  process.env.RUNTIME_ENV = _weDesignNext.ToolbarLayout.UITEST_FLAG;
});
afterAll(() => {
  process.env.RUNTIME_ENV = origin_value;
});
const createBiPlugins = (0, _.createCustomizedBiPlugins)({
  link: _link.default
});
const LOCALE = _zh_CN.default.link.locale;
const createRangeDescriptor = Object.getOwnPropertyDescriptor(document, 'createRange');
beforeAll(() => {
  Object.defineProperty(document, 'createRange', {
    configurable: true,

    value() {
      const range = createRangeDescriptor ? createRangeDescriptor.value() : {};
      return { ...range,

        getClientRects() {
          return [{
            width: 100,
            height: 60,
            top: 100,
            right: 200,
            left: 200,
            bottom: 400
          }];
        }

      };
    }

  });
});
afterAll(() => {
  Object.defineProperty(document, 'createRange', createRangeDescriptor || {
    value() {
      return {};
    }

  });
});

var _ref = (0, _everDevTest.jsx)("cursor", null);

const createTextLink = (text = 'DingTalk', href = 'https://www.dingtalk.com', prefix = ' ', suffix = ' ') => {
  const value = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
    type: "paragraph"
  }, prefix, (0, _everDevTest.jsx)("inline", {
    key: "link",
    type: "link",
    data: {
      href
    }
  }, text), suffix, _ref)));
  return value;
};

var _ref2 = (0, _everDevTest.jsx)("cursor", null);

const createPureLink = (href = 'https://www.dingtalk.com', prefix = 'before', suffix = 'after') => {
  const value = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
    type: "paragraph"
  }, `${prefix} ${href} ${suffix}`, _ref2)));
  return value;
};

var _ref3 = (0, _everDevTest.jsx)(_.Content, {
  tabIndex: 0
});

const Editor = props => {
  const {
    defaultValue,
    linkConfig = {},
    controllerRef
  } = props;
  const [value, setValue] = React.useState(defaultValue);
  const plugins = React.useMemo(() => {
    const config = {
      hotkey: 'mod+k',
      locale: LOCALE,
      protocolAllowList: ['xxx:', 'http:', 'https:'],
      ...linkConfig
    };
    return createBiPlugins({
      link: config,
      clipboard: {
        pastePanel: true
      }
    });
  }, [linkConfig]);
  const handleChange = React.useCallback(changed => {
    setValue(changed.value);
  }, []);
  return (0, _everDevTest.jsx)(_.Provider, {
    controllerRef: controllerRef,
    plugins: plugins,
    value: value,
    onChange: handleChange,
    autoFocus: true
  }, (0, _everDevTest.jsx)(_.HeadingToolbar, {
    singleLayout: [{
      items: [{
        name: 'link'
      }]
    }]
  }), _ref3);
};

var _ref4 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
})));

var _ref5 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "12", (0, _everDevTest.jsx)("anchor", null), "34567", (0, _everDevTest.jsx)("focus", null), "890")));

var _ref14 = (0, _everDevTest.jsx)("cursor", null);

var _ref15 = (0, _everDevTest.jsx)("cursor", null);

var _ref16 = (0, _everDevTest.jsx)("cursor", null);

var _ref17 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
})));

var _ref19 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("anchor", null)), ">", (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "12"), ">"));

var _ref20 = (0, _everDevTest.jsx)("cursor", null);

var _ref21 = (0, _everDevTest.jsx)("cursor", null);

var _ref22 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "https://www.dingtalk.com", (0, _everDevTest.jsx)("cursor", null))));

var _ref23 = (0, _everDevTest.jsx)("cursor", null);

var _ref24 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
})));

var _ref25 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "before https://www.ding", (0, _everDevTest.jsx)("cursor", null), "talk.com after")));

var _ref26 = (0, _everDevTest.jsx)("cursor", null);

var _ref27 = (0, _everDevTest.jsx)("cursor", null);

var _ref28 = (0, _everDevTest.jsx)("cursor", null);

var _ref29 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
})));

var _ref32 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("anchor", null), "\u9489\u9489", (0, _everDevTest.jsx)("focus", null))));

var _ref33 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("anchor", null), "\u9489\u9489", (0, _everDevTest.jsx)("focus", null))));

var _ref34 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("anchor", null), "https://www.dingtalk.com", (0, _everDevTest.jsx)("focus", null))));

var _ref36 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
})));

var _ref39 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "\u6D4B\u8BD5\u6D4B\u8BD5\u6D4B\u8BD5\u6D4B\uFF0C\u8BD5\u6D4B\u8BD5\u6D4B\u8BD5\u6D4B", (0, _everDevTest.jsx)("cursor", null), "\u8BD5\u6D4B\u8BD5\u6D4B\u8BD5\u6D4B\u8BD5\u6D4B\uFF0C\u8BD5\u6D4B\u8BD5\u6D4B\u8BD5\u6D4B\u8BD5\u6D4B\u8BD5")));

var _ref43 = (0, _everDevTest.jsx)("cursor", null);

describe('Bi/link/ui', () => {
  const openLink = jest.fn();
  let spiedWindowOpen;
  let spiedConsoleError;
  beforeAll(() => {
    // 防止被 componentDidCatch catch 的 error 被控制台输出
    spiedConsoleError = jest.spyOn(console, 'error');
    spiedConsoleError.mockImplementation(() => {});
    spiedWindowOpen = jest.spyOn(window, 'open');
    spiedWindowOpen.mockImplementation(openLink);
  });
  afterAll(() => {
    spiedConsoleError.mockRestore();
    spiedWindowOpen.mockRestore();
  });
  afterEach(() => {
    (0, _react.cleanup)();
    openLink.mockReset();
  });
  describe('插入链接', () => {
    const initValue = _ref4;
    const initValueWithSelection = _ref5;

    var _ref6 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: initValue
    });

    test('快捷键插入空链接后光标 focus 到「标题地址」中', async () => {
      const {
        queryByTestId,
        editor
      } = await (0, _everDevTest.renderEditor)(_ref6);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('mod+k'));

      const linkEditor = await (0, _react.waitForElement)(() => queryByTestId('link-editor')); // 插入空链接时，光标应该在标题地址中

      const input = await (0, _react.waitForElement)(() => queryByTestId('link-editor-input-text'));
      expect(input).toHaveFocus();
    });

    var _ref7 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: initValue
    });

    test('工具栏插入空链接后光标 focus 到「标题地址」中', async () => {
      const {
        queryByTestId,
        container
      } = await (0, _everDevTest.renderEditor)(_ref7);
      const linkButton = container.querySelector('[data-testid="bi-toolbar-link"] > div');

      _everDevTest.fireEvent.click(linkButton);

      const linkEditor = await (0, _react.waitForElement)(() => queryByTestId('link-editor')); // 插入空链接时，光标应该在标题地址中

      const input = await (0, _react.waitForElement)(() => queryByTestId('link-editor-input-text'));
      expect(input).toHaveFocus();
    });

    var _ref8 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: initValue
    });

    test('首次插入空链接，再次点击编辑器，光标回归编辑器', async () => {
      const {
        queryByTestId,
        editor
      } = await (0, _everDevTest.renderEditor)(_ref8);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('mod+k'));

      const link = await (0, _react.waitForElement)(() => queryByTestId('link'));
      await (0, _react.waitForElement)(() => queryByTestId('link-editor'));

      _everDevTest.fireEvent.click(editor);

      await (0, _react.waitForElement)(() => queryByTestId('link-editor'));
      const {
        activeElement
      } = link.ownerDocument || {};
      expect(activeElement && activeElement.nodeName === 'TEXTAREA').toBe(true);
    });

    var _ref9 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: initValue
    });

    test('首次插入空链接，再次点击链接，光标focus 到「标题地址」中', async () => {
      const {
        queryByTestId,
        editor
      } = await (0, _everDevTest.renderEditor)(_ref9);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('mod+k'));

      const link = await (0, _react.waitForElement)(() => queryByTestId('link'));
      await (0, _react.waitForElement)(() => queryByTestId('link-editor'));

      _everDevTest.fireEvent.click(link);

      await (0, _react.waitForElement)(() => queryByTestId('link-editor'));
      const {
        activeElement
      } = link.ownerDocument || {};
      const input = await (0, _react.waitForElement)(() => queryByTestId('link-editor-input-text'));
      expect(input).toHaveFocus();
    });

    var _ref10 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: initValue
    });

    test('快捷键插入链接', async () => {
      const {
        queryByTestId,
        editor
      } = await (0, _everDevTest.renderEditor)(_ref10);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('mod+k'));

      const link = await (0, _react.waitForElement)(() => queryByTestId('link'));
      expect(link?.textContent).toBe('添加网页链接');
    });

    var _ref11 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: initValueWithSelection
    });

    test('有选区状态下快捷键插入链接，光标 focus 到「链接地址」中', async () => {
      const {
        queryByTestId,
        editor
      } = await (0, _everDevTest.renderEditor)(_ref11);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('mod+k'));

      const linkEditor = await (0, _react.waitForElement)(() => queryByTestId('link-editor'));
      const {
        activeElement
      } = linkEditor.ownerDocument || {};
      expect(activeElement && activeElement.nodeName === 'INPUT' && activeElement.name === 'href').toBe(true);
    });

    var _ref12 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: initValue
    });

    test('工具栏插入链接', async () => {
      const {
        queryByTestId,
        container
      } = await (0, _everDevTest.renderEditor)(_ref12);
      const linkButton = container.querySelector('[data-testid="bi-toolbar-link"] > div');

      _everDevTest.fireEvent.click(linkButton);

      const link = await (0, _react.waitForElement)(() => queryByTestId('link'));
      expect(link?.textContent).toBe('添加网页链接');
    });

    var _ref13 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: initValueWithSelection
    });

    test('有选区状态下工具栏插入链接，光标 focus 到「链接地址」中', async () => {
      const {
        queryByTestId,
        container
      } = await (0, _everDevTest.renderEditor)(_ref13);
      const linkButton = container.querySelector('[data-testid="bi-toolbar-link"] > div');

      _everDevTest.fireEvent.click(linkButton);

      const linkEditor = await (0, _react.waitForElement)(() => queryByTestId('link-editor'));
      const {
        activeElement
      } = linkEditor.ownerDocument || {};
      expect(activeElement && activeElement.nodeName === 'INPUT' && activeElement.name === 'href').toBe(true);
    });
    test('自定义预置链接文案', async () => {
      const {
        queryByTestId,
        container
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: initValue,
        linkConfig: {
          locale: { ...LOCALE,
            addLinkPlaceholder: 'link'
          }
        }
      }));
      const linkButton = container.querySelector('[data-testid="bi-toolbar-link"] > div');

      _everDevTest.fireEvent.click(linkButton);

      const link = await (0, _react.waitForElement)(() => queryByTestId('link'));
      expect(link?.textContent).toBe('link');
    });
    test('不允许在链接中插入链接', async () => {
      const value = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "paragraph"
      }, (0, _everDevTest.jsx)("inline", {
        key: "link",
        type: "link",
        data: {
          href: 'https://www.dingtalk.com'
        }
      }, "Ding", _ref14, "Talk"))));
      const {
        editor,
        queryByText
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: value
      }));

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('mod+k'));

      await (0, _everDevTest.waitForTime)(200);
      expect(queryByText(/Ding添加网页链接Talk/)).not.toBeInTheDocument();
    });
    test('光标 focus 在链接中时，工具栏链接按钮展示为取消链接', async () => {
      const value = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "paragraph"
      }, (0, _everDevTest.jsx)("inline", {
        key: "link",
        type: "link",
        data: {
          href: 'https://www.dingtalk.com'
        }
      }, "Ding", _ref15, "Talk"))));
      const {
        container
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: value
      }));
      const linkButton = container.querySelector('[data-testid="bi-toolbar-unlink"]'); // TODO @淼淼 需要修改单测

      expect(linkButton).toBeInTheDocument();
    });
  });
  test('光标 focus 在 text = href 的链接中，执行取消链接', async () => {
    const value = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
      type: "paragraph"
    }, (0, _everDevTest.jsx)("inline", {
      key: "link",
      type: "link",
      data: {
        href: 'https://www.dingtalk.com'
      }
    }, "https://www.dingtalk.com"), _ref16)));
    const {
      editor,
      findByTestId,
      queryByTestId,
      content
    } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
      defaultValue: value
    }));
    const link = await (0, _react.waitFor)(() => queryByTestId('link'));

    _everDevTest.fireEvent.mouseOver(link);

    const unlinkButton = await findByTestId('link-toolbar-unlink');

    _everDevTest.fireEvent.mouseDown(unlinkButton);

    await (0, _react.waitForElementToBeRemoved)(() => queryByTestId('link'));
    expect(!queryByTestId('pure-link')).toBe(true);
    expect(content?.textContent).toBe('https://www.dingtalk.com');
  });
  describe('链接工具栏', () => {
    const blankValue = _ref17;
    test('hover 链接后，弹出工具栏', async () => {
      const {
        queryByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createTextLink()
      }));
      const link = await (0, _react.waitForElement)(() => queryByTestId('link'));

      _everDevTest.fireEvent.mouseOver(link);

      await (0, _react.waitForElement)(() => queryByTestId('link-toolbar'));
    });
    test('点击链接后，跳转页面', async () => {
      const {
        findByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createTextLink()
      }));
      const link = await findByTestId('link');

      _everDevTest.fireEvent.click(link);

      expect(openLink).toBeCalledWith('https://www.dingtalk.com');
    });
    test('点击链接后无 schema link，跳转页面', async () => {
      const {
        findByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createTextLink('test', 'www.dingtalk.com')
      }));
      const link = await findByTestId('link');

      _everDevTest.fireEvent.click(link);

      expect(openLink).toBeCalledWith('http://www.dingtalk.com');
    });
    test('编辑状态下，点击链接不跳转', async () => {
      const {
        findByTestId,
        queryByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createTextLink()
      }));
      let link = await findByTestId('link');

      _everDevTest.fireEvent.mouseOver(link);

      await findByTestId('link-toolbar');
      const edit = queryByTestId('link-toolbar-edit');

      _everDevTest.fireEvent.mouseDown(edit);

      await findByTestId('link-editor'); // 点击链接

      link = await findByTestId('link');

      _everDevTest.fireEvent.click(link);

      expect(openLink).not.toBeCalled();
    });

    var _ref18 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: blankValue
    });

    test('创建链接时，弹出编辑框', async () => {
      const {
        queryByTestId,
        editor
      } = await (0, _everDevTest.renderEditor)(_ref18);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('mod+k'));

      await (0, _react.waitForElement)(() => queryByTestId('link-editor'));
    });
    test('创建链接后，快速移动光标至占位符，编辑框弹出', async () => {
      const {
        queryByTestId,
        editor,
        findByText
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: _ref19
      }));

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('mod+k'));

      await (0, _react.waitFor)(() => queryByTestId('link-editor')); // 通过点击下一个 block 的内容，然后再利用键盘移动光标至占位符，能够呼出编辑框

      const text = await findByText('12');

      _everDevTest.fireEvent.mouseDown(text);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('arrowup'));

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('arrowright'));

      await (0, _react.waitFor)(() => queryByTestId('link-editor'));
    });
    test('扩展选区选中链接时，不弹出工具栏', async () => {
      const {
        queryByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createTextLink()
      }));
      expect(queryByTestId('link-toolbar')).not.toBeInTheDocument();
    });
    test('点击链接后，若地址为空，则直接弹出编辑框', async () => {
      const {
        queryByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createTextLink('baidu', '')
      }));
      const link = await (0, _react.waitForElement)(() => queryByTestId('link'));

      _everDevTest.fireEvent.mouseDown(link);

      await (0, _react.waitForElement)(() => queryByTestId('link-editor'));
    });
    test('光标在同一行时，点击链接后，若地址为空，则直接弹出编辑框', async () => {
      const {
        findByText,
        findByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createTextLink('baidu', '', 'aaa')
      }));
      const prefixText = await findByText('aaa');

      _everDevTest.fireEvent.mouseDown(prefixText);

      const link = await findByTestId('link');

      _everDevTest.fireEvent.mouseDown(link);

      await findByTestId('link-editor');
    });
    test('点击 pure link 后，弹出工具栏', async () => {
      const {
        queryByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createPureLink()
      }));
      const link = await (0, _react.waitForElement)(() => queryByTestId('pure-link'));

      _everDevTest.fireEvent.mouseOver(link);

      await (0, _react.waitForElement)(() => queryByTestId('link-toolbar'));
    });
    test('删除文本链接', async () => {
      const value = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "paragraph"
      }, (0, _everDevTest.jsx)("inline", {
        key: "link",
        type: "link",
        data: {
          href: 'https://www.dingtalk.com'
        }
      }, "Ding", _ref20, "Talk"))));
      const {
        queryByText,
        queryByTestId,
        findByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: value
      }));
      const link = await findByTestId('link');

      _everDevTest.fireEvent.mouseOver(link);

      await findByTestId('link-toolbar');
      const remove = queryByTestId('link-toolbar-remove');

      _everDevTest.fireEvent.mouseDown(remove);

      await (0, _react.waitForElementToBeRemoved)(() => queryByTestId('link'));
      expect(queryByText(/DingTalk/)).not.toBeInTheDocument();
    });
    test('删除 pure link', async () => {
      const {
        content,
        queryByTestId,
        findByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createPureLink()
      }));
      const link = await findByTestId('pure-link');

      _everDevTest.fireEvent.mouseOver(link);

      await findByTestId('link-toolbar');
      const remove = queryByTestId('link-toolbar-remove');

      _everDevTest.fireEvent.mouseDown(remove);

      await (0, _react.waitForElementToBeRemoved)(() => queryByTestId('pure-link'));
      expect(content?.textContent).toBe('before  after');
    });
    test('取消文本链接', async () => {
      const value = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "paragraph"
      }, (0, _everDevTest.jsx)("inline", {
        key: "link",
        type: "link",
        data: {
          href: 'https://www.dingtalk.com'
        }
      }, "Di", _ref21, "ngTalk"))));
      const {
        queryByTestId,
        content
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: value
      }));
      const link = await (0, _react.waitForElement)(() => queryByTestId('link'));

      _everDevTest.fireEvent.mouseOver(link);

      await (0, _react.waitForElement)(() => queryByTestId('link-toolbar'));
      const unlink = queryByTestId('link-toolbar-unlink');

      _everDevTest.fireEvent.mouseDown(unlink);

      await (0, _react.waitForElementToBeRemoved)(() => queryByTestId('link'));
      expect(content?.textContent).toBe('DingTalk');
    });
    test('取消 pure link', async () => {
      const {
        content,
        queryByTestId,
        findByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createPureLink()
      }));
      const link = await findByTestId('pure-link');

      _everDevTest.fireEvent.mouseOver(link);

      await findByTestId('link-toolbar');
      const unlink = queryByTestId('link-toolbar-unlink');

      _everDevTest.fireEvent.mouseDown(unlink);

      await (0, _react.waitForElementToBeRemoved)(() => queryByTestId('pure-link'));
      expect(content?.textContent).toBe('before https://www.dingtalk.com after');
    });
    test('存在多个 pure link 时，取消 pure link', async () => {
      const {
        content,
        queryByTestId,
        findByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createPureLink()
      }));
      const link = await findByTestId('pure-link');

      _everDevTest.fireEvent.mouseOver(link);

      await findByTestId('link-toolbar');
      const unlink = queryByTestId('link-toolbar-unlink');

      _everDevTest.fireEvent.mouseDown(unlink);

      await (0, _react.waitForElementToBeRemoved)(() => queryByTestId('pure-link'));
      expect(content?.textContent).toBe('before https://www.dingtalk.com after');
    });
    test('取消 pure link 时，若光标已经在文本末尾，则插入空格', async () => {
      const value = _ref22;
      const {
        content,
        queryByTestId,
        findByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: value
      }));
      const link = await findByTestId('pure-link');

      _everDevTest.fireEvent.mouseOver(link);

      await findByTestId('link-toolbar');
      const unlink = queryByTestId('link-toolbar-unlink');

      _everDevTest.fireEvent.mouseDown(unlink);

      await (0, _react.waitForElementToBeRemoved)(() => queryByTestId('pure-link'));
      expect(content?.textContent).toBe('https://www.dingtalk.com ');
    });
    test('存在多个 pure link 时，取消 pure link', async () => {
      const {
        content,
        queryByTestId,
        findByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createPureLink()
      }));
      const link = await findByTestId('pure-link');

      _everDevTest.fireEvent.mouseOver(link);

      await findByTestId('link-toolbar');
      const unlink = queryByTestId('link-toolbar-unlink');

      _everDevTest.fireEvent.mouseDown(unlink);

      await (0, _react.waitForElementToBeRemoved)(() => queryByTestId('pure-link'));
      expect(content?.textContent).toBe('before https://www.dingtalk.com after');
    });
    test('访问链接', async () => {
      const {
        queryByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createPureLink()
      }));
      const link = await (0, _react.waitForElement)(() => queryByTestId('pure-link'));

      _everDevTest.fireEvent.mouseOver(link);

      await (0, _react.waitForElement)(() => queryByTestId('link-toolbar'));
      const visit = queryByTestId('link-toolbar-visit');

      _everDevTest.fireEvent.mouseDown(visit);

      expect(openLink).toBeCalledWith('https://www.dingtalk.com');
    });
    test('支持访问白名单', async () => {
      const {
        queryByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createPureLink('http://www.dingtalk.com'),
        linkConfig: {
          protocolAllowList: ['https:']
        }
      }));
      const link = await (0, _react.waitForElement)(() => queryByTestId('pure-link'));

      _everDevTest.fireEvent.mouseOver(link);

      await (0, _react.waitForElement)(() => queryByTestId('link-toolbar'));
      const visit = queryByTestId('link-toolbar-visit');

      _everDevTest.fireEvent.mouseDown(visit);

      expect(openLink).toBeCalledWith('');
    });
    test('进入编辑', async () => {
      const {
        queryByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createPureLink()
      }));
      const link = await (0, _react.waitForElement)(() => queryByTestId('pure-link'));

      _everDevTest.fireEvent.mouseOver(link);

      await (0, _react.waitForElement)(() => queryByTestId('link-toolbar'));
      const edit = queryByTestId('link-toolbar-edit');

      _everDevTest.fireEvent.mouseDown(edit);

      await (0, _react.waitForElement)(() => queryByTestId('link-editor'));
    });
    test('mouseleave，关闭 toolbar，并 focus 回编辑器', async () => {
      const {
        queryByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createPureLink()
      }));
      const link = await (0, _react.waitForElement)(() => queryByTestId('pure-link'));

      _everDevTest.fireEvent.mouseEnter(link);

      await (0, _react.waitForElement)(() => queryByTestId('link-toolbar'));

      _everDevTest.fireEvent.mouseLeave(link);

      await (0, _react.waitForElementToBeRemoved)(() => queryByTestId('link-toolbar'));
      expect(queryByTestId('link-toolbar')).not.toBeInTheDocument();
    });
    test('复制链接', async () => {
      const onLinkCopied = jest.fn();
      const {
        queryByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createPureLink(),
        linkConfig: {
          onCopyLink: onLinkCopied
        }
      }));
      const link = await (0, _react.waitForElement)(() => queryByTestId('pure-link'));

      _everDevTest.fireEvent.mouseOver(link);

      await (0, _react.waitForElement)(() => queryByTestId('link-toolbar'));
      const copy = queryByTestId('link-toolbar-copy');

      _everDevTest.fireEvent.mouseDown(copy);

      expect(onLinkCopied).toBeCalledWith('https://www.dingtalk.com');
    });
  }); // 编辑框已经去除删除按键，不需要测试删除功能

  describe('编辑链接', () => {
    const getEditForm = async (link, queryByTestId) => {
      _everDevTest.fireEvent.mouseOver(link);

      const edit = await (0, _react.waitForElement)(() => queryByTestId('link-toolbar-edit'));

      _everDevTest.fireEvent.mouseDown(edit);

      const form = await (0, _react.waitForElement)(() => queryByTestId('link-editor'));
      return form;
    };

    test('编辑链接信息并保存', async () => {
      const {
        queryByTestId,
        queryByText
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createTextLink()
      }));
      let link = await (0, _react.waitForElement)(() => queryByTestId('link'));
      const form = await getEditForm(link, queryByTestId);
      const textInput = form.querySelector('[name="text"]');
      const hrefInput = form.querySelector('[name="href"]');
      const saveButton = queryByTestId('link-editor-save');

      _everDevTest.fireEvent.inputChange(textInput, '谷歌');

      _everDevTest.fireEvent.inputChange(hrefInput, 'https://www.google.com');

      _everDevTest.fireEvent.mouseDown(saveButton);

      await (0, _react.waitForElementToBeRemoved)(() => queryByTestId('link-editor'));
      link = queryByTestId('link');
      expect(link?.textContent).toBe('谷歌');

      _everDevTest.fireEvent.mouseEnter(link);

      await (0, _react.waitForElement)(() => queryByTestId('link-toolbar'));
    });
    test('按下 ESC 时，关闭编辑框', async () => {
      const {
        queryByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createPureLink()
      }));
      const link = await (0, _react.waitForElement)(() => queryByTestId('pure-link'));
      await getEditForm(link, queryByTestId);

      _everDevTest.fireEvent.keyDown(queryByTestId('link-editor'), (0, _everDevTest.getHotkeyEvent)('esc'));

      await (0, _react.waitForElementToBeRemoved)(() => queryByTestId('link-editor'));
      expect(queryByTestId('link-editor')).not.toBeInTheDocument();
    });
    test('在链接末尾时按下 ESC 后，关闭编辑框，继续输入，以纯文本进行输入', async () => {
      const value = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "paragraph"
      }, (0, _everDevTest.jsx)("inline", {
        key: "link",
        type: "link",
        data: {
          href: 'https://www.dingtalk.com'
        }
      }, "DingTalk", _ref23))));
      const {
        queryByTestId,
        editor,
        getContentText
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: value
      }));
      const link = await (0, _react.waitForElement)(() => queryByTestId('link'));
      await getEditForm(link, queryByTestId);

      _everDevTest.fireEvent.keyDown(queryByTestId('link-editor'), (0, _everDevTest.getHotkeyEvent)('esc'));

      await (0, _react.waitForElementToBeRemoved)(() => queryByTestId('link-editor'));
      expect(queryByTestId('link-editor')).not.toBeInTheDocument();

      _everDevTest.fireEvent.cangjieInput(editor, {
        data: '!'
      });

      await (0, _react.wait)();
      expect(getContentText()).toBe('DingTalk!');
      expect(link.textContent).toBe('DingTalk');
    });
    test('编辑链接信息，若 focus 在输入框，则回车后可保存', async () => {
      const {
        queryByTestId,
        queryByText,
        findByText
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createTextLink()
      }));
      let link = await (0, _react.waitForElement)(() => queryByTestId('link'));
      const form = await getEditForm(link, queryByTestId);
      const textInput = form.querySelector('[name="text"]');
      const hrefInput = form.querySelector('[name="href"]');

      _everDevTest.fireEvent.inputChange(textInput, '谷歌');

      _everDevTest.fireEvent.inputChange(hrefInput, 'https://www.google.com');

      _everDevTest.fireEvent.focus(textInput);

      _everDevTest.fireEvent.keyDown(queryByTestId('link-editor'), (0, _everDevTest.getHotkeyEvent)('enter'));

      await (0, _react.waitForElementToBeRemoved)(() => queryByTestId('link-editor'));
      link = queryByTestId('link');
      expect(link?.textContent).toBe('谷歌');

      _everDevTest.fireEvent.mouseEnter(link);

      await findByText('https://www.google.com'); // await waitForElement(() => queryByTestId('link-toolbar'));
      // expect(queryByText('https://www.google.com')).toBeInTheDocument();
    });
    test('若文本为空，则转换为纯文本', async () => {
      const {
        queryByTestId,
        content
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createTextLink('baidu', 'https://www.baidu.com', '', '')
      }));
      const link = await (0, _react.waitForElement)(() => queryByTestId('link'));
      const form = await getEditForm(link, queryByTestId);
      const textInput = form.querySelector('[name="text"]');
      const hrefInput = form.querySelector('[name="href"]');
      const saveButton = queryByTestId('link-editor-save');

      _everDevTest.fireEvent.inputChange(textInput, '');

      _everDevTest.fireEvent.inputChange(hrefInput, 'https://www.baidu.com');

      _everDevTest.fireEvent.mouseDown(saveButton);

      const link2 = await (0, _react.waitFor)(() => queryByTestId('link'));
      expect(link2?.textContent).toBe('https://www.baidu.com');
    });
    test('若待编辑链接文本内容与链接地址一致，则编辑框只初始化链接', async () => {
      const {
        queryByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createTextLink('https://www.baidu.com', 'https://www.baidu.com')
      }));
      const link = await (0, _react.waitForElement)(() => queryByTestId('link'));
      const form = await getEditForm(link, queryByTestId);
      const textInput = form.querySelector('[name="text"]');
      const hrefInput = form.querySelector('[name="href"]');
      expect(textInput.value).toBe('');
      expect(hrefInput.value).toBe('https://www.baidu.com');
    });
    test('若文本及链接都为空，则忽略此次编辑', async () => {
      const value = _ref24;
      const {
        queryByTestId,
        editor
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: value
      }));

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('mod+k'));

      const link = await (0, _react.waitForElement)(() => queryByTestId('link'));

      _everDevTest.fireEvent.mouseDown(link);

      const form = await (0, _react.waitForElement)(() => queryByTestId('link-editor'));
      const textInput = form.querySelector('[name="text"]');
      const hrefInput = form.querySelector('[name="href"]');
      const saveButton = queryByTestId('link-editor-save');

      _everDevTest.fireEvent.inputChange(textInput, '');

      _everDevTest.fireEvent.inputChange(hrefInput, ' ');

      _everDevTest.fireEvent.mouseDown(saveButton);

      expect(queryByTestId('link')?.textContent).toBe('添加网页链接');
    });
    test('pure link 保存后，若文本不为空，转换为 text link', async () => {
      const value = _ref25;
      const {
        queryByTestId,
        content,
        debug
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: value
      }));
      const link = await (0, _react.waitForElement)(() => queryByTestId('pure-link'));
      const form = await getEditForm(link, queryByTestId);
      const textInput = form.querySelector('[name="text"]');
      const hrefInput = form.querySelector('[name="href"]');
      const saveButton = queryByTestId('link-editor-save');

      _everDevTest.fireEvent.inputChange(textInput, '钉钉');

      _everDevTest.fireEvent.inputChange(hrefInput, 'https://www.google.com');

      _everDevTest.fireEvent.mouseDown(saveButton);

      const textLink = await (0, _react.waitForElement)(() => queryByTestId('link'));
      expect(textLink.textContent).toBe('钉钉');
      expect(content.textContent).toBe('before 钉钉 after');
    });
    test('pure link 保存后，若文本为空，转为 textlink', async () => {
      const {
        queryByTestId,
        content
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createPureLink()
      }));
      const link = await (0, _react.waitForElement)(() => queryByTestId('pure-link'));
      const form = await getEditForm(link, queryByTestId);
      const textInput = form.querySelector('[name="text"]');
      const hrefInput = form.querySelector('[name="href"]');
      const saveButton = queryByTestId('link-editor-save');

      _everDevTest.fireEvent.inputChange(textInput, ' ');

      _everDevTest.fireEvent.inputChange(hrefInput, 'https://www.google.com');

      _everDevTest.fireEvent.mouseDown(saveButton);

      const textLink = await (0, _react.waitForElement)(() => queryByTestId('link'));
      expect(textLink?.textContent).toBe('https://www.google.com');
      expect(content?.textContent).toBe('before https://www.google.com after');
    });
    test('取消文本链接', async () => {
      const value = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "paragraph"
      }, (0, _everDevTest.jsx)("inline", {
        key: "link",
        type: "link",
        data: {
          href: ''
        }
      }, "DingTa", _ref26, "lk"))));
      const {
        content,
        queryByTestId,
        findByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: value
      }));
      const link = await findByTestId('link');

      _everDevTest.fireEvent.mouseDown(link);

      const unlink = await findByTestId('link-editor-unlink');

      _everDevTest.fireEvent.mouseDown(unlink);

      await (0, _react.waitForElementToBeRemoved)(() => queryByTestId('link'));
      expect(content?.textContent).toBe('DingTalk');
    });
    test('取消 pure link', async () => {
      const {
        queryByTestId,
        findByTestId,
        content
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: createPureLink()
      }));
      const link = await findByTestId('pure-link');
      await getEditForm(link, queryByTestId);
      const unlink = await findByTestId('link-editor-unlink');

      _everDevTest.fireEvent.mouseDown(unlink);

      await (0, _react.waitForElementToBeRemoved)(() => queryByTestId('pure-link'));
      expect(content?.textContent).toBe('before https://www.dingtalk.com after');
    });
  });
  describe('删除链接', () => {
    test('向前删除', async () => {
      const value = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "paragraph"
      }, (0, _everDevTest.jsx)("inline", {
        key: "link",
        type: "link",
        data: {
          href: 'https://www.dingtalk/com'
        }
      }, "DingTalk"), _ref27)));
      const {
        queryByText,
        editor
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: value
      }));
      await (0, _react.waitForElement)(() => queryByText(/DingTalk/));

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)(_everDevTest.HOTKEYS.deleteBackward));

      await (0, _react.waitForElementToBeRemoved)(() => queryByText(/DingTalk/));
    });
    test('向后删除', async () => {
      const value = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "paragraph"
      }, _ref28, (0, _everDevTest.jsx)("inline", {
        key: "link",
        type: "link",
        data: {
          href: 'https://www.dingtalk/com'
        }
      }, "DingTalk"))));
      const {
        queryByText,
        editor
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: value
      }));
      await (0, _react.waitForElement)(() => queryByText(/DingTalk/));

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)(_everDevTest.HOTKEYS.deleteForward));

      await (0, _react.waitForElementToBeRemoved)(() => queryByText(/DingTalk/));
    });
  });
  describe('粘贴链接', () => {
    const blankValue = _ref29;

    var _ref30 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: blankValue
    });

    test('粘贴链接包含 schema', async () => {
      const {
        queryByTestId,
        editor
      } = await (0, _everDevTest.renderEditor)(_ref30);

      _everDevTest.fireEvent.paste(editor, 'text/plain', 'https://www.dingtalk.com');

      const link = await (0, _react.waitForElement)(() => queryByTestId('link'));
      expect(link?.textContent).toBe('https://www.dingtalk.com');
    });

    var _ref31 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: blankValue
    });

    test('粘贴链接包含自定义的 protocal', async () => {
      const {
        queryByTestId,
        editor
      } = await (0, _everDevTest.renderEditor)(_ref31);

      _everDevTest.fireEvent.paste(editor, 'text/plain', 'xxx://yyy');

      const link = await (0, _react.waitForElement)(() => queryByTestId('pure-link'));
      expect(link?.textContent).toBe('xxx://yyy');
    });
    test('若选中文本，且粘贴内容为链接，则设置选中文本为链接', async () => {
      const value = _ref32;
      const {
        queryByTestId,
        editor
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: value
      }));

      _everDevTest.fireEvent.paste(editor, 'text/plain', 'https://www.dingtalk.com'); // 等待一次 flush


      await (0, _react.wait)();
      const link = await (0, _react.waitForElement)(() => queryByTestId('link'));
      expect(link?.textContent).toBe('钉钉');
    });
    test('若选中文本，且粘贴内容为链接，则设置选中文本为链接后，能够回车换行', async () => {
      const value = _ref33;
      const {
        queryByTestId,
        editor,
        debug,
        content,
        findByText
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: value,
        linkConfig: {
          enableCard: true
        }
      }));

      _everDevTest.fireEvent.paste(editor, 'text/plain', 'https://www.dingtalk.com'); // 等待一次 flush


      await (0, _react.waitFor)(() => queryByTestId('link'));
      let count = content.querySelectorAll('[data-type="paragraph"]').length;
      expect(count).toBe(1);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)(_everDevTest.HOTKEYS.enter));

      _everDevTest.fireEvent.cangjieInput(editor, {
        data: 'test'
      }); // 等待一次 flush


      await findByText('test');
      count = content.querySelectorAll('[data-type="paragraph"]').length;
      expect(count).toBe(2);
    });
    test('若选中内容为链接，且粘贴内容为链接，则替换链接', async () => {
      const value = _ref34;
      const {
        queryByTestId,
        editor
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: value
      }));

      _everDevTest.fireEvent.paste(editor, 'text/plain', 'https://www.google.com'); // 等待一次 flush


      await (0, _react.wait)();
      const link = await (0, _react.waitForElement)(() => queryByTestId('link'));
      expect(link?.textContent).toBe('https://www.google.com');
    });

    var _ref35 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: blankValue
    });

    test('粘贴多个链接', async () => {
      const {
        queryByTestId,
        editor
      } = await (0, _everDevTest.renderEditor)(_ref35);
      const pastedText = 'Head xxx://yyy\nhttps://www.dingtalk.com?q=测试一下';

      _everDevTest.fireEvent.paste(editor, 'text/plain', pastedText);

      const pureLink = await (0, _react.waitForElement)(() => queryByTestId('pure-link'));
      const textLink = await (0, _react.waitForElement)(() => queryByTestId('link'));
      expect(pureLink.textContent).toBe('xxx://yyy');
      expect(textLink.textContent).toBe('https://www.dingtalk.com?q=测试一下');
    });
    test('开启链接卡片时，显示自定义粘贴面板', async () => {
      const {
        editor,
        queryByTestId,
        findByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: blankValue,
        linkConfig: {
          enableCard: true
        }
      }));
      expect(queryByTestId('pastePanel')).toBe(null);

      _everDevTest.fireEvent.paste(editor, 'text/plain', 'http://gitlab.alibaba-inc.com/alidocs/we-plugin-attachment');

      await (0, _react.waitFor)(() => {
        expect(queryByTestId('pastePanel')).not.toBe(null);
      });

      _everDevTest.fireEvent.click(await findByTestId('menu-item-1')); // fireEvent.click(await findByTestId('menu-item-sourceFormat'));


      await (0, _react.waitFor)(() => {
        expect(queryByTestId('pastePanel')).toBe(null);
      });
    });
    test('粘贴时，忽略引用块链接', async () => {
      const {
        editor,
        queryByTestId,
        findByTestId,
        queryByText
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: blankValue,
        linkConfig: {
          enableCard: true
        }
      }));
      expect(queryByTestId('pastePanel')).toBe(null);

      _everDevTest.fireEvent.pasteAll(editor, [{
        type: _everCangjie.constants.MIME_TYPES.REFBLOCK,
        content: 'anything'
      }, {
        type: _everCangjie.constants.MIME_TYPES.TEXT,
        content: 'http://alidocs.com/xxxx'
      }]);

      await findByTestId('pastePanel');
      expect(queryByText(/摘要卡片/)).toBe(null);
    });
    test('未开启链接卡片时，不显示自定义粘贴面板', async () => {
      const {
        editor,
        queryByTestId,
        findByTestId
      } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
        defaultValue: blankValue,
        linkConfig: {
          enableCard: false
        }
      }));
      expect(queryByTestId('pastePanel')).toBe(null);

      _everDevTest.fireEvent.paste(editor, 'text/plain', 'http://gitlab.alibaba-inc.com/alidocs/we-plugin-attachment');

      await (0, _react.waitFor)(() => {
        expect(queryByTestId('pastePanel')).not.toBe(null);
      }); // 有默认转文本选项

      await (0, _react.waitFor)(() => {
        expect(queryByTestId('menu-item-textFormat')).not.toBe(null);
      });
    });
  });
  describe('输入识别', () => {
    const blankValue = _ref36;

    var _ref37 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: blankValue
    });

    ['https://www.dingtalk.com', 'https://www.dingtalk.com?q=测试一下', 'xxx://yyy'].forEach(href => {
      test(`如果符合链接格式[${href}]，则装饰当前文本为链接`, async () => {
        const {
          queryByTestId,
          editor
        } = await (0, _everDevTest.renderEditor)(_ref37);

        _everDevTest.fireEvent.cangjieInput(editor, {
          data: href
        });

        const link = await (0, _react.waitForElement)(() => queryByTestId('pure-link'));
        expect(link?.textContent).toBe(href);
      });
    });

    var _ref38 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: blankValue
    });

    test('正在链接中输入，如果不符合链接格式，则还原当前文本为普通文本', async () => {
      const {
        queryByTestId,
        editor
      } = await (0, _everDevTest.renderEditor)(_ref38);

      _everDevTest.fireEvent.cangjieInput(editor, {
        data: 'https://w'
      });

      await (0, _react.waitForElement)(() => queryByTestId('pure-link'));

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('backspace')); // https://


      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('backspace')); // https:/


      await (0, _react.waitForElementToBeRemoved)(() => queryByTestId('pure-link'));
    });
  });
  describe('闭合选区中插入链接，选中选区附近文字（交互参考word）', () => {
    const value = _ref39;

    var _ref40 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: value
    });

    test('快捷键插入', async () => {
      const {
        queryByTestId,
        editor
      } = await (0, _everDevTest.renderEditor)(_ref40);

      _everDevTest.fireEvent.keyDown(editor, (0, _everDevTest.getHotkeyEvent)('mod+k'));

      await (0, _react.waitForElement)(() => queryByTestId('link'));
      const input = queryByTestId('link-editor-input-href');
      expect(input).toBe(editor.ownerDocument.activeElement);
    });

    var _ref41 = (0, _everDevTest.jsx)(Editor, {
      defaultValue: value
    });

    test('toolbar 插入', async () => {
      const {
        queryByTestId,
        editor
      } = await (0, _everDevTest.renderEditor)(_ref41);

      _everDevTest.fireEvent.click(queryByTestId('bi-toolbar-link'));

      await (0, _react.waitForElement)(() => queryByTestId('link'));
      const input = queryByTestId('link-editor-input-href');
      expect(input).toBe(editor.ownerDocument.activeElement);
    });
  });
  describe('Markdown 格式输入链接', () => {
    const cases = [{
      input: '[]()',
      isLink: true,
      title: '',
      href: '',
      showEditor: true
    }, {
      input: '[abc]()',
      isLink: true,
      title: 'abc',
      href: '',
      showEditor: true
    }, {
      input: '[abc](def)',
      isLink: true,
      title: 'abc',
      href: 'def',
      showEditor: false
    }, {
      input: '[[abc](][中文<>![](dd))',
      isLink: true,
      title: 'abc',
      href: encodeURI('][中文<>![](dd)'),
      showEditor: false
    }, {
      input: 'text[abc](def)',
      isLink: true,
      title: 'abc',
      href: 'def',
      showEditor: false
    }, {
      input: '[](def)',
      isLink: false
    }, {
      input: '[abc[c](def)',
      isLink: true,
      title: 'c',
      href: 'def',
      showEditor: false
    }, {
      input: '[[aaa]](def)',
      isLink: false
    }, {
      input: '[]](def)',
      isLink: false
    }, {
      input: '![foo](http://bar)',
      isLink: false
    }];
    cases.forEach(async ({
      input,
      isLink,
      title,
      href,
      showEditor
    }) => {
      var _ref42 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "paragraph"
      }, input, _ref43)));

      it(`test: \`${input}\``, async () => {
        const value = _ref42;

        let controller = _everCangjie.Controller.create({
          value
        });

        const {
          content,
          editor,
          queryByTestId
        } = await (0, _everDevTest.renderEditor)((0, _everDevTest.jsx)(Editor, {
          controllerRef: c => {
            controller = c;
          },
          defaultValue: value
        }));

        _everDevTest.fireEvent.cangjieInput(editor, {
          data: ' '
        });

        await (0, _everDevTest.waitForTime)(10);
        const link = await (0, _react.waitFor)(() => queryByTestId('link'));
        expect(!!link).toBe(!!isLink);

        if (isLink) {
          const linkNode = controller.value.document.findDescendant(_everMo.Link.isLink);

          if (title) {
            expect(linkNode.text).toBe(title);
            expect(linkNode.data.href).toBe(href);
          }

          if (showEditor) {
            const linkTitle = await (0, _react.waitFor)(() => queryByTestId('link-editor-input-text'));
            const linkHref = await (0, _react.waitFor)(() => queryByTestId('link-editor-input-href'));
            expect(linkTitle?.value).toBe(title);
            expect(linkHref?.value).toBe(href);
          } else {
            expect(controller.value.selection.anchor.key).toEqual(controller.value.document.getNextText(linkNode.key)?.key);
          }
        }
      });
    });
  });
});
//# sourceMappingURL=ui.test.js.map