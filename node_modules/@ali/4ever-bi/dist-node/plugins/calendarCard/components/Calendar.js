"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Calendar = void 0;

var _react = _interopRequireWildcard(require("react"));

var _debug = _interopRequireDefault(require("debug"));

var _everBamboo = require("@ali/4ever-bamboo");

var _Container = _interopRequireDefault(require("../components/Container"));

var _FlashCalendarContainer = _interopRequireDefault(require("../shanhui/FlashCalendarContainer"));

var _types = require("../types");

var _everFactory = require("@ali/4ever-factory");

var _calculatedSize = require("../utils/calculatedSize");

var _calculatedCalendarSize = require("../shanhui/calculatedCalendarSize");

var _useRefreshResult = _interopRequireDefault(require("../hooks/useRefreshResult"));

var _useRenderCalendarBtn = _interopRequireDefault(require("../hooks/useRenderCalendarBtn"));

var _isEqualValue = _interopRequireDefault(require("../utils/isEqualValue"));

var _useInit = _interopRequireDefault(require("../hooks/useInit"));

const _createElement = /*#__PURE__*/_react.default.createElement;
const debug = (0, _debug.default)('EDITOR:BI:CALENDAR:RENDER');
const {
  CALENDAR_CARD_MIN_HEIGHT
} = _everBamboo.CalendarCardPlugin;

const Calendar = ({
  nodeProps,
  controller,
  calendarConfig
}) => {
  const {
    locale,
    jumpToCalendar,
    openProfile,
    jumpToAttachment,
    onRefreshSuccess,
    refresh,
    isMobile,
    getContainerWidthInPC = () => 0,
    handleCreateCalendar,
    onInitData,
    renderCreateCalendarBtn: CreateCalendarBtn,
    mode: calendarMode
  } = calendarConfig;
  const {
    isFocused
  } = controller.value;
  const containerWidthInPC = (0, _react.useMemo)(() => {
    return getContainerWidthInPC() - 4;
  }, [getContainerWidthInPC]);
  const {
    node,
    isSelected
  } = nodeProps;
  const nodeKey = node.key;
  const finalData = node.data;
  const finalHeight = isMobile ? 'auto' : finalData.height || CALENDAR_CARD_MIN_HEIGHT;
  const {
    injectionMetadata,
    injectionHeight,
    isFirstLoaded = !!isMobile
  } = finalData;
  const {
    isInitialized,
    isPlaceholder,
    mode = calendarMode
  } = finalData.metadata;
  const finalMetadata = injectionMetadata || finalData.metadata;
  const {
    calendarId,
    redirectUrl
  } = finalMetadata;
  const [isLoading, setLoading] = (0, _react.useState)(false);
  const isShanhui = mode === _types.CalendarType.SHANHUI; // 点击刷新按钮后的消息反馈

  const {
    refreshTipsNode,
    setRefreshResult
  } = (0, _useRefreshResult.default)();
  const injectToData = (0, _react.useCallback)(mergeData => {
    const latestNode = controller.value.document.getNode(node.key);
    controller.run('onAction', (0, _everFactory.setCardInjection)(latestNode, {
      injectionMetadata,
      injectionHeight,
      isFirstLoaded,
      ...mergeData
    }));
  }, [controller, node.key, injectionMetadata, injectionHeight, isFirstLoaded]); // 设置日程卡片 data

  const setCalendarCardData = (0, _react.useCallback)(async newMetadata => {
    const calculateHeight = isShanhui ? _calculatedCalendarSize.calculatedCalendarSize : _calculatedSize.calculatedSize;
    const height = await calculateHeight(newMetadata, containerWidthInPC);
    const latestNode = controller.value.document.getNode(node.key);
    controller.run('onAction', (0, _everFactory.setCardData)(latestNode, {
      metadata: { ...newMetadata,
        mode,
        isInitialized: true
      },
      height,
      withoutSaving: true
    }));
  }, [containerWidthInPC, controller, node.key, mode, isShanhui]); // 创建右上角日程按钮

  const [createCalendarBtn] = (0, _useRenderCalendarBtn.default)({
    isPlaceholder,
    calendarId,
    containerWidthInPC,
    finalMetadata,
    injectToData,
    setLoading,
    setCalendarCardData,
    CalendarBtn: CreateCalendarBtn,
    key: nodeKey
  }); // 点击创建日程按钮

  const processCreateCalendar = (0, _react.useCallback)(() => {
    if (handleCreateCalendar) handleCreateCalendar(nodeKey);
  }, [handleCreateCalendar, nodeKey]); // 调整到日程容器

  const goToCalendar = (0, _react.useCallback)(eventType => {
    if (!jumpToCalendar || !redirectUrl) return;
    jumpToCalendar(redirectUrl, eventType);
  }, [jumpToCalendar, redirectUrl]); // 将日程数据持久化存储到卡片中

  const setRefreshDataToNode = (0, _react.useCallback)(() => {
    if (injectionMetadata) {
      const latestNode = controller.value.document.getNode(node.key);
      controller.run('onAction', (0, _everFactory.setCardData)(latestNode, {
        metadata: { ...injectionMetadata,
          mode,
          isInitialized: true
        },
        height: injectionHeight,
        withoutSaving: true
      }));
      injectToData({
        injectionMetadata: undefined,
        injectionHeight: undefined,
        isFirstLoaded: true
      });
      if (onRefreshSuccess) onRefreshSuccess();
    }
  }, [injectionMetadata, controller, node.key, mode, injectionHeight, injectToData, onRefreshSuccess]);
  const fireRefresh = (0, _react.useCallback)(event => {
    event.preventDefault();
    event.stopPropagation();
    if (!refresh) return;

    if (injectionMetadata) {
      setRefreshDataToNode();
      return;
    }

    setLoading(true);
    refresh(calendarId, 'click').then(async res => {
      setLoading(false);
      if (res.status !== 'success') return;
      if (!containerWidthInPC) return;
      const getTopReceivers = isShanhui ? _calculatedCalendarSize.getCalculatedCalendarReceivers : _calculatedSize.getCalculatedReceivers;
      const topReceivers = await getTopReceivers(res.data, containerWidthInPC, res.data.totalCount);
      const newMetadata = {
        calendarId,
        ...res.data,
        topReceivers
      };

      if (!(0, _isEqualValue.default)(newMetadata, finalMetadata)) {
        setCalendarCardData(newMetadata);
      }

      if (onRefreshSuccess) onRefreshSuccess();
    }).catch(() => {
      setLoading(false);
    });
  }, [refresh, injectionMetadata, calendarId, setRefreshDataToNode, containerWidthInPC, isShanhui, finalMetadata, onRefreshSuccess, setCalendarCardData]);
  const getLoadingState = (0, _react.useCallback)(() => {
    debug('LOADINGSTATE', isFirstLoaded, isLoading);
    return !isFirstLoaded ? true : isLoading;
  }, [isFirstLoaded, isLoading]);
  (0, _useInit.default)({
    isInitialized,
    isPlaceholder,
    containerWidthInPC,
    isLoading,
    isFirstLoaded,
    isMobile,
    calendarId,
    setLoading,
    refresh,
    controller,
    node,
    finalMetadata,
    finalData,
    injectToData,
    setRefreshResult,
    onInitData,
    mode
  });

  if (isShanhui) {
    return /*#__PURE__*/_createElement(_FlashCalendarContainer.default, {
      refreshTipsNode: refreshTipsNode,
      height: finalHeight,
      isLoading: isLoading,
      isFirstLoaded: isFirstLoaded,
      isChangeData: !!injectionMetadata,
      metadata: { ...finalMetadata,
        mode
      },
      locale: locale,
      isSelected: isSelected && isFocused,
      width: containerWidthInPC,
      jumpToCalendar: goToCalendar,
      openProfile: openProfile,
      jumpToAttachment: jumpToAttachment,
      refresh: fireRefresh,
      isMobile: isMobile,
      handleCreateCalendar: processCreateCalendar,
      createCalendarBtn: createCalendarBtn
    });
  }

  return /*#__PURE__*/_createElement(_Container.default, {
    refreshTipsNode: refreshTipsNode,
    height: finalHeight,
    isLoading: getLoadingState(),
    isFirstLoaded: isFirstLoaded,
    isChangeData: !!injectionMetadata,
    metadata: finalData.metadata,
    locale: locale,
    isSelected: isSelected && isFocused,
    width: containerWidthInPC,
    jumpToCalendar: goToCalendar,
    openProfile: openProfile,
    jumpToAttachment: jumpToAttachment,
    refresh: fireRefresh,
    isMobile: isMobile,
    handleCreateCalendar: processCreateCalendar,
    createCalendarBtn: createCalendarBtn
  });
};

exports.Calendar = Calendar;
var _default = Calendar;
exports.default = _default;
//# sourceMappingURL=Calendar.js.map