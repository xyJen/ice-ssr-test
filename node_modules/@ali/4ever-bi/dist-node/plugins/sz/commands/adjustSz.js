"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = adjustSz;

var _everCangjie = require("@ali/4ever-cangjie");

var _everUtils = require("@ali/4ever-utils");

var _utils = require("../utils");

var _everPluginSz = require("@ali/4ever-plugin-sz");

var _getSize = _interopRequireDefault(require("../queries/getSize"));

var _actions = require("../actions");

const isLeafInSelection = (leaf, leafOffset, selectionOffset, selectionLength) => {
  const {
    length: leafLength
  } = leaf.text;
  if (leafOffset + leafLength <= selectionOffset) return false;
  if (leafOffset >= selectionOffset + selectionLength) return false;
  return true;
};

const isInInlineNode = (document, key) => {
  return document.getClosestInline(key);
};
/**
 * @param controller
 * @param isIncreasingSz
 * @description
 * 若选区重合，直接通过getSize方法获取当前的字体大小，再通过findNextSz方法获取增减后的字体大小，最后设置字体；
 * 若选区非重合，遍历selection中的每一个叶子节点，通过sz mark获取当前叶子节点的字体大小，
 * 若没有sz mark 则根据段落类型获取默认的字体大小，通过findNextSz方法获取每个叶子节点增减后的字体大小，
 * 移除旧的 sz mark 后增加新的 sz；
 */


function adjustSz(controller, isIncreasingSz) {
  const {
    value
  } = controller;
  const {
    document,
    selection
  } = value;
  const {
    isCollapsed
  } = selection;
  const direction = isIncreasingSz ? 'right' : 'left';

  if (isCollapsed) {
    const sz = (0, _getSize.default)(controller);
    controller.run('onAction', (0, _actions.setSz)((0, _everPluginSz.findNextSz)(sz, direction)));
    return controller;
  } else {
    const ranges = (0, _everUtils.getRangesFromEditor)(controller);

    if (!ranges[0]) {
      return controller;
    }

    for (const range of ranges) {
      const {
        start,
        end
      } = range.convertToTextPoints(document);
      const texts = document.getTextsAtRange(range);
      controller.withoutNormalizing(() => {
        texts.forEach(node => {
          const {
            key
          } = node;
          let offset = 0;
          let {
            length
          } = node.text;
          if (key === start.key) ({
            offset
          } = start);
          if (key === end.key) length = end.offset;

          if (key === start.key && key === end.key) {
            length = end.offset - start.offset;
          }

          const {
            leaves
          } = node;
          let subOffset = offset;
          let accOffset = 0;

          for (const leaf of leaves) {
            if (isLeafInSelection(leaf, accOffset, offset, length) || isInInlineNode(document, key)) {
              const subLength = accOffset + leaf.text.length > length ? end.offset - subOffset : leaf.text.length;
              const szMarks = leaf.marks.filter(mark => mark.type === 'sz');
              const szMarksLength = szMarks.length;

              if (szMarksLength > 0) {
                const sz = szMarks[szMarksLength - 1].data.value;

                const newSzMark = _everCangjie.Mark.create({
                  type: 'sz',
                  data: {
                    value: (0, _everPluginSz.findNextSz)(sz, direction),
                    szUnit: 'pt'
                  }
                });

                for (const szMark of szMarks) {
                  controller.command(_everCangjie.Commands.removeMarkByKey, node.key, subOffset, subLength, szMark);
                }

                controller.command(_everCangjie.Commands.addMarkByKey, node.key, subOffset, subLength, newSzMark);
              } else {
                const sz = (0, _utils.getDefaultSz)(document, key);

                const newSzMark = _everCangjie.Mark.create({
                  type: 'sz',
                  data: {
                    value: (0, _everPluginSz.findNextSz)(sz, direction),
                    szUnit: 'pt'
                  }
                });

                controller.command(_everCangjie.Commands.addMarkByKey, node.key, subOffset, subLength, newSzMark);
              }
            }

            accOffset += leaf.text.length;
            subOffset = Math.max(offset, accOffset);
          }
        });
      });
    }
  }

  return controller;
}
//# sourceMappingURL=adjustSz.js.map