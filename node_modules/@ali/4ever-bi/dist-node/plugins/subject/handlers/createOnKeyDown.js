"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _everCangjie = require("@ali/4ever-cangjie");

var _commands = require("../commands");

var _constants = require("../constants");

var _helpers = require("../helpers");

var _queries = require("../queries");

var _utils = require("../utils");

var _everFactory = require("@ali/4ever-factory");

function isDeleteBackward(event) {
  return _everCangjie.hotkeys.isDeleteBackward(event) || _everCangjie.hotkeys.isDeleteWordBackward(event) || _everCangjie.hotkeys.isDeleteLineBackward(event);
}

function isDeleteForward(event) {
  return _everCangjie.hotkeys.isDeleteForward(event) || _everCangjie.hotkeys.isDeleteWordForward(event) || _everCangjie.hotkeys.isDeleteLineForward(event);
}

function isDelete(event) {
  return isDeleteBackward(event) || isDeleteForward(event);
}

function createOnKeyDown() {
  return function onKeyDown(event, controller, next) {
    const {
      document,
      startBlock,
      endBlock,
      selection
    } = controller.value;
    /**
     * 限制 1：反向删除
     * @description 若光标在议题开始处，且议题不为空，则不允许直接删除，选中议题块
     */

    if (isDeleteBackward(event.nativeEvent) && (0, _utils.isSubjectHeading)(endBlock)) {
      const end = selection.getEnd(document);

      if ( // 光标结束在议题的开头
      end.isAtStartOfNode(endBlock) && ( // 标题不为空，或有内容
      !(0, _utils.isEmptyNode)(endBlock) || controller.query(_queries.hasSubjectGroupBlocks, endBlock)) && // 未选中
      !controller.query(_queries.isSubjectSelected, endBlock)) {
        event.preventDefault();
        return controller.command(_commands.selectSubject, endBlock.key);
      }
    }
    /**
     * 限制 2：正向删除
     */


    if (isDeleteForward(event.nativeEvent) && selection.isCollapsed) {
      const {
        focus
      } = selection; // 光标在议题标题处，标题为空，但议题不为空时，不允许删除

      if ((0, _utils.isSubjectHeading)(endBlock) && (0, _utils.isEmptyNode)(endBlock) && focus.isAtStartOfNode(endBlock) && controller.query(_queries.hasSubjectGroupBlocks, endBlock) && !controller.query(_queries.isSubjectSelected, endBlock)) {
        event.preventDefault();
        return controller.command(_commands.selectSubject, endBlock.key);
      } // 光标在议题上方的节点末尾，不允许删除


      if (endBlock && (0, _utils.isSubjectHeading)(document.getNextBlock(endBlock.key)) && focus.isAtEndOfNode(endBlock)) {
        event.preventDefault();
        return;
      }
    }
    /**
     * 限制 3：议题标题无法被换行操作分裂
     * @description 换行时清除议题的属性
     */


    if (_everCangjie.hotkeys.isEnter(event) && (0, _utils.isSubjectHeading)(startBlock) // 在行内输入 + 号唤起工具栏时，Enter 事件会被工具栏消费
    && !controller.query('isNewLineGuideDisplay') // 在 Mention 唤起时，Enter 时间会被选人行为消费
    && !controller.query('isSelectionInMentionSuggestion')) {
      event.preventDefault(); // 若折叠则先展开

      const fold = controller.userData.get(startBlock, 'fold');

      if (fold) {
        controller.command(_everFactory.toggleFold, startBlock, false);
      }

      return controller.command(_everCangjie.Commands.splitBlock).command('clearStyle').command(_commands.clearSubjectStyle);
    }
    /**
     * Effects: 选中状态删除，删除整个议题
     */


    if (isDelete(event.nativeEvent) && (0, _helpers.hasSubjectBeenSelected)(controller)) {
      const {
        [_constants.SELECTED_SUBJECT_KEY]: selectedKey
      } = controller.value.data;
      const block = document.getNode(selectedKey);

      if ((0, _utils.isSubjectHeading)(block)) {
        return controller.command(_commands.deleteSubject, block).command(_commands.unselectSubject);
      }
    }
    /**
     * Effects: 议题完全包含在选区内，删除操作需要删除议题格式
     */


    if (isDelete(event.nativeEvent) && (0, _utils.isSubjectHeading)(startBlock)) {
      const end = selection.getEnd(document);

      if ( // 若 end 选区不为 hanging
      // References: cangjie/src/commands/delete/deleteAtRange (84 Line/252 Line)
      end.isTextPoint() && end.offset > 0 && // 议题完全包含在选区内
      controller.query(_queries.isSelectionCoverSubjectFromStart, startBlock)) {
        next(); // 删除议题块之后，光标此时会停留在议题标题处，这里需要清除议题格式

        return controller.command('clearStyle');
      }
    }

    return next();
  };
}

var _default = createOnKeyDown;
exports.default = _default;
//# sourceMappingURL=createOnKeyDown.js.map