{"version":3,"sources":["../../../../../src/plugins/subject/queries/selection.ts"],"names":["getSubjectEndBlock","SubjectPlugin","queries","isSelectionInSubjectHeading","controller","selection","value","document","blocks","getRootBlocksAtRange","some","block","isSelectionCoverSubjectFromStart","subject","start","getStart","startBlock","getFurthsestBlock","key","isAtStartOfNode","end","getEnd","endBlock","subjectEndBlock","query","isAtEndOfNode","endPath","getPath","subjectEndPath","Path","isAfter","isSelectionCoverSubject","isCoverStart","isBefore","assertPath","isCoverEnd","isSubjectSelected","node","data","SELECTED_SUBJECT_KEY","getSubjectRange","moveAnchorToStartOfNode","moveFocusToEndOfNode","getSubjectFragment","getFragmentAtRange","getCaretOffset","isExpanded","point","anchor","isEdgePoint","edge","EdgePoint","BEFORE","left","SUBJECT_PADDING_LEFT"],"mappings":"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","sourcesContent":["import { Block, Controller, EdgePoint, Path, Selection } from '@ali/4ever-cangjie';\nimport { isSubjectHeading, Subject } from '../utils';\nimport { SubjectPlugin } from '@ali/4ever-bamboo';\nimport { SELECTED_SUBJECT_KEY } from '../constants';\nimport { SUBJECT_PADDING_LEFT } from '../components/subject';\n\nconst {\n  getSubjectEndBlock,\n} = SubjectPlugin.queries;\n\n/**\n * 判断选区是否在议题之内\n * @param controller\n * @param selection\n * @returns\n */\nexport function isSelectionInSubjectHeading(controller: Controller, selection = controller.value.selection): boolean {\n  const { document } = controller.value;\n  const blocks = document.getRootBlocksAtRange(selection);\n  return blocks.some((block) => isSubjectHeading(block));\n}\n\n/**\n * 判断议题是否完全在选区之内\n * @param controller\n * @param subject\n * @param selection\n * @description 包含逻辑从议题的开始节点开始\n */\nexport function isSelectionCoverSubjectFromStart(\n  controller: Controller,\n  subject: Subject,\n  selection = controller.value.selection,\n): boolean {\n  const { document } = controller.value;\n  const start = selection.getStart(document);\n  const startBlock = document.getFurthsestBlock(start.key);\n\n  // 开始节点不同，返回 false\n  if (startBlock !== subject) {\n    return false;\n  }\n\n  // 开始光标不在议题的开头，返回 false\n  if (!start.isAtStartOfNode(startBlock)) {\n    return false;\n  }\n\n  const end = selection.getEnd(document);\n  const endBlock = document.getFurthsestBlock(end.key);\n  const subjectEndBlock = controller.query(getSubjectEndBlock, startBlock);\n\n  /* 这里的前置条件是光标 start 在议题首个节点的开头 */\n\n  // 若光标在议题结束节点的末尾，返回 true\n  if (endBlock && endBlock === subjectEndBlock && end.isAtEndOfNode(endBlock)) {\n    return true;\n  }\n\n  // 若议题的末尾节点在选区的包含范围之内\n  const endPath = document.getPath(endBlock?.key || '');\n  const subjectEndPath = document.getPath(subjectEndBlock?.key || '');\n  if (endPath && subjectEndPath && Path.isAfter(endPath, subjectEndPath)) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * 判断议题组是否完全在选区范围之内\n * @param controller\n * @param startBlock 议题开始节点\n * @param endBlock 议题结束节点\n * @returns\n */\nexport function isSelectionCoverSubject(controller: Controller, startBlock: Block, endBlock: Block) {\n  const { selection, document } = controller.value;\n  const start = selection.getStart(document);\n  const end = selection.getEnd(document);\n\n  const isCoverStart = start.isAtStartOfNode(startBlock) || Path.isBefore(\n    document.assertPath(start.key),\n    document.assertPath(startBlock.key),\n  );\n\n  const isCoverEnd = end.isAtEndOfNode(endBlock) || Path.isAfter(\n    document.assertPath(end.key),\n    document.assertPath(endBlock.key),\n  );\n\n  if (isCoverStart && isCoverEnd) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function isSubjectSelected(controller: Controller, node: Subject) {\n  const { data } = controller.value;\n  return data[SELECTED_SUBJECT_KEY] === node.key;\n}\n\n/**\n * 获取议题 Range\n * @param controller\n * @param subject\n * @returns\n */\nexport function getSubjectRange(controller: Controller, subject: Subject) {\n  const { selection } = controller.value;\n  const subjectEndBlock = controller.query(getSubjectEndBlock, subject);\n  if (subjectEndBlock) {\n    return selection.moveAnchorToStartOfNode(subject, controller).moveFocusToEndOfNode(subjectEndBlock, controller);\n  }\n  return selection.moveAnchorToStartOfNode(subject, controller).moveFocusToEndOfNode(subject, controller);\n}\n\n/**\n * 获取议题 fragment\n * @param controller\n * @param subject\n * @returns\n */\nexport function getSubjectFragment(controller: Controller, subject: Subject) {\n  const { document } = controller.value;\n  const selection = getSubjectRange(controller, subject);\n  return document.getFragmentAtRange(selection);\n}\n\n/**\n * 获取光标偏移量\n */\nexport function getCaretOffset(controller: Controller, selection: Selection): { top?: number, left?: number } {\n  if (selection.isExpanded) {\n    return {};\n  }\n\n  const point = selection.anchor;\n  return point.isEdgePoint() && point.edge === EdgePoint.BEFORE ? { left: SUBJECT_PADDING_LEFT } : {};\n}"],"file":"selection.js"}