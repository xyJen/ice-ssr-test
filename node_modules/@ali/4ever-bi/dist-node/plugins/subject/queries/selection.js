"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSelectionInSubjectHeading = isSelectionInSubjectHeading;
exports.isSelectionCoverSubjectFromStart = isSelectionCoverSubjectFromStart;
exports.isSelectionCoverSubject = isSelectionCoverSubject;
exports.isSubjectSelected = isSubjectSelected;
exports.getSubjectRange = getSubjectRange;
exports.getSubjectFragment = getSubjectFragment;
exports.getCaretOffset = getCaretOffset;

var _everCangjie = require("@ali/4ever-cangjie");

var _utils = require("../utils");

var _everBamboo = require("@ali/4ever-bamboo");

var _constants = require("../constants");

var _subject = require("../components/subject");

const {
  getSubjectEndBlock
} = _everBamboo.SubjectPlugin.queries;
/**
 * 判断选区是否在议题之内
 * @param controller
 * @param selection
 * @returns
 */

function isSelectionInSubjectHeading(controller, selection = controller.value.selection) {
  const {
    document
  } = controller.value;
  const blocks = document.getRootBlocksAtRange(selection);
  return blocks.some(block => (0, _utils.isSubjectHeading)(block));
}
/**
 * 判断议题是否完全在选区之内
 * @param controller
 * @param subject
 * @param selection
 * @description 包含逻辑从议题的开始节点开始
 */


function isSelectionCoverSubjectFromStart(controller, subject, selection = controller.value.selection) {
  const {
    document
  } = controller.value;
  const start = selection.getStart(document);
  const startBlock = document.getFurthsestBlock(start.key); // 开始节点不同，返回 false

  if (startBlock !== subject) {
    return false;
  } // 开始光标不在议题的开头，返回 false


  if (!start.isAtStartOfNode(startBlock)) {
    return false;
  }

  const end = selection.getEnd(document);
  const endBlock = document.getFurthsestBlock(end.key);
  const subjectEndBlock = controller.query(getSubjectEndBlock, startBlock);
  /* 这里的前置条件是光标 start 在议题首个节点的开头 */
  // 若光标在议题结束节点的末尾，返回 true

  if (endBlock && endBlock === subjectEndBlock && end.isAtEndOfNode(endBlock)) {
    return true;
  } // 若议题的末尾节点在选区的包含范围之内


  const endPath = document.getPath(endBlock?.key || '');
  const subjectEndPath = document.getPath(subjectEndBlock?.key || '');

  if (endPath && subjectEndPath && _everCangjie.Path.isAfter(endPath, subjectEndPath)) {
    return true;
  }

  return false;
}
/**
 * 判断议题组是否完全在选区范围之内
 * @param controller
 * @param startBlock 议题开始节点
 * @param endBlock 议题结束节点
 * @returns
 */


function isSelectionCoverSubject(controller, startBlock, endBlock) {
  const {
    selection,
    document
  } = controller.value;
  const start = selection.getStart(document);
  const end = selection.getEnd(document);

  const isCoverStart = start.isAtStartOfNode(startBlock) || _everCangjie.Path.isBefore(document.assertPath(start.key), document.assertPath(startBlock.key));

  const isCoverEnd = end.isAtEndOfNode(endBlock) || _everCangjie.Path.isAfter(document.assertPath(end.key), document.assertPath(endBlock.key));

  if (isCoverStart && isCoverEnd) {
    return true;
  }

  return false;
}

function isSubjectSelected(controller, node) {
  const {
    data
  } = controller.value;
  return data[_constants.SELECTED_SUBJECT_KEY] === node.key;
}
/**
 * 获取议题 Range
 * @param controller
 * @param subject
 * @returns
 */


function getSubjectRange(controller, subject) {
  const {
    selection
  } = controller.value;
  const subjectEndBlock = controller.query(getSubjectEndBlock, subject);

  if (subjectEndBlock) {
    return selection.moveAnchorToStartOfNode(subject, controller).moveFocusToEndOfNode(subjectEndBlock, controller);
  }

  return selection.moveAnchorToStartOfNode(subject, controller).moveFocusToEndOfNode(subject, controller);
}
/**
 * 获取议题 fragment
 * @param controller
 * @param subject
 * @returns
 */


function getSubjectFragment(controller, subject) {
  const {
    document
  } = controller.value;
  const selection = getSubjectRange(controller, subject);
  return document.getFragmentAtRange(selection);
}
/**
 * 获取光标偏移量
 */


function getCaretOffset(controller, selection) {
  if (selection.isExpanded) {
    return {};
  }

  const point = selection.anchor;
  return point.isEdgePoint() && point.edge === _everCangjie.EdgePoint.BEFORE ? {
    left: _subject.SUBJECT_PADDING_LEFT
  } : {};
}
//# sourceMappingURL=selection.js.map