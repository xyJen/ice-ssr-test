"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.InsertBtn = void 0;

var _react = _interopRequireWildcard(require("react"));

var _everCangjie = require("@ali/4ever-cangjie");

var _weDesign = require("@ali/we-design");

var _everUtils = require("@ali/4ever-utils");

var _styled = require("./styled");

var _everComponent = require("@ali/4ever-component");

var _guideMenu = _interopRequireDefault(require("./guideMenu"));

var _weUtil = require("@ali/we-util");

var _actions = require("../actions");

const _createElement = /*#__PURE__*/_react.default.createElement;
const {
  useActiveInteraction
} = _everComponent.ActiveInteractionHooks;

const InsertBtn = props => {
  const {
    controller,
    currentBlock,
    renderGuideMenu,
    onClickGuideMenu,
    enableKeyboard,
    locale,
    trigger = 'hover'
  } = props; // 数据流改造后 useZoomContainer 在未触发controller二次更新前为 null

  const container = (0, _everCangjie.useScrollableContent)() || document.body;
  const [guideMenuVisible, setGuideMenuVisibleState] = (0, _react.useState)(false);
  const timeout = (0, _react.useRef)(null);
  const [, actions] = (0, _everComponent.useLeftToolbar)();
  const [activeType, setActiveType] = useActiveInteraction();

  const activeRef = _react.default.useRef('');

  activeRef.current = activeType;

  const guideMenuVisibleRef = _react.default.useRef(guideMenuVisible);

  guideMenuVisibleRef.current = guideMenuVisible;

  const removeHighlightByType = _react.default.useCallback(type => {
    if (!currentBlock) return;
    controller.dispatch('removeHighlight', {
      node: currentBlock,
      type,
      reason: 'insertBtn'
    });
  }, []);

  (0, _react.useEffect)(() => {
    return () => {
      actions.clearPrevent(); // InsertBtn 在不渲染时会被卸载，在这里兜底清除选中的样式

      removeHighlightByType('hover');
      removeHighlightByType('select');

      if (guideMenuVisibleRef.current) {
        setActiveType('');
      }

      timeout.current && clearTimeout(timeout.current);
    };
  }, [removeHighlightByType, setActiveType]);
  (0, _react.useEffect)(() => {
    const handler = e => {
      const {
        visible
      } = e.detail;
      setGuideMenuVisible(visible);
      removeHighlightByType('select');
      actions.clearPrevent();
      timeout.current && clearTimeout(timeout.current);
    };

    window.document.addEventListener(_everUtils.LEGAL_EVENT.quickInsertMenuVisible, handler);
    return () => {
      window.document.removeEventListener(_everUtils.LEGAL_EVENT.quickInsertMenuVisible, handler);
    };
  }, [removeHighlightByType, actions]);
  const setGuideMenuVisible = (0, _react.useCallback)(state => {
    setGuideMenuVisibleState(state);

    if (state) {
      controller.run('onAction', (0, _actions.mountInsertMenuFromLeftToolbar)());
    }
  }, [setGuideMenuVisibleState, controller]);

  const handleClickGuideMenu = value => {
    onClickGuideMenu?.(value);
    setGuideMenuVisible(false);
    removeHighlightByType('select');
    actions.clearPrevent();
    timeout.current && clearTimeout(timeout.current);
  };

  const guideMenu = (0, _react.useMemo)(() => {
    if (!renderGuideMenu) {
      return null;
    }

    return /*#__PURE__*/_createElement(_guideMenu.default, {
      controller: controller,
      enableKeyboard: enableKeyboard,
      onClickGuideMenu: handleClickGuideMenu
    }, renderGuideMenu());
  }, [renderGuideMenu, enableKeyboard, handleClickGuideMenu]);

  const handleMouseLeave = () => {
    !guideMenuVisible && removeHighlightByType('hover');
    timeout.current && clearTimeout(timeout.current);
  };

  const handleMouseEnter = () => {
    if (!currentBlock) return;
    controller.dispatch('updateHighlight', {
      node: currentBlock,
      type: 'hover',
      reason: 'insertBtn'
    });
  };

  const onVisibleChangeForClick = visible => {
    setGuideMenuVisible(visible);

    if (visible) {
      actions.preventMouseMove();
      controller.dispatch('updateHighlight', {
        node: currentBlock,
        type: 'select',
        reason: 'insertBtn'
      });
    } else {
      actions.clearPrevent();
      removeHighlightByType('select');
    }
  };

  const onVisibleChangeForHover = visible => {
    if (visible) {
      timeout.current = setTimeout(() => {
        setGuideMenuVisible(visible);
        actions.preventMouseMove();
        controller.dispatch('updateHighlight', {
          node: currentBlock,
          type: 'select',
          reason: 'insertBtn'
        });
      }, 300);
    } else {
      setGuideMenuVisible(visible);
      actions.clearPrevent();
      removeHighlightByType('select');
      timeout.current && clearTimeout(timeout.current);
    }
  };

  const handleClick = () => {
    setGuideMenuVisible(true);
    actions.preventMouseMove();
  };

  _react.default.useEffect(() => {
    if (guideMenuVisible) {
      setActiveType('newLineMenu');
    } else {
      if (activeRef.current === 'newLineMenu') {
        setActiveType('');
      }
    }
  }, [guideMenuVisible, setActiveType]);

  const onMouseDown = () => {
    if (!currentBlock) return;
    const {
      startBlock
    } = controller.value;
    if (currentBlock?.key === startBlock?.key) return;
    controller.command(_everCangjie.Commands.moveToEndOfNode, currentBlock).command(_everCangjie.Commands.focus);
  };

  return /*#__PURE__*/_createElement(_weDesign.Dropdown, {
    overlay: guideMenuVisible ? /*#__PURE__*/_createElement(_weUtil.DropdownAnimation, {
      visible: guideMenuVisible
    }, /*#__PURE__*/_createElement("div", {
      onMouseDown: onMouseDown
    }, guideMenu)) : null,
    placement: "leftTop",
    trigger: trigger,
    onVisibleChange: trigger === 'hover' ? onVisibleChangeForHover : onVisibleChangeForClick,
    getContainer: () => container,
    visible: guideMenuVisible
  }, /*#__PURE__*/_createElement("span", null, /*#__PURE__*/_createElement(_weDesign.Tooltip, {
    title: /*#__PURE__*/_createElement(_styled.TooltipText, null, /*#__PURE__*/_createElement(_styled.PrimaryText, null, locale?.click), locale?.clickTip),
    placement: "top",
    getContainer: () => container,
    overlayStyle: {
      padding: 4
    },
    disabled: guideMenuVisible || trigger === 'hover'
  }, /*#__PURE__*/_createElement(_styled.InsertBtnWrapper, {
    "data-drag-handler-key": currentBlock?.key,
    "data-testid": "newline-guide-insertText",
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    onClick: handleClick
  }, _styled.AddIcon))));
};

exports.InsertBtn = InsertBtn;

var _default = config => {
  return ({
    controller,
    currentBlock
  }) => {
    const {
      composing,
      startBlock,
      isFocused,
      document
    } = controller.value;
    const isNewLine = controller.query('isInsertBtnDisplay', {
      node: currentBlock,
      composing
    });
    let inTemplateButton = false; // perf

    if (isNewLine) {
      // 模板按钮内隐藏 insert btn
      inTemplateButton = controller.query('isNodeInTemplateButton', {
        node: currentBlock
      }) ?? false;
    }

    const nodeText = currentBlock?.text;
    const showBtn = !nodeText && isNewLine;

    if (showBtn && !inTemplateButton) {
      return /*#__PURE__*/_createElement(InsertBtn, {
        onClickGuideMenu: config.newlineGuide?.onClickGuideMenu,
        enableKeyboard: config.newlineGuide?.enableKeyboard,
        locale: config.newlineGuide?.locale,
        renderGuideMenu: config.newlineGuide?.renderGuideMenu,
        trigger: config.newlineGuide?.trigger,
        controller: controller,
        currentBlock: currentBlock
      });
    }

    return null;
  };
};

exports.default = _default;
//# sourceMappingURL=insertBtn.js.map