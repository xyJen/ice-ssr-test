"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _everCangjie = require("@ali/4ever-cangjie");

var _everBamboo = require("@ali/4ever-bamboo");

var _everComponent = require("@ali/4ever-component");

var _weDesign = require("@ali/we-design");

var _everLogger = _interopRequireDefault(require("@ali/4ever-logger"));

var _weUtil = require("@ali/we-util");

var _newlineGuide = require("../model/newlineGuide");

var _styled = require("./styled");

var _guideMenu = _interopRequireDefault(require("./guideMenu"));

var _actions = require("../actions");

var _getStartBlock = _interopRequireDefault(require("../utils/getStartBlock"));

const _createElement = /*#__PURE__*/_react.default.createElement;
;
const {
  closeContextMenu
} = _everBamboo.PcContextMenu;
const MAX_ERROR_NUM = 1;
const {
  useActiveInteraction
} = _everComponent.ActiveInteractionHooks;

const NewlineGuide = props => {
  const uiVisible = _react.default.useRef(false);

  const [guideStyle, setGuideStyle] = _react.default.useState({
    top: -9999,
    left: -9999
  });

  const [triggerStyle, setTriggerStyle] = _react.default.useState({
    width: 2,
    height: 0
  });

  const {
    controller,
    renderGuideMenu,
    locale,
    zoom = 1,
    enableKeyboard,
    onClickGuideMenu,
    withoutEmptyParagraphWhitelist
  } = props;
  const {
    document,
    injections,
    selection,
    isFocused
  } = controller.value; // 失焦或选中内容不显示

  const enabled = _react.default.useMemo(() => isFocused && selection.isCollapsed, [isFocused, selection]);

  const startBlock = (0, _getStartBlock.default)(controller);
  const {
    triggered,
    key,
    query
  } = _newlineGuide.NewlineGuideData.get(controller) || {}; // 这里只能从 renderController 中拿到 viewKey
  // 通过 onCangjieInput hook 拿到的是 dataKey，且无法通过 action 劫持转换
  // 通过 点击 触发给到的 key 是这里转换后的后的 dataKey
  // 因此我们确保：NewlineGuideData.key 一定是 dataKey，而 viewKey 转换 dataKey 方法是相对固定的

  const [blockKey] = (startBlock?.key || '').split('-');
  const isInTable = controller.query('isNodeInTable', startBlock); // 当且仅当 focused 在 当前行时 展示面板

  const showMenu = triggered && key === blockKey;
  const container = (0, _everCangjie.useZoomContainer)() || window.document.body;
  const menuContainer = (0, _everBamboo.useScrollableContent)() || window.document.body;

  const errorNumRef = _react.default.useRef(0);

  const handleVisibleChange = value => {
    if (!value && showMenu) {
      uiVisible.current = false;
      controller.run('onAction', (0, _actions.removeNewlineData)());
    }
  };

  const getMenuContainer = () => {
    return menuContainer;
  };

  _react.default.useEffect(() => {
    if (!enabled && triggered) {
      // 失焦、有选区存在时 removeNewlineData
      controller.run('onAction', (0, _actions.removeNewlineData)());
    }
  }, [controller, enabled, triggered]);

  _react.default.useEffect(() => {
    if (!enabled) {
      return;
    } // 支持光标 pending 后，需要保证最新的光标渲染完以后再计算位置，否则可能位置不正确


    if (blockKey && (isInTable || showMenu)) {
      // 根据目标位置计算光标 Rect
      // Tips: 不能依赖光标 dom 节点的位置，在 Safari 下的 useEffect、setTimeout 时序会不稳定，导致读取的位置有误
      const caret = _everCangjie.domUtils.findDOMRange(controller.value.selection, controller, container);

      const caretRect = caret?.getClientRects()[0]; // 根据块级元素和光标的位置计算控件位置，以便在任何字号、行高下都对齐光标中间

      if (caret && caretRect) {
        const {
          top: caretTop,
          height: caretHeight,
          left: caretLeft
        } = caretRect;
        const {
          top: containerTop,
          left: containerLeft
        } = container.getBoundingClientRect();
        const guideLeft = (caretLeft - containerLeft) / zoom;
        setGuideStyle({
          // 光标中间 - 段落顶部 = 控件相对段落的 top
          top: (caretTop + caretHeight / 2 - containerTop) / zoom,
          left: guideLeft
        });
        setTriggerStyle({
          width: 2,
          height: caretHeight
        }); // 这里需要获取container的padding值，然后计算出插入按钮应该在的位置
        // PS 这里应该是获取 container 下 [data-cangjie-editable] 元素的 parent 的 padding
        // 非排版模式下，这个 parent 就是 container，而在排版模式下，这个 container 与 [data-cangjie-editable] 之间有个夹层

        const editorContainerParent = container?.querySelector(`[${_everCangjie.constants.Selector.editable}]`)?.parentElement;
        let padding = 0;

        if (editorContainerParent) {
          padding = Number.parseInt(window.getComputedStyle(editorContainerParent).paddingLeft, 10);
        }
      }
    } // document.nodes、injections 需要作为依赖以便兼容某些 node 导致高度变化的情况（例如插入本地文件上传完成后自动变为预览模式）

  }, [enabled, isInTable, showMenu, blockKey, container, zoom, document.nodes, injections, query]);

  const closeContext = _react.default.useCallback(() => {
    controller.run('onAction', closeContextMenu());
  }, [controller]);

  const onQuery = _react.default.useCallback(results => {
    if (!query || !results || results.length > 0) {
      controller.run('onAction', (0, _actions.setNewlineData)({
        showMenu: true
      }));
      errorNumRef.current = 0;
      return;
    }

    controller.run('onAction', (0, _actions.setNewlineData)({
      showMenu: false
    }));

    if (errorNumRef.current > MAX_ERROR_NUM) {
      controller.run('onAction', (0, _actions.removeNewlineData)());
      errorNumRef.current = 0;
    } else {
      errorNumRef.current += 1;
    }
  }, [query, controller]);

  const guideMenu = _react.default.useMemo(() => {
    if (!enabled || !showMenu || !renderGuideMenu) return null; // 埋点：区分点击和+

    _everLogger.default.sum(`newline_insert_show_by_${uiVisible.current ? 'click' : '+'}`); // 右键菜单栏和插入工具栏需要互斥展示


    closeContext();
    return /*#__PURE__*/_createElement(_guideMenu.default, {
      withoutEmptyParagraphWhitelist: withoutEmptyParagraphWhitelist,
      query: query,
      controller: controller,
      enableKeyboard: enableKeyboard,
      onClickGuideMenu: onClickGuideMenu
    }, renderGuideMenu(query, onQuery));
  }, [enabled, showMenu, renderGuideMenu, controller, enableKeyboard, onClickGuideMenu, query, closeContext, onQuery, withoutEmptyParagraphWhitelist]);

  const [activeType, setActiveType] = useActiveInteraction();

  const activeRef = _react.default.useRef('');

  activeRef.current = activeType;

  _react.default.useEffect(() => {
    if (showMenu) {
      setActiveType('insertMenu');
    } else if (activeRef.current === 'insertMenu') {
      setActiveType('');
    }
  }, [showMenu, setActiveType]);

  if (!enabled) {
    return null;
  } // dropdown 组件placement向上位置计算存在问题


  return /*#__PURE__*/_reactDom.default.createPortal( /*#__PURE__*/_createElement(_styled.GuideWrapper, {
    style: guideStyle
  }, showMenu ? /*#__PURE__*/_createElement(_weDesign.Dropdown, {
    overlay: /*#__PURE__*/_createElement(_weUtil.DropdownAnimation, {
      visible: showMenu
    }, guideMenu),
    visible: showMenu,
    getContainer: getMenuContainer,
    onVisibleChange: handleVisibleChange,
    placement: "bottomLeft",
    overlayAutoAlign: true
  }, /*#__PURE__*/_createElement("i", {
    style: triggerStyle
  })) : null), container);
};

var _default = NewlineGuide;
exports.default = _default;
//# sourceMappingURL=newlineGuide.js.map