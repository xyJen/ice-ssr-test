"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createOnKeyUp;

var _everCangjie = require("@ali/4ever-cangjie");

var _isHotkey = require("is-hotkey");

var _newlineGuide = require("../model/newlineGuide");

var _actions = require("../actions");

const whiteList = ['ins'];

function isEmptyNode(block, defaultText = '') {
  const children = block.nodes.filter(node => {
    // 优先排除text节点的内容
    return !_everCangjie.Text.isText(node);
  }).filter(node => {
    // 过滤掉白名单的节点，例如修订模式插入的节点
    return !whiteList.includes(node.type);
  });
  return block.text === defaultText && children.length === 0;
}

const isEscHotKey = (0, _isHotkey.isKeyHotkey)('esc');
const isUndoKey = (0, _isHotkey.isKeyHotkey)('ctrl+z');
const isEqualKey = (0, _isHotkey.isKeyHotkey)('='); // 微软中文输入法下，输入斜杠，key为Process，这种场景下，选择对输入的内容进行判断

const ignoreKeyList = ['Process'];
/**
 * 因为在中文输入法下存在keydown与cangjieInput时序不可保证
 * 因此使用onKeyUp来收拢触发移除下拉菜单的逻辑
 * 下拉菜单目前触发逻辑：
 * 1.输入/触发
 * 2.在行首输入、触发
 */

function createOnKeyUp(config) {
  const newlineGuideEnabled = config.newlineGuide?.enabled;
  return (event, controller, next) => {
    if (!newlineGuideEnabled || _everCangjie.environment.IS_MOBILE) return next();

    if (controller.query('isTriggerringSnippets')) {
      return next();
    }

    const {
      composing,
      selection,
      startBlock
    } = controller.value;
    const {
      anchor,
      isCollapsed
    } = selection;
    const {
      triggered,
      point
    } = _newlineGuide.NewlineGuideData.get(controller) || {};

    if (triggered && (isEscHotKey(event) || isUndoKey(event) || anchor.key !== point?.key || anchor?.offset < point?.offset)) {
      controller.run('onAction', (0, _actions.removeNewlineData)());
    } // 特殊处理keyup事件，当+快速弹起的时候可能会触发shift和=两个事件，最终以value为准，TODO：后续需要处理仓颉底层keyup


    if (_newlineGuide.triggerKeyList.includes(event.key) || isEqualKey(event) || ignoreKeyList.includes(event.key)) {
      // 触发
      const value = event.target?.value; // 优先处理在分页模式下唤起问题，真正原因是由于在排版下从onKeyDown->onKeyUp过程中textarea被reset了，后续在底层解决该问题

      const data = value?.substr(value.length - 1) || event.key;

      if (data === _newlineGuide.NEWLINE_GUIDE_TRIGGER_CN && !isEmptyNode(startBlock, data)) {
        // 中文顿号在行中不唤起
        return next();
      }

      if (isCollapsed && startBlock && _newlineGuide.triggerList.includes(data) && !composing) {
        // 获取当前光标位置进行存储
        controller.run('onAction', (0, _actions.setNewlineData)({
          key: startBlock.key,
          triggered: true,
          point: selection.anchor,
          showMenu: true
        }));
      }
    }

    return next();
  };
}
//# sourceMappingURL=createOnKeyUp.js.map