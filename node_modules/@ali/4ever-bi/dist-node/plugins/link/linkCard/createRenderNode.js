"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createRenderNode;

var React = _interopRequireWildcard(require("react"));

var _styledComponents = _interopRequireDefault(require("styled-components"));

var _everCangjie = require("@ali/4ever-cangjie");

var _weBizLinkCard = require("@ali/we-biz-link-card");

var _actions = require("./actions");

var _getBlockLinkCardState = require("./utils/getBlockLinkCardState");

var _AnimatePortal = _interopRequireDefault(require("../components/AnimatePortal"));

var _getPosition = require("../utils/getPosition");

var _everBamboo = require("@ali/4ever-bamboo");

var _linkEditor = _interopRequireDefault(require("../components/linkEditor"));

var _zh_CN = _interopRequireDefault(require("../../../locales/zh_CN"));

const _createElement = /*#__PURE__*/React.createElement;
const {
  normalizeLink,
  openLink
} = _everBamboo.LinkPlugin;

const Wrapper = /*#__PURE__*/_styledComponents.default.div(["cursor:pointer;border-radius:9px;"]);

function LinkCardNode(props) {
  const {
    nodeProps,
    controller,
    linkConfig,
    isMobile
  } = props;
  const {
    locale = _zh_CN.default.link.locale,
    protocolAllowList = ['http:', 'https:', 'dingtalk:', 'taobao:'],
    onCopyLink,
    getLinkInfo,
    openLink: openLinkOfConfig
  } = linkConfig;
  const {
    node,
    isSelected
  } = nodeProps;
  const {
    selection
  } = controller.value;
  const {
    text,
    href,
    cardInfo
  } = node.data.metadata;
  const [editMode, setEditMode] = React.useState(false);
  const linkRef = React.useRef(null);
  const portalRef = React.useRef(null);
  const scrollableContent = (0, _everCangjie.useZoomContainer)() || document.body;
  const scrollContent = (0, _everBamboo.useScrollableContent)() || document.body;
  const zoom = (0, _everCangjie.useZoom)();
  const getContainer = React.useCallback(() => {
    return scrollContent;
  }, [scrollContent]);
  const urlInfo = React.useMemo(() => {
    const isTitleEqualsHref = text.trim() === href.trim();
    const actualTitle = isTitleEqualsHref ? cardInfo.title : text;
    return {
      title: actualTitle || '',
      desc: cardInfo.desc || '',
      imgURL: cardInfo.imgURL || ''
    };
  }, [cardInfo, text, href]);
  const linkCardLocale = React.useMemo(() => {
    const tooltipLocale = {
      editTooltip: locale.edit,
      copyTooltip: locale.copy,
      unlinkTooltip: locale.unlink,
      deleteTooltip: locale.delete,
      switchStyleTooltip: locale.styleText
    };
    return { ...locale,
      ...tooltipLocale
    };
  }, [locale]);
  const state = React.useMemo(() => {
    return (0, _getBlockLinkCardState.getBlockLinkCardState)(node);
  }, [node]);
  const handleVisit = React.useCallback(() => {
    if (openLinkOfConfig) {
      const normalizedLink = normalizeLink(href, protocolAllowList);
      openLinkOfConfig(normalizedLink);
    } else {
      openLink(href, protocolAllowList);
    }
  }, [href, protocolAllowList, openLinkOfConfig]);
  const handleCopy = React.useCallback(() => {
    // 卡片形式下，使用仓颉复制
    controller.run('onAction', (0, _actions.copyBlockLinkCard)(node));

    if (onCopyLink && typeof onCopyLink === 'function') {
      onCopyLink(href);
    }
  }, [href, onCopyLink, node, controller]);
  const handleCut = React.useCallback(() => {
    controller.run('onAction', (0, _actions.cutBlockLinkCard)(node));
  }, [controller, node]);
  const handleRemove = React.useCallback(() => {
    controller.run('onAction', (0, _actions.deleteBlockLinkCard)(node));
  }, [controller, node]);
  const handleUnlink = React.useCallback(() => {
    controller.run('onAction', (0, _actions.unlinkBlockCardData)(node));
  }, [controller, node]);
  const handleSwitchStyle = React.useCallback(e => {
    if (e === 'popup') {
      controller.run('onAction', (0, _actions.convertBlockLinkCardToTextLink)(node));
    }
  }, [controller, node]);
  const handleRefresh = React.useCallback(() => {
    controller.run('onAction', (0, _actions.updateBlockLinkCardData)(node, text, href));
  }, [controller, getLinkInfo, text, href, node]);
  const handleClickoutside = React.useCallback(event => {
    const target = event.target;

    if (target === linkRef.current || linkRef.current?.contains(target)) {
      return;
    }

    setEditMode(false);
  }, []);
  const handleEdit = React.useCallback(() => {
    setEditMode(true);
  }, []);
  const handleEditorHide = React.useCallback(() => {
    setEditMode(false);
  }, []);
  const handleSave = React.useCallback((text, href, displayType) => {
    if (displayType === 'link') {
      controller.run('onAction', (0, _actions.convertBlockLinkCardToTextLink)(node, {
        text,
        href
      }));
    } else {
      controller.run('onAction', (0, _actions.updateBlockLinkCardData)(node, text, href));
    }
  }, []);
  const overlay = React.useMemo(() => /*#__PURE__*/_createElement(_linkEditor.default, {
    ref: portalRef,
    displayType: 'card',
    nodeKey: node?.key,
    text: text.trim() === href.trim() ? '' : text,
    href: href,
    onSave: handleSave,
    onRemove: handleRemove,
    onUnlink: handleUnlink,
    locale: linkCardLocale,
    controller: controller,
    onHide: handleEditorHide,
    onClickoutside: handleClickoutside,
    enableCard: true
  }), [portalRef, node, text, href, linkCardLocale, controller, handleRemove, handleUnlink, handleEditorHide, handleClickoutside]);
  return /*#__PURE__*/_createElement(_AnimatePortal.default, {
    className: "bi-link-card-portal",
    visible: editMode,
    triggerRef: linkRef,
    overlay: overlay,
    portalMatchTrigger: false,
    container: scrollableContent,
    getPosition: _getPosition.getPositionTopRight,
    offset: [0, _getPosition.offsetY],
    zoom: zoom
  }, /*#__PURE__*/_createElement(Wrapper, null, /*#__PURE__*/_createElement(_weBizLinkCard.URLLinkCard, {
    getContainer: getContainer,
    isSelected: isSelected && selection.isCollapsed,
    cardStyle: 'indoc',
    state: state,
    url: href,
    readonly: false,
    locale: linkCardLocale,
    urlInfo: urlInfo,
    isMobile: isMobile // @ts-ignore
    ,
    onRefresh: handleRefresh,
    onCopy: handleCopy,
    onOpenURL: handleVisit,
    onSwitchStyle: handleSwitchStyle,
    onDelete: handleRemove,
    onCut: handleCut,
    onEdit: handleEdit,
    onUnlink: handleUnlink,
    editBtnTestID: "link-toolbar-edit",
    copyBtnTestID: "link-toolbar-copy",
    cutBtnTestID: "link-toolbar-cut",
    unlinkBtnTestID: "link-toolbar-unlink",
    deleteBtnTestID: "link-toolbar-remove",
    switchStyleBtnTestID: "link-toolbar-switch",
    linkStyleBtnTestID: "link-toolbar-switch-link",
    cardStyleBtnTestID: "link-toolbar-switch-card",
    cardTestID: "link-card"
  })));
}

function createRenderNode(linkConfig, isMobile) {
  return (nodeProps, controller) => {
    return /*#__PURE__*/_createElement(LinkCardNode, {
      linkConfig: linkConfig,
      isMobile: isMobile,
      nodeProps: nodeProps,
      controller: controller
    });
  };
}
//# sourceMappingURL=createRenderNode.js.map