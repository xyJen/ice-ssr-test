"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var React = _interopRequireWildcard(require("react"));

var _linkToolbar = _interopRequireDefault(require("../linkToolbar"));

var _actions = require("../../actions");

const _createElement = /*#__PURE__*/React.createElement;

const useToolbarPortal = props => {
  const {
    node,
    href = '',
    onRemove,
    onUnlink,
    controller,
    locale,
    onCopyLink,
    onCut,
    isLinkFocused,
    getLinkInfo,
    onToolbarSwitchStyle,
    onOpenlink,
    enableCard,
    onSwitchToEdit,
    showToolbar,
    portalRef,
    linkRef,
    hideToolbar,
    isPlaceholder
  } = props;
  const cardInfo = node?.data.cardInfo || {};
  const {
    title,
    imgURL,
    desc
  } = cardInfo;
  const isEmptyHref = href.trim().length === 0; // isLinkFocused 变化时主动隐藏

  React.useEffect(() => {
    // 对于占位符合首次插入链接，直接显示编辑框
    if (isLinkFocused && (isPlaceholder || isEmptyHref)) {
      onSwitchToEdit();
    }
  }, [isLinkFocused, isPlaceholder, isEmptyHref, onSwitchToEdit]);
  const handleEdit = React.useCallback(() => {
    // 清理所有状态，切换至编辑模式
    onSwitchToEdit();
    controller.run('onAction', (0, _actions.editLinkCard)());
  }, [controller, onSwitchToEdit]);
  const handleLinkMouseDown = React.useCallback(e => {
    // 仅当链接是占位符，或者空链接，点击生效，显示编辑框
    if (isPlaceholder || isEmptyHref) {
      e.stopPropagation();
      e.preventDefault();
      onSwitchToEdit();
    }

    if (isPlaceholder) {
      controller.run('onAction', (0, _actions.handleLinkPlaceholder)());
    }
  }, [controller, isPlaceholder, isEmptyHref, onSwitchToEdit]); // 正常链接点击跳转

  const handleLinkClick = React.useCallback(e => {
    if (!isPlaceholder && !isEmptyHref) {
      typeof onOpenlink === 'function' && onOpenlink();
    }
  }, [onOpenlink, isPlaceholder, isEmptyHref]);
  const handleClickoutside = React.useCallback(event => {
    const target = event.target;

    if (target === linkRef.current || linkRef.current?.contains(target)) {
      return;
    }

    hideToolbar();
  }, []);
  const overlay = React.useMemo(() => /*#__PURE__*/_createElement(_linkToolbar.default, {
    ref: portalRef,
    href: href,
    title: title,
    imgURL: imgURL,
    desc: desc,
    onEdit: handleEdit,
    onRemove: onRemove,
    onUnlink: onUnlink,
    onHide: hideToolbar,
    onCopy: onCopyLink,
    onCut: onCut,
    onOpenlink: onOpenlink,
    onClickoutside: handleClickoutside,
    getLinkInfo: getLinkInfo,
    locale: locale,
    enableCard: enableCard,
    onToolbarSwitchStyle: onToolbarSwitchStyle,
    onMouseLeave: hideToolbar,
    onMouseEnter: showToolbar,
    onCleanup: hideToolbar
  }), [portalRef, href, title, imgURL, desc, handleEdit, onRemove, onUnlink, locale, onCopyLink, onCut, enableCard, onOpenlink]);
  return {
    overlay,
    handleLinkMouseDown,
    handleLinkClick
  };
};

var _default = useToolbarPortal;
exports.default = _default;
//# sourceMappingURL=useToolbarPortal.js.map