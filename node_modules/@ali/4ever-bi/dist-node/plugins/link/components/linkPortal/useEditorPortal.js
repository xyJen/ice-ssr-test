"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var React = _interopRequireWildcard(require("react"));

var _linkEditor = _interopRequireDefault(require("../linkEditor"));

const _createElement = /*#__PURE__*/React.createElement;

// 用于记录上一次的props, 类似react lifecycle当中的preProps
function usePrevious(value) {
  const ref = React.useRef();
  React.useEffect(() => {
    ref.current = value;
  });
  return ref.current;
}

const useEditorPortal = props => {
  const {
    node,
    text,
    href = '',
    onSave,
    onRemove,
    onUnlink,
    controller,
    locale,
    isLinkFocused,
    enableCard,
    onEditorHide,
    portalRef,
    linkRef,
    isEditMode,
    isPlaceholder
  } = props;
  const nodeKey = node?.key;
  const {
    isFocused
  } = controller.value;
  const textInputRef = React.useRef();
  const hrefInputRef = React.useRef();
  const isEmptyHref = href.trim().length === 0;
  const preLinkFocused = usePrevious(isLinkFocused);
  React.useEffect(() => {
    // 占位符默认 focus 标题
    if (isEditMode && isPlaceholder) {
      textInputRef.current?.focus();
    }
  }, [textInputRef, isPlaceholder, isEditMode]);
  React.useEffect(() => {
    // 外部点击触发编辑框显示时，应该 focus 到输入框
    if (isFocused && !preLinkFocused && !isLinkFocused) {
      if (isEmptyHref) {
        // 空连接默认 focus href
        hrefInputRef.current?.focus();
      }
    }
  }, [hrefInputRef, isLinkFocused, isFocused, preLinkFocused]);
  const handleLinkMouseDown = React.useCallback(event => {
    if (isPlaceholder && isEditMode) {
      event.stopPropagation();
      event.preventDefault();
      textInputRef.current?.focus();
    }

    if (isEmptyHref && isEditMode) {
      event.stopPropagation();
      event.preventDefault();
      hrefInputRef.current?.focus();
    } // controller.run('onAction', focusLinkEditor());

  }, [textInputRef, hrefInputRef, isPlaceholder, isEditMode]); // 编辑状态下 click 正常链接，隐藏编辑框

  const handleLinkClick = React.useCallback(event => {
    if (!isPlaceholder && !isPlaceholder && isEditMode) {
      onEditorHide();
    }
  }, [isEditMode, isPlaceholder, isEmptyHref]);
  const handleClickoutside = React.useCallback(event => {
    const target = event.target;

    if (target === linkRef.current || linkRef.current?.contains(target)) {
      return;
    }

    onEditorHide();
  }, [onEditorHide]);
  const overlay = React.useMemo(() => {
    return /*#__PURE__*/_createElement(_linkEditor.default, {
      ref: portalRef,
      displayType: 'link',
      nodeKey: nodeKey,
      text: isPlaceholder ? '' : text,
      href: href,
      onSave: onSave,
      onRemove: onRemove,
      onUnlink: onUnlink,
      locale: locale,
      controller: controller,
      onHide: onEditorHide,
      onClickoutside: handleClickoutside,
      enableCard: enableCard,
      showPlaceholder: isPlaceholder,
      textInputRef: textInputRef,
      hrefInputRef: hrefInputRef
    });
  }, [portalRef, nodeKey, text, href, onSave, onRemove, onUnlink, locale, controller, enableCard, onEditorHide, handleClickoutside, isPlaceholder]);
  return {
    overlay,
    handleLinkMouseDown,
    handleLinkClick
  };
};

var _default = useEditorPortal;
exports.default = _default;
//# sourceMappingURL=useEditorPortal.js.map