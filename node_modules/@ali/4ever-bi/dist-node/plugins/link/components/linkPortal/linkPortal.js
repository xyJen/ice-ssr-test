"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var React = _interopRequireWildcard(require("react"));

var _everCangjie = require("@ali/4ever-cangjie");

var _AnimatePortal = _interopRequireDefault(require("../AnimatePortal"));

var _useEditorPortal = _interopRequireDefault(require("./useEditorPortal"));

var _useToolbarPortal = _interopRequireDefault(require("./useToolbarPortal"));

var _everComponent = require("@ali/4ever-component");

var _actions = require("../../actions");

var _weDesign = require("@ali/we-design");

const _createElement = /*#__PURE__*/React.createElement;
const offsetX = 0;
const offsetY = 6;
const offset = [offsetX, offsetY]; // toolbar 隐藏延时

const HIDE_TOOLBAR_DELAY_TIME = 150;

const getPosition = (containerRect, triggerRect, portalRect) => {
  const {
    height,
    width
  } = portalRect;
  const baseTop = triggerRect.bottom - containerRect.top;
  const baseLeft = triggerRect.left - containerRect.left; // 计算底部剩余空间，若剩余空间能够容纳 portal，则向下展示 portal
  // 如果下方剩余空间无法容纳 portal，还需要判断上方空间能否容纳
  // 若上方也无法容纳(triggerTop < height)，则仍然放到下方
  // 左右则优先放右侧，不够之后向左偏移

  const bottomSpace = containerRect.height - baseTop;
  const rightSpace = containerRect.width - baseLeft;
  const triggerTop = triggerRect.top - containerRect.top;
  const triggerRight = triggerRect.right - containerRect.left;
  const top = bottomSpace < height && triggerTop > height ? triggerTop + offsetY - height - 4 // 放到上方
  : baseTop + offsetY;
  const left = rightSpace < width && triggerRight > width ? baseLeft + offsetX - width + rightSpace - 4 : baseLeft + offsetX;
  return {
    left,
    top
  };
};

const stopEvent = event => event.stopPropagation();

const LinkPortal = props => {
  const {
    children,
    text,
    href,
    locale,
    controller,
    mountRoot = false
  } = props;
  const [portalState, setPortalState] = (0, _everComponent.useDelayedState)('Hidden');
  const [overlayChanging, setOverlayChanging] = React.useState(false);
  const [hidingOverlay, setHidingOverlay] = React.useState(null);
  const onOverlayHide = React.useCallback(() => {
    setHidingOverlay(null);
    setOverlayChanging(false);
  }, []);
  const showEditor = React.useCallback(() => {
    setPortalState('EditorVisible');
  }, []);
  const hideEditor = React.useCallback(() => {
    setPortalState(s => {
      return s === 'EditorVisible' ? 'Hidden' : s;
    });
  }, []);
  const showToolbar = React.useCallback(() => {
    setPortalState(s => {
      return s === 'Hidden' || s === 'ToolbarVisible' ? 'ToolbarVisible' : s;
    });
  }, []);
  const hideToolbar = React.useCallback(() => {
    // toolbar 隐藏时设置延时，处理链接到卡片的 hover 情况
    setPortalState(s => {
      return s === 'ToolbarVisible' ? 'Hidden' : s;
    }, HIDE_TOOLBAR_DELAY_TIME);
  }, []);
  const defaultContent = (0, _everCangjie.useZoomContainer)() || document.body;
  const scrollableContent = mountRoot ? document.body : defaultContent;
  const zoom = (0, _everCangjie.useZoom)();
  const portalRef = React.useRef(null);
  const linkRef = React.useRef(null);
  const isPlaceholder = text === locale.addLinkPlaceholder;
  const isEmptyHref = href.trim().length === 0;
  const showStopEvent = portalState === 'EditorVisible' && (isPlaceholder || isEmptyHref);
  const isNormalLink = !isPlaceholder && !isEmptyHref; // 这里在编辑模式下，显示编辑框

  const editorPortal = (0, _useEditorPortal.default)({ ...props,
    isEditMode: portalState === 'EditorVisible',
    onEditorHide: hideEditor,
    linkRef,
    portalRef,
    isPlaceholder
  });
  const toolbarPortal = (0, _useToolbarPortal.default)({ ...props,
    onSwitchToEdit: showEditor,
    showToolbar,
    hideToolbar,
    linkRef,
    portalRef,
    isPlaceholder
  });
  const {
    overlay: editorOverlay,
    handleLinkMouseDown: handleEditorLinkMouseDown,
    handleLinkClick: handleEditorLinkClick
  } = editorPortal;
  const {
    overlay: toolbarOverlay,
    handleLinkMouseDown,
    handleLinkClick
  } = toolbarPortal;
  const handleMouseEnter = React.useCallback(() => {
    showToolbar();
    controller.run('onAction', (0, _actions.hoverLinkCard)());
  }, [controller, showToolbar]);
  const overlay = portalState !== 'EditorVisible' ? toolbarOverlay : editorOverlay;
  const handleClick = portalState !== 'EditorVisible' ? handleLinkClick : handleEditorLinkClick;
  const prePortalState = (0, _weDesign.usePrevious)(portalState);
  React.useEffect(() => {
    const preVisible = prePortalState === 'EditorVisible' || prePortalState === 'ToolbarVisible';
    const currentVisible = portalState === 'EditorVisible' || portalState === 'ToolbarVisible';

    if (preVisible && !currentVisible) {
      // 进行隐藏时，使用旧的 overlay 进行隐藏，避免动画过程中组件切换
      setHidingOverlay(prePortalState !== 'EditorVisible' ? toolbarOverlay : editorOverlay);
    } else if (preVisible && currentVisible && prePortalState !== portalState) {
      // 显示状态下切换 overlay，先使用旧的 overlay 进行隐藏，再显示新的 overlay
      setOverlayChanging(true);
      setHidingOverlay(prePortalState !== 'EditorVisible' ? toolbarOverlay : editorOverlay);
    }
  }, [prePortalState, portalState]);
  return /*#__PURE__*/_createElement(_AnimatePortal.default, {
    className: "bi-link-portal",
    visible: portalState !== 'Hidden' && !overlayChanging,
    triggerRef: linkRef,
    overlay: hidingOverlay || overlay,
    portalMatchTrigger: false,
    getPosition: getPosition,
    onOverlayHide: onOverlayHide,
    container: scrollableContent,
    offset: offset,
    zoom: zoom
  }, /*#__PURE__*/React.cloneElement(children, {
    onMouseDown: portalState !== 'EditorVisible' ? handleLinkMouseDown : handleEditorLinkMouseDown,
    // 当点击占位符时，需要阻止事件冒泡，避免被 cangjie 处理
    onMouseUp: showStopEvent ? stopEvent : undefined,
    onClick: showStopEvent ? stopEvent : handleClick,
    onMouseEnter: portalState !== 'EditorVisible' && isNormalLink ? handleMouseEnter : undefined,
    onMouseLeave: portalState !== 'EditorVisible' ? hideToolbar : undefined
  }));
};

var _default = LinkPortal;
exports.default = _default;
//# sourceMappingURL=linkPortal.js.map