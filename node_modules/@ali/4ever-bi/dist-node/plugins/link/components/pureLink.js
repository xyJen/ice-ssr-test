"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var React = _interopRequireWildcard(require("react"));

var _everBamboo = require("@ali/4ever-bamboo");

var _styled = require("./styled");

var _actions = require("../actions");

var _linkPortal = _interopRequireDefault(require("./linkPortal/linkPortal"));

var _utils = require("../utils");

var _LinkCard = require("./card/LinkCard");

var _actions2 = require("../linkCard/actions");

const _createElement = /*#__PURE__*/React.createElement;
const {
  normalizeLink,
  openLink
} = _everBamboo.LinkPlugin;

const isSelectionInPureLink = (node, selection, startOffset, endOffset) => {
  const {
    anchor
  } = selection;

  if (node.key === anchor.key && selection.isCollapsed && anchor.isTextPoint()) {
    return anchor.offset >= startOffset && anchor.offset <= endOffset;
  }

  return false;
};

const PureLink = props => {
  const {
    children,
    attributes,
    controller,
    node,
    locale,
    protocolAllowList,
    onCopyLink,
    offset,
    text,
    mark,
    getLinkInfo,
    enableCard,
    openLink: openLinkOfConfig,
    enableLinkCardBlock,
    mountRoot
  } = props;
  const href = mark.data.href || text;
  const offsetInNode = mark.data.offsetInNode || offset;
  const {
    selection
  } = controller.value; // 这里需要使用 text 而不是 href 的 length，
  // 因为在 pi 中，一旦链接换行，text 会拆分为两个不同的 leaf，导致光标定位异常

  const isLinkFocus = React.useMemo(() => isSelectionInPureLink(node, selection, offset, offset + text.length), [node, selection, offset, text]);
  const handleRemove = React.useCallback(() => {
    controller.run('onAction', (0, _actions.removePureLink)(node, offsetInNode, href));
  }, [node, offsetInNode, href, controller]);
  const handleSave = React.useCallback((t, h, displayType) => {
    // 如果保存为卡片形式形式，
    if (displayType === 'card' && getLinkInfo && typeof getLinkInfo === 'function') {
      // 编辑框允许 href 或 text 为空字符串，转为卡片时需要保证都不为空
      const fixedHref = h.length > 0 ? h : t;
      const fixedText = t.length > 0 ? t : h; // 请求前先填充 undefined 信息，确保数据层识别为卡片，解决 loading 时排版问题
      // todo 排版 2.0 后删除下面代码

      if (enableLinkCardBlock) {
        controller.run('onAction', (0, _actions2.convertPureLinkToBlockLinkCard)(node, offsetInNode, fixedText, fixedHref, href, {
          displayType
        }, true));
      } else {
        controller.run('onAction', (0, _actions.updatePureLinkWithCardInfo)(node, offsetInNode, fixedText, fixedHref, href, {
          displayType
        }, true));
      }
    } else {
      controller.run('onAction', (0, _actions.updatePureLink)(node, offsetInNode, t, h, href));
    }

    controller.run('onCangjieFocus');
  }, [node, offsetInNode, href, controller, getLinkInfo, enableLinkCardBlock]);
  const onToolbarSwitchStyle = React.useCallback((newHref, displayType, title, desc, imgURL) => {
    // 当 displayType 为 link 时，没有发生 url 转卡片，不保存 CardInfo
    if (displayType === 'card') {
      const cardInfo = {
        imgURL,
        title,
        desc,
        displayType
      };

      if (enableLinkCardBlock) {
        controller.run('onAction', (0, _actions2.convertPureLinkToBlockLinkCard)(node, offsetInNode, text, newHref, newHref, cardInfo));
      } else {
        controller.run('onAction', (0, _actions.updatePureLinkWithCardInfo)(node, offsetInNode, text, newHref, newHref, cardInfo));
      }
    }
  }, [controller, href, node, offsetInNode, text, enableLinkCardBlock]);
  const handleUnlink = React.useCallback(() => {
    controller.run('onAction', (0, _actions.unwrapPureLink)(node, offsetInNode, href));
  }, [node, offsetInNode, href, controller]);
  const handleVisit = React.useCallback(() => {
    if (openLinkOfConfig) {
      const normalizedLink = normalizeLink(href, protocolAllowList);
      openLinkOfConfig(normalizedLink);
    } else {
      openLink(href, protocolAllowList);
    }
  }, [href, protocolAllowList, openLinkOfConfig]);
  const handleCopy = React.useCallback(() => {
    // 卡片形式下，使用仓颉复制
    (0, _everBamboo.copyToClipboard)(href, onCopyLink);
  }, [href, onCopyLink]);
  const handleCut = React.useCallback(() => {
    controller.run('onAction', (0, _actions.cutPureLink)(node, offsetInNode, href));
  }, [node, offsetInNode, href, controller]);
  const {
    injections
  } = controller.value;
  const showCard = (0, _utils.getCardInfo)(node, injections)?.displayType === 'card';
  return /*#__PURE__*/_createElement(React.Fragment, null, enableCard && showCard ? /*#__PURE__*/_createElement(_styled.LinkCardWrapper, attributes, /*#__PURE__*/_createElement(_LinkCard.LinkCard, {
    state: 'loading',
    href: href,
    displayType: 'card',
    controller: controller,
    readonly: false,
    isMobile: false,
    locale: locale
  })) : /*#__PURE__*/_createElement(_linkPortal.default, {
    controller: controller,
    locale: locale,
    text: "",
    href: href,
    onSave: handleSave,
    onRemove: handleRemove,
    onUnlink: handleUnlink,
    onCopyLink: handleCopy,
    onCut: handleCut,
    getLinkInfo: getLinkInfo,
    onToolbarSwitchStyle: onToolbarSwitchStyle,
    onOpenlink: handleVisit,
    enableCard: enableCard,
    isLinkFocused: isLinkFocus,
    mountRoot: mountRoot
  }, /*#__PURE__*/_createElement(_styled.Link, (0, _extends2.default)({}, attributes, {
    "data-type": "link",
    "data-testid": "pure-link",
    className: "link"
  }), children())));
};

var _default = PureLink;
exports.default = _default;
//# sourceMappingURL=pureLink.js.map