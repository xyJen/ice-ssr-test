"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var React = _interopRequireWildcard(require("react"));

var _everBamboo = require("@ali/4ever-bamboo");

var _weDesign = require("@ali/we-design");

var _styled = require("./styled");

var _actions = require("../actions");

var _linkPortal = _interopRequireDefault(require("./linkPortal/linkPortal"));

var _LinkCardPortal = _interopRequireDefault(require("./card/LinkCardPortal"));

var _utils = require("../utils");

var _actions2 = require("../linkCard/actions");

var _weToolbar = require("@ali/we-toolbar");

const _createElement = /*#__PURE__*/React.createElement;
const {
  normalizeLink,
  openLink
} = _everBamboo.LinkPlugin;

var _ref = /*#__PURE__*/_createElement(_weDesign.ToolbarLinkNormal, {
  className: "link-placeholder-icon"
});

const TextLink = props => {
  const {
    controller,
    node,
    locale,
    attributes,
    children,
    protocolAllowList,
    onCopyLink,
    getLinkInfo,
    isSelected,
    displayType: defaultDisplayType,
    enableCard,
    draggable,
    openLink: openLinkOfConfig,
    enableLinkCardBlock,
    mountRoot
  } = props;
  const {
    selection,
    document
  } = controller.value;
  const {
    href = '',
    cardInfo
  } = node.data;
  const {
    title: cardTitle,
    imgURL: cardImgURL,
    desc: cardDesc
  } = cardInfo || {};
  const text = controller.query('getText', {
    node
  }) || '';
  const handleRemove = React.useCallback(() => {
    controller.run('onAction', (0, _actions.removeLink)(node));
  }, [controller, node]);
  const handleCut = React.useCallback(() => {
    controller.run('onAction', (0, _actions.cutLink)(node));
  }, [controller, node]);
  const handleSave = React.useCallback(async (newText, newHref, displayType) => {
    // 编辑框允许 href 或 text 为空字符串，转为卡片时需要保证都不为空
    const fixedHref = newHref.length > 0 ? newHref : newText;
    const fixedText = newText.length > 0 ? newText : newHref; // 如果保存为卡片形式形式，

    if (displayType === 'card' && getLinkInfo && typeof getLinkInfo === 'function') {
      // 保存为卡片
      if (enableLinkCardBlock) {
        // 保存为 block linkCard
        controller.run('onAction', (0, _actions2.convertTextLinkToBlockLinkCard)(node, fixedText, fixedHref));
      } else {
        // 保存为 inline linkCard
        controller.run('onAction', (0, _actions.saveLinkCard)(node, fixedText, fixedHref));
      }
    } else if (defaultDisplayType === 'card') {
      controller.run('onAction', (0, _actions.updateLinkWithCardInfo)(node, fixedText, fixedHref, {
        displayType: 'link'
      }));
    } else {
      controller.run('onAction', (0, _actions.updateLink)(node, newText, newHref));
    }

    controller.run('onCangjieFocus');
  }, [controller, node, defaultDisplayType, getLinkInfo, enableLinkCardBlock]);
  const handleRefresh = React.useCallback(async () => {
    if (getLinkInfo && typeof getLinkInfo === 'function') {
      // 先设置卡片状态为 loading，刷新无需为节点注入信息
      controller.run('onAction', (0, _actions.injectCardInfo)(node, {
        displayType: 'card'
      }));

      try {
        const info = await getLinkInfo(href);

        if (info) {
          // 请求成功
          const {
            imgURL,
            title,
            desc
          } = info;
          const newInfo = {
            imgURL,
            title,
            desc,
            displayType: 'card'
          };
          controller.run('onAction', (0, _actions.removeInjectCardInfo)(node));
          controller.run('onAction', (0, _actions.updateLinkWithCardInfo)(node, text, href, newInfo));
          controller.run('onCangjieFocus'); // 清理临时状态

          return;
        }
      } catch (e) {} // 请求失败,将状态设置为 error，数据填充 undefined


      controller.run('onAction', (0, _actions.removeInjectCardInfo)(node));
      controller.run('onAction', (0, _actions.updateLinkWithCardInfo)(node, text, href, {
        displayType: 'card'
      }));
    }

    controller.run('onCangjieFocus');
  }, [controller, getLinkInfo, text, href, node]);
  const handleToolbarSwitchStyle = React.useCallback((newHref, displayType, title, desc, imgURL) => {
    // 当 displayType 为 link 时，没有发生 url 转卡片，不保存 CardInfo
    if (displayType === 'link') {
      controller.run('onAction', (0, _actions.switchDisplayType)(node, displayType));
    } else {
      const newInfo = {
        imgURL,
        title,
        desc,
        displayType
      };

      if (enableLinkCardBlock) {
        // 保存为 block linkCard
        controller.run('onAction', (0, _actions2.convertTextLinkToBlockLinkCard)(node, text, newHref, newInfo));
      } else {
        // 保存为 inline linkCard
        controller.run('onAction', (0, _actions.switchLink2Card)(node, text, newHref, newInfo));
      }
    }
  }, [controller, node, text, enableLinkCardBlock]);
  const handleUnlink = React.useCallback(() => {
    const isPlaceholder = text === locale.addLinkPlaceholder && href === '';

    if (isPlaceholder) {
      // 在占位符进行取消链接时，直接执行删除，来自：https://work.aone.alibaba-inc.com/issue/34949369
      controller.run('onAction', (0, _actions.removeLink)(node));
    } else {
      controller.run('onAction', (0, _actions.unwrapLinkCard)(node));
    }
  }, [controller, node, text]);
  const handleVisit = React.useCallback(() => {
    const isCollapsed = controller.value.selection.isCollapsed;
    if (!isCollapsed) return;

    if (openLinkOfConfig) {
      const normalizedLink = normalizeLink(href, protocolAllowList);
      openLinkOfConfig(normalizedLink);
    } else {
      openLink(href, protocolAllowList);
    }
  }, [href, protocolAllowList, openLinkOfConfig]);
  const handleCopy = React.useCallback(() => {
    // 卡片形式下，使用仓颉复制
    controller.run('onAction', (0, _actions.copyLink)(node));

    if (onCopyLink && typeof onCopyLink === 'function') {
      onCopyLink(href);
    }
  }, [href, onCopyLink, node, controller]);
  const isLinkFocused = React.useMemo(() => {
    return controller.value.isFocused && isSelected && selection && selection.isCollapsed;
  }, [controller.value.isFocused, isSelected, selection]); // 当节点的文本为占位符文本时，显示占位符样式；其余情况显示默认链接样式

  const showPlaceholder = text === locale.addLinkPlaceholder && href === '';

  const link = /*#__PURE__*/_createElement(_styled.Link, (0, _extends2.default)({}, attributes, {
    "data-type": "link",
    "data-testid": "link",
    className: "link"
  }), children());

  const {
    fontSize: maxSz
  } = React.useMemo(() => controller.query('getLinkMaxSz', {
    node
  }), [node, controller]);
  const firstPart = (0, _everBamboo.isFirstPart)(node);

  const placeholdLink = /*#__PURE__*/_createElement(_styled.PlaceholerLinkWrapper, (0, _extends2.default)({}, attributes, {
    "data-type": "link",
    "data-testid": "link"
  }), /*#__PURE__*/_createElement(_weToolbar.InlinePlaceholder, {
    icon: firstPart ? _ref : null,
    type: "normal",
    isSelected: isLinkFocused,
    style: {
      fontSize: maxSz
    }
  }, children()));

  const {
    injections
  } = controller.value;
  const showCard = (0, _utils.getCardInfo)(node, injections)?.displayType === 'card';
  const cardState = (0, _utils.getLinkCardState)(false, node, injections);
  const isTitleEqualsHref = text.trim() === href.trim();
  const cardText = isTitleEqualsHref ? '' : text;
  const actualTitle = isTitleEqualsHref ? cardTitle : text;
  return showCard || defaultDisplayType === 'card' ? /*#__PURE__*/_createElement(_styled.LinkCardWrapper, null, /*#__PURE__*/_createElement(_LinkCardPortal.default, (0, _extends2.default)({}, props, {
    controller: controller,
    locale: locale,
    onSave: handleSave,
    onRemove: handleRemove,
    onCut: handleCut,
    onUnlink: handleUnlink,
    href: href,
    text: cardText,
    title: actualTitle,
    state: cardState,
    displayType: defaultDisplayType,
    isSelected: isSelected,
    readonly: false,
    isMobile: false,
    imgURL: cardImgURL,
    desc: cardDesc,
    onOpenLink: handleVisit,
    onRefresh: handleRefresh,
    onCopyLink: handleCopy,
    node: node,
    attributes: attributes,
    draggable: draggable,
    enableCard: enableCard
  }))) : /*#__PURE__*/_createElement(_linkPortal.default, {
    controller: controller,
    node: node,
    href: href,
    text: cardText,
    locale: locale,
    onSave: handleSave,
    onCut: handleCut,
    onRemove: handleRemove,
    onUnlink: handleUnlink,
    onOpenlink: handleVisit,
    onCopyLink: handleCopy,
    getLinkInfo: getLinkInfo,
    isLinkFocused: isLinkFocused,
    onToolbarSwitchStyle: handleToolbarSwitchStyle,
    enableCard: enableCard,
    mountRoot: mountRoot
  }, showPlaceholder ? placeholdLink : link);
};

var _default = TextLink;
exports.default = _default;
//# sourceMappingURL=textLink.js.map