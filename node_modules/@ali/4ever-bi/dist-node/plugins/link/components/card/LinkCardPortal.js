"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var React = _interopRequireWildcard(require("react"));

var _everCangjie = require("@ali/4ever-cangjie");

var _AnimatePortal = _interopRequireDefault(require("../AnimatePortal"));

var _linkEditor = _interopRequireDefault(require("../linkEditor"));

var _actions = require("../../actions");

var _styled = require("../styled");

var _LinkCard = require("./LinkCard");

var _getPosition = require("../../utils/getPosition");

const _createElement = /*#__PURE__*/React.createElement;

const LinkCardPortal = props => {
  const {
    node,
    text,
    href = '',
    onSave,
    onRemove,
    onUnlink,
    onCut,
    onCopyLink,
    controller,
    locale,
    draggable,
    attributes,
    enableCard
  } = props;
  const nodeKey = node?.key;
  const [visible, setVisible] = React.useState(false);
  const portalRef = React.useRef(null);
  const linkRef = React.useRef(null);
  const isLinkCardSelected = controller.query('isLinkCardSelected', {
    node
  });
  const scrollableContent = (0, _everCangjie.useZoomContainer)() || document.body;
  const zoom = (0, _everCangjie.useZoom)();
  const handleEdit = React.useCallback(() => {
    setVisible(true);
    controller.run('onAction', (0, _actions.editLinkCard)());
  }, [controller]);
  const handleEditorHide = React.useCallback(() => {
    setVisible(false);
  }, []);
  const handleClickoutside = React.useCallback(event => {
    const target = event.target;

    if (target === linkRef.current || linkRef.current?.contains(target)) {
      return;
    }

    setVisible(false);
  }, []);
  const handleSwitchStyle = React.useCallback(e => {
    if (e === 'link') {
      controller.run('onAction', (0, _actions.switchDisplayType)(node, 'link'));
    }
  }, [controller, node]);
  const renderCard = React.useMemo(() => {
    return /*#__PURE__*/_createElement(_styled.LinkCardWrapper, attributes, /*#__PURE__*/_createElement(_LinkCard.LinkCard, (0, _extends2.default)({}, props, {
      href: href,
      readonly: false,
      isMobile: false,
      isSelected: isLinkCardSelected,
      onEdit: handleEdit,
      onDelete: onRemove,
      onCut: onCut,
      onSwitchStyle: handleSwitchStyle,
      onCopy: onCopyLink
    })));
  }, [attributes, props, href, isLinkCardSelected, handleEdit, onRemove, onCut, handleSwitchStyle, onCopyLink]);

  const overlay = /*#__PURE__*/_createElement(_linkEditor.default, {
    ref: portalRef,
    displayType: 'card',
    nodeKey: nodeKey,
    text: text,
    href: href,
    onSave: onSave,
    onRemove: onRemove,
    onUnlink: onUnlink,
    locale: locale,
    controller: controller,
    onHide: handleEditorHide,
    onClickoutside: handleClickoutside,
    enableCard: enableCard
  });

  return /*#__PURE__*/_createElement(_AnimatePortal.default, {
    className: "bi-link-card-portal",
    visible: visible,
    triggerRef: linkRef,
    overlay: overlay,
    portalMatchTrigger: false,
    container: scrollableContent,
    getPosition: _getPosition.getPositionTopLeft,
    offset: [0, _getPosition.offsetY],
    zoom: zoom
  }, renderCard);
};

var _default = LinkCardPortal;
exports.default = _default;
//# sourceMappingURL=LinkCardPortal.js.map