"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = onCangjieCopyOrCut;

var _everCangjie = require("@ali/4ever-cangjie");

var _utils = require("../utils");

const {
  MIME_TYPES
} = _everCangjie.constants;

function onCangjieCopyOrCut(event, controller, next) {
  if (!event.clipboardData) {
    return next();
  }

  const {
    document,
    selection
  } = controller.value;
  const {
    anchor,
    focus
  } = selection;
  const inline = document.getClosestInline(anchor.key); // 如果最近的节点不是卡片节点，直接返回

  if (!inline || !(0, _utils.isLinkNode)(inline)) {
    return next();
  }

  if (anchor.isInNode(inline) && focus.isInNode(inline)) {
    const newSelection = selection.moveToRangeOfNode(inline, controller);
    /**
     * linkcard 是一个伪 void 节点。
     * 在 cangjie 的 onClick 事件中，针对 void 节点，会将光标移至节点末尾 packages/cangjie/src/plugins/core.tsx 200:1
     * 导致在 copy 过程中，selection 是 isCollapsed 的，复制的 fragment 获得的是没有 text 内容的片段。
     * 从而用户复制的 linkcard，会丢失标题。
     * 这里覆盖默认 copy 逻辑，将真实的 fragment 注入
     */

    const fragment = document.getFragmentAtRange(newSelection);

    if (typeof inline.data.href === 'string') {
      return next(event.setClipboardData(event.clipboardData.setData(MIME_TYPES.TEXT, inline.data.href).setData(MIME_TYPES.FRAGMENT, _everCangjie.transferUtils.encodeFragment(fragment))));
    }
  }

  return next();
}
//# sourceMappingURL=onCangjieCopyorCut.js.map