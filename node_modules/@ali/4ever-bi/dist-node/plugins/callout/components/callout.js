"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var React = _interopRequireWildcard(require("react"));

var _lodash = require("lodash");

var _everCangjie = require("@ali/4ever-cangjie");

var _everBamboo = require("@ali/4ever-bamboo");

var _everMo = require("@ali/4ever-mo");

var _everComponent = require("@ali/4ever-component");

var _weDesignNext = require("@ali/we-design-next");

var _weDesign = require("@ali/we-design");

var _everUtils = require("@ali/4ever-utils");

var _everPluginSticker = require("@ali/4ever-plugin-sticker");

var _actions = require("../actions");

var _InnerToolbar = _interopRequireDefault(require("./InnerToolbar"));

var _utils = require("../utils");

const _createElement = /*#__PURE__*/React.createElement;
const {
  StickerItem
} = _everBamboo.StickerPlugin;
const {
  CalloutBoxWrapper,
  CalloutBox,
  ContentBox,
  StickerBox,
  StickerInnerBox,
  DEFAULTS,
  STICKER_SIZE,
  PADDING_TOP
} = _everBamboo.CalloutPlugin;

/**
 * 高亮区块
 * @param props
 * @returns
 */
const Callout = props => {
  const {
    controller,
    node,
    attributes,
    children,
    sticker,
    locale
  } = props;
  const contentBoxRef = React.useRef();
  const stickerBoxRef = React.useRef();
  const disableInlineToolbar = controller.query('hasHoverToolbar', 'callout');
  const {
    bgcolor = DEFAULTS.bgcolor,
    sticker: stickerCode = DEFAULTS.stcode,
    border,
    color,
    showSticker
  } = React.useMemo(() => {
    if ((0, _utils.isCallout)(node)) {
      const {
        calloutPr
      } = node.data;
      return {
        bgcolor: calloutPr?.backgroundColor,
        sticker: calloutPr?.stickerCode,
        showSticker: true
      };
    } else {
      const {
        metadata
      } = node.data;
      return { ...metadata,
        showSticker: Boolean(metadata.showstk)
      };
    }
  }, [node]); // 边框色默认为背景色, 使边框和文字对齐

  let borderColor = border || bgcolor;

  if (!border && bgcolor === '#FFFFFF') {
    borderColor = DEFAULTS.whiteBorder;
  }

  const ref = React.useRef(null);
  const [stickerTop, setStickerTop] = React.useState(0);
  const zoom = (0, _everCangjie.useZoom)();
  const [showStickerPanel, setShowStickerTop] = React.useState(false);
  const [showInnerToolbar, setShowInnerToolbar] = React.useState(false);
  React.useEffect(() => {
    if ((0, _utils.isCallout)(node)) {
      const keys = node.nodes.map(n => n.key);
      controller.run('onAction', (0, _actions.convertKeysToContainer)({
        keys
      }));
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, []);
  React.useEffect(() => {
    if (!_everMo.ColorBlocks.isColorBlocks(node)) {
      return;
    }
    /**
     * 背景：
     * 排版下，突然出现 node.nodes 是空数组的临时状态，可能和 task 调度有关系
     * 目前排查下来，非常难定位，暂时忽略这个 case
     *
     * hotfix：排版下，暂时不执行这里的逻辑
     *
     */


    if (node.key.indexOf('-') >= 0) {
      return;
    }

    const {
      nodes = []
    } = node;

    if (!nodes.length || nodes.every(n => !_everCangjie.Block.isBlock(n))) {
      controller.run('onAction', (0, _actions.deleteCallout)({
        node
      }));
    }
  }, [node, controller]);
  React.useEffect(() => {
    if (stickerBoxRef.current && node.nodes[0]) {
      const rect = (0, _everUtils.getRectOfNodeFirstText)(node.nodes[0]);
      const stickerRect = stickerBoxRef.current?.getBoundingClientRect();

      if (rect && rect.height && stickerRect) {
        const newTop = rect.top / zoom - stickerRect.top / zoom - PADDING_TOP + (rect.height / zoom - STICKER_SIZE) / 2 - 1;
        setStickerTop(Math.round(newTop));
      }
    }
  }, [node, stickerBoxRef, zoom]);
  const triggerSetSticker = React.useCallback(({
    code
  }) => {
    setShowStickerTop(false);
    controller.run('onAction', (0, _actions.setCalloutStickerCode)({
      node,
      stickerCode: code
    }));
  }, [controller, node, setShowStickerTop]);
  const updateInnerToolbar = React.useCallback((0, _lodash.throttle)(event => {
    const {
      target
    } = event;

    if (!(target instanceof HTMLElement)) {
      return;
    }

    const forceHide = target.closest('[data-istasklist]');
    const panel = target.closest('[data-color-select-panel]');
    const showIt = !panel || panel === ref.current;
    const isShow = !forceHide && showIt;

    if (showInnerToolbar !== isShow) {
      setShowInnerToolbar(isShow);
    }
  }, 100, {
    trailing: true
  }), [showInnerToolbar]);
  const handleMouseMove = React.useCallback(event => {
    if (_everCangjie.environment.IS_MOBILE) {
      return;
    }

    event.persist();
    updateInnerToolbar(event);
  }, [updateInnerToolbar]);
  const handleHideInnerToolbar = React.useCallback(() => {
    updateInnerToolbar.cancel();
    setShowInnerToolbar(false);
  }, [updateInnerToolbar]);
  const enableBorderHighlight = React.useMemo(() => controller.query('enableBorderHighlight'), []);
  const [isHover, hoverHandlers] = (0, _everComponent.useHover)(enableBorderHighlight, {
    onMouseLeave: handleHideInnerToolbar
  });
  const scrollContent = (0, _everBamboo.useScrollableContent)() || window.document.body; // 如果不这样做，还有一种做法参考现在的 setStickerPanelVisible,
  // 通过 action 触发显示隐藏，在 controller.data 里面存状态
  // 个人不认可这种做法

  React.useEffect(() => {
    window.document.addEventListener('keydown', handleHideInnerToolbar);
    return () => {
      window.document.removeEventListener('keydown', handleHideInnerToolbar);
    };
  }, [controller, handleHideInnerToolbar]);

  const showRightToolbar = _everMo.ColorBlocks.isColorBlocks(node);

  const toggleStickerPanelVisible = React.useCallback(() => {
    setShowStickerTop(!showStickerPanel);
  }, [showStickerPanel]);
  return /*#__PURE__*/_createElement(CalloutBoxWrapper, attributes, /*#__PURE__*/_createElement(CalloutBox, (0, _extends2.default)({
    ref: ref,
    className: "callout-box",
    "data-callout-group": true,
    "data-color-select-panel": true,
    backgroundColor: bgcolor,
    borderColor: borderColor,
    selected: false
  }, hoverHandlers, {
    onMouseMove: handleMouseMove,
    onMouseDown: () => {},
    onClick: () => {},
    "data-hover-box": "borderBox",
    isHover: isHover
  }), !disableInlineToolbar && showRightToolbar && /*#__PURE__*/_createElement(_InnerToolbar.default, {
    color: color,
    bgcolor: bgcolor,
    border: border,
    locale: locale,
    showSticker: showSticker,
    controller: controller,
    node: node,
    showInnerToolbar: showInnerToolbar
  }), Boolean(showSticker) &&
  /*#__PURE__*/
  // we-design-next tooltip 有 bug, 点击 popover 内的表情后不消失，这里先用 we-design 的
  _createElement(_weDesign.Tooltip, {
    title: locale?.switchEmoji,
    placement: "bottom",
    zIndex: 900
  }, /*#__PURE__*/_createElement(StickerBox, {
    className: "callout-sticker-box",
    ref: stickerBoxRef
  }, /*#__PURE__*/_createElement(_weDesignNext.Popover, {
    visible: showStickerPanel,
    trigger: "click",
    getContainer: () => scrollContent // StickerPanel 本身有 memo
    ,
    content: /*#__PURE__*/_createElement(_everPluginSticker.StickerPanel, {
      sticker: sticker,
      columns: _everPluginSticker.STICKER_PANEL_COLUMMS,
      onClick: triggerSetSticker
    }),
    onVisibleChange: v => {
      setShowStickerTop(v);
    },
    placement: "bottom",
    style: {
      zIndex: 1000
    }
  }, /*#__PURE__*/_createElement(StickerInnerBox, {
    style: {
      top: stickerTop
    }
  }, /*#__PURE__*/_createElement(StickerItem, {
    sz: STICKER_SIZE,
    code: stickerCode,
    sticker: sticker,
    onClick: toggleStickerPanelVisible
  }))))), /*#__PURE__*/_createElement(ContentBox, {
    "data-container-block": true,
    showSticker: showSticker,
    ref: contentBoxRef
  }, children)));
};

Callout.displayName = 'Callout';
var _default = Callout;
exports.default = _default;
//# sourceMappingURL=callout.js.map