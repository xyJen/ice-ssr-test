"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createRenderContent;

var React = _interopRequireWildcard(require("react"));

var _everCangjie = require("@ali/4ever-cangjie");

var _actions = _interopRequireDefault(require("../actions"));

const _createElement = /*#__PURE__*/React.createElement;

/**
 * 这里使用默认的 db click 非常容易误触。
 * 参考了飞书的行为，把触发的参数控制的非常严格
 */

/**
 * 连续两次 touch 之间的最大间隔时间 ms
 * 和飞书对比，300 明显偏大，200 明显偏小。250 感觉还是偏大，暂用
 */
const DB_CLICK_TIME = 250; // 连续两次 touch 之间的最大间隔距离 px

const DB_CLICK_PX = 15; // touch start 和 end 之间，移动超过 px 就判定无效

const DB_CLICK_SCROLL_PX = 1;
const OFFSET_NONE = -1000;
let lastMouseDown = 0;
let lastClick = {
  time: 0,
  x: OFFSET_NONE,
  y: OFFSET_NONE
};

function isElementInContent(element, key) {
  const content = element.closest(`[${_everCangjie.constants.Selector.content}]`);

  if (!content || !content.querySelector(`[${_everCangjie.constants.Selector.key}="${key}"]`)) {
    return false;
  }

  return true;
}

function DbClick({
  controller,
  configs
}) {
  React.useEffect(() => {
    const handleTouchStart = event => {
      timer && clearTimeout(timer);
      const {
        isFocused,
        document
      } = controller.value;

      if (isFocused) {
        return;
      }

      const {
        target,
        touches
      } = event;

      if (!(target instanceof HTMLElement) || !touches.length) {
        return;
      }

      if (!isElementInContent(target, document.key)) {
        return;
      } // hack, to be removed later


      const isHitTitle = target instanceof HTMLTextAreaElement && target.closest('#doc-title-area');
      const {
        clientX,
        clientY
      } = touches[0];
      const now = Date.now();
      const timeCount = now - lastClick.time;
      const xCount = Math.abs(clientX - lastClick.x);
      const yCount = Math.abs(clientY - lastClick.y);
      const hitTest = timeCount < DB_CLICK_TIME && xCount < DB_CLICK_PX && yCount < DB_CLICK_PX;

      if (hitTest) {
        controller.run('onAction', {
          type: _actions.default.EXIT,
          payload: {
            noScroll: true,
            noFocus: isHitTitle
          }
        });

        if (isHitTitle) {
          target.focus();
        }
      } else if (isHitTitle) {
        event.preventDefault();
      }

      lastClick = {
        time: now,
        x: clientX,
        y: clientY
      };
    };

    const handleTouchEnd = event => {
      if (controller.value.isFocused) {
        return;
      }

      const {
        target,
        changedTouches
      } = event;

      if (!(target instanceof HTMLElement) || !changedTouches.length) {
        return;
      }

      const {
        clientX,
        clientY
      } = changedTouches[0];
      const xCount = Math.abs(clientX - lastClick.x);
      const yCount = Math.abs(clientY - lastClick.y);

      if (xCount > DB_CLICK_SCROLL_PX || yCount > DB_CLICK_SCROLL_PX) {
        // 发生了滚动，重置掉
        lastClick.time = 0;
      }

      lastClick.x = clientX;
      lastClick.y = clientY;
    };

    let timer = null;

    const handleClick = event => {
      if (!(event.target instanceof HTMLElement)) {
        return;
      }

      const {
        document
      } = controller.value;

      if (!isElementInContent(event.target, document.key)) {
        return;
      }

      timer = setTimeout(() => {
        if (configs?.onPreviewClick) {
          configs.onPreviewClick();
        }
      }, DB_CLICK_TIME * 2);
    };

    const handleMousedown = event => {
      if (!_everCangjie.environment.IS_IPAD) {
        return;
      }

      const isHitTitle = event.target instanceof HTMLTextAreaElement && event.target.closest('#doc-title-area');
      const currentTime = Date.now();
      const hitTest = currentTime - lastMouseDown < DB_CLICK_TIME;

      if (hitTest) {
        controller.run('onAction', {
          type: _actions.default.EXIT,
          payload: {
            noScroll: true,
            noFocus: isHitTitle
          }
        });

        if (isHitTitle) {
          event.target.focus();
        }

        lastMouseDown = 0;
      } else {
        lastMouseDown = Date.now();
        isHitTitle && event.preventDefault();
      }
    };

    window.document.addEventListener('touchstart', handleTouchStart, {
      passive: false
    });
    window.document.addEventListener('touchend', handleTouchEnd);
    window.document.addEventListener('touchcancel', handleTouchEnd);
    window.document.addEventListener('mousedown', handleMousedown);
    window.document.addEventListener('click', handleClick);
    return () => {
      timer && clearTimeout(timer);
      window.document.removeEventListener('touchstart', handleTouchStart);
      window.document.removeEventListener('touchend', handleTouchEnd);
      window.document.removeEventListener('touchcancel', handleTouchEnd);
      window.document.removeEventListener('mousedown', handleMousedown);
      window.document.removeEventListener('click', handleClick);
    };
  }, [controller]);
  return null;
}

function createRenderContent(configs) {
  return function renderContent(props, controller, next) {
    const isQuickPreview = Boolean(controller.query('isQuickPreview'));
    return /*#__PURE__*/_createElement(React.Fragment, null, isQuickPreview && /*#__PURE__*/_createElement(DbClick, {
      controller: controller,
      configs: configs
    }), next());
  };
}
//# sourceMappingURL=createRenderContent.js.map