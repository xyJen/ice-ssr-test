{"version":3,"sources":["../../../../../src/plugins/sticker/utils/getCaretPosition.ts"],"names":["EXTRA_OFFSET_TOP","EXTRA_OFFSET_LEFT","EXTRA_OFFSET_RIGHT","CARET_SCALE","NARROW_GAP","corretCaretPoint","controller","selection","document","value","point","getStart","getClosestVoid","key","getParent","type","query","Queries","pointAtDistance","positionCache","getCaretPosition","rect","zoom","panelHeight","panelWidth","pointCorrected","position","domUtils","findCaretPosition","originLeft","clientLeft","left","originTop","clientTop","top","holderHeight","height","rectWidth","width","rectHeight","isAtRight","topWhenShowUp","isAtBottom"],"mappings":";;;;;;;;AAAA;;AAMA,MAAMA,gBAAgB,GAAG,CAAzB;AACA,MAAMC,iBAAiB,GAAG,CAA1B;AACA,MAAMC,kBAAkB,GAAG,EAA3B;AACA,MAAMC,WAAW,GAAG,GAApB;AACA,MAAMC,UAAU,GAAG,CAAnB;AAEA;AACA;AACA;;AACO,SAASC,gBAAT,CAA0BC,UAA1B,EAAkD;AACvD,QAAM;AAAEC,IAAAA,SAAF;AAAaC,IAAAA;AAAb,MAA0BF,UAAU,CAACG,KAA3C;AACA,QAAMC,KAAK,GAAGH,SAAS,CAACI,QAAV,CAAmBH,QAAnB,CAAd;;AACA,MACEA,QAAQ,CAACI,cAAT,CAAwBF,KAAK,CAACG,GAA9B,EAAmCP,UAAnC,KACAE,QAAQ,CAACM,SAAT,CAAmBJ,KAAK,CAACG,GAAzB,GAA+BE,IAA/B,KAAwC,MAF1C,EAGE;AACA,WAAOT,UAAU,CAACU,KAAX,CAAiBC,qBAAQC,eAAzB,EAA0CR,KAA1C,EAAiD,CAAC,CAAlD,CAAP;AACD;;AACD,SAAOA,KAAP;AACD;;AAUD,IAAIS,aAAa,GAAG,IAApB;;AAEO,SAASC,gBAAT,CAA0B;AAC/Bd,EAAAA,UAD+B;AAE/Be,EAAAA,IAF+B;AAG/BC,EAAAA,IAH+B;AAI/BC,EAAAA,WAJ+B;AAK/BC,EAAAA;AAL+B,CAA1B,EAMe;AACpB,QAAMC,cAAc,GAAGpB,gBAAgB,CAACC,UAAD,CAAvC;;AACA,QAAMoB,QAAQ,GAAGC,sBAASC,iBAAT,CAA2BH,cAA3B,CAAjB;;AACA,MAAIC,QAAJ,EAAc;AACZ;AACAP,IAAAA,aAAa,GAAGO,QAAhB;AACD,GAHD,MAGO;AACL,WAAOP,aAAP;AACD;;AAED,QAAMU,UAAU,GAAG,CAACH,QAAQ,CAACI,UAAT,GAAsBT,IAAI,CAACU,IAA5B,IAAoCT,IAAvD;AACA,QAAMU,SAAS,GAAG,CAACN,QAAQ,CAACO,SAAT,GAAqBZ,IAAI,CAACa,GAA3B,IAAkCZ,IAApD;AACA,QAAMa,YAAY,GAAGT,QAAQ,CAACU,MAAT,GAAkBd,IAAvC;AACA,QAAMe,SAAS,GAAGhB,IAAI,CAACiB,KAAL,GAAahB,IAA/B;AACA,QAAMiB,UAAU,GAAGlB,IAAI,CAACe,MAAL,GAAcd,IAAjC;AAEA,MAAIS,IAAI,GAAGF,UAAU,GAAG5B,iBAAxB;AAEA,MAAIuC,SAAS,GAAGT,IAAI,GAAGP,UAAP,GAAqBa,SAArC;;AACA,MAAIG,SAAJ,EAAe;AACXT,IAAAA,IAAI,GAAGF,UAAU,GAAGL,UAAb,GAA0BtB,kBAAjC;;AACA,QAAI6B,IAAI,GAAG,CAAX,EAAc;AACZ;AACAA,MAAAA,IAAI,GAAGM,SAAS,GAAGb,UAAZ,GAAyBpB,UAAhC;AACAoC,MAAAA,SAAS,GAAG,KAAZ;AACD;AACJ;;AAED,MAAIN,GAAG,GAAGF,SAAS,GAAGG,YAAZ,GAA2BnC,gBAArC,CA5BoB,CA8BpB;;AACA,QAAMyC,aAAa,GAAGT,SAAS,GAAGT,WAAZ,GAA0BvB,gBAAgB,GAAGG,WAAnE;AACA,QAAMuC,UAAU,GAAIR,GAAG,GAAGX,WAAN,GAAoBgB,UAArB,IAAoCE,aAAa,GAAG,CAAvE;;AACA,MAAIC,UAAJ,EAAgB;AACdR,IAAAA,GAAG,GAAGO,aAAN;AACD;;AAED,SAAO;AACLV,IAAAA,IADK;AAELG,IAAAA,GAFK;AAGLQ,IAAAA,UAHK;AAILF,IAAAA;AAJK,GAAP;AAMD","sourcesContent":["import {\n  domUtils,\n  Controller,\n  Queries,\n} from '@ali/4ever-cangjie';\n\nconst EXTRA_OFFSET_TOP = 4;\nconst EXTRA_OFFSET_LEFT = 2;\nconst EXTRA_OFFSET_RIGHT = 18;\nconst CARET_SCALE = 1.5;\nconst NARROW_GAP = 6;\n\n/**\n * 光标位置处理。由于 void 节点内的光标无法定位，尝试获取前一个位置\n */\nexport function corretCaretPoint(controller: Controller) {\n  const { selection, document } = controller.value;\n  const point = selection.getStart(document);\n  if (\n    document.getClosestVoid(point.key, controller) ||\n    document.getParent(point.key)?.type === 'code'\n  ) {\n    return controller.query(Queries.pointAtDistance, point, -1);\n  }\n  return point;\n}\n\ninterface IGetCaretPosition {\n  controller: Controller;\n  rect: DOMRect; // 容器的 BoundingRect\n  zoom: number; // 容器缩放比例\n  panelHeight: number; // 表情面板高度\n  panelWidth: number; // 表情面板宽度\n}\n\nlet positionCache = null;\n\nexport function getCaretPosition({\n  controller,\n  rect,\n  zoom,\n  panelHeight,\n  panelWidth,\n}: IGetCaretPosition) {\n  const pointCorrected = corretCaretPoint(controller);\n  const position = domUtils.findCaretPosition(pointCorrected);\n  if (position) {\n    // @ts-ignore\n    positionCache = position;\n  } else {\n    return positionCache;\n  }\n\n  const originLeft = (position.clientLeft - rect.left) / zoom;\n  const originTop = (position.clientTop - rect.top) / zoom;\n  const holderHeight = position.height / zoom;\n  const rectWidth = rect.width / zoom;\n  const rectHeight = rect.height / zoom;\n\n  let left = originLeft - EXTRA_OFFSET_LEFT;\n\n  let isAtRight = left + panelWidth  > rectWidth;\n  if (isAtRight) {\n      left = originLeft - panelWidth + EXTRA_OFFSET_RIGHT;\n      if (left < 0) {\n        // 当右侧溢出且左侧也不够面板展开时，面板紧临右侧展开\n        left = rectWidth - panelWidth - NARROW_GAP;\n        isAtRight = false;\n      }\n  }\n\n  let top = originTop + holderHeight + EXTRA_OFFSET_TOP;\n\n  // 表情面板靠近底部且上部空间足够时，向上展开\n  const topWhenShowUp = originTop - panelHeight - EXTRA_OFFSET_TOP * CARET_SCALE;\n  const isAtBottom = (top + panelHeight > rectHeight) && topWhenShowUp > 0;\n  if (isAtBottom) {\n    top = topWhenShowUp;\n  }\n\n  return {\n    left,\n    top,\n    isAtBottom,\n    isAtRight,\n  };\n}\n"],"file":"getCaretPosition.js"}