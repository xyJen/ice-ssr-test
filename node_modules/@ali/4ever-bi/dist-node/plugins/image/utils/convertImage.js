"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isMobileSafari = isMobileSafari;
exports.isNativeSupport = isNativeSupport;
exports.orientationToAngle = orientationToAngle;
exports.getStringFromCharCode = getStringFromCharCode;
exports.getOrientation = getOrientation;
exports.loadBuffer = loadBuffer;
exports.loadImage = loadImage;
exports.canvasToBlob = canvasToBlob;
exports.createObjectURL = createObjectURL;
exports.rotateImage = rotateImage;
exports.Orientations = void 0;

function isMobileSafari() {
  return /(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent);
}

function isNativeSupport() {
  return isMobileSafari() || "imageOrientation" in document.createElement("image").style;
}

const Orientations = {
  ["1"]: 0,
  ["3"]: 180,
  ["6"]: 90,
  ["8"]: -90
};
exports.Orientations = Orientations;

function orientationToAngle(orientation) {
  return Orientations[String(orientation)] || 0;
}

function getStringFromCharCode(dataView, start, length) {
  let str = "",
      i;

  for (i = start, length += start; i < length; i++) {
    str += String.fromCharCode(dataView.getUint8(i));
  }

  return str;
}

function getOrientation(buffer) {
  if (isNativeSupport()) {
    return 1;
  }

  const dataView = new DataView(buffer);
  let length = dataView.byteLength;
  let orientation;
  let exifIDCode;
  let tiffOffset;
  let firstIFDOffset;
  let littleEndian;
  let endianness;
  let app1Start;
  let ifdStart;
  let offset;
  let i;

  try {
    // Only handle JPEG image (start by 0xFFD8)
    if (dataView.getUint8(0) === 0xff && dataView.getUint8(1) === 0xd8) {
      offset = 2;

      while (offset < length) {
        if (dataView.getUint8(offset) === 0xff && dataView.getUint8(offset + 1) === 0xe1) {
          app1Start = offset;
          break;
        }

        offset++;
      }
    }

    if (app1Start) {
      exifIDCode = app1Start + 4;
      tiffOffset = app1Start + 10;

      if (getStringFromCharCode(dataView, exifIDCode, 4) === "Exif") {
        endianness = dataView.getUint16(tiffOffset);
        littleEndian = endianness === 0x4949;

        if (littleEndian || endianness === 0x4d4d
        /* bigEndian */
        ) {
            if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002a) {
              firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);

              if (firstIFDOffset >= 0x00000008) {
                ifdStart = tiffOffset + firstIFDOffset;
              }
            }
          }
      }
    }

    if (ifdStart) {
      length = dataView.getUint16(ifdStart, littleEndian);

      for (i = 0; i < length; i++) {
        offset = ifdStart + i * 12 + 2;

        if (dataView.getUint16(offset, littleEndian) === 0x0112
        /* Orientation */
        ) {
            // 8 is the offset of the current tag's value
            offset += 8; // Get the original orientation value

            orientation = dataView.getUint16(offset, littleEndian);
            break;
          }
      }
    }

    return orientation;
  } catch (e) {
    return 1;
  }
}

async function loadBuffer(url) {
  const res = await fetch(url, {
    credentials: "same-origin",
    mode: "cors",
    redirect: "follow"
  });
  return res.arrayBuffer();
}

function loadImage(url) {
  return new Promise((resolve, reject) => {
    const image = new Image();
    image.addEventListener("load", () => resolve(image));
    image.addEventListener("error", err => reject(err));
    image.style.imageOrientation = "from-image";
    image.src = url;
  });
}

function canvasToBlob(canvas) {
  return new Promise(resolve => {
    canvas.toBlob(blob => resolve(blob));
  });
}

function createObjectURL(blob) {
  if (blob instanceof ArrayBuffer) {
    blob = new Blob([blob], {
      type: "image/jpeg"
    });
  }

  return URL.createObjectURL(blob);
}

async function rotateImage(imageFile, angle) {
  if (!angle || angle === 0) {
    return imageFile;
  }

  const localURL = createObjectURL(imageFile);
  const image = await loadImage(localURL);
  const isRightRngle = Math.abs(angle) === 90;
  const {
    width: oldWidth,
    height: oldHeight
  } = image;
  const {
    width: maxWidth,
    height: maxHeight
  } = window.screen;
  const ratioX = oldWidth > maxWidth ? maxWidth / oldWidth : 1;
  const ratioY = oldHeight > maxHeight ? maxHeight / oldHeight : 1;
  const ratio = Math.min(ratioX, ratioY);
  const width = (isRightRngle ? oldHeight : oldWidth) * ratio;
  const height = (isRightRngle ? oldWidth : oldHeight) * ratio;
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = width;
  canvas.height = height;
  ctx.translate(width / 2, height / 2);
  ctx.rotate(angle * Math.PI / 180);

  if (isRightRngle) {
    ctx.drawImage(image, -height / 2, -width / 2, height, width);
  } else {
    ctx.drawImage(image, -width / 2, -height / 2, width, height);
  }

  const blob = await canvasToBlob(canvas);
  URL.revokeObjectURL(localURL);
  return new File([blob], imageFile.name, {
    type: 'image/jpeg'
  });
}
//# sourceMappingURL=convertImage.js.map