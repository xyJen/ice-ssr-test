"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var React = _interopRequireWildcard(require("react"));

var _lodash = require("lodash");

var _resizeObserverPolyfill = _interopRequireDefault(require("resize-observer-polyfill"));

var _everUtils = require("@ali/4ever-utils");

var _everCangjie = require("@ali/4ever-cangjie");

var _everBamboo = require("@ali/4ever-bamboo");

var _imageRotate = _interopRequireDefault(require("./imageRotate"));

var _imageRotateHolder = _interopRequireDefault(require("./imageRotateHolder"));

var _styled = require("./styled");

var _utils = require("../utils");

var _constants = require("./constants");

const _createElement = /*#__PURE__*/React.createElement;
const IMAGE_BG_COLOR = 'rgba(0, 137, 255, .1)';
const ACCURACY = 5;

function shouldUseNaturalRatio(data) {
  const {
    rectClip
  } = data;
  return !rectClip || !(rectClip.left || rectClip.right || rectClip.top || rectClip.bottom);
}

var _ref = /*#__PURE__*/_createElement(_styled.ImageLoading, null);

class ImageEditor extends React.Component {
  constructor(props) {
    super(props);
    this.imageEditor = void 0;
    this.rotateControl = void 0;
    this.initialRectData = void 0;
    this.resizeObserver = null;
    this.mutationObserver = null;
    this.prevImgWidth = void 0;
    this.mutationFrameId = -1;
    this.resizeFrameId = -1;
    this.rate = void 0;
    this.naturalRate = void 0;
    this.scrollableAncestorsDOM = [];
    this.handleParentScroll = (0, _lodash.throttle)(() => {
      const rectData = this.getRealImgRectData();
      this.setState(rectData);
    }, 200);

    this.onResizeStart = (relativeEvent, angle) => {
      this.setState({
        mouse: {
          x: relativeEvent.relativeX,
          y: relativeEvent.relativeY
        },
        angle,
        resizing: false
      });
      this.props.onEnterResizingMode();
    };

    this.onResizeMove = relativeEvent => {
      const X = relativeEvent.relativeX;
      const Y = relativeEvent.relativeY;
      const {
        mouse
      } = this.state;
      const {
        scale
      } = this.props;

      if (X !== mouse.x || Y !== mouse.y) {
        const x = (mouse.x - X) / scale;
        const y = (mouse.y - Y) / scale;
        this.updateImageSize(x, y);
        this.setState({
          mouse: {
            x: X,
            y: Y
          },
          resizing: true
        });
      }
    };

    this.onResizeEnd = () => {
      const {
        onChangeSize
      } = this.props;
      let {
        l,
        r,
        t,
        b
      } = this.initialRectData;
      const {
        clientWidth,
        clientHeight
      } = this.imageEditor.current;
      const ratio = clientWidth / this.initialRectData.width;
      l = (0, _utils.getFixedNumber)(ratio * l, ACCURACY);
      r = (0, _utils.getFixedNumber)(ratio * r, ACCURACY);
      t = (0, _utils.getFixedNumber)(ratio * t, ACCURACY);
      b = (0, _utils.getFixedNumber)(ratio * b, ACCURACY);
      onChangeSize(clientWidth, clientHeight, l, r, t, b);
      this.setState({
        resizing: false,
        angle: 0
      });
    };

    this.handleMouseDown = (e, angle) => {
      e.preventDefault();
      e.stopPropagation();
      const {
        getZoomContainer
      } = this.props;
      const zoomContainer = getZoomContainer();
      if (!zoomContainer) return;
      const relativeEvent = (0, _everUtils.getRelativeMouseEvent)(e, zoomContainer);
      this.onResizeStart(relativeEvent, angle);
      document.addEventListener('mousemove', this.handleMouseMove);
      document.addEventListener('mouseup', this.handleMouseUp);
    };

    this.handleMouseMove = e => {
      e.preventDefault();
      e.stopPropagation();
      const {
        getZoomContainer
      } = this.props;
      const zoomContainer = getZoomContainer();
      const relativeEvent = (0, _everUtils.getRelativeMouseEvent)(e, zoomContainer);
      this.onResizeMove(relativeEvent);
    };

    this.handleMouseUp = e => {
      e.preventDefault();
      e.stopPropagation();
      this.onResizeEnd();
      document.removeEventListener('mousemove', this.handleMouseMove);
      document.removeEventListener('mouseup', this.handleMouseUp);
    };

    this.handleTouchStart = (e, angle) => {
      e.preventDefault();
      e.stopPropagation();
      const {
        getZoomContainer
      } = this.props;
      const zoomContainer = getZoomContainer();
      const {
        targetTouches
      } = e;
      if (!zoomContainer || targetTouches.length > 1) return;
      const relativeEvent = (0, _everUtils.getRelativeTouchEvent)(targetTouches[0], zoomContainer);
      this.onResizeStart(relativeEvent, angle);
      zoomContainer.addEventListener('touchmove', this.handleTouchMove);
      zoomContainer.addEventListener('touchend', this.handleTouchEnd);
    };

    this.handleTouchMove = e => {
      e.preventDefault();
      e.stopPropagation();
      const {
        getZoomContainer
      } = this.props;
      const zoomContainer = getZoomContainer();
      const touch = e.targetTouches[0];
      const relativeEvent = (0, _everUtils.getRelativeTouchEvent)(touch, zoomContainer);
      this.onResizeMove(relativeEvent);
    };

    this.handleTouchEnd = e => {
      e.preventDefault();
      e.stopPropagation();
      this.onResizeEnd();
      const {
        getZoomContainer
      } = this.props;
      const zoomContainer = getZoomContainer();
      zoomContainer && zoomContainer.removeEventListener('touchmove', this.handleTouchMove);
      zoomContainer && zoomContainer.removeEventListener('touchend', this.handleTouchEnd);
    };

    this.updateImageSize = (x, y) => {
      const {
        rotation,
        node
      } = this.props;
      x = x * Math.cos(-rotation / 180 * Math.PI) - y * Math.sin(-rotation / 180 * Math.PI);
      let nw;
      const {
        width,
        angle,
        l,
        r,
        t,
        b
      } = this.state;

      if (angle < 180) {
        nw = width - x;
      } else {
        nw = width + x;
      } // 最小校验


      if (nw < 24) {
        nw = 24;
      }

      const ratio = nw / width;
      const cW = nw;
      const useNaturalRatio = shouldUseNaturalRatio(node.data);
      const rate = useNaturalRatio && this.naturalRate ? this.naturalRate : this.rate;
      const cH = nw * rate;
      this.setState({
        width: cW,
        height: cH,
        l: l * ratio,
        t: t * ratio,
        r: r * ratio,
        b: b * ratio
      });
    };

    this.updateNaturalRate = e => {
      const {
        target
      } = e;
      const {
        naturalWidth,
        naturalHeight
      } = target;
      this.naturalRate = naturalHeight / naturalWidth;
    };

    this.renderResizeHolder = angle => {
      const {
        isBlurred,
        imageConfig,
        rotation
      } = this.props;
      const {
        disableResize
      } = imageConfig;
      const cursor = (0, _utils.getResizeCursor)(angle, rotation);
      return !disableResize ? /*#__PURE__*/_createElement(_styled.EditorResizeHolder, {
        role: "resizer",
        "data-role": `${_everBamboo.PluginRoles.imageResizer}${angle}`,
        angle: angle,
        cursor: cursor,
        onMouseDown: e => this.handleMouseDown(e, angle),
        onMouseUp: this.handleMouseUp,
        onTouchStart: e => this.handleTouchStart(e, angle),
        onTouchEnd: this.handleMouseUp,
        isSupportTouch: _everCangjie.environment.IS_TOUCH_DEVICE,
        isHide: isBlurred
      }) : null;
    };

    this.renderRotateHolder = angle => {
      const {
        isRotating,
        onEnterRotationMode,
        handleRotate,
        rotation,
        scale,
        getZoomContainer,
        controller,
        isBlurred
      } = this.props;
      const {
        width,
        height,
        resizing
      } = this.state;
      const isHide = resizing || isBlurred;
      return /*#__PURE__*/_createElement(_imageRotateHolder.default, {
        angle: angle,
        isSupportTouch: _everCangjie.environment.IS_TOUCH_DEVICE,
        isRotating: isRotating,
        onEnterRotationMode: onEnterRotationMode,
        handleRotate: handleRotate,
        rotation: rotation,
        width: width,
        height: height,
        rotateControl: this.rotateControl.current,
        rotateImageFrame: this.imageEditor.current,
        getZoomContainer: getZoomContainer,
        controller: controller,
        scale: scale,
        isHide: isHide
      });
    };

    this.renderEditBorder = position => /*#__PURE__*/_createElement(_styled.SelectBorder, {
      position: position
    });

    this.renderResizeNumber = () => {
      const {
        width,
        height,
        angle,
        resizing
      } = this.state;
      const {
        isRotating
      } = this.props;
      const normalizedWidth = Number(Number(width).toFixed());
      const normalizedHeight = Number(Number(height).toFixed());
      return isRotating ? null : /*#__PURE__*/_createElement(_styled.EditorNum, {
        angle: angle,
        resizing: resizing
      }, normalizedWidth, " \xD7 ", normalizedHeight);
    };

    this.renderResizeBg = () => {
      const {
        src,
        isRotating,
        onContextMenu,
        filter
      } = this.props;
      const {
        width,
        height,
        l,
        t,
        r,
        b,
        resizing
      } = this.state;

      if (src) {
        return /*#__PURE__*/_createElement(_styled.BgImg, {
          resizing: resizing,
          rotating: isRotating
        }, /*#__PURE__*/_createElement("img", {
          src: src // @ts-ignore 该属性无效
          ,
          filter: filter,
          onContextMenu: onContextMenu,
          style: {
            position: 'relative',
            left: -l,
            top: -t,
            width: typeof width === 'number' ? width + l + r : width,
            height: typeof height === 'number' ? height + t + b : height
          },
          onLoad: this.updateNaturalRate
        }));
      }

      return _ref;
    };

    this.handleClick = e => {
      const {
        onClick,
        controller
      } = this.props;
      const isImageDraggable = controller.query('getDraggableConfig')?.enabled;

      if (!isImageDraggable) {
        e.preventDefault();
      }

      e.stopPropagation();
      onClick && onClick();
    };

    const {
      node: _node
    } = props;
    const {
      width: _width,
      height: _height,
      l: _l,
      r: _r,
      t: _t,
      b: _b,
      left,
      top
    } = this.getRealImgRectData();
    this.state = {
      mouse: {
        x: 0,
        y: 0
      },
      width: _width,
      height: _height,
      angle: 0,
      resizing: false,
      l: _l,
      r: _r,
      t: _t,
      b: _b,
      left,
      top
    };
    this.rotateControl = /*#__PURE__*/React.createRef();
    this.imageEditor = /*#__PURE__*/React.createRef();
    this.initialRectData = {
      width: _width,
      height: _height,
      l: _l,
      r: _r,
      t: _t,
      b: _b,
      left,
      top
    };
    const outlineWidth = _node.data?.outline?.width || 0;
    this.prevImgWidth = _width - 2 * outlineWidth;
    this.rate = _height / _width;
  }

  initResizeObserver() {
    const {
      getImgRef
    } = this.props;
    const img = getImgRef();

    if (!img) {
      return;
    }

    const observerCallback = (0, _lodash.throttle)(entries => {
      for (const entry of entries) {
        if (this.prevImgWidth !== entry.contentRect.width) {
          this.resizeFrameId = window.requestAnimationFrame(() => {
            const rectData = this.getRealImgRectData();
            this.setState(rectData);
          });
          this.prevImgWidth = entry.contentRect.width;
        }
      }
    }, 300);
    this.resizeObserver = new _resizeObserverPolyfill.default(observerCallback);
    this.resizeObserver.observe(img);
  }

  initMutationObserver() {
    const {
      node
    } = this.props;
    const parent = this.props.controller.value.document.getParent(node.key);

    const parentDOM = parent && _everCangjie.domUtils.findDOMNodeSafely(parent.key);

    if (!parentDOM) {
      return;
    }

    const observerCallback = (0, _lodash.debounce)(() => {
      this.mutationFrameId = window.requestAnimationFrame(() => {
        const rectData = this.getRealImgRectData();
        this.setState(rectData);
      });
    }, 200);
    this.mutationObserver = new MutationObserver(observerCallback);
    this.mutationObserver.observe(parentDOM, {
      childList: true,
      attributes: true,
      subtree: true,
      attributeFilter: ['style']
    });
  }

  initScrollHandler() {
    const {
      node
    } = this.props;

    let current = _everCangjie.domUtils.findDOMNodeSafely(node.key);

    while (current?.parentElement && !current?.parentElement?.getAttribute('data-cangjie-content')) {
      const canScroll = current?.parentElement.getAttribute(_everBamboo.DraggablePlugin.SCROLLABLE_ATTRIBUTE_KEY);
      canScroll && this.scrollableAncestorsDOM.push(current?.parentElement);
      current = current?.parentElement;
    }

    this.scrollableAncestorsDOM.forEach(ancestorDOM => {
      ancestorDOM && ancestorDOM.addEventListener('scroll', this.handleParentScroll);
    });
  }

  removeScrollHandler() {
    this.scrollableAncestorsDOM.forEach(ancestorDOM => {
      ancestorDOM && ancestorDOM.removeEventListener('scroll', this.handleParentScroll);
    });
    this.handleParentScroll.cancel();
  }

  componentDidMount() {
    this.initResizeObserver();
    this.initMutationObserver();
    this.initScrollHandler();
  }

  componentWillUnmount() {
    document.removeEventListener('mousemove', this.handleMouseMove);
    document.removeEventListener('mouseup', this.handleMouseUp);
    const {
      getZoomContainer
    } = this.props;
    const container = getZoomContainer();
    container && container.removeEventListener('touchmove', this.handleTouchMove);
    container && container.removeEventListener('touchend', this.handleTouchEnd);
    this.resizeObserver?.disconnect();
    this.mutationObserver?.disconnect();
    this.removeScrollHandler();
    window.cancelAnimationFrame(this.resizeFrameId);
    window.cancelAnimationFrame(this.mutationFrameId);
  }

  getRealImgRectData() {
    const {
      node
    } = this.props;
    const outlineWidth = node.data?.outline?.width || 0;
    const rectData = this.props.getImgRectData();
    rectData.width += outlineWidth * 2;
    rectData.height += outlineWidth * 2;
    return rectData;
  }

  render() {
    const {
      onEnterRotationMode,
      handleRotate,
      rotation,
      isRotating,
      getZoomContainer,
      scale,
      controller,
      imageConfig
    } = this.props;
    const {
      angle,
      width,
      height,
      resizing
    } = this.state;
    let rotateObj;

    if (width > 0 && height > 0) {
      rotateObj = (0, _everUtils.calcRotationObj)(width, height, rotation);
    }

    let translateX = rotateObj?.translateX || 0;
    let translateY = rotateObj?.translateY || 0;
    const oldWidth = this.initialRectData.width;
    const oldHeight = this.initialRectData.height; // 修正旋转后缩放的左上角顶点对齐

    if (rotation !== 0 && oldWidth > 0 && oldHeight > 0) {
      const oldRotateObj = (0, _everUtils.calcRotationObj)(oldWidth, oldHeight, rotation);
      const oldRtX = (0, _everUtils.calcXAfterRotation)(-oldWidth / 2, -oldHeight / 2, rotation, oldRotateObj.translateX);
      const oldRtY = (0, _everUtils.calcYAfterRotation)(-oldWidth / 2, -oldHeight / 2, rotation, oldRotateObj.translateY);
      const newRtX = (0, _everUtils.calcXAfterRotation)(-width / 2, -height / 2, rotation, translateX);
      const newRtY = (0, _everUtils.calcYAfterRotation)(-width / 2, -height / 2, rotation, translateY);
      translateX = translateX - (newRtX - oldRtX) + (oldWidth - width) / 2;
      translateY = translateY - (newRtY - oldRtY) + (oldHeight - height) / 2;
    }

    let backgroundColor = IMAGE_BG_COLOR;

    if (isRotating || rotation % 90 === 0 || resizing) {
      backgroundColor = 'transparent';
    }

    const {
      disableRotate
    } = imageConfig;
    const rotateStyle = {
      height: rotateObj ? rotateObj.rHeight : height,
      width: rotateObj ? rotateObj.rWidth : width,
      backgroundColor,
      left: this.state.left,
      top: this.state.top
    };
    const style = {
      width,
      height,
      top: angle === 45 || angle === 315 ? 'auto' : 0,
      left: angle === 225 || angle === 315 ? 'auto' : 0,
      bottom: angle === 225 || angle === 135 ? 'auto' : 0,
      right: angle === 45 || angle === 135 ? 'auto' : 0,
      transform: `translate(${translateX}px, ${translateY}px) rotate(${rotation}deg)`
    };
    const isEditing = isRotating || resizing;
    const isTouchDevice = _everCangjie.environment.IS_TOUCH_DEVICE;
    const enableSingleRotateBtn = isTouchDevice && !(_everCangjie.environment.IS_MAC || _everCangjie.environment.IS_WINDOWS);
    const showMultipleRotateBtn = !disableRotate && !enableSingleRotateBtn;
    return /*#__PURE__*/_createElement(_styled.RotateControl, {
      style: rotateStyle,
      ref: this.rotateControl,
      "data-testid": "image-select"
    }, /*#__PURE__*/_createElement(_styled.ImageEditorFrame, {
      style: style,
      ref: this.imageEditor,
      "data-testid": "image-select-frame"
    }, !disableRotate && enableSingleRotateBtn && /*#__PURE__*/_createElement(_imageRotate.default, {
      isRotating: isRotating,
      onEnterRotationMode: onEnterRotationMode,
      handleRotate: handleRotate,
      rotation: rotation,
      width: width,
      height: height,
      rotateControl: this.rotateControl.current,
      rotateImageFrame: this.imageEditor.current,
      getZoomContainer: getZoomContainer,
      controller: controller,
      scale: scale
    }), this.renderResizeBg(), isEditing && this.renderEditBorder(_constants.Position.top), isEditing && this.renderEditBorder(_constants.Position.right), isEditing && this.renderEditBorder(_constants.Position.bottom), isEditing && this.renderEditBorder(_constants.Position.left), showMultipleRotateBtn && this.renderRotateHolder(45), showMultipleRotateBtn && this.renderRotateHolder(135), showMultipleRotateBtn && this.renderRotateHolder(225), showMultipleRotateBtn && this.renderRotateHolder(315), this.renderResizeHolder(45), this.renderResizeHolder(135), this.renderResizeHolder(225), this.renderResizeHolder(315), this.renderResizeNumber()));
  }

}

var _default = ImageEditor;
exports.default = _default;
//# sourceMappingURL=imageEditor.js.map