"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var React = _interopRequireWildcard(require("react"));

var ReactDOM = _interopRequireWildcard(require("react-dom"));

var _everUtils = require("@ali/4ever-utils");

var _everBamboo = require("@ali/4ever-bamboo");

var _styled = require("./styled");

var _fitRotate = _interopRequireDefault(require("../utils/fitRotate"));

const _createElement = /*#__PURE__*/React.createElement;

var _ref = /*#__PURE__*/_createElement(_styled.RotateLine, null);

class ImageRotate extends React.Component {
  constructor(props) {
    super(props);
    this.originX = void 0;
    this.originY = void 0;
    this.currentX = void 0;
    this.currentY = void 0;
    this.editorNum = void 0;

    this.onRotateStart = relativeEvent => {
      const {
        onEnterRotationMode
      } = this.props;
      onEnterRotationMode();
      this.originX = relativeEvent.relativeX;
      this.originY = relativeEvent.relativeY;
      this.currentX = relativeEvent.relativeX;
      this.currentY = relativeEvent.relativeY;
    };

    this.onRotateMove = (relativeEvent, zoomContainer) => {
      const {
        translateX,
        translateY
      } = this.state;
      const {
        rotateControl,
        rotation,
        rotateImageFrame,
        scale
      } = this.props;
      if (!rotateImageFrame || !rotateControl) return;
      this.currentX = relativeEvent.relativeX;
      this.currentY = relativeEvent.relativeY;
      const rect = (0, _everUtils.getBoundingRelativeRect)(rotateImageFrame, zoomContainer);
      const rectControl = (0, _everUtils.getBoundingRelativeRect)(rotateControl, zoomContainer);
      this.editorNum.current.style.display = 'inline';
      this.editorNum.current.style.left = this.currentX - rectControl.left + 16 + 'px';
      this.editorNum.current.style.top = this.currentY - rectControl.top + 'px';
      const objX = rect.left + rect.width / 2;
      const objY = rect.top + rect.height / 2;
      const x1 = this.originX - objX;
      const y1 = this.originY - objY;
      const x2 = this.currentX - objX;
      const y2 = this.currentY - objY;
      const triangleTop = x1 * y2 - x2 * y1;
      const triangleBottom = x1 * x2 + y1 * y2;
      const arc = Math.atan2(triangleTop, triangleBottom) * 180 / Math.PI;
      let newRotate = (0, _everUtils.normalizeAngle)(rotation + arc);
      newRotate = (0, _fitRotate.default)(newRotate);
      rotateImageFrame.style.transform = `translate(${translateX * scale}px, ${translateY * scale}px) rotate(${newRotate}deg)`;
      this.setState({
        currentRotation: newRotate
      });
    };

    this.onRotateEnd = () => {
      const {
        rotation,
        handleRotate,
        rotateImageFrame,
        getZoomContainer
      } = this.props;
      let newRotate = null;

      if (rotateImageFrame) {
        if (this.originX !== this.currentX || this.originY !== this.currentY) {
          const rect = (0, _everUtils.getBoundingRelativeRect)(rotateImageFrame, getZoomContainer());
          const objX = rect.left + rect.width / 2;
          const objY = rect.top + rect.height / 2;
          const x1 = this.originX - objX;
          const y1 = this.originY - objY;
          const x2 = this.currentX - objX;
          const y2 = this.currentY - objY;
          const triangleTop = x1 * y2 - x2 * y1;
          const triangleBottom = x1 * x2 + y1 * y2;
          const arc = Math.atan2(triangleTop, triangleBottom) * 180 / Math.PI;
          newRotate = (0, _everUtils.normalizeAngle)(rotation + arc);
          newRotate = (0, _fitRotate.default)(newRotate);
        }
      }

      handleRotate(newRotate);
      this.originX = 0;
      this.originY = 0;
      this.currentX = 0;
      this.currentY = 0;
    };

    this.handleTouchStart = e => {
      const {
        getZoomContainer
      } = this.props;
      e.preventDefault();
      e.stopPropagation();
      const zoomContainer = getZoomContainer();
      const {
        targetTouches
      } = e;

      if (!zoomContainer || targetTouches.length > 1) {
        return;
      }

      const relativeEvent = (0, _everUtils.getRelativeTouchEvent)(targetTouches[0], zoomContainer);
      this.onRotateStart(relativeEvent);
      zoomContainer.addEventListener('touchend', this.handleTouchEnd);
      zoomContainer.addEventListener('touchmove', this.handleTouchMove);
    };

    this.handleTouchMove = e => {
      e.preventDefault();
      e.stopPropagation();
      const {
        rotateImageFrame,
        getZoomContainer
      } = this.props;
      const zoomContainer = getZoomContainer();
      const {
        targetTouches
      } = e;
      const relativeEvent = (0, _everUtils.getRelativeTouchEvent)(targetTouches[0], zoomContainer);
      if (!rotateImageFrame) return;
      this.onRotateMove(relativeEvent, zoomContainer);
    };

    this.handleTouchEnd = e => {
      e.preventDefault();
      e.stopPropagation();
      this.onRotateEnd();
      const {
        getZoomContainer
      } = this.props;
      const zoomContainer = getZoomContainer();
      zoomContainer && zoomContainer.removeEventListener('touchmove', this.handleTouchMove);
      zoomContainer && zoomContainer.removeEventListener('touchend', this.handleTouchEnd);
    };

    this.renderRotateNumber = () => {
      const {
        currentRotation
      } = this.state;
      const {
        isRotating,
        rotateControl
      } = this.props;
      const rotation = (0, _everUtils.normalizeAngle)(currentRotation, true); // 传送到没有rotate的control层

      return isRotating && rotateControl ? /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/_createElement(_styled.EditorNum, {
        ref: this.editorNum,
        style: {
          display: 'none'
        },
        rotating: true
      }, rotation, "\xB0"), rotateControl) : null;
    };

    const {
      width,
      height
    } = props;

    const _rotation = this.props.rotation || 0;

    const {
      translateX: _translateX,
      translateY: _translateY
    } = (0, _everUtils.calcRotationObj)(width, height, _rotation);
    this.originX = 0;
    this.originY = 0;
    this.currentX = 0;
    this.currentY = 0;
    this.state = {
      rotation: _rotation,
      currentRotation: _rotation,
      translateX: _translateX,
      translateY: _translateY,
      width,
      height
    };
    this.editorNum = /*#__PURE__*/React.createRef();
  }

  static getDerivedStateFromProps(nextProps, prevStates) {
    const {
      width,
      height
    } = nextProps;
    const rotation = nextProps.rotation || 0;
    const prevRotation = prevStates.rotation || 0;

    if (rotation !== prevRotation || width !== prevStates.width || height !== prevStates.height) {
      const {
        rWidth,
        rHeight,
        translateX,
        translateY
      } = (0, _everUtils.calcRotationObj)(width, height, rotation);
      return {
        rotation,
        currentRotation: rotation,
        translateX,
        translateY,
        rWidth,
        rHeight,
        width,
        height
      };
    }

    return null;
  }

  componentWillUnmount() {
    const {
      getZoomContainer
    } = this.props;
    const zoomContainer = getZoomContainer();

    if (zoomContainer) {
      zoomContainer.removeEventListener('touchend', this.handleTouchEnd);
      zoomContainer.removeEventListener('touchmove', this.handleTouchMove);
    }
  }

  render() {
    return /*#__PURE__*/_createElement("span", null, _ref, /*#__PURE__*/_createElement(_styled.RotateControlPot, {
      onTouchStart: this.handleTouchStart,
      "data-role": _everBamboo.PluginRoles.imageSingleRotator
    }), this.renderRotateNumber());
  }

}

var _default = ImageRotate;
exports.default = _default;
//# sourceMappingURL=imageRotate.js.map