"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var React = _interopRequireWildcard(require("react"));

var _everUtils = require("@ali/4ever-utils");

var _everBamboo = require("@ali/4ever-bamboo");

var _styled = require("./styled");

const _createElement = /*#__PURE__*/React.createElement;
const MIN_CROP_DISTANCE = 20;

var _ref = /*#__PURE__*/_createElement(_styled.ImageCropSrcRect, null);

class ImageCrop extends React.Component {
  constructor(props) {
    super(props);
    this.initialRectData = void 0;
    this.originX = void 0;
    this.originY = void 0;
    this.currentX = void 0;
    this.currentY = void 0;
    this.cropOuter = void 0;
    this.cropRealImage = void 0;
    this.cropFakeImage = void 0;
    this.cropFakeInner = void 0;
    this.cropOuterTransform = void 0;
    this.handleTarget = void 0;

    this.onCropStart = (relativeEvent, orient, parentOrient) => {
      this.cropOuterTransform = this.cropOuter.current?.style.transform || '';
      this.originX = relativeEvent.relativeX;
      this.originY = relativeEvent.relativeY;
      this.currentX = relativeEvent.relativeX;
      this.currentY = relativeEvent.relativeY;
      const matchedFrameResize = orient.match(/crop-handle-(\w+)/) || parentOrient.match(/crop-handle-(\w+)/);
      const matchedImageResize = orient.match(/image-handle-(\w+)/) || parentOrient.match(/image-handle-(\w+)/);

      if (matchedFrameResize) {
        this.handleTarget = ['frameResize', matchedFrameResize[1]];
      } else if (matchedImageResize) {
        this.handleTarget = ['imageResize', matchedImageResize[1]];
      } else {
        this.handleTarget = ['frameTranslate'];
      }
    };

    this.handleMouseDown = e => {
      e.preventDefault();
      e.stopPropagation();
      const {
        getZoomContainer
      } = this.props;
      const zoomContainer = getZoomContainer();
      const relativeEvent = (0, _everUtils.getRelativeMouseEvent)(e, zoomContainer);
      const orient = e.target.getAttribute('data-orient') || '';
      const parentOrient = e.target.parentNode.getAttribute('data-orient') || '';
      this.onCropStart(relativeEvent, orient, parentOrient);
      document.addEventListener('mousemove', this.handleMouseMove);
      document.addEventListener('mouseup', this.handleMouseUp);
    };

    this.handleTouchStart = e => {
      e.preventDefault();
      e.stopPropagation();
      const {
        getZoomContainer
      } = this.props;
      const zoomContainer = getZoomContainer();
      const {
        targetTouches
      } = e;

      if (!zoomContainer || targetTouches.length > 1) {
        return;
      }

      const touch = targetTouches[0];
      const relativeEvent = (0, _everUtils.getRelativeTouchEvent)(touch, zoomContainer);
      const target = touch.target;
      const orient = target.getAttribute('data-orient') || '';
      const parentOrient = target.parentNode?.getAttribute('data-orient') || '';
      this.onCropStart(relativeEvent, orient, parentOrient);
      zoomContainer.addEventListener('touchmove', this.handleTouchMove);
      zoomContainer.addEventListener('touchend', this.handleTouchEnd);
    };

    this.updateCropFrame = (x, y, target) => {
      const {
        width,
        height,
        l,
        t
      } = this.state;
      const {
        rotation,
        scale
      } = this.props;
      let newWidth = width;
      let newHeight = height;
      const cropOuterEle = this.cropOuter.current;
      const cropRealImageEle = this.cropRealImage.current;
      const cropFakeInnerEle = this.cropFakeInner.current;

      if (!cropOuterEle || !cropRealImageEle || !cropFakeInnerEle) {
        return;
      }

      if (target.indexOf('s') >= 0) {
        newHeight = Math.max(height * scale + y, MIN_CROP_DISTANCE * scale);
        cropOuterEle.style.height = newHeight + 'px';
      }

      if (target.indexOf('e') >= 0) {
        newWidth = Math.max(width * scale + x, MIN_CROP_DISTANCE * scale);
        cropOuterEle.style.width = newWidth + 'px';
      }

      if (target.indexOf('n') >= 0) {
        newHeight = Math.max(height * scale - y, MIN_CROP_DISTANCE * scale);
        cropOuterEle.style.height = newHeight + 'px';
        const top = -t * scale - y + 'px';
        cropRealImageEle.style.top = top;
        cropFakeInnerEle.style.top = top;
      }

      if (target.indexOf('w') >= 0) {
        newWidth = Math.max(width * scale - x, MIN_CROP_DISTANCE * scale);
        cropOuterEle.style.width = newWidth + 'px';
        const left = -l * scale - x + 'px';
        cropRealImageEle.style.left = left;
        cropFakeInnerEle.style.left = left;
      }

      const oldRotateObj = (0, _everUtils.calcRotationObj)(width * scale, height * scale, rotation);
      const newRotateObj = (0, _everUtils.calcRotationObj)(newWidth, newHeight, rotation);
      let translateX = oldRotateObj.translateX;
      let translateY = oldRotateObj.translateY; // 修正旋转后缩放的左上角顶点对齐

      if (target === 's' || target === 'e' || target === 'se') {
        const tlXOld = oldRotateObj.tlX;
        const tlYOld = oldRotateObj.tlY;
        const tlXNew = newRotateObj.tlX;
        const tlYNew = newRotateObj.tlY;
        translateX = translateX - (tlXNew + newWidth / 2 - tlXOld - width * scale / 2);
        translateY = translateY - (tlYNew + newHeight / 2 - tlYOld - height * scale / 2);
      } // 修正旋转后缩放的右下角顶点对齐


      if (target === 'n' || target === 'w' || target === 'nw') {
        const tlXOld = -oldRotateObj.tlX;
        const tlYOld = -oldRotateObj.tlY;
        const tlXNew = -newRotateObj.tlX;
        const tlYNew = -newRotateObj.tlY;
        translateX = translateX - (tlXNew + newWidth / 2 - tlXOld - width * scale / 2);
        translateY = translateY - (tlYNew + newHeight / 2 - tlYOld - height * scale / 2);
      } // 修正旋转后缩放的右上角顶点对齐


      if (target === 'sw') {
        const trXOld = oldRotateObj.trX;
        const trYOld = oldRotateObj.trY;
        const trXNew = newRotateObj.trX;
        const trYNew = newRotateObj.trY;
        translateX = translateX - (trXNew + newWidth / 2 - trXOld - width * scale / 2);
        translateY = translateY - (trYNew + newHeight / 2 - trYOld - height * scale / 2);
      } // 修正旋转后缩放的左下角顶点对齐


      if (target === 'ne') {
        const trXOld = -oldRotateObj.trX;
        const trYOld = -oldRotateObj.trY;
        const trXNew = -newRotateObj.trX;
        const trYNew = -newRotateObj.trY;
        translateX = translateX - (trXNew + newWidth / 2 - trXOld - width * scale / 2);
        translateY = translateY - (trYNew + newHeight / 2 - trYOld - height * scale / 2);
      }

      cropOuterEle.style.transform = `translate(${translateX}px, ${translateY}px) rotate(${rotation}deg)`;
    };

    this.finalizeCropFrame = (x, y, target) => {
      const {
        handleCrop,
        scale
      } = this.props;
      const {
        width,
        height
      } = this.state;
      let {
        l,
        t,
        r,
        b
      } = this.state;
      let newWidth = width;
      let newHeight = height;
      x = Math.round(x / scale);
      y = Math.round(y / scale);
      this.resetOuterPos();

      if (target.indexOf('n') >= 0) {
        newHeight = Math.max(height - y, MIN_CROP_DISTANCE);
        t = t + height - newHeight;
      }

      if (target.indexOf('w') >= 0) {
        newWidth = Math.max(width - x, MIN_CROP_DISTANCE);
        l = l + width - newWidth;
      }

      if (target.indexOf('s') >= 0) {
        newHeight = Math.max(height + y, MIN_CROP_DISTANCE);
        b = b + height - newHeight;
      }

      if (target.indexOf('e') >= 0) {
        newWidth = Math.max(width + x, MIN_CROP_DISTANCE);
        r = r + width - newWidth;
      }

      this.setState({
        l,
        t,
        r,
        b,
        width: newWidth,
        height: newHeight
      });
      handleCrop(newWidth, newHeight, l, r, t, b);
    };

    this.updateCropImage = (x, y, target) => {
      const {
        scale
      } = this.props;
      const {
        l,
        t,
        r,
        b
      } = this.state;
      const height = this.state.height + t + b;
      const width = this.state.width + l + r;
      const cropRealImageEle = this.cropRealImage.current;
      const cropFakeImageEle = this.cropFakeImage.current;
      const cropFakeInnerEle = this.cropFakeInner.current;

      if (!cropRealImageEle || !cropFakeImageEle || !cropFakeInnerEle) {
        return;
      }

      if (target.indexOf('s') >= 0) {
        cropRealImageEle.style.height = Math.max(height * scale + y, MIN_CROP_DISTANCE * scale) + 'px';
        cropFakeImageEle.style.height = Math.max(height * scale + y, MIN_CROP_DISTANCE * scale) + 'px';
      }

      if (target.indexOf('e') >= 0) {
        cropRealImageEle.style.width = Math.max(width * scale + x, MIN_CROP_DISTANCE * scale) + 'px';
        cropFakeImageEle.style.width = Math.max(width * scale + x, MIN_CROP_DISTANCE * scale) + 'px';
      }

      if (target.indexOf('n') >= 0) {
        cropRealImageEle.style.height = Math.max(height * scale - y, MIN_CROP_DISTANCE * scale) + 'px';
        cropFakeImageEle.style.height = Math.max(height * scale - y, MIN_CROP_DISTANCE * scale) + 'px';
        cropRealImageEle.style.top = -t * scale + Math.min(y, (height - MIN_CROP_DISTANCE) * scale) + 'px';
        cropFakeInnerEle.style.top = -t * scale + Math.min(y, (height - MIN_CROP_DISTANCE) * scale) + 'px';
      }

      if (target.indexOf('w') >= 0) {
        cropRealImageEle.style.width = Math.max(width * scale - x, MIN_CROP_DISTANCE) + 'px';
        cropFakeImageEle.style.width = Math.max(width * scale - x, MIN_CROP_DISTANCE) + 'px';
        cropRealImageEle.style.left = -l * scale + Math.min(x, (width - MIN_CROP_DISTANCE) * scale) + 'px';
        cropFakeInnerEle.style.left = -l * scale + Math.min(x, (width - MIN_CROP_DISTANCE) * scale) + 'px';
      }
    };

    this.finalizeCropImage = (x, y, target) => {
      let {
        l,
        r,
        t,
        b
      } = this.state;
      const {
        handleCrop,
        scale
      } = this.props;
      const height = this.state.height + t + b;
      const width = this.state.width + l + r;
      x = Math.round(x / scale);
      y = Math.round(y / scale);
      this.resetOuterPos();

      if (target.indexOf('s') >= 0) {
        b = b + Math.max(y, MIN_CROP_DISTANCE - height);
      }

      if (target.indexOf('e') >= 0) {
        r = r + Math.max(x, MIN_CROP_DISTANCE - width);
      }

      if (target.indexOf('n') >= 0) {
        t = t - Math.min(y, height - MIN_CROP_DISTANCE);
      }

      if (target.indexOf('w') >= 0) {
        l = l - Math.min(x, width - MIN_CROP_DISTANCE);
      }

      this.setState({
        l,
        r,
        t,
        b
      });
      handleCrop(this.state.width, this.state.height, l, r, t, b);
    };

    this.updateTranslateFrame = (x, y) => {
      const {
        scale
      } = this.props;
      const {
        l,
        t
      } = this.state;
      const cropRealImageEle = this.cropRealImage.current;
      const cropFakeImageEle = this.cropFakeImage.current;
      const cropFakeInnerEle = this.cropFakeInner.current;

      if (!cropRealImageEle || !cropFakeImageEle || !cropFakeInnerEle) {
        return;
      }

      cropRealImageEle.style.left = -l * scale + x + 'px';
      cropFakeInnerEle.style.left = -l * scale + x + 'px';
      cropRealImageEle.style.top = -t * scale + y + 'px';
      cropFakeInnerEle.style.top = -t * scale + y + 'px';
    };

    this.finalizeTranslateFrame = (x, y) => {
      const {
        handleCrop,
        scale
      } = this.props;
      x = Math.round(x / scale);
      y = Math.round(y / scale);
      const {
        width,
        height
      } = this.state;
      this.resetOuterPos();
      let {
        l,
        t,
        r,
        b
      } = this.state;
      l = l - x;
      t = t - y;
      r = r + x;
      b = b + y;
      this.setState({
        l,
        t,
        r,
        b
      });
      handleCrop(width, height, l, r, t, b);
    };

    this.onCropMove = relativeEvent => {
      const {
        rotation
      } = this.props;
      this.currentX = relativeEvent.relativeX;
      this.currentY = relativeEvent.relativeY;
      const x = this.currentX - this.originX;
      const y = this.currentY - this.originY;
      const newX = x * Math.cos(-rotation / 180 * Math.PI) - y * Math.sin(-rotation / 180 * Math.PI);
      const newY = x * Math.sin(-rotation / 180 * Math.PI) + y * Math.cos(-rotation / 180 * Math.PI);

      if (this.handleTarget && this.handleTarget[0] === 'frameResize') {
        this.updateCropFrame(newX, newY, this.handleTarget[1]);
      } else if (this.handleTarget && this.handleTarget[0] === 'imageResize') {
        this.updateCropImage(newX, newY, this.handleTarget[1]);
      } else if (this.handleTarget && this.handleTarget[0] === 'frameTranslate') {
        this.updateTranslateFrame(newX, newY);
      }
    };

    this.handleMouseMove = e => {
      const {
        getZoomContainer
      } = this.props;
      e.preventDefault();
      e.stopPropagation();
      const zoomContainer = getZoomContainer();
      const relativeEvent = (0, _everUtils.getRelativeMouseEvent)(e, zoomContainer);
      this.onCropMove(relativeEvent);
    };

    this.handleTouchMove = e => {
      const {
        getZoomContainer
      } = this.props;
      e.preventDefault();
      e.stopPropagation();
      const zoomContainer = getZoomContainer();
      const {
        targetTouches
      } = e;
      const relativeEvent = (0, _everUtils.getRelativeTouchEvent)(targetTouches[0], zoomContainer);
      this.onCropMove(relativeEvent);
    };

    this.resetOuterPos = () => {
      const cropOuterEle = this.cropOuter.current;

      if (!cropOuterEle) {
        return;
      }

      cropOuterEle.style.transform = this.cropOuterTransform;
    };

    this.onCropEnd = () => {
      const {
        rotation
      } = this.props;

      if (this.originX !== this.currentX || this.originY !== this.currentY) {
        const x = this.currentX - this.originX;
        const y = this.currentY - this.originY;
        const newX = x * Math.cos(-rotation / 180 * Math.PI) - y * Math.sin(-rotation / 180 * Math.PI);
        const newY = x * Math.sin(-rotation / 180 * Math.PI) + y * Math.cos(-rotation / 180 * Math.PI);

        if (this.handleTarget && this.handleTarget[0] === 'frameResize') {
          this.finalizeCropFrame(newX, newY, this.handleTarget[1]);
        } else if (this.handleTarget && this.handleTarget[0] === 'imageResize') {
          this.finalizeCropImage(newX, newY, this.handleTarget[1]);
        } else if (this.handleTarget && this.handleTarget[0] === 'frameTranslate') {
          this.finalizeTranslateFrame(newX, newY);
        }
      }

      this.handleTarget = null;
      this.originX = 0;
      this.originY = 0;
      this.currentX = 0;
      this.currentY = 0;
    };

    this.handleMouseUp = e => {
      e.preventDefault();
      e.stopPropagation();
      this.onCropEnd();
      document.removeEventListener('mousemove', this.handleMouseMove);
      document.removeEventListener('mouseup', this.handleMouseUp);
    };

    this.handleTouchEnd = e => {
      e.preventDefault();
      e.stopPropagation();
      const {
        getZoomContainer
      } = this.props;
      const zoomContainer = getZoomContainer();
      this.onCropEnd();
      zoomContainer.removeEventListener('touchmove', this.handleTouchMove);
      zoomContainer.removeEventListener('touchend', this.handleTouchEnd);
    };

    this.handleExitCroppingMode = event => {
      event.preventDefault();
      event.stopPropagation();
      const {
        onExitCroppingMode
      } = this.props;

      if (this.cropOuter.current && !this.cropOuter.current.contains(event.target)) {
        onExitCroppingMode();
      }
    };

    this.exit = event => {
      event.preventDefault();
      event.stopPropagation();
      const {
        onExitCroppingMode
      } = this.props;
      onExitCroppingMode();
    };

    this.initialRectData = this.props.getImgRectData();
    this.originX = 0;
    this.originY = 0;
    this.currentX = 0;
    this.currentY = 0;
    this.state = {
      width: this.initialRectData.width,
      height: this.initialRectData.height,
      l: this.initialRectData.l,
      r: this.initialRectData.r,
      t: this.initialRectData.t,
      b: this.initialRectData.b
    };
    this.handleTarget = null;
    this.cropOuter = /*#__PURE__*/React.createRef();
    this.cropRealImage = /*#__PURE__*/React.createRef();
    this.cropFakeImage = /*#__PURE__*/React.createRef();
    this.cropFakeInner = /*#__PURE__*/React.createRef();
    this.cropOuterTransform = '';
  }

  componentWillUnmount() {
    document.removeEventListener('mousemove', this.handleMouseMove);
    document.removeEventListener('mouseup', this.handleMouseUp);
    document.removeEventListener('mousedown', this.handleExitCroppingMode);
    const {
      getZoomContainer
    } = this.props;
    const zoomContainer = getZoomContainer();

    if (zoomContainer) {
      zoomContainer.removeEventListener('touchmove', this.handleTouchMove);
      zoomContainer.removeEventListener('touchend', this.handleTouchEnd);
      document.removeEventListener('touchstart', this.handleExitCroppingMode);
    }
  }

  componentDidMount() {
    document.addEventListener('mousedown', this.handleExitCroppingMode);
    document.addEventListener('touchstart', this.handleExitCroppingMode);
  }

  render() {
    const {
      attributes,
      src,
      rotation,
      scale
    } = this.props;
    const {
      width,
      height,
      l,
      r,
      t,
      b
    } = this.state;
    const style = {
      width: width * scale,
      height: height * scale
    };
    const rotationObj = (0, _everUtils.calcRotationObj)(width, height, rotation);

    if (rotationObj) {
      style.transform = `translate(${rotationObj.translateX * scale}px, ${rotationObj.translateY * scale}px) rotate(${rotation}deg)`;
    }

    const rotateStyle = {
      width: rotationObj ? rotationObj.rWidth * scale : width * scale,
      height: rotationObj ? rotationObj.rHeight * scale : height * scale,
      left: this.initialRectData.left,
      top: this.initialRectData.top
    };
    return /*#__PURE__*/_createElement(_styled.CropImageRotate, {
      style: rotateStyle
    }, /*#__PURE__*/_createElement(_styled.CropOuter, {
      ref: this.cropOuter,
      onMouseDown: this.handleMouseDown,
      onTouchStart: this.handleTouchStart,
      style: style,
      onDoubleClick: this.exit,
      "data-role": _everBamboo.PluginRoles.imageCropper
    }, /*#__PURE__*/_createElement(_styled.CropRealOuter, null, /*#__PURE__*/_createElement(_styled.CropRealImage, (0, _extends2.default)({
      ref: this.cropRealImage,
      src: src,
      style: {
        left: -l * scale,
        top: -t * scale,
        width: (width + l + r) * scale,
        height: (height + t + b) * scale
      }
    }, attributes))), _ref, /*#__PURE__*/_createElement(_styled.CropFrame, null, /*#__PURE__*/_createElement(_styled.CropFakeInner, {
      ref: this.cropFakeInner,
      style: {
        left: -l * scale,
        top: -t * scale
      }
    }, /*#__PURE__*/_createElement(_styled.CropFakeImage, {
      ref: this.cropFakeImage,
      src: src,
      style: {
        width: (width + l + r) * scale,
        height: (height + t + b) * scale
      }
    })))));
  }

}

var _default = ImageCrop;
exports.default = _default;
//# sourceMappingURL=imageCrop.js.map