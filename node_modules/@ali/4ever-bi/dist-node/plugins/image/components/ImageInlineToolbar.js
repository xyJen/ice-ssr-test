"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.getToolButton = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var React = _interopRequireWildcard(require("react"));

var _lodash = require("lodash");

var _everCangjie = require("@ali/4ever-cangjie");

var _everBamboo = require("@ali/4ever-bamboo");

var _weToolbar = require("@ali/we-toolbar");

var _weIcon = require("@ali/we-icon");

var _weDesign = require("@ali/we-design");

var _actions = require("../actions");

var _index = require("../../../index");

var _everUtils = require("@ali/4ever-utils");

var _TextButton = _interopRequireDefault(require("./TextButton"));

var _everComponent = require("@ali/4ever-component");

const _createElement = /*#__PURE__*/React.createElement;
const inlineToolbarOverlayStyle = {
  backgroundColor: 'transparent',
  boxShadow: 'none',
  border: 'none'
};
const inlineToolbarStyle = {
  border: 'none',
  boxShadow: '0px 0px 1px rgb(0 0 0 / 24%), 0px 8px 24px rgb(0 0 0 / 16%)',
  padding: '0 5px',
  borderRadius: '4px'
};

const getToolButton = (name, icon, handleClick, testid, role, controller, node) => {
  const handleClickWithController = event => {
    return handleClick(event, controller, node);
  },
        _ref = /*#__PURE__*/_createElement(_TextButton.default, {
    name: name,
    testid: testid,
    role: role,
    handleClick: handleClickWithController
  });

  return props => {
    if (!icon) {
      return _ref;
    }

    return /*#__PURE__*/_createElement(_weToolbar.IconButton, (0, _extends2.default)({}, props, {
      testid: testid,
      onClick: handleClickWithController,
      title: name,
      tooltip: name,
      bordered: false,
      icon: icon,
      role: role
    }));
  };
};

exports.getToolButton = getToolButton;

var _ref3 = /*#__PURE__*/_createElement(_weIcon.CutNormal, null);

var _ref4 = /*#__PURE__*/_createElement(_weIcon.DownloadpicturenewNormal, null);

var _ref5 = /*#__PURE__*/_createElement(_weDesign.PreviewBetaNormal, null);

var _ref6 = /*#__PURE__*/_createElement(_weIcon.RotatepictureNormal, null);

var _ref7 = /*#__PURE__*/_createElement(_weIcon.Rotate90Normal, null);

var _ref8 = /*#__PURE__*/_createElement(_weIcon.RotateLeftLineThinNormal, null);

class ImageInlineToolbar extends React.Component {
  constructor(props) {
    super(props);
    this.mutationObserver = null;
    this.observerCallback = (0, _lodash.debounce)((mutationsList, parentDOM) => {
      const ignoreMuation = mutationsList.every(mutation => this.shouldIgnoreMutation(mutation, parentDOM));

      if (!ignoreMuation) {
        this.setState({
          key: `image-inline-toolbar-${Math.random()}`
        });
      }
    }, 200);

    this.handlepreview = e => {
      e.preventDefault();
      e.stopPropagation();
      const {
        node,
        previewImage
      } = this.props;

      if (previewImage) {
        const {
          src
        } = node.data;
        previewImage(src, node);
      }
    };

    this.handledeleteImg = e => {
      e.preventDefault();
      e.stopPropagation();
      const {
        controller,
        node
      } = this.props;
      controller.run('onAction', (0, _actions.removeImage)(node));
    };

    this.handleCorp = event => {
      const {
        controller,
        node
      } = this.props;
      event.preventDefault();
      event.stopPropagation();
      controller.run('onAction', (0, _actions.setImageInjection)(node.key, {
        isImageCropping: true
      }));
    };

    this.handleDownload = event => {
      const {
        downloadImage,
        node
      } = this.props;
      event.preventDefault();
      event.stopPropagation();

      if (downloadImage) {
        const {
          src
        } = node.data;
        downloadImage(src);
      }
    };

    this.handlePreview = event => {
      const {
        previewImage,
        node
      } = this.props;
      event.preventDefault();
      event.stopPropagation();

      if (previewImage) {
        const {
          src
        } = node.data;
        previewImage(src, node);
      }
    };

    this.getCustomToolbar = (node, customToolbars) => {
      const extraData = (0, _everUtils.getData)(node.data, 'extraData', {});

      for (const key in customToolbars) {
        if (extraData[key]) {
          return customToolbars[key];
        }
      }

      return null;
    };

    this.getMoreMenuButton = () => {
      const {
        inlineToolbarMore,
        getScrollableContent
      } = this.props;

      var _ref2 = /*#__PURE__*/_createElement(_weToolbar.MoreButton, {
        testid: "image-inline-more-dropdown",
        getContainer: getScrollableContent,
        placement: "bottomLeft",
        offsetY: 0,
        overlay: /*#__PURE__*/_createElement(_weDesign.Menu, {
          getContainer: getScrollableContent,
          testid: "image-inline-more-menu"
        }, /*#__PURE__*/_createElement(_everComponent.Menu, {
          menus: inlineToolbarMore
        }))
      });

      return () => {
        if (!inlineToolbarMore) {
          return null;
        }

        return _ref2;
      };
    };

    this.getCustomToolButtons = () => {
      const {
        locale,
        handleInlineToolbarRotate,
        handleInlineToolbarRotateAntiClockwise,
        downloadImage,
        previewImage
      } = this.props;
      return {
        'image.crop': getToolButton(locale.cropping, _ref3, this.handleCorp, 'bi-toolbar-image-crop', _everBamboo.PluginRoles.imageInlineToolbarCrop),
        'image.download': !downloadImage ? null : getToolButton(locale.downloadImg, _ref4, this.handleDownload, 'bi-toolbar-image-download', _everBamboo.PluginRoles.imageInlineToolbarDownload),
        'image.preview': !previewImage ? null : getToolButton(locale.previewImg, _ref5, this.handlePreview, 'bi-toolbar-image-preview', _everBamboo.PluginRoles.imageInlineToolbarPreview),
        'image.rotateReverse': getToolButton(locale.rotateAntiClockwise, _ref6, handleInlineToolbarRotateAntiClockwise, 'bi-toolbar-image-rotateReverse', 'imageInlineToolbarRotateReverse'),
        'image.rotate': getToolButton(locale.rotate, _ref7, handleInlineToolbarRotate, 'bi-toolbar-image-rotate', _everBamboo.PluginRoles.imageInlineToolbarRotate),
        'image.singeRotateReverse': getToolButton(locale.rotateAntiClockwise, _ref8, handleInlineToolbarRotateAntiClockwise, 'bi-toolbar-image-rotateReverse', _everBamboo.PluginRoles.imageInlineToolbarSingleRotateReverse),
        'image.more': this.getMoreMenuButton()
      };
    };

    this.getToolButtonFromConfig = config => {
      const {
        controller,
        node
      } = this.props;
      const buttons = {}; // eslint-disable-next-line guard-for-in

      for (const key in config) {
        const {
          name,
          icon,
          handleClick,
          testid,
          role
        } = config[key];
        buttons[key] = getToolButton(name, icon, handleClick, testid, role, controller, node);
      }

      return buttons;
    };

    this.state = {
      key: 'image-inline-toolbar-0'
    };
  }

  componentDidMount() {
    this.initMutationObserver();
  }

  componentWillUnmount() {
    this.mutationObserver?.disconnect();
    this.observerCallback.cancel();
  }

  shouldIgnoreMutation(mutation, root) {
    const {
      type,
      target,
      attributeName
    } = mutation;
    const {
      key
    } = this.props.node;
    let res = false;

    if (type === 'attributes' && attributeName === 'style') {
      let current = target;

      while (current && current !== root && current !== document.body) {
        const targetKey = current.getAttribute('data-cangjie-key');

        if (key === targetKey) {
          res = true;
          break;
        }

        current = current.parentElement;
      }
    }

    return res;
  }

  initMutationObserver() {
    const {
      node,
      getScrollableContent
    } = this.props;
    const parent = this.props.controller.value.document.getParent(node.key);
    const root = getScrollableContent();

    const parentDOM = parent && _everCangjie.domUtils.findDOMNodeSafely(parent.key, root);

    if (!parentDOM) {
      return;
    }

    this.mutationObserver = new MutationObserver(mutationsList => {
      this.observerCallback(mutationsList, parentDOM);
    });
    this.mutationObserver.observe(parentDOM, {
      childList: true,
      attributes: true,
      subtree: true,
      attributeFilter: ['style']
    });
  }

  render() {
    const {
      visible,
      triggerNode,
      inlineToolbarLayout,
      node,
      customToolbars
    } = this.props;
    const {
      customToolButtonConfig,
      customToolLayout
    } = this.getCustomToolbar(node, customToolbars) || {}; // 狗姐：所有 inlineToolbar 样式和极简模式 inlineToolbar 保持一致，先从图片开刀
    // 图片比较紧急，所以基于原来的 inlineToolbar 修改样式，而暂未使用新 inlineToolbar

    return /*#__PURE__*/_createElement(_index.InlineToolbar, {
      key: this.state.key,
      style: inlineToolbarStyle,
      overlayStyle: inlineToolbarOverlayStyle,
      visible: visible,
      triggerNode: triggerNode,
      inlineLayout: customToolLayout || inlineToolbarLayout,
      customToolButtons: customToolButtonConfig ? this.getToolButtonFromConfig(customToolButtonConfig) : this.getCustomToolButtons(),
      offsetY: _everCangjie.environment.IS_TOUCH_DEVICE ? -22 : -12,
      testid: "image"
    });
  }

}

var _default = ImageInlineToolbar;
exports.default = _default;
//# sourceMappingURL=ImageInlineToolbar.js.map