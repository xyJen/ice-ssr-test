"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var React = _interopRequireWildcard(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _everUtils = require("@ali/4ever-utils");

var _everBamboo = require("@ali/4ever-bamboo");

var _styled = require("./styled");

var _fitRotate = _interopRequireDefault(require("../utils/fitRotate"));

const _createElement = /*#__PURE__*/React.createElement;
// 旋转光标未旋转时，其视觉上应该平行于 x 轴，以下常量用于矫正角度
const ROTATE_CURSOR_OFFSET = -45;

var _ref = /*#__PURE__*/_createElement(_styled.DisableCursor, null);

const ImageRotateHolder = props => {
  const {
    angle,
    getZoomContainer,
    onEnterRotationMode,
    width,
    height,
    rotation = 0,
    rotateImageFrame,
    scale,
    handleRotate,
    isHide
  } = props;
  const originX = React.useRef(0);
  const originY = React.useRef(0);
  const currentX = React.useRef(0);
  const currentY = React.useRef(0);
  const rotateHolder = React.useRef(null);
  const customCursorWrapper = React.useRef(null);
  const customCursorIcon = React.useRef(null);
  const rotationNumber = React.useRef(null);
  const [translateX, setTranslateX] = React.useState(0);
  const [translateY, setTranslateY] = React.useState(0);
  const [isHolderRotating, setIsHolderRotating] = React.useState(false);
  const [isMouseEnterHolder, setMouseEnterHolder] = React.useState(false);
  React.useEffect(() => {
    const {
      translateX: newTranslateX,
      translateY: newTranslateY
    } = (0, _everUtils.calcRotationObj)(width, height, rotation);
    setTranslateX(newTranslateX);
    setTranslateY(newTranslateY);
  }, [width, height, rotation]);
  const updateCursor = React.useCallback((e, newRotate) => {
    if (customCursorWrapper.current) {
      customCursorIcon.current.style.transform = `rotate(${newRotate + angle - ROTATE_CURSOR_OFFSET}deg)`;
      customCursorWrapper.current.style.left = `${e.clientX}px`;
      customCursorWrapper.current.style.top = `${e.clientY}px`;
    }
  }, [angle]);
  const onRotateStart = React.useCallback(relativeEvent => {
    onEnterRotationMode();
    setIsHolderRotating(true);
    originX.current = relativeEvent.relativeX;
    originY.current = relativeEvent.relativeY;
    currentX.current = relativeEvent.relativeX;
    currentY.current = relativeEvent.relativeY;
  }, [onEnterRotationMode]);
  const onRotateMove = React.useCallback((relativeEvent, container, e) => {
    if (!rotateImageFrame) return;
    currentX.current = relativeEvent.relativeX;
    currentY.current = relativeEvent.relativeY;
    const rect = (0, _everUtils.getBoundingRelativeRect)(rotateImageFrame, container);
    const objX = rect.left + rect.width / 2;
    const objY = rect.top + rect.height / 2;
    const x1 = originX.current - objX;
    const y1 = originY.current - objY;
    const x2 = currentX.current - objX;
    const y2 = currentY.current - objY;
    const triangleTop = x1 * y2 - x2 * y1;
    const triangleBottom = x1 * x2 + y1 * y2;
    const arc = Math.atan2(triangleTop, triangleBottom) * 180 / Math.PI;
    let newRotate = (0, _everUtils.normalizeAngle)(rotation + arc);
    newRotate = (0, _fitRotate.default)(newRotate);
    rotateImageFrame.style.transform = `translate(${translateX * scale}px, ${translateY * scale}px) rotate(${newRotate}deg)`;
    rotationNumber.current.innerText = `${newRotate.toFixed(Number.isInteger(newRotate) ? 0 : 1)}°`;
    updateCursor(e, newRotate);
  }, [rotation, rotateImageFrame, scale, translateX, translateY, updateCursor]);
  const onRotateEnd = React.useCallback(() => {
    let newRotate = null;

    if (rotateImageFrame) {
      const zoomContainer = getZoomContainer();

      if (originX.current !== currentX.current || originY.current !== currentY.current) {
        const rect = (0, _everUtils.getBoundingRelativeRect)(rotateImageFrame, zoomContainer);
        const objX = rect.left + rect.width / 2;
        const objY = rect.top + rect.height / 2;
        const x1 = originX.current - objX;
        const y1 = originY.current - objY;
        const x2 = currentX.current - objX;
        const y2 = currentY.current - objY;
        const triangleTop = x1 * y2 - x2 * y1;
        const triangleBottom = x1 * x2 + y1 * y2;
        const arc = Math.atan2(triangleTop, triangleBottom) * 180 / Math.PI;
        newRotate = (0, _everUtils.normalizeAngle)(rotation + arc);
        newRotate = (0, _fitRotate.default)(newRotate);
      }
    }

    handleRotate(newRotate, () => setIsHolderRotating(false));
    originX.current = 0;
    originY.current = 0;
    currentX.current = 0;
    currentY.current = 0;
  }, [handleRotate, rotateImageFrame, rotation, getZoomContainer]);
  const handleMouseMove = React.useCallback(e => {
    e.preventDefault();
    e.stopPropagation();
    if (!rotateImageFrame) return;
    const zoomContainer = getZoomContainer();
    const relativeEvent = (0, _everUtils.getRelativeMouseEvent)(e, zoomContainer);
    onRotateMove(relativeEvent, zoomContainer, e);
  }, [getZoomContainer, onRotateMove, rotateImageFrame]);
  const handleMouseUp = React.useCallback(e => {
    e.preventDefault();
    e.stopPropagation();
    onRotateEnd();
  }, [onRotateEnd]);
  const handleMouseDown = React.useCallback(e => {
    e.preventDefault();
    e.stopPropagation();
    const zoomContainer = getZoomContainer();

    if (!zoomContainer) {
      return;
    }

    const relativeEvent = (0, _everUtils.getRelativeMouseEvent)(e, zoomContainer);
    onRotateStart(relativeEvent);
  }, [getZoomContainer, onRotateStart]);
  React.useEffect(() => {
    if (isHolderRotating) {
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
    }

    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
  }, [handleMouseUp, handleMouseMove, isHolderRotating]);
  React.useEffect(() => {
    return () => {
      // 销毁时必须重置父组件中 isRotating 的状态
      handleRotate(null);
    };
  }, [handleRotate]);
  const handleMouseMoveInHolder = React.useCallback(e => {
    if (isHolderRotating) {
      return;
    }

    updateCursor(e, rotation);
  }, [updateCursor, isHolderRotating, rotation]);
  const handleMouseLeave = React.useCallback(() => {
    setMouseEnterHolder(false);
  }, []);
  const handleMouseEnter = React.useCallback(() => {
    setMouseEnterHolder(true);
  }, []);
  React.useEffect(() => {
    if (isMouseEnterHolder) {
      rotateHolder.current?.addEventListener('mousemove', handleMouseMoveInHolder);
    }

    return () => {
      rotateHolder.current?.removeEventListener('mousemove', handleMouseMoveInHolder);
    };
  }, [isMouseEnterHolder, handleMouseMoveInHolder]);
  return /*#__PURE__*/_createElement(React.Fragment, null, /*#__PURE__*/_createElement(_styled.EditorRotateHolder, {
    onMouseDown: handleMouseDown,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    angle: angle,
    ref: rotateHolder,
    isHide: isHide,
    role: "rotator",
    "data-role": `${_everBamboo.PluginRoles.imageRotator}${angle}`
  }), (isMouseEnterHolder || isHolderRotating) && /*#__PURE__*/_reactDom.default.createPortal( /*#__PURE__*/_createElement(_styled.RotateCursorWrapper, {
    ref: customCursorWrapper
  }, /*#__PURE__*/_createElement(_styled.RotateCursorIcon, {
    ref: customCursorIcon,
    rotation: Number(rotation) + angle - ROTATE_CURSOR_OFFSET
  }, /*#__PURE__*/_createElement("img", {
    src: _styled.rotateIcon,
    srcSet: `${_styled.rotateIcon2x} 2x`
  })), /*#__PURE__*/_createElement(_styled.RotateCursorNumber, {
    ref: rotationNumber,
    rotating: isHolderRotating
  })), document.body), (isMouseEnterHolder || isHolderRotating) && _ref);
};

var _default = ImageRotateHolder;
exports.default = _default;
//# sourceMappingURL=imageRotateHolder.js.map