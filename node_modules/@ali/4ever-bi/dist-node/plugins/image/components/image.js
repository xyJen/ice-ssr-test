"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var React = _interopRequireWildcard(require("react"));

var ReactDOM = _interopRequireWildcard(require("react-dom"));

var _lodash = require("lodash");

var _classnames = _interopRequireDefault(require("classnames"));

var _resizeObserverPolyfill = _interopRequireDefault(require("resize-observer-polyfill"));

var _everCangjie = require("@ali/4ever-cangjie");

var _everComponent = require("@ali/4ever-component");

var _everBamboo = require("@ali/4ever-bamboo");

var _everUtils = require("@ali/4ever-utils");

var _actions = require("../actions");

var _imageEditor = _interopRequireDefault(require("./imageEditor"));

var _imageCrop = _interopRequireDefault(require("./imageCrop"));

var _ImageInlineToolbar = _interopRequireDefault(require("./ImageInlineToolbar"));

var _styled = require("./styled");

/* eslint-disable react/no-find-dom-node */
const _createElement = /*#__PURE__*/React.createElement;
const {
  Img,
  isComplexImg,
  isNodeInTable,
  isValidSize
} = _everBamboo.ImagePlugin;
const {
  closeContextMenu
} = _everBamboo.PcContextMenu;
const THROTTLE_PREVIEW_TIME = 400;
const IS_EMPTY_IGNORE_PROPS = ['uuid'];

function isImageRectChanged(prevData, data) {
  const {
    width,
    height,
    rotation,
    rectClip,
    outline
  } = data;
  const {
    width: prevWidth,
    height: prevHeight,
    rotation: prevRotation,
    rectClip: prevRectClip,
    outline: prevOutline
  } = prevData;
  return width !== prevWidth || height !== prevHeight || rotation !== prevRotation || !(0, _lodash.isEqual)(rectClip, prevRectClip) || outline?.width !== prevOutline?.width;
}

class Image extends React.Component {
  static getDerivedStateFromProps(props, state) {
    const {
      isSelected,
      node
    } = props;
    const isRectUpdating = isImageRectChanged(state.prevData, node.data);

    if (!isSelected || isRectUpdating) {
      const newIsCanPreview = !isSelected ? {
        isCanPreview: false
      } : undefined;
      const newUpdate = isRectUpdating ? {
        isUpdating: true,
        prevData: node.data
      } : undefined;
      return { ...newIsCanPreview,
        ...newUpdate
      };
    }

    return null;
  }

  constructor(props) {
    super(props);
    this.image = void 0;
    this.ref = void 0;
    this.isFirstLoad = void 0;
    this.frameId = -1;
    this.updatingEndFrameId = -1;
    this.updateMaxWidthFrameId = -1;
    this.isFocusedBeforeClick = false;
    this.resizeObserver = null;
    this.prevMaxWidth = void 0;

    this.getPortalPosition = () => {
      const {
        scale,
        zoomContainer
      } = this.props;

      if (!this.ref.current) {
        return {
          left: -9999,
          right: -9999
        };
      }

      const rect = (0, _everUtils.getBoundingRelativeRect)(this.ref.current, zoomContainer);
      const left = rect.left / scale;
      const top = rect.top / scale;
      return {
        left,
        top
      };
    };

    this.setIsLoaded = isLoaded => {
      this.setState({
        isLoaded
      });
    };

    this.getZoomContainer = () => {
      const {
        zoomContainer
      } = this.props;
      return zoomContainer;
    };

    this.getScrollableContent = () => {
      return this.props.scrollableContent || window.document.body;
    };

    this.onEnterCroppingMode = e => {
      e.preventDefault();
      e.stopPropagation();
      const {
        controller,
        node
      } = this.props;
      controller.run('onAction', (0, _actions.setImageInjection)(node.key, {
        isImageCropping: true
      }));
    };

    this.onExitCroppingMode = () => {
      const {
        controller,
        node
      } = this.props;
      controller.run('onAction', (0, _actions.setImageInjection)(node.key, {
        isImageCropping: false
      }));
    };

    this.onEnterRotationMode = () => {
      this.setState({
        isRotating: true
      });
    };

    this.onEnterResizingMode = () => {
      this.setState({
        isResizing: true
      });
    };

    this.exitRotationMode = cb => {
      this.setState({
        isRotating: false
      }, cb);
    };

    this.getImageContainer = () => {
      return this.ref.current;
    };

    this.handleChangeSize = (width, height, l = 0, r = 0, t = 0, b = 0) => {
      width = Number(width);
      height = Number(height);
      if (typeof width !== 'number' || typeof height !== 'number') return;
      const {
        node,
        controller
      } = this.props;
      const data = {
        width,
        height
      };

      if (l || t || r || b) {
        data.rectClip = {
          left: l,
          right: r,
          top: t,
          bottom: b
        };
      }

      const {
        rotation
      } = node.data;

      if (typeof rotation !== 'number') {
        data.rotation = 0;
      }

      controller.run('onAction', (0, _actions.updateImage)(node, data));
      this.setState({
        isResizing: false
      });
    };

    this.handleRotate = (rotation, cb) => {
      // 旋转同时会设置高宽，以方便排版等计算
      const {
        node,
        controller
      } = this.props;
      const {
        width,
        height
      } = node.data;
      const container = this.getZoomContainer();

      if (rotation !== null) {
        rotation = (0, _everUtils.normalizeAngle)(rotation, true);
        controller.run('onAction', (0, _actions.updateImage)(node, {
          rotation,
          width,
          height
        }, container));
      }

      this.exitRotationMode(cb);
    };

    this.handleInlineToolbarRotate = e => {
      e.preventDefault();
      e.stopPropagation();
      const {
        node
      } = this.props;
      const rotation = (0, _everUtils.getData)(node.data, 'rotation', 0);
      const newRotation = (0, _everUtils.normalizeAngle)(rotation + 90);
      this.handleRotate(newRotation);
    };

    this.handleInlineToolbarRotateAntiClockwise = e => {
      e.preventDefault();
      e.stopPropagation();
      const {
        node
      } = this.props;
      const rotation = (0, _everUtils.getData)(node.data, 'rotation', 0);
      const newRotation = (0, _everUtils.normalizeAngle)(rotation - 90);
      this.handleRotate(newRotation);
    };

    this.getUploadProgress = () => {
      const {
        node
      } = this.props;
      const {
        src,
        uploadPercent = 0
      } = node.data || {}; // upload.progress 到达 100% 时，整体进度只展示 95%
      // 不展示 100% 原因是还需要下载图片
      // 目前看 progress 在生产环境可代表真实进度

      return src ? 100 : uploadPercent * 0.95;
    };

    this.getCursor = () => {
      const {
        imageConfig = {},
        controller
      } = this.props;
      const {
        previewImage
      } = imageConfig;
      const {
        isFocused
      } = controller.value;

      if (previewImage && this.shouldShowToolbar() && isFocused) {
        return 'zoom-in';
      }

      return 'auto';
    };

    this.handlePreviewImage = () => {
      const {
        isLoaded
      } = this.state;
      const {
        imageConfig,
        node,
        controller
      } = this.props;
      const previewImage = imageConfig?.previewImage;
      if (!isLoaded || !previewImage) return;
      const {
        src
      } = node.data;
      const isSelectingNode = controller.query('isSelectingNode');
      if (isSelectingNode) return;
      previewImage(src, node);
    };

    this.throttleHandlePreviewImage = (0, _lodash.throttle)(this.handlePreviewImage, THROTTLE_PREVIEW_TIME);

    this.handleLoad = () => {
      this.setIsLoaded(true);
      const {
        url
      } = this.props.pluginState || {};

      if (url && url.startsWith('blob:')) {
        URL.revokeObjectURL(url);
      }
    };

    this.handleContextMenu = event => {
      event.preventDefault();
    };

    this.closeContextMenu = () => {
      const {
        controller
      } = this.props;
      controller.run('onAction', closeContextMenu());
    };

    this.handleImgClick = () => {
      this.closeContextMenu();
      const {
        controller,
        node
      } = this.props;

      if (_everBamboo.ImagePlugin.isParentClickable(controller, node)) {
        return;
      }

      if (this.state.isCanPreview && this.isFocusedBeforeClick) {
        this.handlePreviewImage();
      }
    };

    this.handleImgDoubleClick = () => {
      this.throttleHandlePreviewImage();
    };

    this.handleMouseDown = () => {
      this.isFocusedBeforeClick = this.props.controller.value.isFocused;
    };

    this.handleMouseEnter = e => {
      e.stopPropagation();
      this.setState({
        isHovering: true
      });
    };

    this.handleMouseLeave = () => {
      this.setState({
        isHovering: false
      });
    };

    this.handleMouseOver = e => {
      e.stopPropagation();
      this.props.onMouseOver(e);
    };

    this.getImgRectData = () => {
      const {
        node
      } = this.props;
      const {
        width,
        height,
        outline,
        rectClip
      } = node.data;
      const isComplex = isComplexImg(node.data);
      const isValid = isValidSize(width, height);
      const position = this.getPortalPosition();
      const l = rectClip?.left || 0;
      const r = rectClip?.right || 0;
      const t = rectClip?.top || 0;
      const b = rectClip?.bottom || 0;

      if (isComplex && isValid) {
        // img 标签的实际渲染宽度
        const fixedOutline = (outline?.width || 0) * 2; // HACK: 图片增加边框后整体所占的宽高不变，其实会导致图片变形，原因是宽高向内收缩的像素是相同的，但是图片的宽高比例不同
        // img 元素的实际宽度

        const renderImgWidth = this.image.current?.clientWidth || 0; // img 元素的实际长度

        const renderImgHeight = this.image.current?.clientHeight || 0; // 图片实际可见的宽度（不包含边框）= img 元素的实际宽度 * 剪裁后剩余部分所占的比例

        const renderVisibleWidth = renderImgWidth * (width / (width + l + r)); // 图片整体可见的宽度（包含边框）

        const renderContainerWidth = renderVisibleWidth + fixedOutline; // 图片整体可见的高度（包含边框）= 图片整体可见的宽度（包含边框） * 落库的高相对于宽的比例

        const renderContainerHeight = renderContainerWidth * (height / width); // 图片实际可见的高度（不包含边框） = 图片整体可见的高度 - 固定的边框（用户添加的边框）

        const renderVisibleHeight = renderContainerHeight - fixedOutline;
        return {
          width: renderVisibleWidth,
          height: renderVisibleHeight,
          l: renderImgWidth * (l / (width + l + r)),
          r: renderImgWidth * (r / (width + l + r)),
          t: renderImgHeight * (t / (height + t + b)),
          b: renderImgHeight * (b / (height + t + b)),
          ...position
        };
      }

      return {
        width: this.image.current?.clientWidth || 0,
        height: this.image.current?.clientHeight || 0,
        l,
        r,
        t,
        b,
        ...position
      };
    };

    this.getImgRef = () => {
      return this.image.current;
    };

    this.renderImage = () => {
      const {
        node,
        children,
        attributes,
        controller,
        scale,
        pluginState,
        imageConfig = {},
        zoomContainer
      } = this.props;
      const {
        url
      } = pluginState || {};
      const {
        isRotating,
        isResizing,
        isHovering,
        isTransferring,
        isLoaded,
        maxWidth
      } = this.state;
      const {
        src
      } = node.data;
      const {
        renderExtraNode
      } = imageConfig;
      const rotation = (0, _everUtils.getData)(node.data, 'rotation', 0);
      const {
        isBlurred
      } = controller.value;
      const uploadProgress = this.getUploadProgress();
      const normalizeRotation = (0, _everUtils.normalizeAngle)(rotation);
      const transformedSrc = this.calcSrc(src);
      const isImageSelected = this.shouldShowToolbar();
      const isHover = !isRotating && !isResizing && isHovering;
      return /*#__PURE__*/_createElement(React.Fragment, null, children, zoomContainer && this.isCropping() && this.ref.current ? /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/_createElement(_imageCrop.default, {
        src: transformedSrc,
        rotation: normalizeRotation,
        handleCrop: this.handleChangeSize,
        onExitCroppingMode: this.onExitCroppingMode,
        getImgRectData: this.getImgRectData,
        getZoomContainer: this.getZoomContainer,
        controller: controller,
        scale: scale
      }), zoomContainer) : null, /*#__PURE__*/_createElement(_styled.ImgMeta, {
        style: {
          visibility: this.isCropping() || this.isRotating() ? 'hidden' : 'visible',
          userSelect: this.isCropping() || this.isRotating() ? 'none' : 'auto',
          maxWidth
        },
        className: (0, _classnames.default)({
          'show-highlight': isImageSelected && !isResizing && !isBlurred,
          'disable-highlight-when-hover': isResizing
        }),
        imgCursor: this.getCursor(),
        onMouseEnter: renderExtraNode && this.handleMouseEnter,
        onMouseLeave: renderExtraNode && this.handleMouseLeave,
        onMouseOver: this.handleMouseOver,
        "data-hover-box": "noBorderBox"
      }, /*#__PURE__*/_createElement(Img, (0, _extends2.default)({}, attributes, {
        ref: this.image,
        uploadPlaceholder: url,
        node: node,
        controller: controller,
        uploadProgress: uploadProgress,
        onDoubleClick: this.handleImgDoubleClick,
        onContextMenu: this.handleContextMenu,
        onClick: this.handleImgClick,
        onMouseDown: this.handleMouseDown,
        isTransferring: isTransferring,
        imageConfig: imageConfig,
        onLoad: this.handleLoad
      })), renderExtraNode && renderExtraNode(node, isHover, isImageSelected)), zoomContainer && isImageSelected && !this.state.isUpdating && this.ref.current && /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/_createElement(_imageEditor.default, {
        node: node,
        src: transformedSrc,
        controller: controller,
        scale: scale,
        rotation: normalizeRotation,
        onChangeSize: this.handleChangeSize,
        onEnterRotationMode: this.onEnterRotationMode,
        handleRotate: this.handleRotate,
        onEnterResizingMode: this.onEnterResizingMode,
        isRotating: isRotating,
        getZoomContainer: this.getZoomContainer,
        onContextMenu: this.handleContextMenu,
        imageConfig: imageConfig,
        isLoaded: isLoaded,
        isBlurred: isBlurred,
        getImgRectData: this.getImgRectData,
        getImgRef: this.getImgRef
      }), zoomContainer));
    };

    const {
      pluginState: _pluginState,
      isSelected,
      node: _node,
      imageConfig: _imageConfig
    } = props;
    this.state = {
      isRotating: false,
      isResizing: false,
      isHovering: false,
      isTransferring: _pluginState && _pluginState.isTransferring,
      // @ts-ignore
      isLoaded: !!_imageConfig?.isTesting,
      isCanPreview: isSelected,
      // 解决图片编辑后，编辑框未更新或编辑框闪烁更新
      // 原因: 由于自适应后图片编辑后的尺寸不一定与编辑结束时一致，Image Editor 需要感知图片实际 render 的尺寸，但是可能传入未渲染完成的 render size，造成编辑框未更新。
      // 解法1：在本组件的 componentDidUpdate 中，更新render size state时加上延时，可以解决未更新的问题，但是编辑框会闪烁。
      // 解法2：增加 isUpdating state，默认为 false，在resize 和 旋转结束、更新图片时设置 isUpdating 为 true，紧接着延时设置为 false（预期渲染完毕）
      // ，触发render，由于在 isUpdating = true 时不会渲染编辑框，因此不会出现编辑框闪烁的问题。
      isUpdating: false,
      prevData: _node.data,
      maxWidth: this.getIsAutoFit() ? '100%' : undefined
    };
    this.image = /*#__PURE__*/React.createRef();
    this.ref = /*#__PURE__*/React.createRef();
    this.isFirstLoad = true;
  }

  getIsAutoFit() {
    const {
      node,
      controller,
      imageConfig
    } = this.props;
    const {
      disableStretchMode
    } = imageConfig || {};
    const isInTable = isNodeInTable(node, controller.value.document);
    const disableStretch = typeof disableStretchMode === 'function' && disableStretchMode();
    const isAutoFit = !disableStretch || isInTable;
    return isAutoFit;
  }

  initResizeObserver() {
    const {
      imageConfig = {},
      controller,
      node
    } = this.props;
    const {
      getMaxWidthContainer
    } = imageConfig;
    const maxWidthContainer = getMaxWidthContainer && getMaxWidthContainer(node, controller.value.document);

    if (!maxWidthContainer) {
      return;
    }

    const updateMaxWidth = (0, _lodash.throttle)(() => {
      this.updateMaxWidthFrameId = window.requestAnimationFrame(() => {
        const maxWidth = maxWidthContainer.clientWidth;
        this.setState({
          maxWidth: maxWidth || '100%'
        });
      });
    }, 200);

    const observerCallback = entries => {
      for (const entry of entries) {
        if (this.prevMaxWidth !== entry.contentRect.width) {
          updateMaxWidth();
          this.prevMaxWidth = entry.contentRect.width;
        }
      }
    };

    this.resizeObserver = new _resizeObserverPolyfill.default(observerCallback);
    this.resizeObserver.observe(maxWidthContainer);
  }

  componentDidMount() {
    if (this.getIsAutoFit()) {
      this.initResizeObserver();
    }
  }

  componentDidUpdate(prevProps, prevState) {
    const {
      pluginState
    } = this.props;
    const prevPluginState = prevProps.pluginState;
    const {
      isTransferring
    } = pluginState;

    if (prevPluginState.isTransferring !== isTransferring) {
      this.setState({
        isTransferring
      });
    }

    if (this.state.isUpdating && this.state.prevData && this.state.prevData !== prevState.prevData) {
      window.cancelAnimationFrame(this.updatingEndFrameId);
      this.updatingEndFrameId = window.requestAnimationFrame(() => {
        this.setState({
          isUpdating: false,
          isResizing: false,
          isRotating: false
        });
      });
    } // preview 功能等待一个 frame 周期，防止 mousedown 提前更新导致的单击进入预览的问题


    if (this.props.isSelected && !this.state.isCanPreview) {
      this.frameId = window.requestAnimationFrame(() => {
        this.setState({
          isCanPreview: true
        });
      });
    }

    if (!this.props.isSelected && prevProps.isSelected) {
      this.state.isResizing && this.setState({
        isResizing: false
      });
    }
  }

  componentWillUnmount() {
    window.cancelAnimationFrame(this.frameId);
    window.cancelAnimationFrame(this.updatingEndFrameId);
    window.cancelAnimationFrame(this.updateMaxWidthFrameId);
    this.resizeObserver && this.resizeObserver.disconnect();
    const {
      url
    } = this.props.pluginState || {};

    if (url && url.startsWith('blob:')) {
      URL.revokeObjectURL(url);
    }
  }

  calcSrc(src) {
    if (src === null) return null;

    if (!src) {
      const {
        pluginState
      } = this.props;
      const {
        url
      } = pluginState || {};
      return url;
    }

    const {
      imageManager,
      imageConfig = {}
    } = this.props;
    const {
      protocolAllowList
    } = imageConfig;
    const renderSrc = imageManager?.getTransformedURL(src) || src;
    return (0, _everUtils.sanitizeUrl)(renderSrc, protocolAllowList);
  }

  shouldShowToolbar() {
    const {
      controller,
      isSelected
    } = this.props;
    return !this.isCropping() && isSelected && controller.value.selection.isCollapsed;
  }

  isCropping() {
    const {
      node
    } = this.props;
    return node.data.isImageCropping;
  }

  isSettingBorder() {
    const {
      node
    } = this.props;
    return node.data.isSettingBorder;
  }

  isRotating() {
    const {
      isRotating
    } = this.state;
    const {
      node
    } = this.props;
    const {
      width,
      height
    } = node.data;
    return isRotating && typeof width === 'number' && typeof height === 'number';
  }

  renderInlineToolbar() {
    const {
      controller,
      node,
      imageConfig
    } = this.props;
    const showToolbar = this.shouldShowToolbar() && (controller.value.isFocused || this.isSettingBorder());
    if (!showToolbar) return null;
    const {
      previewImage,
      downloadImage,
      locale,
      customToolbars,
      inlineToolbarMore
    } = imageConfig || {};
    const realInlineLayout = controller.query('getImageInlineToolbarLayout');
    const hasInlineToolbar = Array.isArray(realInlineLayout) && realInlineLayout.length > 0;
    return hasInlineToolbar && /*#__PURE__*/_createElement(_ImageInlineToolbar.default, {
      visible: true,
      controller: controller,
      triggerNode: this.ref.current,
      node: node,
      locale: locale,
      handleInlineToolbarRotate: this.handleInlineToolbarRotate,
      handleInlineToolbarRotateAntiClockwise: this.handleInlineToolbarRotateAntiClockwise,
      previewImage: previewImage,
      downloadImage: downloadImage,
      onEnterCroppingMode: this.onEnterCroppingMode,
      getZoomContainer: this.getZoomContainer,
      getScrollableContent: this.getScrollableContent,
      inlineToolbarLayout: realInlineLayout // @ts-ignore
      ,
      customToolbars: customToolbars,
      inlineToolbarMore: inlineToolbarMore
    });
  }

  render() {
    const {
      isLoaded,
      isResizing,
      isRotating
    } = this.state;
    const {
      disableInlineToolbar
    } = this.props;
    return /*#__PURE__*/_createElement(React.Fragment, null, !disableInlineToolbar && isLoaded && !(isResizing || isRotating) && this.renderInlineToolbar(), /*#__PURE__*/_createElement(_styled.ImgContent, {
      ref: this.ref
    }, this.renderImage()));
  }

}

const Container = props => {
  const {
    controller,
    node,
    imageConfig
  } = props;
  const scrollableContent = (0, _everBamboo.useScrollableContent)();
  const zoomContainer = (0, _everCangjie.useZoomContainer)() || document.body;
  const scale = (0, _everCangjie.useZoom)();

  const imageManager = _everBamboo.ImagePlugin.useImageManager();

  const [isSelected, setSelected] = React.useState(false);
  const disableInlineToolbar = controller.query('hasHoverToolbar', 'image');
  const hoverHandlers = (0, _everComponent.useHover)(true)[1];
  const handlePendingSelectionChange = React.useCallback(() => {
    const {
      selection
    } = controller.value;
    const {
      isCollapsed,
      anchor
    } = selection;

    if (!isCollapsed) {
      isSelected && setSelected(false);
    } else {
      const isPendingSelected = node.hasNode(anchor.key);
      isSelected !== isPendingSelected && setSelected(isPendingSelected);
    }
  }, [controller, node, isSelected]);
  (0, _everCangjie.useSelectionData)(controller.selectionData$, null, handlePendingSelectionChange, []);

  if (!node.data || (0, _lodash.isEmpty)((0, _lodash.omit)(node.data, IS_EMPTY_IGNORE_PROPS))) {
    return /*#__PURE__*/_createElement(_everBamboo.ImagePlugin.InlinePlaceholder, {
      onClick: () => controller.run('onAction', (0, _actions.selectImage)(node.key))
    }, imageConfig?.locale?.placeholder || 'Image');
  }

  return /*#__PURE__*/_createElement(Image, (0, _extends2.default)({}, props, {
    scrollableContent: scrollableContent,
    zoomContainer: zoomContainer,
    scale: scale,
    isSelected: controller.enablePending.selection ? isSelected : props.isSelected,
    imageManager: imageManager,
    disableInlineToolbar: disableInlineToolbar,
    onMouseOver: hoverHandlers.onMouseOver
  }));
};

var _default = Container;
exports.default = _default;
//# sourceMappingURL=image.js.map