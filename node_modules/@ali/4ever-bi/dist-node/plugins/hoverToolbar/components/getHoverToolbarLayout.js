"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getHoverToolbarLayout = getHoverToolbarLayout;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _react = _interopRequireDefault(require("react"));

var _weDesignNext = require("@ali/we-design-next");

var _MoreMenuButton = require("./MoreMenuButton");

var _getNodeType = _interopRequireDefault(require("../utils/getNodeType"));

const _createElement = /*#__PURE__*/_react.default.createElement;

function isReactElementValid(element) {
  const validDisplayNames = ['iconButton', 'iconMenu', 'splitButton', 'iconSelect', 'textSelect', 'toolbarSlot'];
  const {
    displayName
  } = element.type;
  return validDisplayNames.indexOf(displayName) > -1;
}

function getHoverToolbarLayout(params) {
  const {
    layoutConfigs,
    plugins,
    controller,
    node,
    hoverCapture,
    locale,
    visiblePopoverSet,
    setActiveInteraction,
    activeRef,
    reset
  } = params;
  const type = (0, _getNodeType.default)(node, controller);
  const layoutConfig = layoutConfigs[type];
  const {
    folded = [],
    normal = [],
    splitFolded
  } = layoutConfig || {};

  if (!plugins || !layoutConfig || !(folded && folded.length > 0) && !(normal && normal.length > 0)) {
    return undefined;
  }

  const onOverlayVisibleChange = (visible, key) => {
    // popover 的 onOverlayVisibleChange 是异步方法
    if (!hoverCapture.getCurrentNode()) {
      hoverCapture?.enableTrigger();
      return;
    }

    if (visible) {
      visiblePopoverSet.add(key);
    } else {
      visiblePopoverSet.delete(key);
    }

    if (visiblePopoverSet.size > 0) {
      setActiveInteraction('hoverToolbarPopover');
      hoverCapture?.disableTrigger();
    } else {
      if (activeRef.current === 'hoverToolbarPopover') {
        setActiveInteraction('');
      }

      hoverCapture?.enableTrigger();
    }
  };

  const getNode = () => {
    const {
      document
    } = controller.value;
    const path = document.getPath(node.key);
    return path ? document.getNodeByPath(path) : null;
  };

  const layout = normal.map(group => {
    return group.map(item => {
      const [pluginName, buttonName = 'default'] = item.split('.');
      const render = plugins.hash[pluginName]?.renderHoverToolbar;
      if (!render) return null;
      const extraProps = {
        onOverlayVisibleChange: v => {
          onOverlayVisibleChange(v, item);
        }
      };
      const buttonOrButtonProps = render({
        buttonName,
        extraProps
      }, controller, getNode);

      if ( /*#__PURE__*/_react.default.isValidElement(buttonOrButtonProps)) {
        if (isReactElementValid(buttonOrButtonProps)) {
          return /*#__PURE__*/_react.default.cloneElement(buttonOrButtonProps, {
            key: item
          });
        } else {
          console.error('Toolbar 内必须使用指定的组件');
          return null;
        }
      } else if (buttonOrButtonProps && typeof buttonOrButtonProps === 'object') {
        const {
          onClick,
          autoClose,
          ...rest
        } = buttonOrButtonProps;
        let handleClick = onClick;

        if (autoClose) {
          handleClick = e => {
            onClick && onClick(e);
            hoverCapture.forceClose();
            reset();
            setActiveInteraction('');
          };
        }

        return (
          /*#__PURE__*/
          // TODO：@淼淼 支持替换 icon
          _createElement(_weDesignNext.TBIconButton, (0, _extends2.default)({}, rest, {
            onClick: handleClick,
            key: item
          }))
        );
      }

      return null;
    }).filter(groupItem => !!groupItem);
  }).filter(groupLayout => groupLayout && groupLayout.length > 0);
  let moreMenuItems = [];
  const clickMap = {};
  folded.forEach(group => {
    const groupItems = [];
    group.forEach(item => {
      const [pluginName, buttonName = 'default'] = item.split('.');
      const extraProps = {
        onOverlayVisibleChange: v => {
          onOverlayVisibleChange(v, item);
        }
      };
      const buttonProps = plugins.hash[pluginName]?.renderHoverToolbar?.({
        buttonName,
        extraProps
      }, controller, getNode);

      if (buttonProps && typeof buttonProps === 'object') {
        const {
          title,
          icon: prefix,
          disabled,
          onClick,
          autoClose,
          testid,
          role
        } = buttonProps;

        if (onClick) {
          const handleClick = autoClose ? e => {
            onClick(e);
            hoverCapture.forceClose();
            setActiveInteraction('');
            reset();
          } : onClick; // @ts-ignore

          clickMap[item] = handleClick;
          groupItems.push({
            key: item,
            title: title || '',
            prefix,
            disabled,
            testid,
            ['data-role']: role
          });
        }
      }
    });

    if (groupItems.length > 0) {
      moreMenuItems = moreMenuItems.concat(groupItems, 'divider');
    }
  });
  let moreButtonMenu = null;

  if (moreMenuItems.length > 0) {
    moreMenuItems.pop();

    const onSelect = key => {
      clickMap[key] && clickMap[key]();
    };

    moreButtonMenu = /*#__PURE__*/_createElement(_weDesignNext.TBItemSlot, {
      display: "iconButton"
    }, /*#__PURE__*/_createElement(_MoreMenuButton.MoreMenuButton, {
      onSelect: onSelect,
      items: moreMenuItems,
      onOverlayVisibleChange: v => {
        onOverlayVisibleChange(v, 'more');
      },
      locale: locale
    }));
  }

  if (moreButtonMenu) {
    const length = layout?.length;
    const lastGroup = length > 0 ? layout[length - 1] : null;

    if (splitFolded || !lastGroup) {
      layout.push([moreButtonMenu]);
    } else {
      lastGroup.push(moreButtonMenu);
    }
  }

  const {
    length
  } = layout;
  let layoutWithDivider = [];
  layout.forEach((block, index) => {
    if (index < length - 1) {
      layoutWithDivider = layoutWithDivider.concat(block, 'divider');
    } else {
      layoutWithDivider.push(block);
    }
  });
  return layoutWithDivider;
}
//# sourceMappingURL=getHoverToolbarLayout.js.map