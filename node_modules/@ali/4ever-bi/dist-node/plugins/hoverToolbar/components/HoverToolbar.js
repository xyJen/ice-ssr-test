"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HoverToolbar = void 0;

var _react = _interopRequireDefault(require("react"));

var _lodash = require("lodash");

var _resizeObserverPolyfill = _interopRequireDefault(require("resize-observer-polyfill"));

var _weDesignNext = require("@ali/we-design-next");

var _everCangjie = require("@ali/4ever-cangjie");

var _everBamboo = require("@ali/4ever-bamboo");

var _everComponent = require("@ali/4ever-component");

var _pluginsContext = require("../../../pluginsContext");

var _hoverCaptureContext = require("../context/hoverCaptureContext");

var _constants = require("../constants");

var _getHoverToolbarLayout = require("./getHoverToolbarLayout");

var _styled = require("./styled");

const _createElement = /*#__PURE__*/_react.default.createElement;
const {
  useActiveInteraction
} = _everComponent.ActiveInteractionHooks;

const HoverToolbar = props => {
  const {
    controller,
    configs
  } = props;
  const plugins = (0, _pluginsContext.usePlugins)();
  const zoomContainer = (0, _everCangjie.useZoomContainer)();
  const scrollableContainer = (0, _everBamboo.useScrollableContainer)();
  const hoverCapture = (0, _hoverCaptureContext.useHoverCapture)();
  const zoom = (0, _everCangjie.useZoom)();

  const currentNode = _react.default.useRef(null);

  const [singleToolbar, setSingleToolbar] = _react.default.useState();

  const wrapperRef = _react.default.useRef(null);

  const toolbarWidth = _react.default.useRef(0);

  const [inOuterContainer, setInOuterContainer] = _react.default.useState(false);

  const inOuterContainerRef = _react.default.useRef(false);

  const innerContainer = zoomContainer || window.document.body;
  const outerContainer = scrollableContainer instanceof Element ? scrollableContainer : window.document.body;
  const container = inOuterContainer ? outerContainer : innerContainer;

  const visiblePopoverSetRef = _react.default.useRef(new Set());

  const needSlidInRef = _react.default.useRef(false);

  const [isVisible, setVisible] = _react.default.useState(false);

  const content = (0, _everBamboo.useScrollableContent)();
  const [activeType, setActiveType] = useActiveInteraction();

  const activeRef = _react.default.useRef('');

  activeRef.current = activeType;

  const [currentKey, setCurrentKey] = _react.default.useState('');

  const showHoverToolbar = singleToolbar && singleToolbar.length > 0;
  inOuterContainerRef.current = inOuterContainer;
  const locale = configs.locale || {};

  _react.default.useEffect(() => {
    // inOuterContainer 更新时浮动工具栏会重新渲染
    hoverCapture?.enableTrigger();

    if (wrapperRef.current) {
      wrapperRef.current.style.opacity = '1';
    }
  }, [inOuterContainer, hoverCapture]);

  const reset = _react.default.useCallback(() => {
    visiblePopoverSetRef.current.clear();
    hoverCapture?.enableTrigger();
    setSingleToolbar(undefined);
    toolbarWidth.current = 0;
  }, [hoverCapture]);

  _react.default.useEffect(() => {
    if (activeType && activeType !== 'hoverToolbarPopover') {
      hoverCapture?.forceClose();
      reset();
    }
  }, [activeType, hoverCapture]);

  const updatePos = _react.default.useCallback(() => {
    const node = currentNode.current;

    if (node && wrapperRef.current) {
      if (toolbarWidth.current === 0) {
        wrapperRef.current.style.opacity = '0';
        return;
      }

      const nodeDOM = _everCangjie.domUtils.findDOMNodeSafely(node.key, innerContainer);

      if (nodeDOM) {
        const newStyle = {
          position: 'absolute'
        };
        const nodeRect = nodeDOM.getBoundingClientRect();
        const contentRect = innerContainer.getBoundingClientRect();
        const containerRect = !scrollableContainer || scrollableContainer instanceof Window ? {
          x: 0,
          y: 0,
          width: window.innerWidth,
          height: window.innerHeight
        } : scrollableContainer.getBoundingClientRect();
        const {
          x: nodeX,
          y: nodeY,
          width: nodeW,
          height: nodeH
        } = nodeRect;
        const {
          y: containerY,
          height: containerH
        } = containerRect;
        const {
          x: contentX,
          y: contentY,
          width: contentWidth
        } = contentRect;
        const contentW = contentWidth || innerContainer.offsetWidth * zoom; // 滚动的时候 contentWidth 可能为 0，会产生抖动

        if (contentWidth === 0) {
          return;
        } // 元素滚出下边缘


        if (nodeY > containerY + containerH) {
          newStyle.opacity = '0';
          setVisible(false); // 元素上边缘与滚动容器之间的距离足够固定安全距离 + 自适应安全距离 + 工具栏高度, 相对于纸张
        } else if (nodeY >= containerY + (_constants.SAFE_CONTAINER_MARGIN_TOP + _constants.SAFE_NODE_MARGIN_TOP + _constants.HOVER_TOOLBAR_HEIGHT) * zoom) {
          const top = (nodeY - contentY) / zoom - _constants.SAFE_NODE_MARGIN_TOP - _constants.HOVER_TOOLBAR_HEIGHT;
          newStyle.top = top;

          if (inOuterContainerRef.current) {
            setInOuterContainer(false);
            newStyle.opacity = '0';
          } else {
            newStyle.opacity = '1';
            wrapperRef.current.classList.remove(_styled.HOVER_TOOLBAR_NOT_READY);
          }

          setVisible(true); // 工具栏上边缘与容器上边缘距离固定, 相对于window
        } else if (nodeY + nodeH >= containerY + (_constants.SAFE_CONTAINER_MARGIN_TOP + _constants.HOVER_TOOLBAR_HEIGHT) * zoom) {
          const top = containerY + _constants.SAFE_CONTAINER_MARGIN_TOP * zoom + (zoom - 1) * _constants.HOVER_TOOLBAR_HEIGHT / 2;
          newStyle.top = top;
          newStyle.position = 'fixed';

          if (!inOuterContainerRef.current) {
            setInOuterContainer(true);
            newStyle.opacity = '0';
          } else {
            newStyle.opacity = '1';
            wrapperRef.current.classList.remove(_styled.HOVER_TOOLBAR_NOT_READY);
          }

          setVisible(true); // 元素下边缘与滚动容器上边缘之间的距离不能容纳 工具栏高度 + 最小安全距离
        } else {
          setVisible(false);
          newStyle.opacity = '0';
        } // 居中后左侧放不下


        if (nodeX + nodeW / 2 - toolbarWidth.current * zoom / 2 - _constants.SAFE_CONTAINER_MARGIN_RIGHT_OR_LEFT * zoom < contentX) {
          if (inOuterContainerRef.current) {
            newStyle.left = _constants.SAFE_CONTAINER_MARGIN_RIGHT_OR_LEFT * zoom + contentX;
          } else {
            newStyle.left = _constants.SAFE_CONTAINER_MARGIN_RIGHT_OR_LEFT;
          }
        } else if (nodeX + nodeW / 2 - toolbarWidth.current * zoom / 2 - _constants.SAFE_CONTAINER_MARGIN_RIGHT_OR_LEFT * zoom >= contentX && nodeX + nodeW / 2 + toolbarWidth.current * zoom / 2 + _constants.SAFE_CONTAINER_MARGIN_RIGHT_OR_LEFT * zoom <= contentX + contentW) {
          if (inOuterContainerRef.current) {
            newStyle.left = nodeX + nodeW / 2 - toolbarWidth.current / 2;
          } else {
            newStyle.left = (nodeX + nodeW / 2 - toolbarWidth.current / 2 * zoom - contentX) / zoom;
          }
        } else if (inOuterContainerRef.current) {
          newStyle.left = contentX + contentW - _constants.SAFE_CONTAINER_MARGIN_RIGHT_OR_LEFT * zoom;
        } else {
          newStyle.left = (contentX + contentW) / zoom - _constants.SAFE_CONTAINER_MARGIN_RIGHT_OR_LEFT;
        }

        if (!wrapperRef.current) {
          hoverCapture?.forceClose();
          return;
        }

        wrapperRef.current.style.top = `${newStyle.top || 0}px`;
        wrapperRef.current.style.left = `${newStyle.left || 0}px`;
        wrapperRef.current.style.opacity = (newStyle.opacity || 0).toString();
        wrapperRef.current.style.position = newStyle.position || 'absolute';

        if (needSlidInRef.current && !wrapperRef.current.classList.contains(_styled.HOVER_TOOLBAR_NOT_READY)) {
          wrapperRef.current.classList.add(_styled.HOVER_TOOLBAR_SLIDE_IN);
        }
      } else {
        hoverCapture?.forceClose();
      }
    }
  }, [zoom, scrollableContainer, innerContainer, hoverCapture]);

  _react.default.useEffect(() => {
    if (!singleToolbar) return _lodash.noop;
    const handleResize = (0, _lodash.debounce)(() => {
      const newWidth = wrapperRef.current?.offsetWidth || 0;

      if (toolbarWidth.current !== newWidth) {
        toolbarWidth.current = newWidth;
        updatePos();
      }
    }, 200);
    const observer = new _resizeObserverPolyfill.default(handleResize);
    wrapperRef.current && observer.observe(wrapperRef.current);
    return () => {
      observer.disconnect();
      handleResize.cancel();
      toolbarWidth.current = 0;
    };
  }, [singleToolbar, updatePos]);

  _react.default.useEffect(() => {
    if (!singleToolbar) return _lodash.noop;
    const handleChange = (0, _lodash.throttle)(() => {
      updatePos();
    }, 200);
    const mutationObserver = new MutationObserver(handleChange);
    content && mutationObserver.observe(content, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ['style']
    });
    return () => {
      mutationObserver && mutationObserver.disconnect();
      handleChange.cancel();
    };
  }, [singleToolbar, updatePos, content]);

  const getContainer = _react.default.useCallback(() => {
    // Hack: 缩放的时候 popover 内部使用的 dom-align 不能正确定位到被 scale 的容器，所以需要挂载到 dom 上，缺点时不会跟随滚动
    if (zoom !== 1) {
      return window.document.body;
    }

    const innerContainer = zoomContainer || window.document.body;
    const outerContainer = scrollableContainer instanceof Element ? scrollableContainer : window.document.body;
    const container = inOuterContainerRef.current ? outerContainer : innerContainer;
    return container;
  }, [zoomContainer, scrollableContainer, zoom]);

  _react.default.useEffect(() => {
    const handleTrigger = msg => {
      // 有其他激活中的菜单就不触发
      if (activeRef.current && activeRef.current !== 'hoverToolbarPopover') {
        return;
      }

      const {
        node = null
      } = msg;

      if (currentNode.current !== node) {
        if (!currentNode.current) {
          needSlidInRef.current = true;
        }

        const currentLayout = node ? (0, _getHoverToolbarLayout.getHoverToolbarLayout)({
          layoutConfigs: configs.layouts || {},
          plugins,
          controller,
          node,
          hoverCapture: hoverCapture,
          locale,
          visiblePopoverSet: visiblePopoverSetRef.current,
          activeRef,
          setActiveInteraction: setActiveType,
          reset
        }) : undefined;
        setSingleToolbar(currentLayout);
        setCurrentKey(node?.key || '');
        currentNode.current = node;
        toolbarWidth.current = 0;

        if (!node) {
          visiblePopoverSetRef.current.clear();
          hoverCapture?.enableTrigger();
        }
      }
    };

    hoverCapture?.on(handleTrigger);
    return () => {
      hoverCapture?.off(handleTrigger);
    };
  }, [controller, configs, plugins, hoverCapture, updatePos, reset, setActiveType]);

  _react.default.useEffect(() => {
    const handleScroll = (0, _lodash.throttle)(() => {
      updatePos();
    }, _constants.SCROLL_TIMEOUT);
    scrollableContainer?.addEventListener('scroll', handleScroll);
    return () => {
      scrollableContainer?.removeEventListener('scroll', handleScroll);
    };
  }, [scrollableContainer, updatePos]);

  const handleMouseEnter = _react.default.useCallback(() => {
    const node = hoverCapture?.getCurrentNode();
    if (!_everCangjie.Block.isBlock(node) && !_everCangjie.Inline.isInline(node)) return;
    controller.dispatch('updateHighlight', {
      node,
      type: 'hover',
      reason: 'hoverToolbar'
    });
  }, [hoverCapture]);

  const handleMouseLeave = _react.default.useCallback(() => {
    const node = hoverCapture?.getCurrentNode();
    if (!_everCangjie.Block.isBlock(node) && !_everCangjie.Inline.isInline(node)) return;
    controller.dispatch('removeHighlight', {
      node,
      type: 'hover',
      reason: 'hoverToolbar'
    });
  }, [hoverCapture]);

  const handleAnimationEnd = _react.default.useCallback(event => {
    const {
      target
    } = event;
    const {
      classList
    } = target;
    classList.remove(_styled.HOVER_TOOLBAR_SLIDE_IN);
    needSlidInRef.current = false;
  }, []);

  return showHoverToolbar ? /*#__PURE__*/_createElement(_everComponent.BasicPortal, {
    container: container
  }, /*#__PURE__*/_createElement(_styled.HoverToolbarWrapper, {
    ref: wrapperRef,
    className: `hover-toolbar-wrapper ${_styled.HOVER_TOOLBAR_NOT_READY}`,
    "data-hover-toolbar": true,
    style: {
      '--hover-toolbar-transform': inOuterContainer ? `scale(${zoom})` : 'scale(1)'
    },
    "data-testid": "hover-toolbar",
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    onAnimationEnd: handleAnimationEnd,
    "data-role": _everBamboo.PluginRoles.hoverToolbar
  }, /*#__PURE__*/_createElement(_everComponent.HoverToolbarContexts.GetContainerContext.Provider, {
    value: getContainer
  }, /*#__PURE__*/_createElement(_everComponent.HoverToolbarContexts.HoverToolbarVisibleContext.Provider, {
    value: isVisible
  }, /*#__PURE__*/_createElement(_everComponent.HoverToolbarContexts.VisiblePopoverSetContext.Provider, {
    value: visiblePopoverSetRef.current
  }, /*#__PURE__*/_createElement(_weDesignNext.ToolbarLayout, {
    mode: "singleLine",
    singleLineToolbar: singleToolbar,
    layout: "fit-content",
    align: "left",
    style: {
      padding: '2px 0'
    },
    key: currentKey
  })))))) : null;
};

exports.HoverToolbar = HoverToolbar;
//# sourceMappingURL=HoverToolbar.js.map