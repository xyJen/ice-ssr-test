"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = onEnter;

var _everCangjie = require("@ali/4ever-cangjie");

var _everMo = require("@ali/4ever-mo");

var _everUtils = require("@ali/4ever-utils");

var _lodash = require("lodash");

var _everPluginHeadingGroup = require("@ali/4ever-plugin-heading-group");

function onEnter(event, controller, next) {
  const {
    value
  } = controller;
  const {
    startBlock,
    selection,
    document
  } = value;
  if (!startBlock || !selection) return next();
  const closestParagraphBlock = (0, _everUtils.getClosestParagraph)(value);
  if (!closestParagraphBlock) return next();

  if (!_everMo.Heading.isHeading(closestParagraphBlock)) {
    return next();
  }

  event.preventDefault();
  const {
    start,
    end
  } = selection.convertToTextPoints(document);
  const {
    isCollapsed,
    isExpanded
  } = selection;
  const closestInline = document.getClosestInline(start.key);
  const isEnterAtInline = isCollapsed && closestInline && // allow to split a link
  closestInline.type !== 'link' && start.offset === 0;

  if (isEnterAtInline) {
    // just move to next text like normal paragraph
    return controller.command(_everCangjie.Commands.moveToStartOfNextText);
  }

  const isFoldNode = controller.userData.get(closestParagraphBlock, 'fold');
  /**
   * 若当前节点是 GroupNode list 节点，做可视节点的切割
   *  I -> 光标坐在位置，在光标位置按 Enter 键
   * 
   * 场景一: 折叠标题一 拆为标题一 和 空标题一
   * 
   *  >标题一I            >标题一
   *   标题一       ->     I<空标题一>
   *                      标题一
   * 
   * 场景二: 展开标题一 拆为 展开标题一 和 空段落
   * 
   *   标题一I            标题一
   *   普通段落       ->  I<空段落>
   *                     普通段落
   * 场景三: 折叠标题一 拆为标题一 和 空段落
   * 
   *  >I标题一            ><空标题一>
   *   标题一       ->    I标题一
   *                     
   * 
   * 场景四：后边无节点的折叠标题一 拆为折叠标题一 和空标题一
   * 
   *  >标题一I        ->  >标题一
   *                     I<空标题一>
   */

  const splitViewGroup = () => {
    const nextViewNode = isFoldNode && (0, _everPluginHeadingGroup.getNextViewGroupNode)(closestParagraphBlock, controller);
    controller.command(_everCangjie.Commands.splitBlock);
    const anchorBlock = controller.value.anchorBlock;

    if (!anchorBlock) {
      return;
    }

    controller.command(_everCangjie.Commands.setNodeByKey, anchorBlock.key, {
      data: { ...(0, _lodash.omit)(anchorBlock.data, 'fold', 'uuid')
      },
      type: closestParagraphBlock.type
    });

    if (nextViewNode) {
      const previous = document.getPreviousBlock(nextViewNode.key);
      previous && controller.command(_everCangjie.Commands.moveToEndOfNode, previous);
    } else {
      const parent = controller.value.document.getParent(closestParagraphBlock.key);
      const lastNode = parent?.nodes[parent?.nodes.length - 1];
      lastNode && controller.command(_everCangjie.Commands.moveToEndOfNode, lastNode);
    }

    const key = controller.value.anchorBlock.key;
    const parent = controller.value.document.getParent(key);
    const index = parent?.getPath(key);

    if (parent && index?.length) {
      controller.command(_everCangjie.Commands.moveNodeByKey, anchorBlock.key, parent.key, index[0]).command(_everCangjie.Commands.moveToStartOfNode, anchorBlock);
    }
  };

  if (isFoldNode) {
    return splitViewGroup();
  } // test isEnterAtLastChar at first since it can be an empty heading


  if (isCollapsed && start.isAtEndOfNode(closestParagraphBlock)) {
    // 使用 splitBlock 保持用户意图
    controller.command(_everCangjie.Commands.splitBlock); // 修正回车换行后的 type, data 和 marks

    const {
      key
    } = closestParagraphBlock;
    const nextSibling = controller.value.document.getNextSibling(key);

    if (nextSibling && _everCangjie.Block.isBlock(nextSibling)) {
      controller.command(_everCangjie.Commands.setNodeByKey, nextSibling.key, {
        type: 'paragraph',
        data: {}
      });
      const text = nextSibling.getFirstText();

      if (text) {
        const marks = text.getMarks();
        marks.forEach(mark => {
          controller.command(_everCangjie.Commands.removeMarkByKey, text.key, 0, text.text.length, mark);
        });
      }
    } // 需要清除选区临时样式（比如通过 # + space 生成的标题会一并设置临时样式）


    return controller.command(_everCangjie.Commands.select, controller.value.selection.set('marks', null));
  }

  if (isExpanded && end.isAtEndOfNode(closestParagraphBlock)) {
    // clear style like word/wps
    return controller.command(_everCangjie.Commands.splitBlock).command('clearStyle');
  }

  return next();
}
//# sourceMappingURL=onEnter.js.map