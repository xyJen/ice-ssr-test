"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = onSpace;

var _everCangjie = require("@ali/4ever-cangjie");

var _shortcutTypes = _interopRequireDefault(require("../utils/shortcutTypes"));

var _actions = require("../actions");

function onSpace(event, controller, next) {
  const {
    value
  } = controller;
  const {
    startBlock,
    selection,
    document
  } = value;
  if (!selection || !startBlock || selection.isExpanded) return next();
  const {
    start,
    anchor
  } = selection.convertToTextPoints(document);
  const texts = startBlock.text.slice(0, start.offset);
  const chars = texts.replace(/\s*/g, '');
  const type = _shortcutTypes.default[chars] || null;
  if (!type) return next(); // 在当前node之前有行内元素时不变heading（例如：@人 + # + 空格）

  const currentNode = startBlock.getNode(anchor.key);
  if (!currentNode) return next();
  let foundInlineNode = false;
  /**
   * 极端场景：段落的开头是 1000 个行内元素
   * 使用 getPreviousSibling 相比 for 循环性能差 3 倍左右
   */

  const index = startBlock.nodes.indexOf(currentNode);

  for (let i = index - 1; i >= 0; i--) {
    const node = startBlock.nodes[i];
    foundInlineNode = foundInlineNode || _everCangjie.Inline.isInline(node);
    if (foundInlineNode) break;
  }

  if (foundInlineNode) return next();
  event.preventDefault();
  controller.command(_everCangjie.Commands.moveFocusToStartOfNode, startBlock).command(_everCangjie.Commands.del);
  controller.run('onAction', (0, _actions.setHeading)(type));
  return controller.dispatch('createTriggerMarkdownAction', {
    mdType: type
  });
}
//# sourceMappingURL=onSpace.js.map