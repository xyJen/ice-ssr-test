"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = pasteFormatAtRange;

var _everCangjie = require("@ali/4ever-cangjie");

var _isParagraphBlock = _interopRequireDefault(require("../utils/isParagraphBlock"));

var _isSelectWholeBlocks = _interopRequireDefault(require("../utils/isSelectWholeBlocks"));

var _clearFormatClipboard = _interopRequireDefault(require("./clearFormatClipboard"));

const supportParagraphData = ['list', 'jc', 'ind', 'shd', 'spacing'];

function isInvalidBlocksInRange(value) {
  const {
    document,
    selection
  } = value;
  const fragment = document.getFragmentAtRange(selection);
  return fragment.nodes // 目前选区内出现分割线及表格，则不应用段落样式
  .some(({
    type
  }) => type === 'hr' || type === 'table');
}

function clearMarksAtRange(controller, range) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const marks = document.getMarksAtRange(range).filter(({
    type
  }) => type !== 'vertAlign');

  if (marks.length) {
    marks.forEach(mark => {
      if (range.isCollapsed) {
        controller.command(_everCangjie.Commands.removeMark, mark);
      } else {
        controller.command(_everCangjie.Commands.removeMarkAtRange, range, mark);
      }
    });
  }

  return controller;
}

function pasteFormatAtRange(controller, range) {
  const {
    value
  } = controller;
  const {
    formatClipboard
  } = value.data;

  if (!formatClipboard) {
    return controller;
  }

  clearMarksAtRange(controller, range);
  const marks = formatClipboard.text;
  marks.forEach(mark => _everCangjie.Commands.addMarkAtRange(controller, range, mark));
  const format = formatClipboard.paragraph;
  const {
    selection,
    document
  } = value;

  if (format && (selection.isCollapsed || (0, _isSelectWholeBlocks.default)(value) && !isInvalidBlocksInRange(value))) {
    const paragraphs = document.getLeafBlocksAtRange(range).filter(_isParagraphBlock.default);
    paragraphs.forEach(paragraph => {
      const data = { ...paragraph.data
      };
      supportParagraphData.forEach(key => {
        // 因为是直接覆盖data，这里过滤一次，不保留不必要字段
        if (!format[key]) {
          delete data[key];
        } else {
          data[key] = format[key];
        }
      });
      controller.command(_everCangjie.Commands.setNodeByKey, paragraph.key, {
        type: format.type,
        data
      });
    });
  } // 双击或快捷键不清除样式以便复用


  if (formatClipboard.type === 'multiple' || formatClipboard.trigger === 'keyboard') {
    return controller;
  }

  return (0, _clearFormatClipboard.default)(controller);
}
//# sourceMappingURL=pasteFormatAtRange.js.map