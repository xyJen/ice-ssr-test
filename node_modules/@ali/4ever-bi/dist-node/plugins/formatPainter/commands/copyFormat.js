"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = copyFormat;

var _everCangjie = require("@ali/4ever-cangjie");

var _everMo = require("@ali/4ever-mo");

var _everBamboo = require("@ali/4ever-bamboo");

var _everUtils = require("@ali/4ever-utils");

var _everPluginBasic = require("@ali/4ever-plugin-basic");

var _isParagraphBlock = _interopRequireDefault(require("../utils/isParagraphBlock"));

var _isSelectWholeBlocks = _interopRequireDefault(require("../utils/isSelectWholeBlocks"));

function getFirstCharRangeAfterStart(range, document) {
  const {
    start
  } = range.convertToTextPoints(document);
  return _everCangjie.Selection.create({
    anchor: start,
    focus: start.moveForward()
  });
}

function isCollapsedAtEndOfBlock(range, block) {
  if (range.isExpanded) {
    return false;
  }

  return range.anchor.isAtEndOfNode(block);
}

let copiableMarks;

function isCopiableMark(type) {
  if (!copiableMarks) {
    copiableMarks = {};
    Object.keys(_everMo.Marks).forEach(key => {
      copiableMarks[_everMo.Marks[key].TYPE] = true;
    });
  }

  return copiableMarks[type];
}

function copyFormat(controller, trigger, type = 'single', defaultSz) {
  const {
    value
  } = controller;
  const ranges = (0, _everUtils.getRangesFromEditor)(controller);
  const range = ranges[0];

  if (!range) {
    return controller;
  }

  const {
    document
  } = value;
  const {
    start
  } = range.convertToTextPoints(document);
  const currentBlock = document.getClosestBlock(start.key);
  if (!currentBlock) return controller;
  let textFormat = []; // TODO: 当前逻辑没有考虑段尾的情况，粘贴样式会导致已有的mark被情况，待修复

  if (range.isExpanded || !isCollapsedAtEndOfBlock(range, currentBlock)) {
    // only copy style of first char
    const firstCharRange = getFirstCharRangeAfterStart(range, document);
    textFormat = document.getMarksAtRange(firstCharRange).filter(({
      type: markType
    }) => isCopiableMark(markType)); // 为默认普通文本补充样式

    if ((0, _isParagraphBlock.default)(currentBlock)) {
      const defaultMarks = _everBamboo.CommonFormatUtil.getDefaultMarks(currentBlock, defaultSz);

      if (!textFormat.find(m => m.type === _everMo.Marks.Bold.TYPE)) {
        // 补充 value 为 false 的 bold mark：让包括标题在内的所有文本都能取消加粗
        const defaultBold = defaultMarks.find(m => m.type === _everMo.Marks.Bold.TYPE) || _everCangjie.Mark.create({
          type: _everMo.Marks.Bold.TYPE,
          data: {
            value: false
          }
        });

        textFormat.push(defaultBold);
      }

      if (!textFormat.find(m => m.type === _everMo.Marks.Sz.TYPE)) {
        // 补充默认字号
        const sz = defaultMarks.find(m => m.type === _everMo.Marks.Sz.TYPE);
        sz && textFormat.push(sz);
      }
    }
  }

  let paragraphFormat;

  if (range.isCollapsed || (0, _isSelectWholeBlocks.default)(value)) {
    // only copy style of text paragraph
    if ((0, _isParagraphBlock.default)(currentBlock)) {
      paragraphFormat = {
        type: currentBlock.type,
        list: currentBlock.data.list,
        jc: currentBlock.data.jc,
        spacing: currentBlock.data.spacing,
        ind: currentBlock.data.ind,
        shd: currentBlock.data.shd
      };
    }
  } // found no formats


  if (paragraphFormat && !textFormat.length) return controller;
  controller.run('onAction', _everPluginBasic.biActions.createMergeDataAction({
    formatClipboard: {
      trigger,
      type,
      text: textFormat,
      paragraph: paragraphFormat
    }
  }));
  return controller;
}
//# sourceMappingURL=copyFormat.js.map