"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _react = _interopRequireWildcard(require("react"));

var _everCangjie = require("@ali/4ever-cangjie");

var _everBamboo = require("@ali/4ever-bamboo");

var _everFactory = require("@ali/4ever-factory");

const _createElement = /*#__PURE__*/_react.default.createElement;
const {
  VideoPlayer,
  EmbedCard
} = _everBamboo.EmbedPlugin;

class Video extends _react.PureComponent {
  constructor(props) {
    super(props);
    this.ref = /*#__PURE__*/_react.default.createRef();
    this.videoRef = /*#__PURE__*/_react.default.createRef();

    this.getNodeData = () => {
      const {
        node
      } = this.props;
      const {
        data
      } = node;
      return data;
    };

    this.onSwitchViewType = viewType => {
      const {
        controller,
        node
      } = this.props;
      const {
        data
      } = node;
      const {
        viewType: prevViewType
      } = this.getNodeData();

      if (prevViewType === viewType) {
        return;
      }

      controller.run('onAction', (0, _everFactory.updateFile)(node, { ...data,
        viewType
      }));
    };

    this.onDownloadFile = () => {
      const {
        src,
        name,
        type,
        size
      } = this.getNodeData();
      const {
        onDownload
      } = this.props;

      if (onDownload) {
        onDownload(src, {
          name,
          type,
          size
        });
      }
    };

    this.onMediaLoadError = () => {
      const {
        src
      } = this.getNodeData();
      const {
        onMediaLoadError
      } = this.props;

      if (onMediaLoadError) {
        onMediaLoadError(src);
      }
    };

    const {
      allowDownload
    } = props;
    this.state = {
      allowDownload: typeof allowDownload === 'boolean' ? allowDownload : false
    };
  }

  componentDidMount() {
    const {
      allowDownload
    } = this.props;
    const {
      src
    } = this.getNodeData();

    if (typeof allowDownload === 'function') {
      allowDownload(src).then(res => {
        this.setState({
          allowDownload: res
        });
      });
    }
  }

  renderCard() {
    const {
      allowDownload
    } = this.state;
    const {
      name,
      size
    } = this.getNodeData();
    const {
      isSelected,
      node,
      locale
    } = this.props;
    return /*#__PURE__*/_createElement(EmbedCard, {
      name: name,
      allowDownload: allowDownload,
      isSelected: isSelected,
      node: node,
      locale: locale,
      onDownloadFile: this.onDownloadFile,
      size: size
    });
  }

  renderPreview() {
    const {
      isSelected,
      node,
      setTempPosterUrl,
      onMediaLoadSuccess,
      transformVideoURL,
      renderVideoMask,
      allowDownload,
      onDownload,
      locale,
      allowFullscreen
    } = this.props;
    return /*#__PURE__*/_createElement(VideoPlayer, {
      transformVideoURL: transformVideoURL,
      onMediaLoadSuccess: onMediaLoadSuccess,
      onMediaLoadError: this.onMediaLoadError,
      setTempPosterUrl: setTempPosterUrl,
      node: node,
      isSelected: isSelected,
      renderVideoMask: renderVideoMask,
      allowDownload: onDownload && allowDownload,
      onDownload: this.onDownloadFile,
      locale: locale,
      allowFullscreen: allowFullscreen
    });
  }

  renderInlineToolbar() {
    const {
      controller,
      node,
      locale = {}
    } = this.props;
    return /*#__PURE__*/_createElement(_everFactory.EmbedInlineToolbar, {
      controller: controller,
      node: node,
      locale: locale,
      onSwitchViewType: this.onSwitchViewType,
      isMoreButtonShown: true,
      triggerNode: this.ref.current
    });
  }

  render() {
    const {
      viewType
    } = this.getNodeData();
    const {
      attributes,
      isSelected,
      controller
    } = this.props;
    const {
      isCollapsed
    } = controller.value.selection;
    return /*#__PURE__*/_createElement(_react.default.Fragment, null, isSelected && isCollapsed ? this.renderInlineToolbar() : null, /*#__PURE__*/_createElement("div", (0, _extends2.default)({}, attributes, {
      ref: this.ref
    }), viewType === 'preview' ? this.renderPreview() : this.renderCard()));
  }

}

const Container = props => {
  const scrollableContainer = (0, _everBamboo.useScrollableContainer)();
  const scale = (0, _everCangjie.useZoom)();
  return /*#__PURE__*/_createElement(Video, (0, _extends2.default)({}, props, {
    scrollableContainer: scrollableContainer,
    scale: scale
  }));
};

var _default = Container;
exports.default = _default;
//# sourceMappingURL=video.js.map