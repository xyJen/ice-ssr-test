import React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import { debounce, noop, throttle } from 'lodash-es';
import ResizeObserver from 'resize-observer-polyfill';
import { ToolbarLayout } from '@ali/we-design-next';
import { useZoomContainer, useZoom, domUtils, Block, Inline } from '@ali/4ever-cangjie';
import { useScrollableContainer, useScrollableContent, PluginRoles } from '@ali/4ever-bamboo';
import { HoverToolbarContexts, ActiveInteractionHooks, BasicPortal as Portal } from '@ali/4ever-component';
import { usePlugins } from "../../../pluginsContext";
import { useHoverCapture } from "../context/hoverCaptureContext";
import { HOVER_TOOLBAR_HEIGHT, SAFE_CONTAINER_MARGIN_TOP, SAFE_NODE_MARGIN_TOP, SAFE_CONTAINER_MARGIN_RIGHT_OR_LEFT, SCROLL_TIMEOUT } from "../constants";
import { getHoverToolbarLayout } from "./getHoverToolbarLayout";
import { HoverToolbarWrapper, HOVER_TOOLBAR_NOT_READY, HOVER_TOOLBAR_SLIDE_IN } from "./styled";
var useActiveInteraction = ActiveInteractionHooks.useActiveInteraction;
export var HoverToolbar = function HoverToolbar(props) {
  var controller = props.controller,
      configs = props.configs;
  var plugins = usePlugins();
  var zoomContainer = useZoomContainer();
  var scrollableContainer = useScrollableContainer();
  var hoverCapture = useHoverCapture();
  var zoom = useZoom();
  var currentNode = React.useRef(null);

  var _React$useState = React.useState(),
      singleToolbar = _React$useState[0],
      setSingleToolbar = _React$useState[1];

  var wrapperRef = React.useRef(null);
  var toolbarWidth = React.useRef(0);

  var _React$useState2 = React.useState(false),
      inOuterContainer = _React$useState2[0],
      setInOuterContainer = _React$useState2[1];

  var inOuterContainerRef = React.useRef(false);
  var innerContainer = zoomContainer || window.document.body;
  var outerContainer = scrollableContainer instanceof Element ? scrollableContainer : window.document.body;
  var container = inOuterContainer ? outerContainer : innerContainer;
  var visiblePopoverSetRef = React.useRef(new Set());
  var needSlidInRef = React.useRef(false);

  var _React$useState3 = React.useState(false),
      isVisible = _React$useState3[0],
      setVisible = _React$useState3[1];

  var content = useScrollableContent();

  var _useActiveInteraction = useActiveInteraction(),
      activeType = _useActiveInteraction[0],
      setActiveType = _useActiveInteraction[1];

  var activeRef = React.useRef('');
  activeRef.current = activeType;

  var _React$useState4 = React.useState(''),
      currentKey = _React$useState4[0],
      setCurrentKey = _React$useState4[1];

  var showHoverToolbar = singleToolbar && singleToolbar.length > 0;
  inOuterContainerRef.current = inOuterContainer;
  var locale = configs.locale || {};
  React.useEffect(function () {
    // inOuterContainer 更新时浮动工具栏会重新渲染
    hoverCapture == null ? void 0 : hoverCapture.enableTrigger();

    if (wrapperRef.current) {
      wrapperRef.current.style.opacity = '1';
    }
  }, [inOuterContainer, hoverCapture]);
  var reset = React.useCallback(function () {
    visiblePopoverSetRef.current.clear();
    hoverCapture == null ? void 0 : hoverCapture.enableTrigger();
    setSingleToolbar(undefined);
    toolbarWidth.current = 0;
  }, [hoverCapture]);
  React.useEffect(function () {
    if (activeType && activeType !== 'hoverToolbarPopover') {
      hoverCapture == null ? void 0 : hoverCapture.forceClose();
      reset();
    }
  }, [activeType, hoverCapture]);
  var updatePos = React.useCallback(function () {
    var node = currentNode.current;

    if (node && wrapperRef.current) {
      if (toolbarWidth.current === 0) {
        wrapperRef.current.style.opacity = '0';
        return;
      }

      var nodeDOM = domUtils.findDOMNodeSafely(node.key, innerContainer);

      if (nodeDOM) {
        var newStyle = {
          position: 'absolute'
        };
        var nodeRect = nodeDOM.getBoundingClientRect();
        var contentRect = innerContainer.getBoundingClientRect();
        var containerRect = !scrollableContainer || scrollableContainer instanceof Window ? {
          x: 0,
          y: 0,
          width: window.innerWidth,
          height: window.innerHeight
        } : scrollableContainer.getBoundingClientRect();
        var nodeX = nodeRect.x,
            nodeY = nodeRect.y,
            nodeW = nodeRect.width,
            nodeH = nodeRect.height;
        var containerY = containerRect.y,
            containerH = containerRect.height;
        var contentX = contentRect.x,
            contentY = contentRect.y,
            contentWidth = contentRect.width;
        var contentW = contentWidth || innerContainer.offsetWidth * zoom; // 滚动的时候 contentWidth 可能为 0，会产生抖动

        if (contentWidth === 0) {
          return;
        } // 元素滚出下边缘


        if (nodeY > containerY + containerH) {
          newStyle.opacity = '0';
          setVisible(false); // 元素上边缘与滚动容器之间的距离足够固定安全距离 + 自适应安全距离 + 工具栏高度, 相对于纸张
        } else if (nodeY >= containerY + (SAFE_CONTAINER_MARGIN_TOP + SAFE_NODE_MARGIN_TOP + HOVER_TOOLBAR_HEIGHT) * zoom) {
          var top = (nodeY - contentY) / zoom - SAFE_NODE_MARGIN_TOP - HOVER_TOOLBAR_HEIGHT;
          newStyle.top = top;

          if (inOuterContainerRef.current) {
            setInOuterContainer(false);
            newStyle.opacity = '0';
          } else {
            newStyle.opacity = '1';
            wrapperRef.current.classList.remove(HOVER_TOOLBAR_NOT_READY);
          }

          setVisible(true); // 工具栏上边缘与容器上边缘距离固定, 相对于window
        } else if (nodeY + nodeH >= containerY + (SAFE_CONTAINER_MARGIN_TOP + HOVER_TOOLBAR_HEIGHT) * zoom) {
          var _top = containerY + SAFE_CONTAINER_MARGIN_TOP * zoom + (zoom - 1) * HOVER_TOOLBAR_HEIGHT / 2;

          newStyle.top = _top;
          newStyle.position = 'fixed';

          if (!inOuterContainerRef.current) {
            setInOuterContainer(true);
            newStyle.opacity = '0';
          } else {
            newStyle.opacity = '1';
            wrapperRef.current.classList.remove(HOVER_TOOLBAR_NOT_READY);
          }

          setVisible(true); // 元素下边缘与滚动容器上边缘之间的距离不能容纳 工具栏高度 + 最小安全距离
        } else {
          setVisible(false);
          newStyle.opacity = '0';
        } // 居中后左侧放不下


        if (nodeX + nodeW / 2 - toolbarWidth.current * zoom / 2 - SAFE_CONTAINER_MARGIN_RIGHT_OR_LEFT * zoom < contentX) {
          if (inOuterContainerRef.current) {
            newStyle.left = SAFE_CONTAINER_MARGIN_RIGHT_OR_LEFT * zoom + contentX;
          } else {
            newStyle.left = SAFE_CONTAINER_MARGIN_RIGHT_OR_LEFT;
          }
        } else if (nodeX + nodeW / 2 - toolbarWidth.current * zoom / 2 - SAFE_CONTAINER_MARGIN_RIGHT_OR_LEFT * zoom >= contentX && nodeX + nodeW / 2 + toolbarWidth.current * zoom / 2 + SAFE_CONTAINER_MARGIN_RIGHT_OR_LEFT * zoom <= contentX + contentW) {
          if (inOuterContainerRef.current) {
            newStyle.left = nodeX + nodeW / 2 - toolbarWidth.current / 2;
          } else {
            newStyle.left = (nodeX + nodeW / 2 - toolbarWidth.current / 2 * zoom - contentX) / zoom;
          }
        } else if (inOuterContainerRef.current) {
          newStyle.left = contentX + contentW - SAFE_CONTAINER_MARGIN_RIGHT_OR_LEFT * zoom;
        } else {
          newStyle.left = (contentX + contentW) / zoom - SAFE_CONTAINER_MARGIN_RIGHT_OR_LEFT;
        }

        if (!wrapperRef.current) {
          hoverCapture == null ? void 0 : hoverCapture.forceClose();
          return;
        }

        wrapperRef.current.style.top = (newStyle.top || 0) + "px";
        wrapperRef.current.style.left = (newStyle.left || 0) + "px";
        wrapperRef.current.style.opacity = (newStyle.opacity || 0).toString();
        wrapperRef.current.style.position = newStyle.position || 'absolute';

        if (needSlidInRef.current && !wrapperRef.current.classList.contains(HOVER_TOOLBAR_NOT_READY)) {
          wrapperRef.current.classList.add(HOVER_TOOLBAR_SLIDE_IN);
        }
      } else {
        hoverCapture == null ? void 0 : hoverCapture.forceClose();
      }
    }
  }, [zoom, scrollableContainer, innerContainer, hoverCapture]);
  React.useEffect(function () {
    if (!singleToolbar) return noop;
    var handleResize = debounce(function () {
      var _wrapperRef$current;

      var newWidth = ((_wrapperRef$current = wrapperRef.current) == null ? void 0 : _wrapperRef$current.offsetWidth) || 0;

      if (toolbarWidth.current !== newWidth) {
        toolbarWidth.current = newWidth;
        updatePos();
      }
    }, 200);
    var observer = new ResizeObserver(handleResize);
    wrapperRef.current && observer.observe(wrapperRef.current);
    return function () {
      observer.disconnect();
      handleResize.cancel();
      toolbarWidth.current = 0;
    };
  }, [singleToolbar, updatePos]);
  React.useEffect(function () {
    if (!singleToolbar) return noop;
    var handleChange = throttle(function () {
      updatePos();
    }, 200);
    var mutationObserver = new MutationObserver(handleChange);
    content && mutationObserver.observe(content, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ['style']
    });
    return function () {
      mutationObserver && mutationObserver.disconnect();
      handleChange.cancel();
    };
  }, [singleToolbar, updatePos, content]);
  var getContainer = React.useCallback(function () {
    // Hack: 缩放的时候 popover 内部使用的 dom-align 不能正确定位到被 scale 的容器，所以需要挂载到 dom 上，缺点时不会跟随滚动
    if (zoom !== 1) {
      return window.document.body;
    }

    var innerContainer = zoomContainer || window.document.body;
    var outerContainer = scrollableContainer instanceof Element ? scrollableContainer : window.document.body;
    var container = inOuterContainerRef.current ? outerContainer : innerContainer;
    return container;
  }, [zoomContainer, scrollableContainer, zoom]);
  React.useEffect(function () {
    var handleTrigger = function handleTrigger(msg) {
      // 有其他激活中的菜单就不触发
      if (activeRef.current && activeRef.current !== 'hoverToolbarPopover') {
        return;
      }

      var _msg$node = msg.node,
          node = _msg$node === void 0 ? null : _msg$node;

      if (currentNode.current !== node) {
        if (!currentNode.current) {
          needSlidInRef.current = true;
        }

        var currentLayout = node ? getHoverToolbarLayout({
          layoutConfigs: configs.layouts || {},
          plugins: plugins,
          controller: controller,
          node: node,
          hoverCapture: hoverCapture,
          locale: locale,
          visiblePopoverSet: visiblePopoverSetRef.current,
          activeRef: activeRef,
          setActiveInteraction: setActiveType,
          reset: reset
        }) : undefined;
        setSingleToolbar(currentLayout);
        setCurrentKey((node == null ? void 0 : node.key) || '');
        currentNode.current = node;
        toolbarWidth.current = 0;

        if (!node) {
          visiblePopoverSetRef.current.clear();
          hoverCapture == null ? void 0 : hoverCapture.enableTrigger();
        }
      }
    };

    hoverCapture == null ? void 0 : hoverCapture.on(handleTrigger);
    return function () {
      hoverCapture == null ? void 0 : hoverCapture.off(handleTrigger);
    };
  }, [controller, configs, plugins, hoverCapture, updatePos, reset, setActiveType]);
  React.useEffect(function () {
    var handleScroll = throttle(function () {
      updatePos();
    }, SCROLL_TIMEOUT);
    scrollableContainer == null ? void 0 : scrollableContainer.addEventListener('scroll', handleScroll);
    return function () {
      scrollableContainer == null ? void 0 : scrollableContainer.removeEventListener('scroll', handleScroll);
    };
  }, [scrollableContainer, updatePos]);
  var handleMouseEnter = React.useCallback(function () {
    var node = hoverCapture == null ? void 0 : hoverCapture.getCurrentNode();
    if (!Block.isBlock(node) && !Inline.isInline(node)) return;
    controller.dispatch('updateHighlight', {
      node: node,
      type: 'hover',
      reason: 'hoverToolbar'
    });
  }, [hoverCapture]);
  var handleMouseLeave = React.useCallback(function () {
    var node = hoverCapture == null ? void 0 : hoverCapture.getCurrentNode();
    if (!Block.isBlock(node) && !Inline.isInline(node)) return;
    controller.dispatch('removeHighlight', {
      node: node,
      type: 'hover',
      reason: 'hoverToolbar'
    });
  }, [hoverCapture]);
  var handleAnimationEnd = React.useCallback(function (event) {
    var target = event.target;
    var _ref = target,
        classList = _ref.classList;
    classList.remove(HOVER_TOOLBAR_SLIDE_IN);
    needSlidInRef.current = false;
  }, []);
  return showHoverToolbar ? /*#__PURE__*/_createElement(Portal, {
    container: container
  }, /*#__PURE__*/_createElement(HoverToolbarWrapper, {
    ref: wrapperRef,
    className: "hover-toolbar-wrapper " + HOVER_TOOLBAR_NOT_READY,
    "data-hover-toolbar": true,
    style: {
      '--hover-toolbar-transform': inOuterContainer ? "scale(" + zoom + ")" : 'scale(1)'
    },
    "data-testid": "hover-toolbar",
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    onAnimationEnd: handleAnimationEnd,
    "data-role": PluginRoles.hoverToolbar
  }, /*#__PURE__*/_createElement(HoverToolbarContexts.GetContainerContext.Provider, {
    value: getContainer
  }, /*#__PURE__*/_createElement(HoverToolbarContexts.HoverToolbarVisibleContext.Provider, {
    value: isVisible
  }, /*#__PURE__*/_createElement(HoverToolbarContexts.VisiblePopoverSetContext.Provider, {
    value: visiblePopoverSetRef.current
  }, /*#__PURE__*/_createElement(ToolbarLayout, {
    mode: "singleLine",
    singleLineToolbar: singleToolbar,
    layout: "fit-content",
    align: "left",
    style: {
      padding: '2px 0'
    },
    key: currentKey
  })))))) : null;
};
//# sourceMappingURL=HoverToolbar.js.map