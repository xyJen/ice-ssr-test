import _extends from "@babel/runtime/helpers/extends";
import * as React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import { throttle } from 'lodash-es';
import { Block, useZoom, environment } from '@ali/4ever-cangjie';
import { useScrollableContent, StickerPlugin, CalloutPlugin } from '@ali/4ever-bamboo';
import { ColorBlocks } from '@ali/4ever-mo';
import { useHover } from '@ali/4ever-component';
import { Popover } from '@ali/we-design-next';
import { Tooltip } from '@ali/we-design';
import { getRectOfNodeFirstText } from '@ali/4ever-utils';
import { STICKER_PANEL_COLUMMS, StickerPanel } from '@ali/4ever-plugin-sticker';
import { setCalloutStickerCode, convertKeysToContainer, deleteCallout } from "../actions";
import CalloutInnerToolbar from "./InnerToolbar";
import { isCallout } from "../utils";
var StickerItem = StickerPlugin.StickerItem;
var CalloutBoxWrapper = CalloutPlugin.CalloutBoxWrapper,
    CalloutBox = CalloutPlugin.CalloutBox,
    ContentBox = CalloutPlugin.ContentBox,
    StickerBox = CalloutPlugin.StickerBox,
    StickerInnerBox = CalloutPlugin.StickerInnerBox,
    DEFAULTS = CalloutPlugin.DEFAULTS,
    STICKER_SIZE = CalloutPlugin.STICKER_SIZE,
    PADDING_TOP = CalloutPlugin.PADDING_TOP;

/**
 * 高亮区块
 * @param props
 * @returns
 */
var Callout = function Callout(props) {
  var controller = props.controller,
      node = props.node,
      attributes = props.attributes,
      children = props.children,
      sticker = props.sticker,
      locale = props.locale;
  var contentBoxRef = React.useRef();
  var stickerBoxRef = React.useRef();
  var disableInlineToolbar = controller.query('hasHoverToolbar', 'callout');

  var _React$useMemo = React.useMemo(function () {
    if (isCallout(node)) {
      var calloutPr = node.data.calloutPr;
      return {
        bgcolor: calloutPr == null ? void 0 : calloutPr.backgroundColor,
        sticker: calloutPr == null ? void 0 : calloutPr.stickerCode,
        showSticker: true
      };
    } else {
      var metadata = node.data.metadata;
      return _extends({}, metadata, {
        showSticker: Boolean(metadata.showstk)
      });
    }
  }, [node]),
      _React$useMemo$bgcolo = _React$useMemo.bgcolor,
      bgcolor = _React$useMemo$bgcolo === void 0 ? DEFAULTS.bgcolor : _React$useMemo$bgcolo,
      _React$useMemo$sticke = _React$useMemo.sticker,
      stickerCode = _React$useMemo$sticke === void 0 ? DEFAULTS.stcode : _React$useMemo$sticke,
      border = _React$useMemo.border,
      color = _React$useMemo.color,
      showSticker = _React$useMemo.showSticker; // 边框色默认为背景色, 使边框和文字对齐


  var borderColor = border || bgcolor;

  if (!border && bgcolor === '#FFFFFF') {
    borderColor = DEFAULTS.whiteBorder;
  }

  var ref = React.useRef(null);

  var _React$useState = React.useState(0),
      stickerTop = _React$useState[0],
      setStickerTop = _React$useState[1];

  var zoom = useZoom();

  var _React$useState2 = React.useState(false),
      showStickerPanel = _React$useState2[0],
      setShowStickerTop = _React$useState2[1];

  var _React$useState3 = React.useState(false),
      showInnerToolbar = _React$useState3[0],
      setShowInnerToolbar = _React$useState3[1];

  React.useEffect(function () {
    if (isCallout(node)) {
      var keys = node.nodes.map(function (n) {
        return n.key;
      });
      controller.run('onAction', convertKeysToContainer({
        keys: keys
      }));
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, []);
  React.useEffect(function () {
    if (!ColorBlocks.isColorBlocks(node)) {
      return;
    }
    /**
     * 背景：
     * 排版下，突然出现 node.nodes 是空数组的临时状态，可能和 task 调度有关系
     * 目前排查下来，非常难定位，暂时忽略这个 case
     *
     * hotfix：排版下，暂时不执行这里的逻辑
     *
     */


    if (node.key.indexOf('-') >= 0) {
      return;
    }

    var _node$nodes = node.nodes,
        nodes = _node$nodes === void 0 ? [] : _node$nodes;

    if (!nodes.length || nodes.every(function (n) {
      return !Block.isBlock(n);
    })) {
      controller.run('onAction', deleteCallout({
        node: node
      }));
    }
  }, [node, controller]);
  React.useEffect(function () {
    if (stickerBoxRef.current && node.nodes[0]) {
      var _stickerBoxRef$curren;

      var rect = getRectOfNodeFirstText(node.nodes[0]);
      var stickerRect = (_stickerBoxRef$curren = stickerBoxRef.current) == null ? void 0 : _stickerBoxRef$curren.getBoundingClientRect();

      if (rect && rect.height && stickerRect) {
        var newTop = rect.top / zoom - stickerRect.top / zoom - PADDING_TOP + (rect.height / zoom - STICKER_SIZE) / 2 - 1;
        setStickerTop(Math.round(newTop));
      }
    }
  }, [node, stickerBoxRef, zoom]);
  var triggerSetSticker = React.useCallback(function (_ref) {
    var code = _ref.code;
    setShowStickerTop(false);
    controller.run('onAction', setCalloutStickerCode({
      node: node,
      stickerCode: code
    }));
  }, [controller, node, setShowStickerTop]);
  var updateInnerToolbar = React.useCallback(throttle(function (event) {
    var target = event.target;

    if (!(target instanceof HTMLElement)) {
      return;
    }

    var forceHide = target.closest('[data-istasklist]');
    var panel = target.closest('[data-color-select-panel]');
    var showIt = !panel || panel === ref.current;
    var isShow = !forceHide && showIt;

    if (showInnerToolbar !== isShow) {
      setShowInnerToolbar(isShow);
    }
  }, 100, {
    trailing: true
  }), [showInnerToolbar]);
  var handleMouseMove = React.useCallback(function (event) {
    if (environment.IS_MOBILE) {
      return;
    }

    event.persist();
    updateInnerToolbar(event);
  }, [updateInnerToolbar]);
  var handleHideInnerToolbar = React.useCallback(function () {
    updateInnerToolbar.cancel();
    setShowInnerToolbar(false);
  }, [updateInnerToolbar]);
  var enableBorderHighlight = React.useMemo(function () {
    return controller.query('enableBorderHighlight');
  }, []);

  var _useHover = useHover(enableBorderHighlight, {
    onMouseLeave: handleHideInnerToolbar
  }),
      isHover = _useHover[0],
      hoverHandlers = _useHover[1];

  var scrollContent = useScrollableContent() || window.document.body; // 如果不这样做，还有一种做法参考现在的 setStickerPanelVisible,
  // 通过 action 触发显示隐藏，在 controller.data 里面存状态
  // 个人不认可这种做法

  React.useEffect(function () {
    window.document.addEventListener('keydown', handleHideInnerToolbar);
    return function () {
      window.document.removeEventListener('keydown', handleHideInnerToolbar);
    };
  }, [controller, handleHideInnerToolbar]);
  var showRightToolbar = ColorBlocks.isColorBlocks(node);
  var toggleStickerPanelVisible = React.useCallback(function () {
    setShowStickerTop(!showStickerPanel);
  }, [showStickerPanel]);
  return /*#__PURE__*/_createElement(CalloutBoxWrapper, attributes, /*#__PURE__*/_createElement(CalloutBox, _extends({
    ref: ref,
    className: "callout-box",
    "data-callout-group": true,
    "data-color-select-panel": true,
    backgroundColor: bgcolor,
    borderColor: borderColor,
    selected: false
  }, hoverHandlers, {
    onMouseMove: handleMouseMove,
    onMouseDown: function onMouseDown() {},
    onClick: function onClick() {},
    "data-hover-box": "borderBox",
    isHover: isHover
  }), !disableInlineToolbar && showRightToolbar && /*#__PURE__*/_createElement(CalloutInnerToolbar, {
    color: color,
    bgcolor: bgcolor,
    border: border,
    locale: locale,
    showSticker: showSticker,
    controller: controller,
    node: node,
    showInnerToolbar: showInnerToolbar
  }), Boolean(showSticker) &&
  /*#__PURE__*/
  // we-design-next tooltip 有 bug, 点击 popover 内的表情后不消失，这里先用 we-design 的
  _createElement(Tooltip, {
    title: locale == null ? void 0 : locale.switchEmoji,
    placement: "bottom",
    zIndex: 900
  }, /*#__PURE__*/_createElement(StickerBox, {
    className: "callout-sticker-box",
    ref: stickerBoxRef
  }, /*#__PURE__*/_createElement(Popover, {
    visible: showStickerPanel,
    trigger: "click",
    getContainer: function getContainer() {
      return scrollContent;
    } // StickerPanel 本身有 memo
    ,
    content: /*#__PURE__*/_createElement(StickerPanel, {
      sticker: sticker,
      columns: STICKER_PANEL_COLUMMS,
      onClick: triggerSetSticker
    }),
    onVisibleChange: function onVisibleChange(v) {
      setShowStickerTop(v);
    },
    placement: "bottom",
    style: {
      zIndex: 1000
    }
  }, /*#__PURE__*/_createElement(StickerInnerBox, {
    style: {
      top: stickerTop
    }
  }, /*#__PURE__*/_createElement(StickerItem, {
    sz: STICKER_SIZE,
    code: stickerCode,
    sticker: sticker,
    onClick: toggleStickerPanelVisible
  }))))), /*#__PURE__*/_createElement(ContentBox, {
    "data-container-block": true,
    showSticker: showSticker,
    ref: contentBoxRef
  }, children)));
};

Callout.displayName = 'Callout';
export default Callout;
//# sourceMappingURL=callout.js.map