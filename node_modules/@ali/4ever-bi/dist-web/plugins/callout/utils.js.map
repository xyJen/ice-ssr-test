{"version":3,"sources":["../../../../src/plugins/callout/utils.ts"],"names":["equal","Paragraph","Heading","Document","Block","Text","isCalloutParagraph","node","isCallout","isBlock","type","createCallout","props","create","condition","firstNode","nextNode","isParagraph","isHeading","data","calloutPr","findFirstBlockOfCalloutPr","document","startNode","finalNode","prevSibling","getPreviousSibling","key","generateClipCallout","endBlock","shouldCutOrCopyBlocks","currentBlock","unshift","fragment","nodes","isEmptyNode","list","length","isEmptyText"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,iBAAlB;AACA,SAASC,SAAT,EAAmCC,OAAnC,QAAkD,eAAlD;AACA,SAASC,QAAT,EAAmBC,KAAnB,EAA+CC,IAA/C,QAAuE,oBAAvE;AAIA,OAAO,SAASC,kBAAT,CAA4BC,IAA5B,EAAuC;AAC5C,SAAOL,OAAO,CAACM,SAAR,CAAkBD,IAAlB,CAAP;AACD;AAED,OAAO,SAASC,SAAT,CAAmBD,IAAnB,EAA+C;AACpD,SAAOH,KAAK,CAACK,OAAN,CAAcF,IAAd,KAAuBA,IAAI,CAACG,IAAL,KAAc,eAA5C;AACD;AAQD,OAAO,SAASC,aAAT,CAAuBC,KAAvB,EAAqD;AAC1D,SAAOR,KAAK,CAACS,MAAN,cACFD,KADE;AAELF,IAAAA,IAAI,EAAE;AAFD,KAAP;AAID;AAED,OAAO,IAAMI,SAAS,GAAG,SAAZA,SAAY,CAACC,SAAD,EAAmBC,QAAnB;AAAA,SAA6C,EAAEA,QAAQ,KAC1Ef,SAAS,CAACgB,WAAV,CAAsBD,QAAtB,KAAmCd,OAAO,CAACgB,SAAR,CAAkBF,QAAlB,CADuC,CAAR,IAEnE,CAAC,CAACA,QAAQ,CAACG,IAAT,CAAcC,SAFmD,IAGnEpB,KAAK,CAACgB,QAAQ,CAACG,IAAT,CAAcC,SAAf,EAA0BL,SAAS,CAACI,IAAV,CAAeC,SAAzC,CAH4D,CAA7C;AAAA,CAAlB;AAMP,OAAO,SAASC,yBAAT,CAAmCC,QAAnC,EAAuDC,SAAvD,EAAyE;AAC9E,MAAIC,SAAS,GAAGD,SAAhB;;AACA,SAAO,IAAP,EAAa;AACX,QAAME,WAAW,GAAGH,QAAQ,CAACI,kBAAT,CAA4BF,SAAS,CAACG,GAAtC,CAApB;;AACA,QAAIb,SAAS,CAACS,SAAD,EAAYE,WAAZ,CAAb,EAAuC;AACrC;AACD;;AACDD,IAAAA,SAAS,GAAGC,WAAZ;AACD;;AACD,SAAOD,SAAP;AACD,C,CAED;AACA;;AACA,OAAO,SAASI,mBAAT,CAA6BN,QAA7B,EAAiDO,QAAjD,EAAkE;AAEvE,MAAMC,qBAA8B,GAAG,EAAvC;AACA,MAAIC,YAA0B,GAAGF,QAAjC;;AACA,SAAO,IAAP,EAAa;AAAA;;AACX,yBAAIE,YAAJ,aAAI,cAAcJ,GAAlB,EAAuB;AACrBG,MAAAA,qBAAqB,CAACE,OAAtB,CAA8BD,YAA9B;AACAA,MAAAA,YAAY,GAAGT,QAAQ,CAACI,kBAAT,CAA4BK,YAAY,CAACJ,GAAzC,CAAf;AACD;;AAED,QAAIb,SAAS,CAACe,QAAD,EAAWE,YAAX,CAAb,EAAuC;AACrC;AACD;AACF;;AAED,MAAME,QAAQ,GAAG9B,QAAQ,CAACU,MAAT,CAAgB;AAC/BqB,IAAAA,KAAK,EAAEJ;AADwB,GAAhB,CAAjB;AAGA,SAAOG,QAAP;AACD;AAED,OAAO,SAASE,WAAT,CAAqB5B,IAArB,EAAwD;AAC7D,SAAOL,OAAO,CAACM,SAAR,CAAkBD,IAAlB,KAA2B,CAACA,IAAI,CAACY,IAAL,CAAUiB,IAAtC,KACL7B,IAAI,CAAC2B,KAAL,CAAWG,MAAX,KAAsB,CAAtB,IACC9B,IAAI,CAAC2B,KAAL,CAAWG,MAAX,KAAsB,CAAtB,IAA2BhC,IAAI,CAACiC,WAAL,CAAiB/B,IAAI,CAAC2B,KAAL,CAAW,CAAX,CAAjB,CAFvB,CAAP;AAID","sourcesContent":["import equal from 'fast-deep-equal';\nimport { Paragraph, ParagraphData, Heading } from '@ali/4ever-mo';\nimport { Document, Block, Node, BlockChildren, Text, BlockChild } from '@ali/4ever-cangjie';\n\nexport type Callout = Block<ParagraphData, BlockChildren>;\n\nexport function isCalloutParagraph(node: any) {\n  return Heading.isCallout(node);\n}\n\nexport function isCallout(node: any): node is Callout {\n  return Block.isBlock(node) && node.type === 'callout-group';\n}\n\nexport interface CalloutProps {\n  key?: string;\n  data: ParagraphData;\n  nodes?: BlockChild[];\n}\n\nexport function createCallout(props: CalloutProps): Callout {\n  return Block.create({\n    ...props,\n    type: 'callout-group',\n  });\n}\n\nexport const condition = (firstNode: Block, nextNode: Node | null) => !(nextNode\n  && (Paragraph.isParagraph(nextNode) || Heading.isHeading(nextNode))\n  && !!nextNode.data.calloutPr\n  && equal(nextNode.data.calloutPr, firstNode.data.calloutPr)\n);\n\nexport function findFirstBlockOfCalloutPr(document: Document, startNode: Block) {\n  let finalNode = startNode;\n  while (true) {\n    const prevSibling = document.getPreviousSibling(finalNode.key);\n    if (condition(startNode, prevSibling)) {\n      break;\n    }\n    finalNode = prevSibling as Heading | Paragraph;\n  }\n  return finalNode;\n}\n\n// 高亮块全选时复制生成 fragment\n// TODO: 外部复制，生成 HTML\nexport function generateClipCallout(document: Document, endBlock: Block) {\n\n  const shouldCutOrCopyBlocks: Block[] = [];\n  let currentBlock: Block | null = endBlock;\n  while (true) {\n    if (currentBlock?.key) {\n      shouldCutOrCopyBlocks.unshift(currentBlock);\n      currentBlock = document.getPreviousSibling(currentBlock.key) as (Block | null);\n    }\n\n    if (condition(endBlock, currentBlock)) {\n      break;\n    }\n  }\n\n  const fragment = Document.create({\n    nodes: shouldCutOrCopyBlocks,\n  });\n  return fragment;\n}\n\nexport function isEmptyNode(node: Block | null): node is Block {\n  return Heading.isCallout(node) && !node.data.list && (\n    node.nodes.length === 0 ||\n    (node.nodes.length === 1 && Text.isEmptyText(node.nodes[0]))\n  );\n}\n"],"file":"utils.js"}