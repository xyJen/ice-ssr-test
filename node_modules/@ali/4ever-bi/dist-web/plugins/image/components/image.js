import _extends from "@babel/runtime/helpers/extends";
import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/* eslint-disable react/no-find-dom-node */
import * as React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import * as ReactDOM from 'react-dom';
import { throttle, isEqual, isEmpty, omit } from 'lodash-es';
import classnames from 'classnames';
import ResizeObserver from 'resize-observer-polyfill';
import { useZoom, useZoomContainer, useSelectionData } from '@ali/4ever-cangjie';
import { useHover } from '@ali/4ever-component';
import { ImagePlugin, PcContextMenu, useScrollableContent } from '@ali/4ever-bamboo';
import { sanitizeUrl, getBoundingRelativeRect, normalizeAngle, getData } from '@ali/4ever-utils';
import { updateImage, setImageInjection, selectImage } from "../actions";
import ImageEditor from "./imageEditor";
import ImageCrop from "./imageCrop";
import ImageInlineToolbar from "./ImageInlineToolbar";
import { ImgContent, ImgMeta } from "./styled";
var Img = ImagePlugin.Img,
    isComplexImg = ImagePlugin.isComplexImg,
    isNodeInTable = ImagePlugin.isNodeInTable,
    isValidSize = ImagePlugin.isValidSize;
var closeContextMenu = PcContextMenu.closeContextMenu;
var THROTTLE_PREVIEW_TIME = 400;
var IS_EMPTY_IGNORE_PROPS = ['uuid'];

function isImageRectChanged(prevData, data) {
  var width = data.width,
      height = data.height,
      rotation = data.rotation,
      rectClip = data.rectClip,
      outline = data.outline;
  var prevWidth = prevData.width,
      prevHeight = prevData.height,
      prevRotation = prevData.rotation,
      prevRectClip = prevData.rectClip,
      prevOutline = prevData.outline;
  return width !== prevWidth || height !== prevHeight || rotation !== prevRotation || !isEqual(rectClip, prevRectClip) || (outline == null ? void 0 : outline.width) !== (prevOutline == null ? void 0 : prevOutline.width);
}

var Image = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Image, _React$Component);

  Image.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    var isSelected = props.isSelected,
        node = props.node;
    var isRectUpdating = isImageRectChanged(state.prevData, node.data);

    if (!isSelected || isRectUpdating) {
      var newIsCanPreview = !isSelected ? {
        isCanPreview: false
      } : undefined;
      var newUpdate = isRectUpdating ? {
        isUpdating: true,
        prevData: node.data
      } : undefined;
      return _extends({}, newIsCanPreview, newUpdate);
    }

    return null;
  };

  function Image(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.image = void 0;
    _this.ref = void 0;
    _this.isFirstLoad = void 0;
    _this.frameId = -1;
    _this.updatingEndFrameId = -1;
    _this.updateMaxWidthFrameId = -1;
    _this.isFocusedBeforeClick = false;
    _this.resizeObserver = null;
    _this.prevMaxWidth = void 0;

    _this.getPortalPosition = function () {
      var _this$props = _this.props,
          scale = _this$props.scale,
          zoomContainer = _this$props.zoomContainer;

      if (!_this.ref.current) {
        return {
          left: -9999,
          right: -9999
        };
      }

      var rect = getBoundingRelativeRect(_this.ref.current, zoomContainer);
      var left = rect.left / scale;
      var top = rect.top / scale;
      return {
        left: left,
        top: top
      };
    };

    _this.setIsLoaded = function (isLoaded) {
      _this.setState({
        isLoaded: isLoaded
      });
    };

    _this.getZoomContainer = function () {
      var zoomContainer = _this.props.zoomContainer;
      return zoomContainer;
    };

    _this.getScrollableContent = function () {
      return _this.props.scrollableContent || window.document.body;
    };

    _this.onEnterCroppingMode = function (e) {
      e.preventDefault();
      e.stopPropagation();
      var _this$props2 = _this.props,
          controller = _this$props2.controller,
          node = _this$props2.node;
      controller.run('onAction', setImageInjection(node.key, {
        isImageCropping: true
      }));
    };

    _this.onExitCroppingMode = function () {
      var _this$props3 = _this.props,
          controller = _this$props3.controller,
          node = _this$props3.node;
      controller.run('onAction', setImageInjection(node.key, {
        isImageCropping: false
      }));
    };

    _this.onEnterRotationMode = function () {
      _this.setState({
        isRotating: true
      });
    };

    _this.onEnterResizingMode = function () {
      _this.setState({
        isResizing: true
      });
    };

    _this.exitRotationMode = function (cb) {
      _this.setState({
        isRotating: false
      }, cb);
    };

    _this.getImageContainer = function () {
      return _this.ref.current;
    };

    _this.handleChangeSize = function (width, height, l, r, t, b) {
      if (l === void 0) {
        l = 0;
      }

      if (r === void 0) {
        r = 0;
      }

      if (t === void 0) {
        t = 0;
      }

      if (b === void 0) {
        b = 0;
      }

      width = Number(width);
      height = Number(height);
      if (typeof width !== 'number' || typeof height !== 'number') return;
      var _this$props4 = _this.props,
          node = _this$props4.node,
          controller = _this$props4.controller;
      var data = {
        width: width,
        height: height
      };

      if (l || t || r || b) {
        data.rectClip = {
          left: l,
          right: r,
          top: t,
          bottom: b
        };
      }

      var rotation = node.data.rotation;

      if (typeof rotation !== 'number') {
        data.rotation = 0;
      }

      controller.run('onAction', updateImage(node, data));

      _this.setState({
        isResizing: false
      });
    };

    _this.handleRotate = function (rotation, cb) {
      // 旋转同时会设置高宽，以方便排版等计算
      var _this$props5 = _this.props,
          node = _this$props5.node,
          controller = _this$props5.controller;
      var _node$data = node.data,
          width = _node$data.width,
          height = _node$data.height;

      var container = _this.getZoomContainer();

      if (rotation !== null) {
        rotation = normalizeAngle(rotation, true);
        controller.run('onAction', updateImage(node, {
          rotation: rotation,
          width: width,
          height: height
        }, container));
      }

      _this.exitRotationMode(cb);
    };

    _this.handleInlineToolbarRotate = function (e) {
      e.preventDefault();
      e.stopPropagation();
      var node = _this.props.node;
      var rotation = getData(node.data, 'rotation', 0);
      var newRotation = normalizeAngle(rotation + 90);

      _this.handleRotate(newRotation);
    };

    _this.handleInlineToolbarRotateAntiClockwise = function (e) {
      e.preventDefault();
      e.stopPropagation();
      var node = _this.props.node;
      var rotation = getData(node.data, 'rotation', 0);
      var newRotation = normalizeAngle(rotation - 90);

      _this.handleRotate(newRotation);
    };

    _this.getUploadProgress = function () {
      var node = _this.props.node;

      var _ref = node.data || {},
          src = _ref.src,
          _ref$uploadPercent = _ref.uploadPercent,
          uploadPercent = _ref$uploadPercent === void 0 ? 0 : _ref$uploadPercent; // upload.progress 到达 100% 时，整体进度只展示 95%
      // 不展示 100% 原因是还需要下载图片
      // 目前看 progress 在生产环境可代表真实进度


      return src ? 100 : uploadPercent * 0.95;
    };

    _this.getCursor = function () {
      var _this$props6 = _this.props,
          _this$props6$imageCon = _this$props6.imageConfig,
          imageConfig = _this$props6$imageCon === void 0 ? {} : _this$props6$imageCon,
          controller = _this$props6.controller;
      var previewImage = imageConfig.previewImage;
      var isFocused = controller.value.isFocused;

      if (previewImage && _this.shouldShowToolbar() && isFocused) {
        return 'zoom-in';
      }

      return 'auto';
    };

    _this.handlePreviewImage = function () {
      var isLoaded = _this.state.isLoaded;
      var _this$props7 = _this.props,
          imageConfig = _this$props7.imageConfig,
          node = _this$props7.node,
          controller = _this$props7.controller;
      var previewImage = imageConfig == null ? void 0 : imageConfig.previewImage;
      if (!isLoaded || !previewImage) return;
      var src = node.data.src;
      var isSelectingNode = controller.query('isSelectingNode');
      if (isSelectingNode) return;
      previewImage(src, node);
    };

    _this.throttleHandlePreviewImage = throttle(_this.handlePreviewImage, THROTTLE_PREVIEW_TIME);

    _this.handleLoad = function () {
      _this.setIsLoaded(true);

      var _ref2 = _this.props.pluginState || {},
          url = _ref2.url;

      if (url && url.startsWith('blob:')) {
        URL.revokeObjectURL(url);
      }
    };

    _this.handleContextMenu = function (event) {
      event.preventDefault();
    };

    _this.closeContextMenu = function () {
      var controller = _this.props.controller;
      controller.run('onAction', closeContextMenu());
    };

    _this.handleImgClick = function () {
      _this.closeContextMenu();

      var _this$props8 = _this.props,
          controller = _this$props8.controller,
          node = _this$props8.node;

      if (ImagePlugin.isParentClickable(controller, node)) {
        return;
      }

      if (_this.state.isCanPreview && _this.isFocusedBeforeClick) {
        _this.handlePreviewImage();
      }
    };

    _this.handleImgDoubleClick = function () {
      _this.throttleHandlePreviewImage();
    };

    _this.handleMouseDown = function () {
      _this.isFocusedBeforeClick = _this.props.controller.value.isFocused;
    };

    _this.handleMouseEnter = function (e) {
      e.stopPropagation();

      _this.setState({
        isHovering: true
      });
    };

    _this.handleMouseLeave = function () {
      _this.setState({
        isHovering: false
      });
    };

    _this.handleMouseOver = function (e) {
      e.stopPropagation();

      _this.props.onMouseOver(e);
    };

    _this.getImgRectData = function () {
      var _this$image$current3, _this$image$current4;

      var node = _this.props.node;
      var _ref3 = node.data,
          width = _ref3.width,
          height = _ref3.height,
          outline = _ref3.outline,
          rectClip = _ref3.rectClip;
      var isComplex = isComplexImg(node.data);
      var isValid = isValidSize(width, height);

      var position = _this.getPortalPosition();

      var l = (rectClip == null ? void 0 : rectClip.left) || 0;
      var r = (rectClip == null ? void 0 : rectClip.right) || 0;
      var t = (rectClip == null ? void 0 : rectClip.top) || 0;
      var b = (rectClip == null ? void 0 : rectClip.bottom) || 0;

      if (isComplex && isValid) {
        var _this$image$current, _this$image$current2;

        // img 标签的实际渲染宽度
        var fixedOutline = ((outline == null ? void 0 : outline.width) || 0) * 2; // HACK: 图片增加边框后整体所占的宽高不变，其实会导致图片变形，原因是宽高向内收缩的像素是相同的，但是图片的宽高比例不同
        // img 元素的实际宽度

        var renderImgWidth = ((_this$image$current = _this.image.current) == null ? void 0 : _this$image$current.clientWidth) || 0; // img 元素的实际长度

        var renderImgHeight = ((_this$image$current2 = _this.image.current) == null ? void 0 : _this$image$current2.clientHeight) || 0; // 图片实际可见的宽度（不包含边框）= img 元素的实际宽度 * 剪裁后剩余部分所占的比例

        var renderVisibleWidth = renderImgWidth * (width / (width + l + r)); // 图片整体可见的宽度（包含边框）

        var renderContainerWidth = renderVisibleWidth + fixedOutline; // 图片整体可见的高度（包含边框）= 图片整体可见的宽度（包含边框） * 落库的高相对于宽的比例

        var renderContainerHeight = renderContainerWidth * (height / width); // 图片实际可见的高度（不包含边框） = 图片整体可见的高度 - 固定的边框（用户添加的边框）

        var renderVisibleHeight = renderContainerHeight - fixedOutline;
        return _extends({
          width: renderVisibleWidth,
          height: renderVisibleHeight,
          l: renderImgWidth * (l / (width + l + r)),
          r: renderImgWidth * (r / (width + l + r)),
          t: renderImgHeight * (t / (height + t + b)),
          b: renderImgHeight * (b / (height + t + b))
        }, position);
      }

      return _extends({
        width: ((_this$image$current3 = _this.image.current) == null ? void 0 : _this$image$current3.clientWidth) || 0,
        height: ((_this$image$current4 = _this.image.current) == null ? void 0 : _this$image$current4.clientHeight) || 0,
        l: l,
        r: r,
        t: t,
        b: b
      }, position);
    };

    _this.getImgRef = function () {
      return _this.image.current;
    };

    _this.renderImage = function () {
      var _this$props9 = _this.props,
          node = _this$props9.node,
          children = _this$props9.children,
          attributes = _this$props9.attributes,
          controller = _this$props9.controller,
          scale = _this$props9.scale,
          pluginState = _this$props9.pluginState,
          _this$props9$imageCon = _this$props9.imageConfig,
          imageConfig = _this$props9$imageCon === void 0 ? {} : _this$props9$imageCon,
          zoomContainer = _this$props9.zoomContainer;

      var _ref4 = pluginState || {},
          url = _ref4.url;

      var _this$state = _this.state,
          isRotating = _this$state.isRotating,
          isResizing = _this$state.isResizing,
          isHovering = _this$state.isHovering,
          isTransferring = _this$state.isTransferring,
          isLoaded = _this$state.isLoaded,
          maxWidth = _this$state.maxWidth;
      var _ref5 = node.data,
          src = _ref5.src;
      var renderExtraNode = imageConfig.renderExtraNode;
      var rotation = getData(node.data, 'rotation', 0);
      var isBlurred = controller.value.isBlurred;

      var uploadProgress = _this.getUploadProgress();

      var normalizeRotation = normalizeAngle(rotation);

      var transformedSrc = _this.calcSrc(src);

      var isImageSelected = _this.shouldShowToolbar();

      var isHover = !isRotating && !isResizing && isHovering;
      return /*#__PURE__*/_createElement(React.Fragment, null, children, zoomContainer && _this.isCropping() && _this.ref.current ? /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/_createElement(ImageCrop, {
        src: transformedSrc,
        rotation: normalizeRotation,
        handleCrop: _this.handleChangeSize,
        onExitCroppingMode: _this.onExitCroppingMode,
        getImgRectData: _this.getImgRectData,
        getZoomContainer: _this.getZoomContainer,
        controller: controller,
        scale: scale
      }), zoomContainer) : null, /*#__PURE__*/_createElement(ImgMeta, {
        style: {
          visibility: _this.isCropping() || _this.isRotating() ? 'hidden' : 'visible',
          userSelect: _this.isCropping() || _this.isRotating() ? 'none' : 'auto',
          maxWidth: maxWidth
        },
        className: classnames({
          'show-highlight': isImageSelected && !isResizing && !isBlurred,
          'disable-highlight-when-hover': isResizing
        }),
        imgCursor: _this.getCursor(),
        onMouseEnter: renderExtraNode && _this.handleMouseEnter,
        onMouseLeave: renderExtraNode && _this.handleMouseLeave,
        onMouseOver: _this.handleMouseOver,
        "data-hover-box": "noBorderBox"
      }, /*#__PURE__*/_createElement(Img, _extends({}, attributes, {
        ref: _this.image,
        uploadPlaceholder: url,
        node: node,
        controller: controller,
        uploadProgress: uploadProgress,
        onDoubleClick: _this.handleImgDoubleClick,
        onContextMenu: _this.handleContextMenu,
        onClick: _this.handleImgClick,
        onMouseDown: _this.handleMouseDown,
        isTransferring: isTransferring,
        imageConfig: imageConfig,
        onLoad: _this.handleLoad
      })), renderExtraNode && renderExtraNode(node, isHover, isImageSelected)), zoomContainer && isImageSelected && !_this.state.isUpdating && _this.ref.current && /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/_createElement(ImageEditor, {
        node: node,
        src: transformedSrc,
        controller: controller,
        scale: scale,
        rotation: normalizeRotation,
        onChangeSize: _this.handleChangeSize,
        onEnterRotationMode: _this.onEnterRotationMode,
        handleRotate: _this.handleRotate,
        onEnterResizingMode: _this.onEnterResizingMode,
        isRotating: isRotating,
        getZoomContainer: _this.getZoomContainer,
        onContextMenu: _this.handleContextMenu,
        imageConfig: imageConfig,
        isLoaded: isLoaded,
        isBlurred: isBlurred,
        getImgRectData: _this.getImgRectData,
        getImgRef: _this.getImgRef
      }), zoomContainer));
    };

    var _pluginState = props.pluginState,
        isSelected = props.isSelected,
        _node = props.node,
        _imageConfig = props.imageConfig;
    _this.state = {
      isRotating: false,
      isResizing: false,
      isHovering: false,
      isTransferring: _pluginState && _pluginState.isTransferring,
      // @ts-ignore
      isLoaded: !!(_imageConfig != null && _imageConfig.isTesting),
      isCanPreview: isSelected,
      // 解决图片编辑后，编辑框未更新或编辑框闪烁更新
      // 原因: 由于自适应后图片编辑后的尺寸不一定与编辑结束时一致，Image Editor 需要感知图片实际 render 的尺寸，但是可能传入未渲染完成的 render size，造成编辑框未更新。
      // 解法1：在本组件的 componentDidUpdate 中，更新render size state时加上延时，可以解决未更新的问题，但是编辑框会闪烁。
      // 解法2：增加 isUpdating state，默认为 false，在resize 和 旋转结束、更新图片时设置 isUpdating 为 true，紧接着延时设置为 false（预期渲染完毕）
      // ，触发render，由于在 isUpdating = true 时不会渲染编辑框，因此不会出现编辑框闪烁的问题。
      isUpdating: false,
      prevData: _node.data,
      maxWidth: _this.getIsAutoFit() ? '100%' : undefined
    };
    _this.image = /*#__PURE__*/React.createRef();
    _this.ref = /*#__PURE__*/React.createRef();
    _this.isFirstLoad = true;
    return _this;
  }

  var _proto = Image.prototype;

  _proto.getIsAutoFit = function getIsAutoFit() {
    var _this$props10 = this.props,
        node = _this$props10.node,
        controller = _this$props10.controller,
        imageConfig = _this$props10.imageConfig;

    var _ref6 = imageConfig || {},
        disableStretchMode = _ref6.disableStretchMode;

    var isInTable = isNodeInTable(node, controller.value.document);
    var disableStretch = typeof disableStretchMode === 'function' && disableStretchMode();
    var isAutoFit = !disableStretch || isInTable;
    return isAutoFit;
  };

  _proto.initResizeObserver = function initResizeObserver() {
    var _this2 = this;

    var _this$props11 = this.props,
        _this$props11$imageCo = _this$props11.imageConfig,
        imageConfig = _this$props11$imageCo === void 0 ? {} : _this$props11$imageCo,
        controller = _this$props11.controller,
        node = _this$props11.node;
    var getMaxWidthContainer = imageConfig.getMaxWidthContainer;
    var maxWidthContainer = getMaxWidthContainer && getMaxWidthContainer(node, controller.value.document);

    if (!maxWidthContainer) {
      return;
    }

    var updateMaxWidth = throttle(function () {
      _this2.updateMaxWidthFrameId = window.requestAnimationFrame(function () {
        var maxWidth = maxWidthContainer.clientWidth;

        _this2.setState({
          maxWidth: maxWidth || '100%'
        });
      });
    }, 200);

    var observerCallback = function observerCallback(entries) {
      for (var _iterator = _createForOfIteratorHelperLoose(entries), _step; !(_step = _iterator()).done;) {
        var entry = _step.value;

        if (_this2.prevMaxWidth !== entry.contentRect.width) {
          updateMaxWidth();
          _this2.prevMaxWidth = entry.contentRect.width;
        }
      }
    };

    this.resizeObserver = new ResizeObserver(observerCallback);
    this.resizeObserver.observe(maxWidthContainer);
  };

  _proto.componentDidMount = function componentDidMount() {
    if (this.getIsAutoFit()) {
      this.initResizeObserver();
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    var _this3 = this;

    var pluginState = this.props.pluginState;
    var prevPluginState = prevProps.pluginState;
    var isTransferring = pluginState.isTransferring;

    if (prevPluginState.isTransferring !== isTransferring) {
      this.setState({
        isTransferring: isTransferring
      });
    }

    if (this.state.isUpdating && this.state.prevData && this.state.prevData !== prevState.prevData) {
      window.cancelAnimationFrame(this.updatingEndFrameId);
      this.updatingEndFrameId = window.requestAnimationFrame(function () {
        _this3.setState({
          isUpdating: false,
          isResizing: false,
          isRotating: false
        });
      });
    } // preview 功能等待一个 frame 周期，防止 mousedown 提前更新导致的单击进入预览的问题


    if (this.props.isSelected && !this.state.isCanPreview) {
      this.frameId = window.requestAnimationFrame(function () {
        _this3.setState({
          isCanPreview: true
        });
      });
    }

    if (!this.props.isSelected && prevProps.isSelected) {
      this.state.isResizing && this.setState({
        isResizing: false
      });
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    window.cancelAnimationFrame(this.frameId);
    window.cancelAnimationFrame(this.updatingEndFrameId);
    window.cancelAnimationFrame(this.updateMaxWidthFrameId);
    this.resizeObserver && this.resizeObserver.disconnect();

    var _ref7 = this.props.pluginState || {},
        url = _ref7.url;

    if (url && url.startsWith('blob:')) {
      URL.revokeObjectURL(url);
    }
  };

  _proto.calcSrc = function calcSrc(src) {
    if (src === null) return null;

    if (!src) {
      var pluginState = this.props.pluginState;

      var _ref8 = pluginState || {},
          url = _ref8.url;

      return url;
    }

    var _this$props12 = this.props,
        imageManager = _this$props12.imageManager,
        _this$props12$imageCo = _this$props12.imageConfig,
        imageConfig = _this$props12$imageCo === void 0 ? {} : _this$props12$imageCo;
    var protocolAllowList = imageConfig.protocolAllowList;
    var renderSrc = (imageManager == null ? void 0 : imageManager.getTransformedURL(src)) || src;
    return sanitizeUrl(renderSrc, protocolAllowList);
  };

  _proto.shouldShowToolbar = function shouldShowToolbar() {
    var _this$props13 = this.props,
        controller = _this$props13.controller,
        isSelected = _this$props13.isSelected;
    return !this.isCropping() && isSelected && controller.value.selection.isCollapsed;
  };

  _proto.isCropping = function isCropping() {
    var node = this.props.node;
    return node.data.isImageCropping;
  };

  _proto.isSettingBorder = function isSettingBorder() {
    var node = this.props.node;
    return node.data.isSettingBorder;
  };

  _proto.isRotating = function isRotating() {
    var isRotating = this.state.isRotating;
    var node = this.props.node;
    var _node$data2 = node.data,
        width = _node$data2.width,
        height = _node$data2.height;
    return isRotating && typeof width === 'number' && typeof height === 'number';
  };

  _proto.renderInlineToolbar = function renderInlineToolbar() {
    var _this$props14 = this.props,
        controller = _this$props14.controller,
        node = _this$props14.node,
        imageConfig = _this$props14.imageConfig;
    var showToolbar = this.shouldShowToolbar() && (controller.value.isFocused || this.isSettingBorder());
    if (!showToolbar) return null;

    var _ref9 = imageConfig || {},
        previewImage = _ref9.previewImage,
        downloadImage = _ref9.downloadImage,
        locale = _ref9.locale,
        customToolbars = _ref9.customToolbars,
        inlineToolbarMore = _ref9.inlineToolbarMore;

    var realInlineLayout = controller.query('getImageInlineToolbarLayout');
    var hasInlineToolbar = Array.isArray(realInlineLayout) && realInlineLayout.length > 0;
    return hasInlineToolbar && /*#__PURE__*/_createElement(ImageInlineToolbar, {
      visible: true,
      controller: controller,
      triggerNode: this.ref.current,
      node: node,
      locale: locale,
      handleInlineToolbarRotate: this.handleInlineToolbarRotate,
      handleInlineToolbarRotateAntiClockwise: this.handleInlineToolbarRotateAntiClockwise,
      previewImage: previewImage,
      downloadImage: downloadImage,
      onEnterCroppingMode: this.onEnterCroppingMode,
      getZoomContainer: this.getZoomContainer,
      getScrollableContent: this.getScrollableContent,
      inlineToolbarLayout: realInlineLayout // @ts-ignore
      ,
      customToolbars: customToolbars,
      inlineToolbarMore: inlineToolbarMore
    });
  };

  _proto.render = function render() {
    var _this$state2 = this.state,
        isLoaded = _this$state2.isLoaded,
        isResizing = _this$state2.isResizing,
        isRotating = _this$state2.isRotating;
    var disableInlineToolbar = this.props.disableInlineToolbar;
    return /*#__PURE__*/_createElement(React.Fragment, null, !disableInlineToolbar && isLoaded && !(isResizing || isRotating) && this.renderInlineToolbar(), /*#__PURE__*/_createElement(ImgContent, {
      ref: this.ref
    }, this.renderImage()));
  };

  return Image;
}(React.Component);

var Container = function Container(props) {
  var controller = props.controller,
      node = props.node,
      imageConfig = props.imageConfig;
  var scrollableContent = useScrollableContent();
  var zoomContainer = useZoomContainer() || document.body;
  var scale = useZoom();
  var imageManager = ImagePlugin.useImageManager();

  var _React$useState = React.useState(false),
      isSelected = _React$useState[0],
      setSelected = _React$useState[1];

  var disableInlineToolbar = controller.query('hasHoverToolbar', 'image');
  var hoverHandlers = useHover(true)[1];
  var handlePendingSelectionChange = React.useCallback(function () {
    var selection = controller.value.selection;
    var isCollapsed = selection.isCollapsed,
        anchor = selection.anchor;

    if (!isCollapsed) {
      isSelected && setSelected(false);
    } else {
      var isPendingSelected = node.hasNode(anchor.key);
      isSelected !== isPendingSelected && setSelected(isPendingSelected);
    }
  }, [controller, node, isSelected]);
  useSelectionData(controller.selectionData$, null, handlePendingSelectionChange, []);

  if (!node.data || isEmpty(omit(node.data, IS_EMPTY_IGNORE_PROPS))) {
    var _imageConfig$locale;

    return /*#__PURE__*/_createElement(ImagePlugin.InlinePlaceholder, {
      onClick: function onClick() {
        return controller.run('onAction', selectImage(node.key));
      }
    }, (imageConfig == null ? void 0 : (_imageConfig$locale = imageConfig.locale) == null ? void 0 : _imageConfig$locale.placeholder) || 'Image');
  }

  return /*#__PURE__*/_createElement(Image, _extends({}, props, {
    scrollableContent: scrollableContent,
    zoomContainer: zoomContainer,
    scale: scale,
    isSelected: controller.enablePending.selection ? isSelected : props.isSelected,
    imageManager: imageManager,
    disableInlineToolbar: disableInlineToolbar,
    onMouseOver: hoverHandlers.onMouseOver
  }));
};

export default Container;
//# sourceMappingURL=image.js.map