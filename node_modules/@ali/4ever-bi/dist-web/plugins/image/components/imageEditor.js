import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import * as React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import { throttle, debounce } from 'lodash-es';
import ResizeObserver from 'resize-observer-polyfill';
import { calcRotationObj, calcXAfterRotation, calcYAfterRotation, getRelativeMouseEvent, getRelativeTouchEvent } from '@ali/4ever-utils';
import { environment, domUtils } from '@ali/4ever-cangjie';
import { PluginRoles, DraggablePlugin } from '@ali/4ever-bamboo';
import ImageRotate from "./imageRotate";
import ImageRotateHolder from "./imageRotateHolder";
import { EditorResizeHolder, EditorNum, SelectBorder, BgImg, ImageLoading, RotateControl, ImageEditorFrame } from "./styled";
import { getFixedNumber, getResizeCursor } from "../utils";
import { Position } from "./constants";
var IMAGE_BG_COLOR = 'rgba(0, 137, 255, .1)';
var ACCURACY = 5;

function shouldUseNaturalRatio(data) {
  var rectClip = data.rectClip;
  return !rectClip || !(rectClip.left || rectClip.right || rectClip.top || rectClip.bottom);
}

var _ref2 = /*#__PURE__*/_createElement(ImageLoading, null);

var ImageEditor = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(ImageEditor, _React$Component);

  function ImageEditor(props) {
    var _node$data, _node$data$outline;

    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.imageEditor = void 0;
    _this.rotateControl = void 0;
    _this.initialRectData = void 0;
    _this.resizeObserver = null;
    _this.mutationObserver = null;
    _this.prevImgWidth = void 0;
    _this.mutationFrameId = -1;
    _this.resizeFrameId = -1;
    _this.rate = void 0;
    _this.naturalRate = void 0;
    _this.scrollableAncestorsDOM = [];
    _this.handleParentScroll = throttle(function () {
      var rectData = _this.getRealImgRectData();

      _this.setState(rectData);
    }, 200);

    _this.onResizeStart = function (relativeEvent, angle) {
      _this.setState({
        mouse: {
          x: relativeEvent.relativeX,
          y: relativeEvent.relativeY
        },
        angle: angle,
        resizing: false
      });

      _this.props.onEnterResizingMode();
    };

    _this.onResizeMove = function (relativeEvent) {
      var X = relativeEvent.relativeX;
      var Y = relativeEvent.relativeY;
      var mouse = _this.state.mouse;
      var scale = _this.props.scale;

      if (X !== mouse.x || Y !== mouse.y) {
        var x = (mouse.x - X) / scale;
        var y = (mouse.y - Y) / scale;

        _this.updateImageSize(x, y);

        _this.setState({
          mouse: {
            x: X,
            y: Y
          },
          resizing: true
        });
      }
    };

    _this.onResizeEnd = function () {
      var onChangeSize = _this.props.onChangeSize;
      var _this$initialRectData = _this.initialRectData,
          l = _this$initialRectData.l,
          r = _this$initialRectData.r,
          t = _this$initialRectData.t,
          b = _this$initialRectData.b;
      var _this$imageEditor$cur = _this.imageEditor.current,
          clientWidth = _this$imageEditor$cur.clientWidth,
          clientHeight = _this$imageEditor$cur.clientHeight;
      var ratio = clientWidth / _this.initialRectData.width;
      l = getFixedNumber(ratio * l, ACCURACY);
      r = getFixedNumber(ratio * r, ACCURACY);
      t = getFixedNumber(ratio * t, ACCURACY);
      b = getFixedNumber(ratio * b, ACCURACY);
      onChangeSize(clientWidth, clientHeight, l, r, t, b);

      _this.setState({
        resizing: false,
        angle: 0
      });
    };

    _this.handleMouseDown = function (e, angle) {
      e.preventDefault();
      e.stopPropagation();
      var getZoomContainer = _this.props.getZoomContainer;
      var zoomContainer = getZoomContainer();
      if (!zoomContainer) return;
      var relativeEvent = getRelativeMouseEvent(e, zoomContainer);

      _this.onResizeStart(relativeEvent, angle);

      document.addEventListener('mousemove', _this.handleMouseMove);
      document.addEventListener('mouseup', _this.handleMouseUp);
    };

    _this.handleMouseMove = function (e) {
      e.preventDefault();
      e.stopPropagation();
      var getZoomContainer = _this.props.getZoomContainer;
      var zoomContainer = getZoomContainer();
      var relativeEvent = getRelativeMouseEvent(e, zoomContainer);

      _this.onResizeMove(relativeEvent);
    };

    _this.handleMouseUp = function (e) {
      e.preventDefault();
      e.stopPropagation();

      _this.onResizeEnd();

      document.removeEventListener('mousemove', _this.handleMouseMove);
      document.removeEventListener('mouseup', _this.handleMouseUp);
    };

    _this.handleTouchStart = function (e, angle) {
      e.preventDefault();
      e.stopPropagation();
      var getZoomContainer = _this.props.getZoomContainer;
      var zoomContainer = getZoomContainer();
      var targetTouches = e.targetTouches;
      if (!zoomContainer || targetTouches.length > 1) return;
      var relativeEvent = getRelativeTouchEvent(targetTouches[0], zoomContainer);

      _this.onResizeStart(relativeEvent, angle);

      zoomContainer.addEventListener('touchmove', _this.handleTouchMove);
      zoomContainer.addEventListener('touchend', _this.handleTouchEnd);
    };

    _this.handleTouchMove = function (e) {
      e.preventDefault();
      e.stopPropagation();
      var getZoomContainer = _this.props.getZoomContainer;
      var zoomContainer = getZoomContainer();
      var touch = e.targetTouches[0];
      var relativeEvent = getRelativeTouchEvent(touch, zoomContainer);

      _this.onResizeMove(relativeEvent);
    };

    _this.handleTouchEnd = function (e) {
      e.preventDefault();
      e.stopPropagation();

      _this.onResizeEnd();

      var getZoomContainer = _this.props.getZoomContainer;
      var zoomContainer = getZoomContainer();
      zoomContainer && zoomContainer.removeEventListener('touchmove', _this.handleTouchMove);
      zoomContainer && zoomContainer.removeEventListener('touchend', _this.handleTouchEnd);
    };

    _this.updateImageSize = function (x, y) {
      var _this$props = _this.props,
          rotation = _this$props.rotation,
          node = _this$props.node;
      x = x * Math.cos(-rotation / 180 * Math.PI) - y * Math.sin(-rotation / 180 * Math.PI);
      var nw;
      var _this$state = _this.state,
          width = _this$state.width,
          angle = _this$state.angle,
          l = _this$state.l,
          r = _this$state.r,
          t = _this$state.t,
          b = _this$state.b;

      if (angle < 180) {
        nw = width - x;
      } else {
        nw = width + x;
      } // 最小校验


      if (nw < 24) {
        nw = 24;
      }

      var ratio = nw / width;
      var cW = nw;
      var useNaturalRatio = shouldUseNaturalRatio(node.data);
      var rate = useNaturalRatio && _this.naturalRate ? _this.naturalRate : _this.rate;
      var cH = nw * rate;

      _this.setState({
        width: cW,
        height: cH,
        l: l * ratio,
        t: t * ratio,
        r: r * ratio,
        b: b * ratio
      });
    };

    _this.updateNaturalRate = function (e) {
      var target = e.target;
      var _ref = target,
          naturalWidth = _ref.naturalWidth,
          naturalHeight = _ref.naturalHeight;
      _this.naturalRate = naturalHeight / naturalWidth;
    };

    _this.renderResizeHolder = function (angle) {
      var _this$props2 = _this.props,
          isBlurred = _this$props2.isBlurred,
          imageConfig = _this$props2.imageConfig,
          rotation = _this$props2.rotation;
      var disableResize = imageConfig.disableResize;
      var cursor = getResizeCursor(angle, rotation);
      return !disableResize ? /*#__PURE__*/_createElement(EditorResizeHolder, {
        role: "resizer",
        "data-role": "" + PluginRoles.imageResizer + angle,
        angle: angle,
        cursor: cursor,
        onMouseDown: function onMouseDown(e) {
          return _this.handleMouseDown(e, angle);
        },
        onMouseUp: _this.handleMouseUp,
        onTouchStart: function onTouchStart(e) {
          return _this.handleTouchStart(e, angle);
        },
        onTouchEnd: _this.handleMouseUp,
        isSupportTouch: environment.IS_TOUCH_DEVICE,
        isHide: isBlurred
      }) : null;
    };

    _this.renderRotateHolder = function (angle) {
      var _this$props3 = _this.props,
          isRotating = _this$props3.isRotating,
          onEnterRotationMode = _this$props3.onEnterRotationMode,
          handleRotate = _this$props3.handleRotate,
          rotation = _this$props3.rotation,
          scale = _this$props3.scale,
          getZoomContainer = _this$props3.getZoomContainer,
          controller = _this$props3.controller,
          isBlurred = _this$props3.isBlurred;
      var _this$state2 = _this.state,
          width = _this$state2.width,
          height = _this$state2.height,
          resizing = _this$state2.resizing;
      var isHide = resizing || isBlurred;
      return /*#__PURE__*/_createElement(ImageRotateHolder, {
        angle: angle,
        isSupportTouch: environment.IS_TOUCH_DEVICE,
        isRotating: isRotating,
        onEnterRotationMode: onEnterRotationMode,
        handleRotate: handleRotate,
        rotation: rotation,
        width: width,
        height: height,
        rotateControl: _this.rotateControl.current,
        rotateImageFrame: _this.imageEditor.current,
        getZoomContainer: getZoomContainer,
        controller: controller,
        scale: scale,
        isHide: isHide
      });
    };

    _this.renderEditBorder = function (position) {
      return /*#__PURE__*/_createElement(SelectBorder, {
        position: position
      });
    };

    _this.renderResizeNumber = function () {
      var _this$state3 = _this.state,
          width = _this$state3.width,
          height = _this$state3.height,
          angle = _this$state3.angle,
          resizing = _this$state3.resizing;
      var isRotating = _this.props.isRotating;
      var normalizedWidth = Number(Number(width).toFixed());
      var normalizedHeight = Number(Number(height).toFixed());
      return isRotating ? null : /*#__PURE__*/_createElement(EditorNum, {
        angle: angle,
        resizing: resizing
      }, normalizedWidth, " \xD7 ", normalizedHeight);
    };

    _this.renderResizeBg = function () {
      var _this$props4 = _this.props,
          src = _this$props4.src,
          isRotating = _this$props4.isRotating,
          onContextMenu = _this$props4.onContextMenu,
          filter = _this$props4.filter;
      var _this$state4 = _this.state,
          width = _this$state4.width,
          height = _this$state4.height,
          l = _this$state4.l,
          t = _this$state4.t,
          r = _this$state4.r,
          b = _this$state4.b,
          resizing = _this$state4.resizing;

      if (src) {
        return /*#__PURE__*/_createElement(BgImg, {
          resizing: resizing,
          rotating: isRotating
        }, /*#__PURE__*/_createElement("img", {
          src: src // @ts-ignore 该属性无效
          ,
          filter: filter,
          onContextMenu: onContextMenu,
          style: {
            position: 'relative',
            left: -l,
            top: -t,
            width: typeof width === 'number' ? width + l + r : width,
            height: typeof height === 'number' ? height + t + b : height
          },
          onLoad: _this.updateNaturalRate
        }));
      }

      return _ref2;
    };

    _this.handleClick = function (e) {
      var _controller$query;

      var _this$props5 = _this.props,
          onClick = _this$props5.onClick,
          controller = _this$props5.controller;
      var isImageDraggable = (_controller$query = controller.query('getDraggableConfig')) == null ? void 0 : _controller$query.enabled;

      if (!isImageDraggable) {
        e.preventDefault();
      }

      e.stopPropagation();
      onClick && onClick();
    };

    var _node = props.node;

    var _this$getRealImgRectD = _this.getRealImgRectData(),
        _width = _this$getRealImgRectD.width,
        _height = _this$getRealImgRectD.height,
        _l = _this$getRealImgRectD.l,
        _r = _this$getRealImgRectD.r,
        _t = _this$getRealImgRectD.t,
        _b = _this$getRealImgRectD.b,
        left = _this$getRealImgRectD.left,
        top = _this$getRealImgRectD.top;

    _this.state = {
      mouse: {
        x: 0,
        y: 0
      },
      width: _width,
      height: _height,
      angle: 0,
      resizing: false,
      l: _l,
      r: _r,
      t: _t,
      b: _b,
      left: left,
      top: top
    };
    _this.rotateControl = /*#__PURE__*/React.createRef();
    _this.imageEditor = /*#__PURE__*/React.createRef();
    _this.initialRectData = {
      width: _width,
      height: _height,
      l: _l,
      r: _r,
      t: _t,
      b: _b,
      left: left,
      top: top
    };
    var outlineWidth = ((_node$data = _node.data) == null ? void 0 : (_node$data$outline = _node$data.outline) == null ? void 0 : _node$data$outline.width) || 0;
    _this.prevImgWidth = _width - 2 * outlineWidth;
    _this.rate = _height / _width;
    return _this;
  }

  var _proto = ImageEditor.prototype;

  _proto.initResizeObserver = function initResizeObserver() {
    var _this2 = this;

    var getImgRef = this.props.getImgRef;
    var img = getImgRef();

    if (!img) {
      return;
    }

    var observerCallback = throttle(function (entries) {
      for (var _iterator = _createForOfIteratorHelperLoose(entries), _step; !(_step = _iterator()).done;) {
        var entry = _step.value;

        if (_this2.prevImgWidth !== entry.contentRect.width) {
          _this2.resizeFrameId = window.requestAnimationFrame(function () {
            var rectData = _this2.getRealImgRectData();

            _this2.setState(rectData);
          });
          _this2.prevImgWidth = entry.contentRect.width;
        }
      }
    }, 300);
    this.resizeObserver = new ResizeObserver(observerCallback);
    this.resizeObserver.observe(img);
  };

  _proto.initMutationObserver = function initMutationObserver() {
    var _this3 = this;

    var node = this.props.node;
    var parent = this.props.controller.value.document.getParent(node.key);
    var parentDOM = parent && domUtils.findDOMNodeSafely(parent.key);

    if (!parentDOM) {
      return;
    }

    var observerCallback = debounce(function () {
      _this3.mutationFrameId = window.requestAnimationFrame(function () {
        var rectData = _this3.getRealImgRectData();

        _this3.setState(rectData);
      });
    }, 200);
    this.mutationObserver = new MutationObserver(observerCallback);
    this.mutationObserver.observe(parentDOM, {
      childList: true,
      attributes: true,
      subtree: true,
      attributeFilter: ['style']
    });
  };

  _proto.initScrollHandler = function initScrollHandler() {
    var _this4 = this;

    var node = this.props.node;
    var current = domUtils.findDOMNodeSafely(node.key);

    while ((_current = current) != null && _current.parentElement && !((_current2 = current) != null && (_current2$parentEleme = _current2.parentElement) != null && _current2$parentEleme.getAttribute('data-cangjie-content'))) {
      var _current, _current2, _current2$parentEleme, _current3, _current4, _current5;

      var canScroll = (_current3 = current) == null ? void 0 : _current3.parentElement.getAttribute(DraggablePlugin.SCROLLABLE_ATTRIBUTE_KEY);
      canScroll && this.scrollableAncestorsDOM.push((_current4 = current) == null ? void 0 : _current4.parentElement);
      current = (_current5 = current) == null ? void 0 : _current5.parentElement;
    }

    this.scrollableAncestorsDOM.forEach(function (ancestorDOM) {
      ancestorDOM && ancestorDOM.addEventListener('scroll', _this4.handleParentScroll);
    });
  };

  _proto.removeScrollHandler = function removeScrollHandler() {
    var _this5 = this;

    this.scrollableAncestorsDOM.forEach(function (ancestorDOM) {
      ancestorDOM && ancestorDOM.removeEventListener('scroll', _this5.handleParentScroll);
    });
    this.handleParentScroll.cancel();
  };

  _proto.componentDidMount = function componentDidMount() {
    this.initResizeObserver();
    this.initMutationObserver();
    this.initScrollHandler();
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    var _this$resizeObserver, _this$mutationObserve;

    document.removeEventListener('mousemove', this.handleMouseMove);
    document.removeEventListener('mouseup', this.handleMouseUp);
    var getZoomContainer = this.props.getZoomContainer;
    var container = getZoomContainer();
    container && container.removeEventListener('touchmove', this.handleTouchMove);
    container && container.removeEventListener('touchend', this.handleTouchEnd);
    (_this$resizeObserver = this.resizeObserver) == null ? void 0 : _this$resizeObserver.disconnect();
    (_this$mutationObserve = this.mutationObserver) == null ? void 0 : _this$mutationObserve.disconnect();
    this.removeScrollHandler();
    window.cancelAnimationFrame(this.resizeFrameId);
    window.cancelAnimationFrame(this.mutationFrameId);
  };

  _proto.getRealImgRectData = function getRealImgRectData() {
    var _node$data2, _node$data2$outline;

    var node = this.props.node;
    var outlineWidth = ((_node$data2 = node.data) == null ? void 0 : (_node$data2$outline = _node$data2.outline) == null ? void 0 : _node$data2$outline.width) || 0;
    var rectData = this.props.getImgRectData();
    rectData.width += outlineWidth * 2;
    rectData.height += outlineWidth * 2;
    return rectData;
  };

  _proto.render = function render() {
    var _rotateObj, _rotateObj2;

    var _this$props6 = this.props,
        onEnterRotationMode = _this$props6.onEnterRotationMode,
        handleRotate = _this$props6.handleRotate,
        rotation = _this$props6.rotation,
        isRotating = _this$props6.isRotating,
        getZoomContainer = _this$props6.getZoomContainer,
        scale = _this$props6.scale,
        controller = _this$props6.controller,
        imageConfig = _this$props6.imageConfig;
    var _this$state5 = this.state,
        angle = _this$state5.angle,
        width = _this$state5.width,
        height = _this$state5.height,
        resizing = _this$state5.resizing;
    var rotateObj;

    if (width > 0 && height > 0) {
      rotateObj = calcRotationObj(width, height, rotation);
    }

    var translateX = ((_rotateObj = rotateObj) == null ? void 0 : _rotateObj.translateX) || 0;
    var translateY = ((_rotateObj2 = rotateObj) == null ? void 0 : _rotateObj2.translateY) || 0;
    var oldWidth = this.initialRectData.width;
    var oldHeight = this.initialRectData.height; // 修正旋转后缩放的左上角顶点对齐

    if (rotation !== 0 && oldWidth > 0 && oldHeight > 0) {
      var oldRotateObj = calcRotationObj(oldWidth, oldHeight, rotation);
      var oldRtX = calcXAfterRotation(-oldWidth / 2, -oldHeight / 2, rotation, oldRotateObj.translateX);
      var oldRtY = calcYAfterRotation(-oldWidth / 2, -oldHeight / 2, rotation, oldRotateObj.translateY);
      var newRtX = calcXAfterRotation(-width / 2, -height / 2, rotation, translateX);
      var newRtY = calcYAfterRotation(-width / 2, -height / 2, rotation, translateY);
      translateX = translateX - (newRtX - oldRtX) + (oldWidth - width) / 2;
      translateY = translateY - (newRtY - oldRtY) + (oldHeight - height) / 2;
    }

    var backgroundColor = IMAGE_BG_COLOR;

    if (isRotating || rotation % 90 === 0 || resizing) {
      backgroundColor = 'transparent';
    }

    var disableRotate = imageConfig.disableRotate;
    var rotateStyle = {
      height: rotateObj ? rotateObj.rHeight : height,
      width: rotateObj ? rotateObj.rWidth : width,
      backgroundColor: backgroundColor,
      left: this.state.left,
      top: this.state.top
    };
    var style = {
      width: width,
      height: height,
      top: angle === 45 || angle === 315 ? 'auto' : 0,
      left: angle === 225 || angle === 315 ? 'auto' : 0,
      bottom: angle === 225 || angle === 135 ? 'auto' : 0,
      right: angle === 45 || angle === 135 ? 'auto' : 0,
      transform: "translate(" + translateX + "px, " + translateY + "px) rotate(" + rotation + "deg)"
    };
    var isEditing = isRotating || resizing;
    var isTouchDevice = environment.IS_TOUCH_DEVICE;
    var enableSingleRotateBtn = isTouchDevice && !(environment.IS_MAC || environment.IS_WINDOWS);
    var showMultipleRotateBtn = !disableRotate && !enableSingleRotateBtn;
    return /*#__PURE__*/_createElement(RotateControl, {
      style: rotateStyle,
      ref: this.rotateControl,
      "data-testid": "image-select"
    }, /*#__PURE__*/_createElement(ImageEditorFrame, {
      style: style,
      ref: this.imageEditor,
      "data-testid": "image-select-frame"
    }, !disableRotate && enableSingleRotateBtn && /*#__PURE__*/_createElement(ImageRotate, {
      isRotating: isRotating,
      onEnterRotationMode: onEnterRotationMode,
      handleRotate: handleRotate,
      rotation: rotation,
      width: width,
      height: height,
      rotateControl: this.rotateControl.current,
      rotateImageFrame: this.imageEditor.current,
      getZoomContainer: getZoomContainer,
      controller: controller,
      scale: scale
    }), this.renderResizeBg(), isEditing && this.renderEditBorder(Position.top), isEditing && this.renderEditBorder(Position.right), isEditing && this.renderEditBorder(Position.bottom), isEditing && this.renderEditBorder(Position.left), showMultipleRotateBtn && this.renderRotateHolder(45), showMultipleRotateBtn && this.renderRotateHolder(135), showMultipleRotateBtn && this.renderRotateHolder(225), showMultipleRotateBtn && this.renderRotateHolder(315), this.renderResizeHolder(45), this.renderResizeHolder(135), this.renderResizeHolder(225), this.renderResizeHolder(315), this.renderResizeNumber()));
  };

  return ImageEditor;
}(React.Component);

export default ImageEditor;
//# sourceMappingURL=imageEditor.js.map