import _extends from "@babel/runtime/helpers/extends";
import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";
import * as React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import { getRelativeMouseEvent, getRelativeTouchEvent, calcRotationObj } from '@ali/4ever-utils';
import { PluginRoles } from '@ali/4ever-bamboo';
import { ImageCropSrcRect, CropOuter, CropImageRotate, CropRealOuter, CropRealImage, CropFakeImage, CropFakeInner, CropFrame } from "./styled";
var MIN_CROP_DISTANCE = 20;

var _ref = /*#__PURE__*/_createElement(ImageCropSrcRect, null);

var ImageCrop = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(ImageCrop, _React$Component);

  function ImageCrop(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.initialRectData = void 0;
    _this.originX = void 0;
    _this.originY = void 0;
    _this.currentX = void 0;
    _this.currentY = void 0;
    _this.cropOuter = void 0;
    _this.cropRealImage = void 0;
    _this.cropFakeImage = void 0;
    _this.cropFakeInner = void 0;
    _this.cropOuterTransform = void 0;
    _this.handleTarget = void 0;

    _this.onCropStart = function (relativeEvent, orient, parentOrient) {
      var _this$cropOuter$curre;

      _this.cropOuterTransform = ((_this$cropOuter$curre = _this.cropOuter.current) == null ? void 0 : _this$cropOuter$curre.style.transform) || '';
      _this.originX = relativeEvent.relativeX;
      _this.originY = relativeEvent.relativeY;
      _this.currentX = relativeEvent.relativeX;
      _this.currentY = relativeEvent.relativeY;
      var matchedFrameResize = orient.match(/crop-handle-(\w+)/) || parentOrient.match(/crop-handle-(\w+)/);
      var matchedImageResize = orient.match(/image-handle-(\w+)/) || parentOrient.match(/image-handle-(\w+)/);

      if (matchedFrameResize) {
        _this.handleTarget = ['frameResize', matchedFrameResize[1]];
      } else if (matchedImageResize) {
        _this.handleTarget = ['imageResize', matchedImageResize[1]];
      } else {
        _this.handleTarget = ['frameTranslate'];
      }
    };

    _this.handleMouseDown = function (e) {
      e.preventDefault();
      e.stopPropagation();
      var getZoomContainer = _this.props.getZoomContainer;
      var zoomContainer = getZoomContainer();
      var relativeEvent = getRelativeMouseEvent(e, zoomContainer);
      var orient = e.target.getAttribute('data-orient') || '';
      var parentOrient = e.target.parentNode.getAttribute('data-orient') || '';

      _this.onCropStart(relativeEvent, orient, parentOrient);

      document.addEventListener('mousemove', _this.handleMouseMove);
      document.addEventListener('mouseup', _this.handleMouseUp);
    };

    _this.handleTouchStart = function (e) {
      var _target$parentNode;

      e.preventDefault();
      e.stopPropagation();
      var getZoomContainer = _this.props.getZoomContainer;
      var zoomContainer = getZoomContainer();
      var targetTouches = e.targetTouches;

      if (!zoomContainer || targetTouches.length > 1) {
        return;
      }

      var touch = targetTouches[0];
      var relativeEvent = getRelativeTouchEvent(touch, zoomContainer);
      var target = touch.target;
      var orient = target.getAttribute('data-orient') || '';
      var parentOrient = ((_target$parentNode = target.parentNode) == null ? void 0 : _target$parentNode.getAttribute('data-orient')) || '';

      _this.onCropStart(relativeEvent, orient, parentOrient);

      zoomContainer.addEventListener('touchmove', _this.handleTouchMove);
      zoomContainer.addEventListener('touchend', _this.handleTouchEnd);
    };

    _this.updateCropFrame = function (x, y, target) {
      var _this$state = _this.state,
          width = _this$state.width,
          height = _this$state.height,
          l = _this$state.l,
          t = _this$state.t;
      var _this$props = _this.props,
          rotation = _this$props.rotation,
          scale = _this$props.scale;
      var newWidth = width;
      var newHeight = height;
      var cropOuterEle = _this.cropOuter.current;
      var cropRealImageEle = _this.cropRealImage.current;
      var cropFakeInnerEle = _this.cropFakeInner.current;

      if (!cropOuterEle || !cropRealImageEle || !cropFakeInnerEle) {
        return;
      }

      if (target.indexOf('s') >= 0) {
        newHeight = Math.max(height * scale + y, MIN_CROP_DISTANCE * scale);
        cropOuterEle.style.height = newHeight + 'px';
      }

      if (target.indexOf('e') >= 0) {
        newWidth = Math.max(width * scale + x, MIN_CROP_DISTANCE * scale);
        cropOuterEle.style.width = newWidth + 'px';
      }

      if (target.indexOf('n') >= 0) {
        newHeight = Math.max(height * scale - y, MIN_CROP_DISTANCE * scale);
        cropOuterEle.style.height = newHeight + 'px';
        var top = -t * scale - y + 'px';
        cropRealImageEle.style.top = top;
        cropFakeInnerEle.style.top = top;
      }

      if (target.indexOf('w') >= 0) {
        newWidth = Math.max(width * scale - x, MIN_CROP_DISTANCE * scale);
        cropOuterEle.style.width = newWidth + 'px';
        var left = -l * scale - x + 'px';
        cropRealImageEle.style.left = left;
        cropFakeInnerEle.style.left = left;
      }

      var oldRotateObj = calcRotationObj(width * scale, height * scale, rotation);
      var newRotateObj = calcRotationObj(newWidth, newHeight, rotation);
      var translateX = oldRotateObj.translateX;
      var translateY = oldRotateObj.translateY; // 修正旋转后缩放的左上角顶点对齐

      if (target === 's' || target === 'e' || target === 'se') {
        var tlXOld = oldRotateObj.tlX;
        var tlYOld = oldRotateObj.tlY;
        var tlXNew = newRotateObj.tlX;
        var tlYNew = newRotateObj.tlY;
        translateX = translateX - (tlXNew + newWidth / 2 - tlXOld - width * scale / 2);
        translateY = translateY - (tlYNew + newHeight / 2 - tlYOld - height * scale / 2);
      } // 修正旋转后缩放的右下角顶点对齐


      if (target === 'n' || target === 'w' || target === 'nw') {
        var _tlXOld = -oldRotateObj.tlX;

        var _tlYOld = -oldRotateObj.tlY;

        var _tlXNew = -newRotateObj.tlX;

        var _tlYNew = -newRotateObj.tlY;

        translateX = translateX - (_tlXNew + newWidth / 2 - _tlXOld - width * scale / 2);
        translateY = translateY - (_tlYNew + newHeight / 2 - _tlYOld - height * scale / 2);
      } // 修正旋转后缩放的右上角顶点对齐


      if (target === 'sw') {
        var trXOld = oldRotateObj.trX;
        var trYOld = oldRotateObj.trY;
        var trXNew = newRotateObj.trX;
        var trYNew = newRotateObj.trY;
        translateX = translateX - (trXNew + newWidth / 2 - trXOld - width * scale / 2);
        translateY = translateY - (trYNew + newHeight / 2 - trYOld - height * scale / 2);
      } // 修正旋转后缩放的左下角顶点对齐


      if (target === 'ne') {
        var _trXOld = -oldRotateObj.trX;

        var _trYOld = -oldRotateObj.trY;

        var _trXNew = -newRotateObj.trX;

        var _trYNew = -newRotateObj.trY;

        translateX = translateX - (_trXNew + newWidth / 2 - _trXOld - width * scale / 2);
        translateY = translateY - (_trYNew + newHeight / 2 - _trYOld - height * scale / 2);
      }

      cropOuterEle.style.transform = "translate(" + translateX + "px, " + translateY + "px) rotate(" + rotation + "deg)";
    };

    _this.finalizeCropFrame = function (x, y, target) {
      var _this$props2 = _this.props,
          handleCrop = _this$props2.handleCrop,
          scale = _this$props2.scale;
      var _this$state2 = _this.state,
          width = _this$state2.width,
          height = _this$state2.height;
      var _this$state3 = _this.state,
          l = _this$state3.l,
          t = _this$state3.t,
          r = _this$state3.r,
          b = _this$state3.b;
      var newWidth = width;
      var newHeight = height;
      x = Math.round(x / scale);
      y = Math.round(y / scale);

      _this.resetOuterPos();

      if (target.indexOf('n') >= 0) {
        newHeight = Math.max(height - y, MIN_CROP_DISTANCE);
        t = t + height - newHeight;
      }

      if (target.indexOf('w') >= 0) {
        newWidth = Math.max(width - x, MIN_CROP_DISTANCE);
        l = l + width - newWidth;
      }

      if (target.indexOf('s') >= 0) {
        newHeight = Math.max(height + y, MIN_CROP_DISTANCE);
        b = b + height - newHeight;
      }

      if (target.indexOf('e') >= 0) {
        newWidth = Math.max(width + x, MIN_CROP_DISTANCE);
        r = r + width - newWidth;
      }

      _this.setState({
        l: l,
        t: t,
        r: r,
        b: b,
        width: newWidth,
        height: newHeight
      });

      handleCrop(newWidth, newHeight, l, r, t, b);
    };

    _this.updateCropImage = function (x, y, target) {
      var scale = _this.props.scale;
      var _this$state4 = _this.state,
          l = _this$state4.l,
          t = _this$state4.t,
          r = _this$state4.r,
          b = _this$state4.b;
      var height = _this.state.height + t + b;
      var width = _this.state.width + l + r;
      var cropRealImageEle = _this.cropRealImage.current;
      var cropFakeImageEle = _this.cropFakeImage.current;
      var cropFakeInnerEle = _this.cropFakeInner.current;

      if (!cropRealImageEle || !cropFakeImageEle || !cropFakeInnerEle) {
        return;
      }

      if (target.indexOf('s') >= 0) {
        cropRealImageEle.style.height = Math.max(height * scale + y, MIN_CROP_DISTANCE * scale) + 'px';
        cropFakeImageEle.style.height = Math.max(height * scale + y, MIN_CROP_DISTANCE * scale) + 'px';
      }

      if (target.indexOf('e') >= 0) {
        cropRealImageEle.style.width = Math.max(width * scale + x, MIN_CROP_DISTANCE * scale) + 'px';
        cropFakeImageEle.style.width = Math.max(width * scale + x, MIN_CROP_DISTANCE * scale) + 'px';
      }

      if (target.indexOf('n') >= 0) {
        cropRealImageEle.style.height = Math.max(height * scale - y, MIN_CROP_DISTANCE * scale) + 'px';
        cropFakeImageEle.style.height = Math.max(height * scale - y, MIN_CROP_DISTANCE * scale) + 'px';
        cropRealImageEle.style.top = -t * scale + Math.min(y, (height - MIN_CROP_DISTANCE) * scale) + 'px';
        cropFakeInnerEle.style.top = -t * scale + Math.min(y, (height - MIN_CROP_DISTANCE) * scale) + 'px';
      }

      if (target.indexOf('w') >= 0) {
        cropRealImageEle.style.width = Math.max(width * scale - x, MIN_CROP_DISTANCE) + 'px';
        cropFakeImageEle.style.width = Math.max(width * scale - x, MIN_CROP_DISTANCE) + 'px';
        cropRealImageEle.style.left = -l * scale + Math.min(x, (width - MIN_CROP_DISTANCE) * scale) + 'px';
        cropFakeInnerEle.style.left = -l * scale + Math.min(x, (width - MIN_CROP_DISTANCE) * scale) + 'px';
      }
    };

    _this.finalizeCropImage = function (x, y, target) {
      var _this$state5 = _this.state,
          l = _this$state5.l,
          r = _this$state5.r,
          t = _this$state5.t,
          b = _this$state5.b;
      var _this$props3 = _this.props,
          handleCrop = _this$props3.handleCrop,
          scale = _this$props3.scale;
      var height = _this.state.height + t + b;
      var width = _this.state.width + l + r;
      x = Math.round(x / scale);
      y = Math.round(y / scale);

      _this.resetOuterPos();

      if (target.indexOf('s') >= 0) {
        b = b + Math.max(y, MIN_CROP_DISTANCE - height);
      }

      if (target.indexOf('e') >= 0) {
        r = r + Math.max(x, MIN_CROP_DISTANCE - width);
      }

      if (target.indexOf('n') >= 0) {
        t = t - Math.min(y, height - MIN_CROP_DISTANCE);
      }

      if (target.indexOf('w') >= 0) {
        l = l - Math.min(x, width - MIN_CROP_DISTANCE);
      }

      _this.setState({
        l: l,
        r: r,
        t: t,
        b: b
      });

      handleCrop(_this.state.width, _this.state.height, l, r, t, b);
    };

    _this.updateTranslateFrame = function (x, y) {
      var scale = _this.props.scale;
      var _this$state6 = _this.state,
          l = _this$state6.l,
          t = _this$state6.t;
      var cropRealImageEle = _this.cropRealImage.current;
      var cropFakeImageEle = _this.cropFakeImage.current;
      var cropFakeInnerEle = _this.cropFakeInner.current;

      if (!cropRealImageEle || !cropFakeImageEle || !cropFakeInnerEle) {
        return;
      }

      cropRealImageEle.style.left = -l * scale + x + 'px';
      cropFakeInnerEle.style.left = -l * scale + x + 'px';
      cropRealImageEle.style.top = -t * scale + y + 'px';
      cropFakeInnerEle.style.top = -t * scale + y + 'px';
    };

    _this.finalizeTranslateFrame = function (x, y) {
      var _this$props4 = _this.props,
          handleCrop = _this$props4.handleCrop,
          scale = _this$props4.scale;
      x = Math.round(x / scale);
      y = Math.round(y / scale);
      var _this$state7 = _this.state,
          width = _this$state7.width,
          height = _this$state7.height;

      _this.resetOuterPos();

      var _this$state8 = _this.state,
          l = _this$state8.l,
          t = _this$state8.t,
          r = _this$state8.r,
          b = _this$state8.b;
      l = l - x;
      t = t - y;
      r = r + x;
      b = b + y;

      _this.setState({
        l: l,
        t: t,
        r: r,
        b: b
      });

      handleCrop(width, height, l, r, t, b);
    };

    _this.onCropMove = function (relativeEvent) {
      var rotation = _this.props.rotation;
      _this.currentX = relativeEvent.relativeX;
      _this.currentY = relativeEvent.relativeY;
      var x = _this.currentX - _this.originX;
      var y = _this.currentY - _this.originY;
      var newX = x * Math.cos(-rotation / 180 * Math.PI) - y * Math.sin(-rotation / 180 * Math.PI);
      var newY = x * Math.sin(-rotation / 180 * Math.PI) + y * Math.cos(-rotation / 180 * Math.PI);

      if (_this.handleTarget && _this.handleTarget[0] === 'frameResize') {
        _this.updateCropFrame(newX, newY, _this.handleTarget[1]);
      } else if (_this.handleTarget && _this.handleTarget[0] === 'imageResize') {
        _this.updateCropImage(newX, newY, _this.handleTarget[1]);
      } else if (_this.handleTarget && _this.handleTarget[0] === 'frameTranslate') {
        _this.updateTranslateFrame(newX, newY);
      }
    };

    _this.handleMouseMove = function (e) {
      var getZoomContainer = _this.props.getZoomContainer;
      e.preventDefault();
      e.stopPropagation();
      var zoomContainer = getZoomContainer();
      var relativeEvent = getRelativeMouseEvent(e, zoomContainer);

      _this.onCropMove(relativeEvent);
    };

    _this.handleTouchMove = function (e) {
      var getZoomContainer = _this.props.getZoomContainer;
      e.preventDefault();
      e.stopPropagation();
      var zoomContainer = getZoomContainer();
      var targetTouches = e.targetTouches;
      var relativeEvent = getRelativeTouchEvent(targetTouches[0], zoomContainer);

      _this.onCropMove(relativeEvent);
    };

    _this.resetOuterPos = function () {
      var cropOuterEle = _this.cropOuter.current;

      if (!cropOuterEle) {
        return;
      }

      cropOuterEle.style.transform = _this.cropOuterTransform;
    };

    _this.onCropEnd = function () {
      var rotation = _this.props.rotation;

      if (_this.originX !== _this.currentX || _this.originY !== _this.currentY) {
        var x = _this.currentX - _this.originX;
        var y = _this.currentY - _this.originY;
        var newX = x * Math.cos(-rotation / 180 * Math.PI) - y * Math.sin(-rotation / 180 * Math.PI);
        var newY = x * Math.sin(-rotation / 180 * Math.PI) + y * Math.cos(-rotation / 180 * Math.PI);

        if (_this.handleTarget && _this.handleTarget[0] === 'frameResize') {
          _this.finalizeCropFrame(newX, newY, _this.handleTarget[1]);
        } else if (_this.handleTarget && _this.handleTarget[0] === 'imageResize') {
          _this.finalizeCropImage(newX, newY, _this.handleTarget[1]);
        } else if (_this.handleTarget && _this.handleTarget[0] === 'frameTranslate') {
          _this.finalizeTranslateFrame(newX, newY);
        }
      }

      _this.handleTarget = null;
      _this.originX = 0;
      _this.originY = 0;
      _this.currentX = 0;
      _this.currentY = 0;
    };

    _this.handleMouseUp = function (e) {
      e.preventDefault();
      e.stopPropagation();

      _this.onCropEnd();

      document.removeEventListener('mousemove', _this.handleMouseMove);
      document.removeEventListener('mouseup', _this.handleMouseUp);
    };

    _this.handleTouchEnd = function (e) {
      e.preventDefault();
      e.stopPropagation();
      var getZoomContainer = _this.props.getZoomContainer;
      var zoomContainer = getZoomContainer();

      _this.onCropEnd();

      zoomContainer.removeEventListener('touchmove', _this.handleTouchMove);
      zoomContainer.removeEventListener('touchend', _this.handleTouchEnd);
    };

    _this.handleExitCroppingMode = function (event) {
      event.preventDefault();
      event.stopPropagation();
      var onExitCroppingMode = _this.props.onExitCroppingMode;

      if (_this.cropOuter.current && !_this.cropOuter.current.contains(event.target)) {
        onExitCroppingMode();
      }
    };

    _this.exit = function (event) {
      event.preventDefault();
      event.stopPropagation();
      var onExitCroppingMode = _this.props.onExitCroppingMode;
      onExitCroppingMode();
    };

    _this.initialRectData = _this.props.getImgRectData();
    _this.originX = 0;
    _this.originY = 0;
    _this.currentX = 0;
    _this.currentY = 0;
    _this.state = {
      width: _this.initialRectData.width,
      height: _this.initialRectData.height,
      l: _this.initialRectData.l,
      r: _this.initialRectData.r,
      t: _this.initialRectData.t,
      b: _this.initialRectData.b
    };
    _this.handleTarget = null;
    _this.cropOuter = /*#__PURE__*/React.createRef();
    _this.cropRealImage = /*#__PURE__*/React.createRef();
    _this.cropFakeImage = /*#__PURE__*/React.createRef();
    _this.cropFakeInner = /*#__PURE__*/React.createRef();
    _this.cropOuterTransform = '';
    return _this;
  }

  var _proto = ImageCrop.prototype;

  _proto.componentWillUnmount = function componentWillUnmount() {
    document.removeEventListener('mousemove', this.handleMouseMove);
    document.removeEventListener('mouseup', this.handleMouseUp);
    document.removeEventListener('mousedown', this.handleExitCroppingMode);
    var getZoomContainer = this.props.getZoomContainer;
    var zoomContainer = getZoomContainer();

    if (zoomContainer) {
      zoomContainer.removeEventListener('touchmove', this.handleTouchMove);
      zoomContainer.removeEventListener('touchend', this.handleTouchEnd);
      document.removeEventListener('touchstart', this.handleExitCroppingMode);
    }
  };

  _proto.componentDidMount = function componentDidMount() {
    document.addEventListener('mousedown', this.handleExitCroppingMode);
    document.addEventListener('touchstart', this.handleExitCroppingMode);
  };

  _proto.render = function render() {
    var _this$props5 = this.props,
        attributes = _this$props5.attributes,
        src = _this$props5.src,
        rotation = _this$props5.rotation,
        scale = _this$props5.scale;
    var _this$state9 = this.state,
        width = _this$state9.width,
        height = _this$state9.height,
        l = _this$state9.l,
        r = _this$state9.r,
        t = _this$state9.t,
        b = _this$state9.b;
    var style = {
      width: width * scale,
      height: height * scale
    };
    var rotationObj = calcRotationObj(width, height, rotation);

    if (rotationObj) {
      style.transform = "translate(" + rotationObj.translateX * scale + "px, " + rotationObj.translateY * scale + "px) rotate(" + rotation + "deg)";
    }

    var rotateStyle = {
      width: rotationObj ? rotationObj.rWidth * scale : width * scale,
      height: rotationObj ? rotationObj.rHeight * scale : height * scale,
      left: this.initialRectData.left,
      top: this.initialRectData.top
    };
    return /*#__PURE__*/_createElement(CropImageRotate, {
      style: rotateStyle
    }, /*#__PURE__*/_createElement(CropOuter, {
      ref: this.cropOuter,
      onMouseDown: this.handleMouseDown,
      onTouchStart: this.handleTouchStart,
      style: style,
      onDoubleClick: this.exit,
      "data-role": PluginRoles.imageCropper
    }, /*#__PURE__*/_createElement(CropRealOuter, null, /*#__PURE__*/_createElement(CropRealImage, _extends({
      ref: this.cropRealImage,
      src: src,
      style: {
        left: -l * scale,
        top: -t * scale,
        width: (width + l + r) * scale,
        height: (height + t + b) * scale
      }
    }, attributes))), _ref, /*#__PURE__*/_createElement(CropFrame, null, /*#__PURE__*/_createElement(CropFakeInner, {
      ref: this.cropFakeInner,
      style: {
        left: -l * scale,
        top: -t * scale
      }
    }, /*#__PURE__*/_createElement(CropFakeImage, {
      ref: this.cropFakeImage,
      src: src,
      style: {
        width: (width + l + r) * scale,
        height: (height + t + b) * scale
      }
    })))));
  };

  return ImageCrop;
}(React.Component);

export default ImageCrop;
//# sourceMappingURL=imageCrop.js.map