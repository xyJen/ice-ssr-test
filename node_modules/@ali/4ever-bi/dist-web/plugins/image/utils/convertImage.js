import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";

var _Orientations;

export function isMobileSafari() {
  return /(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent);
}
export function isNativeSupport() {
  return isMobileSafari() || "imageOrientation" in document.createElement("image").style;
}
export var Orientations = (_Orientations = {}, _Orientations["1"] = 0, _Orientations["3"] = 180, _Orientations["6"] = 90, _Orientations["8"] = -90, _Orientations);
export function orientationToAngle(orientation) {
  return Orientations[String(orientation)] || 0;
}
export function getStringFromCharCode(dataView, start, length) {
  var str = "",
      i;

  for (i = start, length += start; i < length; i++) {
    str += String.fromCharCode(dataView.getUint8(i));
  }

  return str;
}
export function getOrientation(buffer) {
  if (isNativeSupport()) {
    return 1;
  }

  var dataView = new DataView(buffer);
  var length = dataView.byteLength;
  var orientation;
  var exifIDCode;
  var tiffOffset;
  var firstIFDOffset;
  var littleEndian;
  var endianness;
  var app1Start;
  var ifdStart;
  var offset;
  var i;

  try {
    // Only handle JPEG image (start by 0xFFD8)
    if (dataView.getUint8(0) === 0xff && dataView.getUint8(1) === 0xd8) {
      offset = 2;

      while (offset < length) {
        if (dataView.getUint8(offset) === 0xff && dataView.getUint8(offset + 1) === 0xe1) {
          app1Start = offset;
          break;
        }

        offset++;
      }
    }

    if (app1Start) {
      exifIDCode = app1Start + 4;
      tiffOffset = app1Start + 10;

      if (getStringFromCharCode(dataView, exifIDCode, 4) === "Exif") {
        endianness = dataView.getUint16(tiffOffset);
        littleEndian = endianness === 0x4949;

        if (littleEndian || endianness === 0x4d4d
        /* bigEndian */
        ) {
            if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002a) {
              firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);

              if (firstIFDOffset >= 0x00000008) {
                ifdStart = tiffOffset + firstIFDOffset;
              }
            }
          }
      }
    }

    if (ifdStart) {
      length = dataView.getUint16(ifdStart, littleEndian);

      for (i = 0; i < length; i++) {
        offset = ifdStart + i * 12 + 2;

        if (dataView.getUint16(offset, littleEndian) === 0x0112
        /* Orientation */
        ) {
            // 8 is the offset of the current tag's value
            offset += 8; // Get the original orientation value

            orientation = dataView.getUint16(offset, littleEndian);
            break;
          }
      }
    }

    return orientation;
  } catch (e) {
    return 1;
  }
}
export function loadBuffer(_x) {
  return _loadBuffer.apply(this, arguments);
}

function _loadBuffer() {
  _loadBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(url) {
    var res;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return fetch(url, {
              credentials: "same-origin",
              mode: "cors",
              redirect: "follow"
            });

          case 2:
            res = _context.sent;
            return _context.abrupt("return", res.arrayBuffer());

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadBuffer.apply(this, arguments);
}

export function loadImage(url) {
  return new Promise(function (resolve, reject) {
    var image = new Image();
    image.addEventListener("load", function () {
      return resolve(image);
    });
    image.addEventListener("error", function (err) {
      return reject(err);
    });
    image.style.imageOrientation = "from-image";
    image.src = url;
  });
}
export function canvasToBlob(canvas) {
  return new Promise(function (resolve) {
    canvas.toBlob(function (blob) {
      return resolve(blob);
    });
  });
}
export function createObjectURL(blob) {
  if (blob instanceof ArrayBuffer) {
    blob = new Blob([blob], {
      type: "image/jpeg"
    });
  }

  return URL.createObjectURL(blob);
}
export function rotateImage(_x2, _x3) {
  return _rotateImage.apply(this, arguments);
}

function _rotateImage() {
  _rotateImage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(imageFile, angle) {
    var localURL, image, isRightRngle, oldWidth, oldHeight, _window$screen, maxWidth, maxHeight, ratioX, ratioY, ratio, width, height, canvas, ctx, blob;

    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(!angle || angle === 0)) {
              _context2.next = 2;
              break;
            }

            return _context2.abrupt("return", imageFile);

          case 2:
            localURL = createObjectURL(imageFile);
            _context2.next = 5;
            return loadImage(localURL);

          case 5:
            image = _context2.sent;
            isRightRngle = Math.abs(angle) === 90;
            oldWidth = image.width, oldHeight = image.height;
            _window$screen = window.screen, maxWidth = _window$screen.width, maxHeight = _window$screen.height;
            ratioX = oldWidth > maxWidth ? maxWidth / oldWidth : 1;
            ratioY = oldHeight > maxHeight ? maxHeight / oldHeight : 1;
            ratio = Math.min(ratioX, ratioY);
            width = (isRightRngle ? oldHeight : oldWidth) * ratio;
            height = (isRightRngle ? oldWidth : oldHeight) * ratio;
            canvas = document.createElement('canvas');
            ctx = canvas.getContext('2d');
            canvas.width = width;
            canvas.height = height;
            ctx.translate(width / 2, height / 2);
            ctx.rotate(angle * Math.PI / 180);

            if (isRightRngle) {
              ctx.drawImage(image, -height / 2, -width / 2, height, width);
            } else {
              ctx.drawImage(image, -width / 2, -height / 2, width, height);
            }

            _context2.next = 23;
            return canvasToBlob(canvas);

          case 23:
            blob = _context2.sent;
            URL.revokeObjectURL(localURL);
            return _context2.abrupt("return", new File([blob], imageFile.name, {
              type: 'image/jpeg'
            }));

          case 26:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _rotateImage.apply(this, arguments);
}
//# sourceMappingURL=convertImage.js.map