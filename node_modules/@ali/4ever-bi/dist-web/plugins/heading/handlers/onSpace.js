import { Commands, Inline } from '@ali/4ever-cangjie';
import shortcutTypes from "../utils/shortcutTypes";
import { setHeading as setHeadingAction } from "../actions";
export default function onSpace(event, controller, next) {
  var value = controller.value;
  var startBlock = value.startBlock,
      selection = value.selection,
      document = value.document;
  if (!selection || !startBlock || selection.isExpanded) return next();

  var _selection$convertToT = selection.convertToTextPoints(document),
      start = _selection$convertToT.start,
      anchor = _selection$convertToT.anchor;

  var texts = startBlock.text.slice(0, start.offset);
  var chars = texts.replace(/\s*/g, '');
  var type = shortcutTypes[chars] || null;
  if (!type) return next(); // 在当前node之前有行内元素时不变heading（例如：@人 + # + 空格）

  var currentNode = startBlock.getNode(anchor.key);
  if (!currentNode) return next();
  var foundInlineNode = false;
  /**
   * 极端场景：段落的开头是 1000 个行内元素
   * 使用 getPreviousSibling 相比 for 循环性能差 3 倍左右
   */

  var index = startBlock.nodes.indexOf(currentNode);

  for (var i = index - 1; i >= 0; i--) {
    var node = startBlock.nodes[i];
    foundInlineNode = foundInlineNode || Inline.isInline(node);
    if (foundInlineNode) break;
  }

  if (foundInlineNode) return next();
  event.preventDefault();
  controller.command(Commands.moveFocusToStartOfNode, startBlock).command(Commands.del);
  controller.run('onAction', setHeadingAction(type));
  return controller.dispatch('createTriggerMarkdownAction', {
    mdType: type
  });
}
//# sourceMappingURL=onSpace.js.map