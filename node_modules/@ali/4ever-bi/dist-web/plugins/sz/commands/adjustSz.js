function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import { Commands, Mark } from '@ali/4ever-cangjie';
import { getRangesFromEditor } from '@ali/4ever-utils';
import { getDefaultSz } from "../utils";
import { findNextSz } from '@ali/4ever-plugin-sz';
import getSize from "../queries/getSize";
import { setSz } from "../actions";

var isLeafInSelection = function isLeafInSelection(leaf, leafOffset, selectionOffset, selectionLength) {
  var leafLength = leaf.text.length;
  if (leafOffset + leafLength <= selectionOffset) return false;
  if (leafOffset >= selectionOffset + selectionLength) return false;
  return true;
};

var isInInlineNode = function isInInlineNode(document, key) {
  return document.getClosestInline(key);
};
/**
 * @param controller
 * @param isIncreasingSz
 * @description
 * 若选区重合，直接通过getSize方法获取当前的字体大小，再通过findNextSz方法获取增减后的字体大小，最后设置字体；
 * 若选区非重合，遍历selection中的每一个叶子节点，通过sz mark获取当前叶子节点的字体大小，
 * 若没有sz mark 则根据段落类型获取默认的字体大小，通过findNextSz方法获取每个叶子节点增减后的字体大小，
 * 移除旧的 sz mark 后增加新的 sz；
 */


export default function adjustSz(controller, isIncreasingSz) {
  var value = controller.value;
  var document = value.document,
      selection = value.selection;
  var isCollapsed = selection.isCollapsed;
  var direction = isIncreasingSz ? 'right' : 'left';

  if (isCollapsed) {
    var sz = getSize(controller);
    controller.run('onAction', setSz(findNextSz(sz, direction)));
    return controller;
  } else {
    var ranges = getRangesFromEditor(controller);

    if (!ranges[0]) {
      return controller;
    }

    var _loop = function _loop() {
      var range = _step.value;

      var _range$convertToTextP = range.convertToTextPoints(document),
          start = _range$convertToTextP.start,
          end = _range$convertToTextP.end;

      var texts = document.getTextsAtRange(range);
      controller.withoutNormalizing(function () {
        texts.forEach(function (node) {
          var key = node.key;
          var offset = 0;
          var length = node.text.length;

          if (key === start.key) {
            offset = start.offset;
          }

          if (key === end.key) length = end.offset;

          if (key === start.key && key === end.key) {
            length = end.offset - start.offset;
          }

          var leaves = node.leaves;
          var subOffset = offset;
          var accOffset = 0;

          for (var _iterator2 = _createForOfIteratorHelperLoose(leaves), _step2; !(_step2 = _iterator2()).done;) {
            var leaf = _step2.value;

            if (isLeafInSelection(leaf, accOffset, offset, length) || isInInlineNode(document, key)) {
              var subLength = accOffset + leaf.text.length > length ? end.offset - subOffset : leaf.text.length;
              var szMarks = leaf.marks.filter(function (mark) {
                return mark.type === 'sz';
              });
              var szMarksLength = szMarks.length;

              if (szMarksLength > 0) {
                var _sz = szMarks[szMarksLength - 1].data.value;
                var newSzMark = Mark.create({
                  type: 'sz',
                  data: {
                    value: findNextSz(_sz, direction),
                    szUnit: 'pt'
                  }
                });

                for (var _iterator3 = _createForOfIteratorHelperLoose(szMarks), _step3; !(_step3 = _iterator3()).done;) {
                  var szMark = _step3.value;
                  controller.command(Commands.removeMarkByKey, node.key, subOffset, subLength, szMark);
                }

                controller.command(Commands.addMarkByKey, node.key, subOffset, subLength, newSzMark);
              } else {
                var _sz2 = getDefaultSz(document, key);

                var _newSzMark = Mark.create({
                  type: 'sz',
                  data: {
                    value: findNextSz(_sz2, direction),
                    szUnit: 'pt'
                  }
                });

                controller.command(Commands.addMarkByKey, node.key, subOffset, subLength, _newSzMark);
              }
            }

            accOffset += leaf.text.length;
            subOffset = Math.max(offset, accOffset);
          }
        });
      });
    };

    for (var _iterator = _createForOfIteratorHelperLoose(ranges), _step; !(_step = _iterator()).done;) {
      _loop();
    }
  }

  return controller;
}
//# sourceMappingURL=adjustSz.js.map