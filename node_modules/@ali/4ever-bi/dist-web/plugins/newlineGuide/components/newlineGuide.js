import React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import ReactDOM from 'react-dom';
import { useZoomContainer, domUtils, constants } from '@ali/4ever-cangjie';
import { useScrollableContent, PcContextMenu } from '@ali/4ever-bamboo';
import { ActiveInteractionHooks } from '@ali/4ever-component';
import { Dropdown } from '@ali/we-design';
import logger from '@ali/4ever-logger';
import { DropdownAnimation } from '@ali/we-util';
import { NewlineGuideData } from "../model/newlineGuide";
import { GuideWrapper } from "./styled";
import GuideMenu from "./guideMenu";
import { removeNewlineData, setNewlineData } from "../actions";
;
import getStartBlock from "../utils/getStartBlock";
var closeContextMenu = PcContextMenu.closeContextMenu;
var MAX_ERROR_NUM = 1;
var useActiveInteraction = ActiveInteractionHooks.useActiveInteraction;

var NewlineGuide = function NewlineGuide(props) {
  var uiVisible = React.useRef(false);

  var _React$useState = React.useState({
    top: -9999,
    left: -9999
  }),
      guideStyle = _React$useState[0],
      setGuideStyle = _React$useState[1];

  var _React$useState2 = React.useState({
    width: 2,
    height: 0
  }),
      triggerStyle = _React$useState2[0],
      setTriggerStyle = _React$useState2[1];

  var controller = props.controller,
      renderGuideMenu = props.renderGuideMenu,
      locale = props.locale,
      _props$zoom = props.zoom,
      zoom = _props$zoom === void 0 ? 1 : _props$zoom,
      enableKeyboard = props.enableKeyboard,
      onClickGuideMenu = props.onClickGuideMenu,
      withoutEmptyParagraphWhitelist = props.withoutEmptyParagraphWhitelist;
  var _controller$value = controller.value,
      document = _controller$value.document,
      injections = _controller$value.injections,
      selection = _controller$value.selection,
      isFocused = _controller$value.isFocused; // 失焦或选中内容不显示

  var enabled = React.useMemo(function () {
    return isFocused && selection.isCollapsed;
  }, [isFocused, selection]);
  var startBlock = getStartBlock(controller);

  var _ref = NewlineGuideData.get(controller) || {},
      triggered = _ref.triggered,
      key = _ref.key,
      query = _ref.query; // 这里只能从 renderController 中拿到 viewKey
  // 通过 onCangjieInput hook 拿到的是 dataKey，且无法通过 action 劫持转换
  // 通过 点击 触发给到的 key 是这里转换后的后的 dataKey
  // 因此我们确保：NewlineGuideData.key 一定是 dataKey，而 viewKey 转换 dataKey 方法是相对固定的


  var _split = ((startBlock == null ? void 0 : startBlock.key) || '').split('-'),
      blockKey = _split[0];

  var isInTable = controller.query('isNodeInTable', startBlock); // 当且仅当 focused 在 当前行时 展示面板

  var showMenu = triggered && key === blockKey;
  var container = useZoomContainer() || window.document.body;
  var menuContainer = useScrollableContent() || window.document.body;
  var errorNumRef = React.useRef(0);

  var handleVisibleChange = function handleVisibleChange(value) {
    if (!value && showMenu) {
      uiVisible.current = false;
      controller.run('onAction', removeNewlineData());
    }
  };

  var getMenuContainer = function getMenuContainer() {
    return menuContainer;
  };

  React.useEffect(function () {
    if (!enabled && triggered) {
      // 失焦、有选区存在时 removeNewlineData
      controller.run('onAction', removeNewlineData());
    }
  }, [controller, enabled, triggered]);
  React.useEffect(function () {
    if (!enabled) {
      return;
    } // 支持光标 pending 后，需要保证最新的光标渲染完以后再计算位置，否则可能位置不正确


    if (blockKey && (isInTable || showMenu)) {
      // 根据目标位置计算光标 Rect
      // Tips: 不能依赖光标 dom 节点的位置，在 Safari 下的 useEffect、setTimeout 时序会不稳定，导致读取的位置有误
      var caret = domUtils.findDOMRange(controller.value.selection, controller, container);
      var caretRect = caret == null ? void 0 : caret.getClientRects()[0]; // 根据块级元素和光标的位置计算控件位置，以便在任何字号、行高下都对齐光标中间

      if (caret && caretRect) {
        var _container$querySelec;

        var caretTop = caretRect.top,
            caretHeight = caretRect.height,
            caretLeft = caretRect.left;

        var _container$getBoundin = container.getBoundingClientRect(),
            containerTop = _container$getBoundin.top,
            containerLeft = _container$getBoundin.left;

        var guideLeft = (caretLeft - containerLeft) / zoom;
        setGuideStyle({
          // 光标中间 - 段落顶部 = 控件相对段落的 top
          top: (caretTop + caretHeight / 2 - containerTop) / zoom,
          left: guideLeft
        });
        setTriggerStyle({
          width: 2,
          height: caretHeight
        }); // 这里需要获取container的padding值，然后计算出插入按钮应该在的位置
        // PS 这里应该是获取 container 下 [data-cangjie-editable] 元素的 parent 的 padding
        // 非排版模式下，这个 parent 就是 container，而在排版模式下，这个 container 与 [data-cangjie-editable] 之间有个夹层

        var editorContainerParent = container == null ? void 0 : (_container$querySelec = container.querySelector("[" + constants.Selector.editable + "]")) == null ? void 0 : _container$querySelec.parentElement;
        var padding = 0;

        if (editorContainerParent) {
          padding = Number.parseInt(window.getComputedStyle(editorContainerParent).paddingLeft, 10);
        }
      }
    } // document.nodes、injections 需要作为依赖以便兼容某些 node 导致高度变化的情况（例如插入本地文件上传完成后自动变为预览模式）

  }, [enabled, isInTable, showMenu, blockKey, container, zoom, document.nodes, injections, query]);
  var closeContext = React.useCallback(function () {
    controller.run('onAction', closeContextMenu());
  }, [controller]);
  var onQuery = React.useCallback(function (results) {
    if (!query || !results || results.length > 0) {
      controller.run('onAction', setNewlineData({
        showMenu: true
      }));
      errorNumRef.current = 0;
      return;
    }

    controller.run('onAction', setNewlineData({
      showMenu: false
    }));

    if (errorNumRef.current > MAX_ERROR_NUM) {
      controller.run('onAction', removeNewlineData());
      errorNumRef.current = 0;
    } else {
      errorNumRef.current += 1;
    }
  }, [query, controller]);
  var guideMenu = React.useMemo(function () {
    if (!enabled || !showMenu || !renderGuideMenu) return null; // 埋点：区分点击和+

    logger.sum("newline_insert_show_by_" + (uiVisible.current ? 'click' : '+')); // 右键菜单栏和插入工具栏需要互斥展示

    closeContext();
    return /*#__PURE__*/_createElement(GuideMenu, {
      withoutEmptyParagraphWhitelist: withoutEmptyParagraphWhitelist,
      query: query,
      controller: controller,
      enableKeyboard: enableKeyboard,
      onClickGuideMenu: onClickGuideMenu
    }, renderGuideMenu(query, onQuery));
  }, [enabled, showMenu, renderGuideMenu, controller, enableKeyboard, onClickGuideMenu, query, closeContext, onQuery, withoutEmptyParagraphWhitelist]);

  var _useActiveInteraction = useActiveInteraction(),
      activeType = _useActiveInteraction[0],
      setActiveType = _useActiveInteraction[1];

  var activeRef = React.useRef('');
  activeRef.current = activeType;
  React.useEffect(function () {
    if (showMenu) {
      setActiveType('insertMenu');
    } else if (activeRef.current === 'insertMenu') {
      setActiveType('');
    }
  }, [showMenu, setActiveType]);

  if (!enabled) {
    return null;
  } // dropdown 组件placement向上位置计算存在问题


  return /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/_createElement(GuideWrapper, {
    style: guideStyle
  }, showMenu ? /*#__PURE__*/_createElement(Dropdown, {
    overlay: /*#__PURE__*/_createElement(DropdownAnimation, {
      visible: showMenu
    }, guideMenu),
    visible: showMenu,
    getContainer: getMenuContainer,
    onVisibleChange: handleVisibleChange,
    placement: "bottomLeft",
    overlayAutoAlign: true
  }, /*#__PURE__*/_createElement("i", {
    style: triggerStyle
  })) : null), container);
};

export default NewlineGuide;
//# sourceMappingURL=newlineGuide.js.map