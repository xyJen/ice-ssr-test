import _extends from "@babel/runtime/helpers/extends";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import * as React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import { isFirstPart, LinkPlugin } from '@ali/4ever-bamboo';
import { ToolbarLinkNormal } from '@ali/we-design';
import { Link, LinkCardWrapper, PlaceholerLinkWrapper } from "./styled";
import { saveLinkCard, updateLink, cutLink, removeLink, updateLinkWithCardInfo, switchDisplayType, switchLink2Card, injectCardInfo, removeInjectCardInfo, copyLink, unwrapLinkCard } from "../actions";
import LinkPortal from "./linkPortal/linkPortal";
import LinkCardPortal from "./card/LinkCardPortal";
import { getCardInfo, getLinkCardState } from "../utils";
import { convertTextLinkToBlockLinkCard } from "../linkCard/actions";
import { InlinePlaceholder } from '@ali/we-toolbar';
var normalizeLink = LinkPlugin.normalizeLink,
    openLink = LinkPlugin.openLink;

var _ref4 = /*#__PURE__*/_createElement(ToolbarLinkNormal, {
  className: "link-placeholder-icon"
});

var TextLink = function TextLink(props) {
  var _getCardInfo;

  var controller = props.controller,
      node = props.node,
      locale = props.locale,
      attributes = props.attributes,
      children = props.children,
      protocolAllowList = props.protocolAllowList,
      onCopyLink = props.onCopyLink,
      getLinkInfo = props.getLinkInfo,
      isSelected = props.isSelected,
      defaultDisplayType = props.displayType,
      enableCard = props.enableCard,
      draggable = props.draggable,
      openLinkOfConfig = props.openLink,
      enableLinkCardBlock = props.enableLinkCardBlock,
      mountRoot = props.mountRoot;
  var _controller$value = controller.value,
      selection = _controller$value.selection,
      document = _controller$value.document;
  var _node$data = node.data,
      _node$data$href = _node$data.href,
      href = _node$data$href === void 0 ? '' : _node$data$href,
      cardInfo = _node$data.cardInfo;

  var _ref = cardInfo || {},
      cardTitle = _ref.title,
      cardImgURL = _ref.imgURL,
      cardDesc = _ref.desc;

  var text = controller.query('getText', {
    node: node
  }) || '';
  var handleRemove = React.useCallback(function () {
    controller.run('onAction', removeLink(node));
  }, [controller, node]);
  var handleCut = React.useCallback(function () {
    controller.run('onAction', cutLink(node));
  }, [controller, node]);
  var handleSave = React.useCallback( /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(newText, newHref, displayType) {
      var fixedHref, fixedText;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              // 编辑框允许 href 或 text 为空字符串，转为卡片时需要保证都不为空
              fixedHref = newHref.length > 0 ? newHref : newText;
              fixedText = newText.length > 0 ? newText : newHref; // 如果保存为卡片形式形式，

              if (displayType === 'card' && getLinkInfo && typeof getLinkInfo === 'function') {
                // 保存为卡片
                if (enableLinkCardBlock) {
                  // 保存为 block linkCard
                  controller.run('onAction', convertTextLinkToBlockLinkCard(node, fixedText, fixedHref));
                } else {
                  // 保存为 inline linkCard
                  controller.run('onAction', saveLinkCard(node, fixedText, fixedHref));
                }
              } else if (defaultDisplayType === 'card') {
                controller.run('onAction', updateLinkWithCardInfo(node, fixedText, fixedHref, {
                  displayType: 'link'
                }));
              } else {
                controller.run('onAction', updateLink(node, newText, newHref));
              }

              controller.run('onCangjieFocus');

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x, _x2, _x3) {
      return _ref2.apply(this, arguments);
    };
  }(), [controller, node, defaultDisplayType, getLinkInfo, enableLinkCardBlock]);
  var handleRefresh = React.useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
    var info, imgURL, title, desc, newInfo;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(getLinkInfo && typeof getLinkInfo === 'function')) {
              _context2.next = 19;
              break;
            }

            // 先设置卡片状态为 loading，刷新无需为节点注入信息
            controller.run('onAction', injectCardInfo(node, {
              displayType: 'card'
            }));
            _context2.prev = 2;
            _context2.next = 5;
            return getLinkInfo(href);

          case 5:
            info = _context2.sent;

            if (!info) {
              _context2.next = 13;
              break;
            }

            // 请求成功
            imgURL = info.imgURL, title = info.title, desc = info.desc;
            newInfo = {
              imgURL: imgURL,
              title: title,
              desc: desc,
              displayType: 'card'
            };
            controller.run('onAction', removeInjectCardInfo(node));
            controller.run('onAction', updateLinkWithCardInfo(node, text, href, newInfo));
            controller.run('onCangjieFocus'); // 清理临时状态

            return _context2.abrupt("return");

          case 13:
            _context2.next = 17;
            break;

          case 15:
            _context2.prev = 15;
            _context2.t0 = _context2["catch"](2);

          case 17:
            // 请求失败,将状态设置为 error，数据填充 undefined
            controller.run('onAction', removeInjectCardInfo(node));
            controller.run('onAction', updateLinkWithCardInfo(node, text, href, {
              displayType: 'card'
            }));

          case 19:
            controller.run('onCangjieFocus');

          case 20:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[2, 15]]);
  })), [controller, getLinkInfo, text, href, node]);
  var handleToolbarSwitchStyle = React.useCallback(function (newHref, displayType, title, desc, imgURL) {
    // 当 displayType 为 link 时，没有发生 url 转卡片，不保存 CardInfo
    if (displayType === 'link') {
      controller.run('onAction', switchDisplayType(node, displayType));
    } else {
      var newInfo = {
        imgURL: imgURL,
        title: title,
        desc: desc,
        displayType: displayType
      };

      if (enableLinkCardBlock) {
        // 保存为 block linkCard
        controller.run('onAction', convertTextLinkToBlockLinkCard(node, text, newHref, newInfo));
      } else {
        // 保存为 inline linkCard
        controller.run('onAction', switchLink2Card(node, text, newHref, newInfo));
      }
    }
  }, [controller, node, text, enableLinkCardBlock]);
  var handleUnlink = React.useCallback(function () {
    var isPlaceholder = text === locale.addLinkPlaceholder && href === '';

    if (isPlaceholder) {
      // 在占位符进行取消链接时，直接执行删除，来自：https://work.aone.alibaba-inc.com/issue/34949369
      controller.run('onAction', removeLink(node));
    } else {
      controller.run('onAction', unwrapLinkCard(node));
    }
  }, [controller, node, text]);
  var handleVisit = React.useCallback(function () {
    var isCollapsed = controller.value.selection.isCollapsed;
    if (!isCollapsed) return;

    if (openLinkOfConfig) {
      var normalizedLink = normalizeLink(href, protocolAllowList);
      openLinkOfConfig(normalizedLink);
    } else {
      openLink(href, protocolAllowList);
    }
  }, [href, protocolAllowList, openLinkOfConfig]);
  var handleCopy = React.useCallback(function () {
    // 卡片形式下，使用仓颉复制
    controller.run('onAction', copyLink(node));

    if (onCopyLink && typeof onCopyLink === 'function') {
      onCopyLink(href);
    }
  }, [href, onCopyLink, node, controller]);
  var isLinkFocused = React.useMemo(function () {
    return controller.value.isFocused && isSelected && selection && selection.isCollapsed;
  }, [controller.value.isFocused, isSelected, selection]); // 当节点的文本为占位符文本时，显示占位符样式；其余情况显示默认链接样式

  var showPlaceholder = text === locale.addLinkPlaceholder && href === '';

  var link = /*#__PURE__*/_createElement(Link, _extends({}, attributes, {
    "data-type": "link",
    "data-testid": "link",
    className: "link"
  }), children());

  var _React$useMemo = React.useMemo(function () {
    return controller.query('getLinkMaxSz', {
      node: node
    });
  }, [node, controller]),
      maxSz = _React$useMemo.fontSize;

  var firstPart = isFirstPart(node);

  var placeholdLink = /*#__PURE__*/_createElement(PlaceholerLinkWrapper, _extends({}, attributes, {
    "data-type": "link",
    "data-testid": "link"
  }), /*#__PURE__*/_createElement(InlinePlaceholder, {
    icon: firstPart ? _ref4 : null,
    type: "normal",
    isSelected: isLinkFocused,
    style: {
      fontSize: maxSz
    }
  }, children()));

  var injections = controller.value.injections;
  var showCard = ((_getCardInfo = getCardInfo(node, injections)) == null ? void 0 : _getCardInfo.displayType) === 'card';
  var cardState = getLinkCardState(false, node, injections);
  var isTitleEqualsHref = text.trim() === href.trim();
  var cardText = isTitleEqualsHref ? '' : text;
  var actualTitle = isTitleEqualsHref ? cardTitle : text;
  return showCard || defaultDisplayType === 'card' ? /*#__PURE__*/_createElement(LinkCardWrapper, null, /*#__PURE__*/_createElement(LinkCardPortal, _extends({}, props, {
    controller: controller,
    locale: locale,
    onSave: handleSave,
    onRemove: handleRemove,
    onCut: handleCut,
    onUnlink: handleUnlink,
    href: href,
    text: cardText,
    title: actualTitle,
    state: cardState,
    displayType: defaultDisplayType,
    isSelected: isSelected,
    readonly: false,
    isMobile: false,
    imgURL: cardImgURL,
    desc: cardDesc,
    onOpenLink: handleVisit,
    onRefresh: handleRefresh,
    onCopyLink: handleCopy,
    node: node,
    attributes: attributes,
    draggable: draggable,
    enableCard: enableCard
  }))) : /*#__PURE__*/_createElement(LinkPortal, {
    controller: controller,
    node: node,
    href: href,
    text: cardText,
    locale: locale,
    onSave: handleSave,
    onCut: handleCut,
    onRemove: handleRemove,
    onUnlink: handleUnlink,
    onOpenlink: handleVisit,
    onCopyLink: handleCopy,
    getLinkInfo: getLinkInfo,
    isLinkFocused: isLinkFocused,
    onToolbarSwitchStyle: handleToolbarSwitchStyle,
    enableCard: enableCard,
    mountRoot: mountRoot
  }, showPlaceholder ? placeholdLink : link);
};

export default TextLink;
//# sourceMappingURL=textLink.js.map