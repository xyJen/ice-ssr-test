import _extends from "@babel/runtime/helpers/extends";
import * as React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import { copyToClipboard, LinkPlugin } from '@ali/4ever-bamboo';
import { Link, LinkCardWrapper } from "./styled";
import { removePureLink, updatePureLink, unwrapPureLink, updatePureLinkWithCardInfo, cutPureLink } from "../actions";
import LinkPortal from "./linkPortal/linkPortal";
import { getCardInfo } from "../utils";
import { LinkCard } from "./card/LinkCard";
import { convertPureLinkToBlockLinkCard } from "../linkCard/actions";
var normalizeLink = LinkPlugin.normalizeLink,
    openLink = LinkPlugin.openLink;

var isSelectionInPureLink = function isSelectionInPureLink(node, selection, startOffset, endOffset) {
  var anchor = selection.anchor;

  if (node.key === anchor.key && selection.isCollapsed && anchor.isTextPoint()) {
    return anchor.offset >= startOffset && anchor.offset <= endOffset;
  }

  return false;
};

var PureLink = function PureLink(props) {
  var _getCardInfo;

  var children = props.children,
      attributes = props.attributes,
      controller = props.controller,
      node = props.node,
      locale = props.locale,
      protocolAllowList = props.protocolAllowList,
      onCopyLink = props.onCopyLink,
      offset = props.offset,
      text = props.text,
      mark = props.mark,
      getLinkInfo = props.getLinkInfo,
      enableCard = props.enableCard,
      openLinkOfConfig = props.openLink,
      enableLinkCardBlock = props.enableLinkCardBlock,
      mountRoot = props.mountRoot;
  var href = mark.data.href || text;
  var offsetInNode = mark.data.offsetInNode || offset;
  var selection = controller.value.selection; // 这里需要使用 text 而不是 href 的 length，
  // 因为在 pi 中，一旦链接换行，text 会拆分为两个不同的 leaf，导致光标定位异常

  var isLinkFocus = React.useMemo(function () {
    return isSelectionInPureLink(node, selection, offset, offset + text.length);
  }, [node, selection, offset, text]);
  var handleRemove = React.useCallback(function () {
    controller.run('onAction', removePureLink(node, offsetInNode, href));
  }, [node, offsetInNode, href, controller]);
  var handleSave = React.useCallback(function (t, h, displayType) {
    // 如果保存为卡片形式形式，
    if (displayType === 'card' && getLinkInfo && typeof getLinkInfo === 'function') {
      // 编辑框允许 href 或 text 为空字符串，转为卡片时需要保证都不为空
      var fixedHref = h.length > 0 ? h : t;
      var fixedText = t.length > 0 ? t : h; // 请求前先填充 undefined 信息，确保数据层识别为卡片，解决 loading 时排版问题
      // todo 排版 2.0 后删除下面代码

      if (enableLinkCardBlock) {
        controller.run('onAction', convertPureLinkToBlockLinkCard(node, offsetInNode, fixedText, fixedHref, href, {
          displayType: displayType
        }, true));
      } else {
        controller.run('onAction', updatePureLinkWithCardInfo(node, offsetInNode, fixedText, fixedHref, href, {
          displayType: displayType
        }, true));
      }
    } else {
      controller.run('onAction', updatePureLink(node, offsetInNode, t, h, href));
    }

    controller.run('onCangjieFocus');
  }, [node, offsetInNode, href, controller, getLinkInfo, enableLinkCardBlock]);
  var onToolbarSwitchStyle = React.useCallback(function (newHref, displayType, title, desc, imgURL) {
    // 当 displayType 为 link 时，没有发生 url 转卡片，不保存 CardInfo
    if (displayType === 'card') {
      var cardInfo = {
        imgURL: imgURL,
        title: title,
        desc: desc,
        displayType: displayType
      };

      if (enableLinkCardBlock) {
        controller.run('onAction', convertPureLinkToBlockLinkCard(node, offsetInNode, text, newHref, newHref, cardInfo));
      } else {
        controller.run('onAction', updatePureLinkWithCardInfo(node, offsetInNode, text, newHref, newHref, cardInfo));
      }
    }
  }, [controller, href, node, offsetInNode, text, enableLinkCardBlock]);
  var handleUnlink = React.useCallback(function () {
    controller.run('onAction', unwrapPureLink(node, offsetInNode, href));
  }, [node, offsetInNode, href, controller]);
  var handleVisit = React.useCallback(function () {
    if (openLinkOfConfig) {
      var normalizedLink = normalizeLink(href, protocolAllowList);
      openLinkOfConfig(normalizedLink);
    } else {
      openLink(href, protocolAllowList);
    }
  }, [href, protocolAllowList, openLinkOfConfig]);
  var handleCopy = React.useCallback(function () {
    // 卡片形式下，使用仓颉复制
    copyToClipboard(href, onCopyLink);
  }, [href, onCopyLink]);
  var handleCut = React.useCallback(function () {
    controller.run('onAction', cutPureLink(node, offsetInNode, href));
  }, [node, offsetInNode, href, controller]);
  var injections = controller.value.injections;
  var showCard = ((_getCardInfo = getCardInfo(node, injections)) == null ? void 0 : _getCardInfo.displayType) === 'card';
  return /*#__PURE__*/_createElement(React.Fragment, null, enableCard && showCard ? /*#__PURE__*/_createElement(LinkCardWrapper, attributes, /*#__PURE__*/_createElement(LinkCard, {
    state: 'loading',
    href: href,
    displayType: 'card',
    controller: controller,
    readonly: false,
    isMobile: false,
    locale: locale
  })) : /*#__PURE__*/_createElement(LinkPortal, {
    controller: controller,
    locale: locale,
    text: "",
    href: href,
    onSave: handleSave,
    onRemove: handleRemove,
    onUnlink: handleUnlink,
    onCopyLink: handleCopy,
    onCut: handleCut,
    getLinkInfo: getLinkInfo,
    onToolbarSwitchStyle: onToolbarSwitchStyle,
    onOpenlink: handleVisit,
    enableCard: enableCard,
    isLinkFocused: isLinkFocus,
    mountRoot: mountRoot
  }, /*#__PURE__*/_createElement(Link, _extends({}, attributes, {
    "data-type": "link",
    "data-testid": "pure-link",
    className: "link"
  }), children())));
};

export default PureLink;
//# sourceMappingURL=pureLink.js.map