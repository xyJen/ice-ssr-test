import * as React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import LinkEditor from "../linkEditor";

// 用于记录上一次的props, 类似react lifecycle当中的preProps
function usePrevious(value) {
  var ref = React.useRef();
  React.useEffect(function () {
    ref.current = value;
  });
  return ref.current;
}

var useEditorPortal = function useEditorPortal(props) {
  var node = props.node,
      text = props.text,
      _props$href = props.href,
      href = _props$href === void 0 ? '' : _props$href,
      onSave = props.onSave,
      onRemove = props.onRemove,
      onUnlink = props.onUnlink,
      controller = props.controller,
      locale = props.locale,
      isLinkFocused = props.isLinkFocused,
      enableCard = props.enableCard,
      onEditorHide = props.onEditorHide,
      portalRef = props.portalRef,
      linkRef = props.linkRef,
      isEditMode = props.isEditMode,
      isPlaceholder = props.isPlaceholder;
  var nodeKey = node == null ? void 0 : node.key;
  var isFocused = controller.value.isFocused;
  var textInputRef = React.useRef();
  var hrefInputRef = React.useRef();
  var isEmptyHref = href.trim().length === 0;
  var preLinkFocused = usePrevious(isLinkFocused);
  React.useEffect(function () {
    // 占位符默认 focus 标题
    if (isEditMode && isPlaceholder) {
      var _textInputRef$current;

      (_textInputRef$current = textInputRef.current) == null ? void 0 : _textInputRef$current.focus();
    }
  }, [textInputRef, isPlaceholder, isEditMode]);
  React.useEffect(function () {
    // 外部点击触发编辑框显示时，应该 focus 到输入框
    if (isFocused && !preLinkFocused && !isLinkFocused) {
      if (isEmptyHref) {
        var _hrefInputRef$current;

        // 空连接默认 focus href
        (_hrefInputRef$current = hrefInputRef.current) == null ? void 0 : _hrefInputRef$current.focus();
      }
    }
  }, [hrefInputRef, isLinkFocused, isFocused, preLinkFocused]);
  var handleLinkMouseDown = React.useCallback(function (event) {
    if (isPlaceholder && isEditMode) {
      var _textInputRef$current2;

      event.stopPropagation();
      event.preventDefault();
      (_textInputRef$current2 = textInputRef.current) == null ? void 0 : _textInputRef$current2.focus();
    }

    if (isEmptyHref && isEditMode) {
      var _hrefInputRef$current2;

      event.stopPropagation();
      event.preventDefault();
      (_hrefInputRef$current2 = hrefInputRef.current) == null ? void 0 : _hrefInputRef$current2.focus();
    } // controller.run('onAction', focusLinkEditor());

  }, [textInputRef, hrefInputRef, isPlaceholder, isEditMode]); // 编辑状态下 click 正常链接，隐藏编辑框

  var handleLinkClick = React.useCallback(function (event) {
    if (!isPlaceholder && !isPlaceholder && isEditMode) {
      onEditorHide();
    }
  }, [isEditMode, isPlaceholder, isEmptyHref]);
  var handleClickoutside = React.useCallback(function (event) {
    var _linkRef$current;

    var target = event.target;

    if (target === linkRef.current || (_linkRef$current = linkRef.current) != null && _linkRef$current.contains(target)) {
      return;
    }

    onEditorHide();
  }, [onEditorHide]);
  var overlay = React.useMemo(function () {
    return /*#__PURE__*/_createElement(LinkEditor, {
      ref: portalRef,
      displayType: 'link',
      nodeKey: nodeKey,
      text: isPlaceholder ? '' : text,
      href: href,
      onSave: onSave,
      onRemove: onRemove,
      onUnlink: onUnlink,
      locale: locale,
      controller: controller,
      onHide: onEditorHide,
      onClickoutside: handleClickoutside,
      enableCard: enableCard,
      showPlaceholder: isPlaceholder,
      textInputRef: textInputRef,
      hrefInputRef: hrefInputRef
    });
  }, [portalRef, nodeKey, text, href, onSave, onRemove, onUnlink, locale, controller, enableCard, onEditorHide, handleClickoutside, isPlaceholder]);
  return {
    overlay: overlay,
    handleLinkMouseDown: handleLinkMouseDown,
    handleLinkClick: handleLinkClick
  };
};

export default useEditorPortal;
//# sourceMappingURL=useEditorPortal.js.map