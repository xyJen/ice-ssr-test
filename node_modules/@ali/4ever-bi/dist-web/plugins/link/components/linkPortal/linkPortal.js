import _extends from "@babel/runtime/helpers/extends";
import * as React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import { useZoom, useZoomContainer } from '@ali/4ever-cangjie';
import Portal from "../AnimatePortal";
import useEditorPortal from "./useEditorPortal";
import useToolbarPortal from "./useToolbarPortal";
import { useDelayedState } from '@ali/4ever-component';
import { hoverLinkCard } from "../../actions";
import { usePrevious } from '@ali/we-design';
var offsetX = 0;
var offsetY = 6;
var offset = [offsetX, offsetY]; // toolbar 隐藏延时

var HIDE_TOOLBAR_DELAY_TIME = 150;

var getPosition = function getPosition(containerRect, triggerRect, portalRect) {
  var height = portalRect.height,
      width = portalRect.width;
  var baseTop = triggerRect.bottom - containerRect.top;
  var baseLeft = triggerRect.left - containerRect.left; // 计算底部剩余空间，若剩余空间能够容纳 portal，则向下展示 portal
  // 如果下方剩余空间无法容纳 portal，还需要判断上方空间能否容纳
  // 若上方也无法容纳(triggerTop < height)，则仍然放到下方
  // 左右则优先放右侧，不够之后向左偏移

  var bottomSpace = containerRect.height - baseTop;
  var rightSpace = containerRect.width - baseLeft;
  var triggerTop = triggerRect.top - containerRect.top;
  var triggerRight = triggerRect.right - containerRect.left;
  var top = bottomSpace < height && triggerTop > height ? triggerTop + offsetY - height - 4 // 放到上方
  : baseTop + offsetY;
  var left = rightSpace < width && triggerRight > width ? baseLeft + offsetX - width + rightSpace - 4 : baseLeft + offsetX;
  return {
    left: left,
    top: top
  };
};

var stopEvent = function stopEvent(event) {
  return event.stopPropagation();
};

var LinkPortal = function LinkPortal(props) {
  var children = props.children,
      text = props.text,
      href = props.href,
      locale = props.locale,
      controller = props.controller,
      _props$mountRoot = props.mountRoot,
      mountRoot = _props$mountRoot === void 0 ? false : _props$mountRoot;

  var _useDelayedState = useDelayedState('Hidden'),
      portalState = _useDelayedState[0],
      setPortalState = _useDelayedState[1];

  var _React$useState = React.useState(false),
      overlayChanging = _React$useState[0],
      setOverlayChanging = _React$useState[1];

  var _React$useState2 = React.useState(null),
      hidingOverlay = _React$useState2[0],
      setHidingOverlay = _React$useState2[1];

  var onOverlayHide = React.useCallback(function () {
    setHidingOverlay(null);
    setOverlayChanging(false);
  }, []);
  var showEditor = React.useCallback(function () {
    setPortalState('EditorVisible');
  }, []);
  var hideEditor = React.useCallback(function () {
    setPortalState(function (s) {
      return s === 'EditorVisible' ? 'Hidden' : s;
    });
  }, []);
  var showToolbar = React.useCallback(function () {
    setPortalState(function (s) {
      return s === 'Hidden' || s === 'ToolbarVisible' ? 'ToolbarVisible' : s;
    });
  }, []);
  var hideToolbar = React.useCallback(function () {
    // toolbar 隐藏时设置延时，处理链接到卡片的 hover 情况
    setPortalState(function (s) {
      return s === 'ToolbarVisible' ? 'Hidden' : s;
    }, HIDE_TOOLBAR_DELAY_TIME);
  }, []);
  var defaultContent = useZoomContainer() || document.body;
  var scrollableContent = mountRoot ? document.body : defaultContent;
  var zoom = useZoom();
  var portalRef = React.useRef(null);
  var linkRef = React.useRef(null);
  var isPlaceholder = text === locale.addLinkPlaceholder;
  var isEmptyHref = href.trim().length === 0;
  var showStopEvent = portalState === 'EditorVisible' && (isPlaceholder || isEmptyHref);
  var isNormalLink = !isPlaceholder && !isEmptyHref; // 这里在编辑模式下，显示编辑框

  var editorPortal = useEditorPortal(_extends({}, props, {
    isEditMode: portalState === 'EditorVisible',
    onEditorHide: hideEditor,
    linkRef: linkRef,
    portalRef: portalRef,
    isPlaceholder: isPlaceholder
  }));
  var toolbarPortal = useToolbarPortal(_extends({}, props, {
    onSwitchToEdit: showEditor,
    showToolbar: showToolbar,
    hideToolbar: hideToolbar,
    linkRef: linkRef,
    portalRef: portalRef,
    isPlaceholder: isPlaceholder
  }));
  var editorOverlay = editorPortal.overlay,
      handleEditorLinkMouseDown = editorPortal.handleLinkMouseDown,
      handleEditorLinkClick = editorPortal.handleLinkClick;
  var toolbarOverlay = toolbarPortal.overlay,
      handleLinkMouseDown = toolbarPortal.handleLinkMouseDown,
      handleLinkClick = toolbarPortal.handleLinkClick;
  var handleMouseEnter = React.useCallback(function () {
    showToolbar();
    controller.run('onAction', hoverLinkCard());
  }, [controller, showToolbar]);
  var overlay = portalState !== 'EditorVisible' ? toolbarOverlay : editorOverlay;
  var handleClick = portalState !== 'EditorVisible' ? handleLinkClick : handleEditorLinkClick;
  var prePortalState = usePrevious(portalState);
  React.useEffect(function () {
    var preVisible = prePortalState === 'EditorVisible' || prePortalState === 'ToolbarVisible';
    var currentVisible = portalState === 'EditorVisible' || portalState === 'ToolbarVisible';

    if (preVisible && !currentVisible) {
      // 进行隐藏时，使用旧的 overlay 进行隐藏，避免动画过程中组件切换
      setHidingOverlay(prePortalState !== 'EditorVisible' ? toolbarOverlay : editorOverlay);
    } else if (preVisible && currentVisible && prePortalState !== portalState) {
      // 显示状态下切换 overlay，先使用旧的 overlay 进行隐藏，再显示新的 overlay
      setOverlayChanging(true);
      setHidingOverlay(prePortalState !== 'EditorVisible' ? toolbarOverlay : editorOverlay);
    }
  }, [prePortalState, portalState]);
  return /*#__PURE__*/_createElement(Portal, {
    className: "bi-link-portal",
    visible: portalState !== 'Hidden' && !overlayChanging,
    triggerRef: linkRef,
    overlay: hidingOverlay || overlay,
    portalMatchTrigger: false,
    getPosition: getPosition,
    onOverlayHide: onOverlayHide,
    container: scrollableContent,
    offset: offset,
    zoom: zoom
  }, /*#__PURE__*/React.cloneElement(children, {
    onMouseDown: portalState !== 'EditorVisible' ? handleLinkMouseDown : handleEditorLinkMouseDown,
    // 当点击占位符时，需要阻止事件冒泡，避免被 cangjie 处理
    onMouseUp: showStopEvent ? stopEvent : undefined,
    onClick: showStopEvent ? stopEvent : handleClick,
    onMouseEnter: portalState !== 'EditorVisible' && isNormalLink ? handleMouseEnter : undefined,
    onMouseLeave: portalState !== 'EditorVisible' ? hideToolbar : undefined
  }));
};

export default LinkPortal;
//# sourceMappingURL=linkPortal.js.map