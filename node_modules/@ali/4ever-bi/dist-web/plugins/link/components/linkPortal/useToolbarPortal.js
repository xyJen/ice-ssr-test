import * as React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import LinkToolbar from "../linkToolbar";
import { editLinkCard, handleLinkPlaceholder } from "../../actions";

var useToolbarPortal = function useToolbarPortal(props) {
  var node = props.node,
      _props$href = props.href,
      href = _props$href === void 0 ? '' : _props$href,
      onRemove = props.onRemove,
      onUnlink = props.onUnlink,
      controller = props.controller,
      locale = props.locale,
      onCopyLink = props.onCopyLink,
      onCut = props.onCut,
      isLinkFocused = props.isLinkFocused,
      getLinkInfo = props.getLinkInfo,
      onToolbarSwitchStyle = props.onToolbarSwitchStyle,
      onOpenlink = props.onOpenlink,
      enableCard = props.enableCard,
      onSwitchToEdit = props.onSwitchToEdit,
      showToolbar = props.showToolbar,
      portalRef = props.portalRef,
      linkRef = props.linkRef,
      hideToolbar = props.hideToolbar,
      isPlaceholder = props.isPlaceholder;
  var cardInfo = (node == null ? void 0 : node.data.cardInfo) || {};
  var title = cardInfo.title,
      imgURL = cardInfo.imgURL,
      desc = cardInfo.desc;
  var isEmptyHref = href.trim().length === 0; // isLinkFocused 变化时主动隐藏

  React.useEffect(function () {
    // 对于占位符合首次插入链接，直接显示编辑框
    if (isLinkFocused && (isPlaceholder || isEmptyHref)) {
      onSwitchToEdit();
    }
  }, [isLinkFocused, isPlaceholder, isEmptyHref, onSwitchToEdit]);
  var handleEdit = React.useCallback(function () {
    // 清理所有状态，切换至编辑模式
    onSwitchToEdit();
    controller.run('onAction', editLinkCard());
  }, [controller, onSwitchToEdit]);
  var handleLinkMouseDown = React.useCallback(function (e) {
    // 仅当链接是占位符，或者空链接，点击生效，显示编辑框
    if (isPlaceholder || isEmptyHref) {
      e.stopPropagation();
      e.preventDefault();
      onSwitchToEdit();
    }

    if (isPlaceholder) {
      controller.run('onAction', handleLinkPlaceholder());
    }
  }, [controller, isPlaceholder, isEmptyHref, onSwitchToEdit]); // 正常链接点击跳转

  var handleLinkClick = React.useCallback(function (e) {
    if (!isPlaceholder && !isEmptyHref) {
      typeof onOpenlink === 'function' && onOpenlink();
    }
  }, [onOpenlink, isPlaceholder, isEmptyHref]);
  var handleClickoutside = React.useCallback(function (event) {
    var _linkRef$current;

    var target = event.target;

    if (target === linkRef.current || (_linkRef$current = linkRef.current) != null && _linkRef$current.contains(target)) {
      return;
    }

    hideToolbar();
  }, []);
  var overlay = React.useMemo(function () {
    return /*#__PURE__*/_createElement(LinkToolbar, {
      ref: portalRef,
      href: href,
      title: title,
      imgURL: imgURL,
      desc: desc,
      onEdit: handleEdit,
      onRemove: onRemove,
      onUnlink: onUnlink,
      onHide: hideToolbar,
      onCopy: onCopyLink,
      onCut: onCut,
      onOpenlink: onOpenlink,
      onClickoutside: handleClickoutside,
      getLinkInfo: getLinkInfo,
      locale: locale,
      enableCard: enableCard,
      onToolbarSwitchStyle: onToolbarSwitchStyle,
      onMouseLeave: hideToolbar,
      onMouseEnter: showToolbar,
      onCleanup: hideToolbar
    });
  }, [portalRef, href, title, imgURL, desc, handleEdit, onRemove, onUnlink, locale, onCopyLink, onCut, enableCard, onOpenlink]);
  return {
    overlay: overlay,
    handleLinkMouseDown: handleLinkMouseDown,
    handleLinkClick: handleLinkClick
  };
};

export default useToolbarPortal;
//# sourceMappingURL=useToolbarPortal.js.map