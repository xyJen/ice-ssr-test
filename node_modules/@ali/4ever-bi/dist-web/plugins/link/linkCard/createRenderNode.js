import _extends from "@babel/runtime/helpers/extends";
import * as React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import styled from 'styled-components';
import { useZoom, useZoomContainer } from '@ali/4ever-cangjie';
import { URLLinkCard } from '@ali/we-biz-link-card';
import { convertBlockLinkCardToTextLink, copyBlockLinkCard, cutBlockLinkCard, deleteBlockLinkCard, unlinkBlockCardData, updateBlockLinkCardData } from "./actions";
import { getBlockLinkCardState } from "./utils/getBlockLinkCardState";
import Portal from "../components/AnimatePortal";
import { getPositionTopRight, offsetY } from "../utils/getPosition";
import { LinkPlugin, useScrollableContent } from '@ali/4ever-bamboo';
import LinkEditor from "../components/linkEditor";
import biLocale from "../../../locales/zh_CN";
var normalizeLink = LinkPlugin.normalizeLink,
    openLink = LinkPlugin.openLink;
var Wrapper = /*#__PURE__*/styled.div(["cursor:pointer;border-radius:9px;"]);

function LinkCardNode(props) {
  var nodeProps = props.nodeProps,
      controller = props.controller,
      linkConfig = props.linkConfig,
      isMobile = props.isMobile;
  var _linkConfig$locale = linkConfig.locale,
      locale = _linkConfig$locale === void 0 ? biLocale.link.locale : _linkConfig$locale,
      _linkConfig$protocolA = linkConfig.protocolAllowList,
      protocolAllowList = _linkConfig$protocolA === void 0 ? ['http:', 'https:', 'dingtalk:', 'taobao:'] : _linkConfig$protocolA,
      onCopyLink = linkConfig.onCopyLink,
      getLinkInfo = linkConfig.getLinkInfo,
      openLinkOfConfig = linkConfig.openLink;
  var node = nodeProps.node,
      isSelected = nodeProps.isSelected;
  var selection = controller.value.selection;
  var _ref = node.data.metadata,
      text = _ref.text,
      href = _ref.href,
      cardInfo = _ref.cardInfo;

  var _React$useState = React.useState(false),
      editMode = _React$useState[0],
      setEditMode = _React$useState[1];

  var linkRef = React.useRef(null);
  var portalRef = React.useRef(null);
  var scrollableContent = useZoomContainer() || document.body;
  var scrollContent = useScrollableContent() || document.body;
  var zoom = useZoom();
  var getContainer = React.useCallback(function () {
    return scrollContent;
  }, [scrollContent]);
  var urlInfo = React.useMemo(function () {
    var isTitleEqualsHref = text.trim() === href.trim();
    var actualTitle = isTitleEqualsHref ? cardInfo.title : text;
    return {
      title: actualTitle || '',
      desc: cardInfo.desc || '',
      imgURL: cardInfo.imgURL || ''
    };
  }, [cardInfo, text, href]);
  var linkCardLocale = React.useMemo(function () {
    var tooltipLocale = {
      editTooltip: locale.edit,
      copyTooltip: locale.copy,
      unlinkTooltip: locale.unlink,
      deleteTooltip: locale["delete"],
      switchStyleTooltip: locale.styleText
    };
    return _extends({}, locale, tooltipLocale);
  }, [locale]);
  var state = React.useMemo(function () {
    return getBlockLinkCardState(node);
  }, [node]);
  var handleVisit = React.useCallback(function () {
    if (openLinkOfConfig) {
      var normalizedLink = normalizeLink(href, protocolAllowList);
      openLinkOfConfig(normalizedLink);
    } else {
      openLink(href, protocolAllowList);
    }
  }, [href, protocolAllowList, openLinkOfConfig]);
  var handleCopy = React.useCallback(function () {
    // 卡片形式下，使用仓颉复制
    controller.run('onAction', copyBlockLinkCard(node));

    if (onCopyLink && typeof onCopyLink === 'function') {
      onCopyLink(href);
    }
  }, [href, onCopyLink, node, controller]);
  var handleCut = React.useCallback(function () {
    controller.run('onAction', cutBlockLinkCard(node));
  }, [controller, node]);
  var handleRemove = React.useCallback(function () {
    controller.run('onAction', deleteBlockLinkCard(node));
  }, [controller, node]);
  var handleUnlink = React.useCallback(function () {
    controller.run('onAction', unlinkBlockCardData(node));
  }, [controller, node]);
  var handleSwitchStyle = React.useCallback(function (e) {
    if (e === 'popup') {
      controller.run('onAction', convertBlockLinkCardToTextLink(node));
    }
  }, [controller, node]);
  var handleRefresh = React.useCallback(function () {
    controller.run('onAction', updateBlockLinkCardData(node, text, href));
  }, [controller, getLinkInfo, text, href, node]);
  var handleClickoutside = React.useCallback(function (event) {
    var _linkRef$current;

    var target = event.target;

    if (target === linkRef.current || (_linkRef$current = linkRef.current) != null && _linkRef$current.contains(target)) {
      return;
    }

    setEditMode(false);
  }, []);
  var handleEdit = React.useCallback(function () {
    setEditMode(true);
  }, []);
  var handleEditorHide = React.useCallback(function () {
    setEditMode(false);
  }, []);
  var handleSave = React.useCallback(function (text, href, displayType) {
    if (displayType === 'link') {
      controller.run('onAction', convertBlockLinkCardToTextLink(node, {
        text: text,
        href: href
      }));
    } else {
      controller.run('onAction', updateBlockLinkCardData(node, text, href));
    }
  }, []);
  var overlay = React.useMemo(function () {
    return /*#__PURE__*/_createElement(LinkEditor, {
      ref: portalRef,
      displayType: 'card',
      nodeKey: node == null ? void 0 : node.key,
      text: text.trim() === href.trim() ? '' : text,
      href: href,
      onSave: handleSave,
      onRemove: handleRemove,
      onUnlink: handleUnlink,
      locale: linkCardLocale,
      controller: controller,
      onHide: handleEditorHide,
      onClickoutside: handleClickoutside,
      enableCard: true
    });
  }, [portalRef, node, text, href, linkCardLocale, controller, handleRemove, handleUnlink, handleEditorHide, handleClickoutside]);
  return /*#__PURE__*/_createElement(Portal, {
    className: "bi-link-card-portal",
    visible: editMode,
    triggerRef: linkRef,
    overlay: overlay,
    portalMatchTrigger: false,
    container: scrollableContent,
    getPosition: getPositionTopRight,
    offset: [0, offsetY],
    zoom: zoom
  }, /*#__PURE__*/_createElement(Wrapper, null, /*#__PURE__*/_createElement(URLLinkCard, {
    getContainer: getContainer,
    isSelected: isSelected && selection.isCollapsed,
    cardStyle: 'indoc',
    state: state,
    url: href,
    readonly: false,
    locale: linkCardLocale,
    urlInfo: urlInfo,
    isMobile: isMobile // @ts-ignore
    ,
    onRefresh: handleRefresh,
    onCopy: handleCopy,
    onOpenURL: handleVisit,
    onSwitchStyle: handleSwitchStyle,
    onDelete: handleRemove,
    onCut: handleCut,
    onEdit: handleEdit,
    onUnlink: handleUnlink,
    editBtnTestID: "link-toolbar-edit",
    copyBtnTestID: "link-toolbar-copy",
    cutBtnTestID: "link-toolbar-cut",
    unlinkBtnTestID: "link-toolbar-unlink",
    deleteBtnTestID: "link-toolbar-remove",
    switchStyleBtnTestID: "link-toolbar-switch",
    linkStyleBtnTestID: "link-toolbar-switch-link",
    cardStyleBtnTestID: "link-toolbar-switch-card",
    cardTestID: "link-card"
  })));
}

export default function createRenderNode(linkConfig, isMobile) {
  return function (nodeProps, controller) {
    return /*#__PURE__*/_createElement(LinkCardNode, {
      linkConfig: linkConfig,
      isMobile: isMobile,
      nodeProps: nodeProps,
      controller: controller
    });
  };
}
//# sourceMappingURL=createRenderNode.js.map