import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _extends from "@babel/runtime/helpers/extends";
import React, { useCallback, useState, useMemo } from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import Debug from 'debug';
import { CalendarCardPlugin } from '@ali/4ever-bamboo';
import Container from "../components/Container";
import FlashCalendarContainer from "../shanhui/FlashCalendarContainer";
import { CalendarType } from "../types";
import { setCardInjection, setCardData } from '@ali/4ever-factory';
import { calculatedSize, getCalculatedReceivers } from "../utils/calculatedSize";
import { calculatedCalendarSize, getCalculatedCalendarReceivers } from "../shanhui/calculatedCalendarSize";
import useRefreshResult from "../hooks/useRefreshResult";
import useRenderCalendarBtn from "../hooks/useRenderCalendarBtn";
import isEqualValue from "../utils/isEqualValue";
import useInit from "../hooks/useInit";
var debug = Debug('EDITOR:BI:CALENDAR:RENDER');
var CALENDAR_CARD_MIN_HEIGHT = CalendarCardPlugin.CALENDAR_CARD_MIN_HEIGHT;
export var Calendar = function Calendar(_ref) {
  var nodeProps = _ref.nodeProps,
      controller = _ref.controller,
      calendarConfig = _ref.calendarConfig;
  var locale = calendarConfig.locale,
      jumpToCalendar = calendarConfig.jumpToCalendar,
      openProfile = calendarConfig.openProfile,
      jumpToAttachment = calendarConfig.jumpToAttachment,
      onRefreshSuccess = calendarConfig.onRefreshSuccess,
      refresh = calendarConfig.refresh,
      isMobile = calendarConfig.isMobile,
      _calendarConfig$getCo = calendarConfig.getContainerWidthInPC,
      getContainerWidthInPC = _calendarConfig$getCo === void 0 ? function () {
    return 0;
  } : _calendarConfig$getCo,
      handleCreateCalendar = calendarConfig.handleCreateCalendar,
      onInitData = calendarConfig.onInitData,
      CreateCalendarBtn = calendarConfig.renderCreateCalendarBtn,
      calendarMode = calendarConfig.mode;
  var isFocused = controller.value.isFocused;
  var containerWidthInPC = useMemo(function () {
    return getContainerWidthInPC() - 4;
  }, [getContainerWidthInPC]);
  var node = nodeProps.node,
      isSelected = nodeProps.isSelected;
  var nodeKey = node.key;
  var finalData = node.data;
  var finalHeight = isMobile ? 'auto' : finalData.height || CALENDAR_CARD_MIN_HEIGHT;
  var _ref2 = finalData,
      injectionMetadata = _ref2.injectionMetadata,
      injectionHeight = _ref2.injectionHeight,
      _ref2$isFirstLoaded = _ref2.isFirstLoaded,
      isFirstLoaded = _ref2$isFirstLoaded === void 0 ? !!isMobile : _ref2$isFirstLoaded;
  var _finalData$metadata = finalData.metadata,
      isInitialized = _finalData$metadata.isInitialized,
      isPlaceholder = _finalData$metadata.isPlaceholder,
      _finalData$metadata$m = _finalData$metadata.mode,
      mode = _finalData$metadata$m === void 0 ? calendarMode : _finalData$metadata$m;
  var finalMetadata = injectionMetadata || finalData.metadata;
  var calendarId = finalMetadata.calendarId,
      redirectUrl = finalMetadata.redirectUrl;

  var _useState = useState(false),
      isLoading = _useState[0],
      setLoading = _useState[1];

  var isShanhui = mode === CalendarType.SHANHUI; // 点击刷新按钮后的消息反馈

  var _useRefreshResult = useRefreshResult(),
      refreshTipsNode = _useRefreshResult.refreshTipsNode,
      setRefreshResult = _useRefreshResult.setRefreshResult;

  var injectToData = useCallback(function (mergeData) {
    var latestNode = controller.value.document.getNode(node.key);
    controller.run('onAction', setCardInjection(latestNode, _extends({
      injectionMetadata: injectionMetadata,
      injectionHeight: injectionHeight,
      isFirstLoaded: isFirstLoaded
    }, mergeData)));
  }, [controller, node.key, injectionMetadata, injectionHeight, isFirstLoaded]); // 设置日程卡片 data

  var setCalendarCardData = useCallback( /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(newMetadata) {
      var calculateHeight, height, latestNode;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              calculateHeight = isShanhui ? calculatedCalendarSize : calculatedSize;
              _context.next = 3;
              return calculateHeight(newMetadata, containerWidthInPC);

            case 3:
              height = _context.sent;
              latestNode = controller.value.document.getNode(node.key);
              controller.run('onAction', setCardData(latestNode, {
                metadata: _extends({}, newMetadata, {
                  mode: mode,
                  isInitialized: true
                }),
                height: height,
                withoutSaving: true
              }));

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref3.apply(this, arguments);
    };
  }(), [containerWidthInPC, controller, node.key, mode, isShanhui]); // 创建右上角日程按钮

  var _useRenderCalendarBtn = useRenderCalendarBtn({
    isPlaceholder: isPlaceholder,
    calendarId: calendarId,
    containerWidthInPC: containerWidthInPC,
    finalMetadata: finalMetadata,
    injectToData: injectToData,
    setLoading: setLoading,
    setCalendarCardData: setCalendarCardData,
    CalendarBtn: CreateCalendarBtn,
    key: nodeKey
  }),
      createCalendarBtn = _useRenderCalendarBtn[0]; // 点击创建日程按钮


  var processCreateCalendar = useCallback(function () {
    if (handleCreateCalendar) handleCreateCalendar(nodeKey);
  }, [handleCreateCalendar, nodeKey]); // 调整到日程容器

  var goToCalendar = useCallback(function (eventType) {
    if (!jumpToCalendar || !redirectUrl) return;
    jumpToCalendar(redirectUrl, eventType);
  }, [jumpToCalendar, redirectUrl]); // 将日程数据持久化存储到卡片中

  var setRefreshDataToNode = useCallback(function () {
    if (injectionMetadata) {
      var latestNode = controller.value.document.getNode(node.key);
      controller.run('onAction', setCardData(latestNode, {
        metadata: _extends({}, injectionMetadata, {
          mode: mode,
          isInitialized: true
        }),
        height: injectionHeight,
        withoutSaving: true
      }));
      injectToData({
        injectionMetadata: undefined,
        injectionHeight: undefined,
        isFirstLoaded: true
      });
      if (onRefreshSuccess) onRefreshSuccess();
    }
  }, [injectionMetadata, controller, node.key, mode, injectionHeight, injectToData, onRefreshSuccess]);
  var fireRefresh = useCallback(function (event) {
    event.preventDefault();
    event.stopPropagation();
    if (!refresh) return;

    if (injectionMetadata) {
      setRefreshDataToNode();
      return;
    }

    setLoading(true);
    refresh(calendarId, 'click').then( /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(res) {
        var getTopReceivers, topReceivers, newMetadata;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                setLoading(false);

                if (!(res.status !== 'success')) {
                  _context2.next = 3;
                  break;
                }

                return _context2.abrupt("return");

              case 3:
                if (containerWidthInPC) {
                  _context2.next = 5;
                  break;
                }

                return _context2.abrupt("return");

              case 5:
                getTopReceivers = isShanhui ? getCalculatedCalendarReceivers : getCalculatedReceivers;
                _context2.next = 8;
                return getTopReceivers(res.data, containerWidthInPC, res.data.totalCount);

              case 8:
                topReceivers = _context2.sent;
                newMetadata = _extends({
                  calendarId: calendarId
                }, res.data, {
                  topReceivers: topReceivers
                });

                if (!isEqualValue(newMetadata, finalMetadata)) {
                  setCalendarCardData(newMetadata);
                }

                if (onRefreshSuccess) onRefreshSuccess();

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      return function (_x2) {
        return _ref4.apply(this, arguments);
      };
    }())["catch"](function () {
      setLoading(false);
    });
  }, [refresh, injectionMetadata, calendarId, setRefreshDataToNode, containerWidthInPC, isShanhui, finalMetadata, onRefreshSuccess, setCalendarCardData]);
  var getLoadingState = useCallback(function () {
    debug('LOADINGSTATE', isFirstLoaded, isLoading);
    return !isFirstLoaded ? true : isLoading;
  }, [isFirstLoaded, isLoading]);
  useInit({
    isInitialized: isInitialized,
    isPlaceholder: isPlaceholder,
    containerWidthInPC: containerWidthInPC,
    isLoading: isLoading,
    isFirstLoaded: isFirstLoaded,
    isMobile: isMobile,
    calendarId: calendarId,
    setLoading: setLoading,
    refresh: refresh,
    controller: controller,
    node: node,
    finalMetadata: finalMetadata,
    finalData: finalData,
    injectToData: injectToData,
    setRefreshResult: setRefreshResult,
    onInitData: onInitData,
    mode: mode
  });

  if (isShanhui) {
    return /*#__PURE__*/_createElement(FlashCalendarContainer, {
      refreshTipsNode: refreshTipsNode,
      height: finalHeight,
      isLoading: isLoading,
      isFirstLoaded: isFirstLoaded,
      isChangeData: !!injectionMetadata,
      metadata: _extends({}, finalMetadata, {
        mode: mode
      }),
      locale: locale,
      isSelected: isSelected && isFocused,
      width: containerWidthInPC,
      jumpToCalendar: goToCalendar,
      openProfile: openProfile,
      jumpToAttachment: jumpToAttachment,
      refresh: fireRefresh,
      isMobile: isMobile,
      handleCreateCalendar: processCreateCalendar,
      createCalendarBtn: createCalendarBtn
    });
  }

  return /*#__PURE__*/_createElement(Container, {
    refreshTipsNode: refreshTipsNode,
    height: finalHeight,
    isLoading: getLoadingState(),
    isFirstLoaded: isFirstLoaded,
    isChangeData: !!injectionMetadata,
    metadata: finalData.metadata,
    locale: locale,
    isSelected: isSelected && isFocused,
    width: containerWidthInPC,
    jumpToCalendar: goToCalendar,
    openProfile: openProfile,
    jumpToAttachment: jumpToAttachment,
    refresh: fireRefresh,
    isMobile: isMobile,
    handleCreateCalendar: processCreateCalendar,
    createCalendarBtn: createCalendarBtn
  });
};
export default Calendar;
//# sourceMappingURL=Calendar.js.map