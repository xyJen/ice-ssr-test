{"version":3,"sources":["../../../../../src/plugins/sticker/utils/getCaretPosition.ts"],"names":["domUtils","Queries","EXTRA_OFFSET_TOP","EXTRA_OFFSET_LEFT","EXTRA_OFFSET_RIGHT","CARET_SCALE","NARROW_GAP","corretCaretPoint","controller","value","selection","document","point","getStart","getClosestVoid","key","getParent","type","query","pointAtDistance","positionCache","getCaretPosition","rect","zoom","panelHeight","panelWidth","pointCorrected","position","findCaretPosition","originLeft","clientLeft","left","originTop","clientTop","top","holderHeight","height","rectWidth","width","rectHeight","isAtRight","topWhenShowUp","isAtBottom"],"mappings":"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","sourcesContent":["import {\n  domUtils,\n  Controller,\n  Queries,\n} from '@ali/4ever-cangjie';\n\nconst EXTRA_OFFSET_TOP = 4;\nconst EXTRA_OFFSET_LEFT = 2;\nconst EXTRA_OFFSET_RIGHT = 18;\nconst CARET_SCALE = 1.5;\nconst NARROW_GAP = 6;\n\n/**\n * 光标位置处理。由于 void 节点内的光标无法定位，尝试获取前一个位置\n */\nexport function corretCaretPoint(controller: Controller) {\n  const { selection, document } = controller.value;\n  const point = selection.getStart(document);\n  if (\n    document.getClosestVoid(point.key, controller) ||\n    document.getParent(point.key)?.type === 'code'\n  ) {\n    return controller.query(Queries.pointAtDistance, point, -1);\n  }\n  return point;\n}\n\ninterface IGetCaretPosition {\n  controller: Controller;\n  rect: DOMRect; // 容器的 BoundingRect\n  zoom: number; // 容器缩放比例\n  panelHeight: number; // 表情面板高度\n  panelWidth: number; // 表情面板宽度\n}\n\nlet positionCache = null;\n\nexport function getCaretPosition({\n  controller,\n  rect,\n  zoom,\n  panelHeight,\n  panelWidth,\n}: IGetCaretPosition) {\n  const pointCorrected = corretCaretPoint(controller);\n  const position = domUtils.findCaretPosition(pointCorrected);\n  if (position) {\n    // @ts-ignore\n    positionCache = position;\n  } else {\n    return positionCache;\n  }\n\n  const originLeft = (position.clientLeft - rect.left) / zoom;\n  const originTop = (position.clientTop - rect.top) / zoom;\n  const holderHeight = position.height / zoom;\n  const rectWidth = rect.width / zoom;\n  const rectHeight = rect.height / zoom;\n\n  let left = originLeft - EXTRA_OFFSET_LEFT;\n\n  let isAtRight = left + panelWidth  > rectWidth;\n  if (isAtRight) {\n      left = originLeft - panelWidth + EXTRA_OFFSET_RIGHT;\n      if (left < 0) {\n        // 当右侧溢出且左侧也不够面板展开时，面板紧临右侧展开\n        left = rectWidth - panelWidth - NARROW_GAP;\n        isAtRight = false;\n      }\n  }\n\n  let top = originTop + holderHeight + EXTRA_OFFSET_TOP;\n\n  // 表情面板靠近底部且上部空间足够时，向上展开\n  const topWhenShowUp = originTop - panelHeight - EXTRA_OFFSET_TOP * CARET_SCALE;\n  const isAtBottom = (top + panelHeight > rectHeight) && topWhenShowUp > 0;\n  if (isAtBottom) {\n    top = topWhenShowUp;\n  }\n\n  return {\n    left,\n    top,\n    isAtBottom,\n    isAtRight,\n  };\n}\n"],"file":"getCaretPosition.js"}