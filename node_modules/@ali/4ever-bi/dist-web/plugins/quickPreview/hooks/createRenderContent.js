import * as React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import { constants, environment } from '@ali/4ever-cangjie';
import Actions from "../actions";

/**
 * 这里使用默认的 db click 非常容易误触。
 * 参考了飞书的行为，把触发的参数控制的非常严格
 */

/**
 * 连续两次 touch 之间的最大间隔时间 ms
 * 和飞书对比，300 明显偏大，200 明显偏小。250 感觉还是偏大，暂用
 */
var DB_CLICK_TIME = 250; // 连续两次 touch 之间的最大间隔距离 px

var DB_CLICK_PX = 15; // touch start 和 end 之间，移动超过 px 就判定无效

var DB_CLICK_SCROLL_PX = 1;
var OFFSET_NONE = -1000;
var lastMouseDown = 0;
var lastClick = {
  time: 0,
  x: OFFSET_NONE,
  y: OFFSET_NONE
};

function isElementInContent(element, key) {
  var content = element.closest("[" + constants.Selector.content + "]");

  if (!content || !content.querySelector("[" + constants.Selector.key + "=\"" + key + "\"]")) {
    return false;
  }

  return true;
}

function DbClick(_ref) {
  var controller = _ref.controller,
      configs = _ref.configs;
  React.useEffect(function () {
    var handleTouchStart = function handleTouchStart(event) {
      timer && clearTimeout(timer);
      var _controller$value = controller.value,
          isFocused = _controller$value.isFocused,
          document = _controller$value.document;

      if (isFocused) {
        return;
      }

      var target = event.target,
          touches = event.touches;

      if (!(target instanceof HTMLElement) || !touches.length) {
        return;
      }

      if (!isElementInContent(target, document.key)) {
        return;
      } // hack, to be removed later


      var isHitTitle = target instanceof HTMLTextAreaElement && target.closest('#doc-title-area');
      var _touches$ = touches[0],
          clientX = _touches$.clientX,
          clientY = _touches$.clientY;
      var now = Date.now();
      var timeCount = now - lastClick.time;
      var xCount = Math.abs(clientX - lastClick.x);
      var yCount = Math.abs(clientY - lastClick.y);
      var hitTest = timeCount < DB_CLICK_TIME && xCount < DB_CLICK_PX && yCount < DB_CLICK_PX;

      if (hitTest) {
        controller.run('onAction', {
          type: Actions.EXIT,
          payload: {
            noScroll: true,
            noFocus: isHitTitle
          }
        });

        if (isHitTitle) {
          target.focus();
        }
      } else if (isHitTitle) {
        event.preventDefault();
      }

      lastClick = {
        time: now,
        x: clientX,
        y: clientY
      };
    };

    var handleTouchEnd = function handleTouchEnd(event) {
      if (controller.value.isFocused) {
        return;
      }

      var target = event.target,
          changedTouches = event.changedTouches;

      if (!(target instanceof HTMLElement) || !changedTouches.length) {
        return;
      }

      var _changedTouches$ = changedTouches[0],
          clientX = _changedTouches$.clientX,
          clientY = _changedTouches$.clientY;
      var xCount = Math.abs(clientX - lastClick.x);
      var yCount = Math.abs(clientY - lastClick.y);

      if (xCount > DB_CLICK_SCROLL_PX || yCount > DB_CLICK_SCROLL_PX) {
        // 发生了滚动，重置掉
        lastClick.time = 0;
      }

      lastClick.x = clientX;
      lastClick.y = clientY;
    };

    var timer = null;

    var handleClick = function handleClick(event) {
      if (!(event.target instanceof HTMLElement)) {
        return;
      }

      var document = controller.value.document;

      if (!isElementInContent(event.target, document.key)) {
        return;
      }

      timer = setTimeout(function () {
        if (configs != null && configs.onPreviewClick) {
          configs.onPreviewClick();
        }
      }, DB_CLICK_TIME * 2);
    };

    var handleMousedown = function handleMousedown(event) {
      if (!environment.IS_IPAD) {
        return;
      }

      var isHitTitle = event.target instanceof HTMLTextAreaElement && event.target.closest('#doc-title-area');
      var currentTime = Date.now();
      var hitTest = currentTime - lastMouseDown < DB_CLICK_TIME;

      if (hitTest) {
        controller.run('onAction', {
          type: Actions.EXIT,
          payload: {
            noScroll: true,
            noFocus: isHitTitle
          }
        });

        if (isHitTitle) {
          event.target.focus();
        }

        lastMouseDown = 0;
      } else {
        lastMouseDown = Date.now();
        isHitTitle && event.preventDefault();
      }
    };

    window.document.addEventListener('touchstart', handleTouchStart, {
      passive: false
    });
    window.document.addEventListener('touchend', handleTouchEnd);
    window.document.addEventListener('touchcancel', handleTouchEnd);
    window.document.addEventListener('mousedown', handleMousedown);
    window.document.addEventListener('click', handleClick);
    return function () {
      timer && clearTimeout(timer);
      window.document.removeEventListener('touchstart', handleTouchStart);
      window.document.removeEventListener('touchend', handleTouchEnd);
      window.document.removeEventListener('touchcancel', handleTouchEnd);
      window.document.removeEventListener('mousedown', handleMousedown);
      window.document.removeEventListener('click', handleClick);
    };
  }, [controller]);
  return null;
}

export default function createRenderContent(configs) {
  return function renderContent(props, controller, next) {
    var isQuickPreview = Boolean(controller.query('isQuickPreview'));
    return /*#__PURE__*/_createElement(React.Fragment, null, isQuickPreview && /*#__PURE__*/_createElement(DbClick, {
      controller: controller,
      configs: configs
    }), next());
  };
}
//# sourceMappingURL=createRenderContent.js.map