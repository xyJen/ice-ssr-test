"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = PCContextMenu;

var React = _interopRequireWildcard(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _everCangjie = require("@ali/4ever-cangjie");

var _everComponent = require("@ali/4ever-component");

var _weDesign = require("@ali/we-design");

var _lodash = require("lodash");

var _util = require("./util");

var _styled = require("./styled");

var _actions = require("./actions");

const _createElement = /*#__PURE__*/React.createElement;
const PADDING = 28;
const {
  useActiveInteraction
} = _everComponent.ActiveInteractionHooks;

var _ref = /*#__PURE__*/_createElement(_styled.Inflat, null);

var _ref2 = /*#__PURE__*/_createElement("div", {
  "data-testid": "contextmenu-divider"
}, /*#__PURE__*/_createElement(_weDesign.MenuDivider, null));

const ContextMenu = props => {
  const {
    controller,
    scrollableContent,
    contextData = {
      x: 100,
      y: 100
    },
    zoom
  } = props;
  const containerRef = React.useRef(null);
  /**
   * 阻止默认事件，防止文档区域失焦
   */

  const handleMouseDown = React.useCallback(ev => {
    if (ev.target?.tagName.toLocaleLowerCase() !== 'input') {
      // 放过input，以便输入地方可以正常输入
      ev.preventDefault && ev.preventDefault();
      ev.stopPropagation && ev.stopPropagation();
    }
  }, []);
  const close = React.useCallback(() => {
    controller.run('onAction', (0, _actions.closeContextMenu)());
  }, [controller]);
  React.useEffect(() => {
    const node = containerRef.current;
    const child = node?.firstElementChild;

    if (!node || !child) {
      return () => {};
    }

    const animId = window.requestAnimationFrame(() => {
      const style = {};
      const {
        innerWidth,
        innerHeight
      } = window;
      const containerClientRect = scrollableContent.getBoundingClientRect();
      const {
        width,
        height
      } = child.getBoundingClientRect();

      if (contextData.x + width <= innerWidth - PADDING) {
        style.left = (0, _util.toPx)((contextData.x - containerClientRect.left) / zoom);
      } else {
        style.left = (0, _util.toPx)((innerWidth - PADDING - width - containerClientRect.left) / zoom);
      }

      if (contextData.y + height <= innerHeight - PADDING) {
        style.top = (0, _util.toPx)((contextData.y - containerClientRect.top) / zoom);
      } else {
        style.top = (0, _util.toPx)((innerHeight - PADDING - height - containerClientRect.top) / zoom);
      }

      Object.keys(style).forEach(key => {
        node.style[key] = style[key];
      });
      node.style.opacity = '1';
    });
    return () => {
      if (animId) {
        window.cancelAnimationFrame(animId);
      }
    };
  }, [scrollableContent, contextData.x, contextData.y, zoom]);
  const menus = controller.run('contextMenu');
  const menuGroups = [];
  menus.forEach(menu => {
    const groupId = menu.options?.group || 0;
    const group = menuGroups[groupId] || [];
    group.push(menu);
    menuGroups[groupId] = group;
  });
  const menuGroupKeys = Object.keys(menuGroups).sort((a, b) => Number(a) - Number(b)); // eslint-disable-next-line react-hooks/exhaustive-deps

  const createActionHandler = React.useCallback((0, _lodash.memoize)(menu => () => {
    const {
      action,
      options,
      onClick
    } = menu;
    action && controller.run('onAction', action);
    onClick && onClick();

    if (!options?.keepMenu) {
      close();
    }
  }), [close]);
  React.useEffect(() => {
    function onKeyDown(event) {
      if (event.key === 'Escape' || event.key === 'Esc') {
        close();
      }
    }

    document.addEventListener('keydown', onKeyDown);
    return () => {
      document.removeEventListener('keydown', onKeyDown);
    };
  }, [controller, close]);
  const [activeType, setActiveType] = useActiveInteraction();
  const activeRef = React.useRef('');
  activeRef.current = activeType;
  React.useEffect(() => {
    if (menus.length > 0) {
      setActiveType('contextMenu');
    } else if (activeRef.current === 'contextMenu') {
      setActiveType('');
    }
  }, [menus, setActiveType]);
  React.useEffect(() => {
    return () => {
      setActiveType('');
    };
  }, []);

  if (!menus.length) {
    close();
    return null;
  }

  return /*#__PURE__*/_createElement(_styled.MenuWrapper, {
    "data-testid": "bi-contextmenu",
    "data-role": "pcContextMenu",
    onMouseDown: handleMouseDown,
    ref: containerRef
  }, /*#__PURE__*/_createElement(_weDesign.Menu, {
    mode: _weDesign.EMenuMode.vertical
  }, menuGroupKeys.map((group, index) => {
    const renderMenus = menuGroups[group];
    const showDivider = index !== menuGroupKeys.length - 1;
    return /*#__PURE__*/_createElement(_styled.MenuGroup, {
      key: group,
      "data-testid": "contextmenu-group"
    }, renderMenus.map(menu => {
      const {
        name,
        options = {},
        key: menuKey,
        role
      } = menu;
      const {
        disable,
        checked,
        icon,
        hotKey,
        inline
      } = options;
      const itemStyle = inline ? {
        display: 'inline-flex',
        minWidth: 0,
        backgroundColor: checked ? 'rgba(25,31,37,0.12)' : undefined,
        height: 26,
        padding: '0 4px',
        borderRadius: 5
      } : {};
      return /*#__PURE__*/_createElement(_weDesign.MenuItem, {
        key: menuKey,
        menuKey: menuKey,
        testid: menuKey,
        onClick: createActionHandler(menu),
        selected: inline ? false : checked,
        disabled: disable,
        autoClose: false,
        style: itemStyle,
        role: role
      }, /*#__PURE__*/_createElement(_weDesign.Tooltip, {
        title: name,
        placement: "top",
        zIndex: 10001,
        disabled: !(inline && icon)
      }, /*#__PURE__*/_createElement(_styled.MenuItem, {
        "data-checked": checked,
        "data-testid": `${group}-${menuKey}`,
        inline: inline
      }, icon ? /*#__PURE__*/_createElement(_styled.Icon, null, icon) : null, inline && icon ? null : /*#__PURE__*/_createElement(_styled.Name, null, name), _ref, /*#__PURE__*/_createElement(_styled.HotKey, {
        disabled: disable
      }, (0, _util.hotKeyToReadableString)(hotKey || '')))));
    }), showDivider ? _ref2 : null);
  })));
};

function PCContextMenu(props) {
  const {
    mountRoot
  } = props;

  const controller = _everCangjie.Controller.useController();

  const defaultContent = (0, _everCangjie.useScrollableContent)() || document.body;
  const scrollableContent = mountRoot ? document.body : defaultContent; // 由于挂载点变更，zoom 暂时不需要了。后续如果再有变更，可以重新在这里加回来

  const {
    data,
    isFocused,
    selection
  } = controller.value;
  const {
    contextData
  } = data;
  const shouldRenderContextMenu = isFocused && contextData;

  if (!shouldRenderContextMenu || !selection) {
    return null;
  }

  return /*#__PURE__*/_reactDom.default.createPortal( /*#__PURE__*/_createElement(ContextMenu, {
    controller: controller,
    scrollableContent: scrollableContent,
    contextData: contextData,
    zoom: 1
  }), scrollableContent);
}
//# sourceMappingURL=PCContextMenu.js.map