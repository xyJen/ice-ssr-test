"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.biFactory = void 0;

var _react = _interopRequireDefault(require("react"));

var _everCangjie = require("@ali/4ever-cangjie");

var _everUtils = require("@ali/4ever-utils");

var _actions = require("../utils/actions");

var _PCContextMenu = _interopRequireDefault(require("../utils/PCContextMenu"));

var _meta = require("../utils/meta");

const _createElement = /*#__PURE__*/_react.default.createElement;

function handleAction(action, controller, next) {
  const {
    type
  } = action;

  if (type === _actions.ACTION_CLOSE) {
    handleCloseContextMenu(controller);
  }

  return next();
}

function handleCloseContextMenu(controller) {
  const {
    data
  } = controller.value;

  if (data.contextData) {
    (0, _everUtils.dispatchCustomEvent)(_everUtils.LEGAL_EVENT.contextMenuVisible, {
      visible: false
    });

    if (controller.enableHots || controller.isPendingEnable) {
      // BACKGROUND: 右键菜单全选时，形成的 op 序列是：
      // -- set_selection -- set_data --
      // 导致无法匹配选区 pending 的模式，因此将隐藏菜单的变更滞后
      // -- set_selection -- pending -- set_data -- ...
      setTimeout(() => {
        controller.setData({ ...data,
          contextData: null
        });
      }, 0);
    } else {
      controller.setData({ ...data,
        contextData: null
      });
    }
  }
}

const biFactory = configs => {
  const pcContextMenu = configs?.pcContextMenu || {};

  function handleContextMenu(event, controller, next) {
    event.preventDefault();
    const contextData = {
      x: event.clientX,
      y: event.clientY
    }; // 如果右键的时候，当前选区选中了一个 void，则选中这个 void 元素

    const {
      selection,
      document
    } = controller.value;

    if (selection.isCollapsed) {
      const {
        anchor: point
      } = selection;
      const voidParent = document.getClosestVoid(point.key, controller);

      if (voidParent) {
        const anchor = controller.query(_everCangjie.Queries.pointAtDistance, point, -1);
        const focus = controller.query(_everCangjie.Queries.pointAtDistance, point, 1);

        const newSelection = _everCangjie.Selection.create({
          anchor,
          focus
        });

        controller.run('onCangjieSelect', (0, _everCangjie.CangjieSelectEvent)({
          selection: newSelection
        }));
      }
    }

    const {
      data
    } = controller.value;
    (0, _everUtils.dispatchCustomEvent)(_everUtils.LEGAL_EVENT.contextMenuVisible, {
      visible: true
    });
    controller.setData({ ...data,
      contextData
    });
    controller.run('onAction', (0, _actions.openContextMenu)());
    return next();
  }

  function handleMouseDown(event, controller, next) {
    handleCloseContextMenu(controller);
    return next();
  }

  function renderEditable(_, controller, next) {
    return /*#__PURE__*/_createElement(_react.default.Fragment, null, next(), /*#__PURE__*/_createElement(_PCContextMenu.default, pcContextMenu));
  }

  return {
    key: _meta.key,
    onAction: handleAction,
    onContextMenu: handleContextMenu,
    onMouseDown: handleMouseDown,
    renderEditable,
    models: []
  };
};

exports.biFactory = biFactory;
//# sourceMappingURL=index.js.map