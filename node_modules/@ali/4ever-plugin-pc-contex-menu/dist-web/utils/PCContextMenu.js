import * as React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import ReactDOM from 'react-dom';
import { Controller, useScrollableContent } from '@ali/4ever-cangjie';
import { ActiveInteractionHooks } from '@ali/4ever-component';
import { EMenuMode, Menu, MenuDivider, MenuItem, Tooltip } from '@ali/we-design';
import { memoize } from 'lodash-es';
import { hotKeyToReadableString, toPx } from "./util";
import { MenuGroup, MenuWrapper, MenuItem as MenuInnerItem, Icon, HotKey, Inflat, Name } from "./styled";
import { closeContextMenu } from "./actions";
var PADDING = 28;
var useActiveInteraction = ActiveInteractionHooks.useActiveInteraction;

var _ref = /*#__PURE__*/_createElement(Inflat, null);

var _ref2 = /*#__PURE__*/_createElement("div", {
  "data-testid": "contextmenu-divider"
}, /*#__PURE__*/_createElement(MenuDivider, null));

var ContextMenu = function ContextMenu(props) {
  var controller = props.controller,
      scrollableContent = props.scrollableContent,
      _props$contextData = props.contextData,
      contextData = _props$contextData === void 0 ? {
    x: 100,
    y: 100
  } : _props$contextData,
      zoom = props.zoom;
  var containerRef = React.useRef(null);
  /**
   * 阻止默认事件，防止文档区域失焦
   */

  var handleMouseDown = React.useCallback(function (ev) {
    var _ev$target;

    if (((_ev$target = ev.target) == null ? void 0 : _ev$target.tagName.toLocaleLowerCase()) !== 'input') {
      // 放过input，以便输入地方可以正常输入
      ev.preventDefault && ev.preventDefault();
      ev.stopPropagation && ev.stopPropagation();
    }
  }, []);
  var close = React.useCallback(function () {
    controller.run('onAction', closeContextMenu());
  }, [controller]);
  React.useEffect(function () {
    var node = containerRef.current;
    var child = node == null ? void 0 : node.firstElementChild;

    if (!node || !child) {
      return function () {};
    }

    var animId = window.requestAnimationFrame(function () {
      var style = {};
      var _window = window,
          innerWidth = _window.innerWidth,
          innerHeight = _window.innerHeight;
      var containerClientRect = scrollableContent.getBoundingClientRect();

      var _child$getBoundingCli = child.getBoundingClientRect(),
          width = _child$getBoundingCli.width,
          height = _child$getBoundingCli.height;

      if (contextData.x + width <= innerWidth - PADDING) {
        style.left = toPx((contextData.x - containerClientRect.left) / zoom);
      } else {
        style.left = toPx((innerWidth - PADDING - width - containerClientRect.left) / zoom);
      }

      if (contextData.y + height <= innerHeight - PADDING) {
        style.top = toPx((contextData.y - containerClientRect.top) / zoom);
      } else {
        style.top = toPx((innerHeight - PADDING - height - containerClientRect.top) / zoom);
      }

      Object.keys(style).forEach(function (key) {
        node.style[key] = style[key];
      });
      node.style.opacity = '1';
    });
    return function () {
      if (animId) {
        window.cancelAnimationFrame(animId);
      }
    };
  }, [scrollableContent, contextData.x, contextData.y, zoom]);
  var menus = controller.run('contextMenu');
  var menuGroups = [];
  menus.forEach(function (menu) {
    var _menu$options;

    var groupId = ((_menu$options = menu.options) == null ? void 0 : _menu$options.group) || 0;
    var group = menuGroups[groupId] || [];
    group.push(menu);
    menuGroups[groupId] = group;
  });
  var menuGroupKeys = Object.keys(menuGroups).sort(function (a, b) {
    return Number(a) - Number(b);
  }); // eslint-disable-next-line react-hooks/exhaustive-deps

  var createActionHandler = React.useCallback(memoize(function (menu) {
    return function () {
      var action = menu.action,
          options = menu.options,
          onClick = menu.onClick;
      action && controller.run('onAction', action);
      onClick && onClick();

      if (!(options != null && options.keepMenu)) {
        close();
      }
    };
  }), [close]);
  React.useEffect(function () {
    function onKeyDown(event) {
      if (event.key === 'Escape' || event.key === 'Esc') {
        close();
      }
    }

    document.addEventListener('keydown', onKeyDown);
    return function () {
      document.removeEventListener('keydown', onKeyDown);
    };
  }, [controller, close]);

  var _useActiveInteraction = useActiveInteraction(),
      activeType = _useActiveInteraction[0],
      setActiveType = _useActiveInteraction[1];

  var activeRef = React.useRef('');
  activeRef.current = activeType;
  React.useEffect(function () {
    if (menus.length > 0) {
      setActiveType('contextMenu');
    } else if (activeRef.current === 'contextMenu') {
      setActiveType('');
    }
  }, [menus, setActiveType]);
  React.useEffect(function () {
    return function () {
      setActiveType('');
    };
  }, []);

  if (!menus.length) {
    close();
    return null;
  }

  return /*#__PURE__*/_createElement(MenuWrapper, {
    "data-testid": "bi-contextmenu",
    "data-role": "pcContextMenu",
    onMouseDown: handleMouseDown,
    ref: containerRef
  }, /*#__PURE__*/_createElement(Menu, {
    mode: EMenuMode.vertical
  }, menuGroupKeys.map(function (group, index) {
    var renderMenus = menuGroups[group];
    var showDivider = index !== menuGroupKeys.length - 1;
    return /*#__PURE__*/_createElement(MenuGroup, {
      key: group,
      "data-testid": "contextmenu-group"
    }, renderMenus.map(function (menu) {
      var name = menu.name,
          _menu$options2 = menu.options,
          options = _menu$options2 === void 0 ? {} : _menu$options2,
          menuKey = menu.key,
          role = menu.role;
      var disable = options.disable,
          checked = options.checked,
          icon = options.icon,
          hotKey = options.hotKey,
          inline = options.inline;
      var itemStyle = inline ? {
        display: 'inline-flex',
        minWidth: 0,
        backgroundColor: checked ? 'rgba(25,31,37,0.12)' : undefined,
        height: 26,
        padding: '0 4px',
        borderRadius: 5
      } : {};
      return /*#__PURE__*/_createElement(MenuItem, {
        key: menuKey,
        menuKey: menuKey,
        testid: menuKey,
        onClick: createActionHandler(menu),
        selected: inline ? false : checked,
        disabled: disable,
        autoClose: false,
        style: itemStyle,
        role: role
      }, /*#__PURE__*/_createElement(Tooltip, {
        title: name,
        placement: "top",
        zIndex: 10001,
        disabled: !(inline && icon)
      }, /*#__PURE__*/_createElement(MenuInnerItem, {
        "data-checked": checked,
        "data-testid": group + "-" + menuKey,
        inline: inline
      }, icon ? /*#__PURE__*/_createElement(Icon, null, icon) : null, inline && icon ? null : /*#__PURE__*/_createElement(Name, null, name), _ref, /*#__PURE__*/_createElement(HotKey, {
        disabled: disable
      }, hotKeyToReadableString(hotKey || '')))));
    }), showDivider ? _ref2 : null);
  })));
};

export default function PCContextMenu(props) {
  var mountRoot = props.mountRoot;
  var controller = Controller.useController();
  var defaultContent = useScrollableContent() || document.body;
  var scrollableContent = mountRoot ? document.body : defaultContent; // 由于挂载点变更，zoom 暂时不需要了。后续如果再有变更，可以重新在这里加回来

  var _controller$value = controller.value,
      data = _controller$value.data,
      isFocused = _controller$value.isFocused,
      selection = _controller$value.selection;
  var contextData = data.contextData;
  var shouldRenderContextMenu = isFocused && contextData;

  if (!shouldRenderContextMenu || !selection) {
    return null;
  }

  return /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/_createElement(ContextMenu, {
    controller: controller,
    scrollableContent: scrollableContent,
    contextData: contextData,
    zoom: 1
  }), scrollableContent);
}
//# sourceMappingURL=PCContextMenu.js.map