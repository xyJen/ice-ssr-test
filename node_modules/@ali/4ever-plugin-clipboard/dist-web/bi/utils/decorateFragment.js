import { Text } from '@ali/4ever-cangjie';
import { isEqual } from 'lodash-es'; // marks type

var FONT_TYPE = 'fonts';
var SZ_TYPE = 'sz';
/**
 * @description 获取光标所在 leaf 节点的 marks
 * @param {controller}
 * */

export function getMarksAtAnchor(controller) {
  var _controller$value = controller.value,
      document = _controller$value.document,
      selection = _controller$value.selection;
  var anchor = selection.anchor;
  var anchorNode = document.getNode(anchor.key);

  if (Text.isText(anchorNode) && anchor.isTextPoint()) {
    var position = 0;
    var anchorLeaf = anchorNode.leaves.find(function (leaf) {
      position += leaf.text.length;
      return position >= anchor.offset;
    });
    return [].concat((anchorLeaf == null ? void 0 : anchorLeaf.marks) || []);
  }

  return [];
}

function isSameFontSize(fragment) {
  var defaultSz;
  var Firstflag = false;
  var isDifferent = fragment.someDescendant(function (node) {
    if (Text.isText(node)) {
      var szMark = node.getMarks().find(function (mark) {
        return mark.type === SZ_TYPE;
      });

      if (!Firstflag) {
        defaultSz = szMark;
        Firstflag = true;
      }

      if (!isEqual(defaultSz, szMark)) {
        return true;
      }
    }

    return false;
  });
  return !isDifferent;
}
/**
 * @description
 *  非仓颉内容修饰加工
 *  1. 移除字体类型;
 *  2. 粘贴内容字号相同时，自动与目标字体大小合并
 * @param {Controller} controller
 * @param {Document} fragment
 */


export function decorateFragment(controller, fragment) {
  var marks = getMarksAtAnchor(controller).filter(function (mark) {
    return [FONT_TYPE, SZ_TYPE].includes(mark.type);
  });
  var szMark = marks.filter(function (mark) {
    return mark.type === SZ_TYPE;
  });
  var isSameSz = isSameFontSize(fragment);
  var newFragment = fragment.mapDescendants(function (node) {
    var child = node;

    if (!Text.isText(child)) {
      return child;
    }

    child.marks.forEach(function (mark) {
      if (mark.type === FONT_TYPE || mark.type === SZ_TYPE && isSameSz) {
        child = child.removeMark(0, child.text.length, mark);
      }
    });

    if (isSameSz) {
      return child.addMarks(0, child.text.length, szMark);
    }

    return child;
  });
  return newFragment;
}
//# sourceMappingURL=decorateFragment.js.map