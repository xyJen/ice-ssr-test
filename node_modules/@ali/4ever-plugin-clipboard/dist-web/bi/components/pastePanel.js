import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import ReactDOM from 'react-dom';
import { useZoom, useZoomContainer, domUtils } from '@ali/4ever-cangjie';
import logger from '@ali/4ever-logger';
import { getPointAndBlockOnSelection, mimeTypes as MIME } from '@ali/4ever-utils';
import { PastePanel as Panel } from '@ali/we-toolbar';
import { useOnClickOutside } from '@ali/4ever-component';
import { insertFragment, deleteAtRange, hidePastePanel, insertMatchFragment, insertTextFragment, hideCustomPastePanel } from "../actions";
import { CARET_HEIGHT, MATCH_FORMAT, DEFAULT_PASTE_MODES, PASTE_MODES, SOURCE_FROMAT, TEXT_FORMAT } from "../../utils/constants";
import { PanelWrapper, PanelWrapper4Custom } from "./styled";
import { isDingDocs } from "../../utils/tester";

function PastePanel(props) {
  var controller = props.controller,
      clipboardPad = props.clipboardPad,
      customPanel = props.customPanel,
      _props$locale = props.locale,
      locale = _props$locale === void 0 ? {} : _props$locale,
      config = props.config;
  var pasteOptions = locale.pasteOptions;
  var document = controller.value.document;

  var _controller$value$dat = controller.value.data._clipboardPanel,
      _clipboardPanel = _controller$value$dat === void 0 ? '' : _controller$value$dat;

  var updatePosTimer = useRef(0);

  var _useState = useState(false),
      panelVisible = _useState[0],
      setPanelVisible = _useState[1];

  var panelRef = useRef(null);
  var editorContainer = useZoomContainer() || window.document.body;

  var getContainer = props.getContainer || function () {
    return editorContainer;
  };

  var zoom = useZoom();
  var root = window.document.querySelectorAll("[data-cangjie-key=\"" + document.key + "\"]")[0];
  var hidePanel = useCallback(function () {
    setPanelVisible(false);
    controller.run('onAction', hidePastePanel());
  }, [controller]);
  var hideCustomPanel = useCallback(function () {
    setPanelVisible(false);
    controller.run('onAction', hideCustomPastePanel());
  }, [controller]); // 显示并更新粘贴面板位置

  var updatePosition = useCallback(function () {
    try {
      var pointAndBlock = getPointAndBlockOnSelection(controller);
      var endPoint = pointAndBlock.endPoint; // 防止找光标位置时报错导致页面crash

      var rect = domUtils.findCaretPosition(endPoint, 'end', root);

      if (rect && editorContainer) {
        var containerRect = editorContainer.getBoundingClientRect();

        if (!panelVisible) {
          setPanelVisible(true);
        }

        var panelDom = panelRef.current;

        if (panelDom) {
          var caret = domUtils.getCaretDom(editorContainer);
          var caretHeight = caret ? caret.offsetHeight : CARET_HEIGHT;
          panelDom.style.left = (rect.clientLeft - containerRect.left) / zoom + "px";
          panelDom.style.top = (rect.clientTop - containerRect.top) / zoom + caretHeight + "px";
        }
      } else if (!rect) {
        // 找不到光标时，将面板隐藏掉，防止再次聚焦时显示位置不准确
        if (customPanel) {
          hideCustomPanel();
        } else {
          hidePanel();
        }
      }
    } catch (e) {
      logger.error(e);
    }
  }, [controller, customPanel, editorContainer, hideCustomPanel, hidePanel, panelVisible, root]); // 切换粘贴模式

  var onSwitchMode = useCallback(function (mode, e) {
    e == null ? void 0 : e.preventDefault();
    e == null ? void 0 : e.stopPropagation();
    var clipboardData = clipboardPad.getClipboardDataCache();
    if (!clipboardData || !mode) return; // 删除Decoration组成选区之间的内容，重新插入新模式内

    controller.run('onAction', deleteAtRange());
    logger.sum("paste_mode_" + mode);
    var fragment;

    if (mode === SOURCE_FROMAT) {
      // 原格式粘贴
      fragment = clipboardData == null ? void 0 : clipboardData.getFragment();

      if (fragment) {
        controller.run('onAction', insertFragment(fragment));
      }
    } else if (mode === MATCH_FORMAT) {
      // 匹配粘贴
      fragment = clipboardData == null ? void 0 : clipboardData.getFragment();

      if (fragment) {
        controller.run('onAction', insertMatchFragment(fragment));
      }
    } else if (mode === TEXT_FORMAT) {
      // 纯文本粘贴
      fragment = clipboardData == null ? void 0 : clipboardData.getTextFragment();

      if (fragment) {
        controller.run('onAction', insertTextFragment(fragment));
      }
    } else if (mode === PASTE_MODES.markdownToDoc) {
      _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var st, frag, extraData, _props$beforeInsertMa;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                st = Date.now();
                _context.next = 3;
                return clipboardData == null ? void 0 : clipboardData.getMarkdownFragment();

              case 3:
                frag = _context.sent;
                extraData = null;

                if (props.beforeInsertMarkdown) {
                  _props$beforeInsertMa = props.beforeInsertMarkdown(frag);
                  frag = _props$beforeInsertMa[0];
                  extraData = _props$beforeInsertMa[1];
                }

                controller.run('onAction', insertFragment(frag));

                if (props.afterInsertMarkdown) {
                  props.afterInsertMarkdown(extraData);
                }

                logger.perf('markdown_to_value_time', Date.now() - st);

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))()["catch"](function (e) {
        logger.error(e);
        console.error('paste markdown error', e);
      });
    }
  }, [clipboardPad, controller]);
  var onCustomSwitchMode = useCallback(function (key, e) {
    e == null ? void 0 : e.preventDefault();
    e == null ? void 0 : e.stopPropagation();
    var clipboardData = clipboardPad.getClipboardDataCache();
    if (!clipboardData || !customPanel) return;
    customPanel == null ? void 0 : customPanel.onChange(key, function () {
      return controller.run('onAction', deleteAtRange());
    });
    hideCustomPanel();
  }, [clipboardPad, controller, customPanel, hideCustomPanel]);
  useEffect(function () {
    if (_clipboardPanel != null && _clipboardPanel.startsWith('show')) {
      // 有粘贴操作时，更新粘贴按钮位置
      cancelAnimationFrame(updatePosTimer.current);
      updatePosTimer.current = window.requestAnimationFrame(updatePosition);
    }

    return function () {
      if (updatePosTimer.current) {
        cancelAnimationFrame(updatePosTimer.current);
      }
    };
  });
  var onClickPastePanel = useCallback(function (event) {
    event.preventDefault();
    event.stopPropagation();
  }, []);
  var handleClickOutside = useCallback(function (event) {
    var _panelRef$current;

    if (panelRef.current && !((_panelRef$current = panelRef.current) != null && _panelRef$current.contains(event.target)) && !event.target.closest('.ModeMenu')) {
      if (customPanel) {
        hideCustomPanel();
      } else {
        hidePanel();
      }
    }
  }, [customPanel, hideCustomPanel, hidePanel]);
  useOnClickOutside(panelRef, handleClickOutside, false);
  var clipboardData = clipboardPad.getClipboardDataCache();
  var builtinOptions = useMemo(function () {
    if (customPanel) {
      return [];
    }

    var options = [].concat(DEFAULT_PASTE_MODES);

    if (clipboardData != null && clipboardData.maybeMarkdown) {
      options.unshift(PASTE_MODES.markdownToDoc);
    }

    return options;
  }, [clipboardData, customPanel]);
  var autoUnfold = useMemo(function () {
    if (clipboardData && !isDingDocs(clipboardData) && clipboardData.types.includes(MIME.TEXT_HTML)) {
      return true;
    }

    return clipboardData == null ? void 0 : clipboardData.maybeMarkdown;
  }, [clipboardData]);

  if (customPanel) {
    var _panel = /*#__PURE__*/_createElement(PanelWrapper4Custom, {
      ref: panelRef,
      "data-testid": "pastePanel"
    }, /*#__PURE__*/_createElement(Panel, {
      hideSplitBtton: true,
      options: customPanel == null ? void 0 : customPanel.options,
      onChange: onCustomSwitchMode,
      autoUnfold: clipboardData == null ? void 0 : clipboardData.maybeMarkdown,
      getContainer: getContainer,
      title: pasteOptions
    }));

    return panelVisible && editorContainer ? /*#__PURE__*/ReactDOM.createPortal(_panel, editorContainer) : /*#__PURE__*/_createElement(React.Fragment, null);
  }

  var panel = /*#__PURE__*/_createElement(PanelWrapper, {
    ref: panelRef,
    "data-testid": "pastePanel",
    onMouseDown: onClickPastePanel
  }, /*#__PURE__*/_createElement(Panel, {
    options: builtinOptions,
    onChange: onSwitchMode,
    title: pasteOptions,
    autoUnfold: autoUnfold,
    getContainer: getContainer,
    shouldSelectFirstItem: false
  }));

  return panelVisible && editorContainer ? /*#__PURE__*/ReactDOM.createPortal(panel, editorContainer) : /*#__PURE__*/_createElement(React.Fragment, null);
}

export default PastePanel;
//# sourceMappingURL=pastePanel.js.map