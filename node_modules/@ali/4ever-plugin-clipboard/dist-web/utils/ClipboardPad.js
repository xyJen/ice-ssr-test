import _construct from "@babel/runtime/helpers/construct";
import _extends from "@babel/runtime/helpers/extends";

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import { transferUtils, Value } from '@ali/4ever-cangjie';
import { flatten } from 'lodash-es';
import ClipboardData from "./ClipboardData";
import { isEqual } from 'lodash-es';
import { toHash, mimeTypes } from '@ali/4ever-utils';
import getHtmlFromValue from "./getHtmlFromValue";
/**
 * 剪切板实例缓存缓存
 */

var clipboardPadMap = new Map();
/**
 * 当前的剪切事件
 * @description 我们假设同一次剪切板时间只能被一个编辑器实例消费，所以目前可能存在的情况是 ClipboardPad 是多实例，但是
 * 读取到的 ClipboardData 是单实例的。
 * TODO: 后续需要考虑在 Plugin 层如何设计一个多实例的配置
 */

var currentClipboardData = null;

var ClipboardPad = /*#__PURE__*/function () {
  /**
   * 获得一个剪切板，使用配置数据作为 union 单位，针对不同的 config 实例返回不同的剪切板
   * @param config 编辑器的配置
   */
  ClipboardPad.getClipboardPad = function getClipboardPad(conf, key) {
    if (key === void 0) {
      key = 'default';
    }

    // 默认使用 mo 的正反序列化
    var config = _extends({}, conf, {
      serializer: conf.serializer
    });

    var clipboardPadCache = clipboardPadMap.get(key);

    if (clipboardPadCache) {
      if (isEqual(clipboardPadCache.config, config)) {
        return clipboardPadCache;
      }
    }

    var clipboardPad = ClipboardPad.createClipboardPad(config);

    if (key) {
      clipboardPadMap.set(key, clipboardPad);
    }

    return clipboardPad;
  };

  ClipboardPad.createClipboardPad = function createClipboardPad(config) {
    return new ClipboardPad(config);
  }
  /**
   * 剪切板配置
   */
  ;

  function ClipboardPad(config) {
    this.config = void 0;
    this.models = void 0;
    this.config = config;
  }
  /**
   * 读取剪切板数据，相同的 event 会读取到同一个实例
   * @param event
   */


  var _proto = ClipboardPad.prototype;

  _proto.getClipboardData = function getClipboardData(event) {
    var _currentClipboardData;

    var args = [event.clipboardData, this.config, this.models]; // @ts-ignore

    if ((_currentClipboardData = currentClipboardData) != null && _currentClipboardData.isEqual.apply(_currentClipboardData, args)) {
      return currentClipboardData;
    } // @ts-ignore


    currentClipboardData = _construct(ClipboardData, args);
    return currentClipboardData;
  }
  /**
   * 读取剪切板缓存数据，切换不同粘贴模式下使用
   * @param event
   */
  ;

  _proto.getClipboardDataCache = function getClipboardDataCache() {
    return currentClipboardData;
  }
  /**
   * 拷贝一个 fragment
   * @param event 拷贝事件
   * @param fragment
   */
  ;

  _proto.copyFragment = function copyFragment(event, fragment) {
    var clipboardData = event.clipboardData;

    if (!clipboardData) {
      return;
    }

    event.preventDefault();
    var serializer = this.config.serializer;
    var value = Value.create({
      document: fragment
    });
    var text = serializer.valueToText(value);
    var html = getHtmlFromValue(serializer, value);
    var encoded = transferUtils.encodeFragment(fragment);
    clipboardData.setData(mimeTypes.TEXT_PLAIN, text);
    clipboardData.setData(mimeTypes.TEXT_HTML, html);
    clipboardData.setData(mimeTypes.APPLICATION_CANGJIE_FRAGMENT, encoded);
  };

  _proto.initPluginModels = function initPluginModels(controller) {
    var models = this.getPluginModels(controller);
    var pidStr = '';

    for (var _iterator = _createForOfIteratorHelperLoose(models.keys()), _step; !(_step = _iterator()).done;) {
      var model = _step.value;
      pidStr += model;
    }

    models.set('controllerPid', toHash(pidStr));
    this.models = models;
  }
  /**
   * 获取所有插件内容的models map集合
   * @param
   */
  ;

  _proto.getPluginModels = function getPluginModels(controller) {
    var infoMap = new Map(); // @ts-ignore

    var models = controller.handlers.models;

    if (models) {
      var flatModels = flatten(models);
      flatModels.forEach(function (info) {
        if (info) {
          // @ts-ignore
          var infoKey = info.klass + "_" + info.type; // @ts-ignore

          var infoData = info.data || {};
          var oldValue = infoMap.get(infoKey);

          if (oldValue) {
            if (Array.isArray(oldValue)) {
              infoMap.set(infoKey, oldValue.concat(infoData));
            } else {
              infoMap.set(infoKey, [oldValue, infoData]);
            }
          } else {
            // @ts-ignore
            infoMap.set(infoKey, [infoData]);
          }
        }
      });
    }

    return infoMap;
  };

  return ClipboardPad;
}();

ClipboardPad.getCachedClipboardPad = function (key) {
  if (key === void 0) {
    key = 'default';
  }

  return clipboardPadMap.get(key);
};

export default ClipboardPad;
//# sourceMappingURL=ClipboardPad.js.map