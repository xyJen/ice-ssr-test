{"version":3,"sources":["../../../src/utils/restructFragment.ts"],"names":["Block","Document","Inline","Text","Mark","flatten","omit","CheckStatus","klassRule","match","isMark","klass","isText","isDocument","isInline","isBlock","getNodeKlass","node","find","rule","flattenNode","array","reduce","result","current","nodes","concat","push","parseDataType","dataType","Array","isArray","checkDataType","receiveData","expectData","Object","keys","length","success","necessaryType","filter","field","type","includes","undefined","conformNecessary","every","failed","receiveDataTypes","redundance","allowTypes","actual","hasType","some","actualIsObj","typeName","name","toLowerCase","randundance","getModelVal","modelsMap","get","join","isKnown","modelVal","Boolean","processWithNode","results","map","val","data","successResult","randundanceResult","forEach","rst","set","restructFragment","fragment","restructure","oldNode","isKnownNode","restructNodes","create","key","leaves","leaf","marks","mark","isKnownMark","newMark"],"mappings":"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","sourcesContent":["import { Block, Document, Inline, Text, Mark } from '@ali/4ever-cangjie';\nimport { flatten } from 'lodash-es';\nimport { omit } from 'lodash-es';\nimport { ModelsMap } from './types';\n\nenum CheckStatus {\n  success,\n  failed,\n  randundance,\n}\n\ntype CheckDataResult = [CheckStatus.success | CheckStatus.failed | CheckStatus.randundance, object];\n\nconst klassRule = [\n  {\n    match: Mark.isMark,\n    klass: 'mark',\n  },\n  {\n    match: Text.isText,\n    klass: 'text',\n  },\n  {\n    match: Document.isDocument,\n    klass: 'document',\n  },\n  {\n    match: Inline.isInline,\n    klass: 'inline',\n  },\n  {\n    match: Block.isBlock,\n    klass: 'block',\n  },\n];\n\nconst getNodeKlass = (node: Block | Mark): string => {\n  return klassRule.find((rule) => rule.match(node))?.klass || '';\n};\n\nexport const flattenNode = (array) => {\n  return array.reduce((result, current) => {\n    if (current.nodes) {\n      result.concat(current.nodes);\n    } else {\n      result.push(current);\n    }\n    return result;\n  }, []);\n};\n\nfunction parseDataType(dataType: string | string[]): string[] {\n  if (Array.isArray(dataType)) {\n    return dataType;\n  }\n  return [dataType];\n}\n// success -> 校验成功, failed -> 校验失败, redundance -> 校验成功，但有冗余字段\nfunction checkDataType(\n  receiveData: object,\n  expectData?: object,\n): CheckDataResult {\n  // models 中未定义 data 类型，默认为类型校验成功\n  if (!expectData || Object.keys(expectData).length === 0) {\n    return [CheckStatus.success, receiveData];\n  }\n\n  // 从 models 中找出必须有的字段（即非 undefined 类型）\n  const necessaryType = Object.keys(expectData).filter((field) => {\n    const type = expectData[field];\n    return !(Array.isArray(type) && type.includes(undefined));\n  });\n\n  // 校验 node 节点属性上是否有 models 中定义的必须有的字段\n  const conformNecessary = necessaryType.every((field) => {\n    return receiveData[field];\n  });\n\n  // node 缺少必有字段，类型校验失败\n  if (!conformNecessary) {\n    return [CheckStatus.failed, receiveData];\n  }\n\n  // 对 node 上的属性进行类型校验\n  const receiveDataTypes = Object.keys(receiveData);\n  if (receiveDataTypes.length === 0) {\n    return [CheckStatus.success, receiveData];\n  }\n  const redundance: string[] = [];\n  for (const field of receiveDataTypes) {\n    // node 中 存在 models data 中未定义的字段，类型校验失败\n    if (!expectData[field]) {\n      redundance.push(field);\n      continue;\n    }\n\n    // 解析 model.data 字段中允许的类型\n    const allowTypes = parseDataType(expectData[field]);\n\n    // 获取真实节点上对应属性的类型\n    const actual = receiveData[field];\n    const hasType = allowTypes.some((type: any) => {\n      const actualIsObj = actual instanceof Object;\n      if (!type) {\n        // 对 undefined、null 类型的 type 做校验\n        return actual === type;\n      } else if (actualIsObj) {\n        // 这里对 actual 是 Array、Object 类型作区分\n        if (Array.isArray(actual) && !type.isArray) {\n          return false;\n        }\n        return actual instanceof type;\n      };\n      // instanceof 只能通过原型链判断，例如 'abc' instanceof String, 结果是 false\n      const typeName = type.name?.toLowerCase();\n      // eslint-disable-next-line valid-typeof\n      return typeof actual === typeName;\n    });\n\n    // 类型校验\n    if (!hasType) {\n      return [CheckStatus.failed, receiveData];\n    }\n  }\n  if (redundance.length > 0) {\n    return [CheckStatus.randundance, omit(receiveData, redundance)];\n  }\n  return [CheckStatus.success, receiveData];\n}\n\nfunction getModelVal(node, modelsMap) {\n  const klass = getNodeKlass(node);\n  const keys = [klass, node.type];\n  return modelsMap.get(keys.join('_'));\n}\n\nconst isKnown = (node: Block | Mark, modelsMap): boolean => {\n  const klass = getNodeKlass(node);\n  const modelVal = getModelVal(node, modelsMap);\n  return Boolean(modelVal) || klass === 'document';\n};\n\nfunction processWithNode(node, modelsMap) {\n  const klass = getNodeKlass(node);\n  if (klass === 'document') {\n    return [true, node];\n  }\n  if (isKnown(node, modelsMap)) {\n    const modelVal = getModelVal(node, modelsMap);\n    const results = modelVal.map((val) => checkDataType(node.data, val));\n    const successResult: any[] = [];\n    const randundanceResult: any[] = [];\n    results.forEach((rst) => {\n      if (rst[0] === CheckStatus.success) {\n        successResult.push(rst);\n      } else if (rst[0] === CheckStatus.randundance) {\n        randundanceResult.push(rst);\n      }\n    });\n    if (successResult.length > 0) {\n      return [true, node];\n    }\n    if (randundanceResult.length > 0) {\n      return [true, node.set('data', randundanceResult[CheckStatus.success][1])];\n    }\n    return [false, node];\n  }\n  return [false, node];\n}\n\nexport function restructFragment(\n  fragment: Document,\n  modelsMap: ModelsMap,\n): Document {\n  const restructure = (oldNode) => {\n    const [isKnownNode, node] = processWithNode(oldNode, modelsMap);\n    if (isKnownNode) {\n      if (node.nodes) {\n        return [node.set('nodes', flatten(node.nodes.map(restructure)))];\n      }\n      return [node];\n    }\n    if (node.nodes) {\n      const klass = getNodeKlass(node);\n      if (klass === 'block') {\n        return [\n          node\n            .set('type', 'paragraph')\n            .set('nodes', restructNodes(node.nodes))\n            .set('data', {}),\n        ];\n      }\n      return flattenNode(flatten(node.nodes.map(restructure)));\n    }\n    if (Text.isText(node)) {\n      return [\n        Text.create({\n          key: node.key,\n          leaves: node.leaves.map((leaf) => {\n            const marks: Mark[] = [];\n            leaf.marks.forEach((mark) => {\n              const [isKnownMark, newMark] = processWithNode(mark, modelsMap);\n              if (isKnownMark) {\n                marks.push(newMark);\n              }\n            });\n            return leaf.set('marks', marks);\n          }),\n        }),\n      ];\n    }\n    return [node];\n  };\n  const restructNodes = (nodes) => flatten(nodes.map(restructure));\n  const [result] = restructure(fragment);\n  return result;\n}\n"],"file":"restructFragment.js"}