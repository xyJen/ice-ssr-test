import { Block, Document, Inline, Text, Mark } from '@ali/4ever-cangjie';
import { flatten } from 'lodash-es';
import { omit } from 'lodash-es';
var CheckStatus;

(function (CheckStatus) {
  CheckStatus[CheckStatus["success"] = 0] = "success";
  CheckStatus[CheckStatus["failed"] = 1] = "failed";
  CheckStatus[CheckStatus["randundance"] = 2] = "randundance";
})(CheckStatus || (CheckStatus = {}));

var klassRule = [{
  match: Mark.isMark,
  klass: 'mark'
}, {
  match: Text.isText,
  klass: 'text'
}, {
  match: Document.isDocument,
  klass: 'document'
}, {
  match: Inline.isInline,
  klass: 'inline'
}, {
  match: Block.isBlock,
  klass: 'block'
}];

var getNodeKlass = function getNodeKlass(node) {
  var _klassRule$find;

  return ((_klassRule$find = klassRule.find(function (rule) {
    return rule.match(node);
  })) == null ? void 0 : _klassRule$find.klass) || '';
};

export var flattenNode = function flattenNode(array) {
  return array.reduce(function (result, current) {
    if (current.nodes) {
      result.concat(current.nodes);
    } else {
      result.push(current);
    }

    return result;
  }, []);
};

function parseDataType(dataType) {
  if (Array.isArray(dataType)) {
    return dataType;
  }

  return [dataType];
} // success -> 校验成功, failed -> 校验失败, redundance -> 校验成功，但有冗余字段


function checkDataType(receiveData, expectData) {
  // models 中未定义 data 类型，默认为类型校验成功
  if (!expectData || Object.keys(expectData).length === 0) {
    return [CheckStatus.success, receiveData];
  } // 从 models 中找出必须有的字段（即非 undefined 类型）


  var necessaryType = Object.keys(expectData).filter(function (field) {
    var type = expectData[field];
    return !(Array.isArray(type) && type.includes(undefined));
  }); // 校验 node 节点属性上是否有 models 中定义的必须有的字段

  var conformNecessary = necessaryType.every(function (field) {
    return receiveData[field];
  }); // node 缺少必有字段，类型校验失败

  if (!conformNecessary) {
    return [CheckStatus.failed, receiveData];
  } // 对 node 上的属性进行类型校验


  var receiveDataTypes = Object.keys(receiveData);

  if (receiveDataTypes.length === 0) {
    return [CheckStatus.success, receiveData];
  }

  var redundance = [];

  var _loop = function _loop() {
    var field = _receiveDataTypes[_i];

    // node 中 存在 models data 中未定义的字段，类型校验失败
    if (!expectData[field]) {
      redundance.push(field);
      return "continue";
    } // 解析 model.data 字段中允许的类型


    var allowTypes = parseDataType(expectData[field]); // 获取真实节点上对应属性的类型

    var actual = receiveData[field];
    var hasType = allowTypes.some(function (type) {
      var _type$name;

      var actualIsObj = actual instanceof Object;

      if (!type) {
        // 对 undefined、null 类型的 type 做校验
        return actual === type;
      } else if (actualIsObj) {
        // 这里对 actual 是 Array、Object 类型作区分
        if (Array.isArray(actual) && !type.isArray) {
          return false;
        }

        return actual instanceof type;
      }

      ; // instanceof 只能通过原型链判断，例如 'abc' instanceof String, 结果是 false

      var typeName = (_type$name = type.name) == null ? void 0 : _type$name.toLowerCase(); // eslint-disable-next-line valid-typeof

      return typeof actual === typeName;
    }); // 类型校验

    if (!hasType) {
      return {
        v: [CheckStatus.failed, receiveData]
      };
    }
  };

  for (var _i = 0, _receiveDataTypes = receiveDataTypes; _i < _receiveDataTypes.length; _i++) {
    var _ret = _loop();

    if (_ret === "continue") continue;
    if (typeof _ret === "object") return _ret.v;
  }

  if (redundance.length > 0) {
    return [CheckStatus.randundance, omit(receiveData, redundance)];
  }

  return [CheckStatus.success, receiveData];
}

function getModelVal(node, modelsMap) {
  var klass = getNodeKlass(node);
  var keys = [klass, node.type];
  return modelsMap.get(keys.join('_'));
}

var isKnown = function isKnown(node, modelsMap) {
  var klass = getNodeKlass(node);
  var modelVal = getModelVal(node, modelsMap);
  return Boolean(modelVal) || klass === 'document';
};

function processWithNode(node, modelsMap) {
  var klass = getNodeKlass(node);

  if (klass === 'document') {
    return [true, node];
  }

  if (isKnown(node, modelsMap)) {
    var modelVal = getModelVal(node, modelsMap);
    var results = modelVal.map(function (val) {
      return checkDataType(node.data, val);
    });
    var successResult = [];
    var randundanceResult = [];
    results.forEach(function (rst) {
      if (rst[0] === CheckStatus.success) {
        successResult.push(rst);
      } else if (rst[0] === CheckStatus.randundance) {
        randundanceResult.push(rst);
      }
    });

    if (successResult.length > 0) {
      return [true, node];
    }

    if (randundanceResult.length > 0) {
      return [true, node.set('data', randundanceResult[CheckStatus.success][1])];
    }

    return [false, node];
  }

  return [false, node];
}

export function restructFragment(fragment, modelsMap) {
  var restructure = function restructure(oldNode) {
    var _processWithNode = processWithNode(oldNode, modelsMap),
        isKnownNode = _processWithNode[0],
        node = _processWithNode[1];

    if (isKnownNode) {
      if (node.nodes) {
        return [node.set('nodes', flatten(node.nodes.map(restructure)))];
      }

      return [node];
    }

    if (node.nodes) {
      var klass = getNodeKlass(node);

      if (klass === 'block') {
        return [node.set('type', 'paragraph').set('nodes', restructNodes(node.nodes)).set('data', {})];
      }

      return flattenNode(flatten(node.nodes.map(restructure)));
    }

    if (Text.isText(node)) {
      return [Text.create({
        key: node.key,
        leaves: node.leaves.map(function (leaf) {
          var marks = [];
          leaf.marks.forEach(function (mark) {
            var _processWithNode2 = processWithNode(mark, modelsMap),
                isKnownMark = _processWithNode2[0],
                newMark = _processWithNode2[1];

            if (isKnownMark) {
              marks.push(newMark);
            }
          });
          return leaf.set('marks', marks);
        })
      })];
    }

    return [node];
  };

  var restructNodes = function restructNodes(nodes) {
    return flatten(nodes.map(restructure));
  };

  var _restructure = restructure(fragment),
      result = _restructure[0];

  return result;
}
//# sourceMappingURL=restructFragment.js.map