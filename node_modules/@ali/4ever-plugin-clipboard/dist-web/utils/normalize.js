import _extends from "@babel/runtime/helpers/extends";
import { Block, Text, Path } from '@ali/4ever-cangjie';
import { cloneDeep } from 'lodash-es';
import { flatten } from 'lodash-es';
import { Paragraph } from '@ali/4ever-plugin-paragraph';
import { DEFAULT_PAGE_WIDTH, getRandomId } from '@ali/4ever-utils';

function createParagraph(text) {
  if (text === void 0) {
    text = '';
  }

  return Block.create({
    type: 'paragraph',
    nodes: [Text.create(text)]
  });
}
/**
 * 标记表格矩阵的隐藏单元格
 * @param matrix 表格矩阵
 * @param param1 起止坐标
 * @param param2 扩展跨度
 */


function markTableSpanMatrix(matrix, _ref, _ref2) {
  var row = _ref[0],
      col = _ref[1];
  var rowSpan = _ref2[0],
      colSpan = _ref2[1];

  for (var i = row, rl = row + rowSpan; i < rl; i++) {
    for (var j = col, cl = col + colSpan; j < cl; j++) {
      if (i === row && j === col) {
        continue;
      }

      matrix[i][j] = true;
    }
  }
}
/**
 * 订正表格的 span 属性
 * @param table
 */


function normalizeTableSpan(table) {
  var firstRow = table.nodes[0];

  if (!Block.isBlock(firstRow)) {
    return table;
  }

  var rowSize = table.nodes.length;
  var colSize = firstRow.nodes.length; // 表格矩阵，如果是 hidden 坐标标记为 true
  // 这里我们的遍历顺序是 左 -> 右 上 -> 下

  var tableMatrix = Array(rowSize).fill(0).map(function () {
    return Array(colSize).fill(false);
  });
  var normalizedTableRows = table.nodes.map(function (row, i) {
    if (!Block.isBlock(row)) {
      return row;
    }

    return row.set('nodes', row.nodes.map(function (cell, j) {
      // 非 block 节点，这种情况可能会异常
      if (!Block.isBlock(cell)) {
        return cell;
      } // 如果是标记的 hidden 节点


      if (tableMatrix[i][j]) {
        return cell.set('data', _extends({}, cell.data, {
          rowSpan: 1,
          colSpan: 1,
          hidden: true
        }));
      } // 当前坐标可允许的最大行跨度


      var maxRowSpan = table.nodes.length - i; // 当前坐标可允许的最大列跨度

      var maxColSpan = row.nodes.length - j;
      var rowSpan = Math.min(cell.data.rowSpan, maxRowSpan) || 1;
      var colSpan = Math.min(cell.data.colSpan, maxColSpan) || 1; // 如果单元格有跨度，则进行标记

      if (rowSpan > 1 || colSpan > 1) {
        markTableSpanMatrix(tableMatrix, [i, j], [rowSpan, colSpan]);
      }

      return cell.set('data', _extends({}, cell.data, {
        // 只有在 matrix 中标记的格子才 hidden，否则都不 hidden
        hidden: false,
        rowSpan: rowSpan,
        colSpan: colSpan
      }));
    }));
  });
  var normalizedTable = table.set('nodes', normalizedTableRows);
  return normalizedTable;
}
/**
 * 订正表格的行列，使表格所有行列数量对齐
 * @param table
 */


function normalizeTableMatrix(table) {
  var maxColSize = table.nodes.reduce(function (size, row) {
    if (Block.isBlock(row) && row.type === 'table-row') {
      return Math.max(row.nodes.length, size);
    }

    return size;
  }, -Infinity);
  var normalizedRows = table.nodes.map(function (row) {
    if (Block.isBlock(row) && row.type === 'table-row' && row.nodes.length < maxColSize) {
      // 当前行的列数与最大列数的差值
      var offset = maxColSize - row.nodes.length; // 填充空单元格
      // TODO: 这里与 table 有强耦合，待 @灯少 重构，将 normalize 职责改为由 table 本身出发。这里先通过实现一个创建 table cell 逻辑解耦
      //const fillNodes = Array(offset).fill(0).map(() => createEmptyTableCell());

      var fillNodes = Array(offset).fill(0).map(function () {
        return Block.create({
          data: {
            colSpan: 1,
            rowSpan: 1
          },
          type: 'table-cell',
          nodes: [Block.create({
            type: 'paragraph',
            nodes: [Text.create('')]
          })]
        });
      });
      return row.set('nodes', [].concat(row.nodes, fillNodes));
    }

    return row;
  });
  return table.set('nodes', normalizedRows);
}
/**
 * 订正表格单元格数据
 * @param table
 */


function normalizeTableCell(table) {
  var normalizedTableRows = table.nodes.map(function (tableRow) {
    if (!Block.isBlock(tableRow) || tableRow.type !== 'table-row') {
      return tableRow;
    }

    var normalizedTableCells = tableRow.nodes.map(function (tableCell) {
      if (!Block.isBlock(tableCell) || tableCell.type !== 'table-cell') {
        return tableCell;
      }

      var data = cloneDeep(tableCell.data); // width 脏数据

      delete data.width;
      var normalizedTableCell = tableCell.set('data', data); // 如果 tc 下面是空，或者不是 block 节点，则进行数据订正

      if (normalizedTableCell.nodes.length === 0 || !Block.isBlock(normalizedTableCell.nodes[0])) {
        normalizedTableCell = normalizedTableCell.set('nodes', [createParagraph()]);
      }

      return normalizedTableCell;
    });
    return tableRow.set('nodes', normalizedTableCells);
  });
  return table.set('nodes', normalizedTableRows);
}
/**
 * normalize 表格的数据
 * @param table
 */


function normalizeTable(table) {
  // 空行
  if (table.nodes.length === 0) {
    return createParagraph();
  }

  var firstRow = table.nodes[0]; // 空列

  if (!Block.isBlock(firstRow) || firstRow.nodes.length === 0) {
    return createParagraph();
  } // 填充表格空缺的单元格


  var normalizedTable = normalizeTableMatrix(table); // 填补表格单元格的跨度属性及隐藏属性

  normalizedTable = normalizeTableSpan(normalizedTable);
  var normalizedFirstRow = normalizedTable.nodes[0]; // colsWidth 可能为空，这种情况表格会彻底坏掉

  var _ref3 = normalizedTable.data,
      _ref3$colsWidth = _ref3.colsWidth,
      colsWidth = _ref3$colsWidth === void 0 ? [] : _ref3$colsWidth;
  var colsCount = normalizedFirstRow.nodes.length; // 如果 colsWidth 和列数不相等，则重新计算

  if (colsWidth.length !== colsCount) {
    // 注意这里不会使用 tc 上面的 width，tc.data.width 全部是脏数据
    // 650 的值与 Mo 中对齐，含义是纸张的宽度
    var colWidth = Math.floor(DEFAULT_PAGE_WIDTH / colsCount);
    colsWidth = Array(colsCount).fill(colWidth);
    normalizedTable = normalizedTable.set('data', _extends({}, normalizedTable.data, {
      colsWidth: colsWidth
    }));
  } // 订正表格单元格数据


  normalizedTable = normalizeTableCell(normalizedTable);
  return normalizedTable;
}
/**
 * normalize 末尾断行
 * @param fragment
 */


function normalizeEndLine(fragment) {
  var normalizedFragment = fragment; // 只有拷贝复合内容的情况下才修正表格断行的数据，只有一个表格的情况不处理，在 table 的 clipboard 中有自行的逻辑

  if (fragment.nodes.length !== 1) {
    var tables = fragment.nodes.filter(function (child) {
      return Block.isBlock(child) && child.type === 'table';
    });
    tables.forEach(function (table) {
      var node = fragment.getNextSibling(table.key);
      var isParagraphBlock = Block.isBlock(node) && node.type === 'paragraph'; // 如果表格的下一行不是 paragraph 节点，则创建一个空节点
      // 这个问题是由于表格如果下行没有一个断行的话，则在文章末尾无法追加新内容，切两个表格之间同理也无法追加内容

      if (!isParagraphBlock) {
        var path = fragment.getPath(table.key);
        var emptyParagraph = Block.create({
          type: 'paragraph',
          nodes: [Text.create('')]
        });
        normalizedFragment = fragment.insertNode(Path.increment(path), emptyParagraph);
      }
    });
  }

  return normalizedFragment;
}
/**
 * normalize 打平段落嵌套段落的数据结构
 * @param fragment
 */


function flatInvalidBlock(fragment) {
  var restructNodes = function restructNodes(nodes) {
    return flatten(nodes.map(restructure));
  };

  var restructure = function restructure(node) {
    if (node.nodes) {
      if (Paragraph.isParagraph(node)) {
        var isParagraphNested = node.nodes.some(function (n) {
          return Paragraph.isParagraph(n);
        });

        if (isParagraphNested) {
          return restructNodes(node.nodes);
        }
      }

      return [node.set('nodes', restructNodes(node.nodes))];
    }

    return [node];
  };

  var _restructure = restructure(fragment),
      result = _restructure[0];

  return result;
}

export function normalizeFragment(fragment) {
  // 缓存的 listId, <旧 id, 新 id>
  var listIdMap = new Map();
  var normalizedFragment = fragment.mapDescendants(function (node) {
    // normalize 表格
    if (Block.isBlock(node) && node.type === 'table') {
      return normalizeTable(node);
    } // normalize 列表


    if (Block.isBlock(node) && node.type === 'paragraph' && node.data.list) {
      // 待 list 改造
      //const { listId } = (node.data.list as ListPlugin.ListProperties) || {};
      var _ref4 = node.data.list || {},
          listId = _ref4.listId;

      var newListId = ''; // 注意次数 listId 也可能为 undefined，我们在这里认为 listId 为 undefined 的列表项均为一组

      if (listIdMap.has(listId)) {
        newListId = listIdMap.get(listId);
      } else if (!listId) {
        newListId = getRandomId();
        listIdMap.set(listId, newListId);
      } else {
        newListId = listId;
      }

      return node.set('data', _extends({}, node.data, {
        list: _extends({}, node.data.list, {
          listId: newListId
        })
      }));
    }

    return node;
  }); // 处理日志公告中的不合法数据结构
  // console.log('before flat', JSON.stringify(normalizedFragment));

  normalizedFragment = flatInvalidBlock(normalizedFragment); // console.log(JSON.stringify(normalizedFragment));
  // 处理末尾断行

  normalizedFragment = normalizeEndLine(normalizedFragment);
  return normalizedFragment;
}
//# sourceMappingURL=normalize.js.map