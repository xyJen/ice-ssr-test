import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _createClass from "@babel/runtime/helpers/createClass";

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import { CangjieDataTransfer, transferUtils, Value, constants } from '@ali/4ever-cangjie';
import logger from '@ali/4ever-logger';
import { escape } from 'lodash-es';
import { mimeTypes as MIME } from '@ali/4ever-utils';
import * as tester from "./tester";
import { ClipboardErrorEnum, MARKDOWN_GRAMMER_REGEXP } from "./constants";
import filterAndNormalize from "./filterAndNormalize";
var MIME_TYPES = constants.MIME_TYPES;
var cacheMimeTypes = [MIME.APPLICATION_CANGJIE_FRAGMENT, MIME.TEXT_HTML, MIME.TEXT_PLAIN];
/**
 * è‡ªå®šä¹‰å‰ªåˆ‡æ¿æ•°æ®ï¼Œå°è£…äº† fragment ç­‰ä¸€äº›ç¼–è¾‘å™¨æ•°æ®
 */

var ClipboardData = /*#__PURE__*/function () {
  _createClass(ClipboardData, [{
    key: "dropEffect",
    get: function get() {
      return this.nativeData.dropEffect;
    }
  }, {
    key: "effectAllowed",
    get: function get() {
      return this.nativeData.effectAllowed;
    }
  }, {
    key: "files",
    get: function get() {
      return this.nativeData.files;
    }
  }, {
    key: "items",
    get: function get() {
      return this.nativeData.items;
    }
  }, {
    key: "types",
    get: function get() {
      return this.nativeData.types;
    }
    /**
     * 1. ä»“é¢‰å†…å®¹ä¸ä½œ markdown è¯­æ³•æ ¡éªŒ
     * 2. å¦‚æœä»…æœ‰ text/plain å†…å®¹ æˆ– text å†…å®¹ç¬¦åˆ markdown è¯­æ³•ï¼Œåˆ™å¯èƒ½ä¸º Markdown æ–‡æœ¬
     * 3. å±äºç‰¹æ®Šæƒ…å†µï¼Œåˆ™å¯èƒ½ä¸º Markdown æ–‡æœ¬ï¼š
     *   a. VSCodeï¼šMimeType === vscode-editor-data && mode === 'markdown'
     */

  }, {
    key: "maybeMarkdown",
    get: function get() {
      var _ref;

      if (this.types.includes(MIME.APPLICATION_CANGJIE_FRAGMENT)) {
        return false;
      }

      if (this.types.includes(MIME.TEXT_PLAIN) && (this.types.length === 1 || MARKDOWN_GRAMMER_REGEXP.test((_ref = this.getData(MIME.TEXT_PLAIN) || '') == null ? void 0 : _ref.trimStart == null ? void 0 : _ref.trimStart()))) {
        return true;
      }

      if (this.types.includes(MIME.APPLICATION_VSCODE)) {
        var data = this.getData(MIME.APPLICATION_VSCODE);

        try {
          if (JSON.parse(data).mode === 'markdown') {
            return true;
          }
        } catch (_unused) {
          return false;
        }
      }

      return false;
    }
  }]);

  function ClipboardData(nativeData, config, models) {
    this.nativeData = void 0;
    this.serializer = void 0;
    this.rules = void 0;
    this.schema = void 0;
    this.models = void 0;
    this.cangjieData = CangjieDataTransfer.create();
    this.fragment = null;
    this.parsedFragment = null;
    this.cacheId = '';
    this.receiveType = void 0;
    this.onError = void 0;
    this.nativeData = nativeData;
    var serializer = config.serializer,
        rules = config.rules,
        schema = config.schema,
        onError = config.onError;
    this.serializer = serializer;
    this.rules = rules;
    this.schema = schema;
    this.models = models;
    this.onError = onError;
    this.cacheId = this.getCacheId(); // å½“ä¼ å…¥çš„ nativeData éä»“é¢‰ç±»å‹æ—¶, æ•°æ®è¦ copy ä¸€ä»½ï¼Œé˜²æ­¢ç”Ÿå‘½å‘¨æœŸç»“æŸåè¢«é”€æ¯

    if (nativeData && !(nativeData instanceof CangjieDataTransfer)) {
      for (var _i = 0, _Object$values = Object.values(MIME_TYPES); _i < _Object$values.length; _i++) {
        var type = _Object$values[_i];
        this.cangjieData = this.cangjieData.setData(type, nativeData.getData(type));
      }
    }
  }

  var _proto = ClipboardData.prototype;

  _proto.clearData = function clearData(format) {
    this.nativeData.clearData(format);
  };

  _proto.getData = function getData(format) {
    return this.nativeData.getData(format) || this.cangjieData.getData(format);
  };

  _proto.setData = function setData(format, data) {
    this.nativeData.setData(format, data);
  };

  _proto.setDragImage = function setDragImage(image, x, y) {
    this.nativeData.setDragImage(image, x, y);
  };

  _proto.hasData = function hasData(format) {
    return this.types.includes(format);
  } // event æ”¯æŒ mutable æ–¹å¼ä¿®æ”¹æ•°æ®ï¼Œéœ€è¦é€šè¿‡ cacheId æ ¡éªŒ cache fragment çš„æœ‰æ•ˆæ€§
  ;

  _proto.getCacheId = function getCacheId() {
    for (var _iterator = _createForOfIteratorHelperLoose(cacheMimeTypes), _step; !(_step = _iterator()).done;) {
      var type = _step.value;
      var data = this.nativeData.getData(type);

      if (data) {
        return data;
      }
    }

    return '';
  }
  /**
   * è¯»å–å‰ªåˆ‡æ¿ä¸­çš„ fragment
   * @param parse æ˜¯å¦å¼ºåˆ¶è§£æ html/textï¼Œé»˜è®¤ä¸º true
   */
  ;

  _proto.getFragment = function getFragment(parse) {
    if (parse === void 0) {
      parse = true;
    }

    // å¦‚æœæœ‰ fragment ç¼“å­˜ç›´æ¥è¿”å›
    var currentCacheId = this.getCacheId();

    if (currentCacheId === this.cacheId) {
      if (this.fragment) {
        return this.fragment;
      } // å¦‚æœæœ‰è§£æåçš„ fragment ç¼“å­˜ç›´æ¥è¿”å›


      if (parse && this.parsedFragment) {
        return this.parsedFragment;
      }
    }

    var fragment = null;

    try {
      var encoded = this.getData(MIME.APPLICATION_CANGJIE_FRAGMENT);

      if (encoded) {
        // ä»ä»“é¢‰ç¼–è¾‘å™¨æ‹·è´
        fragment = transferUtils.decodeFragment(encoded);
      }

      if (parse && !fragment) {
        // ååºåˆ—åŒ–è§£æHtmlæˆ–Text
        fragment = this.getParseFragment();
      } // å¦‚æœå‰ªåˆ‡æ¿ä¸­æœ‰ fragment, å¯¹å¤åˆ¶æºæ¥è‡ªä»“é¢‰æˆ–å…¶ä»–çš„å†…å®¹ï¼Œç»Ÿä¸€æ”¶å£åšnormalizeå¤„ç†


      if (fragment) {
        fragment = this.normalizeFragment(fragment);
      }
    } catch (e) {
      if (this.onError) {
        e.type = ClipboardErrorEnum.PASTE_FAILED;
        this.onError(e);
      }

      console.error(e);
      logger.error(e);
    } // ä¸è§£æè¿”å› null


    return fragment;
  }
  /**
   * è¯»å–å‰ªåˆ‡æ¿ä¸­çš„ çº¯æ–‡æœ¬å†…å®¹
   */
  ;

  _proto.getTextFragment = function getTextFragment() {
    var text = this.getData(MIME.TEXT_PLAIN) || '';

    var _this$serializer$text = this.serializer.textToValue(text),
        document = _this$serializer$text.document;

    return document;
  }
  /**
   * è¯»å–å‰ªè´´æ¿ä¸­çš„çº¯æ–‡æœ¬å†…å®¹ï¼Œå¹¶è¿”å›ä»¥ Markdown æ ¼å¼åºåˆ—åŒ–çš„ Value
   *
   * @returns {Document}
   */
  ;

  _proto.getMarkdownFragment =
  /*#__PURE__*/
  function () {
    var _getMarkdownFragment = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var text, _yield$this$serialize, document;

      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              text = this.getData(MIME.TEXT_PLAIN) || '';
              _context.next = 3;
              return this.serializer.markdownToValue(text);

            case 3:
              _yield$this$serialize = _context.sent;
              document = _yield$this$serialize.document;
              return _context.abrupt("return", document);

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function getMarkdownFragment() {
      return _getMarkdownFragment.apply(this, arguments);
    }

    return getMarkdownFragment;
  }()
  /**
   * è¯»å–å‰ªåˆ‡æ¿ä¸­çš„å›¾ç‰‡æ–‡ä»¶
   */
  ;

  _proto.getImages = function getImages() {
    var data = this.nativeData;
    var types = data.types;
    var exceptFileTypes = types.includes('Files') && types.filter(function (type) {
      return type !== 'Files';
    }) || []; // ms word æ‹·è´çš„å›¾æ–‡æ··åˆå†…å®¹ï¼Œmime type ä¼šå¸¦ä¸Š file ç±»å‹ï¼Œè¿™é‡Œåˆ¤æ–­é˜²æ­¢è¯¯å¤„ç†ã€‚ï¼ˆwps æ— è¯¥é—®é¢˜ï¼‰

    if (tester.isMicrosoftOffice(data) && exceptFileTypes.length > 1) {
      return [];
    } // perf: file è¾ƒå¤§ï¼Œæ¯æ¬¡è¯»å– data.files è€—è´¹å¤§é‡æ—¶é—´ï¼Œä½¿ç”¨ä¸´æ—¶å˜é‡ç¼“å­˜ä¼˜åŒ–


    var dataFiles = data.files;

    if (!dataFiles) {
      return [];
    }

    var images = [];

    for (var i = 0, length = dataFiles.length; i < length; i++) {
      var file = dataFiles[i]; // file åœ¨ä¸€äº›ç‰¹æ®Šçš„æƒ…å†µæ˜¯ undefined ğŸ¤·â€â™€ï¸

      if (file && file.type.startsWith('image/')) {
        images.push(file);
      }
    }

    return images;
  }
  /**
   * è·å–ç¬¬ä¸€ä¸ªå¯æ¥å—çš„å‰ªåˆ‡æ¿æ•°æ®ç±»å‹
   */
  ;

  _proto.getFirstReceiveType = function getFirstReceiveType() {
    if (this.receiveType) {
      return this.receiveType;
    }

    if (this.types.includes('files') && !tester.isMicrosoftOffice(this.nativeData)) {
      this.receiveType = 'files';
    } else if (this.hasData(MIME.APPLICATION_CANGJIE_FRAGMENT) || this.hasData(MIME.APPLICATION_SLATE_FRAGMENT)) {
      this.receiveType = 'fragment';
    } else if (this.hasData(MIME.TEXT_HTML)) {
      this.receiveType = 'html';
    } else if (this.hasData(MIME.TEXT_PLAIN)) {
      this.receiveType = 'text';
    } else {
      this.receiveType = 'unknown';
    }

    return this.receiveType;
  } // æ ¹æ®å…¥å‚åˆ¤æ–­å®ä¾‹åŒ–å¯¹è±¡æ˜¯å¦ç›¸åŒ
  ;

  _proto.isEqual = function isEqual(nativeData, config, models) {
    var serializer = config.serializer,
        rules = config.rules,
        schema = config.schema;
    return this.nativeData === nativeData && this.serializer === serializer && this.rules === rules && this.schema === schema && this.models === models;
  };

  _proto.getTextHtml = function getTextHtml() {
    var html = '';

    if (this.hasData(MIME.APPLICATION_VSCODE)) {
      html = "<pre>" + escape(this.getData(MIME.TEXT_PLAIN)) + "</pre><p></p>";
    } else {
      html = this.getData(MIME.TEXT_HTML);
    }

    return html;
  };

  _proto.getParseFragment = function getParseFragment() {
    if (this.parsedFragment) {
      return this.parsedFragment;
    }

    var fragment = null;

    if (this.hasData(MIME.TEXT_HTML)) {
      var html = this.getTextHtml();

      if (html) {
        var _this$serializer$html = this.serializer.htmlToValue(html),
            document = _this$serializer$html.document;

        fragment = document;
        return fragment;
      }
    }

    if (this.hasData(MIME.TEXT_PLAIN)) {
      var text = this.getData(MIME.TEXT_PLAIN);

      if (text) {
        /**
         * ä» Excel ä¸­å¤åˆ¶è¡¨æ ¼ï¼Œçº¯æ–‡æœ¬ç²˜è´´ä¼šé™„å¸¦ \t,å½“ \t è¶³å¤Ÿå¤šæ—¶ä¼šé€ æˆæ¸²æŸ“æ€§èƒ½é—®é¢˜ã€‚
         * https://notes.dingtalk.com/doc/E0Vzg7l3wnjKAzJe?orgId=16872003&dd_progress=false&showmenu=false
         * */
        text = text.replace(/\t+/g, '    ');
        var textValue = this.serializer.textToValue(text);
        fragment = textValue.document;
      }
    }

    return fragment;
  };

  _proto.normalizeFragment = function normalizeFragment(fragment) {
    var newFragment = filterAndNormalize({
      fragment: fragment,
      models: this.models,
      rules: this.rules,
      schema: this.schema
    }); // æ•°æ®æ•ˆéªŒ

    if (this.isValidFragment(newFragment)) {
      this.fragment = newFragment;
      this.parsedFragment = newFragment;
    }

    return newFragment;
  }
  /**
   * æ‹·è´è¿‡æ¥çš„æ•°æ®ä¸ä¸€å®šå®Œå…¨å¯ä¿¡ï¼Œè¿™é‡Œåšä¸€ä¸‹æ•°æ®æ•ˆéªŒ
   * @param fragment
   */
  ;

  _proto.isValidFragment = function isValidFragment(fragment) {
    try {
      this.serializer.valueToJsonML(Value.create({
        document: fragment
      }));
      return true;
    } catch (error) {
      // eslint-disable-next-line no-console
      console.warn(error);
      return false;
    }
  };

  return ClipboardData;
}();

export default ClipboardData;
//# sourceMappingURL=ClipboardData.js.map