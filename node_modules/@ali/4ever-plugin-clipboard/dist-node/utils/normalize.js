"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizeFragment = normalizeFragment;

var _everCangjie = require("@ali/4ever-cangjie");

var _lodash = require("lodash");

var _everPluginParagraph = require("@ali/4ever-plugin-paragraph");

var _everUtils = require("@ali/4ever-utils");

function createParagraph(text = '') {
  return _everCangjie.Block.create({
    type: 'paragraph',
    nodes: [_everCangjie.Text.create(text)]
  });
}
/**
 * 标记表格矩阵的隐藏单元格
 * @param matrix 表格矩阵
 * @param param1 起止坐标
 * @param param2 扩展跨度
 */


function markTableSpanMatrix(matrix, [row, col], [rowSpan, colSpan]) {
  for (let i = row, rl = row + rowSpan; i < rl; i++) {
    for (let j = col, cl = col + colSpan; j < cl; j++) {
      if (i === row && j === col) {
        continue;
      }

      matrix[i][j] = true;
    }
  }
}
/**
 * 订正表格的 span 属性
 * @param table
 */


function normalizeTableSpan(table) {
  const firstRow = table.nodes[0];

  if (!_everCangjie.Block.isBlock(firstRow)) {
    return table;
  }

  const rowSize = table.nodes.length;
  const colSize = firstRow.nodes.length; // 表格矩阵，如果是 hidden 坐标标记为 true
  // 这里我们的遍历顺序是 左 -> 右 上 -> 下

  const tableMatrix = Array(rowSize).fill(0).map(() => Array(colSize).fill(false));
  const normalizedTableRows = table.nodes.map((row, i) => {
    if (!_everCangjie.Block.isBlock(row)) {
      return row;
    }

    return row.set('nodes', row.nodes.map((cell, j) => {
      // 非 block 节点，这种情况可能会异常
      if (!_everCangjie.Block.isBlock(cell)) {
        return cell;
      } // 如果是标记的 hidden 节点


      if (tableMatrix[i][j]) {
        return cell.set('data', { ...cell.data,
          rowSpan: 1,
          colSpan: 1,
          hidden: true
        });
      } // 当前坐标可允许的最大行跨度


      const maxRowSpan = table.nodes.length - i; // 当前坐标可允许的最大列跨度

      const maxColSpan = row.nodes.length - j;
      const rowSpan = Math.min(cell.data.rowSpan, maxRowSpan) || 1;
      const colSpan = Math.min(cell.data.colSpan, maxColSpan) || 1; // 如果单元格有跨度，则进行标记

      if (rowSpan > 1 || colSpan > 1) {
        markTableSpanMatrix(tableMatrix, [i, j], [rowSpan, colSpan]);
      }

      return cell.set('data', { ...cell.data,
        // 只有在 matrix 中标记的格子才 hidden，否则都不 hidden
        hidden: false,
        rowSpan,
        colSpan
      });
    }));
  });
  const normalizedTable = table.set('nodes', normalizedTableRows);
  return normalizedTable;
}
/**
 * 订正表格的行列，使表格所有行列数量对齐
 * @param table
 */


function normalizeTableMatrix(table) {
  const maxColSize = table.nodes.reduce((size, row) => {
    if (_everCangjie.Block.isBlock(row) && row.type === 'table-row') {
      return Math.max(row.nodes.length, size);
    }

    return size;
  }, -Infinity);
  const normalizedRows = table.nodes.map(row => {
    if (_everCangjie.Block.isBlock(row) && row.type === 'table-row' && row.nodes.length < maxColSize) {
      // 当前行的列数与最大列数的差值
      const offset = maxColSize - row.nodes.length; // 填充空单元格
      // TODO: 这里与 table 有强耦合，待 @灯少 重构，将 normalize 职责改为由 table 本身出发。这里先通过实现一个创建 table cell 逻辑解耦
      //const fillNodes = Array(offset).fill(0).map(() => createEmptyTableCell());

      const fillNodes = Array(offset).fill(0).map(() => {
        return _everCangjie.Block.create({
          data: {
            colSpan: 1,
            rowSpan: 1
          },
          type: 'table-cell',
          nodes: [_everCangjie.Block.create({
            type: 'paragraph',
            nodes: [_everCangjie.Text.create('')]
          })]
        });
      });
      return row.set('nodes', [...row.nodes, ...fillNodes]);
    }

    return row;
  });
  return table.set('nodes', normalizedRows);
}
/**
 * 订正表格单元格数据
 * @param table
 */


function normalizeTableCell(table) {
  const normalizedTableRows = table.nodes.map(tableRow => {
    if (!_everCangjie.Block.isBlock(tableRow) || tableRow.type !== 'table-row') {
      return tableRow;
    }

    const normalizedTableCells = tableRow.nodes.map(tableCell => {
      if (!_everCangjie.Block.isBlock(tableCell) || tableCell.type !== 'table-cell') {
        return tableCell;
      }

      const data = (0, _lodash.cloneDeep)(tableCell.data); // width 脏数据

      delete data.width;
      let normalizedTableCell = tableCell.set('data', data); // 如果 tc 下面是空，或者不是 block 节点，则进行数据订正

      if (normalizedTableCell.nodes.length === 0 || !_everCangjie.Block.isBlock(normalizedTableCell.nodes[0])) {
        normalizedTableCell = normalizedTableCell.set('nodes', [createParagraph()]);
      }

      return normalizedTableCell;
    });
    return tableRow.set('nodes', normalizedTableCells);
  });
  return table.set('nodes', normalizedTableRows);
}
/**
 * normalize 表格的数据
 * @param table
 */


function normalizeTable(table) {
  // 空行
  if (table.nodes.length === 0) {
    return createParagraph();
  }

  const firstRow = table.nodes[0]; // 空列

  if (!_everCangjie.Block.isBlock(firstRow) || firstRow.nodes.length === 0) {
    return createParagraph();
  } // 填充表格空缺的单元格


  let normalizedTable = normalizeTableMatrix(table); // 填补表格单元格的跨度属性及隐藏属性

  normalizedTable = normalizeTableSpan(normalizedTable);
  const normalizedFirstRow = normalizedTable.nodes[0]; // colsWidth 可能为空，这种情况表格会彻底坏掉

  let {
    colsWidth = []
  } = normalizedTable.data;
  const colsCount = normalizedFirstRow.nodes.length; // 如果 colsWidth 和列数不相等，则重新计算

  if (colsWidth.length !== colsCount) {
    // 注意这里不会使用 tc 上面的 width，tc.data.width 全部是脏数据
    // 650 的值与 Mo 中对齐，含义是纸张的宽度
    const colWidth = Math.floor(_everUtils.DEFAULT_PAGE_WIDTH / colsCount);
    colsWidth = Array(colsCount).fill(colWidth);
    normalizedTable = normalizedTable.set('data', { ...normalizedTable.data,
      colsWidth
    });
  } // 订正表格单元格数据


  normalizedTable = normalizeTableCell(normalizedTable);
  return normalizedTable;
}
/**
 * normalize 末尾断行
 * @param fragment
 */


function normalizeEndLine(fragment) {
  let normalizedFragment = fragment; // 只有拷贝复合内容的情况下才修正表格断行的数据，只有一个表格的情况不处理，在 table 的 clipboard 中有自行的逻辑

  if (fragment.nodes.length !== 1) {
    const tables = fragment.nodes.filter(child => _everCangjie.Block.isBlock(child) && child.type === 'table');
    tables.forEach(table => {
      const node = fragment.getNextSibling(table.key);
      const isParagraphBlock = _everCangjie.Block.isBlock(node) && node.type === 'paragraph'; // 如果表格的下一行不是 paragraph 节点，则创建一个空节点
      // 这个问题是由于表格如果下行没有一个断行的话，则在文章末尾无法追加新内容，切两个表格之间同理也无法追加内容

      if (!isParagraphBlock) {
        const path = fragment.getPath(table.key);

        const emptyParagraph = _everCangjie.Block.create({
          type: 'paragraph',
          nodes: [_everCangjie.Text.create('')]
        });

        normalizedFragment = fragment.insertNode(_everCangjie.Path.increment(path), emptyParagraph);
      }
    });
  }

  return normalizedFragment;
}
/**
 * normalize 打平段落嵌套段落的数据结构
 * @param fragment
 */


function flatInvalidBlock(fragment) {
  const restructNodes = nodes => (0, _lodash.flatten)(nodes.map(restructure));

  const restructure = node => {
    if (node.nodes) {
      if (_everPluginParagraph.Paragraph.isParagraph(node)) {
        const isParagraphNested = node.nodes.some(n => _everPluginParagraph.Paragraph.isParagraph(n));

        if (isParagraphNested) {
          return restructNodes(node.nodes);
        }
      }

      return [node.set('nodes', restructNodes(node.nodes))];
    }

    return [node];
  };

  const [result] = restructure(fragment);
  return result;
}

function normalizeFragment(fragment) {
  // 缓存的 listId, <旧 id, 新 id>
  const listIdMap = new Map();
  let normalizedFragment = fragment.mapDescendants(node => {
    // normalize 表格
    if (_everCangjie.Block.isBlock(node) && node.type === 'table') {
      return normalizeTable(node);
    } // normalize 列表


    if (_everCangjie.Block.isBlock(node) && node.type === 'paragraph' && node.data.list) {
      // 待 list 改造
      //const { listId } = (node.data.list as ListPlugin.ListProperties) || {};
      const {
        listId
      } = node.data.list || {};
      let newListId = ''; // 注意次数 listId 也可能为 undefined，我们在这里认为 listId 为 undefined 的列表项均为一组

      if (listIdMap.has(listId)) {
        newListId = listIdMap.get(listId);
      } else if (!listId) {
        newListId = (0, _everUtils.getRandomId)();
        listIdMap.set(listId, newListId);
      } else {
        newListId = listId;
      }

      return node.set('data', { ...node.data,
        list: { ...node.data.list,
          listId: newListId
        }
      });
    }

    return node;
  }); // 处理日志公告中的不合法数据结构
  // console.log('before flat', JSON.stringify(normalizedFragment));

  normalizedFragment = flatInvalidBlock(normalizedFragment); // console.log(JSON.stringify(normalizedFragment));
  // 处理末尾断行

  normalizedFragment = normalizeEndLine(normalizedFragment);
  return normalizedFragment;
}
//# sourceMappingURL=normalize.js.map