"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.restructFragment = restructFragment;
exports.flattenNode = void 0;

var _everCangjie = require("@ali/4ever-cangjie");

var _lodash = require("lodash");

var CheckStatus;

(function (CheckStatus) {
  CheckStatus[CheckStatus["success"] = 0] = "success";
  CheckStatus[CheckStatus["failed"] = 1] = "failed";
  CheckStatus[CheckStatus["randundance"] = 2] = "randundance";
})(CheckStatus || (CheckStatus = {}));

const klassRule = [{
  match: _everCangjie.Mark.isMark,
  klass: 'mark'
}, {
  match: _everCangjie.Text.isText,
  klass: 'text'
}, {
  match: _everCangjie.Document.isDocument,
  klass: 'document'
}, {
  match: _everCangjie.Inline.isInline,
  klass: 'inline'
}, {
  match: _everCangjie.Block.isBlock,
  klass: 'block'
}];

const getNodeKlass = node => {
  return klassRule.find(rule => rule.match(node))?.klass || '';
};

const flattenNode = array => {
  return array.reduce((result, current) => {
    if (current.nodes) {
      result.concat(current.nodes);
    } else {
      result.push(current);
    }

    return result;
  }, []);
};

exports.flattenNode = flattenNode;

function parseDataType(dataType) {
  if (Array.isArray(dataType)) {
    return dataType;
  }

  return [dataType];
} // success -> 校验成功, failed -> 校验失败, redundance -> 校验成功，但有冗余字段


function checkDataType(receiveData, expectData) {
  // models 中未定义 data 类型，默认为类型校验成功
  if (!expectData || Object.keys(expectData).length === 0) {
    return [CheckStatus.success, receiveData];
  } // 从 models 中找出必须有的字段（即非 undefined 类型）


  const necessaryType = Object.keys(expectData).filter(field => {
    const type = expectData[field];
    return !(Array.isArray(type) && type.includes(undefined));
  }); // 校验 node 节点属性上是否有 models 中定义的必须有的字段

  const conformNecessary = necessaryType.every(field => {
    return receiveData[field];
  }); // node 缺少必有字段，类型校验失败

  if (!conformNecessary) {
    return [CheckStatus.failed, receiveData];
  } // 对 node 上的属性进行类型校验


  const receiveDataTypes = Object.keys(receiveData);

  if (receiveDataTypes.length === 0) {
    return [CheckStatus.success, receiveData];
  }

  const redundance = [];

  for (const field of receiveDataTypes) {
    // node 中 存在 models data 中未定义的字段，类型校验失败
    if (!expectData[field]) {
      redundance.push(field);
      continue;
    } // 解析 model.data 字段中允许的类型


    const allowTypes = parseDataType(expectData[field]); // 获取真实节点上对应属性的类型

    const actual = receiveData[field];
    const hasType = allowTypes.some(type => {
      const actualIsObj = actual instanceof Object;

      if (!type) {
        // 对 undefined、null 类型的 type 做校验
        return actual === type;
      } else if (actualIsObj) {
        // 这里对 actual 是 Array、Object 类型作区分
        if (Array.isArray(actual) && !type.isArray) {
          return false;
        }

        return actual instanceof type;
      }

      ; // instanceof 只能通过原型链判断，例如 'abc' instanceof String, 结果是 false

      const typeName = type.name?.toLowerCase(); // eslint-disable-next-line valid-typeof

      return typeof actual === typeName;
    }); // 类型校验

    if (!hasType) {
      return [CheckStatus.failed, receiveData];
    }
  }

  if (redundance.length > 0) {
    return [CheckStatus.randundance, (0, _lodash.omit)(receiveData, redundance)];
  }

  return [CheckStatus.success, receiveData];
}

function getModelVal(node, modelsMap) {
  const klass = getNodeKlass(node);
  const keys = [klass, node.type];
  return modelsMap.get(keys.join('_'));
}

const isKnown = (node, modelsMap) => {
  const klass = getNodeKlass(node);
  const modelVal = getModelVal(node, modelsMap);
  return Boolean(modelVal) || klass === 'document';
};

function processWithNode(node, modelsMap) {
  const klass = getNodeKlass(node);

  if (klass === 'document') {
    return [true, node];
  }

  if (isKnown(node, modelsMap)) {
    const modelVal = getModelVal(node, modelsMap);
    const results = modelVal.map(val => checkDataType(node.data, val));
    const successResult = [];
    const randundanceResult = [];
    results.forEach(rst => {
      if (rst[0] === CheckStatus.success) {
        successResult.push(rst);
      } else if (rst[0] === CheckStatus.randundance) {
        randundanceResult.push(rst);
      }
    });

    if (successResult.length > 0) {
      return [true, node];
    }

    if (randundanceResult.length > 0) {
      return [true, node.set('data', randundanceResult[CheckStatus.success][1])];
    }

    return [false, node];
  }

  return [false, node];
}

function restructFragment(fragment, modelsMap) {
  const restructure = oldNode => {
    const [isKnownNode, node] = processWithNode(oldNode, modelsMap);

    if (isKnownNode) {
      if (node.nodes) {
        return [node.set('nodes', (0, _lodash.flatten)(node.nodes.map(restructure)))];
      }

      return [node];
    }

    if (node.nodes) {
      const klass = getNodeKlass(node);

      if (klass === 'block') {
        return [node.set('type', 'paragraph').set('nodes', restructNodes(node.nodes)).set('data', {})];
      }

      return flattenNode((0, _lodash.flatten)(node.nodes.map(restructure)));
    }

    if (_everCangjie.Text.isText(node)) {
      return [_everCangjie.Text.create({
        key: node.key,
        leaves: node.leaves.map(leaf => {
          const marks = [];
          leaf.marks.forEach(mark => {
            const [isKnownMark, newMark] = processWithNode(mark, modelsMap);

            if (isKnownMark) {
              marks.push(newMark);
            }
          });
          return leaf.set('marks', marks);
        })
      })];
    }

    return [node];
  };

  const restructNodes = nodes => (0, _lodash.flatten)(nodes.map(restructure));

  const [result] = restructure(fragment);
  return result;
}
//# sourceMappingURL=restructFragment.js.map