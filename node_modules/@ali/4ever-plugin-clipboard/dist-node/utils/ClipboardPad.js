"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _everCangjie = require("@ali/4ever-cangjie");

var _lodash = require("lodash");

var _ClipboardData = _interopRequireDefault(require("./ClipboardData"));

var _everUtils = require("@ali/4ever-utils");

var _getHtmlFromValue = _interopRequireDefault(require("./getHtmlFromValue"));

/**
 * 剪切板实例缓存缓存
 */
const clipboardPadMap = new Map();
/**
 * 当前的剪切事件
 * @description 我们假设同一次剪切板时间只能被一个编辑器实例消费，所以目前可能存在的情况是 ClipboardPad 是多实例，但是
 * 读取到的 ClipboardData 是单实例的。
 * TODO: 后续需要考虑在 Plugin 层如何设计一个多实例的配置
 */

let currentClipboardData = null;

class ClipboardPad {
  /**
   * 获得一个剪切板，使用配置数据作为 union 单位，针对不同的 config 实例返回不同的剪切板
   * @param config 编辑器的配置
   */
  static getClipboardPad(conf, key = 'default') {
    // 默认使用 mo 的正反序列化
    const config = { ...conf,
      serializer: conf.serializer
    };
    const clipboardPadCache = clipboardPadMap.get(key);

    if (clipboardPadCache) {
      if ((0, _lodash.isEqual)(clipboardPadCache.config, config)) {
        return clipboardPadCache;
      }
    }

    const clipboardPad = ClipboardPad.createClipboardPad(config);

    if (key) {
      clipboardPadMap.set(key, clipboardPad);
    }

    return clipboardPad;
  }

  static createClipboardPad(config) {
    return new ClipboardPad(config);
  }
  /**
   * 剪切板配置
   */


  constructor(config) {
    this.config = void 0;
    this.models = void 0;
    this.config = config;
  }
  /**
   * 读取剪切板数据，相同的 event 会读取到同一个实例
   * @param event
   */


  getClipboardData(event) {
    const args = [event.clipboardData, this.config, this.models]; // @ts-ignore

    if (currentClipboardData?.isEqual(...args)) {
      return currentClipboardData;
    } // @ts-ignore


    currentClipboardData = new _ClipboardData.default(...args);
    return currentClipboardData;
  }
  /**
   * 读取剪切板缓存数据，切换不同粘贴模式下使用
   * @param event
   */


  getClipboardDataCache() {
    return currentClipboardData;
  }
  /**
   * 拷贝一个 fragment
   * @param event 拷贝事件
   * @param fragment
   */


  copyFragment(event, fragment) {
    const {
      clipboardData
    } = event;

    if (!clipboardData) {
      return;
    }

    event.preventDefault();
    const {
      serializer
    } = this.config;

    const value = _everCangjie.Value.create({
      document: fragment
    });

    const text = serializer.valueToText(value);
    const html = (0, _getHtmlFromValue.default)(serializer, value);

    const encoded = _everCangjie.transferUtils.encodeFragment(fragment);

    clipboardData.setData(_everUtils.mimeTypes.TEXT_PLAIN, text);
    clipboardData.setData(_everUtils.mimeTypes.TEXT_HTML, html);
    clipboardData.setData(_everUtils.mimeTypes.APPLICATION_CANGJIE_FRAGMENT, encoded);
  }

  initPluginModels(controller) {
    const models = this.getPluginModels(controller);
    let pidStr = '';

    for (const model of models.keys()) {
      pidStr += model;
    }

    models.set('controllerPid', (0, _everUtils.toHash)(pidStr));
    this.models = models;
  }
  /**
   * 获取所有插件内容的models map集合
   * @param
   */


  getPluginModels(controller) {
    const infoMap = new Map(); // @ts-ignore

    const {
      models
    } = controller.handlers;

    if (models) {
      const flatModels = (0, _lodash.flatten)(models);
      flatModels.forEach(info => {
        if (info) {
          // @ts-ignore
          const infoKey = `${info.klass}_${info.type}`; // @ts-ignore

          const infoData = info.data || {};
          const oldValue = infoMap.get(infoKey);

          if (oldValue) {
            if (Array.isArray(oldValue)) {
              infoMap.set(infoKey, oldValue.concat(infoData));
            } else {
              infoMap.set(infoKey, [oldValue, infoData]);
            }
          } else {
            // @ts-ignore
            infoMap.set(infoKey, [infoData]);
          }
        }
      });
    }

    return infoMap;
  }

}

ClipboardPad.getCachedClipboardPad = (key = 'default') => {
  return clipboardPadMap.get(key);
};

var _default = ClipboardPad;
exports.default = _default;
//# sourceMappingURL=ClipboardPad.js.map