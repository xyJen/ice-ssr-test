"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _everCangjie = require("@ali/4ever-cangjie");

var _everLogger = _interopRequireDefault(require("@ali/4ever-logger"));

var _lodash = require("lodash");

var _everUtils = require("@ali/4ever-utils");

var tester = _interopRequireWildcard(require("./tester"));

var _constants = require("./constants");

var _filterAndNormalize = _interopRequireDefault(require("./filterAndNormalize"));

const {
  MIME_TYPES
} = _everCangjie.constants;
const cacheMimeTypes = [_everUtils.mimeTypes.APPLICATION_CANGJIE_FRAGMENT, _everUtils.mimeTypes.TEXT_HTML, _everUtils.mimeTypes.TEXT_PLAIN];
/**
 * 自定义剪切板数据，封装了 fragment 等一些编辑器数据
 */

class ClipboardData {
  get dropEffect() {
    return this.nativeData.dropEffect;
  }

  get effectAllowed() {
    return this.nativeData.effectAllowed;
  }

  get files() {
    return this.nativeData.files;
  }

  get items() {
    return this.nativeData.items;
  }

  get types() {
    return this.nativeData.types;
  }
  /**
   * 1. 仓颉内容不作 markdown 语法校验
   * 2. 如果仅有 text/plain 内容 或 text 内容符合 markdown 语法，则可能为 Markdown 文本
   * 3. 属于特殊情况，则可能为 Markdown 文本：
   *   a. VSCode：MimeType === vscode-editor-data && mode === 'markdown'
   */


  get maybeMarkdown() {
    if (this.types.includes(_everUtils.mimeTypes.APPLICATION_CANGJIE_FRAGMENT)) {
      return false;
    }

    if (this.types.includes(_everUtils.mimeTypes.TEXT_PLAIN) && (this.types.length === 1 || _constants.MARKDOWN_GRAMMER_REGEXP.test((this.getData(_everUtils.mimeTypes.TEXT_PLAIN) || '')?.trimStart?.()))) {
      return true;
    }

    if (this.types.includes(_everUtils.mimeTypes.APPLICATION_VSCODE)) {
      const data = this.getData(_everUtils.mimeTypes.APPLICATION_VSCODE);

      try {
        if (JSON.parse(data).mode === 'markdown') {
          return true;
        }
      } catch {
        return false;
      }
    }

    return false;
  }

  constructor(nativeData, config, models) {
    this.nativeData = void 0;
    this.serializer = void 0;
    this.rules = void 0;
    this.schema = void 0;
    this.models = void 0;
    this.cangjieData = _everCangjie.CangjieDataTransfer.create();
    this.fragment = null;
    this.parsedFragment = null;
    this.cacheId = '';
    this.receiveType = void 0;
    this.onError = void 0;
    this.nativeData = nativeData;
    const {
      serializer,
      rules,
      schema,
      onError
    } = config;
    this.serializer = serializer;
    this.rules = rules;
    this.schema = schema;
    this.models = models;
    this.onError = onError;
    this.cacheId = this.getCacheId(); // 当传入的 nativeData 非仓颉类型时, 数据要 copy 一份，防止生命周期结束后被销毁

    if (nativeData && !(nativeData instanceof _everCangjie.CangjieDataTransfer)) {
      for (const type of Object.values(MIME_TYPES)) {
        this.cangjieData = this.cangjieData.setData(type, nativeData.getData(type));
      }
    }
  }

  clearData(format) {
    this.nativeData.clearData(format);
  }

  getData(format) {
    return this.nativeData.getData(format) || this.cangjieData.getData(format);
  }

  setData(format, data) {
    this.nativeData.setData(format, data);
  }

  setDragImage(image, x, y) {
    this.nativeData.setDragImage(image, x, y);
  }

  hasData(format) {
    return this.types.includes(format);
  } // event 支持 mutable 方式修改数据，需要通过 cacheId 校验 cache fragment 的有效性


  getCacheId() {
    for (const type of cacheMimeTypes) {
      const data = this.nativeData.getData(type);

      if (data) {
        return data;
      }
    }

    return '';
  }
  /**
   * 读取剪切板中的 fragment
   * @param parse 是否强制解析 html/text，默认为 true
   */


  getFragment(parse = true) {
    // 如果有 fragment 缓存直接返回
    const currentCacheId = this.getCacheId();

    if (currentCacheId === this.cacheId) {
      if (this.fragment) {
        return this.fragment;
      } // 如果有解析后的 fragment 缓存直接返回


      if (parse && this.parsedFragment) {
        return this.parsedFragment;
      }
    }

    let fragment = null;

    try {
      const encoded = this.getData(_everUtils.mimeTypes.APPLICATION_CANGJIE_FRAGMENT);

      if (encoded) {
        // 从仓颉编辑器拷贝
        fragment = _everCangjie.transferUtils.decodeFragment(encoded);
      }

      if (parse && !fragment) {
        // 反序列化解析Html或Text
        fragment = this.getParseFragment();
      } // 如果剪切板中有 fragment, 对复制源来自仓颉或其他的内容，统一收口做normalize处理


      if (fragment) {
        fragment = this.normalizeFragment(fragment);
      }
    } catch (e) {
      if (this.onError) {
        e.type = _constants.ClipboardErrorEnum.PASTE_FAILED;
        this.onError(e);
      }

      console.error(e);

      _everLogger.default.error(e);
    } // 不解析返回 null


    return fragment;
  }
  /**
   * 读取剪切板中的 纯文本内容
   */


  getTextFragment() {
    const text = this.getData(_everUtils.mimeTypes.TEXT_PLAIN) || '';
    const {
      document
    } = this.serializer.textToValue(text);
    return document;
  }
  /**
   * 读取剪贴板中的纯文本内容，并返回以 Markdown 格式序列化的 Value
   *
   * @returns {Document}
   */


  async getMarkdownFragment() {
    const text = this.getData(_everUtils.mimeTypes.TEXT_PLAIN) || '';
    const {
      document
    } = await this.serializer.markdownToValue(text);
    return document;
  }
  /**
   * 读取剪切板中的图片文件
   */


  getImages() {
    const data = this.nativeData;
    const {
      types
    } = data;
    const exceptFileTypes = types.includes('Files') && types.filter(type => type !== 'Files') || []; // ms word 拷贝的图文混合内容，mime type 会带上 file 类型，这里判断防止误处理。（wps 无该问题）

    if (tester.isMicrosoftOffice(data) && exceptFileTypes.length > 1) {
      return [];
    } // perf: file 较大，每次读取 data.files 耗费大量时间，使用临时变量缓存优化


    const dataFiles = data.files;

    if (!dataFiles) {
      return [];
    }

    const images = [];

    for (let i = 0, {
      length
    } = dataFiles; i < length; i++) {
      const file = dataFiles[i]; // file 在一些特殊的情况是 undefined 🤷‍♀️

      if (file && file.type.startsWith('image/')) {
        images.push(file);
      }
    }

    return images;
  }
  /**
   * 获取第一个可接受的剪切板数据类型
   */


  getFirstReceiveType() {
    if (this.receiveType) {
      return this.receiveType;
    }

    if (this.types.includes('files') && !tester.isMicrosoftOffice(this.nativeData)) {
      this.receiveType = 'files';
    } else if (this.hasData(_everUtils.mimeTypes.APPLICATION_CANGJIE_FRAGMENT) || this.hasData(_everUtils.mimeTypes.APPLICATION_SLATE_FRAGMENT)) {
      this.receiveType = 'fragment';
    } else if (this.hasData(_everUtils.mimeTypes.TEXT_HTML)) {
      this.receiveType = 'html';
    } else if (this.hasData(_everUtils.mimeTypes.TEXT_PLAIN)) {
      this.receiveType = 'text';
    } else {
      this.receiveType = 'unknown';
    }

    return this.receiveType;
  } // 根据入参判断实例化对象是否相同


  isEqual(nativeData, config, models) {
    const {
      serializer,
      rules,
      schema
    } = config;
    return this.nativeData === nativeData && this.serializer === serializer && this.rules === rules && this.schema === schema && this.models === models;
  }

  getTextHtml() {
    let html = '';

    if (this.hasData(_everUtils.mimeTypes.APPLICATION_VSCODE)) {
      html = `<pre>${(0, _lodash.escape)(this.getData(_everUtils.mimeTypes.TEXT_PLAIN))}</pre><p></p>`;
    } else {
      html = this.getData(_everUtils.mimeTypes.TEXT_HTML);
    }

    return html;
  }

  getParseFragment() {
    if (this.parsedFragment) {
      return this.parsedFragment;
    }

    let fragment = null;

    if (this.hasData(_everUtils.mimeTypes.TEXT_HTML)) {
      const html = this.getTextHtml();

      if (html) {
        const {
          document
        } = this.serializer.htmlToValue(html);
        fragment = document;
        return fragment;
      }
    }

    if (this.hasData(_everUtils.mimeTypes.TEXT_PLAIN)) {
      let text = this.getData(_everUtils.mimeTypes.TEXT_PLAIN);

      if (text) {
        /**
         * 从 Excel 中复制表格，纯文本粘贴会附带 \t,当 \t 足够多时会造成渲染性能问题。
         * https://notes.dingtalk.com/doc/E0Vzg7l3wnjKAzJe?orgId=16872003&dd_progress=false&showmenu=false
         * */
        text = text.replace(/\t+/g, '    ');
        const textValue = this.serializer.textToValue(text);
        fragment = textValue.document;
      }
    }

    return fragment;
  }

  normalizeFragment(fragment) {
    const newFragment = (0, _filterAndNormalize.default)({
      fragment,
      models: this.models,
      rules: this.rules,
      schema: this.schema
    }); // 数据效验

    if (this.isValidFragment(newFragment)) {
      this.fragment = newFragment;
      this.parsedFragment = newFragment;
    }

    return newFragment;
  }
  /**
   * 拷贝过来的数据不一定完全可信，这里做一下数据效验
   * @param fragment
   */


  isValidFragment(fragment) {
    try {
      this.serializer.valueToJsonML(_everCangjie.Value.create({
        document: fragment
      }));
      return true;
    } catch (error) {
      // eslint-disable-next-line no-console
      console.warn(error);
      return false;
    }
  }

}

var _default = ClipboardData;
exports.default = _default;
//# sourceMappingURL=ClipboardData.js.map