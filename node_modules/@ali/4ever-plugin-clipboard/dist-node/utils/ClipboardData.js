"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _everCangjie = require("@ali/4ever-cangjie");

var _everLogger = _interopRequireDefault(require("@ali/4ever-logger"));

var _lodash = require("lodash");

var _everUtils = require("@ali/4ever-utils");

var tester = _interopRequireWildcard(require("./tester"));

var _constants = require("./constants");

var _filterAndNormalize = _interopRequireDefault(require("./filterAndNormalize"));

const {
  MIME_TYPES
} = _everCangjie.constants;
const cacheMimeTypes = [_everUtils.mimeTypes.APPLICATION_CANGJIE_FRAGMENT, _everUtils.mimeTypes.TEXT_HTML, _everUtils.mimeTypes.TEXT_PLAIN];
/**
 * è‡ªå®šä¹‰å‰ªåˆ‡æ¿æ•°æ®ï¼Œå°è£…äº† fragment ç­‰ä¸€äº›ç¼–è¾‘å™¨æ•°æ®
 */

class ClipboardData {
  get dropEffect() {
    return this.nativeData.dropEffect;
  }

  get effectAllowed() {
    return this.nativeData.effectAllowed;
  }

  get files() {
    return this.nativeData.files;
  }

  get items() {
    return this.nativeData.items;
  }

  get types() {
    return this.nativeData.types;
  }
  /**
   * 1. ä»“é¢‰å†…å®¹ä¸ä½œ markdown è¯­æ³•æ ¡éªŒ
   * 2. å¦‚æœä»…æœ‰ text/plain å†…å®¹ æˆ– text å†…å®¹ç¬¦åˆ markdown è¯­æ³•ï¼Œåˆ™å¯èƒ½ä¸º Markdown æ–‡æœ¬
   * 3. å±äºç‰¹æ®Šæƒ…å†µï¼Œåˆ™å¯èƒ½ä¸º Markdown æ–‡æœ¬ï¼š
   *   a. VSCodeï¼šMimeType === vscode-editor-data && mode === 'markdown'
   */


  get maybeMarkdown() {
    if (this.types.includes(_everUtils.mimeTypes.APPLICATION_CANGJIE_FRAGMENT)) {
      return false;
    }

    if (this.types.includes(_everUtils.mimeTypes.TEXT_PLAIN) && (this.types.length === 1 || _constants.MARKDOWN_GRAMMER_REGEXP.test((this.getData(_everUtils.mimeTypes.TEXT_PLAIN) || '')?.trimStart?.()))) {
      return true;
    }

    if (this.types.includes(_everUtils.mimeTypes.APPLICATION_VSCODE)) {
      const data = this.getData(_everUtils.mimeTypes.APPLICATION_VSCODE);

      try {
        if (JSON.parse(data).mode === 'markdown') {
          return true;
        }
      } catch {
        return false;
      }
    }

    return false;
  }

  constructor(nativeData, config, models) {
    this.nativeData = void 0;
    this.serializer = void 0;
    this.rules = void 0;
    this.schema = void 0;
    this.models = void 0;
    this.cangjieData = _everCangjie.CangjieDataTransfer.create();
    this.fragment = null;
    this.parsedFragment = null;
    this.cacheId = '';
    this.receiveType = void 0;
    this.onError = void 0;
    this.nativeData = nativeData;
    const {
      serializer,
      rules,
      schema,
      onError
    } = config;
    this.serializer = serializer;
    this.rules = rules;
    this.schema = schema;
    this.models = models;
    this.onError = onError;
    this.cacheId = this.getCacheId(); // å½“ä¼ å…¥çš„ nativeData éä»“é¢‰ç±»å‹æ—¶, æ•°æ®è¦ copy ä¸€ä»½ï¼Œé˜²æ­¢ç”Ÿå‘½å‘¨æœŸç»“æŸåè¢«é”€æ¯

    if (nativeData && !(nativeData instanceof _everCangjie.CangjieDataTransfer)) {
      for (const type of Object.values(MIME_TYPES)) {
        this.cangjieData = this.cangjieData.setData(type, nativeData.getData(type));
      }
    }
  }

  clearData(format) {
    this.nativeData.clearData(format);
  }

  getData(format) {
    return this.nativeData.getData(format) || this.cangjieData.getData(format);
  }

  setData(format, data) {
    this.nativeData.setData(format, data);
  }

  setDragImage(image, x, y) {
    this.nativeData.setDragImage(image, x, y);
  }

  hasData(format) {
    return this.types.includes(format);
  } // event æ”¯æŒ mutable æ–¹å¼ä¿®æ”¹æ•°æ®ï¼Œéœ€è¦é€šè¿‡ cacheId æ ¡éªŒ cache fragment çš„æœ‰æ•ˆæ€§


  getCacheId() {
    for (const type of cacheMimeTypes) {
      const data = this.nativeData.getData(type);

      if (data) {
        return data;
      }
    }

    return '';
  }
  /**
   * è¯»å–å‰ªåˆ‡æ¿ä¸­çš„ fragment
   * @param parse æ˜¯å¦å¼ºåˆ¶è§£æ html/textï¼Œé»˜è®¤ä¸º true
   */


  getFragment(parse = true) {
    // å¦‚æœæœ‰ fragment ç¼“å­˜ç›´æ¥è¿”å›
    const currentCacheId = this.getCacheId();

    if (currentCacheId === this.cacheId) {
      if (this.fragment) {
        return this.fragment;
      } // å¦‚æœæœ‰è§£æåçš„ fragment ç¼“å­˜ç›´æ¥è¿”å›


      if (parse && this.parsedFragment) {
        return this.parsedFragment;
      }
    }

    let fragment = null;

    try {
      const encoded = this.getData(_everUtils.mimeTypes.APPLICATION_CANGJIE_FRAGMENT);

      if (encoded) {
        // ä»ä»“é¢‰ç¼–è¾‘å™¨æ‹·è´
        fragment = _everCangjie.transferUtils.decodeFragment(encoded);
      }

      if (parse && !fragment) {
        // ååºåˆ—åŒ–è§£æHtmlæˆ–Text
        fragment = this.getParseFragment();
      } // å¦‚æœå‰ªåˆ‡æ¿ä¸­æœ‰ fragment, å¯¹å¤åˆ¶æºæ¥è‡ªä»“é¢‰æˆ–å…¶ä»–çš„å†…å®¹ï¼Œç»Ÿä¸€æ”¶å£åšnormalizeå¤„ç†


      if (fragment) {
        fragment = this.normalizeFragment(fragment);
      }
    } catch (e) {
      if (this.onError) {
        e.type = _constants.ClipboardErrorEnum.PASTE_FAILED;
        this.onError(e);
      }

      console.error(e);

      _everLogger.default.error(e);
    } // ä¸è§£æè¿”å› null


    return fragment;
  }
  /**
   * è¯»å–å‰ªåˆ‡æ¿ä¸­çš„ çº¯æ–‡æœ¬å†…å®¹
   */


  getTextFragment() {
    const text = this.getData(_everUtils.mimeTypes.TEXT_PLAIN) || '';
    const {
      document
    } = this.serializer.textToValue(text);
    return document;
  }
  /**
   * è¯»å–å‰ªè´´æ¿ä¸­çš„çº¯æ–‡æœ¬å†…å®¹ï¼Œå¹¶è¿”å›ä»¥ Markdown æ ¼å¼åºåˆ—åŒ–çš„ Value
   *
   * @returns {Document}
   */


  async getMarkdownFragment() {
    const text = this.getData(_everUtils.mimeTypes.TEXT_PLAIN) || '';
    const {
      document
    } = await this.serializer.markdownToValue(text);
    return document;
  }
  /**
   * è¯»å–å‰ªåˆ‡æ¿ä¸­çš„å›¾ç‰‡æ–‡ä»¶
   */


  getImages() {
    const data = this.nativeData;
    const {
      types
    } = data;
    const exceptFileTypes = types.includes('Files') && types.filter(type => type !== 'Files') || []; // ms word æ‹·è´çš„å›¾æ–‡æ··åˆå†…å®¹ï¼Œmime type ä¼šå¸¦ä¸Š file ç±»å‹ï¼Œè¿™é‡Œåˆ¤æ–­é˜²æ­¢è¯¯å¤„ç†ã€‚ï¼ˆwps æ— è¯¥é—®é¢˜ï¼‰

    if (tester.isMicrosoftOffice(data) && exceptFileTypes.length > 1) {
      return [];
    } // perf: file è¾ƒå¤§ï¼Œæ¯æ¬¡è¯»å– data.files è€—è´¹å¤§é‡æ—¶é—´ï¼Œä½¿ç”¨ä¸´æ—¶å˜é‡ç¼“å­˜ä¼˜åŒ–


    const dataFiles = data.files;

    if (!dataFiles) {
      return [];
    }

    const images = [];

    for (let i = 0, {
      length
    } = dataFiles; i < length; i++) {
      const file = dataFiles[i]; // file åœ¨ä¸€äº›ç‰¹æ®Šçš„æƒ…å†µæ˜¯ undefined ğŸ¤·â€â™€ï¸

      if (file && file.type.startsWith('image/')) {
        images.push(file);
      }
    }

    return images;
  }
  /**
   * è·å–ç¬¬ä¸€ä¸ªå¯æ¥å—çš„å‰ªåˆ‡æ¿æ•°æ®ç±»å‹
   */


  getFirstReceiveType() {
    if (this.receiveType) {
      return this.receiveType;
    }

    if (this.types.includes('files') && !tester.isMicrosoftOffice(this.nativeData)) {
      this.receiveType = 'files';
    } else if (this.hasData(_everUtils.mimeTypes.APPLICATION_CANGJIE_FRAGMENT) || this.hasData(_everUtils.mimeTypes.APPLICATION_SLATE_FRAGMENT)) {
      this.receiveType = 'fragment';
    } else if (this.hasData(_everUtils.mimeTypes.TEXT_HTML)) {
      this.receiveType = 'html';
    } else if (this.hasData(_everUtils.mimeTypes.TEXT_PLAIN)) {
      this.receiveType = 'text';
    } else {
      this.receiveType = 'unknown';
    }

    return this.receiveType;
  } // æ ¹æ®å…¥å‚åˆ¤æ–­å®ä¾‹åŒ–å¯¹è±¡æ˜¯å¦ç›¸åŒ


  isEqual(nativeData, config, models) {
    const {
      serializer,
      rules,
      schema
    } = config;
    return this.nativeData === nativeData && this.serializer === serializer && this.rules === rules && this.schema === schema && this.models === models;
  }

  getTextHtml() {
    let html = '';

    if (this.hasData(_everUtils.mimeTypes.APPLICATION_VSCODE)) {
      html = `<pre>${(0, _lodash.escape)(this.getData(_everUtils.mimeTypes.TEXT_PLAIN))}</pre><p></p>`;
    } else {
      html = this.getData(_everUtils.mimeTypes.TEXT_HTML);
    }

    return html;
  }

  getParseFragment() {
    if (this.parsedFragment) {
      return this.parsedFragment;
    }

    let fragment = null;

    if (this.hasData(_everUtils.mimeTypes.TEXT_HTML)) {
      const html = this.getTextHtml();

      if (html) {
        const {
          document
        } = this.serializer.htmlToValue(html);
        fragment = document;
        return fragment;
      }
    }

    if (this.hasData(_everUtils.mimeTypes.TEXT_PLAIN)) {
      let text = this.getData(_everUtils.mimeTypes.TEXT_PLAIN);

      if (text) {
        /**
         * ä» Excel ä¸­å¤åˆ¶è¡¨æ ¼ï¼Œçº¯æ–‡æœ¬ç²˜è´´ä¼šé™„å¸¦ \t,å½“ \t è¶³å¤Ÿå¤šæ—¶ä¼šé€ æˆæ¸²æŸ“æ€§èƒ½é—®é¢˜ã€‚
         * https://notes.dingtalk.com/doc/E0Vzg7l3wnjKAzJe?orgId=16872003&dd_progress=false&showmenu=false
         * */
        text = text.replace(/\t+/g, '    ');
        const textValue = this.serializer.textToValue(text);
        fragment = textValue.document;
      }
    }

    return fragment;
  }

  normalizeFragment(fragment) {
    const newFragment = (0, _filterAndNormalize.default)({
      fragment,
      models: this.models,
      rules: this.rules,
      schema: this.schema
    }); // æ•°æ®æ•ˆéªŒ

    if (this.isValidFragment(newFragment)) {
      this.fragment = newFragment;
      this.parsedFragment = newFragment;
    }

    return newFragment;
  }
  /**
   * æ‹·è´è¿‡æ¥çš„æ•°æ®ä¸ä¸€å®šå®Œå…¨å¯ä¿¡ï¼Œè¿™é‡Œåšä¸€ä¸‹æ•°æ®æ•ˆéªŒ
   * @param fragment
   */


  isValidFragment(fragment) {
    try {
      this.serializer.valueToJsonML(_everCangjie.Value.create({
        document: fragment
      }));
      return true;
    } catch (error) {
      // eslint-disable-next-line no-console
      console.warn(error);
      return false;
    }
  }

}

var _default = ClipboardData;
exports.default = _default;
//# sourceMappingURL=ClipboardData.js.map