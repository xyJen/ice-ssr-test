"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMarksAtAnchor = getMarksAtAnchor;
exports.decorateFragment = decorateFragment;

var _everCangjie = require("@ali/4ever-cangjie");

var _lodash = require("lodash");

// marks type
const FONT_TYPE = 'fonts';
const SZ_TYPE = 'sz';
/**
 * @description 获取光标所在 leaf 节点的 marks
 * @param {controller}
 * */

function getMarksAtAnchor(controller) {
  const {
    document,
    selection
  } = controller.value;
  const {
    anchor
  } = selection;
  const anchorNode = document.getNode(anchor.key);

  if (_everCangjie.Text.isText(anchorNode) && anchor.isTextPoint()) {
    let position = 0;
    const anchorLeaf = anchorNode.leaves.find(leaf => {
      position += leaf.text.length;
      return position >= anchor.offset;
    });
    return [...(anchorLeaf?.marks || [])];
  }

  return [];
}

function isSameFontSize(fragment) {
  let defaultSz;
  let Firstflag = false;
  const isDifferent = fragment.someDescendant(node => {
    if (_everCangjie.Text.isText(node)) {
      const szMark = node.getMarks().find(mark => mark.type === SZ_TYPE);

      if (!Firstflag) {
        defaultSz = szMark;
        Firstflag = true;
      }

      if (!(0, _lodash.isEqual)(defaultSz, szMark)) {
        return true;
      }
    }

    return false;
  });
  return !isDifferent;
}
/**
 * @description
 *  非仓颉内容修饰加工
 *  1. 移除字体类型;
 *  2. 粘贴内容字号相同时，自动与目标字体大小合并
 * @param {Controller} controller
 * @param {Document} fragment
 */


function decorateFragment(controller, fragment) {
  const marks = getMarksAtAnchor(controller).filter(mark => [FONT_TYPE, SZ_TYPE].includes(mark.type));
  const szMark = marks.filter(mark => mark.type === SZ_TYPE);
  const isSameSz = isSameFontSize(fragment);
  const newFragment = fragment.mapDescendants(node => {
    let child = node;

    if (!_everCangjie.Text.isText(child)) {
      return child;
    }

    child.marks.forEach(mark => {
      if (mark.type === FONT_TYPE || mark.type === SZ_TYPE && isSameSz) {
        child = child.removeMark(0, child.text.length, mark);
      }
    });

    if (isSameSz) {
      return child.addMarks(0, child.text.length, szMark);
    }

    return child;
  });
  return newFragment;
}
//# sourceMappingURL=decorateFragment.js.map