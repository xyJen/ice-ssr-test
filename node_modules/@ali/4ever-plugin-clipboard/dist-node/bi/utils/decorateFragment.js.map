{"version":3,"sources":["../../../../src/bi/utils/decorateFragment.ts"],"names":["FONT_TYPE","SZ_TYPE","getMarksAtAnchor","controller","document","selection","value","anchor","anchorNode","getNode","key","Text","isText","isTextPoint","position","anchorLeaf","leaves","find","leaf","text","length","offset","marks","isSameFontSize","fragment","defaultSz","Firstflag","isDifferent","someDescendant","node","szMark","getMarks","mark","type","decorateFragment","filter","includes","isSameSz","newFragment","mapDescendants","child","forEach","removeMark","addMarks"],"mappings":"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","sourcesContent":["import { Controller, Document, Text } from '@ali/4ever-cangjie';\nimport { isEqual } from 'lodash-es';\n\n// marks type\nconst FONT_TYPE = 'fonts';\nconst SZ_TYPE = 'sz';\n\n/**\n * @description 获取光标所在 leaf 节点的 marks\n * @param {controller}\n * */\nexport function getMarksAtAnchor(controller: Controller) {\n  const { document, selection } = controller.value;\n  const { anchor } = selection;\n  const anchorNode = document.getNode(anchor.key);\n  if (Text.isText(anchorNode) && anchor.isTextPoint()) {\n    let position = 0;\n    const anchorLeaf = anchorNode.leaves.find((leaf) => {\n      position += leaf.text.length;\n      return position >= anchor.offset;\n    });\n    return [...(anchorLeaf?.marks || [])];\n  }\n  return [];\n}\n\nfunction isSameFontSize(fragment: Document) {\n  let defaultSz;\n  let Firstflag = false;\n\n  const isDifferent = fragment.someDescendant((node) => {\n    if (Text.isText(node)) {\n      const szMark = node.getMarks().find((mark) => mark.type === SZ_TYPE);\n      if (!Firstflag) {\n        defaultSz = szMark;\n        Firstflag = true;\n      }\n      if (!isEqual(defaultSz, szMark)) {\n        return true;\n      }\n    }\n    return false;\n  });\n  return !isDifferent;\n}\n\n/**\n * @description\n *  非仓颉内容修饰加工\n *  1. 移除字体类型;\n *  2. 粘贴内容字号相同时，自动与目标字体大小合并\n * @param {Controller} controller\n * @param {Document} fragment\n */\nexport function decorateFragment(controller: Controller, fragment: Document) {\n  const marks = getMarksAtAnchor(controller).filter((mark) =>\n    [FONT_TYPE, SZ_TYPE].includes(mark.type));\n  const szMark = marks.filter((mark) => mark.type === SZ_TYPE);\n\n  const isSameSz = isSameFontSize(fragment);\n  const newFragment = fragment.mapDescendants((node) => {\n    let child = node;\n    if (!Text.isText(child)) {\n      return child;\n    }\n    child.marks.forEach((mark) => {\n      if (mark.type === FONT_TYPE || (mark.type === SZ_TYPE && isSameSz)) {\n        child = (child as Text).removeMark(0, child.text.length, mark);\n      }\n    });\n    if (isSameSz) {\n      return child.addMarks(0, child.text.length, szMark);\n    }\n    return child;\n  });\n  return newFragment;\n}\n"],"file":"decorateFragment.js"}