"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createRenderNode;

var React = _interopRequireWildcard(require("react"));

var _fastDeepEqual = _interopRequireDefault(require("fast-deep-equal"));

var _everCangjie = require("@ali/4ever-cangjie");

var _everPluginMarks = require("@ali/4ever-plugin-marks");

var _backgroundLayer = _interopRequireDefault(require("./components/backgroundLayer"));

var _everUtils = require("@ali/4ever-utils");

const _createElement = /*#__PURE__*/React.createElement;

// 当文字字体大小相同且不为渐变色时，通过自身 background 渲染背景色，否则使用 div 模拟背景色
function shouldRenderBySelf(text) {
  let prevSz = null;
  return text.leaves.every(leaf => {
    const szMark = leaf.marks.find(({
      type
    }) => type === 'sz');
    const sz = szMark?.data || null;
    const isSameSize = !prevSz || (0, _fastDeepEqual.default)(sz, prevSz);
    prevSz = sz;
    const colorMark = leaf.marks.find(({
      type
    }) => type === 'color');
    const color = colorMark?.data?.value;
    return isSameSize && !(0, _everUtils.isGradientColor)(color);
  });
}

function shouldAntiAliasing(node) {
  return node.nodes.length > 1 || !_everCangjie.Text.isTextList(node.nodes) || !node.nodes.every(shouldRenderBySelf);
}

const cachedMarksMap = new WeakMap();

function buildHightlightMarks(node) {
  const cachedMarks = cachedMarksMap.get(node);

  if (cachedMarks) {
    return cachedMarks;
  }

  const marks = [];
  node.getTexts().forEach(text => {
    let offset = 0;
    text.leaves.forEach(leaf => {
      const inlineCodeMark = leaf.marks.find(mark => mark.type === 'inlineCode'); // 存在 行内代码 样式，则忽略其他背景色效果

      if (inlineCodeMark) {
        marks.push({
          mark: inlineCodeMark,
          key: text.key,
          offset
        });
        offset += leaf.text.length;
        return;
      }

      let colorMark;
      leaf.marks.forEach(mark => {
        if (mark.type === 'highlight') {
          colorMark = mark;
        } else if (mark.type === 'shd') {
          colorMark = colorMark || mark;
        }
      });

      if (colorMark) {
        const {
          key
        } = text;
        marks.push({
          mark: colorMark,
          key,
          offset
        });
      }

      offset += leaf.text.length;
    });
  });
  cachedMarksMap.set(node, marks);
  return marks;
}

const marksOption = {
  disableHighlight: true
};
const COLORS_WHITE = ['rgba(0,0,0,0)', 'white'];
/**
 * 如果是白色的 mark，直接无视掉。
 * 一些外部拷贝的内容可能会加很多白色背景，严重影响性能。
 */

const invalidMark = m => {
  const color = String(m.mark.data.value).replace(/ /g, '');
  return COLORS_WHITE.some(c => c === color);
};

function createRenderNode(configs) {
  const {
    disableAntiAliasing
  } = configs || {};
  return function renderNode(props, controller, next) {
    const {
      node,
      children
    } = props;

    if (!_everCangjie.Block.isLeafBlock(node)) {
      return next();
    }

    const isAntiAliasingDisabled = disableAntiAliasing && disableAntiAliasing() === true;

    if (isAntiAliasingDisabled || !shouldAntiAliasing(node)) {
      return next();
    }

    const marks = buildHightlightMarks(node);

    if (!marks.length || marks.every(invalidMark)) {
      return next();
    }

    const newChildren = () => {
      return /*#__PURE__*/_createElement(_everPluginMarks.MarksOptionContext.Provider, {
        value: marksOption
      }, /*#__PURE__*/_createElement(_backgroundLayer.default, {
        marks: marks,
        node: node,
        controller: controller
      }), children());
    };

    const newProps = { ...props,
      children: newChildren
    };
    return next(newProps);
  };
}
//# sourceMappingURL=renderNode.js.map