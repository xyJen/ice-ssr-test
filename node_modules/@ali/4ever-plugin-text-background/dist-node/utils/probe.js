"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useMeasureProbe = exports.MeasureProbeContext = exports.ProbeProvider = void 0;

var _react = _interopRequireWildcard(require("react"));

var _everCangjie = require("@ali/4ever-cangjie");

var _everUtils = require("@ali/4ever-utils");

var _lodash = require("lodash");

const _createElement = /*#__PURE__*/_react.default.createElement;
const {
  defaultKeyTypographyStyle
} = _everUtils.theme;
const THROTTLE_TIME_RESIZE = 200;
const probeStyle = { ...defaultKeyTypographyStyle,
  // 绝对布局 + 100%，限制只在 data-cangjie-content 区域变化时才触发变化
  position: 'absolute',
  zIndex: -1,
  width: '100%',
  visibility: 'hidden',
  pointerEvents: 'none',
  top: 0,
  left: 0
};

const Probe = props => {
  const {
    controller,
    onRef
  } = props; // 探测需要响应全局样式

  const globleStyle = (0, _everCangjie.useContentStyle)(controller);
  /**
   * 使用 shadow dom：
   * 1. 避免在正文内插入节点导致大量单测受影响（影响单测中 content.text）
   * 2. 隔离样式，避免性能问题
   */

  return /*#__PURE__*/_createElement(_everCangjie.ShadowRoot, null, /*#__PURE__*/_createElement("div", {
    ref: onRef,
    style: { ...probeStyle,
      ...globleStyle
    }
  }, "\u4E2D"));
};

const ProbeProvider = props => {
  const [needUpdate, update] = (0, _react.useState)(undefined);
  const probeRef = (0, _react.useRef)();
  const obRef = (0, _react.useRef)();
  const updateRef = (0, _react.useRef)(undefined);
  const {
    controller
  } = props;
  const pgMar = (0, _everUtils.getSectPr)(controller.value.document.data, 'pgMar');
  const left = Math.round(pgMar.left || 0);
  const right = Math.round(pgMar.right || 0);
  const handleResize = (0, _react.useCallback)((0, _lodash.debounce)(() => {
    update(!updateRef.current);
    updateRef.current = !updateRef.current;
  }, THROTTLE_TIME_RESIZE, {
    leading: true
  }), []); // TODO: 因为表格里可能会 puring（在第一次 render 后再 display none）
  // 在 display:none 的情况触发重算会导致背景消失
  // 这里 hack 仅确保第一次渲染不出问题

  (0, _react.useEffect)(() => {
    // 响应页边距 left 和 right
    if (updateRef.current !== undefined) handleResize(); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [handleResize, left, right]);
  const onRef = (0, _react.useCallback)(node => {
    if (node && window.ResizeObserver) {
      probeRef.current = node;
      obRef.current = new window.ResizeObserver(handleResize);
      obRef.current.observe(node);
    }

    return undefined;
  }, [handleResize]);
  (0, _react.useEffect)(() => {
    return () => {
      handleResize.cancel();

      if (obRef.current && probeRef.current) {
        obRef.current.unobserve(probeRef.current);
      }
    };
  }, [handleResize]);
  return /*#__PURE__*/_createElement(MeasureProbeContext.Provider, {
    value: needUpdate
  }, props.children, /*#__PURE__*/_createElement(Probe, {
    onRef: onRef,
    controller: controller
  }));
};
/**
 * 探测编辑区域 resize
 * 原因可能是窗口 resize 或 默认字号变化等原因
 */


exports.ProbeProvider = ProbeProvider;

const MeasureProbeContext = /*#__PURE__*/_react.default.createContext(undefined);
/**
 * 返回探测结果
 * Boolean 值标识是否改变
 * @returns Boolean
 */


exports.MeasureProbeContext = MeasureProbeContext;

const useMeasureProbe = () => {
  return _react.default.useContext(MeasureProbeContext);
};

exports.useMeasureProbe = useMeasureProbe;
//# sourceMappingURL=probe.js.map