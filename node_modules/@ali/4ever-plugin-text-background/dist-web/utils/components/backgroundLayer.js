import _extends from "@babel/runtime/helpers/extends";
import * as React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import { domUtils, useZoom, constants, useLeafBlockResizer } from '@ali/4ever-cangjie';
import styled from 'styled-components';
import { useMeasureProbe } from "../probe";
import { ShdUtil } from '@ali/4ever-utils';
var TextLayer = /*#__PURE__*/styled.div(["float:left;position:relative;width:0;height:0;& ~ *{position:relative;}"]);

function getRenderItems(overlayDom, marks) {
  var items = [];

  if (!overlayDom) {
    return items;
  }

  var parentDOMNode = overlayDom.parentElement;

  if (!parentDOMNode) {
    return items;
  }

  var rows = domUtils.splitRows(parentDOMNode);
  var overlayRect = overlayDom.getBoundingClientRect();
  marks.forEach(function (mark) {
    var domNode = parentDOMNode.querySelector("[data-cangjie-key='" + mark.key + ":" + mark.offset + "']");

    if (!domNode) {
      return;
    }

    var boundingRects = Array.from(domNode.getClientRects());
    var rects = domUtils.fitRows(rows, boundingRects, overlayRect);

    if (!rects.length) {
      return;
    }

    var color;

    if (mark.mark.type === 'highlight' && mark.mark.data.value !== 'transparent') {
      color = mark.mark.data.value;
    } else if (mark.mark.type === 'shd') {
      color = ShdUtil.transformShd(mark.mark.data);
    }

    if (color === 'transparent') {
      return;
    }

    var item = items.find(function (i) {
      return i.color === color;
    });

    if (item) {
      item.rects = item.rects.concat(rects);
    } else {
      var key = mark.key;
      items.push({
        color: color,
        key: key,
        rects: rects
      });
    }
  });
  return items.map(function (item) {
    return _extends({}, item, {
      rects: domUtils.mergeRects(item.rects)
    });
  });
}

var BackgroundOverlay = /*#__PURE__*/React.memo(function (props) {
  var _attrbiute;

  var marks = props.marks,
      zoom = props.zoom;
  var ref = React.useRef(null);

  var _React$useState = React.useState([]),
      renderItems = _React$useState[0],
      setRenderItems = _React$useState[1];

  var updateMarks = React.useCallback(function () {
    var newItems = getRenderItems(ref.current, marks);
    setRenderItems(newItems);
  }, [marks]);
  React.useEffect(function () {
    updateMarks();
  }, [marks, updateMarks, zoom]);
  useLeafBlockResizer(ref, updateMarks, [marks]);
  var probeChanged = useMeasureProbe();
  React.useEffect(function () {
    if (probeChanged !== undefined) {
      // TODO: 因为引入了 puring，放弃使用 probe 带来的性能优化，@多鱼后续考虑性能优化吧
      // 策略：在表格和高亮块里监听原来的 leafBlock，其它走全局的 probe 探测
      updateMarks();
    }
  }, [updateMarks, probeChanged]);
  var attrbiute = (_attrbiute = {}, _attrbiute[constants.Selector.nonSelect] = true, _attrbiute);
  return /*#__PURE__*/_createElement(TextLayer, {
    ref: ref,
    "data-cangjie-text-layer": true
  }, renderItems.map(function (renderItem) {
    return renderItem.rects && renderItem.rects.map(function (rect) {
      var backgroundColor = renderItem.color;
      var position = 'absolute';
      var left = rect.left,
          top = rect.top,
          width = rect.width,
          height = rect.height;
      var keyStr = renderItem.key + "-" + left + "-" + top + "-" + width + "-" + height;
      var style = {
        position: position,
        left: left / zoom,
        top: top / zoom,
        width: width / zoom,
        height: height / zoom,
        backgroundColor: backgroundColor
      };
      return /*#__PURE__*/_createElement("div", _extends({}, attrbiute, {
        key: keyStr,
        style: style
      }));
    });
  }));
});
export default (function (props) {
  var zoom = useZoom();
  return /*#__PURE__*/_createElement(BackgroundOverlay, _extends({}, props, {
    zoom: zoom
  }));
});
//# sourceMappingURL=backgroundLayer.js.map