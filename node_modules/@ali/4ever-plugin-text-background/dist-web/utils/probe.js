import _extends from "@babel/runtime/helpers/extends";
import React, { useState, useRef, useEffect, useCallback } from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import { useContentStyle, ShadowRoot } from '@ali/4ever-cangjie';
import { getSectPr, theme } from '@ali/4ever-utils';
import { debounce } from 'lodash-es';
var defaultKeyTypographyStyle = theme.defaultKeyTypographyStyle;
var THROTTLE_TIME_RESIZE = 200;

var probeStyle = _extends({}, defaultKeyTypographyStyle, {
  // 绝对布局 + 100%，限制只在 data-cangjie-content 区域变化时才触发变化
  position: 'absolute',
  zIndex: -1,
  width: '100%',
  visibility: 'hidden',
  pointerEvents: 'none',
  top: 0,
  left: 0
});

var Probe = function Probe(props) {
  var controller = props.controller,
      onRef = props.onRef; // 探测需要响应全局样式

  var globleStyle = useContentStyle(controller);
  /**
   * 使用 shadow dom：
   * 1. 避免在正文内插入节点导致大量单测受影响（影响单测中 content.text）
   * 2. 隔离样式，避免性能问题
   */

  return /*#__PURE__*/_createElement(ShadowRoot, null, /*#__PURE__*/_createElement("div", {
    ref: onRef,
    style: _extends({}, probeStyle, globleStyle)
  }, "\u4E2D"));
};

export var ProbeProvider = function ProbeProvider(props) {
  var _useState = useState(undefined),
      needUpdate = _useState[0],
      update = _useState[1];

  var probeRef = useRef();
  var obRef = useRef();
  var updateRef = useRef(undefined);
  var controller = props.controller;
  var pgMar = getSectPr(controller.value.document.data, 'pgMar');
  var left = Math.round(pgMar.left || 0);
  var right = Math.round(pgMar.right || 0);
  var handleResize = useCallback(debounce(function () {
    update(!updateRef.current);
    updateRef.current = !updateRef.current;
  }, THROTTLE_TIME_RESIZE, {
    leading: true
  }), []); // TODO: 因为表格里可能会 puring（在第一次 render 后再 display none）
  // 在 display:none 的情况触发重算会导致背景消失
  // 这里 hack 仅确保第一次渲染不出问题

  useEffect(function () {
    // 响应页边距 left 和 right
    if (updateRef.current !== undefined) handleResize(); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [handleResize, left, right]);
  var onRef = useCallback(function (node) {
    if (node && window.ResizeObserver) {
      probeRef.current = node;
      obRef.current = new window.ResizeObserver(handleResize);
      obRef.current.observe(node);
    }

    return undefined;
  }, [handleResize]);
  useEffect(function () {
    return function () {
      handleResize.cancel();

      if (obRef.current && probeRef.current) {
        obRef.current.unobserve(probeRef.current);
      }
    };
  }, [handleResize]);
  return /*#__PURE__*/_createElement(MeasureProbeContext.Provider, {
    value: needUpdate
  }, props.children, /*#__PURE__*/_createElement(Probe, {
    onRef: onRef,
    controller: controller
  }));
};
/**
 * 探测编辑区域 resize
 * 原因可能是窗口 resize 或 默认字号变化等原因
 */

export var MeasureProbeContext = /*#__PURE__*/React.createContext(undefined);
/**
 * 返回探测结果
 * Boolean 值标识是否改变
 * @returns Boolean
 */

export var useMeasureProbe = function useMeasureProbe() {
  return React.useContext(MeasureProbeContext);
};
//# sourceMappingURL=probe.js.map