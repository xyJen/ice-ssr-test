import _extends from "@babel/runtime/helpers/extends";
import * as React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import equal from 'fast-deep-equal';
import { Block, Text } from '@ali/4ever-cangjie';
import { MarksOptionContext } from '@ali/4ever-plugin-marks';
import BackgroundOverlay from "./components/backgroundLayer";
import { isGradientColor } from '@ali/4ever-utils';

// 当文字字体大小相同且不为渐变色时，通过自身 background 渲染背景色，否则使用 div 模拟背景色
function shouldRenderBySelf(text) {
  var prevSz = null;
  return text.leaves.every(function (leaf) {
    var _colorMark$data;

    var szMark = leaf.marks.find(function (_ref) {
      var type = _ref.type;
      return type === 'sz';
    });
    var sz = (szMark == null ? void 0 : szMark.data) || null;
    var isSameSize = !prevSz || equal(sz, prevSz);
    prevSz = sz;
    var colorMark = leaf.marks.find(function (_ref2) {
      var type = _ref2.type;
      return type === 'color';
    });
    var color = colorMark == null ? void 0 : (_colorMark$data = colorMark.data) == null ? void 0 : _colorMark$data.value;
    return isSameSize && !isGradientColor(color);
  });
}

function shouldAntiAliasing(node) {
  return node.nodes.length > 1 || !Text.isTextList(node.nodes) || !node.nodes.every(shouldRenderBySelf);
}

var cachedMarksMap = new WeakMap();

function buildHightlightMarks(node) {
  var cachedMarks = cachedMarksMap.get(node);

  if (cachedMarks) {
    return cachedMarks;
  }

  var marks = [];
  node.getTexts().forEach(function (text) {
    var offset = 0;
    text.leaves.forEach(function (leaf) {
      var inlineCodeMark = leaf.marks.find(function (mark) {
        return mark.type === 'inlineCode';
      }); // 存在 行内代码 样式，则忽略其他背景色效果

      if (inlineCodeMark) {
        marks.push({
          mark: inlineCodeMark,
          key: text.key,
          offset: offset
        });
        offset += leaf.text.length;
        return;
      }

      var colorMark;
      leaf.marks.forEach(function (mark) {
        if (mark.type === 'highlight') {
          colorMark = mark;
        } else if (mark.type === 'shd') {
          colorMark = colorMark || mark;
        }
      });

      if (colorMark) {
        var key = text.key;
        marks.push({
          mark: colorMark,
          key: key,
          offset: offset
        });
      }

      offset += leaf.text.length;
    });
  });
  cachedMarksMap.set(node, marks);
  return marks;
}

var marksOption = {
  disableHighlight: true
};
var COLORS_WHITE = ['rgba(0,0,0,0)', 'white'];
/**
 * 如果是白色的 mark，直接无视掉。
 * 一些外部拷贝的内容可能会加很多白色背景，严重影响性能。
 */

var invalidMark = function invalidMark(m) {
  var color = String(m.mark.data.value).replace(/ /g, '');
  return COLORS_WHITE.some(function (c) {
    return c === color;
  });
};

export default function createRenderNode(configs) {
  var _ref3 = configs || {},
      disableAntiAliasing = _ref3.disableAntiAliasing;

  return function renderNode(props, controller, next) {
    var node = props.node,
        children = props.children;

    if (!Block.isLeafBlock(node)) {
      return next();
    }

    var isAntiAliasingDisabled = disableAntiAliasing && disableAntiAliasing() === true;

    if (isAntiAliasingDisabled || !shouldAntiAliasing(node)) {
      return next();
    }

    var marks = buildHightlightMarks(node);

    if (!marks.length || marks.every(invalidMark)) {
      return next();
    }

    var newChildren = function newChildren() {
      return /*#__PURE__*/_createElement(MarksOptionContext.Provider, {
        value: marksOption
      }, /*#__PURE__*/_createElement(BackgroundOverlay, {
        marks: marks,
        node: node,
        controller: controller
      }), children());
    };

    var newProps = _extends({}, props, {
      children: newChildren
    });

    return next(newProps);
  };
}
//# sourceMappingURL=renderNode.js.map