{"version":3,"sources":["../../../src/utils/conditions.ts"],"names":["Heading","indent","isList","getOffsetLeft","node","data","ind","left","firstLine","list","level","size","listGroupConditions","when","nextNode","isHeading","blockquote","calloutPr","until","lastFoldNode","currentList","lastFoldList"],"mappings":"AACA,SAASA,OAAT,QAAwB,2BAAxB;AACA,SAASC,MAAT,QAAuB,kBAAvB;AAEA,SAASC,MAAT;;AAEA,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAACC,IAAD,EAAyB;AAAA;;AAAA,aACT,eAAAA,IAAI,CAACC,IAAL,gCAAWC,GAAX,KAAkB,EADT;AAAA,uBACrCC,IADqC;AAAA,MACrCA,IADqC,0BAC9B,CAD8B;AAAA,4BAC3BC,SAD2B;AAAA,MAC3BA,SAD2B,+BACf,CADe;;AAAA,8BAEvBJ,IAAI,CAACC,IAAL,CAAUI,IAFa,CAErCC,KAFqC;AAAA,MAErCA,KAFqC,sCAE7B,CAF6B;AAG7C,SAAOH,IAAI,GAAGC,SAAP,GAAmBE,KAAK,GAAGT,MAAM,CAACU,IAAzC;AACD,CAJD;;AAMA,OAAO,IAAMC,mBASX,GAAG,CACH;AACEC,EAAAA,IAAI,EAAE,cAACT,IAAD,EAAcU,QAAd,EAAkC;AACtC,QAAI,CAACZ,MAAM,CAACE,IAAD,CAAP,IAAiB,CAACF,MAAM,CAACY,QAAD,CAA5B,EAAwC;AACtC,aAAO,KAAP;AACD,KAHqC,CAItC;;;AACA,QAAId,OAAO,CAACe,SAAR,CAAkBX,IAAlB,CAAJ,EAA6B;AAC3B,aAAO,KAAP;AACD;;AACD,QAAIA,IAAI,CAACC,IAAL,CAAUW,UAAd,EAA0B;AACxB,aAAO,KAAP;AACD,KAVqC,CAYtC;;;AACA,QAAIZ,IAAI,CAACC,IAAL,CAAUY,SAAd,EAAyB;AACvB,aAAO,KAAP;AACD,KAfqC,CAgBtC;;;AACA,QAAId,aAAa,CAACC,IAAD,CAAb,IAAuBD,aAAa,CAACW,QAAD,CAAxC,EAAoD;AAClD,aAAO,KAAP;AACD;;AACD,WAAQA,QAAQ,CAACT,IAAT,CAAcI,IAAd,CAAmBC,KAAnB,GAA2BN,IAAI,CAACC,IAAL,CAAUI,IAAV,CAAeC,KAAlD;AACD,GAtBH;AAuBEQ,EAAAA,KAAK,EAAE,eAACd,IAAD,EAAce,YAAd,EAAsC;AAC3C,QAAI,CAACjB,MAAM,CAACE,IAAD,CAAX,EAAmB;AACjB,aAAO,IAAP;AACD,KAH0C,CAI3C;;;AACA,QAAID,aAAa,CAACC,IAAD,CAAb,IAAuBD,aAAa,CAACgB,YAAD,CAAxC,EAAwD;AACtD,aAAO,IAAP;AACD;;AAP0C,QAQ7BC,WAR6B,GAQbhB,IAAI,CAACC,IARQ,CAQnCI,IARmC;AAAA,QAS7BY,YAT6B,GASZF,YAAY,CAACd,IATD,CASnCI,IATmC;AAU3C,WAAOW,WAAW,CAACV,KAAZ,IAAqBW,YAAY,CAACX,KAAzC;AACD;AAlCH,CADG,CATE","sourcesContent":["import { Block } from '@ali/4ever-cangjie';\nimport { Heading } from '@ali/4ever-plugin-heading';\nimport { indent } from '@ali/4ever-utils';\n\nimport { isList } from './utils';\n\nconst getOffsetLeft = (node: Block): number => {\n  const { left = 0, firstLine = 0 } = node.data?.ind || {};\n  const { level = 0 } = node.data.list;\n  return left + firstLine + level * indent.size;\n}\n\nexport const listGroupConditions: Array<{\n  /**\n   * 聚合列表\n   */\n  when: (node: any, nextNode: any) => boolean;\n  /**\n   * 聚合截止\n   */\n  until: (node: any, lastFoldNode: Block) => boolean;\n}> = [\n  {\n    when: (node: Block, nextNode: Block) => {\n      if (!isList(node) || !isList(nextNode)) {\n        return false;\n      }\n      // 标题类型列表不使用连接线\n      if (Heading.isHeading(node)) {\n        return false;\n      }\n      if (node.data.blockquote) {\n        return false;\n      }\n      \n      // 旧高亮块嵌套列表，可能会出现死循环\n      if (node.data.calloutPr) {\n        return false;\n      }\n      // 列表有 ind 值, 需要子项的左边距大于折叠点的左边距，防止与连接线重叠\n      if (getOffsetLeft(node) >= getOffsetLeft(nextNode)) {\n        return false;\n      }\n      return (nextNode.data.list.level > node.data.list.level);\n    },\n    until: (node: Block, lastFoldNode: Block) => {\n      if (!isList(node)) {\n        return true;\n      }\n      // 列表有 ind 值, 项的左边距小于折叠点的左边距时，防止重叠，结束折叠规则\n      if (getOffsetLeft(node) <= getOffsetLeft(lastFoldNode)) {\n        return true;\n      }\n      const { list: currentList } = node.data;\n      const { list: lastFoldList } = lastFoldNode.data;\n      return currentList.level <= lastFoldList.level;\n    },\n  },\n];\n"],"file":"conditions.js"}