"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.listGroupConditions = void 0;

var _everPluginHeading = require("@ali/4ever-plugin-heading");

var _everUtils = require("@ali/4ever-utils");

var _utils = require("./utils");

const getOffsetLeft = node => {
  const {
    left = 0,
    firstLine = 0
  } = node.data?.ind || {};
  const {
    level = 0
  } = node.data.list;
  return left + firstLine + level * _everUtils.indent.size;
};

const listGroupConditions = [{
  when: (node, nextNode) => {
    if (!(0, _utils.isList)(node) || !(0, _utils.isList)(nextNode)) {
      return false;
    } // 标题类型列表不使用连接线


    if (_everPluginHeading.Heading.isHeading(node)) {
      return false;
    }

    if (node.data.blockquote) {
      return false;
    } // 旧高亮块嵌套列表，可能会出现死循环


    if (node.data.calloutPr) {
      return false;
    } // 列表有 ind 值, 需要子项的左边距大于折叠点的左边距，防止与连接线重叠


    if (getOffsetLeft(node) >= getOffsetLeft(nextNode)) {
      return false;
    }

    return nextNode.data.list.level > node.data.list.level;
  },
  until: (node, lastFoldNode) => {
    if (!(0, _utils.isList)(node)) {
      return true;
    } // 列表有 ind 值, 项的左边距小于折叠点的左边距时，防止重叠，结束折叠规则


    if (getOffsetLeft(node) <= getOffsetLeft(lastFoldNode)) {
      return true;
    }

    const {
      list: currentList
    } = node.data;
    const {
      list: lastFoldList
    } = lastFoldNode.data;
    return currentList.level <= lastFoldList.level;
  }
}];
exports.listGroupConditions = listGroupConditions;
//# sourceMappingURL=conditions.js.map