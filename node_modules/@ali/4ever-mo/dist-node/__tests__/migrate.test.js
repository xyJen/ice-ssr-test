"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _everDevTest = require("@ali/4ever-dev-test");

var _everUtils = require("@ali/4ever-utils");

var _ = require("..");

var _migrate = _interopRequireWildcard(require("../migrate"));

var _type = require("../type");

var _version = require("../version");

var _createMigration = _interopRequireDefault(require("../migrations/createMigration"));

/** @jsx jsx */
var _ref = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref2 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref3 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref4 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref5 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref6 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref7 = (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello"));

var _ref8 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref9 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref10 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref11 = (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello"));

describe('#migrate', () => {
  const migrations = [{
    prevVersion: 1,
    nextVersion: 2,
    upgrade: document => {
      return document.set('data', { ...document.data,
        vv: 2
      });
    },
    downgrade: document => {
      return document.set('data', { ...document.data,
        vv: 1
      });
    }
  }, {
    prevVersion: 2,
    nextVersion: 3,
    upgrade: document => {
      return document.set('data', { ...document.data,
        vv: 3
      });
    },
    downgrade: document => {
      return document.set('data', { ...document.data,
        vv: 2
      });
    }
  }];
  test('逐版本升级模型', () => {
    const corrections = [cp => {
      if (typeof cp === 'string') {
        return JSON.parse(cp);
      }

      return cp;
    }, cp => {
      const data = (0, _everUtils.getAttributes)(cp);

      if (!data.ok) {
        return [cp[0], { ...data,
          ok: true
        }, ...cp.slice(2)];
      }

      return cp;
    }];

    const src = _.moSerializer.nodeToJsonML((0, _everDevTest.jsx)("document", {
      data: {
        [_version.KEY_OF_VERSION]: 1
      }
    }, _ref));

    const cp = (0, _migrate.default)({
      src: JSON.stringify(src),
      migrations,
      corrections,
      targetVersion: 3
    });

    const expected = _.moSerializer.nodeToJsonML((0, _everDevTest.jsx)("document", {
      data: {
        [_version.KEY_OF_VERSION]: 3,
        vv: 3,
        ok: true
      }
    }, _ref2));

    expect(cp).toEqual(expected);
  });
  test('逐版本降级模型', () => {
    const src = _.moSerializer.nodeToJsonML((0, _everDevTest.jsx)("document", {
      data: {
        [_version.KEY_OF_VERSION]: 3
      }
    }, _ref3));

    const cp = (0, _migrate.default)({
      src,
      migrations,
      corrections: [],
      targetVersion: 1
    });

    const expected = _.moSerializer.nodeToJsonML((0, _everDevTest.jsx)("document", {
      data: {
        [_version.KEY_OF_VERSION]: 1,
        vv: 1
      }
    }, _ref4));

    expect(cp).toEqual(expected);
  });
  test('版本未变更时，不迁移', () => {
    // 缺失版本号为 1
    const srcCp = ['root'];
    const cp = (0, _migrate.default)({
      src: srcCp,
      migrations,
      corrections: [],
      targetVersion: 1
    });
    expect(cp).toBe(srcCp);
  });
  test('遇到异常时，中断迁移', () => {
    const onError = jest.fn();
    const srcCp = ['root', {
      [_version.KEY_OF_VERSION]: 1
    }];
    const cp = (0, _migrate.default)({
      src: srcCp,
      migrations: [{
        prevVersion: 1,
        nextVersion: 2,
        upgrade: cp => {
          throw Error('Bomb!');
        },
        downgrade: cp => cp
      }],
      corrections: [],
      targetVersion: 2,
      onError
    });
    expect(cp).toBe(srcCp);
    expect(onError).toBeCalledWith({
      code: _type.MigrateErrorCode.Unknown,
      message: expect.anything()
    });
  });
  test('缺失迁移脚本时，抛出异常', () => {
    const onError = jest.fn();
    const srcCp = ['root', {
      [_version.KEY_OF_VERSION]: 1
    }];
    const cp = (0, _migrate.default)({
      src: srcCp,
      migrations: [],
      corrections: [],
      targetVersion: 2,
      onError
    });
    expect(cp).toBe(srcCp);
    expect(onError).toBeCalledWith(_migrate.MissingMigrationError);
  });
  test('初始版本允许无迁移脚本', () => {
    const onError = jest.fn();

    const src = _.moSerializer.nodeToJsonML((0, _everDevTest.jsx)("document", {
      data: {
        [_version.KEY_OF_VERSION]: -1
      }
    }, _ref5));

    const migrated = (0, _migrate.default)({
      src,
      migrations: [],
      corrections: [],
      targetVersion: 1,
      onError
    });

    const expected = _.moSerializer.nodeToJsonML((0, _everDevTest.jsx)("document", {
      data: {
        [_version.KEY_OF_VERSION]: 1
      }
    }, _ref6));

    expect(migrated).toEqual(expected);
    expect(onError).not.toBeCalled();
  });
  test('支持缺失版本号的 CP 升级', () => {
    const src = _.moSerializer.nodeToJsonML(_ref7);

    const cp = (0, _migrate.default)({
      src,
      migrations,
      corrections: [],
      targetVersion: 2
    });

    const expected = _.moSerializer.nodeToJsonML((0, _everDevTest.jsx)("document", {
      data: {
        [_version.KEY_OF_VERSION]: 2,
        vv: 2
      }
    }, _ref8));

    expect(cp).toEqual(expected);
  });
  test('若 src 为内存模型，则返回升级后的内存模型', () => {
    const document = (0, _everDevTest.jsx)("document", {
      data: {
        [_version.KEY_OF_VERSION]: 1
      }
    }, _ref9);
    const cp = (0, _migrate.default)({
      src: document,
      migrations,
      corrections: [],
      targetVersion: 3
    });
    const expected = (0, _everDevTest.jsx)("document", {
      data: {
        [_version.KEY_OF_VERSION]: 3,
        vv: 3
      }
    }, _ref10);
    expect(cp.toJSON()).toEqual(expected.toJSON());
  });
  test('若 src 为内存模型，且版本无变更，不迁移并返回内存模型', () => {
    const document = // 缺省版本为 1
    _ref11;
    const cp = (0, _migrate.default)({
      src: document,
      migrations,
      corrections: [],
      targetVersion: 1
    });
    expect(cp).toBe(document);
  });
});

var _ref12 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref13 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

describe('#createMigration', () => {
  test('自定义迁移算法将依次升级 cp', () => {
    const algs = [{
      upgrade: document => document.set('data', { ...document.data,
        count: document.data.count + 1
      }),
      downgrade: document => document.set('data', { ...document.data,
        count: document.data.count - 1
      })
    }, {
      upgrade: document => document.set('data', { ...document.data,
        count: document.data.count + 1
      }),
      downgrade: document => document.set('data', { ...document.data,
        count: document.data.count - 1
      })
    }];
    const migration = (0, _createMigration.default)(1, 2, algs);
    const documentV1 = (0, _everDevTest.jsx)("document", {
      data: {
        count: 0
      }
    }, _ref12);
    const documentV2 = (0, _everDevTest.jsx)("document", {
      data: {
        count: 2
      }
    }, _ref13);
    const upgraded = migration.upgrade(documentV1);
    const downgraded = migration.downgrade(documentV2);
    expect(upgraded.toJSON()).toEqual(documentV2.toJSON());
    expect(downgraded.toJSON()).toEqual(documentV1.toJSON());
  });
});
//# sourceMappingURL=migrate.test.js.map