/* eslint-disable react-hooks/exhaustive-deps */
import React, { useEffect, useState, useRef, useCallback } from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import { Dropdown, Tooltip } from '@ali/we-design';
import { DropdownAnimation } from '@ali/we-util';
import { Commands } from '@ali/4ever-cangjie';
import { useScrollableContent } from '@ali/4ever-cangjie';
import { ActiveInteractionHooks } from '@ali/4ever-component';
import DragMenu from "./dragMenu";
import { DragHand, TooltipText, PrimaryText, DragIcon } from "./styled";
import getElementType from "../utils/getElementType";
import { updateDragHighlight, updateDragHander, mountDragHander, removeDragHighlightSingle } from "../actions";
import dragStartHandler from "../dragEventHandlers/dragStartHandler";
import { getDraggableData } from "../model/draggableData";
import { useLeftToolbar } from '@ali/4ever-component';
import { getSiblingDraggableBlocks } from "../utils";
import { dispatchCustomEvent, LEGAL_EVENT } from '@ali/4ever-utils';
import { DraggableRole } from "../../utils/role";
var removeHighlightTimer;
var useActiveInteraction = ActiveInteractionHooks.useActiveInteraction;

var DragDropdown = function DragDropdown(props) {
  var controller = props.controller,
      _props$scale = props.scale,
      scale = _props$scale === void 0 ? 1 : _props$scale,
      currentBlock = props.currentBlock,
      onClickIcon = props.onClickIcon,
      active = props.active,
      draggableConfig = props.draggableConfig,
      customizeMenus = props.customizeMenus,
      _props$dragHanderclas = props.dragHanderclassName,
      dragHanderclassName = _props$dragHanderclas === void 0 ? '' : _props$dragHanderclas,
      disableDrag = props.disableDrag,
      handleClickMenuItem = props.handleClickMenuItem;

  var _ref = draggableConfig || {},
      locale = _ref.locale,
      getCopyURL = _ref.getCopyURL,
      shareParagraph = _ref.shareParagraph,
      hetu = _ref.hetu,
      refblock = _ref.refblock,
      _ref$extraTransformMe = _ref.extraTransformMenu,
      extraTransformMenu = _ref$extraTransformMe === void 0 ? [] : _ref$extraTransformMe,
      _ref$trigger = _ref.trigger,
      trigger = _ref$trigger === void 0 ? 'hover' : _ref$trigger;

  var container = useScrollableContent() || document.body; // 是否触发过高亮

  var highlightRef = useRef(false);

  var _useState = useState(false),
      dragMenuVisible = _useState[0],
      setDragMenuVisible = _useState[1];

  var _useActiveInteraction = useActiveInteraction(),
      activeType = _useActiveInteraction[0],
      setActiveType = _useActiveInteraction[1];

  var activeRef = React.useRef('');
  activeRef.current = activeType;
  var timeout = useRef(null);

  var _useLeftToolbar = useLeftToolbar(),
      actions = _useLeftToolbar[1];

  var type = getElementType(currentBlock); // 优先根据传入配置判断

  var _ref2 = controller.query('getDraggableConfig') || {},
      _ref2$forbiddenElemen = _ref2.forbiddenElements,
      forbiddenElements = _ref2$forbiddenElemen === void 0 ? {} : _ref2$forbiddenElemen;

  var isForbidden = forbiddenElements[type];
  /**
   * 非必要时候不要使用utils中的全局高亮移除方法
   * 因为由于调用执行时机的问题会导致很多情况下一些
   * 不必要移除的高亮被移除。
   * 每个组件只需要保证对自己添加的那部分高亮进行移除即可
   * 保证各自职责分明。
   */

  var removeDragHighlight = React.useCallback(function (type) {
    if (type === void 0) {
      type = 'hover';
    }

    // 如果是表格的话就走定制背景色
    var isTableHighlight = controller.query('isTable', currentBlock);
    controller.run('onAction', removeDragHighlightSingle({
      key: currentBlock == null ? void 0 : currentBlock.key,
      isTableHighlight: isTableHighlight,
      type: type
    }));
  }, [currentBlock]);
  var updateDragHighlightByType = React.useCallback(function (type) {
    if (type === void 0) {
      type = 'hover';
    }

    if (!currentBlock) return; // 如果是表格的话就走定制背景色

    var isTableHighlight = controller.query('isTable', currentBlock);
    controller.run('onAction', updateDragHighlight({
      key: currentBlock == null ? void 0 : currentBlock.key,
      isTableHighlight: isTableHighlight,
      type: type
    }));
  }, [currentBlock]);
  var removeAllDragHighlight = React.useCallback(function () {
    removeDragHighlight('select');
    removeDragHighlight('hover');
  }, [removeDragHighlight]);
  useEffect(function () {
    if (currentBlock) {
      controller.run('onAction', updateDragHander({
        viewKey: currentBlock == null ? void 0 : currentBlock.key,
        type: 'hover'
      }));
    } else {
      controller.run('onAction', updateDragHander());
    }
  }, [currentBlock]);
  useEffect(function () {
    if (!dragMenuVisible && activeRef.current === 'leftMenu') {
      setActiveType('');
    }
  }, [dragMenuVisible, setActiveType]);
  useEffect(function () {
    return function () {
      actions.clearPrevent();
      /**
       * 组件 unmount 的时候移除高亮
       * 这个逻辑可以保证大多数场景下被添加的高亮被移除。
       * 但是表格的cornerToolbar例外，其生命周期跟随表格
       * 并非在鼠标移出后卸载，因此需要在mouseLeave的时候
       * 对高亮进行移除
       */

      highlightRef.current && removeAllDragHighlight();
      timeout.current && clearTimeout(timeout.current);
    };
  }, [removeAllDragHighlight]);
  var onMouseUp = useCallback(function (e) {
    e.stopPropagation();
    if (!currentBlock) return;
    var startBlock = controller.value.startBlock;
    if ((currentBlock == null ? void 0 : currentBlock.key) === (startBlock == null ? void 0 : startBlock.key)) return;
    var blocks = getSiblingDraggableBlocks(controller, currentBlock);
    controller.command(Commands.moveToEndOfNode, blocks[blocks.length - 1]).command(Commands.focus);
  }, [currentBlock]);

  if (isForbidden || currentBlock && controller.query('disableDrag', currentBlock)) {
    // 销毁：dragEnd 后可能会触发 mouseenter 事件，造成不一致
    return null;
  }

  var handleDragStart = function handleDragStart(event) {
    clearTimeout(removeHighlightTimer);
    actions.clearPrevent();
    timeout.current && clearTimeout(timeout.current);
    setDragMenuVisible(false); // 此处能确保 dragStart 一定触发

    dragStartHandler(event, controller, {
      viewKey: currentBlock == null ? void 0 : currentBlock.key
    });
  };

  var handleMouseLeave = function handleMouseLeave() {
    // 这个逻辑是为了处理鼠标快速移进移出时导致下拉菜单还未显示的情况
    // 此时高亮已经添加，如果仅依赖于visibleChange来处理高亮移除则
    // 无法处理这种情况
    if (!dragMenuVisible) {
      removeDragHighlight('hover');
    } else {
      return;
    } // hover到button时，鼠标移动到下拉子菜单选项上也不移除block选中态


    var dragData = getDraggableData(controller);

    if (!(dragData != null && dragData.dropHolder)) {
      removeHighlightTimer = setTimeout(function () {
        return removeDragHighlight('hover');
      }, 150);
    }

    timeout.current && clearTimeout(timeout.current);
  };

  var handleMouseEnter = function handleMouseEnter() {
    highlightRef.current = true; // 高亮都走 dom 直接更改，不去触发 value.data 变更，此处用 action 方便排版模式下感知

    updateDragHighlightByType('hover');
  };

  var onVisibleChangeForHover = function onVisibleChangeForHover(visible) {
    // cornerToolbar菜单状态变更的时候设置对应状态，防止背景色置空
    dispatchCustomEvent(LEGAL_EVENT.hoverMenuVisible, {
      visible: visible
    });

    if (visible) {
      timeout.current = setTimeout(function () {
        controller.run('onAction', mountDragHander());
        setDragMenuVisible(visible);
        actions.preventMouseMove();
      }, 300);
    } else {
      actions.clearPrevent(); // 鼠标移出导致下拉框菜单隐藏时去掉block的背景色

      removeDragHighlight('hover');
      timeout.current && clearTimeout(timeout.current); // 菜单延时消失逻辑

      timeout.current = setTimeout(function () {
        setDragMenuVisible(visible);
      }, 200);
    }
  };

  var onVisibleChangeForClick = function onVisibleChangeForClick(visible) {
    // cornerToolbar菜单状态变更的时候设置对应状态，防止背景色置空
    dispatchCustomEvent(LEGAL_EVENT.hoverMenuVisible, {
      visible: visible
    });
    setDragMenuVisible(visible);

    if (visible) {
      controller.run('onAction', mountDragHander());
      actions.preventMouseMove();
    } else {
      actions.clearPrevent(); // 鼠标移出导致下拉框菜单隐藏时去掉block的背景色

      removeDragHighlight('select');
    }
  };

  var handleClickMenu = function handleClickMenu(menuKey) {
    actions.clearPrevent();
    actions.updateHoverBlock(); // 点击菜单选项后移除背景色

    removeDragHighlight('select');

    if (handleClickMenuItem) {
      // 移除表格左上角汉堡的hover态
      handleClickMenuItem(menuKey, setDragMenuVisible);
    } else {
      setDragMenuVisible(false);
    }
  };

  var handleClick = function handleClick() {
    setDragMenuVisible(true);

    if (trigger === 'click') {
      updateDragHighlightByType('select');
    }

    setActiveType('leftMenu');
    actions.preventMouseMove();
    onClickIcon == null ? void 0 : onClickIcon();
  };

  var tooltipContent = /*#__PURE__*/_createElement(React.Fragment, null, /*#__PURE__*/_createElement(TooltipText, null, /*#__PURE__*/_createElement(PrimaryText, null, locale == null ? void 0 : locale.click), locale == null ? void 0 : locale.clickTip), /*#__PURE__*/_createElement(TooltipText, null, /*#__PURE__*/_createElement(PrimaryText, null, locale == null ? void 0 : locale.drag), locale == null ? void 0 : locale.dragTip));

  return /*#__PURE__*/_createElement(Dropdown, {
    overlay: dragMenuVisible ? /*#__PURE__*/_createElement(DropdownAnimation, {
      visible: dragMenuVisible
    }, /*#__PURE__*/_createElement("div", {
      onMouseUp: onMouseUp
    }, /*#__PURE__*/_createElement(DragMenu, {
      locale: locale,
      controller: controller,
      extraTransformMenu: extraTransformMenu,
      currentBlock: currentBlock,
      handleClickMenu: handleClickMenu,
      getCopyURL: getCopyURL,
      shareParagraph: shareParagraph,
      hetu: hetu,
      refblock: refblock,
      customizeMenus: customizeMenus
    }))) : null,
    placement: "leftTop",
    trigger: trigger,
    onVisibleChange: trigger === 'hover' ? onVisibleChangeForHover : onVisibleChangeForClick,
    getContainer: function getContainer() {
      return container;
    },
    visible: dragMenuVisible,
    overlayAutoAlign: false
  }, /*#__PURE__*/_createElement("span", null, /*#__PURE__*/_createElement(Tooltip, {
    placement: "top",
    title: tooltipContent,
    overlayStyle: {
      padding: '4px 8px',
      backgroundColor: 'rgba(23,26,29,1)'
    },
    disabled: dragMenuVisible || trigger === 'hover'
  }, /*#__PURE__*/_createElement(DragHand, {
    scale: scale,
    "data-testid": "drag-hander",
    draggable: !disableDrag,
    "data-drag-handler-key": currentBlock == null ? void 0 : currentBlock.key,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    onClick: handleClick,
    onDragStart: handleDragStart,
    "data-is-hover": dragMenuVisible,
    "data-role": DraggableRole.dragHand,
    className: dragHanderclassName,
    active: active
  }, DragIcon))));
};

export default DragDropdown;
//# sourceMappingURL=dargDropdown.js.map