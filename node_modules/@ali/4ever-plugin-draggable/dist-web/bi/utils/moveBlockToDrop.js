import { Document, Block, Text, Commands, Path } from '@ali/4ever-cangjie';
import { Paragraph } from '@ali/4ever-plugin-paragraph';
import logger from '@ali/4ever-logger';
import { DROP_POSITION } from "../types";
/**
 * 移动节点到 drop 位置
 * @param controller
 * @param dragKey
 * @param dropBlock
 * @param dropPosition
 * @param isCopy
 * @returns 返回移动后的节点
 */

export default function moveBlockToDrop(controller, dragKey, dropBlock, dropPosition, isCopy) {
  var document = controller.value.document;

  try {
    var dragBlock = document.getNode(dragKey);
    if (!dragBlock) return undefined;

    if (controller.query('disableDrop', dragBlock, dropBlock)) {
      return undefined;
    }

    var parent = document.getParent(dropBlock.key);
    if (!parent) return null;
    var isDropToTable = controller.query('isNodeInTable', dropBlock, true);

    if (dragBlock.type === 'table' && isDropToTable) {
      // 不允许表格拖入表格
      return null;
    }

    var index = parent.nodes.indexOf(dropBlock);
    var dragPath = document.assertPath(dragBlock.key);
    var dropPath = document.assertPath(dropBlock.key);
    var isYounger = Path.isYounger(dragPath, dropPath);
    var isSibling = Path.isSibling(dragPath, dropPath);

    if (isSibling && !isCopy) {
      if (isYounger && dropPosition === DROP_POSITION.before) {
        index -= 1;
      } else if (!isYounger && dropPosition === DROP_POSITION.after) {
        index += 1;
      }
    } else if (dropPosition === DROP_POSITION.after) {
      index += 1;
    } // source 是个 TableCell，需要过滤掉 Cell 节点。


    if (controller.query('isTableCell', dragBlock)) {
      if (dragBlock === dropBlock || dragBlock.getNode(dropBlock.key)) {
        // 拖到了自己的 children，直接返回
        return null;
      }

      if (isCopy) {
        var copyedBlock = Block.fromJSON(dragBlock.toJSON());
        var doc = Document.create({
          nodes: copyedBlock.nodes
        });
        controller.command(Commands.insertFragmentByKey, parent.key, index, doc);
      } else {
        controller.withoutNormalizing(function () {
          var parentPath = document.getPath(parent.key);
          /**
           * 由于河图卡片限制，只能使用 move node 操作。
           * move mode 之后，需要移除 dragBlock，但是此时 dragBlock 已经无法定位了（path、key 均失效了）。
           *
           * 因此这里引入了一个 dummyBlock，先插入到 dragBlock 内部，作为定位使用。
           * 这样移动完了之后，dragBlock 还剩一个 dummyBlock，可以获取最新的 dragBlock 引用。
           */

          var dummyBlock = Paragraph.create({
            nodes: [Text.create()]
          });
          controller.command(Commands.insertNodeByKey, dragBlock.key, 0, dummyBlock); // dragBlock.nodes：旧的 dragBlock 引用，不包含 dummyBlock

          [].concat(dragBlock.nodes).reverse().forEach(function (n) {
            var path = controller.value.document.getPath(n.key);

            if (path && parentPath) {
              controller.command(Commands.moveNodeByPath, path, parentPath, index);
            }
          }); // 参考上面注释，这里来获取最新的 dragBlock 引用

          var newDragBlock = controller.value.document.getParent(dummyBlock.key);

          if (newDragBlock) {
            controller.command(Commands.removeNodeByKey, newDragBlock.key);
          }
        });
      }

      return undefined;
    }

    var draggedBlock = dragBlock;

    if (isCopy) {
      var _copyedBlock = Block.fromJSON(dragBlock.toJSON());

      draggedBlock = _copyedBlock;
      controller.command(Commands.insertNodeByKey, parent.key, index, _copyedBlock).command(Commands.moveToEndOfNode, _copyedBlock).command(Commands.focus);
    } else {
      controller.command(Commands.moveNodeByKey, dragKey, parent.key, index).command(Commands.moveToEndOfNode, dragBlock).command(Commands.focus);
    }

    return draggedBlock;
  } catch (error) {
    logger.error("parse drag fragment failed: " + error.message);
    return null;
  }
}
//# sourceMappingURL=moveBlockToDrop.js.map