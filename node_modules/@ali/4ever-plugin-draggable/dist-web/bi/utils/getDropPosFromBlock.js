import { DROP_POSITION } from "../types";
import getClosestDom from "./getClosestDom";
import { getDraggableData } from "../model/draggableData";
import { Heading } from '@ali/4ever-plugin-heading';
var COLUMN_ITEM = 'data-column';
var COLUMNS_TABLE = 'data-columns';
export default function getDropPosFromBlock(controller, block, x, y, onlyHorizon) {
  var _dropDomNode$closest, _draggableData$dropHo;

  var dropHolder = null;
  var dropDomNode = getClosestDom(block);
  if (!dropDomNode) return dropHolder;
  var document = controller.value.document;
  var dropPosition;
  var rect = dropDomNode.getBoundingClientRect(); // <table> 包含了滚动，这里需要取 <table> 的上一层

  var tableNode = (_dropDomNode$closest = dropDomNode.closest('table')) == null ? void 0 : _dropDomNode$closest.closest('[data-cangjie-key]');
  var tableRect = tableNode == null ? void 0 : tableNode.getBoundingClientRect(); // 判断是否是左右方向。
  // case 1，普通元素的拖拽

  if (!tableRect) {
    if (x <= rect.left) {
      dropPosition = DROP_POSITION.left;
    }

    if (x >= rect.right) {
      dropPosition = DROP_POSITION.right;
    } // case 2，表格需要单独处理

  } else if (x < tableRect.left || x > tableRect.right) {
    // 此时一定是左右拖拽了。
    dropPosition = x < tableRect.left ? DROP_POSITION.left : DROP_POSITION.right; // 这里取父元素，作为 target node

    var table = document.getClosest(block.key, function (n) {
      return !!controller.query('isTable', n);
    });
    dropHolder = {
      type: table.type,
      rect: {
        top: tableRect.top,
        left: tableRect.left,
        width: tableRect.width,
        height: tableRect.height
      },
      key: table.key,
      dropPosition: dropPosition
    };
  }

  var isHorizon = dropPosition === DROP_POSITION.left || dropPosition === DROP_POSITION.right; // 仅左右分栏时，若不满足拖拽到段左、段右，直接返回

  if (onlyHorizon && !isHorizon) return dropHolder;

  if (!dropPosition) {
    dropPosition = y < rect.top + rect.height / 2 ? DROP_POSITION.before : DROP_POSITION.after;
  } // 如果之前没有定义的话，现在可以使用 block 赋值


  if (!dropHolder) {
    dropHolder = {
      type: block.type,
      rect: {
        top: rect.top,
        left: rect.left,
        width: rect.width,
        height: rect.height
      },
      key: block.key,
      dropPosition: dropPosition
    };
  } // 如果存在分栏拖拽，单独处理一下 rect。（target node 不需要处理）


  var parentColumn = dropDomNode.closest("[" + COLUMN_ITEM + "]");

  if (parentColumn && isHorizon) {
    var _parentColumn$closest;

    var columnsRect = (_parentColumn$closest = parentColumn.closest("[" + COLUMNS_TABLE + "]")) == null ? void 0 : _parentColumn$closest.getBoundingClientRect();

    if (!columnsRect) {
      return dropHolder;
    }

    var newRect = parentColumn.getBoundingClientRect();
    var left = newRect.left,
        width = newRect.width;
    var top = columnsRect.top,
        height = columnsRect.height;
    dropHolder.rect = {
      top: top,
      left: left,
      width: width,
      height: height
    };
  } // 处理跨页的情况：pagePosition（由分页模式下的 renderController 计算）
  // 如果有跨页则覆盖 dropPosition 和 rect


  var draggableData = getDraggableData(controller);
  var pagePosition = draggableData == null ? void 0 : (_draggableData$dropHo = draggableData.dropHolder) == null ? void 0 : _draggableData$dropHo.pagePosition;

  if (draggableData && pagePosition !== undefined) {
    var _draggableData$dropHo2;

    dropHolder.dropPosition = pagePosition;
    dropHolder.rect = (_draggableData$dropHo2 = draggableData.dropHolder) == null ? void 0 : _draggableData$dropHo2.rect;
  }

  var isInTable = controller.query('isNodeInTable', block);

  if (pagePosition === undefined && dropPosition === DROP_POSITION.before && !isInTable) {
    var preDropNode = document.getPreviousSibling(block.key); // 高亮块下的元素则不修正

    var preDropDomNode = preDropNode && !Heading.isCallout(preDropNode) ? getClosestDom(preDropNode) : null;

    if (preDropDomNode && dropHolder.rect) {
      // 修正：drop 位置处于元素上方时，取前一个元素的 bottom，确保两个元素之间只有一根线
      var preDomRect = preDropDomNode.getBoundingClientRect();
      dropHolder.rect = {
        top: preDomRect.bottom,
        left: preDomRect.left,
        height: preDomRect.height,
        width: preDomRect.width
      };
    }
  }

  return dropHolder;
}
//# sourceMappingURL=getDropPosFromBlock.js.map