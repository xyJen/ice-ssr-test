import _extends from "@babel/runtime/helpers/extends";
import { Commands } from '@ali/4ever-cangjie';
import logger from '@ali/4ever-logger';
import { DRAG_TYPE, DROP_POSITION } from "../types";
import moveBlockToDrop from "../utils/moveBlockToDrop";
import moveInlineToDrop from "../utils/moveInlineToDrop";
import moveImageToDrop from "../utils/moveImageToDrop";
import { updateDraggableData } from "../model/draggableData";
import isSubjectFragment from "../utils/isSubjectFragment";
import { omit } from 'lodash-es';
import { cloneDeep } from 'lodash-es';
import { Heading } from '@ali/4ever-plugin-heading';
/**
 * drop 文档中的内容（inline | blocks）
 * controller should be dataController
 */

export default function dropFragment(controller, payload) {
  var dragFragment = payload.dragFragment,
      dropHolder = payload.dropHolder,
      isCopy = payload.isCopy;
  if (!dragFragment) return controller;
  var type = dragFragment.type;

  if (type === DRAG_TYPE.blocks && Array.isArray(dragFragment.fragment) && dropHolder) {
    var fragment = [].concat(dragFragment.fragment);
    var blocksCount = fragment.length;
    var dropKey = dropHolder.key,
        dropPosition = dropHolder.dropPosition,
        pagePosition = dropHolder.pagePosition;
    if (!blocksCount || !dropKey) return controller;
    var position = pagePosition !== undefined ? pagePosition : dropPosition; // 是否是议题组

    var isSubjectGroup = isSubjectFragment(dragFragment);

    if (blocksCount > 1 && position === DROP_POSITION.after) {
      /**
       * 0: A
       * 1: B
       * 2: C
       * 3: D
       * 现在我们将 [C, D] drop 到 A.after，假设按照正常顺序结果是：
       * 待移动 [C, D]，文档: [A, B, C, D]
       * 待移动 [D]，文档: [A, C, B, D]
       * 待移动 []，文档: [A, D, C, B]
       * 因为 A.after 是一个固定位，最终的结果 [D, C] 与预期不符，reverse 的话:
       * 待移动 [D, C]，文档: [A, B, C, D]
       * 待移动 [C]，文档: [A, D, B, C]
       * 待移动 []，文档: [A, C, D, B]
       * 最终结果 [C, D] 的顺序得以保留
       */
      fragment.reverse();
    }

    var document = controller.value.document;
    var dropBlock = document.getNode(dropKey);
    var dragNodes = dropBlock ? fragment.map(function (block) {
      return moveBlockToDrop(controller, block.key, dropBlock, position, isCopy);
    }).filter(function (node) {
      return !!node;
    }) : [];

    if (Heading.isCallout(dropBlock)) {
      // dropBlock 是 callout 的边缘节点
      var isAtCalloutEdge = controller.query('getCalloutStartBlock', dropBlock) === dropBlock || controller.query('getCalloutEndBlock', dropBlock) === dropBlock; // 在 callout 边缘的议题组则不予处理

      var isSubjectAtCalloutEdge = isSubjectGroup && isAtCalloutEdge;

      if (!isSubjectAtCalloutEdge) {
        dragNodes.forEach(function (dragNode) {
          return controller.command(Commands.setNodeByKey, dragNode.key, {
            data: _extends({}, omit(dragNode.data, 'subjectPr'), {
              calloutPr: cloneDeep(dropBlock.data.calloutPr)
            })
          });
        });
      }
    }

    if (blocksCount === 1) {
      logger.sum('drag_block');
    } else {
      logger.sum('drag_blocks');
    }
  } else if (type === DRAG_TYPE.inline && dragFragment.fragment.type === 'image' && dropHolder) {
    var _dropPosition = dropHolder.dropPosition,
        _dropKey = dropHolder.key;
    var _document = controller.value.document;

    var _dropBlock = _document.getNode(_dropKey);

    if (!_dropBlock) return controller;
    moveImageToDrop(controller, dragFragment.fragment.key, _dropBlock, _dropPosition, isCopy);
  } else if (type === DRAG_TYPE.inline && dragFragment.fragment.key) {
    moveInlineToDrop(controller, dragFragment.fragment.key, isCopy);
    logger.sum('drag_inline');
  } // 清除 controller 上的数据


  return updateDraggableData(controller);
}
//# sourceMappingURL=dropFragment.js.map