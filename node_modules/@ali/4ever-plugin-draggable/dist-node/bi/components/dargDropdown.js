"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _weDesign = require("@ali/we-design");

var _weUtil = require("@ali/we-util");

var _everCangjie = require("@ali/4ever-cangjie");

var _everComponent = require("@ali/4ever-component");

var _dragMenu = _interopRequireDefault(require("./dragMenu"));

var _styled = require("./styled");

var _getElementType = _interopRequireDefault(require("../utils/getElementType"));

var _actions = require("../actions");

var _dragStartHandler = _interopRequireDefault(require("../dragEventHandlers/dragStartHandler"));

var _draggableData = require("../model/draggableData");

var _utils = require("../utils");

var _everUtils = require("@ali/4ever-utils");

var _role = require("../../utils/role");

/* eslint-disable react-hooks/exhaustive-deps */
const _createElement = /*#__PURE__*/_react.default.createElement;
let removeHighlightTimer;
const {
  useActiveInteraction
} = _everComponent.ActiveInteractionHooks;

const DragDropdown = props => {
  const {
    controller,
    scale = 1,
    currentBlock,
    onClickIcon,
    active,
    draggableConfig,
    customizeMenus,
    dragHanderclassName = '',
    disableDrag,
    handleClickMenuItem
  } = props;
  const {
    locale,
    getCopyURL,
    shareParagraph,
    hetu,
    refblock,
    extraTransformMenu = [],
    trigger = 'hover'
  } = draggableConfig || {};
  const container = (0, _everCangjie.useScrollableContent)() || document.body; // 是否触发过高亮

  const highlightRef = (0, _react.useRef)(false);
  const [dragMenuVisible, setDragMenuVisible] = (0, _react.useState)(false);
  const [activeType, setActiveType] = useActiveInteraction();

  const activeRef = _react.default.useRef('');

  activeRef.current = activeType;
  const timeout = (0, _react.useRef)(null);
  const [, actions] = (0, _everComponent.useLeftToolbar)();
  const type = (0, _getElementType.default)(currentBlock); // 优先根据传入配置判断

  const {
    forbiddenElements = {}
  } = controller.query('getDraggableConfig') || {};
  const isForbidden = forbiddenElements[type];
  /**
   * 非必要时候不要使用utils中的全局高亮移除方法
   * 因为由于调用执行时机的问题会导致很多情况下一些
   * 不必要移除的高亮被移除。
   * 每个组件只需要保证对自己添加的那部分高亮进行移除即可
   * 保证各自职责分明。
   */

  const removeDragHighlight = _react.default.useCallback((type = 'hover') => {
    // 如果是表格的话就走定制背景色
    const isTableHighlight = controller.query('isTable', currentBlock);
    controller.run('onAction', (0, _actions.removeDragHighlightSingle)({
      key: currentBlock?.key,
      isTableHighlight,
      type
    }));
  }, [currentBlock]);

  const updateDragHighlightByType = _react.default.useCallback((type = 'hover') => {
    if (!currentBlock) return; // 如果是表格的话就走定制背景色

    const isTableHighlight = controller.query('isTable', currentBlock);
    controller.run('onAction', (0, _actions.updateDragHighlight)({
      key: currentBlock?.key,
      isTableHighlight,
      type
    }));
  }, [currentBlock]);

  const removeAllDragHighlight = _react.default.useCallback(() => {
    removeDragHighlight('select');
    removeDragHighlight('hover');
  }, [removeDragHighlight]);

  (0, _react.useEffect)(() => {
    if (currentBlock) {
      controller.run('onAction', (0, _actions.updateDragHander)({
        viewKey: currentBlock?.key,
        type: 'hover'
      }));
    } else {
      controller.run('onAction', (0, _actions.updateDragHander)());
    }
  }, [currentBlock]);
  (0, _react.useEffect)(() => {
    if (!dragMenuVisible && activeRef.current === 'leftMenu') {
      setActiveType('');
    }
  }, [dragMenuVisible, setActiveType]);
  (0, _react.useEffect)(() => {
    return () => {
      actions.clearPrevent();
      /**
       * 组件 unmount 的时候移除高亮
       * 这个逻辑可以保证大多数场景下被添加的高亮被移除。
       * 但是表格的cornerToolbar例外，其生命周期跟随表格
       * 并非在鼠标移出后卸载，因此需要在mouseLeave的时候
       * 对高亮进行移除
       */

      highlightRef.current && removeAllDragHighlight();
      timeout.current && clearTimeout(timeout.current);
    };
  }, [removeAllDragHighlight]);
  const onMouseUp = (0, _react.useCallback)(e => {
    e.stopPropagation();
    if (!currentBlock) return;
    const {
      startBlock
    } = controller.value;
    if (currentBlock?.key === startBlock?.key) return;
    const blocks = (0, _utils.getSiblingDraggableBlocks)(controller, currentBlock);
    controller.command(_everCangjie.Commands.moveToEndOfNode, blocks[blocks.length - 1]).command(_everCangjie.Commands.focus);
  }, [currentBlock]);

  if (isForbidden || currentBlock && controller.query('disableDrag', currentBlock)) {
    // 销毁：dragEnd 后可能会触发 mouseenter 事件，造成不一致
    return null;
  }

  const handleDragStart = event => {
    clearTimeout(removeHighlightTimer);
    actions.clearPrevent();
    timeout.current && clearTimeout(timeout.current);
    setDragMenuVisible(false); // 此处能确保 dragStart 一定触发

    (0, _dragStartHandler.default)(event, controller, {
      viewKey: currentBlock?.key
    });
  };

  const handleMouseLeave = () => {
    // 这个逻辑是为了处理鼠标快速移进移出时导致下拉菜单还未显示的情况
    // 此时高亮已经添加，如果仅依赖于visibleChange来处理高亮移除则
    // 无法处理这种情况
    if (!dragMenuVisible) {
      removeDragHighlight('hover');
    } else {
      return;
    } // hover到button时，鼠标移动到下拉子菜单选项上也不移除block选中态


    const dragData = (0, _draggableData.getDraggableData)(controller);

    if (!dragData?.dropHolder) {
      removeHighlightTimer = setTimeout(() => removeDragHighlight('hover'), 150);
    }

    timeout.current && clearTimeout(timeout.current);
  };

  const handleMouseEnter = () => {
    highlightRef.current = true; // 高亮都走 dom 直接更改，不去触发 value.data 变更，此处用 action 方便排版模式下感知

    updateDragHighlightByType('hover');
  };

  const onVisibleChangeForHover = visible => {
    // cornerToolbar菜单状态变更的时候设置对应状态，防止背景色置空
    (0, _everUtils.dispatchCustomEvent)(_everUtils.LEGAL_EVENT.hoverMenuVisible, {
      visible
    });

    if (visible) {
      timeout.current = setTimeout(() => {
        controller.run('onAction', (0, _actions.mountDragHander)());
        setDragMenuVisible(visible);
        actions.preventMouseMove();
      }, 300);
    } else {
      actions.clearPrevent(); // 鼠标移出导致下拉框菜单隐藏时去掉block的背景色

      removeDragHighlight('hover');
      timeout.current && clearTimeout(timeout.current); // 菜单延时消失逻辑

      timeout.current = setTimeout(() => {
        setDragMenuVisible(visible);
      }, 200);
    }
  };

  const onVisibleChangeForClick = visible => {
    // cornerToolbar菜单状态变更的时候设置对应状态，防止背景色置空
    (0, _everUtils.dispatchCustomEvent)(_everUtils.LEGAL_EVENT.hoverMenuVisible, {
      visible
    });
    setDragMenuVisible(visible);

    if (visible) {
      controller.run('onAction', (0, _actions.mountDragHander)());
      actions.preventMouseMove();
    } else {
      actions.clearPrevent(); // 鼠标移出导致下拉框菜单隐藏时去掉block的背景色

      removeDragHighlight('select');
    }
  };

  const handleClickMenu = menuKey => {
    actions.clearPrevent();
    actions.updateHoverBlock(); // 点击菜单选项后移除背景色

    removeDragHighlight('select');

    if (handleClickMenuItem) {
      // 移除表格左上角汉堡的hover态
      handleClickMenuItem(menuKey, setDragMenuVisible);
    } else {
      setDragMenuVisible(false);
    }
  };

  const handleClick = () => {
    setDragMenuVisible(true);

    if (trigger === 'click') {
      updateDragHighlightByType('select');
    }

    setActiveType('leftMenu');
    actions.preventMouseMove();
    onClickIcon?.();
  };

  const tooltipContent = /*#__PURE__*/_createElement(_react.default.Fragment, null, /*#__PURE__*/_createElement(_styled.TooltipText, null, /*#__PURE__*/_createElement(_styled.PrimaryText, null, locale?.click), locale?.clickTip), /*#__PURE__*/_createElement(_styled.TooltipText, null, /*#__PURE__*/_createElement(_styled.PrimaryText, null, locale?.drag), locale?.dragTip));

  return /*#__PURE__*/_createElement(_weDesign.Dropdown, {
    overlay: dragMenuVisible ? /*#__PURE__*/_createElement(_weUtil.DropdownAnimation, {
      visible: dragMenuVisible
    }, /*#__PURE__*/_createElement("div", {
      onMouseUp: onMouseUp
    }, /*#__PURE__*/_createElement(_dragMenu.default, {
      locale: locale,
      controller: controller,
      extraTransformMenu: extraTransformMenu,
      currentBlock: currentBlock,
      handleClickMenu: handleClickMenu,
      getCopyURL: getCopyURL,
      shareParagraph: shareParagraph,
      hetu: hetu,
      refblock: refblock,
      customizeMenus: customizeMenus
    }))) : null,
    placement: "leftTop",
    trigger: trigger,
    onVisibleChange: trigger === 'hover' ? onVisibleChangeForHover : onVisibleChangeForClick,
    getContainer: () => {
      return container;
    },
    visible: dragMenuVisible,
    overlayAutoAlign: false
  }, /*#__PURE__*/_createElement("span", null, /*#__PURE__*/_createElement(_weDesign.Tooltip, {
    placement: "top",
    title: tooltipContent,
    overlayStyle: {
      padding: '4px 8px',
      backgroundColor: 'rgba(23,26,29,1)'
    },
    disabled: dragMenuVisible || trigger === 'hover'
  }, /*#__PURE__*/_createElement(_styled.DragHand, {
    scale: scale,
    "data-testid": "drag-hander",
    draggable: !disableDrag,
    "data-drag-handler-key": currentBlock?.key,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    onClick: handleClick,
    onDragStart: handleDragStart,
    "data-is-hover": dragMenuVisible,
    "data-role": _role.DraggableRole.dragHand,
    className: dragHanderclassName,
    active: active
  }, _styled.DragIcon))));
};

var _default = DragDropdown;
exports.default = _default;
//# sourceMappingURL=dargDropdown.js.map