"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = dropFragment;

var _everCangjie = require("@ali/4ever-cangjie");

var _everLogger = _interopRequireDefault(require("@ali/4ever-logger"));

var _types = require("../types");

var _moveBlockToDrop = _interopRequireDefault(require("../utils/moveBlockToDrop"));

var _moveInlineToDrop = _interopRequireDefault(require("../utils/moveInlineToDrop"));

var _moveImageToDrop = _interopRequireDefault(require("../utils/moveImageToDrop"));

var _draggableData = require("../model/draggableData");

var _isSubjectFragment = _interopRequireDefault(require("../utils/isSubjectFragment"));

var _lodash = require("lodash");

var _everPluginHeading = require("@ali/4ever-plugin-heading");

/**
 * drop 文档中的内容（inline | blocks）
 * controller should be dataController
 */
function dropFragment(controller, payload) {
  const {
    dragFragment,
    dropHolder,
    isCopy
  } = payload;
  if (!dragFragment) return controller;
  const {
    type
  } = dragFragment;

  if (type === _types.DRAG_TYPE.blocks && Array.isArray(dragFragment.fragment) && dropHolder) {
    const fragment = [...dragFragment.fragment];
    const blocksCount = fragment.length;
    const {
      key: dropKey,
      dropPosition,
      pagePosition
    } = dropHolder;
    if (!blocksCount || !dropKey) return controller;
    const position = pagePosition !== undefined ? pagePosition : dropPosition; // 是否是议题组

    const isSubjectGroup = (0, _isSubjectFragment.default)(dragFragment);

    if (blocksCount > 1 && position === _types.DROP_POSITION.after) {
      /**
       * 0: A
       * 1: B
       * 2: C
       * 3: D
       * 现在我们将 [C, D] drop 到 A.after，假设按照正常顺序结果是：
       * 待移动 [C, D]，文档: [A, B, C, D]
       * 待移动 [D]，文档: [A, C, B, D]
       * 待移动 []，文档: [A, D, C, B]
       * 因为 A.after 是一个固定位，最终的结果 [D, C] 与预期不符，reverse 的话:
       * 待移动 [D, C]，文档: [A, B, C, D]
       * 待移动 [C]，文档: [A, D, B, C]
       * 待移动 []，文档: [A, C, D, B]
       * 最终结果 [C, D] 的顺序得以保留
       */
      fragment.reverse();
    }

    const {
      document
    } = controller.value;
    const dropBlock = document.getNode(dropKey);
    const dragNodes = dropBlock ? fragment.map(block => (0, _moveBlockToDrop.default)(controller, block.key, dropBlock, position, isCopy)).filter(node => !!node) : [];

    if (_everPluginHeading.Heading.isCallout(dropBlock)) {
      // dropBlock 是 callout 的边缘节点
      const isAtCalloutEdge = controller.query('getCalloutStartBlock', dropBlock) === dropBlock || controller.query('getCalloutEndBlock', dropBlock) === dropBlock; // 在 callout 边缘的议题组则不予处理

      const isSubjectAtCalloutEdge = isSubjectGroup && isAtCalloutEdge;

      if (!isSubjectAtCalloutEdge) {
        dragNodes.forEach(dragNode => controller.command(_everCangjie.Commands.setNodeByKey, dragNode.key, {
          data: { // 兜底处理，拖进 callout 的 subjectPr 置空
            ...(0, _lodash.omit)(dragNode.data, 'subjectPr'),
            calloutPr: (0, _lodash.cloneDeep)(dropBlock.data.calloutPr)
          }
        }));
      }
    }

    if (blocksCount === 1) {
      _everLogger.default.sum('drag_block');
    } else {
      _everLogger.default.sum('drag_blocks');
    }
  } else if (type === _types.DRAG_TYPE.inline && dragFragment.fragment.type === 'image' && dropHolder) {
    const {
      dropPosition,
      key: dropKey
    } = dropHolder;
    const {
      document
    } = controller.value;
    const dropBlock = document.getNode(dropKey);
    if (!dropBlock) return controller;
    (0, _moveImageToDrop.default)(controller, dragFragment.fragment.key, dropBlock, dropPosition, isCopy);
  } else if (type === _types.DRAG_TYPE.inline && dragFragment.fragment.key) {
    (0, _moveInlineToDrop.default)(controller, dragFragment.fragment.key, isCopy);

    _everLogger.default.sum('drag_inline');
  } // 清除 controller 上的数据


  return (0, _draggableData.updateDraggableData)(controller);
}
//# sourceMappingURL=dropFragment.js.map