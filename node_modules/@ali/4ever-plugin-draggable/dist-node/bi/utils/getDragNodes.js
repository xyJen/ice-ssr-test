"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSiblingDraggableBlocks = getSiblingDraggableBlocks;
exports.default = getDragNodes;
exports.getTransformNodes = void 0;

var _lodash = require("lodash");

var _everCangjie = require("@ali/4ever-cangjie");

var _everUtils = require("@ali/4ever-utils");

var _everPluginHeading = require("@ali/4ever-plugin-heading");

var _everPluginParagraph = require("@ali/4ever-plugin-paragraph");

var _everPluginHeadingGroup = require("@ali/4ever-plugin-heading-group");

const {
  Heading1
} = _everPluginHeading.Heading;
/**
 * 聚合节点组
 * @param node 聚合开始节点
 * @param document 文档模型
 * @param until 聚合截止
 * @returns
 */

function groupNodes(node, document, until) {
  const path = document.getPath(node.key);

  if (!path) {
    return [];
  }

  const nodes = [node];
  let [index] = path;
  index += 1;

  while (index < document.nodes.length) {
    const item = document.nodes[index];

    if (until(item)) {
      break;
    }

    nodes.push(item);
    index += 1;
  }

  return nodes;
}
/**
 * 基于 getRootBlocksAtRange 获取关联的可拖拽元素集合
 * 排版模式下有 page、section、line 等自定义层级结构较为复杂，要提取出正确的可拖拽元素比较繁琐
 * @controller 应是排版前的 controller
 */


function getSiblingDraggableBlocks(controller, node) {
  const {
    enableSubjectGroup = false,
    enableHeadingGroup = false
  } = controller.query('getDraggableConfig') || {};
  const {
    selection,
    document
  } = controller.value;
  const tableSelection = controller.query('hasTableSelection');
  const isNormalSelection = selection.isExpanded && !tableSelection;

  if (isNormalSelection) {
    const allBlocks = document.getRootBlocksAtRange(selection);

    if (allBlocks.length > 1 && allBlocks.some(block => block.key === node.key)) {
      // 若最后一个节点附带聚合属性，则向下聚合
      const lastBlock = allBlocks[allBlocks.length - 1];

      if (enableSubjectGroup && Heading1.isHeading1(lastBlock) && lastBlock.data.subjectPr) {
        const blocks = groupNodes(lastBlock, document, item => Heading1.isHeading1(item) && !!item.data.subjectPr);
        allBlocks.pop();
        allBlocks.push(...blocks);
      } else if (enableHeadingGroup) {
        const condition = _everPluginHeadingGroup.headingGroupList.find(({
          when
        }) => {
          const fold = controller.userData.get(lastBlock, 'fold');
          return when(lastBlock) && fold;
        });

        if (condition) {
          const {
            until
          } = condition;
          const blocks = groupNodes(lastBlock, document, until);
          allBlocks.pop();
          allBlocks.push(...blocks);
        }
      } // 选区包含多个块级元素 且 包含当前 node


      return allBlocks;
    }
  }

  if ((_everPluginParagraph.Paragraph.isParagraph(node) || _everPluginHeading.Heading.isHeading(node)) && node.data.calloutPr) {
    const startNode = controller.query('findFirstBlockOfCalloutPr', node);

    if (startNode) {
      const res = groupNodes(startNode, document, nextNode => !(nextNode && (_everPluginParagraph.Paragraph.isParagraph(nextNode) || _everPluginHeading.Heading.isHeading(nextNode)) && !!nextNode.data.calloutPr && (0, _lodash.isEqual)(nextNode.data.calloutPr, node.data.calloutPr)));
      return res;
    }
  } // 议题级联


  if (enableSubjectGroup && Heading1.isHeading1(node) && node.data.subjectPr) {
    return groupNodes(node, document, item => Heading1.isHeading1(item) && !!item.data.subjectPr);
  } // 标题分组折叠


  if (enableHeadingGroup) {
    const condition = _everPluginHeadingGroup.headingGroupList.find(({
      when
    }) => {
      const fold = controller.userData.get(node, 'fold');
      return when(node) && fold;
    }); // 若标题折叠条件查询成功，则聚合节点组


    if (condition) {
      const {
        until
      } = condition;
      return groupNodes(node, document, until);
    }
  }

  if (!(0, _everUtils.isListNode)(node)) return [node]; // 列表级联

  return controller.query('getListChildItems', node);
}
/**
 * 获取可拖拽元素
 */


function getDragNodes(controller, key) {
  const node = controller.value.document.getNode(key);
  if (!node) return [];
  if (_everCangjie.Inline.isInline(node)) return node;
  return getSiblingDraggableBlocks(controller, node);
}
/**
 * 获取关联的可转换格式的元素，目前跟可拖拽元素保持一致
 */


const getTransformNodes = controller => {
  const {
    selection,
    document
  } = controller.value;
  const {
    anchor
  } = selection;
  const currentBlock = document.getClosestBlock(anchor.key);
  return getDragNodes(controller, currentBlock?.key);
};

exports.getTransformNodes = getTransformNodes;
//# sourceMappingURL=getDragNodes.js.map