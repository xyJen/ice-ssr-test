"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getDropPosFromBlock;

var _types = require("../types");

var _getClosestDom = _interopRequireDefault(require("./getClosestDom"));

var _draggableData = require("../model/draggableData");

var _everPluginHeading = require("@ali/4ever-plugin-heading");

const COLUMN_ITEM = 'data-column';
const COLUMNS_TABLE = 'data-columns';

function getDropPosFromBlock(controller, block, x, y, onlyHorizon) {
  let dropHolder = null;
  const dropDomNode = (0, _getClosestDom.default)(block);
  if (!dropDomNode) return dropHolder;
  const {
    document
  } = controller.value;
  let dropPosition;
  const rect = dropDomNode.getBoundingClientRect(); // <table> 包含了滚动，这里需要取 <table> 的上一层

  const tableNode = dropDomNode.closest('table')?.closest('[data-cangjie-key]');
  const tableRect = tableNode?.getBoundingClientRect(); // 判断是否是左右方向。
  // case 1，普通元素的拖拽

  if (!tableRect) {
    if (x <= rect.left) {
      dropPosition = _types.DROP_POSITION.left;
    }

    if (x >= rect.right) {
      dropPosition = _types.DROP_POSITION.right;
    } // case 2，表格需要单独处理

  } else if (x < tableRect.left || x > tableRect.right) {
    // 此时一定是左右拖拽了。
    dropPosition = x < tableRect.left ? _types.DROP_POSITION.left : _types.DROP_POSITION.right; // 这里取父元素，作为 target node

    const table = document.getClosest(block.key, n => {
      return !!controller.query('isTable', n);
    });
    dropHolder = {
      type: table.type,
      rect: {
        top: tableRect.top,
        left: tableRect.left,
        width: tableRect.width,
        height: tableRect.height
      },
      key: table.key,
      dropPosition
    };
  }

  const isHorizon = dropPosition === _types.DROP_POSITION.left || dropPosition === _types.DROP_POSITION.right; // 仅左右分栏时，若不满足拖拽到段左、段右，直接返回

  if (onlyHorizon && !isHorizon) return dropHolder;

  if (!dropPosition) {
    dropPosition = y < rect.top + rect.height / 2 ? _types.DROP_POSITION.before : _types.DROP_POSITION.after;
  } // 如果之前没有定义的话，现在可以使用 block 赋值


  if (!dropHolder) {
    dropHolder = {
      type: block.type,
      rect: {
        top: rect.top,
        left: rect.left,
        width: rect.width,
        height: rect.height
      },
      key: block.key,
      dropPosition
    };
  } // 如果存在分栏拖拽，单独处理一下 rect。（target node 不需要处理）


  const parentColumn = dropDomNode.closest(`[${COLUMN_ITEM}]`);

  if (parentColumn && isHorizon) {
    const columnsRect = parentColumn.closest(`[${COLUMNS_TABLE}]`)?.getBoundingClientRect();

    if (!columnsRect) {
      return dropHolder;
    }

    const newRect = parentColumn.getBoundingClientRect();
    const {
      left,
      width
    } = newRect;
    const {
      top,
      height
    } = columnsRect;
    dropHolder.rect = {
      top,
      left,
      width,
      height
    };
  } // 处理跨页的情况：pagePosition（由分页模式下的 renderController 计算）
  // 如果有跨页则覆盖 dropPosition 和 rect


  const draggableData = (0, _draggableData.getDraggableData)(controller);
  const pagePosition = draggableData?.dropHolder?.pagePosition;

  if (draggableData && pagePosition !== undefined) {
    dropHolder.dropPosition = pagePosition;
    dropHolder.rect = draggableData.dropHolder?.rect;
  }

  const isInTable = controller.query('isNodeInTable', block);

  if (pagePosition === undefined && dropPosition === _types.DROP_POSITION.before && !isInTable) {
    const preDropNode = document.getPreviousSibling(block.key); // 高亮块下的元素则不修正

    const preDropDomNode = preDropNode && !_everPluginHeading.Heading.isCallout(preDropNode) ? (0, _getClosestDom.default)(preDropNode) : null;

    if (preDropDomNode && dropHolder.rect) {
      // 修正：drop 位置处于元素上方时，取前一个元素的 bottom，确保两个元素之间只有一根线
      const preDomRect = preDropDomNode.getBoundingClientRect();
      dropHolder.rect = {
        top: preDomRect.bottom,
        left: preDomRect.left,
        height: preDomRect.height,
        width: preDomRect.width
      };
    }
  }

  return dropHolder;
}
//# sourceMappingURL=getDropPosFromBlock.js.map