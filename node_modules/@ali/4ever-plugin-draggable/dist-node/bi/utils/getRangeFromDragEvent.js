"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBlockFromDragEvent = getBlockFromDragEvent;
exports.default = getRangeFromDragEvent;

var _everCangjie = require("@ali/4ever-cangjie");

const COLUMN_BAR_KEY = 'data-column-dragkey';
const HORIZ_ADJUST_OFFSET = 10;

function shouldTraverseBlock(node) {
  if (!node) return false;
  if (!_everCangjie.Block.isBlock(node)) return true;
  if (/line/.test(node.type)) return true;
  return false;
}
/**
   * 从 drag 事件中计算命中的块级元素
   * 水平位置矫正策略（I 表示 drag 事件的位置）：
   * |   [---I---  ]   |
   * |   [------ I ]   |
   * | I [-------  ]   |
   * |   [-------  ] I |
   * 当事件命中 content 的 padding 区域时，如果取原始的水平位置拿不到 block
   * 因此矫正为 dragEvent.target 的中点
   */


function getBlockFromDragEvent(controller, event, zoom, onlyEdge = false) {
  const {
    clientX,
    clientY
  } = event;
  const {
    left,
    right
  } = event.target?.getBoundingClientRect() || {};
  let adjustedX = (left + right) / 2 || clientX;
  const {
    document
  } = controller.value;
  let isOutsideContent = false;

  if (event.target) {
    const element = event.target;
    const dragKey = element.getAttribute(COLUMN_BAR_KEY); // 如果刚好到分隔栏上，就直接返回分隔栏的 key

    if (dragKey) {
      const block = document.getNode(dragKey);

      if (block?.isElement()) {
        return block.nodes[0];
      }
    } // 如果在编辑器区域外部，需要加一下 padding，重新获取一下。


    if (element.querySelector('[data-cangjie-editable]')) {
      isOutsideContent = true;
      if (typeof zoom !== 'number') return null;
      const {
        paddingLeft,
        paddingRight
      } = window.getComputedStyle(event.target);
      const l = left + parseInt(paddingLeft, 10) * zoom;
      const r = right - parseInt(paddingRight, 10) * zoom;

      if (clientX < l) {
        adjustedX = l + HORIZ_ADJUST_OFFSET * zoom;
      } else if (clientX > r) {
        adjustedX = r - HORIZ_ADJUST_OFFSET * zoom;
      }
    }
  } // 图片仅在拖拽到分隔栏和编辑器区域外部时返回 block


  if (onlyEdge && !isOutsideContent) {
    return null;
  }

  let hitedTarget = window.document.elementFromPoint(adjustedX, clientY);
  if (!hitedTarget) return null; // 兼容列表悬空区域探测

  if (hitedTarget.closest('[data-listid]')) {
    hitedTarget = hitedTarget.querySelector('[data-cangjie-key]') || hitedTarget;
  } // 兼容分栏悬空区域探测


  if (hitedTarget.hasAttribute('data-column')) {
    const pivotY = hitedTarget.firstElementChild?.getBoundingClientRect().bottom || 0;
    const childTarget = clientY >= pivotY ? hitedTarget.lastElementChild : hitedTarget.firstElementChild;
    hitedTarget = childTarget?.querySelector('[data-cangjie-key]') || hitedTarget;
  }

  const node = hitedTarget.closest('[data-cangjie-key]');
  let block = null;

  if (node) {
    const [key] = node.getAttribute('data-cangjie-key')?.split(':') || [];
    block = document.getNode(key);

    while (shouldTraverseBlock(block)) {
      block = document.getParent(block?.key || '');
    }
  }

  if (block?.key === document.key) {
    return null;
  }

  return block;
}

function getRangeFromDragEvent(controller, event) {
  getBlockFromDragEvent(controller, event);
  const {
    clientX,
    clientY
  } = event;
  let hitedTarget = window.document.elementFromPoint(clientX, clientY);
  if (!hitedTarget) return null;
  hitedTarget = hitedTarget.closest('[data-listid]') || hitedTarget;
  return _everCangjie.domUtils.caretRangeFromTargetAndCoord(hitedTarget, clientX, clientY, controller);
}
//# sourceMappingURL=getRangeFromDragEvent.js.map