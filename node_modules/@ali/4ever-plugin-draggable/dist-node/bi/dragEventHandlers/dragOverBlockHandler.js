"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = dragOverBlockHandler;

var _getRangeFromDragEvent = require("../utils/getRangeFromDragEvent");

var _getDropPosFromBlock = _interopRequireDefault(require("../utils/getDropPosFromBlock"));

var _getDropHolderDataFromViewKeys = _interopRequireDefault(require("../utils/getDropHolderDataFromViewKeys"));

var _draggableData = require("../model/draggableData");

var _types = require("../types");

function updateBlockDropHolder(controller, dropBlock, event, dragFragment) {
  const {
    document
  } = controller.value;
  const fragment = dragFragment.fragment;
  if (!fragment.length) return undefined; // 不允许落到表格单元、行列 以及 排版相关位置

  if (/^table-/.test(dropBlock.type) || /^page|^section/.test(dropBlock.key)) return undefined; // 不允许拖入到 fragment 中

  const dropKey = controller.query('getDataKey', dropBlock.key) || dropBlock.key;
  if (fragment.some(node => node.key === dropKey)) return undefined; // 不允许表格嵌套

  if (dragFragment.isContainTable() && controller.query('isNodeInTable', dropBlock, true)) return undefined;
  const viewKeys = controller.query('getViewKeys', dropKey);
  const {
    clientX,
    clientY
  } = event;
  let nextDropHolderData = (0, _getDropPosFromBlock.default)(controller, dropBlock, clientX, clientY);

  if (nextDropHolderData && viewKeys?.length > 1) {
    // 兼容分页下段落跨页情形
    nextDropHolderData = { ...nextDropHolderData,
      ...(0, _getDropHolderDataFromViewKeys.default)(controller, event, viewKeys)
    };
  }

  return nextDropHolderData;
}

function dragOverBlockHandler(event, controller, zoom) {
  const draggableData = (0, _draggableData.getDraggableData)(controller);
  if (!draggableData) return null;
  const {
    dragFragment
  } = draggableData; // 只处理 block 元素

  if (!dragFragment || dragFragment.type !== _types.DRAG_TYPE.blocks) return null; // 根据 drag 事件计算命中的 block

  const block = (0, _getRangeFromDragEvent.getBlockFromDragEvent)(controller, event, zoom);
  if (!block) return null;
  const nextDropHolderData = updateBlockDropHolder(controller, block, event, dragFragment);
  if (!nextDropHolderData) return null;
  return nextDropHolderData;
}
//# sourceMappingURL=dragOverBlockHandler.js.map