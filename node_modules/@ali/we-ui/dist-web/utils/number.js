/* eslint-disable max-len */
export var ENumberStrategy;

(function (ENumberStrategy) {
  ENumberStrategy[ENumberStrategy["ROUND"] = 1] = "ROUND";
  ENumberStrategy[ENumberStrategy["FLOOR"] = 2] = "FLOOR";
})(ENumberStrategy || (ENumberStrategy = {}));

/**
 * 浮点数匹配处理
 * @param num1 比较的数字1
 * @param num2 比较的数字2
 * @param accuracy 两个小数的最小差异, 0.000001
 */
export var equalFloat = function equalFloat(num1, num2, accuracy) {
  if (accuracy === void 0) {
    accuracy = 0.000001;
  }

  return Math.abs(num1 - num2) <= accuracy;
};
/**
 * 浮点数精确度处理
 * @param num 要处理的浮点数
 * @param accuracy 保存的精度位数，默认2位小数
 */

export var formatNumber = function formatNumber(num, accuracy, strategy) {
  if (accuracy === void 0) {
    accuracy = 2;
  }

  if (strategy === void 0) {
    strategy = ENumberStrategy.ROUND;
  }

  var multiple = Math.pow(10, accuracy);
  var newNum = num;

  if (strategy === ENumberStrategy.ROUND) {
    newNum = Math.floor(num * multiple + 0.5) / multiple;
  } else if (strategy === ENumberStrategy.FLOOR) {
    newNum = Math.floor(num * multiple) / multiple;
  }

  return newNum;
};
/**
 * 先放大为整数，再完成浮点数相加，以（在日常场景）获得更接近数学的结果
 * @param num1 浮点数1
 * @param num2 浮点数2
 * 参考：https://github.com/camsong/blog/issues/9
 */

export var addFloat = function addFloat(num1, num2) {
  var num1Digits = (num1.toString().split('.')[1] || '').length;
  var num2Digits = (num2.toString().split('.')[1] || '').length;
  var baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));
  return (num1 * baseNum + num2 * baseNum) / baseNum;
};
/**
 * 判断数字在给定精度（位数）下是否需要圆整
 * @param num 需判断的数字
 * @param accuracy 小数点位数
 */

export var needsRounding = function needsRounding(num, accuracy) {
  var numStr = String(num);
  if (!accuracy) return numStr.indexOf('.') !== -1;
  return numStr.length - 1 - numStr.indexOf('.') > accuracy;
};