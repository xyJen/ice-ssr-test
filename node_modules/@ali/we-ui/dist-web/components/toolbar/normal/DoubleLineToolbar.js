import _extends from "@babel/runtime/helpers/extends";
import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";
import React, { Component } from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import ResizeObserver from 'resize-observer-polyfill';
import warning from 'warning';
import { Dropdown } from "../../dropdown";
import { Button } from "../../button";
import { MoreNormal } from "../../icons";
import { debounce } from "../../../utils";
import { ToolBox, EToolBoxLayout } from "./ToolBox";
import { ToolGroup, HiddenToolGroup } from "./ToolGroup";
import { ToolsShow, ToolsMore, Content, ToolbarWrapper } from "./styled";
import { TranslateProvider } from "../../../locale/TranslateProvider";
var INIT_PIVOT = -1;
/**
 * 获取初始的自组件(包含首次渲染和children变化的情况), 重新布局
 * @param children
 */

var getChildren = function getChildren(children) {
  var groups = [];
  var hiddenGroups = [];
  var hasIllegalChild = false;

  var handleChild = function handleChild(child) {
    if (!child) return;

    if (child.type === ToolGroup) {
      groups.push(child);
    } else if (child.type === HiddenToolGroup) {
      hiddenGroups.push(child);
    } else if (child.type === React.Fragment) {
      React.Children.forEach(child.props.children, handleChild);
    } else {
      hasIllegalChild = true;
    }
  };

  React.Children.forEach(children, handleChild);
  warning(!hasIllegalChild, 'Children of DoubleLineToolbar must be ToolGroup or HiddenToolGroup');

  if (!((groups.length || hiddenGroups.length) > 0)) {
    throw new Error('DoubleLineToolbar should has more than one child which type is ToolGroup or HiddenToolGroup');
  }

  return {
    groups: groups,
    hiddenGroups: hiddenGroups
  };
};

var toolsMoreOverlayStyle = {
  padding: '0 10px'
};

var _ref = /*#__PURE__*/_createElement(Button, {
  bordered: false,
  shape: "rect",
  icon: /*#__PURE__*/_createElement(MoreNormal, null)
});

export var DoubleLineToolbar = /*#__PURE__*/function (_Component) {
  _inheritsLoose(DoubleLineToolbar, _Component);

  // eslint-disable-next-line react/static-property-placement
  // Slot的宽度缓存
  function DoubleLineToolbar(props) {
    var _this;

    _this = _Component.call(this, props) || this;
    _this.resizeObserver = void 0;
    _this.slotsWidthList = [];
    _this.refToolbar = /*#__PURE__*/React.createRef();
    _this.refToolContent = /*#__PURE__*/React.createRef();
    _this.refShow = /*#__PURE__*/React.createRef();
    _this.refMore = /*#__PURE__*/React.createRef();
    _this.recomputeLayout = debounce(function () {
      _this.calculateWidth(false);
    }, 50);

    _this.mouseDownAtShow = function (e) {
      var whiteTags = ['input', 'textarea'];
      var tagName = (e.target.tagName || '').toLowerCase();

      if (!whiteTags.includes(tagName)) {
        e.preventDefault();
      }
    };

    _this.calculateWidth = function (isFirst) {
      if (isFirst === void 0) {
        isFirst = false;
      }

      if (!_this.refShow.current || !_this.refShow.current.children) return;
      var children = _this.refShow.current.children;
      var parentElement = _this.refShow.current.parentElement;
      var containerWidth = parentElement.offsetWidth;
      var pivot = INIT_PIVOT; // 更多(...)的宽度

      var sum = 32;

      if (_this.refMore.current) {
        sum = _this.refMore.current.offsetWidth;
      } // 非第一次计算(如resize)，从缓存中取已计算好的数据


      if (!isFirst && _this.slotsWidthList && _this.slotsWidthList.length > 0) {
        for (var index = 0; index < _this.slotsWidthList.length; index += 1) {
          sum += _this.slotsWidthList[index];

          if (sum > containerWidth) {
            pivot = index;
            break;
          }
        }

        _this.setState({
          hiddenPivot: pivot
        });

        return;
      } // 第一渲染或children发生变化，重新计算宽度


      for (var _index = 0; _index < children.length; _index += 1) {
        var child = children[_index];

        if (isFirst) {
          _this.slotsWidthList.push(child.offsetWidth);
        }

        sum += child.offsetWidth;

        if (sum > containerWidth && pivot <= INIT_PIVOT) {
          pivot = _index;
        }
      }

      _this.setState({
        hiddenPivot: pivot
      });
    };

    _this.getResizeContainer = function () {
      return _this.refToolbar.current;
    };

    _this.handleResize = function () {
      _this.recomputeLayout();
    };

    _this.handleClickMorePanel = function (e) {
      var autoCloseMorePanel = _this.props.autoCloseMorePanel; // 阻止冒泡

      e.stopPropagation();

      if (autoCloseMorePanel) {
        _this.setState({
          morePanelVisible: false
        });
      }
    };

    _this.handleMorePanelVisibleChange = function (e) {
      _this.setState({
        morePanelVisible: e
      });
    };

    _this.state = {
      hiddenPivot: INIT_PIVOT,
      groups: [],
      hiddenGroups: [],
      // eslint-disable-next-line react/no-unused-state
      prevChildren: null,
      // 用于状态比对
      needCalculating: false,
      morePanelVisible: false
    };
    _this.resizeObserver = new ResizeObserver(_this.handleResize);
    return _this;
  }

  var _proto = DoubleLineToolbar.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;

    var autoFolding = this.props.autoFolding;
    if (!autoFolding) return;
    setTimeout(function () {
      return _this2.calculateWidth(true);
    });

    if (this.refToolContent.current && this.resizeObserver) {
      this.resizeObserver.observe(this.refToolContent.current);
    }

    if (this.refShow.current) {
      this.refShow.current.addEventListener('mousedown', this.mouseDownAtShow);
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var needCalculating = this.state.needCalculating;

    if (prevProps.children !== this.props.children && needCalculating) {
      this.calculateWidth(true);
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    var autoFolding = this.props.autoFolding;
    if (!autoFolding) return;

    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    }

    if (this.refShow.current) {
      this.refShow.current.removeEventListener('mousedown', this.mouseDownAtShow);
    }
  };

  // render hidden slots
  _proto.renderMore = function renderMore(hiddenSlots) {
    var _this3 = this;

    var zIndex = this.props.zIndex;
    var morePanelVisible = this.state.morePanelVisible;

    if (hiddenSlots.length === 0) {
      return null;
    }

    var DropContent = /*#__PURE__*/_createElement(ToolsShow, {
      onClick: this.handleClickMorePanel
    }, hiddenSlots);

    return /*#__PURE__*/_createElement(ToolsMore, {
      ref: this.refMore,
      isSingleLine: false
    }, /*#__PURE__*/_createElement(TranslateProvider, null, function (t) {
      return /*#__PURE__*/_createElement(Dropdown, {
        trigger: "click",
        overlay: DropContent,
        placement: "bottomRight",
        zIndex: zIndex,
        overlayStyle: toolsMoreOverlayStyle,
        visible: morePanelVisible,
        onVisibleChange: _this3.handleMorePanelVisibleChange
      }, /*#__PURE__*/_createElement(ToolBox, {
        layout: EToolBoxLayout.Vertical,
        name: t('we_ui_double_line_toolbar_more')
      }, _ref));
    }));
  };

  _proto.render = function render() {
    var _this$props = this.props,
        style = _this$props.style,
        autoFolding = _this$props.autoFolding,
        alignType = _this$props.alignType,
        className = _this$props.className;
    var _this$state = this.state,
        hiddenPivot = _this$state.hiddenPivot,
        hiddenGroups = _this$state.hiddenGroups,
        groups = _this$state.groups;
    var computedShowSlots = groups;
    var computedHiddenSlots = hiddenGroups; // 如果为初始值, 说明没有计算, 直接略过

    if (hiddenPivot > INIT_PIVOT) {
      computedHiddenSlots = hiddenGroups.concat(computedShowSlots.slice(hiddenPivot));
      computedShowSlots = computedShowSlots.slice(0, hiddenPivot);
    }

    var styles = {
      width: autoFolding ? '0' : '100%'
    };
    return /*#__PURE__*/_createElement(ToolbarWrapper, {
      style: _extends({}, style),
      ref: this.refToolbar,
      className: className
    }, /*#__PURE__*/_createElement(Content, {
      ref: this.refToolContent,
      style: styles,
      className: alignType
    }, /*#__PURE__*/_createElement(ToolsShow, {
      ref: this.refShow
    }, computedShowSlots), this.renderMore(computedHiddenSlots)));
  };

  return DoubleLineToolbar;
}(Component);
DoubleLineToolbar.defaultProps = {
  autoFolding: true,
  alignType: 'center'
};

DoubleLineToolbar.getDerivedStateFromProps = function (props, state) {
  var prevChildren = state.prevChildren;
  var children = props.children,
      autoFolding = props.autoFolding;

  var _getChildren = getChildren(children),
      groups = _getChildren.groups,
      hiddenGroups = _getChildren.hiddenGroups;

  if (!autoFolding) {
    return {
      groups: groups,
      hiddenGroups: hiddenGroups,
      prevChildren: children,
      hiddenPivot: INIT_PIVOT,
      needCalculating: false
    };
  }
  /**
   * 分两种情况
   * 1: 布局变换, 则重新计算布局
   * 2: 布局没变化, 但是children变换(children的props变化), 需要重新渲染
   */


  if (children !== prevChildren) {
    // TODO 如果对应自组件长度变化, 则认为布局变化
    if (groups.length !== state.groups.length || hiddenGroups.length !== state.hiddenGroups.length) {
      return {
        groups: groups,
        hiddenGroups: hiddenGroups,
        prevChildren: children,
        hiddenPivot: INIT_PIVOT,
        needCalculating: true
      };
    } // 布局未变化, 则沿用上次计算结果


    return {
      groups: groups,
      hiddenGroups: hiddenGroups,
      prevChildren: children,
      needCalculating: false
    };
  }

  return null;
};