import _extends from "@babel/runtime/helpers/extends";
import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";
import React, { Component } from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import ResizeObserver from 'resize-observer-polyfill';
import warning from 'warning';
import { Dropdown } from "../../dropdown";
import { Button } from "../../button";
import { MoreNormal } from "../../icons";
import { debounce } from "../../../utils";
import { ToolLine, HiddenToolLine } from "./ToolLine";
import { ToolsShow, ToolsMore, Content, ToolbarWrapper } from "./styled";
var INIT_PIVOT = -1;
/**
 * 获取初始的自组件(包含首次渲染和children变化的情况), 重新布局
 * @param children
 */

var getChildren = function getChildren(children) {
  var groups = [];
  var hiddenGroups = [];
  var hasIllegalChild = false;

  var handleChild = function handleChild(child) {
    if (!child) return;

    if (child.type === ToolLine) {
      groups.push(child);
    } else if (child.type === HiddenToolLine) {
      hiddenGroups.push(child);
    } else if (child.type === React.Fragment) {
      React.Children.forEach(child.props.children, handleChild);
    } else {
      hasIllegalChild = true;
    }
  };

  React.Children.forEach(children, handleChild);
  warning(!hasIllegalChild, 'Children of SingleLineToolbar must be ToolLine or HiddenToolLine');

  if (!((groups.length || hiddenGroups.length) > 0)) {
    throw new Error('SingleLineToolbar should has more than one child which type is ToolLine or HiddenToolLine');
  }

  return {
    groups: groups,
    hiddenGroups: hiddenGroups
  };
};

var toolsMoreOverlayStyle = {
  padding: '0 10px'
};

var _ref = /*#__PURE__*/_createElement(Button, {
  bordered: false,
  shape: "rect",
  icon: /*#__PURE__*/_createElement(MoreNormal, null)
});

export var SingleLineToolbar = /*#__PURE__*/function (_Component) {
  _inheritsLoose(SingleLineToolbar, _Component);

  // eslint-disable-next-line react/static-property-placement
  // Slot的宽度缓存
  function SingleLineToolbar(props) {
    var _this;

    _this = _Component.call(this, props) || this;
    _this.resizeObserver = void 0;
    _this.slotsWidthList = [];
    _this.refToolbar = /*#__PURE__*/React.createRef();
    _this.refToolContent = /*#__PURE__*/React.createRef();
    _this.refShow = /*#__PURE__*/React.createRef();
    _this.refMore = /*#__PURE__*/React.createRef();
    _this.recomputeLayout = debounce(function () {
      _this.calculateWidth(false);
    }, 50);

    _this.mouseDownAtShow = function (e) {
      var whiteTags = ['input', 'textarea'];
      var tagName = (e.target.tagName || '').toLowerCase();

      if (!whiteTags.includes(tagName)) {
        e.preventDefault();
      }
    };

    _this.getLineWidth = function (toolLine) {
      if (!toolLine) {
        return {
          totalWidth: 0,
          buttonWidths: []
        };
      }

      var totalWidth = toolLine.offsetWidth;
      var buttonWidths = [];
      var buttons = toolLine.children;

      for (var btnIdx = 0; btnIdx < buttons.length; btnIdx++) {
        var button = buttons[btnIdx];

        if (button) {
          buttonWidths.push(button.offsetWidth);
        }
      }

      return {
        totalWidth: totalWidth,
        buttonWidths: buttonWidths
      };
    };

    _this.calculateWidth = function (isFirst) {
      if (isFirst === void 0) {
        isFirst = false;
      }

      if (!_this.refShow.current || !_this.refShow.current.children) return;
      var children = _this.refShow.current.children;
      var parentElement = _this.refShow.current.parentElement;
      var containerWidth = parentElement.offsetWidth;
      var pivot = INIT_PIVOT;
      var buttonPivot = INIT_PIVOT; // 更多(...)的宽度

      var sum = 32;

      if (_this.refMore.current) {
        sum = _this.refMore.current.offsetWidth;
      } // 非第一次计算(如resize)，从缓存中取已计算好的数据


      if (!isFirst && _this.slotsWidthList && _this.slotsWidthList.length > 0) {
        for (var index = 0; index < _this.slotsWidthList.length; index += 1) {
          var lineWidth = _this.slotsWidthList[index];

          if (sum + lineWidth.totalWidth > containerWidth) {
            pivot = index;
            var widths = lineWidth.buttonWidths;
            var leftPadding = lineWidth.totalWidth - widths.reduce(function (a, b) {
              return a + b;
            }, 0);
            sum += leftPadding;

            for (var btnIdx = 0; btnIdx < widths.length; btnIdx++) {
              var btnWidth = widths[btnIdx];
              sum += btnWidth;

              if (sum > containerWidth && buttonPivot <= INIT_PIVOT) {
                buttonPivot = btnIdx;
              }
            }

            break;
          } else {
            sum += lineWidth.totalWidth;
          }
        }

        _this.setState({
          hiddenPivot: pivot,
          hiddenBtnPivot: buttonPivot
        });

        return;
      } // 第一次渲染或children发生变化，重新计算宽度


      for (var _index = 0; _index < children.length; _index += 1) {
        var child = children[_index]; // 计算的结构存入缓存

        var _lineWidth = _this.getLineWidth(child);

        _this.slotsWidthList.push(_lineWidth);

        if (sum + _lineWidth.totalWidth > containerWidth && pivot <= INIT_PIVOT) {
          pivot = _index;
          var _widths = _lineWidth.buttonWidths;

          for (var _btnIdx = 0; _btnIdx < _widths.length; _btnIdx++) {
            var _btnWidth = _widths[_btnIdx];
            sum += _btnWidth;

            if (sum > containerWidth && buttonPivot <= INIT_PIVOT) {
              buttonPivot = _btnIdx;
            }
          }
        } else {
          sum += _lineWidth.totalWidth;
        }
      }

      _this.setState({
        hiddenPivot: pivot,
        hiddenBtnPivot: buttonPivot
      });
    };

    _this.getResizeContainer = function () {
      return _this.refToolbar.current;
    };

    _this.handleResize = function () {
      _this.recomputeLayout();
    };

    _this.handleClickMorePanel = function (e) {
      var autoCloseMorePanel = _this.props.autoCloseMorePanel; // 阻止冒泡

      e.stopPropagation();

      if (autoCloseMorePanel) {
        _this.setState({
          morePanelVisible: false
        });
      }
    };

    _this.handleMorePanelVisibleChange = function (e) {
      _this.setState({
        morePanelVisible: e
      });
    };

    _this.state = {
      hiddenPivot: INIT_PIVOT,
      hiddenBtnPivot: INIT_PIVOT,
      groups: [],
      hiddenGroups: [],
      // eslint-disable-next-line react/no-unused-state
      prevChildren: null,
      // 用于状态比对
      needCalculating: false,
      morePanelVisible: false
    };
    _this.resizeObserver = new ResizeObserver(_this.handleResize);
    return _this;
  }

  var _proto = SingleLineToolbar.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;

    var autoFolding = this.props.autoFolding;
    if (!autoFolding) return;
    setTimeout(function () {
      return _this2.calculateWidth(true);
    }, 0);

    if (this.refToolContent.current && this.resizeObserver) {
      this.resizeObserver.observe(this.refToolContent.current);
    }

    if (this.refShow.current) {
      this.refShow.current.addEventListener('mousedown', this.mouseDownAtShow);
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var needCalculating = this.state.needCalculating;

    if (prevProps.children !== this.props.children && needCalculating) {
      this.calculateWidth(true);
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    var autoFolding = this.props.autoFolding;
    if (!autoFolding) return;

    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    }

    if (this.refShow.current) {
      this.refShow.current.removeEventListener('mousedown', this.mouseDownAtShow);
    }
  };

  _proto.renderMore = function renderMore(splitHiddenBoxs, hiddenSlots) {
    var zIndex = this.props.zIndex;
    var morePanelVisible = this.state.morePanelVisible;

    if (splitHiddenBoxs.length === 0 && hiddenSlots.length === 0) {
      return null;
    }

    var DropContent = /*#__PURE__*/_createElement(ToolsShow, {
      onClick: this.handleClickMorePanel
    }, splitHiddenBoxs.length ? /*#__PURE__*/_createElement(ToolLine, null, splitHiddenBoxs) : null, hiddenSlots);

    return /*#__PURE__*/_createElement(ToolsMore, {
      ref: this.refMore,
      isSingleLine: true
    }, /*#__PURE__*/_createElement(Dropdown, {
      trigger: "click",
      overlay: DropContent,
      placement: "bottomRight",
      zIndex: zIndex,
      overlayStyle: toolsMoreOverlayStyle,
      visible: morePanelVisible,
      onVisibleChange: this.handleMorePanelVisibleChange
    }, _ref));
  };

  _proto.render = function render() {
    var _this$props = this.props,
        style = _this$props.style,
        autoFolding = _this$props.autoFolding,
        alignType = _this$props.alignType,
        className = _this$props.className;
    var _this$state = this.state,
        hiddenPivot = _this$state.hiddenPivot,
        hiddenBtnPivot = _this$state.hiddenBtnPivot,
        hiddenGroups = _this$state.hiddenGroups,
        groups = _this$state.groups;
    var computedShowSlots = groups;
    var computedHiddenSlots = hiddenGroups;
    var splitHiddenBox = [];
    var splitShowBox = []; // 如果为初始值, 说明没有计算, 直接略过

    if (hiddenPivot > INIT_PIVOT) {
      // 分割点的ToolLine
      var toolLine = groups[hiddenPivot];
      var buttons = toolLine && toolLine.props && toolLine.props.children;

      if (buttons && buttons.length) {
        splitShowBox = buttons.slice(0, hiddenBtnPivot);
        splitHiddenBox = buttons.slice(hiddenBtnPivot);
      }

      computedShowSlots = groups.slice(0, hiddenPivot);
      computedHiddenSlots = computedHiddenSlots.concat(groups.slice(hiddenPivot + 1));
    }

    var styles = {
      width: autoFolding ? '0' : '100%'
    };
    return /*#__PURE__*/_createElement(ToolbarWrapper, {
      style: _extends({}, style),
      ref: this.refToolbar,
      className: className
    }, /*#__PURE__*/_createElement(Content, {
      ref: this.refToolContent,
      style: styles,
      className: alignType
    }, /*#__PURE__*/_createElement(ToolsShow, {
      ref: this.refShow
    }, computedShowSlots, splitShowBox.length ? /*#__PURE__*/_createElement(ToolLine, null, splitShowBox) : null), this.renderMore(splitHiddenBox, computedHiddenSlots)));
  };

  return SingleLineToolbar;
}(Component);
SingleLineToolbar.defaultProps = {
  autoFolding: true,
  alignType: 'center'
};

SingleLineToolbar.isNeedCalculating = function (params) {
  var prevGroups = params.prevGroups,
      prevHiddenGroups = params.prevHiddenGroups,
      groups = params.groups,
      hiddenGroups = params.hiddenGroups;

  if (prevGroups.length !== groups.length || prevHiddenGroups.length !== hiddenGroups.length) {
    return true;
  }

  for (var i = 0; i < groups.length; i++) {
    var _prevGroups$i$props$c = prevGroups[i].props.children,
        prevChildren = _prevGroups$i$props$c === void 0 ? [] : _prevGroups$i$props$c;
    var _groups$i$props$child = groups[i].props.children,
        curChildren = _groups$i$props$child === void 0 ? [] : _groups$i$props$child;

    if (prevChildren.length !== curChildren.length) {
      return true;
    }
  }

  for (var _i = 0; _i < hiddenGroups.length; _i++) {
    var _prevHiddenGroups$_i$ = prevHiddenGroups[_i].props.children,
        _prevChildren = _prevHiddenGroups$_i$ === void 0 ? [] : _prevHiddenGroups$_i$;

    var _hiddenGroups$_i$prop = hiddenGroups[_i].props.children,
        _curChildren = _hiddenGroups$_i$prop === void 0 ? [] : _hiddenGroups$_i$prop;

    if (_prevChildren.length !== _curChildren.length) {
      return true;
    }
  }

  return false;
};

SingleLineToolbar.getDerivedStateFromProps = function (props, state) {
  var prevChildren = state.prevChildren;
  var children = props.children,
      autoFolding = props.autoFolding;

  var _getChildren = getChildren(children),
      groups = _getChildren.groups,
      hiddenGroups = _getChildren.hiddenGroups;

  if (!autoFolding) {
    return {
      groups: groups,
      hiddenGroups: hiddenGroups,
      prevChildren: children,
      hiddenPivot: INIT_PIVOT,
      hiddenBtnPivot: INIT_PIVOT,
      needCalculating: false
    };
  }
  /**
   * 分两种情况
   * 1: 布局变换, 则重新计算布局
   * 2: 布局没变化, 但是children变换(children的props变化), 需要重新渲染
   */


  if (children !== prevChildren) {
    // TODO 如果对应自组件长度变化, 则认为布局变化
    var needCalculating = SingleLineToolbar.isNeedCalculating({
      prevGroups: state.groups,
      prevHiddenGroups: state.hiddenGroups,
      groups: groups,
      hiddenGroups: hiddenGroups
    });

    if (needCalculating) {
      return {
        groups: groups,
        hiddenGroups: hiddenGroups,
        prevChildren: children,
        hiddenPivot: INIT_PIVOT,
        hiddenBtnPivot: INIT_PIVOT,
        needCalculating: true
      };
    } // 布局未变化, 则沿用上次计算结果


    return {
      groups: groups,
      hiddenGroups: hiddenGroups,
      prevChildren: children,
      needCalculating: false
    };
  }

  return null;
};