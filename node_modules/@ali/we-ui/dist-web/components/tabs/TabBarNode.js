import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";

/* eslint-disable max-lines-per-function */

/* eslint-disable react/destructuring-assignment */

/* eslint-disable @typescript-eslint/no-explicit-any */

/* eslint-disable class-methods-use-this */

/* eslint-disable @typescript-eslint/explicit-function-return-type */

/* eslint-disable react/static-property-placement */
import React, { Component } from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import ResizeObserver from 'resize-observer-polyfill';
import { ArrowLeftNormal, ArrowRightNormal, ArrowDownNormal } from "../icons";
import { debounce, classnames } from "../../utils";
import { setTransform, isTransform3dSupported, noop } from "./utils";
import { NavContainer, NavWrap, NavScroll, Nav, PrevButton, NextButton, DropdownArrow, DropdownWrap, DropdownItemWrap } from "./styled";
import { Dropdown } from "../dropdown";

var _ref = /*#__PURE__*/_createElement(ArrowLeftNormal, {
  className: "prev-icon"
});

var _ref2 = /*#__PURE__*/_createElement(ArrowRightNormal, {
  className: "next-icon"
});

var _ref3 = /*#__PURE__*/_createElement(DropdownArrow, null, /*#__PURE__*/_createElement(ArrowDownNormal, null));

var TabBarNode = /*#__PURE__*/function (_Component) {
  _inheritsLoose(TabBarNode, _Component);

  function TabBarNode(props) {
    var _this;

    _this = _Component.call(this, props) || this;
    _this.offset = void 0;
    _this.resizeObserver = void 0;
    _this.debouncedResize = void 0;
    _this.lastNextPrevShown = void 0;

    _this.prevTransitionEnd = function (e) {
      if (e.propertyName !== 'opacity') {
        return;
      }

      var container = _this.props.getRef('container');

      _this.scrollToActiveTab({
        target: container,
        currentTarget: container
      });
    };

    _this.scrollToActiveTab = function (e) {
      var _this$props = _this.props,
          getRef = _this$props.getRef,
          excessMode = _this$props.excessMode;
      var activeTab = getRef('activeTab');
      var navWrap = getRef('navWrap');

      if (e && e.target !== e.currentTarget || !activeTab) {
        return;
      } // when not scrollable or enter scrollable first time, don't emit scrolling


      if (excessMode === 'arrow') {
        var needToSroll = _this.isNextPrevShown() && _this.lastNextPrevShown;

        _this.lastNextPrevShown = _this.isNextPrevShown();

        if (!needToSroll) {
          return;
        }
      }

      var activeTabWH = _this.getScrollWH(activeTab);

      var navWrapNodeWH = _this.getOffsetWH(navWrap);

      var _assertThisInitialize = _assertThisInitialized(_this),
          offset = _assertThisInitialize.offset;

      var wrapOffset = _this.getOffsetLT(navWrap);

      var activeTabOffset = _this.getOffsetLT(activeTab);

      if (wrapOffset > activeTabOffset) {
        // activeTab 在 wrap 的可见区域左侧
        offset += wrapOffset - activeTabOffset;

        _this.setOffset(offset);

        if (excessMode === 'arrow') _this.setNextPrev();
      } else if (wrapOffset + navWrapNodeWH < activeTabOffset + activeTabWH) {
        // activeTab 在 wrap 的可见区域右侧
        offset -= activeTabOffset + activeTabWH - (wrapOffset + navWrapNodeWH);

        _this.setOffset(offset);

        if (excessMode === 'arrow') _this.setNextPrev();
      }
    };

    _this.prev = function (e) {
      var _this$props2 = _this.props,
          onPrevClick = _this$props2.onPrevClick,
          getRef = _this$props2.getRef;

      if (onPrevClick) {
        onPrevClick(e);
      }

      var navWrapNode = getRef('navWrap');

      var navWrapNodeWH = _this.getOffsetWH(navWrapNode);

      var _assertThisInitialize2 = _assertThisInitialized(_this),
          offset = _assertThisInitialize2.offset;

      _this.setOffset(offset + navWrapNodeWH);

      _this.setNextPrev();
    };

    _this.next = function (e) {
      var _this$props3 = _this.props,
          onNextClick = _this$props3.onNextClick,
          getRef = _this$props3.getRef;

      if (onNextClick) {
        onNextClick(e);
      }

      var navWrapNode = getRef('navWrap');

      var navWrapNodeWH = _this.getOffsetWH(navWrapNode);

      var _assertThisInitialize3 = _assertThisInitialized(_this),
          offset = _assertThisInitialize3.offset;

      _this.setOffset(offset - navWrapNodeWH);

      _this.setNextPrev();
    };

    _this.offset = 0;
    _this.state = {
      next: false,
      prev: false,
      needsDropdown: false
    };
    return _this;
  }

  var _proto = TabBarNode.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;

    var _this$props4 = this.props,
        getRef = _this$props4.getRef,
        excessMode = _this$props4.excessMode;
    this.componentDidUpdate();
    var debounceCallback = noop;

    if (excessMode === 'arrow') {
      debounceCallback = function debounceCallback() {
        _this2.setNextPrev();

        _this2.scrollToActiveTab();
      };
    } else if (excessMode === 'dropdown') {
      debounceCallback = function debounceCallback() {
        _this2.setNeedsDropdown();

        _this2.scrollToActiveTab();
      };
    }

    this.debouncedResize = debounce(debounceCallback, 200);
    this.resizeObserver = new ResizeObserver(this.debouncedResize);
    this.resizeObserver.observe(getRef('container'));
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var props = this.props;
    var excessMode = props.excessMode;

    if (excessMode === 'arrow') {
      var nextPrev = this.setNextPrev(); // wait next, prev show hide

      if (this.isNextPrevShown(this.state) !== this.isNextPrevShown(nextPrev)) {
        // eslint-disable-next-line react/no-did-update-set-state
        this.setState({}, this.scrollToActiveTab);
      } else if (!prevProps || props.activeKey !== prevProps.activeKey) {
        // can not use props.activeKey
        this.scrollToActiveTab();
      }
    } else {
      var needsDropdown = this.setNeedsDropdown();

      if (needsDropdown !== this.state.needsDropdown) {
        this.scrollToActiveTab();
      } else if (!prevProps || props.activeKey !== prevProps.activeKey) {
        this.scrollToActiveTab();
      }
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    }

    if (this.debouncedResize && this.debouncedResize.cancel) {
      this.debouncedResize.cancel();
    }
  }
  /**
   * 检测左右按钮的激活状态，并调整 offset
   */
  ;

  _proto.setNextPrev = function setNextPrev() {
    var getRef = this.props.getRef;
    var navNode = getRef('nav');
    var navTabsContainer = getRef('navTabsContainer');
    var navNodeWH = this.getScrollWH(navTabsContainer || navNode); // Add 1px to fix `offsetWidth` with decimal in Chrome not correct handle
    // https://github.com/ant-design/ant-design/issues/13423

    var containerWH = this.getOffsetWH(getRef('container')) + 1;
    var navWrapNodeWH = this.getOffsetWH(getRef('navWrap'));
    var offset = this.offset;
    var minOffset = containerWH - navNodeWH;
    var _this$state = this.state,
        next = _this$state.next,
        prev = _this$state.prev;

    if (minOffset >= 0) {
      next = false;
      this.setOffset(0);
      offset = 0;
    } else if (minOffset < offset) {
      next = true;
    } else {
      next = false; // Fix https://github.com/ant-design/ant-design/issues/8861
      // Test with container offset which is stable
      // and set the offset of the nav wrap node

      var realOffset = navWrapNodeWH - navNodeWH;
      this.setOffset(realOffset);
      offset = realOffset;
    }

    if (offset < 0) {
      prev = true;
    } else {
      prev = false;
    }

    this.setNext(next);
    this.setPrev(prev);
    return {
      next: next,
      prev: prev
    };
  }
  /**
   * 获取节点的宽度
   *
   * @param {HTMLElement} node
   * @return {number} offsetWidth
   */
  ;

  _proto.getOffsetWH = function getOffsetWH(node) {
    return node.offsetWidth;
  }
  /**
   * 获取节点的滚动宽度
   *
   * @param {HTMLElement} node
   * @return {number} scrollWidth
   */
  ;

  _proto.getScrollWH = function getScrollWH(node) {
    return node.scrollWidth;
  }
  /**
   * 获取节点的偏移量
   *
   * @param {HTMLElement} node
   * @return {number} clientRect.left
   */
  ;

  _proto.getOffsetLT = function getOffsetLT(node) {
    return node.getBoundingClientRect().left;
  }
  /**
   * 设置偏移量
   *
   */
  ;

  _proto.setOffset = function setOffset(offset) {
    var getRef = this.props.getRef;
    var target = Math.min(0, offset);

    if (this.offset !== target) {
      this.offset = target;
      var navOffset = {};
      var navStyle = getRef('nav').style;
      var transformSupported = isTransform3dSupported(navStyle);

      if (transformSupported) {
        navOffset = {
          value: "translate3d(" + target + "px,0,0)"
        };
      } else {
        navOffset = {
          name: 'left',
          value: target + "px"
        };
      }

      if (transformSupported) {
        setTransform(navStyle, navOffset.value);
      } else {
        navStyle[navOffset.name] = navOffset.value;
      }
    }
  };

  _proto.setPrev = function setPrev(v) {
    if (this.state.prev !== v) {
      this.setState({
        prev: v
      });
    }
  };

  _proto.setNext = function setNext(v) {
    if (this.state.next !== v) {
      this.setState({
        next: v
      });
    }
  };

  /**
   * 判断左右的按钮是否显示
   */
  _proto.isNextPrevShown = function isNextPrevShown(state) {
    if (state) {
      return state.next || state.prev;
    }

    var _this$state2 = this.state,
        next = _this$state2.next,
        prev = _this$state2.prev;
    return next || prev;
  }
  /**
   * 检测 dropdown 是否需要显示，并调整 offset
   */
  ;

  _proto.setNeedsDropdown = function setNeedsDropdown() {
    var getRef = this.props.getRef;
    var navNode = getRef('nav');
    var navTabsContainer = getRef('navTabsContainer');
    var navNodeWH = this.getScrollWH(navTabsContainer || navNode);
    var containerWH = this.getOffsetWH(getRef('container')) + 1; // 最小的偏移量（可滚动时为负值）

    var minOffset = containerWH - navNodeWH;
    var needsDropdown = minOffset < 0;

    if (!needsDropdown) {
      this.setOffset(0);
    } else if (minOffset > this.offset) {
      // 如果此时偏移量比最小偏移量小（可能是窗口 resize 引起），则重置 offset
      this.setOffset(minOffset);
    }

    if (needsDropdown !== this.state.needsDropdown) {
      this.setState({
        needsDropdown: needsDropdown
      });
    }

    return needsDropdown;
  };

  _proto.render = function render() {
    var _this$state3 = this.state,
        next = _this$state3.next,
        prev = _this$state3.prev,
        needsDropdown = _this$state3.needsDropdown;
    var showNextPrev = prev || next;
    var prevCallback = this.prev,
        nextCallback = this.next,
        prevTransitionEnd = this.prevTransitionEnd;
    var _this$props5 = this.props,
        size = _this$props5.size,
        children = _this$props5.children,
        saveRef = _this$props5.saveRef,
        animated = _this$props5.animated,
        type = _this$props5.type,
        excessMode = _this$props5.excessMode,
        onTabClick = _this$props5.onTabClick,
        panes = _this$props5.panes,
        activeKey = _this$props5.activeKey;

    var getPrevNext = function getPrevNext() {
      var prevButton = /*#__PURE__*/_createElement(PrevButton, {
        onClick: prev ? prevCallback : undefined,
        unselectable: "on",
        className: classnames({
          disabled: !prev,
          show: showNextPrev
        }),
        onTransitionEnd: prevTransitionEnd
      }, _ref);

      var nextButton = /*#__PURE__*/_createElement(NextButton, {
        onClick: next ? nextCallback : undefined,
        unselectable: "on",
        className: classnames({
          disabled: !next,
          show: showNextPrev
        })
      }, _ref2);

      return /*#__PURE__*/_createElement(React.Fragment, null, prevButton, nextButton);
    };

    var getOverlay = function getOverlay() {
      var rst = [];
      React.Children.forEach(panes, function (child) {
        if (!child) {
          return;
        }

        var key = child.key;
        var isActived = activeKey === key;

        var handleClick = function handleClick(e) {
          if (onTabClick) {
            onTabClick(key, e);
          }
        };

        var node = /*#__PURE__*/_createElement(DropdownItemWrap, {
          "aria-disabled": child.props.disabled ? 'true' : 'false',
          "aria-selected": isActived ? 'true' : 'false',
          tabIndex: isActived ? 0 : -1,
          key: key,
          className: classnames({
            disabled: Boolean(child.props.disabled),
            actived: isActived
          }),
          onClick: !isActived && !child.props.disabled ? handleClick : undefined
        }, child.props.tab);

        rst.push(node);
      });
      return /*#__PURE__*/_createElement(DropdownWrap, null, rst);
    };

    var excessTabsHelper = function excessTabsHelper(mode) {
      if (mode === 'arrow') {
        return showNextPrev ? getPrevNext() : undefined;
      } else if (mode === 'dropdown') {
        return needsDropdown ? /*#__PURE__*/_createElement(Dropdown, {
          overlay: getOverlay(),
          trigger: "click",
          placement: "bottomRight"
        }, _ref3) : undefined;
      }
    };

    return /*#__PURE__*/_createElement(NavContainer, {
      className: classnames(size, type, {
        scrolling: excessMode === 'arrow' ? showNextPrev : needsDropdown
      }),
      ref: saveRef('container')
    }, excessTabsHelper(excessMode), /*#__PURE__*/_createElement(NavWrap, {
      className: classnames(type),
      ref: saveRef('navWrap')
    }, /*#__PURE__*/_createElement(NavScroll, null, /*#__PURE__*/_createElement(Nav, {
      className: classnames(type, animated && 'animated'),
      ref: saveRef('nav')
    }, children))));
  };

  return TabBarNode;
}(Component);

TabBarNode.defaultProps = {
  tabBarPosition: 'left',
  prefixCls: '',
  onPrevClick: noop,
  onNextClick: noop
};
export { TabBarNode as default };