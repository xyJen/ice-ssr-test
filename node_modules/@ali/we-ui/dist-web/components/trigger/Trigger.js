/* eslint-disable react/no-find-dom-node */
import React, { useCallback, useRef, useState } from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import useControlledValue from "../../hooks/useControlledValue";
import { KEY_CODES } from "../../utils/consts";
import { supportRef, composeRef } from "../../utils/ref";
import { findDOMNode, elementContain } from "../../utils/dom";
import { Popup } from "./Popup";
import { Tooltip } from "../tooltip";
var DELAY_TO_SHOW = 300;
var DELAY_TO_HIDE = 200;
// eslint-disable-next-line max-lines-per-function
export var Trigger = /*#__PURE__*/React.memo(function (props) {
  var children = props.children,
      overlay = props.overlay,
      action = props.action,
      onVisibleChange = props.onVisibleChange,
      getContainer = props.getContainer,
      placement = props.placement,
      overlayStyle = props.overlayStyle,
      zIndex = props.zIndex,
      offsetX = props.offsetX,
      offsetY = props.offsetY,
      pageX = props.pageX,
      pageY = props.pageY,
      overlayClassName = props.overlayClassName,
      mask = props.mask,
      triggerNode = props.triggerNode,
      title = props.title,
      testid = props.testid;
  var triggerRef = useRef(null);

  var _useControlledValue = useControlledValue(props.visible, props.defaultVisible),
      visible = _useControlledValue[0],
      setVisible = _useControlledValue[1];

  var coord = useRef({
    x: 0,
    y: 0
  }).current;

  var _useState = useState(false),
      isTriggerFocused = _useState[0],
      setTriggerFocuesed = _useState[1];

  var hasFocusAction = action.includes('focus');
  var hasHoverAction = action.includes('hover');
  var hasClickAction = action.includes('click');
  var hasContextMenuAction = action.includes('contextMenu');
  var child = children ? React.Children.only(children) : null;
  var cloneProps = {};

  var _ref = child && child.props || {},
      onFocus = _ref.onFocus,
      onBlur = _ref.onBlur,
      onMouseEnter = _ref.onMouseEnter,
      onMouseLeave = _ref.onMouseLeave,
      onClick = _ref.onClick,
      onContextMenu = _ref.onContextMenu,
      onKeyDown = _ref.onKeyDown;

  var timerEnter = useRef(0);
  var timerLeave = useRef(0);
  var isEntered = useRef({
    trigger: false,
    overlay: false
  }).current;
  var getTriggerNode = useCallback(function () {
    if (triggerRef.current) {
      return findDOMNode(triggerRef.current);
    }

    return triggerNode;
  }, [triggerNode]);
  /**
   * visible变化
   *
   * @param {boolean}
   * @return {void}
   */

  var handleVisibleChange = useCallback(function (e) {
    if (visible !== e) {
      if (onVisibleChange) {
        onVisibleChange(e);
      }

      setVisible(e);
    }
  }, [onVisibleChange, setVisible, visible]);
  /**
   * 清除进入的定时器
   *
   * @param {void}
   */

  var handleClearTimerEnter = useCallback(function () {
    if (timerEnter.current) {
      window.clearTimeout(timerEnter.current);
      timerEnter.current = 0;
    }
  }, []);
  /**
   * 清除离开的定时器
   *
   * @param {void}
   */

  var handleClearTimerLeave = useCallback(function () {
    if (timerLeave.current) {
      window.clearTimeout(timerLeave.current);
      timerLeave.current = 0;
    }
  }, []);
  /**
   * 进入trigger/overlay
   *
   * @return void
   */

  var handleEnter = useCallback(function () {
    handleClearTimerEnter();
    handleClearTimerLeave();
    var newVisible = isEntered.trigger || isEntered.overlay;

    if (newVisible && !visible) {
      timerLeave.current = window.setTimeout(function () {
        handleVisibleChange(true);
      }, DELAY_TO_SHOW);
    }
  }, [isEntered, handleClearTimerEnter, handleClearTimerLeave, handleVisibleChange, visible]);
  /**
   * 离开trigger/overlay
   *
   * @return void
   */

  var handleLeave = useCallback(function () {
    handleClearTimerEnter();
    handleClearTimerLeave();
    var newVisible = isEntered.trigger || isEntered.overlay;

    if (!newVisible && visible) {
      timerLeave.current = window.setTimeout(function () {
        handleVisibleChange(false);
      }, DELAY_TO_HIDE);
    }
  }, [handleClearTimerEnter, handleClearTimerLeave, isEntered, visible, handleVisibleChange]);
  /**
   * 进入trigger
   *
   * @param {React.MouseEvent<HTMLElement>} e
   * @return {void}
   */

  var handleEnterTrigger = useCallback(function (e) {
    var tNode = getTriggerNode();

    if (tNode) {
      // 等于或者包含
      if (elementContain(tNode, e.target)) {
        onMouseEnter && onMouseEnter(e);
        isEntered.trigger = true;
        handleEnter();
      }
    }
  }, [onMouseEnter, isEntered, handleEnter, getTriggerNode]);
  /**
   * 聚焦
   *
   * @param {React.FocusEvent<HTMLElement>} e
   * @return {void}
   */

  var handleTriggerFocus = useCallback(function (e) {
    var tNode = getTriggerNode();

    if (tNode) {
      // 等于或者包含
      if (elementContain(tNode, e.target)) {
        onFocus && onFocus(e);
        setTriggerFocuesed(true);
      }
    }
  }, [onFocus, getTriggerNode]);
  /**
   * 失焦
   *
   * @param {React.FocusEvent<HTMLElement>} e
   * @return {void}
   */

  var handleTriggerBlur = useCallback(function (e) {
    var tNode = getTriggerNode();

    if (tNode) {
      // 等于或者包含
      if (elementContain(tNode, e.target)) {
        onBlur && onBlur(e);
        setTriggerFocuesed(false);

        if (visible) {
          handleVisibleChange(false);
        }
      }
    }
  }, [onBlur, handleVisibleChange, visible, getTriggerNode]);
  /**
   * 离开trigger
   *
   * @param {React.MouseEvent<HTMLElement>} e
   * @return {void}
   */

  var handleLeaveTrigger = useCallback(function (e) {
    var tNode = getTriggerNode();

    if (tNode) {
      // 等于或者包含
      if (elementContain(tNode, e.target)) {
        onMouseLeave && onMouseLeave(e);
        isEntered.trigger = false;
        handleLeave();
      }
    }
  }, [onMouseLeave, isEntered, handleLeave, getTriggerNode]);
  /**
   * 进入overlay
   *
   * @return {void}
   */

  var handleEnterOverlay = useCallback(function () {
    isEntered.overlay = true;
    handleEnter();
  }, [handleEnter, isEntered]);
  /**
   * 离开overlay
   *
   * @return {void}
   */

  var handleLeaveOverlay = useCallback(function () {
    isEntered.overlay = false;
    handleLeave();
  }, [handleLeave, isEntered]);
  /**
   * 点击overlay外需要收起
   */

  var handleClickOverlayOuter = useCallback(function (e) {
    var tNode = getTriggerNode();

    if (tNode) {
      // 等于或者包含
      if (!elementContain(tNode, e.target)) {
        handleVisibleChange(false);
      }
    } else {
      handleVisibleChange(false);
    }
  }, [handleVisibleChange, getTriggerNode]);
  /**
   * 点击trigger
   *
   * @param {React.MouseEvent<HTMLElement>}
   * @return {void}
   */

  var handleClickTrigger = useCallback(function (e) {
    var tNode = getTriggerNode();

    if (tNode) {
      // 等于或者包含
      if (elementContain(tNode, e.target)) {
        if (onClick) {
          var rst = onClick(e);

          if (rst === false) {
            return false;
          }
        }

        handleVisibleChange(!visible);
      }
    }
  }, [onClick, visible, handleVisibleChange, getTriggerNode]);
  /**
   * 右键惨淡展开
   *
   * @param {React.MouseEvent<HTMLElement>}
   * @return {void}
   */

  var handleContextMenuTrigger = useCallback(function (e) {
    var tNode = getTriggerNode();

    if (tNode) {
      // 等于或者包含
      if (elementContain(tNode, e.target)) {
        e.preventDefault();

        if (onContextMenu) {
          onContextMenu(e);
        }

        if (tNode.getBoundingClientRect) {
          var clientRect = tNode.getBoundingClientRect();
          coord.x = e.clientX - clientRect.left;
          coord.y = e.clientY - clientRect.top - clientRect.height;
        } else {
          coord.x = e.clientX;
          coord.y = e.clientY;
        }

        handleVisibleChange(!visible);
      }
    }
  }, [onContextMenu, handleVisibleChange, getTriggerNode, visible, coord]);
  /**
   * 遮罩
   */

  var handleClickMask = useCallback(function () {
    handleVisibleChange(false);
  }, [handleVisibleChange]);
  var handleKeyDown = useCallback(function (e) {
    if (onKeyDown) {
      onKeyDown(e);
    }

    if (isTriggerFocused) {
      // 方向键展开
      if ([KEY_CODES.UP, KEY_CODES.DOWN, KEY_CODES.LEFT, KEY_CODES.RIGHT].includes(e.which)) {
        e.preventDefault();

        if (!visible) {
          handleVisibleChange(true);
        }
      } // ESC 关闭


      if (e.which === KEY_CODES.ESC) {
        e.preventDefault();

        if (visible) {
          handleVisibleChange(false);
        }
      }
    }
  }, [isTriggerFocused, handleVisibleChange, visible, onKeyDown]);

  if (child && supportRef(child)) {
    cloneProps.ref = composeRef(triggerRef, child.ref);
  }

  if (hasHoverAction) {
    cloneProps.onMouseEnter = handleEnterTrigger;
    cloneProps.onMouseLeave = handleLeaveTrigger;
  } else {
    cloneProps.onMouseEnter = onMouseEnter;
    cloneProps.onMouseLeave = onMouseLeave;
  }

  if (hasFocusAction) {
    cloneProps.onFocus = handleTriggerFocus;
    cloneProps.onBlur = handleTriggerBlur;
    cloneProps.onKeyDown = handleKeyDown;
  }

  if (hasClickAction) {
    cloneProps.onClick = handleClickTrigger;
  }

  if (hasContextMenuAction) {
    cloneProps.onContextMenu = handleContextMenuTrigger;
  }

  return /*#__PURE__*/_createElement(React.Fragment, null, !!child && /*#__PURE__*/_createElement(Tooltip, {
    title: title,
    disabled: visible
  }, /*#__PURE__*/React.cloneElement(child, cloneProps)), /*#__PURE__*/_createElement(Popup, {
    zIndex: zIndex,
    overlay: overlay,
    visible: !!visible,
    placement: hasContextMenuAction ? 'bottomLeft' : placement,
    triggerNode: getTriggerNode(),
    overlayStyle: overlayStyle,
    overlayClassName: overlayClassName,
    mask: hasContextMenuAction || !!mask,
    getContainer: getContainer,
    offsetX: hasContextMenuAction ? coord.x + offsetX : offsetX,
    offsetY: hasContextMenuAction ? coord.y + offsetY : offsetY,
    pageX: pageX,
    pageY: pageY,
    onMouseEnter: hasHoverAction ? handleEnterOverlay : undefined,
    onMouseLeave: hasHoverAction ? handleLeaveOverlay : undefined,
    onClickOuter: hasClickAction ? handleClickOverlayOuter : undefined,
    onClickMask: hasContextMenuAction ? handleClickMask : undefined,
    testid: testid
  }));
});
Trigger.defaultProps = {
  action: [],
  placement: 'bottomLeft',
  overlayStyle: {},
  defaultVisible: false,
  offsetX: 0,
  offsetY: 0
};