// /* eslint-disable @typescript-eslint/no-non-null-assertion */
// /* eslint-disable prefer-destructuring */
// import React, { useRef, useEffect, useState } from 'react';
// import { EllipsisWrap, EllipsisShadowWrap } from './styled';
// interface IEllipsisProps {
//   lines?: number;
//   suffix?: React.ReactNode;
//   text: string;
// }
// const MAX_EXEC_COUNT = 1000;
// const Ellipsis: React.FC<IEllipsisProps> = (props) => {
//   const { text, lines, suffix } = props;
//   const containerRef = useRef<HTMLDivElement>(null);
//   const shadowRef = useRef<HTMLDivElement>(null);
//   const shadowTextRef = useRef<HTMLSpanElement>(null);
//   const [showText, setShowText] = useState(text);
//   useEffect(() => {
//     let updated = false;
//     let count = 0;
//     if (lines && text) {
//       const lineHeight = parseInt(getComputedStyle(containerRef.current!).lineHeight, 10);
//       const targetHeight = lineHeight * lines;
//       /**
//        * 二分法算法
//        * @param {number} start 截取起点
//        * @param {number} end 截取终点
//        * @return {void}
//        */
//       const dichotomy = (start: number, end: number): void => {
//         count += 1;
//         const middle = Math.floor(start / 2 + end / 2); // 用floor可以在临界点取较少的字
//         const targetText = text.slice(0, middle);
//         shadowTextRef.current!.innerText = `${targetText}...`;
//         const offsetHeight = shadowRef.current!.offsetHeight;
//         /**
//          * offsetHeight <= targetHeight: 文本可能少，也可能刚好
//          * offsetHeight > targetHeight: 文本仍然超出
//          */
//         const newStart = offsetHeight <= targetHeight ? middle : start;
//         const newEnd = offsetHeight <= targetHeight ? end : middle;
//         if (newEnd - newStart > 1 && count < MAX_EXEC_COUNT && !updated) {
//           dichotomy(newStart, newEnd);
//         } else {
//           // 极限情况下会有1个字符的多余情况
//           const newText = offsetHeight > targetHeight ? targetText.slice(0, -1) : targetText;
//           setShowText(`${newText}...`);
//         }
//       };
//       const offsetHeight = shadowRef.current!.offsetHeight;
//       const needCalculation = (lines > 1 || suffix) && offsetHeight > targetHeight;
//       if (needCalculation) {
//         dichotomy(0, text.length);
//       }
//     }
//     return (): void => {
//       updated = true;
//     };
//   }, [lines, text, suffix]);
//   return (
//     <EllipsisWrap ref={containerRef} ellipsis={(lines || 0) <= 1 && !suffix}>
//       {showText}
//       {suffix}
//       <EllipsisShadowWrap ref={shadowRef}>
//         <span ref={shadowTextRef}>{text}</span>
//         {suffix}
//       </EllipsisShadowWrap>
//     </EllipsisWrap>
//   );
// };
// Ellipsis.defaultProps = {
//   lines: 1,
//   suffix: null,
// };
// const MemoEllipsis = React.memo(Ellipsis);
// export { MemoEllipsis as Ellipsis };