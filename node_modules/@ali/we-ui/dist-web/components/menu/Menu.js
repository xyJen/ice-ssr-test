import _extends from "@babel/runtime/helpers/extends";
import React, { useCallback, useMemo, useState, useEffect } from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import { MenuDivider } from "./MenuDivider";
import { MenuItem } from "./MenuItem";
import { SubMenu } from "./SubMenu";
import { MenuItemGroup } from "./MenuItemGroup";
import { ControllerContext, MenuKeyContext, PathContext, HotkeyPositionContext } from "./contexts";
import { MenuRoot } from "./styled";
import classnames from "../../utils/classnames";
import { useMenuKeyContext, useMousePosition, useRegisterValidNode } from "./hooks";
import { useControlledValue } from "../../hooks";
import { EMenuMode } from "./consts";
import { uuid } from "../../utils";
import { elementContain } from "../../utils/dom";

/**
 * 获取同层级的所有的 menuKey
 *
 * @param {Record<string, string>} menuKeys
 * @param {string} path
 * @return {string[]}
 */
var getSameLevelMenuKeys = function getSameLevelMenuKeys(menuKeys, path) {
  var paths = path.split('::');
  paths.pop();
  var levelMenuKeys = Object.keys(paths.reduce(function (keys, key) {
    return keys[key];
  }, menuKeys));
  return levelMenuKeys;
}; // eslint-disable-next-line max-lines-per-function


export var Menu = /*#__PURE__*/React.memo(function (props) {
  var mode = props.mode,
      children = props.children,
      className = props.className,
      style = props.style,
      selectedKeys = props.selectedKeys,
      defaultSelectedKeys = props.defaultSelectedKeys,
      zIndex = props.zIndex,
      onClick = props.onClick,
      autoClose = props.autoClose,
      destroyOverlayWhenInvisible = props.destroyOverlayWhenInvisible,
      shortcutKey = props.shortcutKey,
      shouldSelectFirstItem = props.shouldSelectFirstItem,
      insertSubmenuToMenuRoot = props.insertSubmenuToMenuRoot;
  var menuId = useMemo(function () {
    return uuid();
  }, []);
  var menuRootRef = React.useRef(); // 展开的submenu的key

  var _useState = useState([]),
      openedMenuKeys = _useState[0],
      setOpenedMenuKeys = _useState[1]; // 处理menuKeys


  var _useMenuKeyContext = useMenuKeyContext(),
      menuKeyCtxValue = _useMenuKeyContext[0],
      menuKeys = _useMenuKeyContext[2]; // 选中的 key，受控


  var _useControlledValue = useControlledValue(selectedKeys, defaultSelectedKeys),
      selectedMenuKeys = _useControlledValue[0],
      setSelectedMenuKeys = _useControlledValue[1];

  var _useMousePosition = useMousePosition(),
      handleMouseOver = _useMousePosition.handleMouseOver,
      setMousePosition = _useMousePosition.setMousePosition,
      mousePosition = _useMousePosition.mousePosition;

  var _useState2 = useState(shortcutKey || false),
      isHotkeyType = _useState2[0],
      _setHotkeyType = _useState2[1];

  var _useRegisterValidNode = useRegisterValidNode(menuId, !!shouldSelectFirstItem, openedMenuKeys),
      registerValidNode = _useRegisterValidNode.registerValidNode,
      unRegisterValidNode = _useRegisterValidNode.unRegisterValidNode,
      hotkeyPosition = _useRegisterValidNode.hotkeyPosition,
      _setHotkeyPosition = _useRegisterValidNode.setHotkeyPosition,
      validNodes = _useRegisterValidNode.validNodes,
      hotKeyPath = _useRegisterValidNode.hotKeyPath; // useEffect(() => {
  //   // eslint-disable-next-line no-console
  //   console.log('当前位置', validNodes, hotkeyPosition, mousePosition);
  // }, [hotkeyPosition, mousePosition, validNodes]);

  /**
   * 绑定快捷键
   */


  useEffect(function () {
    if (shortcutKey) {
      document.addEventListener('keydown', addHotKeys);
      return function () {
        document.removeEventListener('keydown', addHotKeys);
        hotKeyPath.current = undefined;
        _setHotkeyPosition && _setHotkeyPosition(null);
      };
    }
  }, [shortcutKey, mode]);
  /**
  * 添加快捷方式
  */

  var addHotKeys = useCallback(function (event) {
    var key = event.key.toLowerCase();

    _setHotkeyType(true);

    if (validNodes.current.length === 0) return;
    if (!hotKeyPath.current) return;

    if (key === 'arrowup' || event.keyCode === 38) {
      event.preventDefault();

      if (hotKeyPath.current.path.split('::').length === 2 && mode === EMenuMode.horizontal && hotKeyPath.current.index === 0) {
        arrowLeft();
      } else {
        arrowDownOrUp('up');
      }
    } else if (key === 'arrowright' || event.keyCode === 39) {
      event.preventDefault();

      if (hotKeyPath.current.path.split('::').length === 1 && mode === EMenuMode.horizontal) {
        arrowDownOrUp('down');
      } else {
        arrowRight();
      }
    } else if (key === 'arrowdown' || event.keyCode === 40) {
      event.preventDefault();

      if (hotKeyPath.current.path.split('::').length === 1 && mode === EMenuMode.horizontal) {
        arrowRight();
      } else {
        arrowDownOrUp('down');
      }
    } else if (key === 'arrowleft' || event.keyCode === 37) {
      event.preventDefault();

      if (hotKeyPath.current.path.split('::').length === 2 && mode === EMenuMode.horizontal) {
        return;
      } else if (hotKeyPath.current.path.split('::').length === 1 && mode === EMenuMode.horizontal) {
        arrowDownOrUp('up');
      } else {
        arrowLeft();
      }
    } else if (key === 'enter' || event.keyCode === 13) {
      event.preventDefault();

      if (hotKeyPath.current && hotKeyPath.current.onClick) {
        hotKeyPath.current.onClick();
        controller.closeAllMenu();
      }

      return;
    }

    if (_setHotkeyPosition && hotKeyPath.current) _setHotkeyPosition(_extends({}, hotKeyPath.current, {
      eventKey: key
    }));
  }, [openedMenuKeys, mode]);
  /**
   * 快捷键：从有效的结构树中获取节点
   */

  var getActionNode = useCallback(function (key, nodes) {
    var node = null;
    (nodes || validNodes.current).every(function (o) {
      if (o.menuKey === key) {
        node = o;
        return false;
      }

      node = getActionNode(key, o.children || []);
      if (node) return false;
      return true;
    });
    return node;
  }, [validNodes]);
  /**
   * 键盘向右
   */

  var arrowRight = function arrowRight() {
    if (!hotKeyPath.current || !hotKeyPath.current.children) return;
    showSubMenu(hotKeyPath.current.path);

    if (hotKeyPath.current && hotKeyPath.current.children.length > 0) {
      hotKeyPath.current = hotKeyPath.current.children[0];
    }
  };
  /**
  * 键盘向坐左
  */


  var arrowLeft = function arrowLeft() {
    if (!hotKeyPath.current) {
      return;
    }

    var current;

    var findParentNode = function findParentNode(_validNodes) {
      _validNodes.every(function (o) {
        var _hotKeyPath$current;

        if (!o.children) return true;

        if (((_hotKeyPath$current = hotKeyPath.current) == null ? void 0 : _hotKeyPath$current.parentPath) === o.path) {
          current = o;
          return false;
        }

        current = findParentNode(o.children);
        return true;
      });

      return current;
    };

    var node = findParentNode(validNodes.current);

    if (node) {
      controller.showSubMenu(node.path.split('::').slice(0, -1).join('::'));
      hotKeyPath.current = node;
    }
  };
  /**
  * 键盘向上下
  */


  var arrowDownOrUp = function arrowDownOrUp(key) {
    if (!hotKeyPath.current) return;

    if (hotKeyPath.current.children && hotKeyPath.current.children.length > 0) {
      controller.showSubMenu(hotKeyPath.current.path.split('::').slice(0, -1).join('::'));
    }

    var current;

    var findNextNode = function findNextNode(_validNodes) {
      if (_validNodes.length === 0) return;

      _validNodes.every(function (o, i) {
        var _hotKeyPath$current2;

        var resNode = key === 'down' ? _validNodes[i + 1] : _validNodes[i - 1];

        if (((_hotKeyPath$current2 = hotKeyPath.current) == null ? void 0 : _hotKeyPath$current2.menuKey) === o.menuKey && resNode) {
          current = resNode;
          return false;
        } else {
          findNextNode(o.children || []);
        }

        return true;
      });

      return current;
    };

    var node = findNextNode(validNodes.current);
    if (node) hotKeyPath.current = node;
  };
  /**
   * 显示二级菜单
   *
   * @param {string} path 要显示的菜单项的key路径
   * @return {void}
   */


  var showSubMenu = useCallback(function (path) {
    setOpenedMenuKeys(path.split('::'));
  }, []);
  /**
   * 二级菜单是否展开
   *
   * @param {string} menuKey
   * @return {boolean} isVisible
   */

  var isSubMenuOpened = useCallback(function (menuKey) {
    return openedMenuKeys.includes(menuKey);
  }, [openedMenuKeys]);
  /**
   * 同级的二级菜单是否展开
   *
   * @param {string} path 要显示的菜单项的key路径
   * @return {boolean}
   */

  var isAnySubMenuOpened = useCallback(function (path) {
    var keys = getSameLevelMenuKeys(menuKeys, path);
    return keys.some(function (key) {
      return openedMenuKeys.includes(key);
    });
  }, [openedMenuKeys, menuKeys]);
  /**
   * 菜单项是否被选中
   *
   * @param {string} menuKey
   * @return {boolean}
   */

  var isMenuItemSelected = useCallback(function (menuKey) {
    return selectedMenuKeys.includes(menuKey);
  }, [selectedMenuKeys]);
  /**
   * 关闭所有的展开菜单项
   *
   * @return {void}
   */

  var closeAllMenu = useCallback(function () {
    _setHotkeyPosition(null);

    hotKeyPath.current = null;
    setOpenedMenuKeys([]);
  }, []);
  /**
   * 选中 MenuItem
   *
   * @param {string} menuKey
   * @return {void}
   */

  var selectMenuItem = useCallback(function (menuKey) {
    if (!selectedMenuKeys.includes(menuKey)) {
      setSelectedMenuKeys([].concat(selectedMenuKeys, [menuKey]));
    }
  }, [selectedMenuKeys, setSelectedMenuKeys]);
  var controller = useMemo(function () {
    return {
      mode: mode,
      zIndex: zIndex,
      autoClose: !!autoClose,
      menuId: menuId,
      isSubMenuOpened: isSubMenuOpened,
      isAnySubMenuOpened: isAnySubMenuOpened,
      showSubMenu: showSubMenu,
      isMenuItemSelected: isMenuItemSelected,
      closeAllMenu: closeAllMenu,
      selectMenuItem: selectMenuItem,
      clickMenuItem: onClick,
      destroyOverlayWhenInvisible: destroyOverlayWhenInvisible,
      showMenuTimer: 0,
      shortcutKey: shortcutKey,
      menuRootRef: insertSubmenuToMenuRoot ? menuRootRef : undefined
    };
  }, [mode, menuId, zIndex, autoClose, showSubMenu, isSubMenuOpened, isAnySubMenuOpened, isMenuItemSelected, closeAllMenu, selectMenuItem, onClick, destroyOverlayWhenInvisible, shortcutKey, menuRootRef, insertSubmenuToMenuRoot]);
  var hotkeyPositionValue = {
    hotkeyPosition: hotkeyPosition,
    isHotkeyType: isHotkeyType,
    mousePosition: mousePosition,
    getActionNode: getActionNode,
    registerValidNode: registerValidNode,
    unRegisterValidNode: unRegisterValidNode,
    setHotkeyPosition: function setHotkeyPosition(node) {
      hotKeyPath.current = node;

      _setHotkeyPosition(node);
    },
    setMousePosition: setMousePosition,
    setHotkeyType: function setHotkeyType(val) {
      if (val === false) _setHotkeyPosition(null);

      _setHotkeyType(val);
    }
  };
  useEffect(function () {
    var handleMouseDown = function handleMouseDown(e) {
      // 后续寻求更好的办法
      var overlayElements = document.querySelectorAll(".we-ui-submenu-" + menuId + "-overlay"); // 是否点击的是overlay

      var inOverlay = Array.from(overlayElements).some(function (overlayElement) {
        return elementContain(overlayElement, e.target);
      });

      if (!inOverlay) {
        closeAllMenu();
      }
    };

    var length = openedMenuKeys.length;

    if (length) {
      document.addEventListener('mousedown', handleMouseDown);
    }

    return function () {
      if (length) {
        document.removeEventListener('mousedown', handleMouseDown);
      }
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [menuId, openedMenuKeys.length, closeAllMenu]);
  return /*#__PURE__*/_createElement(MenuRoot, {
    onMouseMove: shortcutKey ? handleMouseOver : null,
    ref: menuRootRef,
    className: classnames("we-ui-submenu-" + menuId + "-overlay", className, mode),
    style: style
  }, /*#__PURE__*/_createElement(PathContext.Provider, {
    value: ""
  }, /*#__PURE__*/_createElement(MenuKeyContext.Provider, {
    value: menuKeyCtxValue
  }, /*#__PURE__*/_createElement(ControllerContext.Provider, {
    value: controller
  }, /*#__PURE__*/_createElement(HotkeyPositionContext.Provider, {
    value: hotkeyPositionValue
  }, children)))));
});
Menu.defaultProps = {
  mode: EMenuMode.vertical,
  defaultSelectedKeys: [],
  autoClose: true,
  destroyOverlayWhenInvisible: false,
  shortcutKey: false,
  shouldSelectFirstItem: false
};
Menu.Item = MenuItem;
Menu.ItemGroup = MenuItemGroup;
Menu.Divider = MenuDivider;
Menu.SubMenu = SubMenu;