import _regeneratorRuntime from "@babel/runtime/regenerator";
import _extends from "@babel/runtime/helpers/extends";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import { transferUtils, constants } from '@ali/4ever-cangjie';
import { stubFalse } from 'lodash-es';
import RefBlock from "../../mo/models";
import { isSelectionInRefBlock, isSyncHetuNode } from "../../utils/logic";
import { getRefBlockMap } from "../../utils/value";
var MIME_TYPES = constants.MIME_TYPES;
export default function createOnPaste(config) {
  var _config$clipboard = config.clipboard,
      clipboard = _config$clipboard === void 0 ? {} : _config$clipboard,
      refblock = config.refblock;
  var _ref = refblock,
      generateCopyDoc = _ref.generateCopyDoc,
      _ref$disableNestedInR = _ref.disableNestedInRefBlock,
      disableNestedInRefBlock = _ref$disableNestedInR === void 0 ? stubFalse : _ref$disableNestedInR,
      getHetuWhenPaste = _ref.getHetuWhenPaste;
  return /*#__PURE__*/function () {
    var _onPaste = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(event, controller, next) {
      var clipboardData, fragment, packageJSON, hetuSyncNodes, refblocks, invalidNodes, refblockMap, deserialized, docKey, nodes, nextEvent;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              clipboardData = controller.query('getClipboardData', event);

              if (clipboardData) {
                _context2.next = 3;
                break;
              }

              return _context2.abrupt("return", next());

            case 3:
              if (clipboardData.hasData(MIME_TYPES.FRAGMENT)) {
                _context2.next = 5;
                break;
              }

              return _context2.abrupt("return", next());

            case 5:
              fragment = clipboardData.getFragment(false);
              packageJSON = clipboardData.getData(MIME_TYPES.REFBLOCK); // 粘贴到引用块时，剔除引用块和河图同步块

              if (!fragment) {
                _context2.next = 36;
                break;
              }

              if (!isSelectionInRefBlock(controller.value)) {
                _context2.next = 16;
                break;
              }

              // 剔除河图同步块
              hetuSyncNodes = []; // 剔除引用块

              refblocks = []; // 剔除包含有非法节点的块

              invalidNodes = [];
              fragment.forEachDescendant(function (descendant) {
                if (isSyncHetuNode(descendant)) {
                  hetuSyncNodes.push(descendant);
                } else if (RefBlock.isRefBlock(descendant)) {
                  refblocks.push(descendant);
                } else if (disableNestedInRefBlock(descendant, controller)) {
                  invalidNodes.push(descendant);
                }
              });
              [].concat(hetuSyncNodes, refblocks, invalidNodes).forEach(function (node) {
                fragment = fragment.removeNode(fragment.assertPath(node.key));
              });
              _context2.next = 34;
              break;

            case 16:
              refblockMap = getRefBlockMap(fragment); // 如果不含有引用块，提前退出

              if (Object.keys(refblockMap).length) {
                _context2.next = 19;
                break;
              }

              return _context2.abrupt("return", next());

            case 19:
              // 粘贴 fragment 中包含的引用块
              deserialized = false;
              _context2.t0 = _regeneratorRuntime.keys(refblockMap);

            case 21:
              if ((_context2.t1 = _context2.t0()).done) {
                _context2.next = 34;
                break;
              }

              docKey = _context2.t1.value;

              if (packageJSON && !deserialized) {
                deserialized = true;
                getHetuWhenPaste(packageJSON);
              }

              nodes = refblockMap[docKey].map(function (_ref2) {
                var nodeKey = _ref2.nodeKey;
                return fragment.assertNode(nodeKey);
              });
              _context2.prev = 25;
              return _context2.delegateYield( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
                var _yield$generateCopyDo, uuid;

                return _regeneratorRuntime.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _context.next = 2;
                        return generateCopyDoc(docKey);

                      case 2:
                        _yield$generateCopyDo = _context.sent;
                        uuid = _yield$generateCopyDo.uuid;
                        nodes.forEach(function (node) {
                          fragment = fragment.setNode(fragment.assertPath(node.key), {
                            data: _extends({}, node.data, {
                              refblockUUID: uuid
                            })
                          });
                        });

                      case 5:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              })(), "t2", 27);

            case 27:
              _context2.next = 32;
              break;

            case 29:
              _context2.prev = 29;
              _context2.t3 = _context2["catch"](25);
              // 如果对应 refblock 的 uuid 生成失败，则不粘贴这些节点
              nodes.forEach(function (node) {
                fragment = fragment.removeNode(fragment.assertPath(node.key));
              });

            case 32:
              _context2.next = 21;
              break;

            case 34:
              nextEvent = event.setClipboardData(event.clipboardData.setData(MIME_TYPES.FRAGMENT, transferUtils.encodeFragment(fragment))); // @ts-ignore

              return _context2.abrupt("return", next(nextEvent));

            case 36:
              return _context2.abrupt("return", next());

            case 37:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[25, 29]]);
    }));

    function onPaste(_x, _x2, _x3) {
      return _onPaste.apply(this, arguments);
    }

    return onPaste;
  }();
}
//# sourceMappingURL=createOnPaste.js.map