"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var React = _interopRequireWildcard(require("react"));

var _lodash = require("lodash");

var _models = require("../mo/models");

var _styled = require("./styled");

var _Forbidden = _interopRequireDefault(require("./Forbidden"));

var _Deleted = _interopRequireDefault(require("./Deleted"));

var _Invalid = _interopRequireDefault(require("./Invalid"));

var _Loading = _interopRequireDefault(require("./Loading"));

var _RefBlockToolbar = _interopRequireDefault(require("./RefBlockToolbar"));

var _styles = require("../utils/styles");

const _createElement = /*#__PURE__*/React.createElement;

const defaultGetUrl = url => url;

const RefBlock = props => {
  const {
    children,
    readOnly,
    locale,
    renderProps,
    toolbarAnimationDuration = 150,
    enableToolbar = _lodash.stubFalse,
    detach,
    getReferenceList,
    getDocKey,
    renderRefBlockInOtherStates,
    onRefBlockMounted,
    copyRefBlock,
    renderLoading,
    getURL = defaultGetUrl
  } = props;
  const {
    attributes
  } = renderProps;
  const {
    ref
  } = attributes;
  const node = renderProps.node;
  const {
    controller
  } = renderProps;
  const {
    selection,
    isBlurred
  } = controller.value;
  const {
    isCollapsed
  } = selection;
  const isFocused = props.isFocused && !isBlurred;
  const [toolbarVisible, setToolbarVisible] = React.useState(false);
  /**********************************\
  *                                  *
  *                      |           *
  *                    left          *
  *                      |           *
  *                      v           *
  * +--------------------+  <--top-- *
  * |      RefBlock      |           *
  * +--------------------+           *
  *                                  *
  \**********************************/

  const [toolbarAnchor, setToolbarAnchor] = React.useState({
    top: -100,
    left: -100
  });
  const wrapperRef = React.useRef(ref && ref.current);
  const {
    status = _models.RefBlockStatus.loading,
    isPageMode
  } = node.data;
  const docKey = node.data.docKey;
  const uuid = node.data.refblockUUID;
  const isHost = uuid === docKey;
  React.useLayoutEffect(() => {
    if (ref) {
      wrapperRef.current = ref.current;
    }
  }, [ref]);
  React.useEffect(() => {
    onRefBlockMounted && onRefBlockMounted(controller, node.key, uuid);
  }, [onRefBlockMounted, controller, node.key, uuid]);
  const handleToolbarHide = React.useMemo(() => (0, _lodash.debounce)(() => {
    setToolbarVisible(false);
  }, toolbarAnimationDuration), [toolbarAnimationDuration]);
  const handleToolbarShow = React.useCallback(() => {
    handleToolbarHide.cancel(); // 计算工具栏定位锚点

    const rect = wrapperRef.current.getBoundingClientRect();
    const left = rect.right;
    const top = rect.top - 42;
    setToolbarAnchor({
      top,
      left
    });
    setToolbarVisible(true);
  }, [handleToolbarHide]);
  React.useEffect(() => {
    return () => {
      handleToolbarHide.cancel();
    };
  }, [handleToolbarHide]);
  const handleCopy = React.useCallback(() => {
    copyRefBlock();
    setToolbarVisible(false);
  }, [copyRefBlock]);
  const handleMouseEnterToContent = React.useCallback(event => {
    // focus 时，鼠标进入到 content，隐藏工具栏
    event.preventDefault();
    event.stopPropagation();
    setToolbarVisible(false);
  }, []);
  React.useEffect(() => {
    // focus 时，隐藏工具栏
    if (isFocused) {
      setToolbarVisible(false);
    }
  }, [isFocused]);

  if (status === _models.RefBlockStatus.loading) {
    const loadingJSX = renderLoading?.(renderProps);
    return /*#__PURE__*/_createElement(_styled.RefBlockWrapper, (0, _extends2.default)({
      "data-dockey": docKey,
      "data-cangjie-not-editable": true,
      isHost: isHost,
      $loading: true
    }, attributes), loadingJSX || /*#__PURE__*/_createElement(_Loading.default, null, children));
  } else if (status === _models.RefBlockStatus.forbidden) {
    return /*#__PURE__*/_createElement(_Forbidden.default, {
      attributes: attributes
    }, locale.forbidden);
  } else if (status === _models.RefBlockStatus.deleted) {
    return /*#__PURE__*/_createElement(_Deleted.default, {
      attributes: attributes
    }, locale.deleted);
  } else if (status === _models.RefBlockStatus.invalid) {
    return /*#__PURE__*/_createElement(_Invalid.default, {
      attributes: attributes
    }, locale.deleted);
  } else if (status === _models.RefBlockStatus.normal || status === _models.RefBlockStatus.readOnly) {
    const read = status === _models.RefBlockStatus.readOnly || readOnly;
    /* istanbul ignore next */

    const wrapperStyle = isPageMode && status === _models.RefBlockStatus.readOnly ? {
      maxHeight: _styles.REFBLOCK_MAX_HEIGHT,
      overflow: 'scroll'
    } : {};
    return /*#__PURE__*/_createElement(_styled.RefBlockWrapper, (0, _extends2.default)({
      "data-testid": "refblock-container",
      "data-container-block": true,
      "data-focused": isFocused,
      ref: wrapperRef,
      isFocused: isFocused,
      isHost: isHost,
      style: wrapperStyle,
      onMouseLeave: handleToolbarHide,
      onMouseEnter: isFocused ? _lodash.noop : handleToolbarShow,
      onMouseMove: isFocused ? handleToolbarShow : _lodash.noop
    }, attributes), enableToolbar() && /*#__PURE__*/_createElement(_RefBlockToolbar.default, {
      locale: locale,
      readOnly: read,
      canCopy: status === _models.RefBlockStatus.normal,
      visible: toolbarVisible && isCollapsed,
      node: node,
      isHost: isHost,
      status: status,
      duration: toolbarAnimationDuration,
      anchor: toolbarAnchor,
      detach: detach,
      getReferenceList: getReferenceList,
      getDocKey: getDocKey,
      getURL: getURL,
      copy: handleCopy,
      onToolbarShow: handleToolbarShow,
      onToolbarHide: handleToolbarHide
    }), /*#__PURE__*/_createElement("div", {
      className: "refblock-content",
      "data-refblock-uuid": uuid,
      onMouseEnter: isFocused ? handleMouseEnterToContent : _lodash.noop
    }, children));
  } else {
    return /*#__PURE__*/_createElement("div", (0, _extends2.default)({}, attributes, {
      "data-testid": `refblock-other-states-${status}`
    }), renderRefBlockInOtherStates(renderProps, status));
  }
};

var _default = RefBlock;
exports.default = _default;
//# sourceMappingURL=RefBlock.js.map