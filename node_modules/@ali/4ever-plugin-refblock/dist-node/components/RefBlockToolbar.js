"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var React = _interopRequireWildcard(require("react"));

var _reactTransitionGroup = require("react-transition-group");

var _everCangjie = require("@ali/4ever-cangjie");

var _lodash = require("lodash");

var _styled = require("./styled");

var _RefBlockToolbarHost = _interopRequireDefault(require("./RefBlockToolbarHost"));

var _RefBlockToolbarCopy = _interopRequireDefault(require("./RefBlockToolbarCopy"));

var _ToolbarPortal = _interopRequireDefault(require("./ToolbarPortal"));

const _createElement = /*#__PURE__*/React.createElement;
const transitionStyles = {
  entering: {
    opacity: 0
  },
  entered: {
    opacity: 1
  },
  exiting: {
    opacity: 0
  },
  exited: {
    opacity: 0
  }
};

const RefBlockToolbar = props => {
  const {
    visible,
    locale,
    node,
    readOnly,
    status,
    isHost,
    duration,
    canCopy,
    anchor,
    detach,
    getDocKey,
    getReferenceList,
    copy,
    onToolbarShow,
    onToolbarHide,
    getURL
  } = props;
  const [list, setList] = React.useState([]);
  const [loading, setLoading] = React.useState(false);
  const [coords, setCoords] = React.useState(anchor);
  const wrapperRef = React.useRef(null);
  const container = (0, _everCangjie.useZoomContainer)() || document.body;
  const fetchList = React.useMemo(() => (0, _lodash.debounce)(getReferenceList, 1000, {
    leading: true
  }), [getReferenceList]);
  const {
    docKey,
    refblockUUID: uuid
  } = node.data;
  const currentDocKey = getDocKey();
  const copyFrom = list.find(item => item.uuid === docKey);
  React.useEffect(() => {
    // 展开的时候获得引用列表
    if (visible) {
      setLoading(true);
      fetchList(docKey)?.then(setList).catch(e => {
        console.error('fecth syncdocs failed', e);
      }).finally(() => {
        setLoading(false);
      });
    }
  }, [visible, docKey]); // 过滤当前文档，并按照宿主聚合

  const filteredList = React.useMemo(() => {
    return isHost ? list.filter(item => item.hostDocKey !== currentDocKey).sort((a, b) => {
      if (a.hostDocKey === b.hostDocKey) {
        return 0;
      }

      return a.hostDocKey < b.hostDocKey ? -1 : 1;
    }) : list;
  }, [list, currentDocKey, isHost]);
  const handleToolbarEnter = React.useCallback(() => {
    const containerRect = container.getBoundingClientRect();
    setCoords({
      left: anchor.left - containerRect.left - wrapperRef.current.getBoundingClientRect().width,
      top: anchor.top - containerRect.top
    });
  }, [anchor, container]);

  var _ref = /*#__PURE__*/_createElement(_RefBlockToolbarHost.default, {
    list: filteredList,
    locale: locale,
    loading: loading,
    status: status,
    wrapperVisible: visible,
    canCopy: canCopy,
    copy: copy,
    getURL: getURL
  });

  return /*#__PURE__*/_createElement(_reactTransitionGroup.Transition, {
    in: visible,
    timeout: {
      appear: 0,
      enter: duration,
      exit: duration
    },
    onEnter: handleToolbarEnter,
    unmountOnExit: true
  }, state => /*#__PURE__*/_createElement(_ToolbarPortal.default, {
    container: container
  }, /*#__PURE__*/_createElement(_styled.ToolbarWrapper, {
    "data-testid": "refblock-toolbar-wrapper",
    ref: wrapperRef,
    onMouseEnter: onToolbarShow,
    onMouseLeave: onToolbarHide,
    style: { ...transitionStyles[state],
      ...coords
    },
    duration: duration
  }, /*#__PURE__*/_createElement(_styled.Toolbar, null, isHost ? _ref : /*#__PURE__*/_createElement(_RefBlockToolbarCopy.default, {
    from: copyFrom,
    locale: locale,
    status: status,
    docKey: docKey,
    uuid: uuid,
    readOnly: readOnly,
    canCopy: canCopy,
    detach: detach,
    copy: copy,
    getURL: getURL
  })))));
};

var _default = /*#__PURE__*/React.memo(RefBlockToolbar);

exports.default = _default;
//# sourceMappingURL=RefBlockToolbar.js.map