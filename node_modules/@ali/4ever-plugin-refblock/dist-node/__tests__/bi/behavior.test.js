"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _everDevTest = require("@ali/4ever-dev-test");

var _everCangjie = require("@ali/4ever-cangjie");

var _everSetup = require("@ali/4ever-setup");

var _everBi = require("@ali/4ever-bi");

var _everPluginHeading = require("@ali/4ever-plugin-heading");

var _everPluginRefblock = require("@ali/4ever-plugin-refblock");

var _everPluginCard = require("@ali/4ever-plugin-card");

var _lodash = require("lodash");

var _models = require("../../mo/models");

var _queries = require("../../bi/queries");

var _bi = _interopRequireDefault(require("../../bi"));

/** @jsx jsx */
let mockedClipboard = {};
jest.mock('@ali/clipboard-manager', () => {
  return jest.fn().mockImplementation(() => {
    return {
      write: data => {
        mockedClipboard = data;
      }
    };
  });
});
const {
  MIME_TYPES
} = _everCangjie.constants;
const {
  encodeFragment
} = _everCangjie.transferUtils;
const plgs = (0, _everSetup.createCustomMoPlugins)({
  factories: [_everPluginCard.moFactory, _everPluginHeading.moFactory, _everPluginRefblock.moFactory]
});
const serializer = (0, _everCangjie.createSerializer)(plgs);
const DEFAULT_VALUE = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("cursor", null))));

const VoidPlugin = () => ({
  schema: {
    blocks: {
      void: {
        isVoid: true
      }
    }
  }
});

const CodePlugin = () => ({
  queries: {
    shouldSelectAll: controller => {
      const {
        selection,
        document
      } = controller.value;
      const {
        focus
      } = selection;
      const code = document.getClosest(focus.key, node => _everCangjie.Block.isBlock(node) && node.type === 'code');
      return code ? true : undefined;
    }
  }
});

const PasteTesterPlugin = config => {
  const {
    onCangjiePaste = _lodash.noop
  } = config.pasteTester || {};
  return {
    onCangjiePaste: (event, controller, next) => {
      onCangjiePaste(event);
      return next();
    }
  };
};

function createController(value, config, options) {
  const {
    refblock = {},
    clipboard,
    pasteTester
  } = config || {};
  const plugins = [(0, _everBi.DraggablePlugin)({}), PasteTesterPlugin({
    pasteTester: {
      onCangjiePaste: _lodash.noop,
      ...pasteTester
    }
  }), ...(0, _everSetup.createCustomBiPlugins)({
    factories: [_bi.default],
    locales: {},
    configs: {
      clipboard: {
        serializer,
        ...clipboard
      },
      refblock: {
        locale: {
          nestedNotSupported: '不支持嵌套的引用块',
          createFailed: '创建引用块失败',
          referFromTitle: '引用源',
          detach: '解除引用关系',
          detachFailed: '解除引用关系失败',
          detachSuccess: '解除引用关系成功',
          deleted: '引用块已删除',
          forbidden: '无权限',
          invalid: '无效',
          referenceListTitle: '被[n]篇文档引用了[m]次',
          copySuccess: '拷贝成功',
          cannotMoveTo: '无法移动到',
          cannotDropTo: '无法粘贴到',
          copy: '复制',
          showRefs: '查看引用关系',
          creating: '创建中',
          noRefers: '暂未被其他文档引用'
        },
        decorateRefBlockFragment: fragment => fragment,
        getDocKey: () => 'host',
        renderReadOnly: () => null,
        generateDoc: () => Promise.resolve().then(() => ({
          docKey: 'doc-a',
          uuid: 'doc-a'
        })),
        generateCopyDoc: docKey => {
          return Promise.resolve().then(() => ({
            uuid: 'abc',
            docKey
          }));
        },
        getReferenceList: () => Promise.resolve().then(() => []),
        detach: () => Promise.resolve().then(),
        renderRefBlockInOtherStates: () => null,
        onRefBlockMounted: () => {},
        cacheHetuWhenCopy: () => '',
        getHetuWhenPaste: () => {},
        getRefBlockURL: id => id,
        getDocURL: url => url,
        ...refblock
      }
    }
  }), (0, _everPluginCard.moFactory)({}), (0, _everPluginHeading.moFactory)({}), VoidPlugin(), CodePlugin()];
  return _everCangjie.Controller.create({
    plugins,
    value: value || DEFAULT_VALUE,
    autoFocus: true
  }, {
    normalize: false,
    ...options
  });
}

var _ref = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("text", null));

var _ref2 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("text", null));

var _ref3 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello"), (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World"), (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Cangjie", (0, _everDevTest.jsx)("cursor", null))));

var _ref4 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref5 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World");

var _ref6 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Cangjie");

var _ref7 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello"), (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World"), (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Cangjie", (0, _everDevTest.jsx)("cursor", null))));

var _ref8 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref9 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World");

var _ref10 = (0, _everDevTest.jsx)("block", {
  key: "disabled",
  type: "paragraph"
}, "Hello");

var _ref11 = (0, _everDevTest.jsx)("block", {
  key: "enabled",
  type: "paragraph"
}, "World");

var _ref12 = (0, _everDevTest.jsx)("block", {
  key: "normal",
  type: "paragraph"
}, "Cangjie");

var _ref13 = (0, _everDevTest.jsx)("block", {
  key: "p-in-refblock",
  type: "paragraph"
}, "Hello");

var _ref14 = (0, _everDevTest.jsx)("block", {
  key: "table",
  type: "table"
}, "World");

var _ref15 = (0, _everDevTest.jsx)("block", {
  key: "nested-table",
  type: "paragraph"
}, (0, _everDevTest.jsx)("block", {
  type: "table"
}, "World"));

var _ref16 = (0, _everDevTest.jsx)("block", {
  key: "p-in-refblock",
  type: "paragraph"
}, "Hello");

var _ref17 = (0, _everDevTest.jsx)("block", {
  key: "template-button",
  type: "template-button"
}, "TemplateButton");

var _ref18 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  key: "table",
  type: "table"
}, "World")));

var _ref19 = (0, _everDevTest.jsx)("block", {
  key: "p-in-refblock",
  type: "paragraph"
}, "Hello");

var _ref20 = (0, _everDevTest.jsx)("block", {
  key: "table",
  type: "table"
}, "World");

var _ref21 = (0, _everDevTest.jsx)("block", {
  key: "nested-table",
  type: "paragraph"
}, (0, _everDevTest.jsx)("block", {
  type: "table"
}, "World"));

var _ref22 = (0, _everDevTest.jsx)("block", {
  key: "p-in-refblock",
  type: "paragraph"
}, "Hello");

var _ref23 = (0, _everDevTest.jsx)("block", {
  key: "disabled",
  type: "paragraph"
}, "Hello");

var _ref24 = (0, _everDevTest.jsx)("block", {
  key: "enabled",
  type: "paragraph"
}, "World");

var _ref25 = (0, _everDevTest.jsx)("block", {
  key: "enabled",
  type: "paragraph"
}, "World");

var _ref26 = (0, _everDevTest.jsx)("block", {
  key: "disabled",
  type: "paragraph"
}, "Hello");

var _ref27 = (0, _everDevTest.jsx)("block", {
  key: "enabled",
  type: "paragraph"
}, "World");

var _ref28 = (0, _everDevTest.jsx)("block", {
  key: "enabled",
  type: "paragraph"
}, "World");

var _ref29 = (0, _everDevTest.jsx)("block", {
  key: "disabled",
  type: "paragraph"
}, "Hello");

var _ref30 = (0, _everDevTest.jsx)("block", {
  key: "enabled",
  type: "paragraph"
}, "World");

var _ref31 = (0, _everDevTest.jsx)("block", {
  key: "disabled",
  type: "paragraph"
}, "Hello");

var _ref32 = (0, _everDevTest.jsx)("block", {
  key: "enabled",
  type: "paragraph"
}, "World");

var _ref33 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello"), (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World"), (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Cangjie")));

var _ref34 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref35 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World");

var _ref36 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Cangjie");

var _ref37 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("text", null));

var _ref38 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("text", null));

var _ref39 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref40 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref41 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello"), (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello")));

var _ref42 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref43 = (0, _everDevTest.jsx)("block", {
  key: "normal",
  type: "paragraph"
}, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World"));

var _ref44 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello"), (0, _everDevTest.jsx)("block", {
  key: "normal",
  type: "paragraph"
}, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World"))));

var _ref45 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("cursor", null))));

var _ref46 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref47 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Cangjie");

var _ref48 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World");

var _ref49 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref50 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Cangjie");

var _ref51 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World");

var _ref52 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("cursor", null))));

var _ref53 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("cursor", null))));

var _ref54 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("text", null));

var _ref55 = (0, _everDevTest.jsx)("block", {
  type: "void"
}, (0, _everDevTest.jsx)("text", null));

var _ref56 = (0, _everDevTest.jsx)("block", {
  type: "void"
}, (0, _everDevTest.jsx)("text", null));

var _ref57 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("cursor", null))));

var _ref58 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref59 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Cangjie");

var _ref60 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Slate");

var _ref61 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World");

var _ref62 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref63 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Cangjie");

var _ref64 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Slate");

var _ref65 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World");

var _ref66 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("cursor", null))));

var _ref67 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref68 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Cangjie");

var _ref69 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Slate");

var _ref70 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World");

var _ref71 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref72 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Cangjie");

var _ref73 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Slate");

var _ref74 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World");

var _ref75 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("cursor", null))));

var _ref76 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref77 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Cangjie");

var _ref78 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World");

var _ref79 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref80 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Cangjie");

var _ref81 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Slate");

var _ref82 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World");

var _ref83 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello", (0, _everDevTest.jsx)("cursor", null))));

var _ref84 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "HelloWorld")));

var _ref85 = (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World"));

var _ref86 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello", (0, _everDevTest.jsx)("cursor", null));

var _ref87 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "HelloWorld");

var _ref88 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Nested RefBlock");

var _ref89 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "not-supported");

var _ref90 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World");

var _ref91 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("text", null), (0, _everDevTest.jsx)("cursor", null))));

var _ref92 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "hello-world", (0, _everDevTest.jsx)("cursor", null))));

var _ref93 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("anchor", null), "Hello"), (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World", (0, _everDevTest.jsx)("focus", null)), (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Cangjie")));

var _ref94 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref95 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World");

var _ref96 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Cangjie");

var _ref97 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("anchor", null), "Hello"), (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World", (0, _everDevTest.jsx)("focus", null)), (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Cangjie")));

var _ref98 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref99 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World");

var _ref100 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Cangjie");

var _ref101 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("anchor", null), "Hello"), (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World", (0, _everDevTest.jsx)("focus", null)), (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Cangjie")));

var _ref102 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("anchor", null), "Hello"), (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World", (0, _everDevTest.jsx)("focus", null)), (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Cangjie")));

var _ref103 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("anchor", null), "Hello", (0, _everDevTest.jsx)("focus", null)), (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World"), (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Cangjie")));

var _ref104 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref105 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World");

var _ref106 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Cangjie");

var _ref107 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello"), (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World"), (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Cangjie")));

var _ref108 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref109 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World!");

var _ref110 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Cangjie");

var _ref111 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref112 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref113 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("text", null));

var _ref114 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("text", null));

var _ref115 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hel", (0, _everDevTest.jsx)("anchor", null), "lo");

var _ref116 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Worl", (0, _everDevTest.jsx)("focus", null), "d");

var _ref117 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("anchor", null), "Hello");

var _ref118 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World", (0, _everDevTest.jsx)("focus", null));

var _ref119 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hel", (0, _everDevTest.jsx)("anchor", null), "lo");

var _ref120 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Worl", (0, _everDevTest.jsx)("focus", null), "d");

var _ref121 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("anchor", null), "Hello", (0, _everDevTest.jsx)("focus", null));

var _ref122 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "World");

var _ref123 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hell", (0, _everDevTest.jsx)("anchor", null), "o");

var _ref124 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Wor", (0, _everDevTest.jsx)("focus", null), "ld");

var _ref125 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hello");

var _ref126 = (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, (0, _everDevTest.jsx)("anchor", null), "World", (0, _everDevTest.jsx)("focus", null));

var _ref127 = (0, _everDevTest.jsx)("block", {
  type: "code"
}, "Wor", (0, _everDevTest.jsx)("cursor", null), "ld");

var _ref128 = (0, _everDevTest.jsx)("block", {
  type: "code"
}, "Wor", (0, _everDevTest.jsx)("cursor", null), "ld");

var _ref129 = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Hel", (0, _everDevTest.jsx)("anchor", null), "lo"), (0, _everDevTest.jsx)("block", {
  type: "paragraph"
}, "Worl", (0, _everDevTest.jsx)("focus", null), "d")));

describe('Bi/refblock/behaviour', () => {
  beforeEach(() => {
    mockedClipboard = {};
  });
  describe('commands', () => {
    test('#insertRefBlock', () => {
      // 插入引用块时，默认为其插入空段落
      const controller = createController();
      const {
        value
      } = controller.command('insertRefBlock', {
        docKey: 'doc-a'
      });
      const expected = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      }, _ref), _ref2));
      expect(expected.toJSON()).toEqual(value.toJSON());
    });
    test('#setRefBlockInjectionByKey', () => {
      const controller = createController((0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("injection", {
        data: {
          a: 1,
          status: _models.RefBlockStatus.loading
        }
      }, (0, _everDevTest.jsx)("block", {
        key: "refblock",
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      })))));
      const expected = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("injection", {
        data: {
          a: 1,
          status: _models.RefBlockStatus.normal
        }
      }, (0, _everDevTest.jsx)("block", {
        key: "refblock",
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      }))));
      const {
        value
      } = controller.command('setRefBlockInjectionByKey', 'refblock', {
        status: _models.RefBlockStatus.normal
      });
      expect(value.toJSON({
        preserveInjections: true
      })).toEqual(expected.toJSON({
        preserveInjections: true
      }));
    });
    test('#setRefBlockInjectionByKey: terminate if node is not exists', () => {
      const controller = createController((0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        key: "paragraph",
        type: "paragraph",
        data: {
          docKey: 'doc-a'
        }
      }))));
      const {
        value
      } = controller.command('setRefBlockInjectionByKey', 'not-exist-paragraph', {
        status: _models.RefBlockStatus.normal
      });
      expect(value.injections).toEqual([]);
    });
    test('#setRefBlockInjectionByKey: terminate if node is not a refblock', () => {
      const controller = createController((0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        key: "paragraph",
        type: "paragraph",
        data: {
          docKey: 'doc-a'
        }
      }))));
      const {
        value
      } = controller.command('setRefBlockInjectionByKey', 'paragraph', {
        status: _models.RefBlockStatus.normal
      });
      expect(value.injections).toEqual([]);
    });
    test('#setRefBlockInjectionByDocKey', () => {
      const controller = createController((0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("injection", {
        data: {
          a: 1,
          status: _models.RefBlockStatus.loading
        }
      }, (0, _everDevTest.jsx)("block", {
        key: "refblock1",
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      })), (0, _everDevTest.jsx)("injection", {
        data: {
          a: 1,
          status: _models.RefBlockStatus.loading
        }
      }, (0, _everDevTest.jsx)("block", {
        key: "refblock2",
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      })))));
      const expected = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("injection", {
        data: {
          a: 1,
          status: _models.RefBlockStatus.normal
        }
      }, (0, _everDevTest.jsx)("block", {
        key: "refblock1",
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      })), (0, _everDevTest.jsx)("injection", {
        data: {
          a: 1,
          status: _models.RefBlockStatus.normal
        }
      }, (0, _everDevTest.jsx)("block", {
        key: "refblock2",
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      }))));
      const {
        value
      } = controller.command('setRefBlockInjectionByDocKey', 'doc-a', {
        status: _models.RefBlockStatus.normal
      });
      expect(value.toJSON({
        preserveInjections: true
      })).toEqual(expected.toJSON({
        preserveInjections: true
      }));
    });
    test('#upgradeToRefBlock', () => {
      const controller = createController(_ref3);
      const expected = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a'
        },
        cursor: "after"
      }, _ref4, _ref5), _ref6));
      const blocks = controller.value.document.nodes.slice(0, 2);
      const {
        value
      } = controller.command('upgradeToRefBlock', blocks, {
        docKey: 'doc-a'
      });
      expect(value.toJSON()).toEqual(expected.toJSON());
      const refblock = value.document.assertNodeByPath([0]);

      const edge = _everCangjie.EdgePoint.create({
        key: refblock.key,
        edge: 'after'
      });

      expect(value.selection).toEqual(_everCangjie.Selection.create({
        anchor: edge,
        focus: edge
      }));
      expect(value.injections).toEqual([_everCangjie.Injection.create({
        key: refblock.key,
        data: {
          status: _models.RefBlockStatus.loading
        }
      })]);
    });
    test('#upgradeToRefBlock, blocks is empty', () => {
      const value = _ref7;
      const controller = createController(value);
      const blocks = [];
      controller.command('upgradeToRefBlock', blocks, {
        docKey: 'doc-a'
      });
      expect(value.toJSON()).toEqual(controller.value.toJSON());
    });
  });
  describe('queries', () => {
    const disableDrop = (0, _queries.createDisableDrop)('无法移动到引用块', '无法将引用块移动到此内容', (controller, node) => _everCangjie.Block.isBlock(node) && node.type === 'table', dropBlock => dropBlock.type === 'template-button');
    test('#disableDrag', () => {
      // 如果 drag 的内容存在于只读引用块，则不允许 drag
      const controller = createController((0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("injection", {
        data: {
          status: _models.RefBlockStatus.readOnly
        }
      }, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      }, _ref8)), (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      }, _ref9))));
      const disabled = controller.value.document.assertNodeByPath([0, 0]);
      const enabled = controller.value.document.assertNodeByPath([1, 0]);
      expect(controller.query('disableDrag', disabled)).toBe(true);
      expect(controller.query('disableDrag', enabled)).toBe(false);
    });
    test('#disableDrop: disable drop at readonly refblock', () => {
      // 如果 drop 块是只读引用块，则不允许 drop
      const controller = createController((0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("injection", {
        data: {
          status: _models.RefBlockStatus.readOnly
        }
      }, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      }, _ref10)), (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      }, _ref11), _ref12)));
      const {
        document
      } = controller.value;
      const dragBlock = document.assertNode('normal');
      const disabled = document.assertNode('disabled');
      const enabled = document.assertNode('enabled');
      expect(controller.query(disableDrop, dragBlock, disabled)).toBe(true);
      expect(controller.query(disableDrop, dragBlock, enabled)).toBe(false);
    });
    test('#disableDrop: customized disable move-to', () => {
      // 禁止拖拽引用块到引用块
      const controller = createController((0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("injection", {
        data: {
          status: _models.RefBlockStatus.readOnly
        }
      }, (0, _everDevTest.jsx)("block", {
        key: "refblock",
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      }, _ref13)), _ref14, _ref15)));
      const {
        document
      } = controller.value;
      const tableBlock = document.assertNode('table');
      const nestedTableBlock = document.assertNode('nested-table');
      const dropBlock = document.assertNode('p-in-refblock');
      expect(controller.query(disableDrop, tableBlock, dropBlock)).toBe(true);
      expect(controller.query(disableDrop, nestedTableBlock, dropBlock)).toBe(true);
    });
    test('#disableDrop: customize disable drop-to', () => {
      const controller = createController((0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        key: "refblock",
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      }, _ref16), (0, _everDevTest.jsx)("block", {
        type: "paragraph",
        key: "p-nested-refblock"
      }, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-b'
        }
      }, "World")), _ref17)));
      const {
        document
      } = controller.value;
      const refBlock = document.assertNode('refblock');
      const pNestedRefBlock = document.assertNode('p-nested-refblock');
      const dropBlock = document.assertNode('template-button');
      expect(controller.query(disableDrop, refBlock, dropBlock)).toBe(true);
      expect(controller.query(disableDrop, pNestedRefBlock, dropBlock)).toBe(true);
    });
    test('#disableNodeInRefBlock', () => {
      const disableNodeInRefBlock = (0, _queries.createDisableNodeInRefBlock)(node => _everCangjie.Block.isBlock(node) && node.type === 'table'); // 禁止拖拽引用块到引用块

      const controller = createController(_ref18);
      const {
        document
      } = controller.value;
      const table = document.assertNode('table');
      expect(controller.query(disableNodeInRefBlock, table)).toBe(true);
    });
    test('#isContainer', () => {
      const controller = createController((0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("injection", {
        data: {
          status: _models.RefBlockStatus.readOnly
        }
      }, (0, _everDevTest.jsx)("block", {
        key: "refblock",
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      }, _ref19)), _ref20, _ref21)));
      const {
        document
      } = controller.value;
      const refblock = document.getNode('refblock');
      const table = document.getNode('table');
      expect(controller.query('isContainer', table)).toBeNull();
      expect(controller.query('isContainer', refblock)).toBeNull();
      expect(controller.query('isContainer', _everCangjie.Document.create({
        nodes: [refblock]
      }))).toBe(true);
    });
    test('#anchor', () => {
      const controller = createController((0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        key: "refblock",
        type: "refblock",
        data: {
          docKey: 'doc-a',
          refblockUUID: 'doc-a-uuid'
        }
      }, _ref22))), {}, {
        uuid: {
          enable: true,
          gen: _lodash.uniqueId
        }
      });
      const {
        document
      } = controller.value;
      const refblock = document.assertNode('refblock');
      expect(controller.query('anchor', refblock)).toBe('doc-a-uuid');
    });
  });
  describe('actions', () => {
    test('#setRefBlockInjectionByDocKey', () => {
      const controller = createController((0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("injection", {
        data: {
          status: _models.RefBlockStatus.loading,
          a: 1
        }
      }, (0, _everDevTest.jsx)("block", {
        key: "refblock1",
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      }, _ref23)), (0, _everDevTest.jsx)("block", {
        key: "refblock2",
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      }, _ref24), (0, _everDevTest.jsx)("injection", {
        data: {
          status: _models.RefBlockStatus.loading,
          a: 1
        }
      }, (0, _everDevTest.jsx)("block", {
        key: "refblock3",
        type: "refblock",
        data: {
          docKey: 'doc-b'
        }
      }, _ref25)))));
      const expected = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("injection", {
        data: {
          status: _models.RefBlockStatus.readOnly,
          a: 1
        }
      }, (0, _everDevTest.jsx)("block", {
        key: "refblock1",
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      }, _ref26)), (0, _everDevTest.jsx)("injection", {
        data: {
          status: _models.RefBlockStatus.readOnly
        }
      }, (0, _everDevTest.jsx)("block", {
        key: "refblock2",
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      }, _ref27)), (0, _everDevTest.jsx)("injection", {
        data: {
          status: _models.RefBlockStatus.loading,
          a: 1
        }
      }, (0, _everDevTest.jsx)("block", {
        key: "refblock3",
        type: "refblock",
        data: {
          docKey: 'doc-b'
        }
      }, _ref28))));
      controller.dispatch('setRefBlockInjectionByDocKey', 'doc-a', {
        status: _models.RefBlockStatus.readOnly
      });
      controller.dispatch('setRefBlockInjectionByDocKey', 'doc-b', {
        status: _models.RefBlockStatus.normal
      }, false);
      expect(controller.value.toJSON()).toEqual(expected.toJSON());
    });
    test('#setRefBlockInjectionByKey', () => {
      const controller = createController((0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("injection", {
        data: {
          status: _models.RefBlockStatus.loading,
          a: 1
        }
      }, (0, _everDevTest.jsx)("block", {
        key: "refblock1",
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      }, _ref29)), (0, _everDevTest.jsx)("injection", {
        data: {
          status: _models.RefBlockStatus.loading,
          a: 1
        }
      }, (0, _everDevTest.jsx)("block", {
        key: "refblock2",
        type: "refblock",
        data: {
          docKey: 'doc-b'
        }
      }, _ref30)))));
      const expected = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("injection", {
        data: {
          status: _models.RefBlockStatus.readOnly,
          a: 1
        }
      }, (0, _everDevTest.jsx)("block", {
        key: "refblock1",
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      }, _ref31)), (0, _everDevTest.jsx)("injection", {
        data: {
          status: _models.RefBlockStatus.loading,
          a: 1
        }
      }, (0, _everDevTest.jsx)("block", {
        key: "refblock2",
        type: "refblock",
        data: {
          docKey: 'doc-b'
        }
      }, _ref32))));
      controller.dispatch('setRefBlockInjectionByKey', 'refblock1', {
        status: _models.RefBlockStatus.readOnly
      });
      controller.dispatch('setRefBlockInjectionByKey', 'refblock2', {
        status: _models.RefBlockStatus.normal
      }, false);
      expect(controller.value.toJSON()).toEqual(expected.toJSON());
    });
    test('#upgradeToRefBlock', () => {
      const controller = createController(_ref33);
      const expected = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a',
          refblockUUID: 'doc-a',
          uuid: 'doc-a'
        }
      }, _ref34, _ref35), _ref36));
      const blocks = controller.value.document.nodes.slice(0, 2);
      controller.dispatch('upgradeToRefBlock', 'doc-a', 'doc-a', blocks);
      const {
        value
      } = controller;
      expect(value.toJSON()).toEqual(expected.toJSON());
      const refblock = value.document.assertNodeByPath([0]);
      expect(value.injections).toEqual([_everCangjie.Injection.create({
        key: refblock.key,
        data: {
          status: _models.RefBlockStatus.loading
        }
      })]);
    });
    test('#insertRefBlock', () => {
      // 插入引用块时，默认为其插入空段落
      const controller = createController();
      controller.dispatch('insertRefBlock', {
        docKey: 'doc-a'
      });
      const {
        value
      } = controller;
      const expected = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      }, _ref37), _ref38));
      expect(expected.toJSON()).toEqual(value.toJSON());
    });
    test('#donwgradeToBlocksByDocKey', () => {
      const controller = createController((0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      }, _ref39), (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      }, _ref40))));
      const expected = _ref41;
      controller.dispatch('downgradeToBlocksByDocKey', 'doc-a');
      expect(controller.value.toJSON()).toEqual(expected.toJSON());
    });
    test('#downgradeToBlocksByKey', () => {
      const controller = createController((0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        key: "refblock1",
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      }, _ref42), _ref43)));
      const expected = _ref44;
      controller.dispatch('downgradeToBlocksByKey', 'refblock1'); // 忽略对于非引用块的处理

      controller.dispatch('downgradeToBlocksByKey', 'normal');
      expect(controller.value.toJSON()).toEqual(expected.toJSON());
    });
  });
  describe('handlers', () => {
    test('#onPaste: paste refblock', async () => {
      const controller = createController(_ref45);
      const expected = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, _ref46, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a',
          hostKey: 'doc-b',
          refblockUUID: 'abc'
        }
      }, _ref47), _ref48));
      const fragment = (0, _everDevTest.jsx)("document", null, _ref49, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a',
          hostKey: 'doc-b'
        }
      }, _ref50), _ref51); // 剪贴板写入 DocKey，则需要插入 refblock

      const clipboardData = {
        [MIME_TYPES.FRAGMENT]: encodeFragment(fragment)
      };
      const event = (0, _everCangjie.CangjieClipboardEvent)('cangjiePaste', {
        clipboardData: {
          items: [// @ts-ignore
          {
            type: MIME_TYPES.FRAGMENT
          }],
          types: [MIME_TYPES.FRAGMENT],
          data: clipboardData,
          getData: format => {
            return clipboardData[format];
          }
        }
      });
      controller.run('onCangjiePaste', event); // 等待引用关系生成

      await (0, _everDevTest.waitForTime)(50);
      const {
        value
      } = controller; // 检查引用块是否插入

      expect(value.toJSON()).toEqual(expected.toJSON()); // 检查插入后是否加载中

      const refblock = value.document.assertNodeByPath([1]);
      expect(value.injections).toEqual([_everCangjie.Injection.create({
        key: refblock.key,
        data: {
          status: _models.RefBlockStatus.loading
        }
      })]);
    });
    test('#onPaste: ignore pasting if fragment is nil', async () => {
      const value = _ref52;
      const controller = createController(value);
      const clipboardData = {
        [MIME_TYPES.FRAGMENT]: ''
      };
      const event = (0, _everCangjie.CangjieClipboardEvent)('cangjiePaste', {
        clipboardData: {
          items: [// @ts-ignore
          {
            type: MIME_TYPES.FRAGMENT
          }],
          types: [MIME_TYPES.FRAGMENT],
          data: clipboardData,
          getData: format => {
            return clipboardData[format];
          }
        }
      });
      controller.run('onCangjiePaste', event); // 等待引用关系生成

      await (0, _everDevTest.waitForTime)(50); // 检查引用块是否插入

      expect(value).toEqual(controller.value);
    });
    test('#onPaste: paste refblock, only contains a void block', async () => {
      const controller = createController(_ref53);
      const expected = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, _ref54, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a',
          hostKey: 'doc-b',
          refblockUUID: 'abc'
        }
      }, _ref55)));
      const fragment = (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a',
          hostKey: 'doc-b'
        }
      }, _ref56)); // 剪贴板写入 DocKey，则需要插入 refblock

      const clipboardData = {
        [MIME_TYPES.FRAGMENT]: encodeFragment(fragment)
      };
      const event = (0, _everCangjie.CangjieClipboardEvent)('cangjiePaste', {
        clipboardData: {
          items: [// @ts-ignore
          {
            type: MIME_TYPES.FRAGMENT
          }],
          types: [MIME_TYPES.FRAGMENT],
          data: clipboardData,
          getData: format => {
            return clipboardData[format];
          }
        }
      });
      controller.run('onCangjiePaste', event); // 等待引用关系生成

      await (0, _everDevTest.waitForTime)(50);
      const {
        value
      } = controller; // 检查引用块是否插入

      expect(value.toJSON()).toEqual(expected.toJSON()); // 检查插入后是否加载中

      const refblock = value.document.assertNodeByPath([1]);
      expect(value.injections).toEqual([_everCangjie.Injection.create({
        key: refblock.key,
        data: {
          status: _models.RefBlockStatus.loading
        }
      })]);
    });
    test('#onPaste: paste multiple refblocks', async () => {
      const controller = createController(_ref57);
      const expected = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, _ref58, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a',
          refblockUUID: 'abc'
        }
      }, _ref59), (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-c',
          hostDocKey: 'doc-b',
          refblockUUID: 'abc'
        }
      }, _ref60), _ref61));
      const fragment = (0, _everDevTest.jsx)("document", null, _ref62, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      }, _ref63), (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-c',
          hostDocKey: 'doc-b'
        }
      }, _ref64), _ref65); // 剪贴板写入 DocKey，则需要插入 refblock

      const clipboardData = {
        [MIME_TYPES.FRAGMENT]: encodeFragment(fragment)
      };
      const event = (0, _everCangjie.CangjieClipboardEvent)('cangjiePaste', {
        clipboardData: {
          items: [// @ts-ignore
          {
            type: MIME_TYPES.FRAGMENT
          }],
          types: [MIME_TYPES.FRAGMENT],
          data: clipboardData,
          getData: format => {
            return clipboardData[format];
          }
        }
      });
      controller.run('onCangjiePaste', event);
      await (0, _everDevTest.waitForTime)(10);
      const {
        value
      } = controller; // 检查引用块是否插入

      expect(value.toJSON()).toEqual(expected.toJSON()); // 检查插入后是否加载中

      const docA = value.document.assertNodeByPath([1]);
      const docC = value.document.assertNodeByPath([2]);
      expect(value.injections).toEqual([_everCangjie.Injection.create({
        key: docA.key,
        data: {
          status: _models.RefBlockStatus.loading
        }
      }), _everCangjie.Injection.create({
        key: docC.key,
        data: {
          status: _models.RefBlockStatus.loading
        }
      })]);
    });
    test('#onPaste: paste refblocks, customized pakcage cacher', async () => {
      const getHetuWhenPaste = jest.fn();
      const controller = createController(_ref66, {
        // @ts-ignore
        refblock: {
          getHetuWhenPaste
        }
      });
      const expected = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, _ref67, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a',
          refblockUUID: 'abc'
        }
      }, _ref68), (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-c',
          hostDocKey: 'doc-b',
          refblockUUID: 'abc'
        }
      }, _ref69), _ref70));
      const fragment = (0, _everDevTest.jsx)("document", null, _ref71, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      }, _ref72), (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-c',
          hostDocKey: 'doc-b'
        }
      }, _ref73), _ref74); // 剪贴板写入 DocKey，则需要插入 refblock

      const clipboardData = {
        [MIME_TYPES.FRAGMENT]: encodeFragment(fragment),
        [MIME_TYPES.REFBLOCK]: 'package'
      };
      const event = (0, _everCangjie.CangjieClipboardEvent)('cangjiePaste', {
        clipboardData: {
          items: [// @ts-ignore
          {
            type: MIME_TYPES.FRAGMENT
          }, // @ts-ignore
          {
            type: MIME_TYPES.REFBLOCK
          }],
          types: [MIME_TYPES.FRAGMENT, MIME_TYPES.REFBLOCK],
          data: clipboardData,
          getData: format => {
            return clipboardData[format];
          }
        }
      });
      controller.run('onCangjiePaste', event);
      await (0, _everDevTest.waitForTime)(10);
      const {
        value
      } = controller; // 检查引用块是否插入

      expect(value.toJSON()).toEqual(expected.toJSON()); // 检查插入后是否加载中

      const docA = value.document.assertNodeByPath([1]);
      const docC = value.document.assertNodeByPath([2]);
      expect(value.injections).toEqual([_everCangjie.Injection.create({
        key: docA.key,
        data: {
          status: _models.RefBlockStatus.loading
        }
      }), _everCangjie.Injection.create({
        key: docC.key,
        data: {
          status: _models.RefBlockStatus.loading
        }
      })]);
      expect(getHetuWhenPaste).toBeCalledWith('package');
      expect(getHetuWhenPaste).toBeCalledTimes(1);
    });
    test('#onPaste: remove refblock which generate copy failed', async () => {
      const controller = createController(_ref75, {
        // @ts-ignore
        refblock: {
          generateCopyDoc: docKey => {
            if (docKey === 'doc-c') {
              return Promise.reject();
            } else {
              return Promise.resolve({
                docKey,
                uuid: 'abc'
              });
            }
          }
        }
      });
      const expected = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, _ref76, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a',
          refblockUUID: 'abc'
        }
      }, _ref77), _ref78));
      const fragment = (0, _everDevTest.jsx)("document", null, _ref79, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      }, _ref80), (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-c',
          hostDocKey: 'doc-b'
        }
      }, _ref81), _ref82);
      const clipboardData = {
        [MIME_TYPES.FRAGMENT]: encodeFragment(fragment)
      };
      const event = (0, _everCangjie.CangjieClipboardEvent)('cangjiePaste', {
        clipboardData: {
          items: [// @ts-ignore
          {
            type: MIME_TYPES.FRAGMENT
          }],
          types: [MIME_TYPES.FRAGMENT],
          data: clipboardData,
          getData: format => {
            return clipboardData[format];
          }
        }
      });
      controller.run('onCangjiePaste', event);
      await (0, _everDevTest.waitForTime)(10);
      const {
        value
      } = controller; // 检查引用块是否插入

      expect(value.toJSON()).toEqual(expected.toJSON());
    });
    test('#onPaste: without refblock', async () => {
      const controller = createController(_ref83);
      const expected = _ref84;
      const fragment = _ref85;
      const encodedFragment = encodeFragment(fragment); // 剪贴板内也是 fragment

      const clipboardData = {
        [MIME_TYPES.FRAGMENT]: encodedFragment
      };
      const event = (0, _everCangjie.CangjieClipboardEvent)('cangjiePaste', {
        clipboardData: {
          // @ts-ignore
          items: [{
            type: MIME_TYPES.FRAGMENT
          }],
          types: [MIME_TYPES.FRAGMENT],
          data: clipboardData,
          getData: format => {
            return clipboardData[format];
          }
        }
      });
      controller.run('onCangjiePaste', event);
      await (0, _everDevTest.waitForTime)(10);
      const {
        value
      } = controller;
      expect(value.toJSON()).toEqual(expected.toJSON());
    });
    test('#onPaste: remove nested refblocks & hetu sync nodes & invalid nodes', async () => {
      const controller = createController((0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      }, _ref86))), {
        // @ts-ignore
        refblock: {
          disableNestedInRefBlock: node => _everCangjie.Block.isBlock(node) && node.text === 'not-supported'
        }
      });
      const expected = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a'
        }
      }, _ref87)));
      const fragment = (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-b'
        }
      }, _ref88), (0, _everDevTest.jsx)("block", {
        type: "card",
        data: {
          cardType: 'calendar',
          height: 300,
          metadata: {
            sync: true
          }
        }
      }), _ref89, _ref90); // 剪贴板内也是 fragment

      const clipboardData = {
        [MIME_TYPES.FRAGMENT]: encodeFragment(fragment)
      };
      const event = (0, _everCangjie.CangjieClipboardEvent)('cangjiePaste', {
        clipboardData: {
          // @ts-ignore
          items: [{
            type: MIME_TYPES.FRAGMENT
          }],
          types: [MIME_TYPES.FRAGMENT],
          data: clipboardData,
          getData: format => {
            return clipboardData[format];
          }
        }
      });
      controller.run('onCangjiePaste', event);
      await (0, _everDevTest.waitForTime)(10);
      const {
        value
      } = controller;
      expect(value.toJSON()).toEqual(expected.toJSON());
    });
    test('#onPaste: without fragment', async () => {
      const onCangjiePaste = jest.fn();
      const controller = createController(_ref91, {
        pasteTester: {
          onCangjiePaste
        }
      });
      const expected = _ref92; // 剪贴板未写入 Fragment

      const clipboardData = {
        [MIME_TYPES.TEXT]: 'hello-world'
      };
      const event = (0, _everCangjie.CangjieClipboardEvent)('cangjiePaste', {
        clipboardData: {
          // @ts-ignore
          items: [{
            type: MIME_TYPES.TEXT
          }],
          types: [MIME_TYPES.TEXT],
          data: clipboardData,
          getData: format => {
            return clipboardData[format];
          }
        }
      });
      controller.run('onCangjiePaste', event);
      await (0, _everDevTest.waitForTime)(10);
      const {
        value
      } = controller;
      expect(value.toJSON()).toEqual(expected.toJSON());
      const nextEvent = onCangjiePaste.mock.calls[0][0]; // 不产生 fragment mimetype

      expect(nextEvent.clipboardData?.types).toEqual([MIME_TYPES.TEXT]);
    });
    test('#onAction: COPY_AS_REFBLOCK, blocks in current selection', async () => {
      const controller = createController(_ref93, {
        clipboard: {
          serializer: {
            valueToJsonML: () => ['root', {}, []],
            jsonMLToHTML: () => '<p></p>'
          }
        },
        refblock: {
          getRefBlockURL: id => `https://dingtalk.com?id=${id}`
        }
      });
      const expected = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a',
          refblockUUID: 'doc-a',
          uuid: 'doc-a'
        }
      }, _ref94, _ref95), _ref96));
      controller.dispatch('copyAsRefBlock', []); // wait for created

      await (0, _everDevTest.waitForTime)(10);
      const {
        value
      } = controller; // 检查 refblock 是否生成

      expect(controller.value.toJSON()).toEqual(expected.toJSON());
      const refblock = value.document.assertNodeByPath([0]); // 检查 refblock 是否为加载态

      expect(value.injections).toEqual([_everCangjie.Injection.create({
        key: refblock.key,
        data: {
          status: _models.RefBlockStatus.loading
        }
      })]); // 检查剪贴板是否写入信息

      expect(mockedClipboard).toEqual({
        [MIME_TYPES.FRAGMENT]: expect.anything(),
        [MIME_TYPES.HTML]: expect.anything(),
        [MIME_TYPES.REFBLOCK]: expect.anything(),
        // text 写入源文档地址
        [MIME_TYPES.TEXT]: 'https://dingtalk.com?id=doc-a'
      });
    });
    test('#onAction: COPY_AS_REFBLOCK with fragment decorator', async () => {
      const controller = createController(_ref97, {
        clipboard: {
          serializer: {
            valueToJsonML: () => ['root', {}, []],
            jsonMLToHTML: () => '<p></p>'
          }
        },
        refblock: {
          decorateRefBlockFragment: fragment => fragment.set('nodes', fragment.nodes.slice(0, 1))
        }
      });
      const expected = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a',
          refblockUUID: 'doc-a',
          uuid: 'doc-a'
        }
      }, _ref98), _ref99, _ref100));
      controller.dispatch('copyAsRefBlock', []); // wait for created

      await (0, _everDevTest.waitForTime)(10);
      const {
        value
      } = controller; // 检查 refblock 是否生成

      expect(controller.value.toJSON()).toEqual(expected.toJSON());
      const refblock = value.document.assertNodeByPath([0]); // 检查 refblock 是否为加载态

      expect(value.injections).toEqual([_everCangjie.Injection.create({
        key: refblock.key,
        data: {
          status: _models.RefBlockStatus.loading
        }
      })]); // 检查剪贴板是否写入信息

      expect(mockedClipboard).toEqual({
        [MIME_TYPES.FRAGMENT]: expect.anything(),
        [MIME_TYPES.HTML]: expect.anything(),
        [MIME_TYPES.REFBLOCK]: expect.anything(),
        [MIME_TYPES.TEXT]: expect.anything()
      });
    });
    test('#onAction: COPY_AS_REFBLOCK: failed', async () => {
      const controller = createController(_ref101, {
        clipboard: {
          serializer: {
            valueToJsonML: () => ['root', {}, []],
            jsonMLToHTML: () => '<p></p>'
          }
        },
        refblock: {
          generateDoc: () => Promise.reject()
        }
      });
      const expected = _ref102;
      controller.dispatch('copyAsRefBlock', []); // wait for created

      await (0, _everDevTest.waitForTime)(10); // 内容应当无变化

      expect(controller.value.toJSON()).toEqual(expected.toJSON()); // 出错时，剪贴板不写入信息

      expect(mockedClipboard).toEqual({});
    });
    test('#onAction: COPY_AS_REFBLOCK, prefer block in action payload', async () => {
      const controller = createController(_ref103, {
        clipboard: {
          serializer: {
            valueToJsonML: () => ['root', {}, []],
            jsonMLToHTML: () => '<p></p>'
          }
        }
      });
      const expected = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, _ref104, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a',
          refblockUUID: 'doc-a',
          uuid: 'doc-a'
        }
      }, _ref105), _ref106));
      const block = controller.value.document.assertNodeByPath([1]);
      controller.dispatch('copyAsRefBlock', [block]); // wait for created

      await (0, _everDevTest.waitForTime)(10); // 检查 refblock 是否生成

      expect(controller.value.toJSON()).toEqual(expected.toJSON());
    });
    test('#onAction: COPY_AS_REFBLOCK, current block in payload changed', async () => {
      const controller = createController(_ref107, {
        clipboard: {
          // @ts-ignore
          serializer: {
            valueToJsonML: () => ['root', {}, []],
            jsonMLToHTML: () => '<p></p>'
          }
        }
      });
      const expected = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, _ref108, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a',
          refblockUUID: 'doc-a',
          uuid: 'doc-a'
        }
      }, _ref109), _ref110));
      const srcBlock = controller.value.document.assertNodeByPath([1]); // refresh block

      controller.command(_everCangjie.Commands.insertTextByPath, [1, 0], 5, '!', []).flush();
      controller.dispatch('copyAsRefBlock', [srcBlock]); // wait for created

      await (0, _everDevTest.waitForTime)(10); // 检查 refblock 是否生成

      expect(controller.value.toJSON()).toEqual(expected.toJSON());
    });
    test('#onAction: COPY_REFBLOCK', async () => {
      const controller = createController((0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a',
          refblockUUID: 'doc-a'
        }
      }, _ref111))), {
        clipboard: {
          // @ts-ignore
          serializer: {
            valueToJsonML: () => ['root', {}, []],
            jsonMLToHTML: () => '<p></p>'
          }
        }
      });
      const refblock = controller.value.document.getNodeByPath([0]);
      controller.dispatch('copyRefBlock', refblock); // 检查剪贴板内容

      expect(mockedClipboard).toEqual({
        [MIME_TYPES.FRAGMENT]: expect.anything(),
        [MIME_TYPES.HTML]: expect.anything(),
        [MIME_TYPES.REFBLOCK]: expect.anything(),
        [MIME_TYPES.TEXT]: expect.anything()
      });
    });
    test('#onAction: COPY_REFBLOCK, customize package serializer', async () => {
      const controller = createController((0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'doc-a',
          refblockUUID: 'doc-a'
        }
      }, _ref112))), {
        clipboard: {
          // @ts-ignore
          serializer: {
            valueToJsonML: () => ['root', {}, []],
            jsonMLToHTML: () => '<p></p>'
          }
        },
        refblock: {
          cacheHetuWhenCopy: () => 'package'
        }
      });
      const refblock = controller.value.document.getNodeByPath([0]);
      controller.dispatch('copyRefBlock', refblock); // 检查剪贴板内容

      expect(mockedClipboard).toEqual({
        [MIME_TYPES.FRAGMENT]: expect.anything(),
        [MIME_TYPES.HTML]: expect.anything(),
        [MIME_TYPES.REFBLOCK]: 'package',
        [MIME_TYPES.TEXT]: expect.anything()
      });
    });
    test('#onAction: UPDATE_REFBLOCK_DATA', async () => {
      const controller = createController((0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'a'
        }
      }, _ref113))));
      const expected = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'a',
          refblockUUID: 'a'
        }
      }, _ref114)));
      const refblock = controller.value.document.getNodeByPath([0]);
      controller.dispatch('updateRefBlockData', refblock, {
        refblockUUID: 'a'
      });
      expect(controller.value.toJSON()).toEqual(expected.toJSON());
    });
    test('#onKeyDown: select all inside a refblock', async () => {
      const controller = createController((0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'a'
        }
      }, _ref115, _ref116))));
      const expected = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'a'
        }
      }, _ref117, _ref118)));
      controller.run('onKeyDown', new KeyboardEvent('keydown', (0, _everDevTest.getHotkeyEvent)('mod+a')));
      controller.flush();
      expect(controller.value.toJSON({
        preserveSelections: true
      })).toEqual(expected.toJSON({
        preserveSelections: true
      }));
    });
    test('#onKeyDown: select all when start inside a refblock', async () => {
      const controller = createController((0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'a'
        }
      }, _ref119), _ref120)));
      const expected = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'a'
        }
      }, _ref121), _ref122));
      controller.run('onKeyDown', new KeyboardEvent('keydown', (0, _everDevTest.getHotkeyEvent)('mod+a')));
      controller.flush();
      expect(controller.value.toJSON({
        preserveSelections: true
      })).toEqual(expected.toJSON({
        preserveSelections: true
      }));
    });
    test('#onKeyDown: select all when end inside a refblock', async () => {
      const controller = createController((0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, _ref123, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'a'
        }
      }, _ref124))));
      const expected = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, _ref125, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'a'
        }
      }, _ref126)));
      controller.run('onKeyDown', new KeyboardEvent('keydown', (0, _everDevTest.getHotkeyEvent)('mod+a')));
      controller.flush();
      expect(controller.value.toJSON({
        preserveSelections: true
      })).toEqual(expected.toJSON({
        preserveSelections: true
      }));
    });
    test('#onKeyDown: select all inside a selectall-able element which is inside a refblock', async () => {
      const controller = createController((0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'a'
        }
      }, _ref127))));
      const expected = (0, _everDevTest.jsx)("value", null, (0, _everDevTest.jsx)("document", null, (0, _everDevTest.jsx)("block", {
        type: "refblock",
        data: {
          docKey: 'a'
        }
      }, _ref128)));
      controller.run('onKeyDown', new KeyboardEvent('keydown', (0, _everDevTest.getHotkeyEvent)('mod+a')));
      controller.flush();
      expect(controller.value.toJSON({
        preserveSelections: true
      })).toEqual(expected.toJSON({
        preserveSelections: true
      }));
    });
    test('#onKeyDown: skip if key event is not select-all', async () => {
      const value = _ref129;
      const controller = createController(value);
      controller.run('onKeyDown', new KeyboardEvent('keydown', (0, _everDevTest.getHotkeyEvent)('mod+o')));
      controller.flush();
      expect(controller.value).toBe(value);
    });
  });
});
//# sourceMappingURL=behavior.test.js.map