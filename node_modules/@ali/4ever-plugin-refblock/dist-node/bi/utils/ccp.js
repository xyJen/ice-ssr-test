"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.writeRefBlockToClipboard = writeRefBlockToClipboard;
exports.cropRefBlockInFragment = cropRefBlockInFragment;
exports.unwrapRefBlock = unwrapRefBlock;

var _everCangjie = require("@ali/4ever-cangjie");

var _everPluginClipboard = require("@ali/4ever-plugin-clipboard");

var _everPluginParagraph = require("@ali/4ever-plugin-paragraph");

var _models = _interopRequireDefault(require("../../mo/models"));

var _lodash = require("lodash");

var _value = require("../../utils/value");

const {
  MIME_TYPES
} = _everCangjie.constants;
/**
 * 将引用块数据写入剪贴板
 * @param refblock
 * @param serializer
 */

function writeRefBlockToClipboard(refblock, cacheHetuWhenCopy, getRefBlockURL, serializer) {
  /* istanbul ignore next */
  if (!serializer) {
    return;
  }

  const fragment = _everCangjie.Document.create({
    nodes: [refblock]
  });

  const value = _everCangjie.Value.create({
    document: fragment
  });

  const clip = (0, _everPluginClipboard.createClipboardManager)();
  const refblockData = cacheHetuWhenCopy(fragment);

  const fragmentData = _everCangjie.transferUtils.encodeFragment(fragment);

  const html = _everPluginClipboard.utils.writeClipboardDataToHtml((0, _everPluginClipboard.getHtmlFromValue)(serializer, value), [[MIME_TYPES.REFBLOCK, refblockData], [MIME_TYPES.FRAGMENT, fragmentData]]);

  clip.write({
    [MIME_TYPES.FRAGMENT]: fragmentData,
    [MIME_TYPES.HTML]: html,
    [MIME_TYPES.TEXT]: getRefBlockURL(refblock.data.uuid || refblock.data.refblockUUID),
    [MIME_TYPES.REFBLOCK]: refblockData
  });
}
/**
 * 裁剪 Fragment 中的引用块内容：
 *
 * - uuid: 保证粘贴时生成新的引用关系
 * - children: 裁剪掉引用块的内容，保证引用块内容只由协同服务供给
 * @param fragment
 * @returns
 */


function cropRefBlockInFragment(fragment) {
  let newFragment = fragment;
  const refblockMap = (0, _value.getRefBlockMap)(newFragment);
  Object.keys(refblockMap).forEach(docKey => {
    refblockMap[docKey].forEach(({
      nodeKey
    }) => {
      const node = newFragment.assertNode(nodeKey);
      newFragment = newFragment.setNode(newFragment.assertPath(nodeKey), {
        data: (0, _lodash.omit)(node.data, 'refblockUUID'),
        nodes: [_everPluginParagraph.Paragraph.create()]
      });
    });
  });
  return newFragment;
}
/**
 * 剪贴板包含引用块时：
 * 1. 若引用块被设置标志位，代表用户明确意图复制引用块，需要保留引用块
 * 2. 否则，只保留引用块内内容
 * @param fragment
 */


function unwrapRefBlock(fragment) {
  let newFragment = fragment;
  fragment.forEachDescendant(node => {
    if (_models.default.isRefBlock(node)) {
      const path = newFragment.assertPath(node.key); // 展平引用块

      newFragment = newFragment.removeNode(path);
      node.nodes.forEach((child, index) => {
        newFragment = newFragment.insertNode(_everCangjie.Path.increment(path, index), child);
      });
    }
  });
  return newFragment;
}
//# sourceMappingURL=ccp.js.map