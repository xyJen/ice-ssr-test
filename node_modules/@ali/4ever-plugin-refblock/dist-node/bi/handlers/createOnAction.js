"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createOnAction;

var _everCangjie = require("@ali/4ever-cangjie");

var _weDesign = require("@ali/we-design");

var _everPluginClipboard = require("@ali/4ever-plugin-clipboard");

var _models = _interopRequireWildcard(require("../../mo/models"));

var _actions = require("../actions");

var _commands = require("../commands");

var _ccp = require("../utils/ccp");

var _value = require("../../utils/value");

function createOnAction(config, serializer) {
  const {
    generateDoc,
    decorateRefBlockFragment,
    cacheHetuWhenCopy,
    getRefBlockURL,
    locale
  } = config;
  return function onAction(action, controller, next) {
    const isCopyAsRefBlock = controller.isActionFactory('isCopyAsRefBlock');
    const isCopyRefBlock = controller.isActionFactory('isCopyRefBlock');
    const {
      type
    } = action;

    if (isCopyAsRefBlock?.(action)) {
      const {
        nodes: dragBlocks
      } = action.payload;
      let {
        document,
        selection
      } = controller.value;
      let blocks = document.getRootBlocksAtRange(selection);

      if (dragBlocks && dragBlocks.length >= blocks.length) {
        blocks = [...dragBlocks.map(n => {
          // 重新获得 block，防止拖拽杆展开后，block 又发生了变更（例如图片加载完成）
          return document.assertNode(n.key);
        })];
      }

      _weDesign.message.loading({
        key: 'loading',
        type: 'loading',
        content: locale.creating
      }); // 装饰 fragment


      const fragment = decorateRefBlockFragment(_everCangjie.Document.create({
        nodes: blocks
      }));
      generateDoc(fragment).then(resp => {
        // 创建成功后：
        // 1. 拷贝内容到剪贴板
        // 2. 升级普通块为引用块
        // 3. 驱动引用块开始加载
        const {
          docKey,
          uuid
        } = resp;

        const refblock = _models.default.create({
          nodes: blocks,
          data: {
            docKey: resp.docKey,
            refblockUUID: uuid
          }
        });

        (0, _ccp.writeRefBlockToClipboard)(refblock, cacheHetuWhenCopy, getRefBlockURL, serializer);
        controller.run('onAction', _actions.actions.upgradeToRefBlock(docKey, uuid, fragment.nodes));

        _weDesign.message.success(locale.copySuccess);

        _weDesign.message.close('loading');
      }).catch(e => {
        console.error('cannot create refblock', e);
      });
      return controller;
    } else if (_actions.isActions.isSetRefBlockInjectionByDocKeyAction(action)) {
      const {
        data,
        docKey,
        overwrite
      } = action.payload;
      return controller.command(_commands.setRefBlockInjectionByDocKey, docKey, data, overwrite);
    } else if (_actions.isActions.isSetRefBlockInjectionByKeyAction(action)) {
      const {
        data,
        key,
        overwrite
      } = action.payload;
      return controller.command(_commands.setRefBlockInjectionByKey, key, data, overwrite);
    } else if (_actions.isActions.isUpgradeToRefBlockAction(action)) {
      const {
        blocks,
        docKey,
        uuid
      } = action.payload;
      return controller.command(_commands.upgradeToRefBlock, blocks, {
        docKey,
        uuid,
        refblockUUID: uuid
      });
    } else if (_actions.isActions.isDowngradeToBlocksByDocKeyAction(action)) {
      const {
        docKey
      } = action.payload;
      return controller.command(_commands.downgradeToBlocksByDocKey, docKey);
    } else if (_actions.isActions.isDowngradeToBlocksByKeyAction(action)) {
      const {
        key
      } = action.payload;
      return controller.command(_commands.downgradeToBlocksByKey, key);
    } else if (isCopyRefBlock?.(action)) {
      const {
        refblock
      } = action.payload;
      (0, _ccp.writeRefBlockToClipboard)(refblock, cacheHetuWhenCopy, getRefBlockURL, serializer);

      _weDesign.message.success(locale.copySuccess);
    } else if (_actions.isActions.isInsertRefBlockAction(action)) {
      const {
        data
      } = action.payload;
      return controller.command(_commands.insertRefBlock, data).command(_commands.setRefBlockInjectionByDocKey, data.docKey, {
        status: _models.RefBlockStatus.loading
      }, false);
    } else if (_actions.isActions.isUpdateRefBlockDataAction(action)) {
      const {
        data,
        node
      } = action.payload;
      return controller.command(_commands.updateRefBlockData, node, data).command(_commands.setRefBlockInjectionByKey, node.key, {
        status: _models.RefBlockStatus.loading
      }, false);
    } else if (type === _everPluginClipboard.CLIPBOARD_INSERT_FRAGMENT) {
      // wait for fragment pasted
      const {
        fragment
      } = action.payload;

      if (!fragment) {
        return next();
      }

      const cachedSelection = controller.value.selection; // 因为 CCP 插入 fragment 是异步的，因此这里同步状态也需要异步

      Promise.resolve().then(() => {
        const refblockMap = (0, _value.getRefBlockMap)(fragment); // 检查 fragment 中的引用块

        Object.keys(refblockMap).forEach((docKey, index) => {
          if (index === 0) {
            // 避免光标移动到引用块内部
            controller.command(_everCangjie.Commands.select, cachedSelection);
          }

          controller.run('onAction', _actions.actions.setRefBlockInjectionByDocKey(docKey, {
            status: _models.RefBlockStatus.loading
          }, false));
        });
      });
    }

    return next();
  };
}
//# sourceMappingURL=createOnAction.js.map