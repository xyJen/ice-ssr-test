"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createOnPaste;

var _everCangjie = require("@ali/4ever-cangjie");

var _lodash = require("lodash");

var _models = _interopRequireDefault(require("../../mo/models"));

var _logic = require("../../utils/logic");

var _value = require("../../utils/value");

const {
  MIME_TYPES
} = _everCangjie.constants;

function createOnPaste(config) {
  const {
    clipboard = {},
    refblock
  } = config;
  const {
    generateCopyDoc,
    disableNestedInRefBlock = _lodash.stubFalse,
    getHetuWhenPaste
  } = refblock;
  return async function onPaste(event, controller, next) {
    const clipboardData = controller.query('getClipboardData', event);

    if (!clipboardData) {
      return next();
    }

    if (!clipboardData.hasData(MIME_TYPES.FRAGMENT)) {
      return next();
    }

    let fragment = clipboardData.getFragment(false);
    const packageJSON = clipboardData.getData(MIME_TYPES.REFBLOCK); // 粘贴到引用块时，剔除引用块和河图同步块

    if (fragment) {
      if ((0, _logic.isSelectionInRefBlock)(controller.value)) {
        // 剔除河图同步块
        const hetuSyncNodes = []; // 剔除引用块

        const refblocks = []; // 剔除包含有非法节点的块

        const invalidNodes = [];
        fragment.forEachDescendant(descendant => {
          if ((0, _logic.isSyncHetuNode)(descendant)) {
            hetuSyncNodes.push(descendant);
          } else if (_models.default.isRefBlock(descendant)) {
            refblocks.push(descendant);
          } else if (disableNestedInRefBlock(descendant, controller)) {
            invalidNodes.push(descendant);
          }
        });
        [...hetuSyncNodes, ...refblocks, ...invalidNodes].forEach(node => {
          fragment = fragment.removeNode(fragment.assertPath(node.key));
        });
      } else {
        const refblockMap = (0, _value.getRefBlockMap)(fragment); // 如果不含有引用块，提前退出

        if (!Object.keys(refblockMap).length) {
          return next();
        } // 粘贴 fragment 中包含的引用块


        let deserialized = false;

        for (const docKey in refblockMap) {
          if (packageJSON && !deserialized) {
            deserialized = true;
            getHetuWhenPaste(packageJSON);
          }

          const nodes = refblockMap[docKey].map(({
            nodeKey
          }) => fragment.assertNode(nodeKey));

          try {
            const {
              uuid
            } = await generateCopyDoc(docKey);
            nodes.forEach(node => {
              fragment = fragment.setNode(fragment.assertPath(node.key), {
                data: { ...node.data,
                  refblockUUID: uuid
                }
              });
            });
          } catch (e) {
            // 如果对应 refblock 的 uuid 生成失败，则不粘贴这些节点
            nodes.forEach(node => {
              fragment = fragment.removeNode(fragment.assertPath(node.key));
            });
          }
        }
      }

      const nextEvent = event.setClipboardData(event.clipboardData.setData(MIME_TYPES.FRAGMENT, _everCangjie.transferUtils.encodeFragment(fragment))); // @ts-ignore

      return next(nextEvent);
    }

    return next();
  };
}
//# sourceMappingURL=createOnPaste.js.map