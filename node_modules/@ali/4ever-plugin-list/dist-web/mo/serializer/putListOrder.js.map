{"version":3,"sources":["../../../../src/mo/serializer/putListOrder.ts"],"names":["Block","Injection","createListCountContext","itemCount","Map","clearOrderCount","level","orderCount","prevLevel","largerThanCurrent","keys","lvl","getListOrder","get","tempOrder","listOrder","set","getListOrderDataById","nodes","id","itemCountMap","results","forEach","n","isBlock","data","list","listId","listStart","start","isOrdered","Math","max","step","Array","fill","map","value","index","join","push","key","getListOrderData","root","create"],"mappings":"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","sourcesContent":["// 防止与Bi循环引用，mo中先单独列一份\nimport { Block, Document, Injection, BlockChildren } from '@ali/4ever-cangjie';\n\nexport interface ListCountContext {\n  itemCount: Map<number, number>;\n  prevLevel?: number;\n}\n\ninterface ListData {\n  key: string;\n  data: {\n    start: number;\n    step: string;\n    listId: string;\n  };\n}\n\nexport const createListCountContext = (): ListCountContext => ({\n  itemCount: new Map<number, number>(),\n});\n\nconst clearOrderCount = (level: number, orderCount: Map<number, number>, prevLevel?: number) => {\n  const largerThanCurrent = !!prevLevel && prevLevel > level;\n  // 如果前一项 level 大于当前 level 就清空所有比当前大的计数\n  if (largerThanCurrent) {\n    for (const lvl of orderCount.keys()) {\n      if (lvl > level) {\n        orderCount.delete(lvl);\n      }\n    }\n  }\n};\n\nexport const getListOrder = (\n  level: number,\n  orderCount: Map<number, number>,\n  prevLevel?: number,\n) => {\n  const itemCount = orderCount.get(level);\n  const largerThanCurrent = !!prevLevel && prevLevel > level;\n  const tempOrder = largerThanCurrent ? 2 : 1;\n  // word 中第一项默认从 1 开始，但是如果前一项 level 大于当前 level 就从 2 开始\n  const listOrder = typeof itemCount === 'undefined' ? tempOrder : itemCount + 1;\n\n  clearOrderCount(level, orderCount, prevLevel);\n\n  orderCount.set(level, listOrder);\n\n  return listOrder;\n};\n\nconst getListOrderDataById = (nodes: BlockChildren, id?: string) => {\n  const itemCountMap = new Map<string, ListCountContext>();\n  const results: ListData[] = [];\n\n  nodes.forEach((n) => {\n    // 线上存在 listId 一样的列表但是类型不一样，需要做一下过滤，只对有序列表做计算\n    if (\n      !Block.isBlock(n) ||\n      !n.data.list ||\n      (!!id && n.data.list.listId !== id)\n    ) {\n      return;\n    }\n\n    const { listId, level: lvl, start: listStart, isOrdered } = n.data.list;\n    const level = Math.max(lvl, 0);\n    const { itemCount, prevLevel } =\n      itemCountMap.get(listId) || createListCountContext();\n\n    if (!isOrdered) {\n      clearOrderCount(level, itemCount, prevLevel);\n      itemCountMap.set(listId, { itemCount, prevLevel: level });\n      return;\n    }\n\n    // 如果有 节点有 start 字段，序号从指定 start 开始\n    if (typeof listStart === 'number') {\n      itemCount.set(level, listStart - 1);\n    }\n\n    const start = getListOrder(level, itemCount, prevLevel);\n    const step = Array(level + 1)\n      .fill(1)\n      .map((value, index) => itemCount.get(index) || value)\n      .join('.');\n    itemCountMap.set(listId, { itemCount, prevLevel: level });\n\n    results.push({\n      key: n.key,\n      data: { start, step, listId },\n    });\n  });\n\n  return results;\n};\n\nexport function getListOrderData(root: Document | Block, listId: string) {\n  const results = getListOrderDataById(root.nodes, listId);\n  return results.map((data) => Injection.create(data));\n}\n"],"file":"putListOrder.js"}