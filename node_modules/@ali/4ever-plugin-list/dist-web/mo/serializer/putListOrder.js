function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// 防止与Bi循环引用，mo中先单独列一份
import { Block, Injection } from '@ali/4ever-cangjie';
export var createListCountContext = function createListCountContext() {
  return {
    itemCount: new Map()
  };
};

var clearOrderCount = function clearOrderCount(level, orderCount, prevLevel) {
  var largerThanCurrent = !!prevLevel && prevLevel > level; // 如果前一项 level 大于当前 level 就清空所有比当前大的计数

  if (largerThanCurrent) {
    for (var _iterator = _createForOfIteratorHelperLoose(orderCount.keys()), _step; !(_step = _iterator()).done;) {
      var lvl = _step.value;

      if (lvl > level) {
        orderCount["delete"](lvl);
      }
    }
  }
};

export var getListOrder = function getListOrder(level, orderCount, prevLevel) {
  var itemCount = orderCount.get(level);
  var largerThanCurrent = !!prevLevel && prevLevel > level;
  var tempOrder = largerThanCurrent ? 2 : 1; // word 中第一项默认从 1 开始，但是如果前一项 level 大于当前 level 就从 2 开始

  var listOrder = typeof itemCount === 'undefined' ? tempOrder : itemCount + 1;
  clearOrderCount(level, orderCount, prevLevel);
  orderCount.set(level, listOrder);
  return listOrder;
};

var getListOrderDataById = function getListOrderDataById(nodes, id) {
  var itemCountMap = new Map();
  var results = [];
  nodes.forEach(function (n) {
    // 线上存在 listId 一样的列表但是类型不一样，需要做一下过滤，只对有序列表做计算
    if (!Block.isBlock(n) || !n.data.list || !!id && n.data.list.listId !== id) {
      return;
    }

    var _n$data$list = n.data.list,
        listId = _n$data$list.listId,
        lvl = _n$data$list.level,
        listStart = _n$data$list.start,
        isOrdered = _n$data$list.isOrdered;
    var level = Math.max(lvl, 0);

    var _ref = itemCountMap.get(listId) || createListCountContext(),
        itemCount = _ref.itemCount,
        prevLevel = _ref.prevLevel;

    if (!isOrdered) {
      clearOrderCount(level, itemCount, prevLevel);
      itemCountMap.set(listId, {
        itemCount: itemCount,
        prevLevel: level
      });
      return;
    } // 如果有 节点有 start 字段，序号从指定 start 开始


    if (typeof listStart === 'number') {
      itemCount.set(level, listStart - 1);
    }

    var start = getListOrder(level, itemCount, prevLevel);
    var step = Array(level + 1).fill(1).map(function (value, index) {
      return itemCount.get(index) || value;
    }).join('.');
    itemCountMap.set(listId, {
      itemCount: itemCount,
      prevLevel: level
    });
    results.push({
      key: n.key,
      data: {
        start: start,
        step: step,
        listId: listId
      }
    });
  });
  return results;
};

export function getListOrderData(root, listId) {
  var results = getListOrderDataById(root.nodes, listId);
  return results.map(function (data) {
    return Injection.create(data);
  });
}
//# sourceMappingURL=putListOrder.js.map