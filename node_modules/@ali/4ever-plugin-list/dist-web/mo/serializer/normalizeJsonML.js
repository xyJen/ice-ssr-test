import _extends from "@babel/runtime/helpers/extends";

/* eslint-disable no-restricted-imports */
import { getAttributes, getChildren, getTagName } from '@ali/4ever-cangjie';
import { getListOrder, createListCountContext } from "./putListOrder"; // 用于判断两个 list 是否为同一个 list
// 判断依据：listId 相同，type 也相同

function assertSameList(list, anotherList) {
  return typeof list.listId === 'string' && typeof anotherList.listId === 'string' && list.listId === anotherList.listId;
}

function transformListNode(content) {
  var outerChildren = getChildren(content);
  var attrs = getAttributes(content);
  var _ref = attrs,
      _ref$isOrdered = _ref.isOrdered,
      isOrdered = _ref$isOrdered === void 0 ? false : _ref$isOrdered;
  var result = [isOrdered ? 'ol' : 'ul', _extends({}, attrs)];
  /**
   * 将平铺的子节点转成为嵌套的列表树形结构
   *
   * @param nodes
   * @param path
   * @param prevLevel
   */

  var flatNodesToListTree = function flatNodesToListTree(nodes, path, prevLevel) {
    var node = nodes.shift();

    var _ref2 = getAttributes(node),
        list = _ref2.list;

    var level = list.level;
    var curr;
    var parent = result;

    if (level === prevLevel) {
      curr = 0;

      for (var i = 0; i < path.length - 1; i++) {
        parent = getChildren(parent)[path[i]];
      }

      if (path.length) {
        path[path.length - 1] += 1;
      } else {
        path = [0];
      }
    } else if (level < prevLevel) {
      curr = level - prevLevel;
      path = path.slice(0, path.length - (prevLevel - level) * 2);

      for (var _i = 0; _i < path.length - 1; _i++) {
        parent = getChildren(parent)[path[_i]];
      }

      path[path.length - 1] += 1;
    } else if (level > prevLevel) {
      // 如果 level - prevLevel > 1，也按 1 来计算, 避免找不到上层节点
      curr = 1;

      for (var _i2 = 0; _i2 < path.length; _i2++) {
        parent = getChildren(parent)[path[_i2]];
      }

      path = [].concat(path, [getChildren(parent).length]);
    }

    var children = getChildren(parent);
    node = ['li', _extends({}, getAttributes(node)), node];

    if (children.length > 0) {
      var last = getTagName(children[children.length - 1]);

      if (['ul', 'ol', 'li'].indexOf(last) < 0) {
        var _attrs = getAttributes(node);

        var _attrs$list$isOrdered = _attrs.list.isOrdered,
            innerIsOrdered = _attrs$list$isOrdered === void 0 ? false : _attrs$list$isOrdered;
        node = [innerIsOrdered ? 'ol' : 'ul', _extends({}, _attrs.list), node];
        path = [].concat(path, [0]);
      }
    }

    parent.push(node);

    if (nodes.length > 0) {
      flatNodesToListTree(nodes, path, prevLevel + curr);
    }
  };

  flatNodesToListTree(outerChildren, [], 0);
  return result;
} // 正规化渲染 HTML 的 Asl，主要解决平铺列表转为嵌套列表的问题


function normalize(content, countMap) {
  var nodes = getChildren(content);
  var normalizeNodes = nodes.reduce(function (arr, node, index) {
    var tag = getTagName(node);
    var last = arr[arr.length - 1];

    if (tag === 'p') {
      var attrs = getAttributes(node) || {};
      var _ref3 = attrs,
          list = _ref3.list;
      var isLastIndex = index === nodes.length - 1; // 如果不是 list 节点

      if (!list) {
        // 上一个节点为 'list' 的话，需要对其进行转换
        if (last && getTagName(last) === 'list') {
          var listNode = transformListNode(last);
          arr[arr.length - 1] = listNode;
        }

        arr.push(node);
        return arr;
      } // 序号计算


      var _ref4 = countMap.get(list.listId) || createListCountContext(),
          itemCount = _ref4.itemCount,
          prevLevel = _ref4.prevLevel;

      var start = getListOrder(list.level, itemCount, prevLevel);
      countMap.set(list.listId, {
        itemCount: itemCount,
        prevLevel: list.level
      });
      node = ['p', {
        list: _extends({}, list, {
          start: start
        })
      }].concat(getChildren(node));

      if (last && getTagName(last) === 'list') {
        var next = [].concat(last, [node]);
        var lastAttrs = getAttributes(last) || {}; // 上一个节点为 'list'，并且和当前的 listId 相同则追加进去

        if (assertSameList(lastAttrs, list)) {
          arr[arr.length - 1] = isLastIndex ? transformListNode(next) : next;
        } else {
          // 否则说明是新的 list，要先把之前 list 进行转换
          arr[arr.length - 1] = transformListNode(last); // 然后再新建一个 list

          var newList = ['list', _extends({}, list), node];
          arr.push(isLastIndex ? transformListNode(newList) : newList);
        }
      } else if (isLastIndex) {
        // 当前为最后一个子节点，直接进行转换
        var _listNode = transformListNode(['list', _extends({}, list), node]);

        arr.push(_listNode);
      } else {
        arr.push(['list', _extends({}, list, {
          start: start
        }), node]);
      }
    } else {
      // 需要对上一个节点进行转换
      if (last && getTagName(last) === 'list') {
        var _list = transformListNode(last);

        arr[arr.length - 1] = _list;
      } // table 存在嵌套的情况，需要循环处理下


      if (tag === 'table') {
        var trs = getChildren(node).map(function (tr) {
          var tds = getChildren(tr).map(function (td) {
            return normalize(td, countMap);
          });
          return ['tr', _extends({}, getAttributes(tr))].concat(tds);
        });
        node = ['table', _extends({}, getAttributes(node))].concat(trs);
      }

      arr.push(node);
    }

    return arr;
  }, []);
  return [getTagName(content), _extends({}, getAttributes(content))].concat(normalizeNodes);
}

export function normalizeJsonMl(content) {
  var countMap = new Map();
  return normalize(content, countMap);
}
//# sourceMappingURL=normalizeJsonML.js.map