function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import { Injection, Block, Document } from '@ali/4ever-cangjie';
import { generateSymbol } from "./generateSymbol";
import { isListNode } from '@ali/4ever-utils';
export var createListCountContext = function createListCountContext() {
  return {
    itemCount: new Map()
  };
};
/**
 * 根据列表 id 获取列表序号
 * @param root parent blocks
 * @param id 列表 id
 */

export var getListOrderDataById = function getListOrderDataById(nodes, id) {
  var itemCountMap = new Map();
  var results = [];
  nodes.forEach(function (n) {
    // 线上存在 listId 一样的列表但是类型不一样，需要做一下过滤，只对有序列表做计算
    if (!Block.isBlock(n) || !n.data.list || !!id && n.data.list.listId !== id) {
      return;
    }

    var _n$data$list = n.data.list,
        listId = _n$data$list.listId,
        lvl = _n$data$list.level,
        listStart = _n$data$list.start,
        isOrdered = _n$data$list.isOrdered;
    var level = Math.max(lvl, 0);

    var _ref = itemCountMap.get(listId) || createListCountContext(),
        itemCount = _ref.itemCount,
        prevLevel = _ref.prevLevel;

    if (!isOrdered) {
      clearOrderCount(level, itemCount, prevLevel);
      itemCountMap.set(listId, {
        itemCount: itemCount,
        prevLevel: level
      });
      return;
    } // 如果有 节点有 start 字段，序号从指定 start 开始


    if (typeof listStart === 'number') {
      itemCount.set(level, listStart - 1);
    }

    var start = getListOrder(level, itemCount, prevLevel);
    var step = Array(level + 1).fill(1).map(function (value, index) {
      return itemCount.get(index) || value;
    }).join('.');
    itemCountMap.set(listId, {
      itemCount: itemCount,
      prevLevel: level
    });
    results.push({
      key: n.key,
      data: {
        start: start,
        step: step,
        listId: listId
      }
    });
  });
  return results;
};
export var getSymbolByListOrder = function getSymbolByListOrder(data, itemCountMap) {
  var list = data.list;

  if (list && list.isOrdered) {
    var _ref2 = list,
        _ref2$listId = _ref2.listId,
        listId = _ref2$listId === void 0 ? '' : _ref2$listId,
        _ref2$level = _ref2.level,
        lvl = _ref2$level === void 0 ? 0 : _ref2$level,
        _ref2$isOrdered = _ref2.isOrdered,
        isOrdered = _ref2$isOrdered === void 0 ? true : _ref2$isOrdered,
        listStyle = _ref2.listStyle,
        listStyleType = _ref2.listStyleType,
        listStart = _ref2.start;
    var level = Math.max(lvl, 0);

    var _ref3 = itemCountMap.get(listId) || createListCountContext(),
        itemCount = _ref3.itemCount,
        prevLevel = _ref3.prevLevel; // 如果有 节点有 start 字段，序号从指定 start 开始


    if (typeof listStart === 'number') {
      itemCount.set(level, listStart - 1);
    }

    var start = getListOrder(level, itemCount, prevLevel);
    var step = Array(level + 1).fill(1).map(function (value, index) {
      return itemCount.get(index) || value;
    }).join('.');
    itemCountMap.set(listId, {
      itemCount: itemCount,
      prevLevel: level
    });
    return generateSymbol(level, start, step, isOrdered, listStyleType, listStyle);
  }

  return undefined;
};

var clearOrderCount = function clearOrderCount(level, orderCount, prevLevel) {
  var largerThanCurrent = !!prevLevel && prevLevel > level; // 如果前一项 level 大于当前 level 就清空所有比当前大的计数

  if (largerThanCurrent) {
    for (var _iterator = _createForOfIteratorHelperLoose(orderCount.keys()), _step; !(_step = _iterator()).done;) {
      var lvl = _step.value;

      if (lvl > level) {
        orderCount["delete"](lvl);
      }
    }
  }
};

export var getListOrder = function getListOrder(level, orderCount, prevLevel) {
  var itemCount = orderCount.get(level);
  var largerThanCurrent = !!prevLevel && prevLevel > level;
  var tempOrder = largerThanCurrent ? 2 : 1; // word 中第一项默认从 1 开始，但是如果前一项 level 大于当前 level 就从 2 开始

  var listOrder = typeof itemCount === 'undefined' ? tempOrder : itemCount + 1;
  clearOrderCount(level, orderCount, prevLevel);
  orderCount.set(level, listOrder);
  return listOrder;
}; // 存在多个编辑器实例，则需要根据不同实例的列表做处理，map 是文档中所有列表的缓存。 key 是 listId

export var getListOrderData = function getListOrderData(controller, undividedList) {
  if (undividedList === void 0) {
    undividedList = [];
  }

  // 遍历中对列表项目计数的缓存 key: listId
  var itemCountMap = new Map();
  var results = [];
  var value = controller.value;
  var injections = value.injections,
      document = value.document;
  controller.value.document.forEachDescendant(function (n) {
    var _injections$find;

    // 线上存在 listId 一样的列表但是类型不一样，需要做一下过滤
    if (!Block.isBlock(n) || !n.data.list) {
      return;
    }

    var parent = document.getParent(n.key);
    var _n$data$list2 = n.data.list,
        listId = _n$data$list2.listId,
        lvl = _n$data$list2.level,
        listStart = _n$data$list2.start,
        isOrdered = _n$data$list2.isOrdered;
    var level = Math.max(lvl, 0);
    var itemCountMapKey = listId + (parent && !undividedList.includes(parent == null ? void 0 : parent.type) && (parent == null ? void 0 : parent.key)) || '';

    var _ref4 = itemCountMap.get(itemCountMapKey) || createListCountContext(),
        itemCount = _ref4.itemCount,
        prevLevel = _ref4.prevLevel; // 无序列表仍要根据 level 清理。有序列表会出现跨无序连续的问题
    // ● AAA              expect:  ● AAA
    //   a. BBB                      a. BBB
    // ● CCC       ->              ● CCC
    //   b. DDD                      a. DDD


    if (!isOrdered) {
      clearOrderCount(level, itemCount, prevLevel);
      itemCountMap.set(itemCountMapKey, {
        itemCount: itemCount,
        prevLevel: level
      });
      return;
    } // 如果有 节点有 start 字段，序号从指定 start 开始


    if (typeof listStart === 'number') {
      itemCount.set(level, listStart - 1);
    }

    var start = getListOrder(level, itemCount, prevLevel);
    var step = Array(Math.max(level + 1, 0)).fill(1).map(function (val, index) {
      return itemCount.get(index) || val;
    }).join('.');
    itemCountMap.set(itemCountMapKey, {
      itemCount: itemCount,
      prevLevel: level
    });
    var injection = Injection.create({
      key: n.key,
      data: {
        start: start,
        step: step,
        listId: listId,
        isSelected: !!((_injections$find = injections.find(function (i) {
          return i.key === n.key;
        })) != null && _injections$find.data.isSelected)
      }
    });
    results.push(injection);
  });
  return results;
};

var isHotsContainList = function isHotsContainList(controller) {
  return controller.hasHots() && controller.hots.hots.some(function (hot) {
    return isListNode(hot.node) || !!hot.node.findDescendant(isListNode);
  });
};

export var injectToNode = function injectToNode(node, controller, next) {
  var others = next() || []; // TODO: @灯少 更好的做法时，列表 `injectNode` 可以支持不从 Document 计算，当 node 为热区时，仅重算热区下的列表

  if (Document.isDocument(node) || isHotsContainList(controller)) {
    // 递归计算文档中所有的列表序号
    var injections = getListOrderData(controller);
    return [].concat(others, injections);
  }

  return others;
};
export var createInjectToNode = function createInjectToNode(listConfig) {
  var undividedList = listConfig.undividedList || [];
  return function (node, controller, next) {
    var others = next() || [];

    if (Document.isDocument(node) || isHotsContainList(controller)) {
      // 递归计算文档中所有的列表序号
      var injections = getListOrderData(controller, undividedList);
      return [].concat(others, injections);
    }

    return others;
  };
};
//# sourceMappingURL=putListOrder.js.map