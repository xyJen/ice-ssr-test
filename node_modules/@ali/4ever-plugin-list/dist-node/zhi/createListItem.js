"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createListItem;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _react = _interopRequireDefault(require("react"));

var _everCangjie = require("@ali/4ever-cangjie");

var _everUtils = require("@ali/4ever-utils");

var _everPluginListGroup = require("@ali/4ever-plugin-list-group");

var _utils = require("../utils");

const _createElement = /*#__PURE__*/_react.default.createElement;
const {
  BorderStyleEnum
} = _everCangjie.MoCommon;
const {
  isListGroupAvailable,
  isInUnlistGroupContainer,
  isNormalGroupNode
} = _everPluginListGroup.utils;
const {
  EXTRA_PADDING
} = _everPluginListGroup.constants;
const DEFAULT_BORDER_COLOR = '#000000';
const DEFAULT_SHD_MARGIN_BOTTOM = 1;
const {
  DEFAULT_SHD_STYLES
} = _everUtils.theme;

function createListItem(Paragraph) {
  class ListItem extends _react.default.Component {
    constructor(...args) {
      super(...args);

      this.getGroupListStyle = () => {
        const {
          node,
          controller
        } = this.props;
        const {
          shd
        } = node.data;

        if (!this.isListGroupAvailable || !shd) {
          return {
            display: 'contents'
          };
        } //@ts-ignore


        const paddingLeft = DEFAULT_SHD_STYLES.paddingLeft + (this.symbolAlign === 'right' ? _utils.ROMAN_EXTRA_INDENT : 0);
        const backgroundColor = isNormalGroupNode(node, controller) ? _everUtils.ShdUtil.transformShd(shd) : 'unset';
        const width = `calc(100% + ${(DEFAULT_SHD_STYLES.paddingLeft || 0) + (DEFAULT_SHD_STYLES.paddingRight || 0)}px)`;
        const justifyContent = (0, _utils.getJustifyContent)(this.align);
        return { ...DEFAULT_SHD_STYLES,
          backgroundColor,
          paddingLeft,
          width,
          display: 'flex',
          justifyContent
        };
      };
    }

    get align() {
      const {
        node
      } = this.props;
      return node.data.jc || 'left';
    }

    get symbolAlign() {
      const listConfig = this.props.node.data.list;
      const {
        listStyle
      } = listConfig;

      if (listStyle && ['upperRoman', 'lowerRoman'].includes(listStyle.format)) {
        return 'right';
      } else {
        return 'left';
      }
    }

    get isListGroupAvailable() {
      return isListGroupAvailable(this.props.controller);
    }

    /**
     * @TODO 列表的缩进完全由 ind 来排版，不由 level 而定
     */
    getStyle() {
      const {
        node,
        controller,
        visible
      } = this.props;
      const {
        list: listConfig,
        bdr = {},
        ind = {},
        pi,
        shd
      } = node.data;
      const {
        level = 0,
        listStyle
      } = listConfig;
      let paddingSpace = level * _everUtils.INDENT_SIZE;

      if (ind) {
        const {
          firstLine = 0,
          left = 0
        } = _everUtils.IndUtil.fromBlock(node);

        paddingSpace += firstLine + left;
      } // 罗马数字统一右侧对齐


      if (listStyle && ['upperRoman', 'lowerRoman'].includes(listStyle.format)) {
        // TODO 根据字体大小，动态计算罗马数字预留空间的宽度
        paddingSpace += this.isListGroupAvailable && shd ? 0 : _utils.ROMAN_EXTRA_INDENT;
      }

      const styleObj = {
        paddingLeft: paddingSpace,
        textAlign: this.align === 'distribute' ? 'justify' : this.align
      }; // Pi-2.0：列表高度有时会被项目符号莫名撑高，且边距需要渲染在列表处才可以生效

      if (pi && pi.box) {
        const {
          height,
          margin = {},
          padding = {}
        } = pi.box;
        const {
          top = 0,
          bottom = 0
        } = margin;
        styleObj.height = height;
        styleObj.marginTop = top;
        styleObj.marginBottom = bottom;
      } // 列表的边框需要挂载外围的 DOM 上


      if (bdr.top) {
        const {
          val = BorderStyleEnum.Single,
          sz = 1,
          color: bdrColor = DEFAULT_BORDER_COLOR,
          space = 0
        } = bdr.top;
        const borderStyle = val === BorderStyleEnum.Single ? 'solid' : val;
        const borderColor = bdrColor === 'auto' ? DEFAULT_BORDER_COLOR : bdrColor;
        styleObj.borderTop = `${sz}px ${borderStyle} ${borderColor}`;
        styleObj.paddingTop = space;
      }

      if (bdr.bottom) {
        const {
          val = BorderStyleEnum.Single,
          sz = 1,
          color: bdrColor = DEFAULT_BORDER_COLOR,
          space = 0
        } = bdr.bottom;
        const borderStyle = val === BorderStyleEnum.Single ? 'solid' : val;
        const borderColor = bdrColor === 'auto' ? DEFAULT_BORDER_COLOR : bdrColor;
        styleObj.borderBottom = `${sz}px ${borderStyle} ${borderColor}`;
        styleObj.paddingBottom = space;
      }

      if (bdr.left) {
        const {
          val = BorderStyleEnum.Single,
          sz = 1,
          color: bdrColor = DEFAULT_BORDER_COLOR,
          space = 0
        } = bdr.left;
        const borderStyle = val === BorderStyleEnum.Single ? 'solid' : val;
        const borderColor = bdrColor === 'auto' ? DEFAULT_BORDER_COLOR : bdrColor;
        styleObj.borderLeft = `${sz}px ${borderStyle} ${borderColor}`;
        styleObj.paddingLeft = space + paddingSpace;
      }

      if (bdr.right) {
        const {
          val = BorderStyleEnum.Single,
          sz = 1,
          color: bdrColor = DEFAULT_BORDER_COLOR,
          space = 0
        } = bdr.right;
        const borderStyle = val === BorderStyleEnum.Single ? 'solid' : val;
        const borderColor = bdrColor === 'auto' ? DEFAULT_BORDER_COLOR : bdrColor;
        styleObj.borderRight = `${sz}px ${borderStyle} ${borderColor}`;
        styleObj.paddingRight = space;
      }

      if (shd && !this.isListGroupAvailable) {
        for (const key in DEFAULT_SHD_STYLES) {
          if (typeof styleObj[key] === 'number') {
            styleObj[key] += DEFAULT_SHD_STYLES[key];
          } else {
            styleObj[key] = DEFAULT_SHD_STYLES[key];
          }
        }

        styleObj.backgroundColor = _everUtils.ShdUtil.transformShd(shd);
        styleObj.marginBottom = DEFAULT_SHD_MARGIN_BOTTOM;
      }

      if (isInUnlistGroupContainer(node, controller)) {
        styleObj.paddingLeft = (Number(styleObj.paddingLeft) || 0) + EXTRA_PADDING;
      }

      if (visible === false) {
        styleObj.display = 'none';
      }

      return styleObj;
    }

    render() {
      const {
        node,
        step: propStep = '',
        nodeRef
      } = this.props;
      const listConfig = node.data.list;
      const isList = !!listConfig;

      const paragraph = /*#__PURE__*/_createElement(Paragraph, (0, _extends2.default)({
        isList: isList,
        ref: nodeRef
      }, this.props));

      if (!isList) {
        return paragraph;
      }

      const {
        isOrdered,
        isTaskList,
        isChecked,
        level = 0,
        listId,
        listStyle,
        listStyleType,
        hideSymbol,
        symbolStyle = _utils.SYMBOL_STYLE
      } = listConfig;
      const stepArray = propStep.split('.');
      const propStart = stepArray[stepArray.length - 1] || '1';
      const {
        start = propStart,
        step = propStep
      } = node.data;
      const listSymbol = isTaskList ? '' : (0, _utils.generateSymbol)(level, Number(start), step, isOrdered, listStyleType, listStyle);
      const taskListConfig = {
        isTaskList,
        isChecked,
        isOrdered
      };
      return /*#__PURE__*/_createElement(_utils.ListItemWrapper, {
        align: this.align,
        style: this.getStyle(),
        "data-testid": "list",
        "data-start": start,
        "data-listid": listId,
        "data-level": level,
        "data-isordered": isOrdered,
        "data-istasklist": isTaskList,
        "data-ischecked": isChecked,
        "data-format": listStyleType?.format,
        "data-text": listStyleType?.text,
        "data-align": listStyleType?.align
      }, /*#__PURE__*/_createElement(_utils.GroupListContainer, {
        style: this.getGroupListStyle()
      }, /*#__PURE__*/_createElement(_utils.RenderStyledListItem, {
        hideSymbol: hideSymbol,
        listSymbol: listSymbol,
        symbolAlign: this.symbolAlign,
        symbolStyle: (0, _utils.convertSymbolStyle)(symbolStyle, isOrdered),
        taskListConfig: taskListConfig
      }, paragraph)));
    }

  }

  ;
  return /*#__PURE__*/_react.default.forwardRef((props, ref) => {
    return /*#__PURE__*/_createElement(ListItem, (0, _extends2.default)({}, props, {
      nodeRef: ref
    }));
  });
}
//# sourceMappingURL=createListItem.js.map