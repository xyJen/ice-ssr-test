"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createInjectToNode = exports.injectToNode = exports.getListOrderData = exports.getListOrder = exports.getSymbolByListOrder = exports.getListOrderDataById = exports.createListCountContext = void 0;

var _everCangjie = require("@ali/4ever-cangjie");

var _generateSymbol = require("./generateSymbol");

var _everUtils = require("@ali/4ever-utils");

const createListCountContext = () => ({
  itemCount: new Map()
});
/**
 * 根据列表 id 获取列表序号
 * @param root parent blocks
 * @param id 列表 id
 */


exports.createListCountContext = createListCountContext;

const getListOrderDataById = (nodes, id) => {
  const itemCountMap = new Map();
  const results = [];
  nodes.forEach(n => {
    // 线上存在 listId 一样的列表但是类型不一样，需要做一下过滤，只对有序列表做计算
    if (!_everCangjie.Block.isBlock(n) || !n.data.list || !!id && n.data.list.listId !== id) {
      return;
    }

    const {
      listId,
      level: lvl,
      start: listStart,
      isOrdered
    } = n.data.list;
    const level = Math.max(lvl, 0);
    const {
      itemCount,
      prevLevel
    } = itemCountMap.get(listId) || createListCountContext();

    if (!isOrdered) {
      clearOrderCount(level, itemCount, prevLevel);
      itemCountMap.set(listId, {
        itemCount,
        prevLevel: level
      });
      return;
    } // 如果有 节点有 start 字段，序号从指定 start 开始


    if (typeof listStart === 'number') {
      itemCount.set(level, listStart - 1);
    }

    const start = getListOrder(level, itemCount, prevLevel);
    const step = Array(level + 1).fill(1).map((value, index) => itemCount.get(index) || value).join('.');
    itemCountMap.set(listId, {
      itemCount,
      prevLevel: level
    });
    results.push({
      key: n.key,
      data: {
        start,
        step,
        listId
      }
    });
  });
  return results;
};

exports.getListOrderDataById = getListOrderDataById;

const getSymbolByListOrder = (data, itemCountMap) => {
  const {
    list
  } = data;

  if (list && list.isOrdered) {
    const {
      listId = '',
      level: lvl = 0,
      isOrdered = true,
      listStyle,
      listStyleType,
      start: listStart
    } = list;
    const level = Math.max(lvl, 0);
    const {
      itemCount,
      prevLevel
    } = itemCountMap.get(listId) || createListCountContext(); // 如果有 节点有 start 字段，序号从指定 start 开始

    if (typeof listStart === 'number') {
      itemCount.set(level, listStart - 1);
    }

    const start = getListOrder(level, itemCount, prevLevel);
    const step = Array(level + 1).fill(1).map((value, index) => itemCount.get(index) || value).join('.');
    itemCountMap.set(listId, {
      itemCount,
      prevLevel: level
    });
    return (0, _generateSymbol.generateSymbol)(level, start, step, isOrdered, listStyleType, listStyle);
  }

  return undefined;
};

exports.getSymbolByListOrder = getSymbolByListOrder;

const clearOrderCount = (level, orderCount, prevLevel) => {
  const largerThanCurrent = !!prevLevel && prevLevel > level; // 如果前一项 level 大于当前 level 就清空所有比当前大的计数

  if (largerThanCurrent) {
    for (const lvl of orderCount.keys()) {
      if (lvl > level) {
        orderCount.delete(lvl);
      }
    }
  }
};

const getListOrder = (level, orderCount, prevLevel) => {
  const itemCount = orderCount.get(level);
  const largerThanCurrent = !!prevLevel && prevLevel > level;
  const tempOrder = largerThanCurrent ? 2 : 1; // word 中第一项默认从 1 开始，但是如果前一项 level 大于当前 level 就从 2 开始

  const listOrder = typeof itemCount === 'undefined' ? tempOrder : itemCount + 1;
  clearOrderCount(level, orderCount, prevLevel);
  orderCount.set(level, listOrder);
  return listOrder;
}; // 存在多个编辑器实例，则需要根据不同实例的列表做处理，map 是文档中所有列表的缓存。 key 是 listId


exports.getListOrder = getListOrder;

const getListOrderData = (controller, undividedList = []) => {
  // 遍历中对列表项目计数的缓存 key: listId
  const itemCountMap = new Map();
  const results = [];
  const {
    value
  } = controller;
  const {
    injections,
    document
  } = value;
  controller.value.document.forEachDescendant(n => {
    // 线上存在 listId 一样的列表但是类型不一样，需要做一下过滤
    if (!_everCangjie.Block.isBlock(n) || !n.data.list) {
      return;
    }

    const parent = document.getParent(n.key);
    const {
      listId,
      level: lvl,
      start: listStart,
      isOrdered
    } = n.data.list;
    const level = Math.max(lvl, 0);
    const itemCountMapKey = listId + (parent && !undividedList.includes(parent?.type) && parent?.key) || '';
    const {
      itemCount,
      prevLevel
    } = itemCountMap.get(itemCountMapKey) || createListCountContext(); // 无序列表仍要根据 level 清理。有序列表会出现跨无序连续的问题
    // ● AAA              expect:  ● AAA
    //   a. BBB                      a. BBB
    // ● CCC       ->              ● CCC
    //   b. DDD                      a. DDD

    if (!isOrdered) {
      clearOrderCount(level, itemCount, prevLevel);
      itemCountMap.set(itemCountMapKey, {
        itemCount,
        prevLevel: level
      });
      return;
    } // 如果有 节点有 start 字段，序号从指定 start 开始


    if (typeof listStart === 'number') {
      itemCount.set(level, listStart - 1);
    }

    const start = getListOrder(level, itemCount, prevLevel);
    const step = Array(Math.max(level + 1, 0)).fill(1).map((val, index) => itemCount.get(index) || val).join('.');
    itemCountMap.set(itemCountMapKey, {
      itemCount,
      prevLevel: level
    });

    const injection = _everCangjie.Injection.create({
      key: n.key,
      data: {
        start,
        step,
        listId,
        isSelected: !!injections.find(i => i.key === n.key)?.data.isSelected
      }
    });

    results.push(injection);
  });
  return results;
};

exports.getListOrderData = getListOrderData;

const isHotsContainList = controller => {
  return controller.hasHots() && controller.hots.hots.some(hot => (0, _everUtils.isListNode)(hot.node) || !!hot.node.findDescendant(_everUtils.isListNode));
};

const injectToNode = (node, controller, next) => {
  const others = next() || []; // TODO: @灯少 更好的做法时，列表 `injectNode` 可以支持不从 Document 计算，当 node 为热区时，仅重算热区下的列表

  if (_everCangjie.Document.isDocument(node) || isHotsContainList(controller)) {
    // 递归计算文档中所有的列表序号
    const injections = getListOrderData(controller);
    return [...others, ...injections];
  }

  return others;
};

exports.injectToNode = injectToNode;

const createInjectToNode = listConfig => {
  const undividedList = listConfig.undividedList || [];
  return (node, controller, next) => {
    const others = next() || [];

    if (_everCangjie.Document.isDocument(node) || isHotsContainList(controller)) {
      // 递归计算文档中所有的列表序号
      const injections = getListOrderData(controller, undividedList);
      return [...others, ...injections];
    }

    return others;
  };
};

exports.createInjectToNode = createInjectToNode;
//# sourceMappingURL=putListOrder.js.map