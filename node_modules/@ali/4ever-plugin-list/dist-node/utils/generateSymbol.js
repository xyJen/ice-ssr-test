"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateSymbol = generateSymbol;
exports.RELATIVE_LEVEL = void 0;

var _listStyleMapping = require("./listStyleMapping");

var _transformNumber = require("./transformNumber");

const RELATIVE_LEVEL = [0, 1, 2];
exports.RELATIVE_LEVEL = RELATIVE_LEVEL;
const REG_DEC_DEC_DEC = /%\d(.%\d)+/;

const isContinuousDec = listStyle => {
  // 处理导入没有 listStyleType 的 连续数字类型(如：2.1.1)的列表
  return listStyle?.format === 'decimal' && REG_DEC_DEC_DEC.test(listStyle.text);
};

const getListSymbolTuple = (isOrdered, relativeLevel, listStyle) => {
  if (listStyle) {
    const {
      format,
      text,
      align
    } = listStyle;
    return [format, text, align];
  } else {
    const listTypeName = isOrdered ? _listStyleMapping.DEFAULT_NUMBER_LIST_ARRAY[0] : _listStyleMapping.DEFAULT_BULLET_LIST_ARRAY[0];
    return _listStyleMapping.mapping[listTypeName][relativeLevel];
  }
};

function generateSymbol(level, start, step, isOrdered, listStyleType, listStyle) {
  const remainder = level % 3; // 旧列表的level存在负数跟小数会导致all[listTypeName][relativeLevel]返回的是undefined，数组结构失败，所以用RELATIVE_LEVEL处理

  const relativeLevel = RELATIVE_LEVEL.includes(remainder) ? remainder : 0;
  const listSymbolTuple = getListSymbolTuple(isOrdered, relativeLevel, listStyle);
  const [type, pattern] = listSymbolTuple;
  let listSymbol = pattern || ''; // process number symbol, if match %number pattern
  // TODO 暂时保留listStyleType字段，未来依赖上下文判断列表类型

  if (listStyleType === _listStyleMapping.DEFAULT_NUMBER_LIST_ARRAY[2] || isContinuousDec(listStyle)) {
    return `${step}.`;
  } else if (RegExp(/%\d/).test(listSymbol)) {
    listSymbol = listSymbol.replace(/(%\d)/g, () => (0, _transformNumber.transformNumber)(start, type));
  }

  return listSymbol;
}
//# sourceMappingURL=generateSymbol.js.map