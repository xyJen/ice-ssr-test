{"version":3,"sources":["../../../src/utils/putListOrder.ts"],"names":["createListCountContext","itemCount","Map","getListOrderDataById","nodes","id","itemCountMap","results","forEach","n","Block","isBlock","data","list","listId","level","lvl","start","listStart","isOrdered","Math","max","prevLevel","get","clearOrderCount","set","getListOrder","step","Array","fill","map","value","index","join","push","key","getSymbolByListOrder","listStyle","listStyleType","undefined","orderCount","largerThanCurrent","keys","delete","tempOrder","listOrder","getListOrderData","controller","undividedList","injections","document","forEachDescendant","parent","getParent","itemCountMapKey","includes","type","val","injection","Injection","create","isSelected","find","i","isHotsContainList","hasHots","hots","some","hot","node","findDescendant","isListNode","injectToNode","next","others","Document","isDocument","createInjectToNode","listConfig"],"mappings":"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","sourcesContent":["import {\n  Node,\n  Controller,\n  Injection,\n  Block,\n  Data,\n  Document,\n} from '@ali/4ever-cangjie';\nimport { ListProperties } from './types';\nimport { generateSymbol } from './generateSymbol';\nimport { isListNode } from '@ali/4ever-utils';\n\nexport interface ListCountContext {\n  itemCount: Map<number, number>;\n  prevLevel?: number;\n}\n\ninterface ListData {\n  key: string;\n  data: {\n    start: number;\n    step: string;\n    listId: string;\n  };\n}\n\nexport const createListCountContext = (): ListCountContext => ({\n  itemCount: new Map<number, number>(),\n});\n\n/**\n * 根据列表 id 获取列表序号\n * @param root parent blocks\n * @param id 列表 id\n */\nexport const getListOrderDataById = (\n  nodes: Array<Node | null>,\n  id?: string,\n) => {\n  const itemCountMap = new Map<string, ListCountContext>();\n  const results: ListData[] = [];\n\n  nodes.forEach((n) => {\n    // 线上存在 listId 一样的列表但是类型不一样，需要做一下过滤，只对有序列表做计算\n    if (\n      !Block.isBlock(n) ||\n      !n.data.list ||\n      (!!id && n.data.list.listId !== id)\n    ) {\n      return;\n    }\n\n    const { listId, level: lvl, start: listStart, isOrdered } = n.data.list;\n    const level = Math.max(lvl, 0);\n    const { itemCount, prevLevel } =\n      itemCountMap.get(listId) || createListCountContext();\n\n    if (!isOrdered) {\n      clearOrderCount(level, itemCount, prevLevel);\n      itemCountMap.set(listId, { itemCount, prevLevel: level });\n      return;\n    }\n\n    // 如果有 节点有 start 字段，序号从指定 start 开始\n    if (typeof listStart === 'number') {\n      itemCount.set(level, listStart - 1);\n    }\n    const start = getListOrder(level, itemCount, prevLevel);\n    const step = Array(level + 1)\n      .fill(1)\n      .map((value, index) => itemCount.get(index) || value)\n      .join('.');\n    itemCountMap.set(listId, { itemCount, prevLevel: level });\n\n    results.push({\n      key: n.key,\n      data: { start, step, listId },\n    });\n  });\n\n  return results;\n};\n\nexport const getSymbolByListOrder = (\n  data: Data,\n  itemCountMap: Map<string, ListCountContext>,\n) => {\n  const { list } = data;\n\n  if (list && list.isOrdered) {\n    const {\n      listId = '',\n      level: lvl = 0,\n      isOrdered = true,\n      listStyle,\n      listStyleType,\n      start: listStart,\n    } = list as ListProperties;\n    const level = Math.max(lvl, 0);\n    const { itemCount, prevLevel } =\n      itemCountMap.get(listId) || createListCountContext();\n\n    // 如果有 节点有 start 字段，序号从指定 start 开始\n    if (typeof listStart === 'number') {\n      itemCount.set(level, listStart - 1);\n    }\n\n    const start = getListOrder(level, itemCount, prevLevel);\n    const step = Array(level + 1)\n      .fill(1)\n      .map((value, index) => itemCount.get(index) || value)\n      .join('.');\n    itemCountMap.set(listId, { itemCount, prevLevel: level });\n    return generateSymbol(\n      level,\n      start,\n      step,\n      isOrdered,\n      listStyleType,\n      listStyle,\n    );\n  }\n\n  return undefined;\n};\n\nconst clearOrderCount = (\n  level,\n  orderCount: Map<number, number>,\n  prevLevel?: number,\n) => {\n  const largerThanCurrent = !!prevLevel && prevLevel > level;\n  // 如果前一项 level 大于当前 level 就清空所有比当前大的计数\n  if (largerThanCurrent) {\n    for (const lvl of orderCount.keys()) {\n      if (lvl > level) {\n        orderCount.delete(lvl);\n      }\n    }\n  }\n};\n\nexport const getListOrder = (\n  level: number,\n  orderCount: Map<number, number>,\n  prevLevel?: number,\n) => {\n  const itemCount = orderCount.get(level);\n  const largerThanCurrent = !!prevLevel && prevLevel > level;\n  const tempOrder = largerThanCurrent ? 2 : 1;\n  // word 中第一项默认从 1 开始，但是如果前一项 level 大于当前 level 就从 2 开始\n  const listOrder =\n    typeof itemCount === 'undefined' ? tempOrder : itemCount + 1;\n\n  clearOrderCount(level, orderCount, prevLevel);\n\n  orderCount.set(level, listOrder);\n\n  return listOrder;\n};\n\n// 存在多个编辑器实例，则需要根据不同实例的列表做处理，map 是文档中所有列表的缓存。 key 是 listId\n\nexport const getListOrderData = (\n  controller: Controller,\n  undividedList: string[] = [],\n) => {\n  // 遍历中对列表项目计数的缓存 key: listId\n  const itemCountMap = new Map<string, ListCountContext>();\n  const results: Injection[] = [];\n  const { value } = controller;\n  const { injections, document } = value;\n  controller.value.document.forEachDescendant((n) => {\n    // 线上存在 listId 一样的列表但是类型不一样，需要做一下过滤\n    if (!Block.isBlock(n) || !n.data.list) {\n      return;\n    }\n    const parent = document.getParent(n.key);\n    const { listId, level: lvl, start: listStart, isOrdered } = n.data.list;\n    const level = Math.max(lvl, 0);\n    const itemCountMapKey =\n      listId +\n        (parent && !undividedList.includes(parent?.type) && parent?.key) || '';\n    const { itemCount, prevLevel } =\n      itemCountMap.get(itemCountMapKey) || createListCountContext();\n\n    // 无序列表仍要根据 level 清理。有序列表会出现跨无序连续的问题\n    // ● AAA              expect:  ● AAA\n    //   a. BBB                      a. BBB\n    // ● CCC       ->              ● CCC\n    //   b. DDD                      a. DDD\n    if (!isOrdered) {\n      clearOrderCount(level, itemCount, prevLevel);\n      itemCountMap.set(itemCountMapKey, { itemCount, prevLevel: level });\n      return;\n    }\n\n    // 如果有 节点有 start 字段，序号从指定 start 开始\n    if (typeof listStart === 'number') {\n      itemCount.set(level, listStart - 1);\n    }\n\n    const start = getListOrder(level, itemCount, prevLevel);\n    const step = Array(Math.max(level + 1, 0))\n      .fill(1)\n      .map((val, index) => itemCount.get(index) || val)\n      .join('.');\n    itemCountMap.set(itemCountMapKey, { itemCount, prevLevel: level });\n\n    const injection = Injection.create({\n      key: n.key,\n      data: {\n        start,\n        step,\n        listId,\n        isSelected: !!injections.find((i) => i.key === n.key)?.data.isSelected,\n      },\n    });\n\n    results.push(injection);\n  });\n\n  return results;\n};\n\nconst isHotsContainList = (controller: Controller) => {\n  return (\n    controller.hasHots() &&\n    controller.hots.hots.some(\n      (hot) => isListNode(hot.node) || !!hot.node.findDescendant(isListNode),\n    )\n  );\n};\n\nexport const injectToNode = (\n  node: Node,\n  controller: Controller,\n  next: () => Injection[],\n) => {\n  const others = next() || [];\n\n  // TODO: @灯少 更好的做法时，列表 `injectNode` 可以支持不从 Document 计算，当 node 为热区时，仅重算热区下的列表\n  if (Document.isDocument(node) || isHotsContainList(controller)) {\n    // 递归计算文档中所有的列表序号\n    const injections = getListOrderData(controller);\n    return [...others, ...injections];\n  }\n\n  return others;\n};\n\nexport const createInjectToNode = (listConfig) => {\n  const undividedList: string[] = listConfig.undividedList || [];\n  return (node: Node, controller: Controller, next: () => Injection[]) => {\n    const others = next() || [];\n\n    if (Document.isDocument(node) || isHotsContainList(controller)) {\n      // 递归计算文档中所有的列表序号\n      const injections = getListOrderData(controller, undividedList);\n      return [...others, ...injections];\n    }\n    return others;\n  };\n};\n"],"file":"putListOrder.js"}