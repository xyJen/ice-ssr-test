"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertMarkToSymbolStyle = convertMarkToSymbolStyle;
exports.getSymbolStyle = getSymbolStyle;
exports.getSymbolStyleByKey = getSymbolStyleByKey;
exports.convertSymbolStyle = convertSymbolStyle;
exports.parseSymbolMarks = parseSymbolMarks;

var _everCangjie = require("@ali/4ever-cangjie");

var _everPluginMarks = require("@ali/4ever-plugin-marks");

var _everUtils = require("@ali/4ever-utils");

// 移动端不支持Arial字体，默认字体显示的项目符号过大，通过视觉对比确定缩小系数
const SYMBOL_SIZE_LOWER = 0.8;

function convertMarkToSymbolStyle(mark) {
  switch (mark.type) {
    case 'highlight':
      return {
        shd: mark.data.value
      };

    case 'fonts':
      return {
        fonts: mark.data.ascii
      };

    case 'bold':
      return {
        bold: mark.data.value ?? true
      };

    case 'strike':
      return {
        strike: mark.data.value ?? true
      };

    case 'italic':
      return {
        italic: mark.data.value ?? true
      };

    case 'underline':
      return {};

    default:
      return {
        [mark.type]: mark.data.value
      };
  }
}

function getSymbolStyle(controller) {
  const {
    data,
    document
  } = controller.value;
  const listSelections = data.listSelections || [];

  if (listSelections.length > 0) {
    const block = document.getNode(listSelections[0]); // @ts-ignore

    if (block?.data?.list?.symbolStyle) {
      // @ts-ignore
      return block.data.list.symbolStyle;
    }
  }

  return null;
}

function getSymbolStyleByKey(controller, key) {
  const symbolStyle = getSymbolStyle(controller);
  let result;

  if (symbolStyle && key) {
    result = symbolStyle[key];
  }

  return result;
}

function convertSymbolStyle(symbolStyle, isOrdered) {
  const result = {};
  if (!symbolStyle) return result;
  const shouldDegradeGradient = symbolStyle.shd && symbolStyle.color && (0, _everUtils.isGradientColor)(symbolStyle.color);

  for (const styleName in symbolStyle) {
    if (symbolStyle[styleName]) {
      let markStyle;

      switch (styleName) {
        case 'fonts':
          markStyle = {
            type: styleName,
            data: {
              ascii: symbolStyle[styleName],
              hAnsi: symbolStyle[styleName],
              cs: symbolStyle[styleName],
              eastAsia: symbolStyle[styleName]
            }
          };
          break;

        case 'sz':
          markStyle = {
            type: styleName,
            data: {
              // 由于移动端无序列表符号过大，使用px按比例缩小一些
              value: (!isOrdered && _everCangjie.environment.IS_MOBILE ? SYMBOL_SIZE_LOWER : 1) * (symbolStyle[styleName] || 11),
              szUnit: 'pt'
            }
          };
          break;

        case 'shd':
          // 通用的样式转换不识别这种不规范的数据格式，这里转换一下
          markStyle = {
            type: 'highlight',
            data: {
              value: symbolStyle[styleName]
            }
          };
          break;

        default:
          if (styleName === 'color' && shouldDegradeGradient) {
            markStyle = {
              type: 'color',
              data: {
                value: (0, _everUtils.transferGradientColor)(symbolStyle[styleName])[0]
              }
            };
          } else {
            markStyle = {
              type: styleName,
              data: {
                value: symbolStyle[styleName]
              }
            };
          }

          break;
      }

      (0, _everPluginMarks.setStyleWithMark)(result, markStyle);
    }
  }

  return result;
}

function parseSymbolMarks(symbolStyle, isOrdered) {
  if (!symbolStyle) {
    return [];
  }

  const marks = [];
  Object.keys(symbolStyle).forEach(styleName => {
    if (symbolStyle[styleName]) {
      switch (styleName) {
        case 'fonts':
          {
            marks.push(_everCangjie.Mark.create({
              type: styleName,
              data: {
                ascii: symbolStyle[styleName],
                hAnsi: symbolStyle[styleName],
                cs: symbolStyle[styleName],
                eastAsia: symbolStyle[styleName]
              }
            }));
            break;
          }

        case 'sz':
          {
            marks.push(_everCangjie.Mark.create({
              type: styleName,
              data: {
                // 由于移动端无序列表符号过大，使用px按比例缩小一些
                value: (!isOrdered && _everCangjie.environment.IS_MOBILE ? SYMBOL_SIZE_LOWER : 1) * (symbolStyle[styleName] || 11),
                szUnit: 'pt'
              }
            }));
            break;
          }

        default:
          {
            marks.push(_everCangjie.Mark.create({
              type: styleName,
              data: {
                value: symbolStyle[styleName]
              }
            }));
          }
      }
    }
  });
  return marks;
}
//# sourceMappingURL=getSymbolStyleByKey.js.map