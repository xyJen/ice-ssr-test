"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _everUtils = require("@ali/4ever-utils");

var _lodash = require("lodash");

var _utils = require("./utils");

var _constants = require("./constants");

function parseFromWeb() {
  let currentListType = '';
  let nestDepth = 0;
  const idMap = {};
  return {
    name: 'list',
    onOpenTag: (state, name, attr) => {
      if (!_utils.listTags[name]) return false;
      const style = attr.styleObj;
      const ind = {};
      const listType = style.listStyleType || style.listStyle || attr.type;

      if (name === 'ol' || name === 'ul') {
        // 兼容 list-style、list-style-type
        state.wrapList(name === 'ol' ? 'ordered-list' : 'unordered-list');
        /**
         * 优先处理zhi的list
         * 避免使用原来的listId, 导致页面出现不期望的连续段落列表, ol情况下
         * 但是保留原来的level属性
         * TODO
         * 1. 如果复制到已有列表当中, 则需要拿到上下文数据.
         * 2. 需要补全 Bi => ASL => Zhi => Copy HTML => Bi 的链路测试, 保证
         * 预览模式下的插件复制到编辑模式下行为一致.
         */

        if (attr['data-listid']) {
          const parent = state.peek();
          const prevSibling = (0, _everUtils.getLastChild)(parent); // @ts-ignore

          const listData = (0, _everUtils.getAttributes)(prevSibling) || {};

          if (prevSibling === null || !listData.list) {
            state.currentListId = (0, _utils.getRandomId)(); // eslint-disable-line no-param-reassign
          } else {
            const currentListId = listData.list && listData.list.listId;
            state.currentListId = currentListId;
          }

          state.currentListLevel = parseInt(attr['data-level'], 10);
        } else if (attr.start && parseInt(attr.start) > 1) {
          // 当前列表 start 大于 1时，就近继承所有样式相同的列表的 id
          if (idMap[attr.style]) {
            state.currentListId = idMap[attr.style];
          }
        } else if (!state.currentListId || attr.start === '1') {
          state.currentListId = (0, _utils.getRandomId)(); // eslint-disable-line no-param-reassign
        } else if (!nestDepth && !attr.start) {
          state.currentListId = (0, _utils.getRandomId)();
        }

        idMap[attr.style] = state.currentListId;

        if (listType) {
          currentListType = listType;
        } else {
          currentListType = '';
        }

        nestDepth++;
      }

      if (name === 'li') {
        const listData = {
          listId: state.currentListId,
          isOrdered: state.isParentOrderedList(),
          level: state.currentListLevel || state.getListItemLevel()
        };
        const liListType = listType || currentListType;

        if (liListType) {
          const format = _constants.FORMAT_MAP[liListType] || 'bullet';
          const text = format !== 'bullet' ? '%1.' : _constants.TEXT_MAP[liListType] || '\u25cf'; // @ts-ignore

          listData.listStyle = {
            format,
            text,
            align: 'left'
          };
        }

        if (style.marginLeft) {
          ind.left = _everUtils.unitsConverter.toPX(style.marginLeft);
        }

        if (style.paddingLeft) {
          ind.left = (ind.left || 0) + _everUtils.unitsConverter.toPX(style.marginLeft);
        }

        const indData = (0, _lodash.isEmpty)(ind) ? {} : {
          ind
        };
        const li = ['p', { ...indData,
          list: listData
        }];
        state.push(li);
      }

      return true;
    },
    onCloseTag: (state, name) => {
      if (!_utils.listTags[name]) return false;

      if (name === 'ol' || name === 'ul') {
        state.unwrapList();
        nestDepth--;
      }

      if (name === 'li') {
        const li = state.pop();

        if ((0, _utils.shouldFlattenChildren)(li)) {
          const flattenedChildren = (0, _utils.getFlattenedChildren)(li);
          state.append(...flattenedChildren);
        } else if ((0, _everUtils.getChildren)(li).length) {
          state.append((0, _everUtils.normalizeJsonMLChildren)(li));
        }
      }

      return true;
    }
  };
}

var _default = parseFromWeb;
exports.default = _default;
//# sourceMappingURL=parseFromWeb.js.map