"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizeJsonMl = normalizeJsonMl;

var _everCangjie = require("@ali/4ever-cangjie");

var _putListOrder = require("./putListOrder");

/* eslint-disable no-restricted-imports */
// 用于判断两个 list 是否为同一个 list
// 判断依据：listId 相同，type 也相同
function assertSameList(list, anotherList) {
  return typeof list.listId === 'string' && typeof anotherList.listId === 'string' && list.listId === anotherList.listId;
}

function transformListNode(content) {
  const outerChildren = (0, _everCangjie.getChildren)(content);
  const attrs = (0, _everCangjie.getAttributes)(content);
  const {
    isOrdered = false
  } = attrs;
  const result = [isOrdered ? 'ol' : 'ul', { ...attrs
  }];
  /**
   * 将平铺的子节点转成为嵌套的列表树形结构
   *
   * @param nodes
   * @param path
   * @param prevLevel
   */

  const flatNodesToListTree = (nodes, path, prevLevel) => {
    let node = nodes.shift();
    const {
      list
    } = (0, _everCangjie.getAttributes)(node);
    const {
      level
    } = list;
    let curr;
    let parent = result;

    if (level === prevLevel) {
      curr = 0;

      for (let i = 0; i < path.length - 1; i++) {
        parent = (0, _everCangjie.getChildren)(parent)[path[i]];
      }

      if (path.length) {
        path[path.length - 1] += 1;
      } else {
        path = [0];
      }
    } else if (level < prevLevel) {
      curr = level - prevLevel;
      path = path.slice(0, path.length - (prevLevel - level) * 2);

      for (let i = 0; i < path.length - 1; i++) {
        parent = (0, _everCangjie.getChildren)(parent)[path[i]];
      }

      path[path.length - 1] += 1;
    } else if (level > prevLevel) {
      // 如果 level - prevLevel > 1，也按 1 来计算, 避免找不到上层节点
      curr = 1;

      for (let i = 0; i < path.length; i++) {
        parent = (0, _everCangjie.getChildren)(parent)[path[i]];
      }

      path = [...path, (0, _everCangjie.getChildren)(parent).length];
    }

    const children = (0, _everCangjie.getChildren)(parent);
    node = ['li', { ...(0, _everCangjie.getAttributes)(node)
    }, node];

    if (children.length > 0) {
      const last = (0, _everCangjie.getTagName)(children[children.length - 1]);

      if (['ul', 'ol', 'li'].indexOf(last) < 0) {
        const attrs = (0, _everCangjie.getAttributes)(node);
        const {
          isOrdered: innerIsOrdered = false
        } = attrs.list;
        node = [innerIsOrdered ? 'ol' : 'ul', { ...attrs.list
        }, node];
        path = [...path, 0];
      }
    }

    parent.push(node);

    if (nodes.length > 0) {
      flatNodesToListTree(nodes, path, prevLevel + curr);
    }
  };

  flatNodesToListTree(outerChildren, [], 0);
  return result;
} // 正规化渲染 HTML 的 Asl，主要解决平铺列表转为嵌套列表的问题


function normalize(content, countMap) {
  const nodes = (0, _everCangjie.getChildren)(content);
  const normalizeNodes = nodes.reduce((arr, node, index) => {
    const tag = (0, _everCangjie.getTagName)(node);
    const last = arr[arr.length - 1];

    if (tag === 'p') {
      const attrs = (0, _everCangjie.getAttributes)(node) || {};
      const {
        list
      } = attrs;
      const isLastIndex = index === nodes.length - 1; // 如果不是 list 节点

      if (!list) {
        // 上一个节点为 'list' 的话，需要对其进行转换
        if (last && (0, _everCangjie.getTagName)(last) === 'list') {
          const listNode = transformListNode(last);
          arr[arr.length - 1] = listNode;
        }

        arr.push(node);
        return arr;
      } // 序号计算


      const {
        itemCount,
        prevLevel
      } = countMap.get(list.listId) || (0, _putListOrder.createListCountContext)();
      const start = (0, _putListOrder.getListOrder)(list.level, itemCount, prevLevel);
      countMap.set(list.listId, {
        itemCount,
        prevLevel: list.level
      });
      node = ['p', {
        list: { ...list,
          start
        }
      }, ...(0, _everCangjie.getChildren)(node)];

      if (last && (0, _everCangjie.getTagName)(last) === 'list') {
        const next = [...last, node];
        const lastAttrs = (0, _everCangjie.getAttributes)(last) || {}; // 上一个节点为 'list'，并且和当前的 listId 相同则追加进去

        if (assertSameList(lastAttrs, list)) {
          arr[arr.length - 1] = isLastIndex ? transformListNode(next) : next;
        } else {
          // 否则说明是新的 list，要先把之前 list 进行转换
          arr[arr.length - 1] = transformListNode(last); // 然后再新建一个 list

          const newList = ['list', { ...list
          }, node];
          arr.push(isLastIndex ? transformListNode(newList) : newList);
        }
      } else if (isLastIndex) {
        // 当前为最后一个子节点，直接进行转换
        const listNode = transformListNode(['list', { ...list
        }, node]);
        arr.push(listNode);
      } else {
        arr.push(['list', { ...list,
          start
        }, node]);
      }
    } else {
      // 需要对上一个节点进行转换
      if (last && (0, _everCangjie.getTagName)(last) === 'list') {
        const list = transformListNode(last);
        arr[arr.length - 1] = list;
      } // table 存在嵌套的情况，需要循环处理下


      if (tag === 'table') {
        const trs = (0, _everCangjie.getChildren)(node).map(tr => {
          const tds = (0, _everCangjie.getChildren)(tr).map(td => normalize(td, countMap));
          return ['tr', { ...(0, _everCangjie.getAttributes)(tr)
          }, ...tds];
        });
        node = ['table', { ...(0, _everCangjie.getAttributes)(node)
        }, ...trs];
      }

      arr.push(node);
    }

    return arr;
  }, []);
  return [(0, _everCangjie.getTagName)(content), { ...(0, _everCangjie.getAttributes)(content)
  }, ...normalizeNodes];
}

function normalizeJsonMl(content) {
  const countMap = new Map();
  return normalize(content, countMap);
}
//# sourceMappingURL=normalizeJsonML.js.map