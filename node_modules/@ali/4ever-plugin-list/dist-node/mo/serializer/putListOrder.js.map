{"version":3,"sources":["../../../../src/mo/serializer/putListOrder.ts"],"names":["createListCountContext","itemCount","Map","clearOrderCount","level","orderCount","prevLevel","largerThanCurrent","lvl","keys","delete","getListOrder","get","tempOrder","listOrder","set","getListOrderDataById","nodes","id","itemCountMap","results","forEach","n","Block","isBlock","data","list","listId","start","listStart","isOrdered","Math","max","step","Array","fill","map","value","index","join","push","key","getListOrderData","root","Injection","create"],"mappings":"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","sourcesContent":["// 防止与Bi循环引用，mo中先单独列一份\nimport { Block, Document, Injection, BlockChildren } from '@ali/4ever-cangjie';\n\nexport interface ListCountContext {\n  itemCount: Map<number, number>;\n  prevLevel?: number;\n}\n\ninterface ListData {\n  key: string;\n  data: {\n    start: number;\n    step: string;\n    listId: string;\n  };\n}\n\nexport const createListCountContext = (): ListCountContext => ({\n  itemCount: new Map<number, number>(),\n});\n\nconst clearOrderCount = (level: number, orderCount: Map<number, number>, prevLevel?: number) => {\n  const largerThanCurrent = !!prevLevel && prevLevel > level;\n  // 如果前一项 level 大于当前 level 就清空所有比当前大的计数\n  if (largerThanCurrent) {\n    for (const lvl of orderCount.keys()) {\n      if (lvl > level) {\n        orderCount.delete(lvl);\n      }\n    }\n  }\n};\n\nexport const getListOrder = (\n  level: number,\n  orderCount: Map<number, number>,\n  prevLevel?: number,\n) => {\n  const itemCount = orderCount.get(level);\n  const largerThanCurrent = !!prevLevel && prevLevel > level;\n  const tempOrder = largerThanCurrent ? 2 : 1;\n  // word 中第一项默认从 1 开始，但是如果前一项 level 大于当前 level 就从 2 开始\n  const listOrder = typeof itemCount === 'undefined' ? tempOrder : itemCount + 1;\n\n  clearOrderCount(level, orderCount, prevLevel);\n\n  orderCount.set(level, listOrder);\n\n  return listOrder;\n};\n\nconst getListOrderDataById = (nodes: BlockChildren, id?: string) => {\n  const itemCountMap = new Map<string, ListCountContext>();\n  const results: ListData[] = [];\n\n  nodes.forEach((n) => {\n    // 线上存在 listId 一样的列表但是类型不一样，需要做一下过滤，只对有序列表做计算\n    if (\n      !Block.isBlock(n) ||\n      !n.data.list ||\n      (!!id && n.data.list.listId !== id)\n    ) {\n      return;\n    }\n\n    const { listId, level: lvl, start: listStart, isOrdered } = n.data.list;\n    const level = Math.max(lvl, 0);\n    const { itemCount, prevLevel } =\n      itemCountMap.get(listId) || createListCountContext();\n\n    if (!isOrdered) {\n      clearOrderCount(level, itemCount, prevLevel);\n      itemCountMap.set(listId, { itemCount, prevLevel: level });\n      return;\n    }\n\n    // 如果有 节点有 start 字段，序号从指定 start 开始\n    if (typeof listStart === 'number') {\n      itemCount.set(level, listStart - 1);\n    }\n\n    const start = getListOrder(level, itemCount, prevLevel);\n    const step = Array(level + 1)\n      .fill(1)\n      .map((value, index) => itemCount.get(index) || value)\n      .join('.');\n    itemCountMap.set(listId, { itemCount, prevLevel: level });\n\n    results.push({\n      key: n.key,\n      data: { start, step, listId },\n    });\n  });\n\n  return results;\n};\n\nexport function getListOrderData(root: Document | Block, listId: string) {\n  const results = getListOrderDataById(root.nodes, listId);\n  return results.map((data) => Injection.create(data));\n}\n"],"file":"putListOrder.js"}