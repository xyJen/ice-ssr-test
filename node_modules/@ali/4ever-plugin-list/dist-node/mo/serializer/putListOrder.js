"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getListOrderData = getListOrderData;
exports.getListOrder = exports.createListCountContext = void 0;

var _everCangjie = require("@ali/4ever-cangjie");

// 防止与Bi循环引用，mo中先单独列一份
const createListCountContext = () => ({
  itemCount: new Map()
});

exports.createListCountContext = createListCountContext;

const clearOrderCount = (level, orderCount, prevLevel) => {
  const largerThanCurrent = !!prevLevel && prevLevel > level; // 如果前一项 level 大于当前 level 就清空所有比当前大的计数

  if (largerThanCurrent) {
    for (const lvl of orderCount.keys()) {
      if (lvl > level) {
        orderCount.delete(lvl);
      }
    }
  }
};

const getListOrder = (level, orderCount, prevLevel) => {
  const itemCount = orderCount.get(level);
  const largerThanCurrent = !!prevLevel && prevLevel > level;
  const tempOrder = largerThanCurrent ? 2 : 1; // word 中第一项默认从 1 开始，但是如果前一项 level 大于当前 level 就从 2 开始

  const listOrder = typeof itemCount === 'undefined' ? tempOrder : itemCount + 1;
  clearOrderCount(level, orderCount, prevLevel);
  orderCount.set(level, listOrder);
  return listOrder;
};

exports.getListOrder = getListOrder;

const getListOrderDataById = (nodes, id) => {
  const itemCountMap = new Map();
  const results = [];
  nodes.forEach(n => {
    // 线上存在 listId 一样的列表但是类型不一样，需要做一下过滤，只对有序列表做计算
    if (!_everCangjie.Block.isBlock(n) || !n.data.list || !!id && n.data.list.listId !== id) {
      return;
    }

    const {
      listId,
      level: lvl,
      start: listStart,
      isOrdered
    } = n.data.list;
    const level = Math.max(lvl, 0);
    const {
      itemCount,
      prevLevel
    } = itemCountMap.get(listId) || createListCountContext();

    if (!isOrdered) {
      clearOrderCount(level, itemCount, prevLevel);
      itemCountMap.set(listId, {
        itemCount,
        prevLevel: level
      });
      return;
    } // 如果有 节点有 start 字段，序号从指定 start 开始


    if (typeof listStart === 'number') {
      itemCount.set(level, listStart - 1);
    }

    const start = getListOrder(level, itemCount, prevLevel);
    const step = Array(level + 1).fill(1).map((value, index) => itemCount.get(index) || value).join('.');
    itemCountMap.set(listId, {
      itemCount,
      prevLevel: level
    });
    results.push({
      key: n.key,
      data: {
        start,
        step,
        listId
      }
    });
  });
  return results;
};

function getListOrderData(root, listId) {
  const results = getListOrderDataById(root.nodes, listId);
  return results.map(data => _everCangjie.Injection.create(data));
}
//# sourceMappingURL=putListOrder.js.map