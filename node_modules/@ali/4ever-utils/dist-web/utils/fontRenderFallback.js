import { FONTS_INFO, FALLBACK_STRATEGIES_CN } from "../theme/fonts";
import SimpleMapCache from "./simpleMapCache";

var FontRenderFallback = /*#__PURE__*/function () {
  /**
   * 存储降级策略
   */

  /**
   * 字体名和降级策略的索引
   */

  /**
   * 简易缓存，减少计算消耗
   */
  function FontRenderFallback() {
    this.STRATEGY_ARRAY = [];
    this.FALLBACK_INDEX_MAP = new Map();
    this.CACHE_MAP = {};
    this.simpleCache = new SimpleMapCache();
    this.simpleBTBDCache = new SimpleMapCache();
    this.init();
  }

  var _proto = FontRenderFallback.prototype;

  _proto.getCommonFallbackStrategy = function getCommonFallbackStrategy(generic) {
    return FALLBACK_STRATEGIES_CN[generic] || [];
  };

  _proto.getFallbackStrategy = function getFallbackStrategy(font) {
    var family = font.family,
        generic = font.generic,
        chinesefamily = font.chinesefamily,
        fallback = font.fallback; // 只对中文做通用降级

    var commonFallback = chinesefamily ? this.getCommonFallbackStrategy(generic) : []; // 优先级：font.fallback > family > chinesefamily > commonFallback > generic

    var fallbackStrategy = fallback != null && fallback.length ? [].concat(fallback) : [family, chinesefamily || ''].concat(commonFallback, [generic]); // 过滤下

    return Array.from(new Set(fallbackStrategy.filter(function (item) {
      return item;
    })));
  };

  _proto.cacheStrategy = function cacheStrategy(strategy, btbd) {
    var key = strategy.toString();
    var cached = this.CACHE_MAP[key];
    if (cached !== undefined) return cached;
    this.STRATEGY_ARRAY.push({
      fontFamily: strategy,
      btbd: btbd
    });
    var index = this.STRATEGY_ARRAY.length - 1;
    this.CACHE_MAP[key] = index;
    return index;
  };

  _proto.updateFallbackIndex = function updateFallbackIndex(keys, fallbackIndex) {
    var _this = this;

    keys.forEach(function (key) {
      if (key) {
        _this.FALLBACK_INDEX_MAP.set(key, fallbackIndex);
      }
    });
  };

  _proto.init = function init() {
    var _this2 = this;

    FONTS_INFO.forEach(function (font) {
      var family = font.family,
          chinesefamily = font.chinesefamily,
          _font$weights = font.weights,
          weights = _font$weights === void 0 ? [] : _font$weights,
          _font$charSets = font.charSets,
          charSets = _font$charSets === void 0 ? [] : _font$charSets,
          postScriptName = font.postScriptName,
          btbd = font.btbd;

      var fallbackStrategy = _this2.getFallbackStrategy(font);

      var cachedIndex = _this2.cacheStrategy(fallbackStrategy, btbd); // 添加英文和中文索引


      _this2.updateFallbackIndex([family, chinesefamily], cachedIndex); // 中英文都支持字符集和字重（例如 仿宋_GB2312 或 微软雅黑 bold ）


      [family, chinesefamily].forEach(function (name) {
        for (var i = 0; i <= charSets.length; i++) {
          var fontName = name; // 拼接 charset

          var charset = charSets[i];

          if (charset) {
            fontName += "_" + charset;
          }

          if (!weights.length) {
            _this2.updateFallbackIndex([fontName], cachedIndex);

            continue;
          }

          var nameWithWeights = [];

          for (var j = 0; j < weights.length; j++) {
            // 拼接 weight
            var weight = weights[j];
            var nameWithWeight = fontName + " " + weight;

            if (postScriptName) {
              // Chrome 不识别 family Light，需要换成 postScriptName-light
              var newStrategy = [postScriptName + "-" + weight].concat(fallbackStrategy);
              cachedIndex = _this2.cacheStrategy(newStrategy, btbd);

              _this2.updateFallbackIndex([nameWithWeight], cachedIndex);

              continue;
            } else {
              nameWithWeights.push(nameWithWeight);
            }
          }

          _this2.updateFallbackIndex(nameWithWeights, cachedIndex);
        }
      });
    });
  };

  _proto.getSupportFonts = function getSupportFonts() {
    return Array.from(this.FALLBACK_INDEX_MAP).map(function (item) {
      return item[0];
    });
  };

  _proto.getFontBTBD = function getFontBTBD(font) {
    if (!font) return 1; // 先走缓存逻辑

    var cachedValue = this.simpleBTBDCache.get(font);
    if (cachedValue) return cachedValue;
    var fonts = font.split(',');
    var btbd = 1;

    for (var i = 0; i < fonts.length; i++) {
      var fallbackIndex = this.FALLBACK_INDEX_MAP.get(fonts[i]);

      if (fallbackIndex !== undefined) {
        btbd = this.STRATEGY_ARRAY[fallbackIndex].btbd || 1;
        break;
      }
    }

    this.simpleBTBDCache.add(font, btbd);
    return btbd;
  };

  _proto.getFontFallback = function getFontFallback(mark) {
    var _mark$data = mark.data,
        ascii = _mark$data.ascii,
        eastAsia = _mark$data.eastAsia,
        cs = _mark$data.cs,
        hAnsi = _mark$data.hAnsi,
        hint = _mark$data.hint; // 先走缓存逻辑

    var cacheKey = ascii + "_" + eastAsia + "_" + cs + "_" + hAnsi + "_" + hint;
    var cachedValue = this.simpleCache.get(cacheKey);
    if (cachedValue) return cachedValue; // 只对中英文降级，暂不处理 cs 和 hAnsi

    var fonts = [ascii, eastAsia];

    if (mark.data[hint]) {
      // 优先跟踪 hint
      fonts = [mark.data[hint]];
    }

    var fontsArray = Array.from(new Set(fonts.filter(function (f) {
      return f;
    })));
    var fallbackFonts = [];

    for (var i = 0; i < fontsArray.length; i++) {
      var font = fontsArray[i];
      var fallbackIndex = this.FALLBACK_INDEX_MAP.get(font);

      if (fallbackIndex === undefined) {
        fallbackFonts.push(font);
        continue;
      }

      var strategy = this.STRATEGY_ARRAY[fallbackIndex];
      fallbackFonts = fallbackFonts.concat([font].concat(strategy.fontFamily));
    }

    fallbackFonts.push(cs, hAnsi);
    cachedValue = Array.from(new Set(fallbackFonts.filter(function (f) {
      return f;
    }))).toString();
    this.simpleCache.add(cacheKey, cachedValue);
    return cachedValue;
  };

  return FontRenderFallback;
}();

var fontRenderFallback = new FontRenderFallback();
export default fontRenderFallback;
//# sourceMappingURL=fontRenderFallback.js.map