/* eslint-disable no-param-reassign */
import { environment } from '@ali/4ever-cangjie';
var UL_CSS_MAP = {
  dash: 'dashed',
  single: 'solid',
  wave: 'wavy'
};

function strAppend(prev, current) {
  return prev ? prev + " " + current : current;
}

function addWebkitPrefix(style) {
  Object.keys(style).forEach(function (key) {
    if (/^textDecoration|^textUnderline/.test(key)) {
      var k = "Webkit" + key[0].toUpperCase() + key.slice(1);
      style[k] = style[key];
    }
  });
}
/**
 * 设置 CSS 文字修饰
 * textDecorationStyle 只允许一个值，因此 underline 和 双删除线无法共存
 * @param style
 * @param type
 * @param underline
 */


function setTextDecotation(style, type, mark) {
  var _mark$data, _mark$data2;

  if (type === 'underline') {
    // 兼容 mark = {type: 'underline'} 的生成方式
    var _ref = mark.data || {},
        _ref$value = _ref.value,
        value = _ref$value === void 0 ? 'single' : _ref$value,
        color = _ref.color;

    var underlineStyle = UL_CSS_MAP[value] || value; // 跳过不支持的样式

    if (!underlineStyle || underlineStyle === 'none') return; // 下划线优先级更高：直接覆盖 textDecorationStyle

    style.textDecorationStyle = underlineStyle;
    style.textDecorationLine = strAppend(style.textDecorationLine, 'underline');

    if (color) {
      style.textDecorationColor = color;
    } // BACKGROUND: 
    //   https://aone.alibaba-inc.com/v2/bug/35006381# 《【0615文字bvt】文本设置样式后取消下划线重新设置异常》
    //   Android 下有时候会出现取消下划线时仍渲染下划线的情况。
    //   但实际上代码确实是正确的，当出现问题后又触发重新渲染（例如取消选区、增大字号等操作），则奇怪的下划线就会消失。
    //   通过注释下面的样式，问题消失。
    // HOW:
    //   这里暂时通过让 Android 下不使用 textUnderlinePosition 这个属性来避免
    //   后续可以评估下通过类似 boxShadow: '0 1px' 等方式来实现下划线效果是否可行


    if (!environment.IS_ANDROID) {
      style.textUnderlinePosition = 'under';
    }

    return addWebkitPrefix(style);
  }

  if (type === 'strike' && ((_mark$data = mark.data) == null ? void 0 : _mark$data.value) !== false) {
    style.textDecorationLine = strAppend(style.textDecorationLine, 'line-through');
    return addWebkitPrefix(style);
  }

  if (type === 'dstrike' && ((_mark$data2 = mark.data) == null ? void 0 : _mark$data2.value) !== false) {
    if (!style.textDecorationStyle) {
      // 优先级低于 underline：仅在没有设置 textDecorationStyle (没有下划线）的情况下设置
      style.textDecorationStyle = 'double';
    }

    style.textDecorationLine = strAppend(style.textDecorationLine, 'line-through');
    return addWebkitPrefix(style);
  }
}

export default {
  setTextDecotation: setTextDecotation
};
//# sourceMappingURL=underline.js.map