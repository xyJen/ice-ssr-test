import { environment } from '@ali/4ever-cangjie';
import SimpleCache from "./Cache";
export var CJK_REG = /[\u4E00-\u9FA5]/;
var MEASURE_CACHE_SIZE = 1000;
var CJK_REG_GLOBAL = /[\u4E00-\u9FA5]/ig;
var TEXT_SSR_WIDTH = {
  '.': 1.225,
  ')': 1.38
};

/**
 * 供非 Web 端粗略计算字符宽高使用
 * 中文字符（宽 = fontSize, 高 = fontSize）
 * 非中文字符（宽= fontSize / 2, 高 = fontSize）
 */
export function getTextWidthOnServer(text, fontSize) {
  var zhChars = text.match(CJK_REG_GLOBAL) || [];
  var width = (zhChars.length + (text.length - zhChars.length) / 2) * fontSize;
  return {
    // TEXT_SSR_WIDTH 纯粹为了对齐实际测量结果
    width: (TEXT_SSR_WIDTH[text] || 1) * width,
    height: fontSize
  };
}

var Measure = /*#__PURE__*/function () {
  function Measure() {
    var _this = this;

    this.container = void 0;
    this.measurer = void 0;
    this.measureCache = new SimpleCache(MEASURE_CACHE_SIZE);

    this.measureSingleText = function (text, font, sz) {
      if (environment.IS_NODE) {
        return getTextWidthOnServer(text, parseFloat(sz));
      }

      var measureText = text;

      if (text.length === 1 && CJK_REG.test(text)) {
        measureText = '中';
      }

      var cacheKey = measureText + font + sz;

      var cache = _this.measureCache.get(cacheKey);

      if (cache) {
        return cache;
      }

      _this.ensureMeasurer();

      _this.measurer.textContent = measureText;
      _this.measurer.style.fontFamily = font || 'unset';
      _this.measurer.style.fontSize = sz || 'unset';

      var rect = _this.measurer.getBoundingClientRect();

      var measureInfo = {
        width: rect.width,
        height: rect.height
      };

      _this.measureCache.set(cacheKey, measureInfo);

      return measureInfo;
    };

    this.measureTextWidth = function (chars, font, sz) {
      var textWidth = 0; // TODO: 不会有性能问题么，不能一次性测量完？

      for (var i = chars.length - 1; i >= 0; i--) {
        var measureInfo = _this.measureSingleText(chars[i], font, sz);

        textWidth += measureInfo.width;
      }

      return textWidth;
    };

    this.warmup = function (batch) {
      var tasks = [];
      Object.keys(batch).forEach(function (_char) {
        var fontFamilies = batch[_char];
        Object.keys(fontFamilies).forEach(function (fontFamily) {
          var sizes = fontFamilies[fontFamily];
          sizes.forEach(function (size) {
            tasks.push({
              "char": _char,
              fontFamily: fontFamily,
              size: size
            });
          });
        });
      });

      _this.ensureMeasurer();

      var container = _this.container;
      tasks.map(function (task) {
        var measurer = document.createElement('span');
        measurer.textContent = task["char"];
        measurer.style.fontFamily = task.fontFamily || 'unset';
        measurer.style.fontSize = task.size || 'unset';
        container.appendChild(measurer);
        return {
          task: task,
          measurer: measurer
        };
      }).map(function (_ref) {
        var task = _ref.task,
            measurer = _ref.measurer;
        var cacheKey = task["char"] + task.fontFamily + task.size;
        var rect = measurer.getBoundingClientRect();
        var measureInfo = {
          width: rect.width,
          height: rect.height
        };

        _this.measureCache.set(cacheKey, measureInfo);

        return measurer;
      }).forEach(function (measurer) {
        return container.removeChild(measurer);
      });
    };
  }

  var _proto = Measure.prototype;

  _proto.ensureMeasurer = function ensureMeasurer() {
    if (!this.container) {
      var container = document.createElement('div');
      container.style.bottom = '-100px';
      container.style.position = 'fixed';
      container.style.visibility = 'hidden';
      container.style.zIndex = '-999';
      container.style.whiteSpace = 'nowrap';
      document.body.appendChild(container);
      this.container = container;
    }

    if (!this.measurer) {
      var measurer = document.createElement('span');
      this.container.appendChild(measurer);
      this.measurer = measurer;
    }
  };

  return Measure;
}();

export default Measure;
//# sourceMappingURL=measure.js.map