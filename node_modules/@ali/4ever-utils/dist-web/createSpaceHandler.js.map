{"version":3,"sources":["../../src/createSpaceHandler.ts"],"names":["Commands","Mark","getMarkTextMatchInfo","hasMark","maybeMark","mark","delimiter","insideWhitespace","alwaysTrailSpace","create","event","controller","next","value","selection","startText","document","isExpanded","isMark","type","startOffset","convertToTextPoints","start","offset","text","slice","delimiters","Array","isArray","matchedInfo","config","hitDelimiter","newStart","size","preventDefault","path","getPath","key","command","moveAnchorTo","moveFocusTo","del","newEnd","total","toggleMark","removeMark","hasPrevSpace","insertText","dispatch","mdType"],"mappings":"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","sourcesContent":["import { Controller, Commands, Mark, MarkProperties } from '@ali/4ever-cangjie';\nimport { Delimiter, OffsetInfo, getMarkTextMatchInfo } from './biUtils';\nimport hasMark from './hasMark';\n\nexport type { Delimiter };\n\ninterface CreateSpaceHandlerOptions {\n  mark: string | MarkProperties;\n  delimiter: Delimiter | Delimiter[]; // 标识符定义\n  insideWhitespace?: boolean; // 是否允许标识符内侧空白符，默认为 false\n  alwaysTrailSpace?: boolean; // 是否需要转换后始终跟空格，默认为 false\n}\n\nexport default ({ mark: maybeMark, delimiter, insideWhitespace, alwaysTrailSpace }: CreateSpaceHandlerOptions) => {\n  const mark = Mark.create(maybeMark);\n  return (event, controller: Controller, next) => {\n    const { value } = controller;\n    const { selection, startText, document } = value;\n    if (!startText) return controller;\n\n    if (selection.isExpanded) return next();\n\n    const isMark = hasMark(value, mark.type);\n    if (isMark) return next();\n\n    const startOffset = selection.convertToTextPoints(document).start.offset;\n    const text = startText.text.slice(0, startOffset);\n\n    if (!text) return next();\n\n    const delimiters = Array.isArray(delimiter) ? delimiter : [delimiter];\n\n    let matchedInfo: { delimiter: Delimiter; offset: OffsetInfo } | null = null;\n    for (const config of delimiters) {\n      const offset = getMarkTextMatchInfo(text, config, insideWhitespace);\n      if (offset) {\n        matchedInfo = { delimiter: config, offset };\n        break;\n      }\n    }\n\n    if (!matchedInfo) {\n      return next();\n    }\n\n    const { offset, delimiter: hitDelimiter } = matchedInfo;\n    const newStart = offset!.start - hitDelimiter.size;\n\n    event.preventDefault();\n\n    const path = document.getPath(startText.key);\n    if (!path) return controller;\n\n    controller\n      // 删除前面 triggerText\n      .command(Commands.moveAnchorTo, path, newStart)\n      .command(Commands.moveFocusTo, path, offset!.start)\n      .command(Commands.del);\n\n    const newEnd = newStart + offset!.total; // 此时前面的 triggerText 已经被删除\n    controller\n      // 删除后面 triggerText\n      .command(Commands.moveAnchorTo, path, newEnd)\n      .command(Commands.moveFocusTo, path, newEnd + hitDelimiter.size)\n      .command(Commands.del)\n      // 选中文字并更新样式.\n      .command(Commands.moveAnchorTo, path, newStart)\n      .command(Commands.moveFocusTo, path, newEnd)\n      .command(Commands.toggleMark, mark)\n      // 聚焦到粗体文字最后，并取消样式.\n      .command(Commands.moveAnchorTo, path, newEnd)\n      .command(Commands.moveFocusTo, path, newEnd)\n      // .command(Commands.toggleMark, mark)\n      .command(Commands.removeMark, mark);\n    // 仅当前面有空格时，为后面加上空格(配置了 alwaysTrailSpace=true 的除外)。理由如下：\n    // > 英文场景单词之间都有空格，mark 的文字大概率以单词为单位\n    // > 中文场景下，字、标点符号之间一般不会有空格，有空格的情况大多是人为故意添加的，前面有空格大概率后面也会有\n    // > 即便错误地不加空格，输入空格的成本还是小于按 backspace 的成本的，用户心情也不一样\n    const hasPrevSpace = newStart > 0 ? text[newStart - 1] === ' ' : false;\n    if (alwaysTrailSpace || hasPrevSpace) {\n      controller.command(Commands.insertText, ' '); // 插入一个空格，完成格式化.\n    }\n\n    // @ts-ignore\n    return controller.dispatch('createTriggerMarkdownAction', { mdType: mark.type });\n  };\n};\n"],"file":"createSpaceHandler.js"}