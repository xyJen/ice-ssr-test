function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import { Commands, Mark } from '@ali/4ever-cangjie';
import { getMarkTextMatchInfo } from "./biUtils";
import hasMark from "./hasMark";
export default (function (_ref) {
  var maybeMark = _ref.mark,
      delimiter = _ref.delimiter,
      insideWhitespace = _ref.insideWhitespace,
      alwaysTrailSpace = _ref.alwaysTrailSpace;
  var mark = Mark.create(maybeMark);
  return function (event, controller, next) {
    var value = controller.value;
    var selection = value.selection,
        startText = value.startText,
        document = value.document;
    if (!startText) return controller;
    if (selection.isExpanded) return next();
    var isMark = hasMark(value, mark.type);
    if (isMark) return next();
    var startOffset = selection.convertToTextPoints(document).start.offset;
    var text = startText.text.slice(0, startOffset);
    if (!text) return next();
    var delimiters = Array.isArray(delimiter) ? delimiter : [delimiter];
    var matchedInfo = null;

    for (var _iterator = _createForOfIteratorHelperLoose(delimiters), _step; !(_step = _iterator()).done;) {
      var config = _step.value;

      var _offset = getMarkTextMatchInfo(text, config, insideWhitespace);

      if (_offset) {
        matchedInfo = {
          delimiter: config,
          offset: _offset
        };
        break;
      }
    }

    if (!matchedInfo) {
      return next();
    }

    var _matchedInfo = matchedInfo,
        offset = _matchedInfo.offset,
        hitDelimiter = _matchedInfo.delimiter;
    var newStart = offset.start - hitDelimiter.size;
    event.preventDefault();
    var path = document.getPath(startText.key);
    if (!path) return controller;
    controller // 删除前面 triggerText
    .command(Commands.moveAnchorTo, path, newStart).command(Commands.moveFocusTo, path, offset.start).command(Commands.del);
    var newEnd = newStart + offset.total; // 此时前面的 triggerText 已经被删除

    controller // 删除后面 triggerText
    .command(Commands.moveAnchorTo, path, newEnd).command(Commands.moveFocusTo, path, newEnd + hitDelimiter.size).command(Commands.del) // 选中文字并更新样式.
    .command(Commands.moveAnchorTo, path, newStart).command(Commands.moveFocusTo, path, newEnd).command(Commands.toggleMark, mark) // 聚焦到粗体文字最后，并取消样式.
    .command(Commands.moveAnchorTo, path, newEnd).command(Commands.moveFocusTo, path, newEnd) // .command(Commands.toggleMark, mark)
    .command(Commands.removeMark, mark); // 仅当前面有空格时，为后面加上空格(配置了 alwaysTrailSpace=true 的除外)。理由如下：
    // > 英文场景单词之间都有空格，mark 的文字大概率以单词为单位
    // > 中文场景下，字、标点符号之间一般不会有空格，有空格的情况大多是人为故意添加的，前面有空格大概率后面也会有
    // > 即便错误地不加空格，输入空格的成本还是小于按 backspace 的成本的，用户心情也不一样

    var hasPrevSpace = newStart > 0 ? text[newStart - 1] === ' ' : false;

    if (alwaysTrailSpace || hasPrevSpace) {
      controller.command(Commands.insertText, ' '); // 插入一个空格，完成格式化.
    } // @ts-ignore


    return controller.dispatch('createTriggerMarkdownAction', {
      mdType: mark.type
    });
  };
});
//# sourceMappingURL=createSpaceHandler.js.map