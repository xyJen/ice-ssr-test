{"version":3,"sources":["../../src/biUtils.ts"],"names":["re","bold","italic","strike","subscript","superscript","underline","link","mention","inlineCode","getMatches","value","regex","startText","startOffset","text","string","slice","match","replace","getOffset","snippetEnd","snippet","borderSize","start","length","end","total","punctuationRegExp","whitespaceRegExp","isIntraword","matchedStr","delimiterRunSize","prevSnippetLength","prevChar","test","getMatchInfo","delimiter","size","disableIntraword","offset","intraword","getMarkTextMatchInfo","insideWhitespace","character","trim","RegExp","normalMatches","whiteSpaceMatches"],"mappings":"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","sourcesContent":["/**\n * @deprecated we-editor 内没有找到其他依赖这处的地方，但由于 export 出去了，暂时先保留，后续没问题可以删掉\n * 行内对象正则\n */\n/* eslint-disable */\nexport const re = {\n  bold: /\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)$/,\n  italic: /\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)+$/,\n  strike: /~~([\\s\\S]+?)~~(?!~)$/,\n  subscript: /~((?:~~|[\\s\\S])+?)~$/,\n  superscript: /\\^((?:\\^\\^|[\\s\\S])+?)\\^$/,\n  underline: /\\+\\+([\\s\\S]+?)\\+\\+(?!\\+)$/,\n  link:/\\[((?:\\[[^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*)\\]\\(\\s*<?((?:\\\\\\(|\\\\\\)|\\\\\\\"|\\\\\\'|[^()\"'])*)>?(?:\\s+['\"]((?:\\\\\\(|\\\\\\)|\\\\\\\"|\\\\\\'|[^()\"'])*?)['\"])?\\s*\\)/,\n  mention: /@([\\w\\u4e00-\\u9fa5\\_\\-\\.]*)/,\n  inlineCode: /(\\`)([^`\\r\\n]+)(\\`)/,\n};\n\n/**\n * 匹配行内对象\n */\nexport const getMatches = (value, regex) => {\n  const { startText, startOffset } = value;\n  const { text } = startText;\n  const string = text.slice(0, startOffset);\n  const match = string.match(regex);\n  if (!match) return null;\n  match[0] = match[0].replace(/^\\s+/, '');\n  return match;\n};\n\nexport interface OffsetInfo {\n  start: number;\n  end: number;\n  total: number;\n}\n\n/**\n * 获取字符的位置信息\n */\nexport const getOffset = (snippetEnd, snippet, borderSize): OffsetInfo => ({\n  start: snippetEnd - snippet.length + borderSize,\n  end: snippetEnd - borderSize,\n  total: snippet.length - 2 * borderSize,\n});\n\n// Reference: https://github.com/commonmark/commonmark.js/blob/master/lib/inlines.js#L38\nconst punctuationRegExp = /^[!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E42\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]|\\uD800[\\uDD00-\\uDD02\\uDF9F\\uDFD0]|\\uD801\\uDD6F|\\uD802[\\uDC57\\uDD1F\\uDD3F\\uDE50-\\uDE58\\uDE7F\\uDEF0-\\uDEF6\\uDF39-\\uDF3F\\uDF99-\\uDF9C]|\\uD804[\\uDC47-\\uDC4D\\uDCBB\\uDCBC\\uDCBE-\\uDCC1\\uDD40-\\uDD43\\uDD74\\uDD75\\uDDC5-\\uDDC9\\uDDCD\\uDDDB\\uDDDD-\\uDDDF\\uDE38-\\uDE3D\\uDEA9]|\\uD805[\\uDCC6\\uDDC1-\\uDDD7\\uDE41-\\uDE43\\uDF3C-\\uDF3E]|\\uD809[\\uDC70-\\uDC74]|\\uD81A[\\uDE6E\\uDE6F\\uDEF5\\uDF37-\\uDF3B\\uDF44]|\\uD82F\\uDC9F|\\uD836[\\uDE87-\\uDE8B]/;\nconst whitespaceRegExp = /^[\\t ]/\n\nfunction isIntraword(text: string, matchedStr: string, delimiterRunSize: number) {\n  const prevSnippetLength = text.length - matchedStr.length;\n  if (prevSnippetLength === 0) {\n    return false;\n  }\n  const prevChar = text[prevSnippetLength - 1];\n  return !whitespaceRegExp.test(prevChar) && !punctuationRegExp.test(prevChar);\n}\n\nfunction getMatchInfo(text: string, matchedStr: string, delimiter: Delimiter) {\n  const { size, disableIntraword } = delimiter;\n  const offset = getOffset(text.length, matchedStr, size);\n  const intraword = isIntraword(text, matchedStr, size); // 前面不为空白或标点\n  if (disableIntraword && intraword) { // 不允许 intraword\n    return null;\n  }\n  return offset;\n}\n\nexport interface Delimiter {\n  character: string; // 标识字符，例如 *, _\n  size: number; // 标识符长度，标识符长度，例如 **foo** 表示加粗的话，该值为 2\n  disableIntraword?: boolean; // 禁止 intraword\n}\n\n/**\n * 获取 mark text 的 match 信息\n * 若符合 mark 规则，则返回 offset，否则返回 null\n * 规则：标识符前后无相同标识字符 + 允许 intraword（_ 除外） + 标识符内侧无空白（可配置）\n * 例如：\n * 以 bold 为例，insideWhitespace 为 false\n * * valid: [**abc**] [a**bc**] [a **bc**] [**a b c**] [a **b**c**](c 为加粗)\n * * invalid: [*abc_] [*abc*] [** abc **] [a__bc__]\n *\n * @param {string} text 待检测的字符串\n * @param {Delimiter} delimiter 标识符定义\n * @param {boolean} insideWhitespace 是否允许标识符内侧无空白\n */\nexport function getMarkTextMatchInfo(text: string, delimiter: Delimiter, insideWhitespace = false) {\n  const { character, size, disableIntraword } = delimiter;\n  // 排除为空白字符串、仅包含 delimiter 的情况\n  if (!text.trim() || RegExp(`^(\\\\${character})*$`).test(text)) {\n    return null;\n  }\n\n  // 判断 仅包含「非 delimiter 且 非空白」的字符 or 允许空白符的情况\n  const normalMatches = text.match(RegExp(\n    // 例如 bold: \\*{2}      (     [^\\*\\s]+       )          \\*{2} $\n    `\\\\${character}{${size}}([^\\\\${character}${insideWhitespace ? '' : '\\\\s'}]+)\\\\${character}{${size}}$`\n  ));\n  if (normalMatches) {\n    return getMatchInfo(text, normalMatches[0], delimiter);\n  }\n\n  if (!insideWhitespace) {\n    // 不允许内侧空白符时，需要校验标识符内侧有无空白符\n    const whiteSpaceMatches = text.match(RegExp(\n      // 例如 bold: \\*{2}      (     [^\\*\\s]+             [^\\*]*            [^\\*\\s]+        )    \\*{2} $\n      `\\\\${character}{${size}}([^\\\\${character}\\\\s]+[^\\\\${character}]*[^\\\\${character}\\\\s]+)\\\\${character}{${size}}$`\n    ));\n    if (whiteSpaceMatches) {\n      return getMatchInfo(text, whiteSpaceMatches[0], delimiter);\n    }\n  }\n\n  return null;\n}\n"],"file":"biUtils.js"}