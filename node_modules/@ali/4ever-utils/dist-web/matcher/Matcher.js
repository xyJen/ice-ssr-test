import { levenshtein } from "./levenshtein";

/**
 * 匹配模式
 */
var MatchMode;
/**
 * 获取匹配得分
 * @param mode 匹配模式
 * @param position 子串的位置
 * @param relevance 1 - 编辑距离/关键词长度
 *
 * ### 匹配得分计算公式
 *
 * 将匹配分数分为 3 个区间，若在某一个区间中两项相等，则比较下一个区间的大小，否则则以当前区间的分数类排序
 *
 * *设计思想：将 3 个区间分别用 4 位来表示，每个区间的取值是 0-15，将每个区间的值依次填充，然后比较最终的得分即可*
 *
 * *score = 0x[mode][position][relevance]*
 */

(function (MatchMode) {
  MatchMode[MatchMode["Substring"] = 0] = "Substring";
  MatchMode[MatchMode["Levenshtein"] = 1] = "Levenshtein";
})(MatchMode || (MatchMode = {}));

function getMatchScore(mode, position, relevance) {
  var num = 0x000; // 区间一：填充匹配模式

  if (mode === MatchMode.Substring) {
    num |= 0x100;
  } else if (mode === MatchMode.Levenshtein) {
    num |= 0x000;
  }

  if (mode === MatchMode.Substring) {
    // 区间二：填充子串模式的位置
    num |= Math.max(0xf - position, 0) << 4;
  } else if (mode === MatchMode.Levenshtein) {
    // 区间三：填充编辑距离的相似度
    num |= relevance * 15 & 0xf;
  } // 评分区间 0-1，匹配模式的最大值是 0x100，所以这里分母是 0x1ff


  return num / 0x1ff * 100;
}

/**
 * 空白符正则表达式
 */
var WHITE_SPACE_REG = /\s/g;
/**
 * 搜索工具库
 *
 * @example
 *
 * const matcher = new Matcher({
 *   lang: 'en-US',
 *   items: [
 *     {
 *       keywords: ['Table'],
 *       data: {
 *         key: 'table',
 *       }
 *     },
 *     {
 *       keywords: ['Template'],
 *       data: {
 *         key: 'template',
 *       }
 *     },
 *     {
 *       keywords: ['Temple'],
 *       data: {
 *         key: 'temple',
 *       }
 *     }
 *   ],
 * });
 *
 * const rs = matcher.match('tem);
 */

var Matcher = /*#__PURE__*/function () {
  function Matcher(options) {
    this.items = void 0;
    this.lang = void 0;
    this.leafOnly = void 0;
    this.enableFuzzy = void 0;
    this.threshold = void 0;
    var items = options.items,
        lang = options.lang,
        _options$leafOnly = options.leafOnly,
        leafOnly = _options$leafOnly === void 0 ? false : _options$leafOnly,
        _options$enableFuzzy = options.enableFuzzy,
        enableFuzzy = _options$enableFuzzy === void 0 ? false : _options$enableFuzzy,
        _options$threshold = options.threshold,
        threshold = _options$threshold === void 0 ? 0.75 : _options$threshold;
    this.items = items;
    this.lang = lang;
    this.leafOnly = leafOnly;
    this.enableFuzzy = enableFuzzy;
    this.threshold = threshold;
  }

  var _proto = Matcher.prototype;

  _proto.buildItemResult = function buildItemResult(item, score) {
    var _item$subItems,
        _this = this;

    return {
      score: score,
      data: item.data,
      subItems: (_item$subItems = item.subItems) == null ? void 0 : _item$subItems.map(function (subItem) {
        return _this.buildItemResult(subItem, score);
      })
    };
  };

  _proto.matchKeywords = function matchKeywords(query, keywords) {
    var matchPosition = -1;

    for (var i = 0; i < keywords.length; i++) {
      var keyword = keywords[i]; // TODO: 考虑对 keyword 的 normalize 行为做缓存

      var $keyword = keyword.replace(WHITE_SPACE_REG, '').toLowerCase();
      var index = $keyword.indexOf(query);

      if (index !== -1) {
        if (matchPosition === -1 || index < matchPosition) {
          matchPosition = index;
        }
      }
    } // 子串匹配不校验相似度门槛


    if (matchPosition !== -1) {
      return getMatchScore(MatchMode.Substring, matchPosition, 0);
    } // 允许模糊匹配


    if (this.enableFuzzy) {
      var maxRelevance = 0;

      for (var _i = 0; _i < keywords.length; _i++) {
        var _keyword = keywords[_i]; // TODO: 考虑对 keyword 的 normalize 行为做缓存

        var _$keyword = _keyword.replace(WHITE_SPACE_REG, '').toLowerCase();

        var distance = levenshtein(query, _$keyword);
        var relevance = 1 - distance / _$keyword.length; // 若当前关键词的相似度大于最大值，则更新 index

        if (relevance > maxRelevance) {
          maxRelevance = relevance;
        }
      } // 仅当相似度大于模糊匹配的门槛时返回匹配项


      if (maxRelevance >= this.threshold) {
        return getMatchScore(MatchMode.Levenshtein, 0xf, maxRelevance);
      }
    }

    return 0;
  }
  /**
   * 节点搜索，搜索此节点以及所有的子节点，此节点的权重为其所有子节点的最大值
   * @param query
   * @param item
   * @returns
   */
  ;

  _proto.matchItem = function matchItem(query, item) {
    var score = this.matchKeywords(query, item.keywords); // 若支持搜索组，且组名能够匹配关键词，则返回组内所有节点

    if (!this.leafOnly && score > 0) {
      return this.buildItemResult(item, score);
    } // 若没有子项


    if (!item.subItems && score > 0) {
      return {
        score: score,
        data: item.data
      };
    } // 若存在子项，则搜索子项


    if (item.subItems) {
      var subResults = [];

      for (var i = 0; i < item.subItems.length; i++) {
        var subItem = item.subItems[i];
        var subResult = this.matchItem(query, subItem);

        if (subResult) {
          subResults.push(subResult);
        }
      }

      if (subResults.length === 0) {
        return null;
      }

      subResults.sort(function (a, b) {
        return b.score - a.score;
      });
      var firstItem = subResults[0];
      return {
        score: firstItem.score,
        data: item.data,
        subItems: subResults
      };
    }

    return null;
  };

  _proto.match = function match(query) {
    var res = [];
    var $query = query.replace(WHITE_SPACE_REG, '').toLowerCase();

    for (var i = 0; i < this.items.length; i++) {
      var item = this.items[i];
      var itemResult = this.matchItem($query, item);

      if (itemResult) {
        res.push(itemResult);
      }
    }

    if (res.length > 0) {
      res.sort(function (a, b) {
        return b.score - a.score;
      });
    }

    return res;
  };

  return Matcher;
}();

export default Matcher;
//# sourceMappingURL=Matcher.js.map