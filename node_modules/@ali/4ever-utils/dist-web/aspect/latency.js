import _extends from "@babel/runtime/helpers/extends";

/* eslint-disable @typescript-eslint/no-explicit-any */
import Debug from 'debug';
var debug = Debug('EDITOR:UTIL:ASPECT:LATENCY');

function onLatency(key, cost, success) {
  if (success === void 0) {
    success = true;
  }

  var status = success ? 'success' : 'failed';
  debug('Latency %s %c%s: %c%dms', status, 'color: dodgerblue', key, 'color: orange', cost);
}

export function connect(speed) {
  return function reporter(key, cost, success) {
    if (success === void 0) {
      success = true;
    }

    onLatency(key, cost, success);
    var status = success ? 'success' : 'failed';
    speed("latency_" + key + "_" + status, cost);
  };
}
/**
 * 函数计时打点，支持同步函数和异步函数计时
 * @param key 打点的 key
 * @param fn 装饰的函数
 * @param callback 自定义打点
 */

export function latency(key, fn, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$callback = _options.callback,
      callback = _options$callback === void 0 ? onLatency : _options$callback;
  return function _latency() {
    var start = Date.now();

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var rs = fn.apply(this, args); // 如果函数是 async 函数

    if (rs instanceof Promise && rs.then && rs["catch"]) {
      return rs.then(function (res) {
        callback(key, Date.now() - start, true);
        return res;
      })["catch"](function (err) {
        callback(key, Date.now() - start, false);
        throw err;
      });
    }

    callback(key, Date.now() - start);
    return rs;
  };
}
/**
 * 函数计时装饰器，支持同步函数和异步函数计时
 * @param key 打点计时 key
 */

export function Latency(key, options) {
  return function deco(target, propertyKey, descriptor) {
    if (!descriptor || typeof descriptor.value !== 'function') {
      throw new TypeError("Only methods can be decorated with @Latency. <" + String(propertyKey) + "> is not a method!");
    }

    return _extends({}, descriptor, {
      value: latency(key, descriptor.value, options)
    });
  };
}

function onFrameCallback(key, cost, type) {
  debug('Latency %s %c%s: %c%dms', type, 'color: dodgerblue', key, 'color: orange', cost);
}

// 计时器缓存
var frameMap = new Map();
/**
 * 记录当前执行点至下一帧的耗时，帧类型支持三种 frame | microtask | macrotask
 * @param key 计时 key
 * @param options
 */

export function latencyCurrentFrame(key, options) {
  if (options === void 0) {
    options = {};
  }

  var _options2 = options,
      _options2$leading = _options2.leading,
      leading = _options2$leading === void 0 ? true : _options2$leading,
      _options2$callback = _options2.callback,
      callback = _options2$callback === void 0 ? onFrameCallback : _options2$callback,
      _options2$type = _options2.type,
      type = _options2$type === void 0 ? 'frame' : _options2$type; // 如果缓存中有 key，则直接 return

  if (frameMap.has(key)) {
    // 非 leading 模式重置计时
    if (!leading) {
      frameMap.set(key, Date.now());
    }

    return;
  } // 计时结束


  function frameEnd() {
    var start = frameMap.get(key);
    frameMap["delete"](key);

    if (typeof start !== 'number' || isNaN(start)) {
      throw new Error("Cannot find start timer for key: " + key);
    }

    var cost = Date.now() - start;
    callback(key, cost, type);
  } // 设置计时起始点


  frameMap.set(key, Date.now());

  if (type === 'frame') {
    window.requestAnimationFrame(frameEnd);
  } else if (type === 'microtask') {
    Promise.resolve().then(frameEnd);
  } else if (type === 'macrotask') {
    window.setTimeout(frameEnd);
  } else {
    console.warn('Unexpected frame type: ', type);
    frameMap["delete"](key);
  }
}
/**
 * 装饰函数，记录从函数执行开始至下一帧的耗时
 * @param key 计时 key
 * @param fn 装饰的函数
 * @param options
 */

export function latencyFrame(key, fn, options) {
  return function _latency() {
    latencyCurrentFrame(key, options);

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return fn.apply(this, args);
  };
}
/**
 * 装饰方法，记录从函数执行开始至下一帧的耗时
 * @param key 计时 key
 * @param options
 */

export function LatencyFrame(key, options) {
  return function deco(target, propertyKey, descriptor) {
    if (!descriptor || typeof descriptor.value !== 'function') {
      throw new TypeError("Only methods can be decorated with @LatencyFrame. <" + String(propertyKey) + "> is not a method!");
    }

    return _extends({}, descriptor, {
      value: latencyFrame(key, descriptor.value, options)
    });
  };
}

var onTotalCallback = function onTotalCallback(key, cost, total) {
  debug('Latency total %c%s: %c%d/time %c%dms', 'color: dodgerblue', key, 'color: tomato', total, 'color: orange', cost);
};

/**
 * 记录一个函数在一个 task 内总共执行的次数以及耗时
 * @param key 计时 key
 * @param fn 计时函数
 * @param options
 */
export function latencyTotal(key, fn, options) {
  if (options === void 0) {
    options = {};
  }

  var _options3 = options,
      _options3$callback = _options3.callback,
      callback = _options3$callback === void 0 ? onTotalCallback : _options3$callback;
  var counting = false;
  var total = 0;
  var cost = 0;
  return function _latencyTotal() {
    var start = Date.now();

    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    var res = fn.apply(this, args);
    var onceCost = Date.now() - start;
    total += 1;
    cost += onceCost;

    if (!counting) {
      counting = true;
      Promise.resolve().then(function () {
        try {
          callback(key, cost, total);
        } finally {
          counting = false;
          total = 0;
          cost = 0;
        }
      });
    }

    return res;
  };
}
/**
 * 记录一个函数在一个 task 内总共执行的次数以及耗时
 * @param key 计时 key
 * @param options
 */

export function LatencyTotal(key, options) {
  return function deco(target, propertyKey, descriptor) {
    if (!descriptor || typeof descriptor.value !== 'function') {
      throw new TypeError("Only methods can be decorated with @LatencyTotal. <" + String(propertyKey) + "> is not a method!");
    }

    return _extends({}, descriptor, {
      value: latencyTotal(key, descriptor.value, options)
    });
  };
}
//# sourceMappingURL=latency.js.map