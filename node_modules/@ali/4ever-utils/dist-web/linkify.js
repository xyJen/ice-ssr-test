import Linkify from 'linkify-it';
import { memoize } from 'lodash-es';

function createLinkify(protocolAllowList) {
  if (protocolAllowList === void 0) {
    protocolAllowList = ['dingtalk:'];
  }

  var linkify = Linkify({
    fuzzyLink: false
  });
  protocolAllowList.filter(function (protocol) {
    return !['http:', 'https:'].includes(protocol);
  }).forEach(function (protocol) {
    linkify.add(protocol, 'http:');
  }); // HACK: 支持 domain 识别下划线, linkify 这边有对应的 pr,如果他合并了，可以直接更新
  // https://github.com/markdown-it/linkify-it/issues/95

  var orgin_src_domain = linkify.re.src_domain;
  var new_domain = '(?:' + linkify.re.src_xn + '|' + '(?:' + linkify.re.src_pseudo_letter + ')' + '|' + '(?:' + linkify.re.src_pseudo_letter + '(?:-|_|' + linkify.re.src_pseudo_letter + '){0,61}' + linkify.re.src_pseudo_letter + ')' + ')';
  updateRegex(linkify, orgin_src_domain, new_domain); // 非 fuzzy 状态下，会使用 str_xxx 进行拼接(性能消耗), 所以也需要替换

  updateSrc(linkify, orgin_src_domain, new_domain); // HACK: 中文字符后紧接链接也可以识别，之后可尝试向 linkify-it 提 MR 支持配置

  var origin_src_ZPCc = linkify.re.src_ZPCc;
  ;
  var new_src_ZPCc = linkify.re.src_ZPCc + "|[\u4E00-\u9FA5]";
  updateRegex(linkify, origin_src_ZPCc, new_src_ZPCc);
  return linkify;
}

function updateRegex(instance, pre, cur) {
  Object.keys(instance.re).forEach(function (name) {
    var rx = instance.re[name];

    if (rx instanceof RegExp) {
      // @ts-ignore
      var source = rx.source.split(pre).join(cur);
      instance.re[name] = RegExp(source, rx.flags);
    }
  });
}

function updateSrc(instance, pre, cur) {
  Object.keys(instance.re).forEach(function (name) {
    var rx = instance.re[name];

    if (typeof rx === 'string') {
      var source = rx.split(pre).join(cur); // @ts-ignore

      instance.re[name] = source;
    }
  });
}

export default memoize(createLinkify, function (list) {
  if (Array.isArray(list)) {
    return list.sort().reduce(function (a, b) {
      return a + b;
    }, '');
  }

  return list;
});
/**
 * 检查字符串是否包含链接（排除 URL 包含在 md 链接、图片语法内的情况）
 * @param linkify
 * @param text 待检查的字符串
 * @returns 若不包含链接，则返回 null，否则返回符合条件的 LinkifyIt.Match[]
 */

export function matchesLink(linkify, text) {
  var matches = linkify.match(text);

  if (!matches) {
    return matches;
  } // 对每个匹配为 URL 的字符串，向前后扩展到相邻的 URL，然后检查是否在链接、图片 markdown 语法中
  // 若匹配，则不转为 Link 元素


  var filtered = matches.filter(function (match, idx) {
    var beforeIndex = idx > 0 ? matches[idx - 1].lastIndex + 1 : 0;
    var afterIndex = idx < matches.length - 1 ? matches[idx + 1].index : text.length;
    var current = text.slice(beforeIndex, afterIndex); // linkify 的结果中 URL 有问题，可能包含 ()[]{} 且括号非成对出现
    // 括号不成对出现会导致正则对象创建失败，需要转义

    var url = Array.from(match.text).map(function (c) {
      return Array.from('/|?+.-[](){}').includes(c) ? "\\" + c : c;
    }).join('');

    try {
      return !new RegExp("\\[([^\\[\\]]*)\\]\\(" + url + "( \"(\\S\\s)?\\S+(\\s\\S)?\")?\\)").test(current);
    } catch (_unused) {
      return true;
    }
  });
  return filtered.length > 0 ? filtered : null;
}
//# sourceMappingURL=linkify.js.map