"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calcRotationObj = calcRotationObj;
exports.calcXAfterRotation = calcXAfterRotation;
exports.calcYAfterRotation = calcYAfterRotation;
exports.normalizeAngle = normalizeAngle;

function calcRotationObj(w, h, r) {
  r = r * Math.PI / 180;
  const diag = Math.sqrt(Math.pow(w, 2) + Math.pow(h, 2));
  const tlX = -(Math.cos(Math.atan(h / w) + r) * diag / 2);
  const tlY = -(Math.sin(Math.atan(h / w) + r) * diag / 2);
  const trX = Math.cos(Math.atan(h / w) - r) * diag / 2;
  const trY = -(Math.sin(Math.atan(h / w) - r) * diag / 2);
  const blX = -trX;
  const blY = -trY;
  const brX = -tlX;
  const brY = -tlY;
  const width = Math.round(Math.max(Math.abs(tlX), Math.abs(trX)) * 2);
  const height = Math.round(Math.max(Math.abs(tlY), Math.abs(trY)) * 2);
  const translateX = -Math.round(Math.min(tlX, trX, blX, brX) + w / 2);
  const translateY = -Math.round(Math.min(tlY, trY, blY, brY) + h / 2);
  return {
    rWidth: width,
    rHeight: height,
    translateX,
    translateY,
    tlX,
    tlY,
    trX,
    trY
  };
}

function calcXAfterRotation(x, y, rotation, translateX = 0) {
  return x * Math.cos(rotation / 180 * Math.PI) - y * Math.sin(rotation / 180 * Math.PI) + translateX;
}

function calcYAfterRotation(x, y, rotation, translateY = 0) {
  return x * Math.sin(rotation / 180 * Math.PI) + y * Math.cos(rotation / 180 * Math.PI) + translateY;
}

function normalizeAngle(angle, round = false) {
  // normalize to 0 - 360
  if (round) {
    angle = Math.round(angle);
  }

  return angle + Math.ceil(-angle / 360) * 360;
}
//# sourceMappingURL=calcRotation.js.map