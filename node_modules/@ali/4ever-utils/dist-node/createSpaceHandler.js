"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _everCangjie = require("@ali/4ever-cangjie");

var _biUtils = require("./biUtils");

var _hasMark = _interopRequireDefault(require("./hasMark"));

var _default = ({
  mark: maybeMark,
  delimiter,
  insideWhitespace,
  alwaysTrailSpace
}) => {
  const mark = _everCangjie.Mark.create(maybeMark);

  return (event, controller, next) => {
    const {
      value
    } = controller;
    const {
      selection,
      startText,
      document
    } = value;
    if (!startText) return controller;
    if (selection.isExpanded) return next();
    const isMark = (0, _hasMark.default)(value, mark.type);
    if (isMark) return next();
    const startOffset = selection.convertToTextPoints(document).start.offset;
    const text = startText.text.slice(0, startOffset);
    if (!text) return next();
    const delimiters = Array.isArray(delimiter) ? delimiter : [delimiter];
    let matchedInfo = null;

    for (const config of delimiters) {
      const offset = (0, _biUtils.getMarkTextMatchInfo)(text, config, insideWhitespace);

      if (offset) {
        matchedInfo = {
          delimiter: config,
          offset
        };
        break;
      }
    }

    if (!matchedInfo) {
      return next();
    }

    const {
      offset,
      delimiter: hitDelimiter
    } = matchedInfo;
    const newStart = offset.start - hitDelimiter.size;
    event.preventDefault();
    const path = document.getPath(startText.key);
    if (!path) return controller;
    controller // 删除前面 triggerText
    .command(_everCangjie.Commands.moveAnchorTo, path, newStart).command(_everCangjie.Commands.moveFocusTo, path, offset.start).command(_everCangjie.Commands.del);
    const newEnd = newStart + offset.total; // 此时前面的 triggerText 已经被删除

    controller // 删除后面 triggerText
    .command(_everCangjie.Commands.moveAnchorTo, path, newEnd).command(_everCangjie.Commands.moveFocusTo, path, newEnd + hitDelimiter.size).command(_everCangjie.Commands.del) // 选中文字并更新样式.
    .command(_everCangjie.Commands.moveAnchorTo, path, newStart).command(_everCangjie.Commands.moveFocusTo, path, newEnd).command(_everCangjie.Commands.toggleMark, mark) // 聚焦到粗体文字最后，并取消样式.
    .command(_everCangjie.Commands.moveAnchorTo, path, newEnd).command(_everCangjie.Commands.moveFocusTo, path, newEnd) // .command(Commands.toggleMark, mark)
    .command(_everCangjie.Commands.removeMark, mark); // 仅当前面有空格时，为后面加上空格(配置了 alwaysTrailSpace=true 的除外)。理由如下：
    // > 英文场景单词之间都有空格，mark 的文字大概率以单词为单位
    // > 中文场景下，字、标点符号之间一般不会有空格，有空格的情况大多是人为故意添加的，前面有空格大概率后面也会有
    // > 即便错误地不加空格，输入空格的成本还是小于按 backspace 的成本的，用户心情也不一样

    const hasPrevSpace = newStart > 0 ? text[newStart - 1] === ' ' : false;

    if (alwaysTrailSpace || hasPrevSpace) {
      controller.command(_everCangjie.Commands.insertText, ' '); // 插入一个空格，完成格式化.
    } // @ts-ignore


    return controller.dispatch('createTriggerMarkdownAction', {
      mdType: mark.type
    });
  };
};

exports.default = _default;
//# sourceMappingURL=createSpaceHandler.js.map