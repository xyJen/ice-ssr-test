"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bdrToStyle = bdrToStyle;
exports.bdrToPaddingStyle = void 0;

function bdrToStyle(bdr, enableNilBdr = true) {
  const style = {};

  for (const key of ['top', 'bottom', 'left', 'right']) {
    if (key in bdr && bdr[key]) {
      const styleKey = `border${key.charAt(0).toUpperCase()}${key.slice(1)}`;
      const val = bdr[key].val === 'dashed' ? 'dashed' : 'solid';
      const color = isValidColor(bdr[key].color) && bdr[key].color ? bdr[key].color : '';
      let width = bdr[key].sz > 1 ? `${bdr[key].sz}px` : '1px';

      if (bdr[key].sz === 0 && enableNilBdr) {
        width = '0';
      }

      style[styleKey] = `${val} ${color} ${width}`;
    }
  }

  return style;
} // table cell左右border占据的空间会从padding中挤占出来


const bdrToPaddingStyle = function (bdr, originalPadding) {
  const paddingObj = {
    paddingLeft: originalPadding.left,
    paddingRight: originalPadding.right,
    paddingTop: originalPadding.top,
    paddingBottom: originalPadding.bottom
  };

  if (bdr && bdr.left && +bdr.left.sz > 0) {
    paddingObj.paddingLeft = originalPadding.left - +bdr.left.sz;
  }

  if (bdr && bdr.right && +bdr.right.sz > 0) {
    paddingObj.paddingRight = originalPadding.right - +bdr.right.sz;
  }

  return paddingObj;
};

exports.bdrToPaddingStyle = bdrToPaddingStyle;

function isValidColor(color) {
  if (typeof color !== 'string') {
    return false;
  }

  if (color.indexOf('#') === 0 || color.indexOf('rgb') === 0) {
    return true;
  }

  return false;
}
//# sourceMappingURL=generateStyle.js.map