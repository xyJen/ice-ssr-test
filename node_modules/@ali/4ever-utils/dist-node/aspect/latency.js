"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.connect = connect;
exports.latency = latency;
exports.Latency = Latency;
exports.latencyCurrentFrame = latencyCurrentFrame;
exports.latencyFrame = latencyFrame;
exports.LatencyFrame = LatencyFrame;
exports.latencyTotal = latencyTotal;
exports.LatencyTotal = LatencyTotal;

var _debug = _interopRequireDefault(require("debug"));

/* eslint-disable @typescript-eslint/no-explicit-any */
const debug = (0, _debug.default)('EDITOR:UTIL:ASPECT:LATENCY');

function onLatency(key, cost, success = true) {
  const status = success ? 'success' : 'failed';
  debug('Latency %s %c%s: %c%dms', status, 'color: dodgerblue', key, 'color: orange', cost);
}

function connect(speed) {
  return function reporter(key, cost, success = true) {
    onLatency(key, cost, success);
    const status = success ? 'success' : 'failed';
    speed(`latency_${key}_${status}`, cost);
  };
}
/**
 * 函数计时打点，支持同步函数和异步函数计时
 * @param key 打点的 key
 * @param fn 装饰的函数
 * @param callback 自定义打点
 */


function latency(key, fn, options = {}) {
  const {
    callback = onLatency
  } = options;
  return function _latency(...args) {
    const start = Date.now();
    const rs = fn.apply(this, args); // 如果函数是 async 函数

    if (rs instanceof Promise && rs.then && rs.catch) {
      return rs.then(res => {
        callback(key, Date.now() - start, true);
        return res;
      }).catch(err => {
        callback(key, Date.now() - start, false);
        throw err;
      });
    }

    callback(key, Date.now() - start);
    return rs;
  };
}
/**
 * 函数计时装饰器，支持同步函数和异步函数计时
 * @param key 打点计时 key
 */


function Latency(key, options) {
  return function deco(target, propertyKey, descriptor) {
    if (!descriptor || typeof descriptor.value !== 'function') {
      throw new TypeError(`Only methods can be decorated with @Latency. <${String(propertyKey)}> is not a method!`);
    }

    return { ...descriptor,
      value: latency(key, descriptor.value, options)
    };
  };
}

function onFrameCallback(key, cost, type) {
  debug('Latency %s %c%s: %c%dms', type, 'color: dodgerblue', key, 'color: orange', cost);
}

// 计时器缓存
const frameMap = new Map();
/**
 * 记录当前执行点至下一帧的耗时，帧类型支持三种 frame | microtask | macrotask
 * @param key 计时 key
 * @param options
 */

function latencyCurrentFrame(key, options = {}) {
  const {
    leading = true,
    callback = onFrameCallback,
    type = 'frame'
  } = options; // 如果缓存中有 key，则直接 return

  if (frameMap.has(key)) {
    // 非 leading 模式重置计时
    if (!leading) {
      frameMap.set(key, Date.now());
    }

    return;
  } // 计时结束


  function frameEnd() {
    const start = frameMap.get(key);
    frameMap.delete(key);

    if (typeof start !== 'number' || isNaN(start)) {
      throw new Error(`Cannot find start timer for key: ${key}`);
    }

    const cost = Date.now() - start;
    callback(key, cost, type);
  } // 设置计时起始点


  frameMap.set(key, Date.now());

  if (type === 'frame') {
    window.requestAnimationFrame(frameEnd);
  } else if (type === 'microtask') {
    Promise.resolve().then(frameEnd);
  } else if (type === 'macrotask') {
    window.setTimeout(frameEnd);
  } else {
    console.warn('Unexpected frame type: ', type);
    frameMap.delete(key);
  }
}
/**
 * 装饰函数，记录从函数执行开始至下一帧的耗时
 * @param key 计时 key
 * @param fn 装饰的函数
 * @param options
 */


function latencyFrame(key, fn, options) {
  return function _latency(...args) {
    latencyCurrentFrame(key, options);
    return fn.apply(this, args);
  };
}
/**
 * 装饰方法，记录从函数执行开始至下一帧的耗时
 * @param key 计时 key
 * @param options
 */


function LatencyFrame(key, options) {
  return function deco(target, propertyKey, descriptor) {
    if (!descriptor || typeof descriptor.value !== 'function') {
      throw new TypeError(`Only methods can be decorated with @LatencyFrame. <${String(propertyKey)}> is not a method!`);
    }

    return { ...descriptor,
      value: latencyFrame(key, descriptor.value, options)
    };
  };
}

const onTotalCallback = (key, cost, total) => {
  debug('Latency total %c%s: %c%d/time %c%dms', 'color: dodgerblue', key, 'color: tomato', total, 'color: orange', cost);
};

/**
 * 记录一个函数在一个 task 内总共执行的次数以及耗时
 * @param key 计时 key
 * @param fn 计时函数
 * @param options
 */
function latencyTotal(key, fn, options = {}) {
  const {
    callback = onTotalCallback
  } = options;
  let counting = false;
  let total = 0;
  let cost = 0;
  return function _latencyTotal(...args) {
    const start = Date.now();
    const res = fn.apply(this, args);
    const onceCost = Date.now() - start;
    total += 1;
    cost += onceCost;

    if (!counting) {
      counting = true;
      Promise.resolve().then(() => {
        try {
          callback(key, cost, total);
        } finally {
          counting = false;
          total = 0;
          cost = 0;
        }
      });
    }

    return res;
  };
}
/**
 * 记录一个函数在一个 task 内总共执行的次数以及耗时
 * @param key 计时 key
 * @param options
 */


function LatencyTotal(key, options) {
  return function deco(target, propertyKey, descriptor) {
    if (!descriptor || typeof descriptor.value !== 'function') {
      throw new TypeError(`Only methods can be decorated with @LatencyTotal. <${String(propertyKey)}> is not a method!`);
    }

    return { ...descriptor,
      value: latencyTotal(key, descriptor.value, options)
    };
  };
}
//# sourceMappingURL=latency.js.map