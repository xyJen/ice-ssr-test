"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = findBlockKeyFromEvent;

var _everCangjie = require("@ali/4ever-cangjie");

/* eslint-disable @typescript-eslint/ban-ts-comment */
const leftThrottle = 100;
const rightThrottle = 30;
const {
  leafBlock: leafBlockKey,
  key: cangjieKey,
  edgeSelectable,
  content: contentKey
} = _everCangjie.constants.Selector;
const DRAG_BAR_KEY = 'data-drag-handler-key';
const COLUMNS_KEY = 'data-columns-key';
const COLUMN_BAR_KEY = 'data-column-dragkey';
const COLUMN_SELECTOR = 'data-column'; // 如果鼠标在 content 左侧，则往右侧偏移一部分，取新的元素。

const RIGHT_OFFSET = 20;
/**
 * 从 target 开始，往 parent 找，一直找到并返回满足 attribute 的元素
 */

function getParentByAttributes(attribute, target) {
  const attributes = Array.isArray(attribute) ? attribute : [attribute];
  let found = target;

  while (found && !found.getAttribute(contentKey) && found !== window.document.body && found !== window.document.documentElement) {
    for (let i = 0; i < attributes.length; i++) {
      if (found.getAttribute(attributes[i])) return found;
    }

    found = found.parentElement;
  }

  return null;
}

/**
 * 根据鼠标移动事件查找文档 key
 * 策略：一直查找到文档内容根节点或 body/html
 * 优先使用支持边缘选区的节点
 * 其次使用 列表/leafBlock 节点
 * @param event
 * @param container
 */
function findBlockKeyFromEvent(event, container, options) {
  const {
    zoom,
    filterColumn
  } = options || {};
  const eventTarget = event.target;

  if (!eventTarget) {
    return '';
  }

  let oriTarget = eventTarget;
  let blockKey = '';
  let edgeKey = '';

  if (container) {
    const scale = zoom || 1;
    const paddingLeft = parseInt(getComputedStyle(container).paddingLeft, 10) || leftThrottle;
    const rect = container.getBoundingClientRect();
    const {
      clientX,
      clientY
    } = event; // 兼容在左边 padding 区域也可以识别（放大时 padding也会一并变大）

    if (clientX > rect.left && clientX < rect.left + paddingLeft * scale) {
      oriTarget = window.document.elementFromPoint(rect.left + paddingLeft * scale + RIGHT_OFFSET, clientY) || eventTarget;
    }

    if (clientX > rect.right && clientX < rect.right + rightThrottle) {
      oriTarget = window.document.elementFromPoint(rect.right - rect.width / 2, clientY) || eventTarget;
    }
  } // 如果落在了自带 key 的元素上，直接返回对应的 key


  const selfKeyElems = [oriTarget, oriTarget.closest(`[${DRAG_BAR_KEY}]`)];

  if (oriTarget !== eventTarget) {
    selfKeyElems.push(oriTarget);
    selfKeyElems.push(eventTarget.closest(`[${DRAG_BAR_KEY}]`));
  }

  const selfKey = selfKeyElems.map(e => e?.getAttribute(DRAG_BAR_KEY)).find(Boolean);

  if (selfKey) {
    return selfKey;
  }

  let target = oriTarget; // 1. 先尝试找 列表 或 leafBlock

  const blockEle = getParentByAttributes(['data-listid', leafBlockKey], target);

  if (blockEle) {
    blockKey = blockEle.getAttribute(cangjieKey) || blockEle.querySelector(`[${cangjieKey}]`)?.getAttribute(cangjieKey) || '';
  } else {
    target = oriTarget;
  } // 2. 如果有设置 column 标记，尝试定位到分栏
  // 20220316: 这里暂时下线了，不允许拖拽分栏的每一个栏。代码保留、PD 后续很可能再加回来


  if (filterColumn) {
    const dragBarKey = target?.getAttribute(COLUMN_BAR_KEY);

    if (dragBarKey) {
      return '';
    }

    if (target?.getAttribute(COLUMN_SELECTOR)) {
      return target.getAttribute(cangjieKey);
    }

    let columnKey = '';
    let columnEle = getParentByAttributes(COLUMN_SELECTOR, target);

    while (columnEle) {
      columnKey = columnEle.getAttribute(cangjieKey) || columnKey;
      columnEle = getParentByAttributes(COLUMN_SELECTOR, columnEle.parentElement);
    }

    if (columnKey) {
      return columnKey;
    } else if (target?.closest(`[${COLUMNS_KEY}]`)) {
      return '';
    }
  } // 3. 遍历找到最上层的 edgeBlock（例如表格里的 edge block）


  let edgeEle = getParentByAttributes(edgeSelectable, target);

  while (edgeEle) {
    edgeKey = edgeEle.getAttribute(cangjieKey) || edgeKey;
    edgeEle = getParentByAttributes(edgeSelectable, edgeEle.parentElement);
  } // 优先级：edgeKey > leafBlockKey（比如在表格中）


  const finalKey = edgeKey || blockKey;
  return finalKey || '';
}
//# sourceMappingURL=findBlockKeyFromEvent.js.map