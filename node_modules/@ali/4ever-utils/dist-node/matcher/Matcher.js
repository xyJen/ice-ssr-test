"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _levenshtein = require("./levenshtein");

/**
 * 匹配模式
 */
var MatchMode;
/**
 * 获取匹配得分
 * @param mode 匹配模式
 * @param position 子串的位置
 * @param relevance 1 - 编辑距离/关键词长度
 *
 * ### 匹配得分计算公式
 *
 * 将匹配分数分为 3 个区间，若在某一个区间中两项相等，则比较下一个区间的大小，否则则以当前区间的分数类排序
 *
 * *设计思想：将 3 个区间分别用 4 位来表示，每个区间的取值是 0-15，将每个区间的值依次填充，然后比较最终的得分即可*
 *
 * *score = 0x[mode][position][relevance]*
 */

(function (MatchMode) {
  MatchMode[MatchMode["Substring"] = 0] = "Substring";
  MatchMode[MatchMode["Levenshtein"] = 1] = "Levenshtein";
})(MatchMode || (MatchMode = {}));

function getMatchScore(mode, position, relevance) {
  let num = 0x000; // 区间一：填充匹配模式

  if (mode === MatchMode.Substring) {
    num |= 0x100;
  } else if (mode === MatchMode.Levenshtein) {
    num |= 0x000;
  }

  if (mode === MatchMode.Substring) {
    // 区间二：填充子串模式的位置
    num |= Math.max(0xf - position, 0) << 4;
  } else if (mode === MatchMode.Levenshtein) {
    // 区间三：填充编辑距离的相似度
    num |= relevance * 15 & 0xf;
  } // 评分区间 0-1，匹配模式的最大值是 0x100，所以这里分母是 0x1ff


  return num / 0x1ff * 100;
}

/**
 * 空白符正则表达式
 */
const WHITE_SPACE_REG = /\s/g;
/**
 * 搜索工具库
 *
 * @example
 *
 * const matcher = new Matcher({
 *   lang: 'en-US',
 *   items: [
 *     {
 *       keywords: ['Table'],
 *       data: {
 *         key: 'table',
 *       }
 *     },
 *     {
 *       keywords: ['Template'],
 *       data: {
 *         key: 'template',
 *       }
 *     },
 *     {
 *       keywords: ['Temple'],
 *       data: {
 *         key: 'temple',
 *       }
 *     }
 *   ],
 * });
 *
 * const rs = matcher.match('tem);
 */

class Matcher {
  constructor(options) {
    this.items = void 0;
    this.lang = void 0;
    this.leafOnly = void 0;
    this.enableFuzzy = void 0;
    this.threshold = void 0;
    const {
      items,
      lang,
      leafOnly = false,
      enableFuzzy = false,
      threshold = 0.75
    } = options;
    this.items = items;
    this.lang = lang;
    this.leafOnly = leafOnly;
    this.enableFuzzy = enableFuzzy;
    this.threshold = threshold;
  }

  buildItemResult(item, score) {
    return {
      score,
      data: item.data,
      subItems: item.subItems?.map(subItem => this.buildItemResult(subItem, score))
    };
  }

  matchKeywords(query, keywords) {
    let matchPosition = -1;

    for (let i = 0; i < keywords.length; i++) {
      const keyword = keywords[i]; // TODO: 考虑对 keyword 的 normalize 行为做缓存

      const $keyword = keyword.replace(WHITE_SPACE_REG, '').toLowerCase();
      const index = $keyword.indexOf(query);

      if (index !== -1) {
        if (matchPosition === -1 || index < matchPosition) {
          matchPosition = index;
        }
      }
    } // 子串匹配不校验相似度门槛


    if (matchPosition !== -1) {
      return getMatchScore(MatchMode.Substring, matchPosition, 0);
    } // 允许模糊匹配


    if (this.enableFuzzy) {
      let maxRelevance = 0;

      for (let i = 0; i < keywords.length; i++) {
        const keyword = keywords[i]; // TODO: 考虑对 keyword 的 normalize 行为做缓存

        const $keyword = keyword.replace(WHITE_SPACE_REG, '').toLowerCase();
        const distance = (0, _levenshtein.levenshtein)(query, $keyword);
        const relevance = 1 - distance / $keyword.length; // 若当前关键词的相似度大于最大值，则更新 index

        if (relevance > maxRelevance) {
          maxRelevance = relevance;
        }
      } // 仅当相似度大于模糊匹配的门槛时返回匹配项


      if (maxRelevance >= this.threshold) {
        return getMatchScore(MatchMode.Levenshtein, 0xf, maxRelevance);
      }
    }

    return 0;
  }
  /**
   * 节点搜索，搜索此节点以及所有的子节点，此节点的权重为其所有子节点的最大值
   * @param query
   * @param item
   * @returns
   */


  matchItem(query, item) {
    const score = this.matchKeywords(query, item.keywords); // 若支持搜索组，且组名能够匹配关键词，则返回组内所有节点

    if (!this.leafOnly && score > 0) {
      return this.buildItemResult(item, score);
    } // 若没有子项


    if (!item.subItems && score > 0) {
      return {
        score,
        data: item.data
      };
    } // 若存在子项，则搜索子项


    if (item.subItems) {
      const subResults = [];

      for (let i = 0; i < item.subItems.length; i++) {
        const subItem = item.subItems[i];
        const subResult = this.matchItem(query, subItem);

        if (subResult) {
          subResults.push(subResult);
        }
      }

      if (subResults.length === 0) {
        return null;
      }

      subResults.sort((a, b) => b.score - a.score);
      const firstItem = subResults[0];
      return {
        score: firstItem.score,
        data: item.data,
        subItems: subResults
      };
    }

    return null;
  }

  match(query) {
    const res = [];
    const $query = query.replace(WHITE_SPACE_REG, '').toLowerCase();

    for (let i = 0; i < this.items.length; i++) {
      const item = this.items[i];
      const itemResult = this.matchItem($query, item);

      if (itemResult) {
        res.push(itemResult);
      }
    }

    if (res.length > 0) {
      res.sort((a, b) => b.score - a.score);
    }

    return res;
  }

}

var _default = Matcher;
exports.default = _default;
//# sourceMappingURL=Matcher.js.map