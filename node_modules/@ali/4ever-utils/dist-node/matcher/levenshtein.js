"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.levenshtein = levenshtein;

/**
 * 编辑距离算法实现
 *
 * Time Complexity: *O(m x n)*
 *
 * Auxiliary Space: *2O(m)*
 * @param a
 * @param b
 * @returns
 */
function levenshtein(a, b) {
  if (a.length === 0) {
    return b.length;
  }

  if (b.length === 0) {
    return a.length;
  }

  const dp = Array(2).fill(0).map(() => Array(a.length + 1).fill(0)); // 0 -> b[0] 置为 1

  dp[1][0] = 1; // 初始化 0 -> a.length 的距离

  for (let i = 0; i <= a.length; i++) {
    dp[0][i] = i;
  }

  for (let i = 1; i <= b.length; i++) {
    for (let j = 0; j <= a.length; j++) {
      const row = i % 2; // 初始位的距离为 b.substring(0, i) 的长度

      if (j === 0) {
        dp[row][j] = i;
      } // 若字符相等，则距离为 lev(tail(a), tail(b))
      else if (a[j - 1] === b[i - 1]) {
          dp[row][j] = dp[(i - 1) % 2][j - 1];
        } // 若不相等，则距离为
        //           |--- lev(tail(a), b)
        // 1 + min --|--- lev(tail(a), tail(b))
        //           |--- lev(a, tail(b))
        else {
            dp[row][j] = 1 + Math.min(dp[(i - 1) % 2][j], // delete b[i]
            dp[(i - 1) % 2][j - 1], // replace a[j] with b[i]
            dp[row][j - 1] // insert a[j]
            );
          }
    }
  }

  return dp[b.length % 2][a.length];
}
//# sourceMappingURL=levenshtein.js.map