{"version":3,"sources":["../../../src/matcher/Matcher.ts"],"names":["MatchMode","getMatchScore","mode","position","relevance","num","Substring","Levenshtein","Math","max","WHITE_SPACE_REG","Matcher","constructor","options","items","lang","leafOnly","enableFuzzy","threshold","buildItemResult","item","score","data","subItems","map","subItem","matchKeywords","query","keywords","matchPosition","i","length","keyword","$keyword","replace","toLowerCase","index","indexOf","maxRelevance","distance","matchItem","subResults","subResult","push","sort","a","b","firstItem","match","res","$query","itemResult"],"mappings":"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","sourcesContent":["import { levenshtein } from './levenshtein';\n\nexport type Language = 'zh-CN' | 'en-US';\n\nexport interface Item<T> {\n  /**\n   * 关键词组\n   */\n  keywords: string[];\n  /**\n   * 自定义数据\n   */\n  data?: T;\n  /**\n   * 子项\n   * @description 若此属性存在，则当前节点为一个分组\n   */\n  subItems?: Array<Item<T>>;\n}\n\n/**\n * 匹配模式\n */\nenum MatchMode {\n  /**\n   * 子串匹配模式\n   */\n  Substring = 0,\n  /**\n   * 编辑距离匹配模式\n   */\n  Levenshtein,\n}\n\n/**\n * 获取匹配得分\n * @param mode 匹配模式\n * @param position 子串的位置\n * @param relevance 1 - 编辑距离/关键词长度\n *\n * ### 匹配得分计算公式\n *\n * 将匹配分数分为 3 个区间，若在某一个区间中两项相等，则比较下一个区间的大小，否则则以当前区间的分数类排序\n *\n * *设计思想：将 3 个区间分别用 4 位来表示，每个区间的取值是 0-15，将每个区间的值依次填充，然后比较最终的得分即可*\n *\n * *score = 0x[mode][position][relevance]*\n */\nfunction getMatchScore(mode: MatchMode, position: number, relevance: number) {\n  let num = 0x000;\n\n  // 区间一：填充匹配模式\n  if (mode === MatchMode.Substring) {\n    num |= 0x100;\n  } else if (mode === MatchMode.Levenshtein) {\n    num |= 0x000;\n  }\n\n  if (mode === MatchMode.Substring) {\n    // 区间二：填充子串模式的位置\n    num |= Math.max(0xf - position, 0) << 4;\n  } else if (mode === MatchMode.Levenshtein) {\n    // 区间三：填充编辑距离的相似度\n    num |= (relevance * 15) & 0xf;\n  }\n\n  // 评分区间 0-1，匹配模式的最大值是 0x100，所以这里分母是 0x1ff\n  return (num / 0x1ff) * 100;\n}\n\nexport interface ItemResult<T> {\n  /**\n   * 优先级得分\n   */\n  score: number;\n  /**\n   * 结果项\n   */\n  data?: T;\n  /**\n   * 子项\n   */\n  subItems?: Array<ItemResult<T>>;\n}\n\nexport interface MatcherOptions<T> {\n  /**\n   * 搜索数据项\n   */\n  items: Array<Item<T>>;\n  /**\n   * 语言环境\n   */\n  lang: Language;\n  /**\n   * 仅搜索叶子节点\n   * @description 仅搜索叶子节点时不检索分组名\n   */\n  leafOnly?: boolean;\n  /**\n   * 开启模糊匹配\n   */\n  enableFuzzy?: boolean;\n  /**\n   * 关键词命中的相似度阀值\n   * @default 0.75\n   */\n  threshold?: number;\n}\n\n/**\n * 空白符正则表达式\n */\nconst WHITE_SPACE_REG = /\\s/g;\n\n/**\n * 搜索工具库\n *\n * @example\n *\n * const matcher = new Matcher({\n *   lang: 'en-US',\n *   items: [\n *     {\n *       keywords: ['Table'],\n *       data: {\n *         key: 'table',\n *       }\n *     },\n *     {\n *       keywords: ['Template'],\n *       data: {\n *         key: 'template',\n *       }\n *     },\n *     {\n *       keywords: ['Temple'],\n *       data: {\n *         key: 'temple',\n *       }\n *     }\n *   ],\n * });\n *\n * const rs = matcher.match('tem);\n */\nclass Matcher<T extends object = {}> {\n  protected items: Array<Item<T>>;\n\n  protected lang: Language;\n\n  protected leafOnly: boolean;\n\n  protected enableFuzzy: boolean;\n\n  protected threshold: number;\n\n  constructor(options: MatcherOptions<T>) {\n    const {\n      items,\n      lang,\n      leafOnly = false,\n      enableFuzzy = false,\n      threshold = 0.75,\n    } = options;\n\n    this.items = items;\n    this.lang = lang;\n    this.leafOnly = leafOnly;\n    this.enableFuzzy = enableFuzzy;\n    this.threshold = threshold;\n  }\n\n  private buildItemResult(item: Item<T>, score: number): ItemResult<T> {\n    return {\n      score,\n      data: item.data,\n      subItems: item.subItems?.map((subItem) =>\n        this.buildItemResult(subItem, score),\n      ),\n    };\n  }\n\n  private matchKeywords(query: string, keywords: string[]): number {\n    let matchPosition = -1;\n\n    for (let i = 0; i < keywords.length; i++) {\n      const keyword = keywords[i];\n      // TODO: 考虑对 keyword 的 normalize 行为做缓存\n      const $keyword = keyword.replace(WHITE_SPACE_REG, '').toLowerCase();\n\n      const index = $keyword.indexOf(query);\n      if (index !== -1) {\n        if (matchPosition === -1 || index < matchPosition) {\n          matchPosition = index;\n        }\n      }\n    }\n\n    // 子串匹配不校验相似度门槛\n    if (matchPosition !== -1) {\n      return getMatchScore(MatchMode.Substring, matchPosition, 0);\n    }\n\n    // 允许模糊匹配\n    if (this.enableFuzzy) {\n      let maxRelevance = 0;\n\n      for (let i = 0; i < keywords.length; i++) {\n        const keyword = keywords[i];\n        // TODO: 考虑对 keyword 的 normalize 行为做缓存\n        const $keyword = keyword.replace(WHITE_SPACE_REG, '').toLowerCase();\n\n        const distance = levenshtein(query, $keyword);\n\n        const relevance = 1 - distance / $keyword.length;\n\n        // 若当前关键词的相似度大于最大值，则更新 index\n        if (relevance > maxRelevance) {\n          maxRelevance = relevance;\n        }\n      }\n\n      // 仅当相似度大于模糊匹配的门槛时返回匹配项\n      if (maxRelevance >= this.threshold) {\n        return getMatchScore(MatchMode.Levenshtein, 0xf, maxRelevance);\n      }\n    }\n\n    return 0;\n  }\n\n  /**\n   * 节点搜索，搜索此节点以及所有的子节点，此节点的权重为其所有子节点的最大值\n   * @param query\n   * @param item\n   * @returns\n   */\n  private matchItem(query: string, item: Item<T>): ItemResult<T> | null {\n    const score = this.matchKeywords(query, item.keywords);\n\n    // 若支持搜索组，且组名能够匹配关键词，则返回组内所有节点\n    if (!this.leafOnly && score > 0) {\n      return this.buildItemResult(item, score);\n    }\n\n    // 若没有子项\n    if (!item.subItems && score > 0) {\n      return {\n        score,\n        data: item.data,\n      };\n    }\n\n    // 若存在子项，则搜索子项\n    if (item.subItems) {\n      const subResults: Array<ItemResult<T>> = [];\n      for (let i = 0; i < item.subItems.length; i++) {\n        const subItem = item.subItems[i];\n        const subResult = this.matchItem(query, subItem);\n        if (subResult) {\n          subResults.push(subResult);\n        }\n      }\n\n      if (subResults.length === 0) {\n        return null;\n      }\n\n      subResults.sort((a, b) => b.score - a.score);\n      const firstItem = subResults[0];\n      return {\n        score: firstItem.score,\n        data: item.data,\n        subItems: subResults,\n      };\n    }\n\n    return null;\n  }\n\n  match(query: string): Array<ItemResult<T>> {\n    const res: Array<ItemResult<T>> = [];\n    const $query = query.replace(WHITE_SPACE_REG, '').toLowerCase();\n\n    for (let i = 0; i < this.items.length; i++) {\n      const item = this.items[i];\n      const itemResult = this.matchItem($query, item);\n\n      if (itemResult) {\n        res.push(itemResult);\n      }\n    }\n\n    if (res.length > 0) {\n      res.sort((a, b) => b.score - a.score);\n    }\n\n    return res;\n  }\n}\n\nexport default Matcher;\n"],"file":"Matcher.js"}