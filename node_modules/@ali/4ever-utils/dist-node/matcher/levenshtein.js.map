{"version":3,"sources":["../../../src/matcher/levenshtein.ts"],"names":["levenshtein","a","b","length","dp","Array","fill","map","i","j","row","Math","min"],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,WAAT,CAAqBC,CAArB,EAAgCC,CAAhC,EAAmD;AACxD,MAAID,CAAC,CAACE,MAAF,KAAa,CAAjB,EAAoB;AAClB,WAAOD,CAAC,CAACC,MAAT;AACD;;AAED,MAAID,CAAC,CAACC,MAAF,KAAa,CAAjB,EAAoB;AAClB,WAAOF,CAAC,CAACE,MAAT;AACD;;AAED,QAAMC,EAAc,GAAGC,KAAK,CAAC,CAAD,CAAL,CACpBC,IADoB,CACf,CADe,EAEpBC,GAFoB,CAEhB,MAAMF,KAAK,CAACJ,CAAC,CAACE,MAAF,GAAW,CAAZ,CAAL,CAAoBG,IAApB,CAAyB,CAAzB,CAFU,CAAvB,CATwD,CAaxD;;AACAF,EAAAA,EAAE,CAAC,CAAD,CAAF,CAAM,CAAN,IAAW,CAAX,CAdwD,CAgBxD;;AACA,OAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIP,CAAC,CAACE,MAAvB,EAA+BK,CAAC,EAAhC,EAAoC;AAClCJ,IAAAA,EAAE,CAAC,CAAD,CAAF,CAAMI,CAAN,IAAWA,CAAX;AACD;;AAED,OAAK,IAAIA,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIN,CAAC,CAACC,MAAvB,EAA+BK,CAAC,EAAhC,EAAoC;AAClC,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIR,CAAC,CAACE,MAAvB,EAA+BM,CAAC,EAAhC,EAAoC;AAClC,YAAMC,GAAG,GAAGF,CAAC,GAAG,CAAhB,CADkC,CAGlC;;AACA,UAAIC,CAAC,KAAK,CAAV,EAAa;AACXL,QAAAA,EAAE,CAACM,GAAD,CAAF,CAAQD,CAAR,IAAaD,CAAb;AACD,OAFD,CAGA;AAHA,WAIK,IAAIP,CAAC,CAACQ,CAAC,GAAG,CAAL,CAAD,KAAaP,CAAC,CAACM,CAAC,GAAG,CAAL,CAAlB,EAA2B;AAC9BJ,UAAAA,EAAE,CAACM,GAAD,CAAF,CAAQD,CAAR,IAAaL,EAAE,CAAC,CAACI,CAAC,GAAG,CAAL,IAAU,CAAX,CAAF,CAAgBC,CAAC,GAAG,CAApB,CAAb;AACD,SAFI,CAGL;AACA;AACA;AACA;AANK,aAOA;AACHL,YAAAA,EAAE,CAACM,GAAD,CAAF,CAAQD,CAAR,IACE,IACAE,IAAI,CAACC,GAAL,CACER,EAAE,CAAC,CAACI,CAAC,GAAG,CAAL,IAAU,CAAX,CAAF,CAAgBC,CAAhB,CADF,EACsB;AACpBL,YAAAA,EAAE,CAAC,CAACI,CAAC,GAAG,CAAL,IAAU,CAAX,CAAF,CAAgBC,CAAC,GAAG,CAApB,CAFF,EAE0B;AACxBL,YAAAA,EAAE,CAACM,GAAD,CAAF,CAAQD,CAAC,GAAG,CAAZ,CAHF,CAGkB;AAHlB,aAFF;AAOD;AACF;AACF;;AAED,SAAOL,EAAE,CAACF,CAAC,CAACC,MAAF,GAAW,CAAZ,CAAF,CAAiBF,CAAC,CAACE,MAAnB,CAAP;AACD","sourcesContent":["/**\n * 编辑距离算法实现\n *\n * Time Complexity: *O(m x n)*\n *\n * Auxiliary Space: *2O(m)*\n * @param a\n * @param b\n * @returns\n */\nexport function levenshtein(a: string, b: string): number {\n  if (a.length === 0) {\n    return b.length;\n  }\n\n  if (b.length === 0) {\n    return a.length;\n  }\n\n  const dp: number[][] = Array(2)\n    .fill(0)\n    .map(() => Array(a.length + 1).fill(0));\n\n  // 0 -> b[0] 置为 1\n  dp[1][0] = 1;\n\n  // 初始化 0 -> a.length 的距离\n  for (let i = 0; i <= a.length; i++) {\n    dp[0][i] = i;\n  }\n\n  for (let i = 1; i <= b.length; i++) {\n    for (let j = 0; j <= a.length; j++) {\n      const row = i % 2;\n\n      // 初始位的距离为 b.substring(0, i) 的长度\n      if (j === 0) {\n        dp[row][j] = i;\n      }\n      // 若字符相等，则距离为 lev(tail(a), tail(b))\n      else if (a[j - 1] === b[i - 1]) {\n        dp[row][j] = dp[(i - 1) % 2][j - 1];\n      }\n      // 若不相等，则距离为\n      //           |--- lev(tail(a), b)\n      // 1 + min --|--- lev(tail(a), tail(b))\n      //           |--- lev(a, tail(b))\n      else {\n        dp[row][j] =\n          1 +\n          Math.min(\n            dp[(i - 1) % 2][j], // delete b[i]\n            dp[(i - 1) % 2][j - 1], // replace a[j] with b[i]\n            dp[row][j - 1], // insert a[j]\n          );\n      }\n    }\n  }\n\n  return dp[b.length % 2][a.length];\n}\n"],"file":"levenshtein.js"}