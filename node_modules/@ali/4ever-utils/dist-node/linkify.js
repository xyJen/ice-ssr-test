"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.matchesLink = matchesLink;
exports.default = void 0;

var _linkifyIt = _interopRequireDefault(require("linkify-it"));

var _lodash = require("lodash");

function createLinkify(protocolAllowList = ['dingtalk:']) {
  const linkify = (0, _linkifyIt.default)({
    fuzzyLink: false
  });
  protocolAllowList.filter(protocol => !['http:', 'https:'].includes(protocol)).forEach(protocol => {
    linkify.add(protocol, 'http:');
  }); // HACK: 支持 domain 识别下划线, linkify 这边有对应的 pr,如果他合并了，可以直接更新
  // https://github.com/markdown-it/linkify-it/issues/95

  const orgin_src_domain = linkify.re.src_domain;
  const new_domain = '(?:' + linkify.re.src_xn + '|' + '(?:' + linkify.re.src_pseudo_letter + ')' + '|' + '(?:' + linkify.re.src_pseudo_letter + '(?:-|_|' + linkify.re.src_pseudo_letter + '){0,61}' + linkify.re.src_pseudo_letter + ')' + ')';
  updateRegex(linkify, orgin_src_domain, new_domain); // 非 fuzzy 状态下，会使用 str_xxx 进行拼接(性能消耗), 所以也需要替换

  updateSrc(linkify, orgin_src_domain, new_domain); // HACK: 中文字符后紧接链接也可以识别，之后可尝试向 linkify-it 提 MR 支持配置

  const origin_src_ZPCc = linkify.re.src_ZPCc;
  ;
  const new_src_ZPCc = `${linkify.re.src_ZPCc}|[\u4e00-\u9fa5]`;
  updateRegex(linkify, origin_src_ZPCc, new_src_ZPCc);
  return linkify;
}

function updateRegex(instance, pre, cur) {
  Object.keys(instance.re).forEach(name => {
    const rx = instance.re[name];

    if (rx instanceof RegExp) {
      // @ts-ignore
      const source = rx.source.split(pre).join(cur);
      instance.re[name] = RegExp(source, rx.flags);
    }
  });
}

function updateSrc(instance, pre, cur) {
  Object.keys(instance.re).forEach(name => {
    const rx = instance.re[name];

    if (typeof rx === 'string') {
      const source = rx.split(pre).join(cur); // @ts-ignore

      instance.re[name] = source;
    }
  });
}

var _default = (0, _lodash.memoize)(createLinkify, list => {
  if (Array.isArray(list)) {
    return list.sort().reduce((a, b) => a + b, '');
  }

  return list;
});
/**
 * 检查字符串是否包含链接（排除 URL 包含在 md 链接、图片语法内的情况）
 * @param linkify
 * @param text 待检查的字符串
 * @returns 若不包含链接，则返回 null，否则返回符合条件的 LinkifyIt.Match[]
 */


exports.default = _default;

function matchesLink(linkify, text) {
  const matches = linkify.match(text);

  if (!matches) {
    return matches;
  } // 对每个匹配为 URL 的字符串，向前后扩展到相邻的 URL，然后检查是否在链接、图片 markdown 语法中
  // 若匹配，则不转为 Link 元素


  const filtered = matches.filter((match, idx) => {
    const beforeIndex = idx > 0 ? matches[idx - 1].lastIndex + 1 : 0;
    const afterIndex = idx < matches.length - 1 ? matches[idx + 1].index : text.length;
    const current = text.slice(beforeIndex, afterIndex); // linkify 的结果中 URL 有问题，可能包含 ()[]{} 且括号非成对出现
    // 括号不成对出现会导致正则对象创建失败，需要转义

    const url = Array.from(match.text).map(c => Array.from('/|?+.-[](){}').includes(c) ? `\\${c}` : c).join('');

    try {
      return !new RegExp(`\\[([^\\[\\]]*)\\]\\(${url}( "(\\S\\s)?\\S+(\\s\\S)?")?\\)`).test(current);
    } catch {
      return true;
    }
  });
  return filtered.length > 0 ? filtered : null;
}
//# sourceMappingURL=linkify.js.map