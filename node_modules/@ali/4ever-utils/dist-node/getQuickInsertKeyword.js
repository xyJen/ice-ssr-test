"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getKeyword = getKeyword;

/**
 * 注入 composing 至文本中
 * @param txt 阶段后的文本
 * @param composing
 * @param startOffset 截断的起始位置
 * @param pointOffset composing 位置
 */
function injectComposing(txt, composing, startOffset, pointOffset) {
  const offset = pointOffset - startOffset;

  if (offset < 0 || offset > txt.length) {
    return txt;
  }

  const startTxt = txt.slice(0, offset);
  const endTxt = txt.slice(offset);
  return startTxt + composing + endTxt;
}

function getKeyword(controller, {
  type
}) {
  const {
    document,
    decorations,
    composing,
    selection
  } = controller.value;
  const deco = decorations.find(item => item.mark.type === type);

  if (!deco) {
    return '';
  }

  const {
    start,
    end
  } = deco; // 同一个 text 节点

  if (start.key === end.key) {
    const text = document.getNode(start.key);
    let txt = text ? text.text.slice(start.offset, end.offset) : '';
    const {
      anchor: point
    } = selection; // 若存在 composing，则给文本注入

    if (composing && selection.isCollapsed && point.isTextPoint() && point.key === start.key) {
      txt = injectComposing(txt, composing, start.offset, point.offset);
    }

    return txt;
  } // 目前暂时不存在 Text 被分割的情况


  return '';
}
//# sourceMappingURL=getQuickInsertKeyword.js.map