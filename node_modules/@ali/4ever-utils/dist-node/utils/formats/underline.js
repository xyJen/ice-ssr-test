"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _everCangjie = require("@ali/4ever-cangjie");

/* eslint-disable no-param-reassign */
const UL_CSS_MAP = {
  dash: 'dashed',
  single: 'solid',
  wave: 'wavy'
};

function strAppend(prev, current) {
  return prev ? `${prev} ${current}` : current;
}

function addWebkitPrefix(style) {
  Object.keys(style).forEach(key => {
    if (/^textDecoration|^textUnderline/.test(key)) {
      const k = `Webkit${key[0].toUpperCase()}${key.slice(1)}`;
      style[k] = style[key];
    }
  });
}
/**
 * 设置 CSS 文字修饰
 * textDecorationStyle 只允许一个值，因此 underline 和 双删除线无法共存
 * @param style
 * @param type
 * @param underline
 */


function setTextDecotation(style, type, mark) {
  if (type === 'underline') {
    // 兼容 mark = {type: 'underline'} 的生成方式
    const {
      value = 'single',
      color
    } = mark.data || {};
    const underlineStyle = UL_CSS_MAP[value] || value; // 跳过不支持的样式

    if (!underlineStyle || underlineStyle === 'none') return; // 下划线优先级更高：直接覆盖 textDecorationStyle

    style.textDecorationStyle = underlineStyle;
    style.textDecorationLine = strAppend(style.textDecorationLine, 'underline');

    if (color) {
      style.textDecorationColor = color;
    } // BACKGROUND: 
    //   https://aone.alibaba-inc.com/v2/bug/35006381# 《【0615文字bvt】文本设置样式后取消下划线重新设置异常》
    //   Android 下有时候会出现取消下划线时仍渲染下划线的情况。
    //   但实际上代码确实是正确的，当出现问题后又触发重新渲染（例如取消选区、增大字号等操作），则奇怪的下划线就会消失。
    //   通过注释下面的样式，问题消失。
    // HOW:
    //   这里暂时通过让 Android 下不使用 textUnderlinePosition 这个属性来避免
    //   后续可以评估下通过类似 boxShadow: '0 1px' 等方式来实现下划线效果是否可行


    if (!_everCangjie.environment.IS_ANDROID) {
      style.textUnderlinePosition = 'under';
    }

    return addWebkitPrefix(style);
  }

  if (type === 'strike' && mark.data?.value !== false) {
    style.textDecorationLine = strAppend(style.textDecorationLine, 'line-through');
    return addWebkitPrefix(style);
  }

  if (type === 'dstrike' && mark.data?.value !== false) {
    if (!style.textDecorationStyle) {
      // 优先级低于 underline：仅在没有设置 textDecorationStyle (没有下划线）的情况下设置
      style.textDecorationStyle = 'double';
    }

    style.textDecorationLine = strAppend(style.textDecorationLine, 'line-through');
    return addWebkitPrefix(style);
  }
}

var _default = {
  setTextDecotation
};
exports.default = _default;
//# sourceMappingURL=underline.js.map