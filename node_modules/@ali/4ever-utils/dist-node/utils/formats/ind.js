"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_INDENT = exports.IndentType = exports.IndentTrigger = exports.IndUtil = void 0;

var _theme = require("../../theme");

var _toUnits = require("../toUnits");

var _common = require("./common");

var _unitConvert = require("../unitConvert");

const ONE_CHAR_PX = 14;

function charsToPx(char) {
  // 按照 10.5pt/char 转换（导入数据未作单位转换需除以100）
  return char / 100 * ONE_CHAR_PX;
}

function pxToChars(px) {
  return px / ONE_CHAR_PX * 100;
}

function getFirstTextPxSz(node) {
  const firstText = node.getFirstText();
  if (!firstText) return _theme.fontSize.DEFAULT * _unitConvert.PT_TO_PIX;
  const szMark = firstText.marks.find(m => m.type === 'sz');

  if (szMark) {
    if (szMark.data.szUnit !== 'pt') {
      return szMark.data.value;
    }

    return szMark.data.value * _unitConvert.PT_TO_PIX;
  }

  if (/heading-\d/i.test(node.type)) {
    const headStyle = (0, _common.getDefaultHeadStyle)(node.type);
    return _toUnits.unitsConverter.toPX(headStyle['font-size']);
  }

  return _theme.fontSize.DEFAULT * _unitConvert.PT_TO_PIX;
}
/**
 * 解析 block indent 数据
 * leftChars/rightChars/firstLineChars/hangingChars 将覆盖对应不带单位的字段，并被转换为 px 单位
 * 会处理悬挂和首行缩进冲突，并根据第一个字的字号动态计算缩进值
 * @param node BLock
 * @param inheritedData 继承数据
 * @returns IndentProperties
 */


function fromBlock(node, inheritedData) {
  // 优先级：自身 > 继承
  const nodeData = inheritedData || node.data;
  const {
    ind
  } = nodeData;
  const newInd = { ...ind
  };
  if (!ind) return newInd;
  const {
    firstLine,
    hanging: originalHanging,
    firstLineChars,
    hangingChars,
    left,
    leftChars,
    right,
    rightChars
  } = ind;
  let firstTextPxSz = 0;
  let hanging = originalHanging;

  if (!hanging && firstLine < 0) {
    // 兼容编辑器老数据（用 firstLine < 0 表示悬挂缩进）
    hanging = -firstLine;
    newInd.hanging = hanging;
  }

  if (firstLineChars || hangingChars) {
    firstTextPxSz = getFirstTextPxSz(node);
  } // first 和 hanging 互斥，且 hanging 优先级更高


  if (hanging || hangingChars) {
    delete newInd.firstLine;
    delete newInd.firstLineChars;
  }

  if (firstLineChars) {
    newInd.firstLine = firstTextPxSz * firstLineChars / 100 || firstLine || 0;
  }

  if (hangingChars) {
    // hangingChars 存在时忽略 left 的值
    newInd.left = 0;
    newInd.hanging = firstTextPxSz * hangingChars / 100 || hanging || 0;
  }

  if (leftChars) {
    // left 视为兜底
    newInd.left = charsToPx(leftChars) || left || 0;
  }

  if (rightChars) {
    newInd.right = charsToPx(rightChars) || right || 0;
  }

  return newInd;
}

const IndUtil = {
  fromBlock,
  charsToPx,
  pxToChars
};
exports.IndUtil = IndUtil;
let IndentTrigger;
exports.IndentTrigger = IndentTrigger;

(function (IndentTrigger) {
  IndentTrigger[IndentTrigger["keyboard"] = 0] = "keyboard";
  IndentTrigger[IndentTrigger["toolbar"] = 1] = "toolbar";
})(IndentTrigger || (exports.IndentTrigger = IndentTrigger = {}));

let IndentType;
exports.IndentType = IndentType;

(function (IndentType) {
  IndentType["none"] = "noe";
  IndentType["hang"] = "hang";
  IndentType["firstLine"] = "firstLine";
})(IndentType || (exports.IndentType = IndentType = {}));

const DEFAULT_INDENT = {
  firstLine: 0,
  firstLineChars: 0,
  left: 0,
  leftChars: 0,
  hanging: 0,
  hangingChars: 0
};
exports.DEFAULT_INDENT = DEFAULT_INDENT;
//# sourceMappingURL=ind.js.map