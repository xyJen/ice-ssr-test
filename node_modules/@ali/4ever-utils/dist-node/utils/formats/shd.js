"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _everCangjie = require("@ali/4ever-cangjie");

var _tinycolor = require("@ctrl/tinycolor");

var _theme = require("../../theme");

const PCT_REG = /^pct(\d*)/;

function transformShd(shd) {
  if (!shd) return '';
  const {
    val = '',
    color = 'auto',
    fill = 'auto'
  } = shd;
  const isAutoColor = color === 'auto';
  const isAutoFill = fill === 'auto';

  if (val === 'clear') {
    // 清除
    return fill;
  }

  if (val === 'solid') {
    // 纯色
    if (isAutoColor) return '#000';
    return color;
  }

  const pctMatch = val.match(PCT_REG); // TODO: 不支持其它复杂纹理

  if (!pctMatch || !pctMatch[1]) return fill;
  const pct = parseInt(pctMatch[1], 10);
  if (!pct) return ''; // 前景色默认黑色，背景色默认白色

  const colorRgb = new _tinycolor.TinyColor(isAutoColor ? '#000000' : color).toRgb();
  const fillRgb = new _tinycolor.TinyColor(isAutoFill ? '#FFFFFF' : fill).toRgb();
  const colorFactor = pct / 100;
  const fillFactor = (100 - pct) / 100; // 针对 pctXX 模拟混合（因为比较均匀）

  return new _tinycolor.TinyColor({
    r: colorRgb.r * colorFactor + fillRgb.r * fillFactor,
    g: colorRgb.g * colorFactor + fillRgb.g * fillFactor,
    b: colorRgb.b * colorFactor + fillRgb.b * fillFactor
  }).toHexString();
}

function fromBlock(node) {
  const {
    shd
  } = node.data; // 暂直接返回

  return shd;
}
/**
 * 转换段落 shd 为 style
 * 装饰性样式的 padding 优先级需要低于 spacing
 */


function toStyle(node) {
  if (!_everCangjie.Block.isBlock(node)) return undefined; // 「 引用 」的背景色在插件中单独处理

  if (!node?.data?.shd || node?.data?.blockquote) return undefined;
  return { ..._theme.theme.DEFAULT_SHD_STYLES,
    backgroundColor: transformShd(node.data.shd)
  };
}

var _default = {
  transformShd,
  fromBlock,
  toStyle
};
exports.default = _default;
//# sourceMappingURL=shd.js.map