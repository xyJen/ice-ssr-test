"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addMarkAtRange = addMarkAtRange;
exports.default = addMarkAtCurrentRange;

var _everCangjie = require("@ali/4ever-cangjie");

var _getRangesFromEditor = require("./getRangesFromEditor");

/**
 * 在给定选区内增加指定 mark
 * 策略同 addMarkAtCurrentRange
 * @param controller
 * @param selection
 * @param mark
 */
function addMarkAtRange(controller, selection, mark) {
  const {
    document
  } = controller.value;
  const {
    isCollapsed
  } = selection;

  if (!isCollapsed) {
    /**
       * 1
       * 先移除选区中同类型的样式
       * TODO: 原则上我们只允许 marks 中同类型的 mark 只有一个
       * 因此可以走更直接的 filter + push 操作
       * 这里的 removeMarkAtRange 和 addMarkAtRange 要遍历两次 且 会使用数据层的 equal 比较，性能更低
       */
    const sameTypeMarks = document.getMarksAtRange(selection).filter(m => m.type === mark.type);
    sameTypeMarks.forEach(m => {
      controller.command(_everCangjie.Commands.removeMarkAtRange, selection, m);
    }); // 增加指定 mark

    controller.command(_everCangjie.Commands.addMarkAtRange, selection, mark);
    return controller;
  }

  const {
    focus
  } = selection.convertToTextPoints(document);
  const focusNode = document.getNode(focus.key);
  if (!focusNode) return controller;
  const isCollapsedAtEmptyParagraph = controller.query('isCollapsedAtEmptyParagraph', selection);
  const isCollapsedAtEmptyHeading = controller.query('isCollapsedAtEmptyHeading', selection);

  if (isCollapsedAtEmptyParagraph || isCollapsedAtEmptyHeading) {
    // 2.1
    if (_everCangjie.Text.isText(focusNode)) {
      // 依然需要先移除同类型样式
      const sameTypeMarks = document.getMarksAtPosition(focusNode.key, 0).filter(m => m.type === mark.type);
      sameTypeMarks.forEach(m => {
        controller.command(_everCangjie.Commands.removeMarkByKey, focusNode.key, 0, 0, m);
      });
      controller.command(_everCangjie.Commands.addMarkByKey, focusNode.key, 0, 0, mark);
    }
  } // 2 都需要设置选区临时样式：需要将当前位置和要设置的 mark 做合并
  // 需要取 value.selection 否则可能会改变原有选区范围


  const valueSelection = controller.value.selection;
  let curPosMarks = valueSelection.marks || document.getMarksAtPosition(focusNode.key, focus.offset); // 同类型的文本样式仅允许存在一个，这里直接 filter
  // 特殊业务（例如评论）允许多个存在可以使用 setUtils.add

  curPosMarks = curPosMarks.filter(m => m.type !== mark.type);
  curPosMarks.push(mark);
  const newSelection = valueSelection.set('marks', curPosMarks);
  controller.command('select', newSelection);
  return controller;
}
/**
 * 在当前选区内增加指定 mark
 * 1. 未闭合时策略：在选区内增加样式
 * 2. 闭合时策略：
 *  2.1 如果是 isCollapsedAtEmptyParagraph/Heading 时需要给 text 节点加mark（操作可持久化），对应的场景有二：
 *    a. 表格选区中的空 cell；
 *    b. focus 在空段落（paragraph 和 heading）
 *  2.2 边缘闭合选区：仅设置选区的临时样式，对应的场景：focus 在分割线、卡片、表格等左右
 *  2.3 focus 在段落中以及其它情形：仅设置选区的临时样式
 * @param controller
 * @param mark 要求必须是 Mark，尽量使用 mo 中的 create 函数创建以确保兼容性（直接使用 Mark.create 不安全）
 */


function addMarkAtCurrentRange(controller, mark) {
  const selections = (0, _getRangesFromEditor.getRangesFromEditor)(controller);
  selections.forEach(selection => addMarkAtRange(controller, selection, mark));
  return controller;
}
//# sourceMappingURL=addMarkAtCurrentRange.js.map