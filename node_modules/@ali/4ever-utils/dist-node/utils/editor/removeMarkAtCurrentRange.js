"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeMarkAtRange = removeMarkAtRange;
exports.removeMarkAtCurrentRange = removeMarkAtCurrentRange;

var _everCangjie = require("@ali/4ever-cangjie");

var _getRangesFromEditor = require("./getRangesFromEditor");

/**
 * 移除当前位置的临时样式
 * @param controller 
 * @param type 
 * @returns 
 */
function removeMarkAtCurrentPosition(controller, type) {
  const {
    document,
    selection
  } = controller.value;
  const {
    isCollapsed
  } = selection;
  const {
    focus
  } = selection.convertToTextPoints(document);
  const focusNode = document.getNode(focus.key);
  if (!focusNode) return controller;
  /**
   * 优先级: selection.marks > marksAtPosition
   * selection.marks = [] 代表临时的、强制的清空样式的状态
   */

  let curPosMarks = selection.marks;

  if (isCollapsed && !curPosMarks) {
    // collapsed 状态需要 getMarksAtPosition，例如在一段加粗和红色文本中单独取消加粗，此时是设置临时的 selection.marks，不落库
    curPosMarks = document.getMarksAtPosition(focusNode.key, focus.offset);
  }

  if (!curPosMarks) return controller; // 同类型的文本样式仅允许存在一个，这里直接 filter
  // 特殊业务（例如评论）允许多个存在可以使用 setUtils.remove

  curPosMarks = curPosMarks.filter(m => m.type !== type);
  const newSelection = selection.set('marks', curPosMarks);
  controller.command('select', newSelection);
  return controller;
}
/**
 * 在给定选区内删除指定类型的 mark
 * 策略同 removeMarkAtCurrentRange
 * @param controller
 * @param selection
 * @param type
 */


function removeMarkAtRange(controller, selection, type) {
  const {
    document
  } = controller.value;
  const {
    isCollapsed
  } = selection;

  if (!isCollapsed) {
    // 1
    const needRemovedMarks = document.getMarksAtRange(selection).filter(m => m.type === type);
    needRemovedMarks.forEach(m => {
      controller.command(_everCangjie.Commands.removeMarkAtRange, selection, m);
    }); // 即使是 isExpanded 也需要 removeMarkAtCurrentPosition，例如标题变为普通段落

    return removeMarkAtCurrentPosition(controller, type);
  }

  const {
    focus
  } = selection.convertToTextPoints(document);
  const focusNode = document.getNode(focus.key);
  if (!focusNode) return controller;
  const isCollapsedAtEmptyParagraph = controller.query('isCollapsedAtEmptyParagraph', selection);
  const isCollapsedAtEmptyHeading = controller.query('isCollapsedAtEmptyHeading', selection);

  if (isCollapsedAtEmptyParagraph || isCollapsedAtEmptyHeading) {
    // 2
    if (focusNode && _everCangjie.Text.isText(focusNode)) {
      const needRemovedMarks = document.getMarksAtPosition(focusNode.key, 0).filter(m => m.type === type);
      needRemovedMarks.forEach(m => {
        controller.command(_everCangjie.Commands.removeMarkByKey, focusNode.key, 0, 0, m);
      });
    }
  }

  return removeMarkAtCurrentPosition(controller, type);
}
/**
 * 在当前选区内删除指定类型的 mark
 * 1. 未闭合时策略：清除选区内样式
 * 2. 闭合时策略：
 *  2.1 如果是 isCollapsedAtEmptyParagraph/Heading 时需要清除选区临时样式，也需要清除 text 节点的mark（操作可持久化），对应的场景有二：
 *    a. 表格选区中的空 cell；
 *    b. focus 在空段落（paragraph 和 heading）
 *  2.2 边缘闭合选区：仅设置选区的临时样式，对应的场景：focus 在分割线、卡片、表格等左右
 *  2.3 focus 在段落中以及其它情形：仅设置选区的临时样式
 * @param controller
 * @param type 类型
 */


function removeMarkAtCurrentRange(controller, type) {
  const selections = (0, _getRangesFromEditor.getRangesFromEditor)(controller);
  selections.forEach(selection => removeMarkAtRange(controller, selection, type));
  return controller;
}
//# sourceMappingURL=removeMarkAtCurrentRange.js.map