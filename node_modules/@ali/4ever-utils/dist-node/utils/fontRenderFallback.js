"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _fonts = require("../theme/fonts");

var _simpleMapCache = _interopRequireDefault(require("./simpleMapCache"));

class FontRenderFallback {
  /**
   * 存储降级策略
   */

  /**
   * 字体名和降级策略的索引
   */

  /**
   * 简易缓存，减少计算消耗
   */
  constructor() {
    this.STRATEGY_ARRAY = [];
    this.FALLBACK_INDEX_MAP = new Map();
    this.CACHE_MAP = {};
    this.simpleCache = new _simpleMapCache.default();
    this.simpleBTBDCache = new _simpleMapCache.default();
    this.init();
  }

  getCommonFallbackStrategy(generic) {
    return _fonts.FALLBACK_STRATEGIES_CN[generic] || [];
  }

  getFallbackStrategy(font) {
    const {
      family,
      generic,
      chinesefamily,
      fallback
    } = font; // 只对中文做通用降级

    const commonFallback = chinesefamily ? this.getCommonFallbackStrategy(generic) : []; // 优先级：font.fallback > family > chinesefamily > commonFallback > generic

    const fallbackStrategy = fallback?.length ? [...fallback] : [family, chinesefamily || '', ...commonFallback, generic]; // 过滤下

    return Array.from(new Set(fallbackStrategy.filter(item => item)));
  }

  cacheStrategy(strategy, btbd) {
    const key = strategy.toString();
    const cached = this.CACHE_MAP[key];
    if (cached !== undefined) return cached;
    this.STRATEGY_ARRAY.push({
      fontFamily: strategy,
      btbd
    });
    const index = this.STRATEGY_ARRAY.length - 1;
    this.CACHE_MAP[key] = index;
    return index;
  }

  updateFallbackIndex(keys, fallbackIndex) {
    keys.forEach(key => {
      if (key) {
        this.FALLBACK_INDEX_MAP.set(key, fallbackIndex);
      }
    });
  }

  init() {
    _fonts.FONTS_INFO.forEach(font => {
      const {
        family,
        chinesefamily,
        weights = [],
        charSets = [],
        postScriptName,
        btbd
      } = font;
      const fallbackStrategy = this.getFallbackStrategy(font);
      let cachedIndex = this.cacheStrategy(fallbackStrategy, btbd); // 添加英文和中文索引

      this.updateFallbackIndex([family, chinesefamily], cachedIndex); // 中英文都支持字符集和字重（例如 仿宋_GB2312 或 微软雅黑 bold ）

      [family, chinesefamily].forEach(name => {
        for (let i = 0; i <= charSets.length; i++) {
          let fontName = name; // 拼接 charset

          const charset = charSets[i];

          if (charset) {
            fontName += `_${charset}`;
          }

          if (!weights.length) {
            this.updateFallbackIndex([fontName], cachedIndex);
            continue;
          }

          const nameWithWeights = [];

          for (let j = 0; j < weights.length; j++) {
            // 拼接 weight
            const weight = weights[j];
            const nameWithWeight = `${fontName} ${weight}`;

            if (postScriptName) {
              // Chrome 不识别 family Light，需要换成 postScriptName-light
              const newStrategy = [`${postScriptName}-${weight}`, ...fallbackStrategy];
              cachedIndex = this.cacheStrategy(newStrategy, btbd);
              this.updateFallbackIndex([nameWithWeight], cachedIndex);
              continue;
            } else {
              nameWithWeights.push(nameWithWeight);
            }
          }

          this.updateFallbackIndex(nameWithWeights, cachedIndex);
        }
      });
    });
  }

  getSupportFonts() {
    return Array.from(this.FALLBACK_INDEX_MAP).map(item => item[0]);
  }

  getFontBTBD(font) {
    if (!font) return 1; // 先走缓存逻辑

    const cachedValue = this.simpleBTBDCache.get(font);
    if (cachedValue) return cachedValue;
    const fonts = font.split(',');
    let btbd = 1;

    for (let i = 0; i < fonts.length; i++) {
      const fallbackIndex = this.FALLBACK_INDEX_MAP.get(fonts[i]);

      if (fallbackIndex !== undefined) {
        btbd = this.STRATEGY_ARRAY[fallbackIndex].btbd || 1;
        break;
      }
    }

    this.simpleBTBDCache.add(font, btbd);
    return btbd;
  }

  getFontFallback(mark) {
    const {
      ascii,
      eastAsia,
      cs,
      hAnsi,
      hint
    } = mark.data; // 先走缓存逻辑

    const cacheKey = `${ascii}_${eastAsia}_${cs}_${hAnsi}_${hint}`;
    let cachedValue = this.simpleCache.get(cacheKey);
    if (cachedValue) return cachedValue; // 只对中英文降级，暂不处理 cs 和 hAnsi

    let fonts = [ascii, eastAsia];

    if (mark.data[hint]) {
      // 优先跟踪 hint
      fonts = [mark.data[hint]];
    }

    const fontsArray = Array.from(new Set(fonts.filter(f => f)));
    let fallbackFonts = [];

    for (let i = 0; i < fontsArray.length; i++) {
      const font = fontsArray[i];
      const fallbackIndex = this.FALLBACK_INDEX_MAP.get(font);

      if (fallbackIndex === undefined) {
        fallbackFonts.push(font);
        continue;
      }

      const strategy = this.STRATEGY_ARRAY[fallbackIndex];
      fallbackFonts = fallbackFonts.concat([font, ...strategy.fontFamily]);
    }

    fallbackFonts.push(cs, hAnsi);
    cachedValue = Array.from(new Set(fallbackFonts.filter(f => f))).toString();
    this.simpleCache.add(cacheKey, cachedValue);
    return cachedValue;
  }

}

const fontRenderFallback = new FontRenderFallback();
var _default = fontRenderFallback;
exports.default = _default;
//# sourceMappingURL=fontRenderFallback.js.map