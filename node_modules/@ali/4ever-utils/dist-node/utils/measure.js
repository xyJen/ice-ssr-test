"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTextWidthOnServer = getTextWidthOnServer;
exports.default = exports.CJK_REG = void 0;

var _everCangjie = require("@ali/4ever-cangjie");

var _Cache = _interopRequireDefault(require("./Cache"));

const CJK_REG = /[\u4E00-\u9FA5]/;
exports.CJK_REG = CJK_REG;
const MEASURE_CACHE_SIZE = 1000;
const CJK_REG_GLOBAL = /[\u4E00-\u9FA5]/ig;
const TEXT_SSR_WIDTH = {
  '.': 1.225,
  ')': 1.38
};

/**
 * 供非 Web 端粗略计算字符宽高使用
 * 中文字符（宽 = fontSize, 高 = fontSize）
 * 非中文字符（宽= fontSize / 2, 高 = fontSize）
 */
function getTextWidthOnServer(text, fontSize) {
  const zhChars = text.match(CJK_REG_GLOBAL) || [];
  const width = (zhChars.length + (text.length - zhChars.length) / 2) * fontSize;
  return {
    // TEXT_SSR_WIDTH 纯粹为了对齐实际测量结果
    width: (TEXT_SSR_WIDTH[text] || 1) * width,
    height: fontSize
  };
}

class Measure {
  constructor() {
    this.container = void 0;
    this.measurer = void 0;
    this.measureCache = new _Cache.default(MEASURE_CACHE_SIZE);

    this.measureSingleText = (text, font, sz) => {
      if (_everCangjie.environment.IS_NODE) {
        return getTextWidthOnServer(text, parseFloat(sz));
      }

      let measureText = text;

      if (text.length === 1 && CJK_REG.test(text)) {
        measureText = '中';
      }

      const cacheKey = measureText + font + sz;
      const cache = this.measureCache.get(cacheKey);

      if (cache) {
        return cache;
      }

      this.ensureMeasurer();
      this.measurer.textContent = measureText;
      this.measurer.style.fontFamily = font || 'unset';
      this.measurer.style.fontSize = sz || 'unset';
      const rect = this.measurer.getBoundingClientRect();
      const measureInfo = {
        width: rect.width,
        height: rect.height
      };
      this.measureCache.set(cacheKey, measureInfo);
      return measureInfo;
    };

    this.measureTextWidth = (chars, font, sz) => {
      let textWidth = 0; // TODO: 不会有性能问题么，不能一次性测量完？

      for (let i = chars.length - 1; i >= 0; i--) {
        const measureInfo = this.measureSingleText(chars[i], font, sz);
        textWidth += measureInfo.width;
      }

      return textWidth;
    };

    this.warmup = batch => {
      const tasks = [];
      Object.keys(batch).forEach(char => {
        const fontFamilies = batch[char];
        Object.keys(fontFamilies).forEach(fontFamily => {
          const sizes = fontFamilies[fontFamily];
          sizes.forEach(size => {
            tasks.push({
              char,
              fontFamily,
              size
            });
          });
        });
      });
      this.ensureMeasurer();
      const {
        container
      } = this;
      tasks.map(task => {
        const measurer = document.createElement('span');
        measurer.textContent = task.char;
        measurer.style.fontFamily = task.fontFamily || 'unset';
        measurer.style.fontSize = task.size || 'unset';
        container.appendChild(measurer);
        return {
          task,
          measurer
        };
      }).map(({
        task,
        measurer
      }) => {
        const cacheKey = task.char + task.fontFamily + task.size;
        const rect = measurer.getBoundingClientRect();
        const measureInfo = {
          width: rect.width,
          height: rect.height
        };
        this.measureCache.set(cacheKey, measureInfo);
        return measurer;
      }).forEach(measurer => container.removeChild(measurer));
    };
  }

  ensureMeasurer() {
    if (!this.container) {
      const container = document.createElement('div');
      container.style.bottom = '-100px';
      container.style.position = 'fixed';
      container.style.visibility = 'hidden';
      container.style.zIndex = '-999';
      container.style.whiteSpace = 'nowrap';
      document.body.appendChild(container);
      this.container = container;
    }

    if (!this.measurer) {
      const measurer = document.createElement('span');
      this.container.appendChild(measurer);
      this.measurer = measurer;
    }
  }

}

var _default = Measure;
exports.default = _default;
//# sourceMappingURL=measure.js.map