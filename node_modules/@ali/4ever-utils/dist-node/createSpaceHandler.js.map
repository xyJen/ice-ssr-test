{"version":3,"sources":["../../src/createSpaceHandler.ts"],"names":["mark","maybeMark","delimiter","insideWhitespace","alwaysTrailSpace","Mark","create","event","controller","next","value","selection","startText","document","isExpanded","isMark","type","startOffset","convertToTextPoints","start","offset","text","slice","delimiters","Array","isArray","matchedInfo","config","hitDelimiter","newStart","size","preventDefault","path","getPath","key","command","Commands","moveAnchorTo","moveFocusTo","del","newEnd","total","toggleMark","removeMark","hasPrevSpace","insertText","dispatch","mdType"],"mappings":"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","sourcesContent":["import { Controller, Commands, Mark, MarkProperties } from '@ali/4ever-cangjie';\nimport { Delimiter, OffsetInfo, getMarkTextMatchInfo } from './biUtils';\nimport hasMark from './hasMark';\n\nexport type { Delimiter };\n\ninterface CreateSpaceHandlerOptions {\n  mark: string | MarkProperties;\n  delimiter: Delimiter | Delimiter[]; // 标识符定义\n  insideWhitespace?: boolean; // 是否允许标识符内侧空白符，默认为 false\n  alwaysTrailSpace?: boolean; // 是否需要转换后始终跟空格，默认为 false\n}\n\nexport default ({ mark: maybeMark, delimiter, insideWhitespace, alwaysTrailSpace }: CreateSpaceHandlerOptions) => {\n  const mark = Mark.create(maybeMark);\n  return (event, controller: Controller, next) => {\n    const { value } = controller;\n    const { selection, startText, document } = value;\n    if (!startText) return controller;\n\n    if (selection.isExpanded) return next();\n\n    const isMark = hasMark(value, mark.type);\n    if (isMark) return next();\n\n    const startOffset = selection.convertToTextPoints(document).start.offset;\n    const text = startText.text.slice(0, startOffset);\n\n    if (!text) return next();\n\n    const delimiters = Array.isArray(delimiter) ? delimiter : [delimiter];\n\n    let matchedInfo: { delimiter: Delimiter; offset: OffsetInfo } | null = null;\n    for (const config of delimiters) {\n      const offset = getMarkTextMatchInfo(text, config, insideWhitespace);\n      if (offset) {\n        matchedInfo = { delimiter: config, offset };\n        break;\n      }\n    }\n\n    if (!matchedInfo) {\n      return next();\n    }\n\n    const { offset, delimiter: hitDelimiter } = matchedInfo;\n    const newStart = offset!.start - hitDelimiter.size;\n\n    event.preventDefault();\n\n    const path = document.getPath(startText.key);\n    if (!path) return controller;\n\n    controller\n      // 删除前面 triggerText\n      .command(Commands.moveAnchorTo, path, newStart)\n      .command(Commands.moveFocusTo, path, offset!.start)\n      .command(Commands.del);\n\n    const newEnd = newStart + offset!.total; // 此时前面的 triggerText 已经被删除\n    controller\n      // 删除后面 triggerText\n      .command(Commands.moveAnchorTo, path, newEnd)\n      .command(Commands.moveFocusTo, path, newEnd + hitDelimiter.size)\n      .command(Commands.del)\n      // 选中文字并更新样式.\n      .command(Commands.moveAnchorTo, path, newStart)\n      .command(Commands.moveFocusTo, path, newEnd)\n      .command(Commands.toggleMark, mark)\n      // 聚焦到粗体文字最后，并取消样式.\n      .command(Commands.moveAnchorTo, path, newEnd)\n      .command(Commands.moveFocusTo, path, newEnd)\n      // .command(Commands.toggleMark, mark)\n      .command(Commands.removeMark, mark);\n    // 仅当前面有空格时，为后面加上空格(配置了 alwaysTrailSpace=true 的除外)。理由如下：\n    // > 英文场景单词之间都有空格，mark 的文字大概率以单词为单位\n    // > 中文场景下，字、标点符号之间一般不会有空格，有空格的情况大多是人为故意添加的，前面有空格大概率后面也会有\n    // > 即便错误地不加空格，输入空格的成本还是小于按 backspace 的成本的，用户心情也不一样\n    const hasPrevSpace = newStart > 0 ? text[newStart - 1] === ' ' : false;\n    if (alwaysTrailSpace || hasPrevSpace) {\n      controller.command(Commands.insertText, ' '); // 插入一个空格，完成格式化.\n    }\n\n    // @ts-ignore\n    return controller.dispatch('createTriggerMarkdownAction', { mdType: mark.type });\n  };\n};\n"],"file":"createSpaceHandler.js"}