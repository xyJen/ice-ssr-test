{"version":3,"sources":["../../../../src/bi/utils/createInlineNodeOnSpace.ts"],"names":["Commands","Selection","TextPoint","commands","hasInlineCodeMark","createInlineNodeOnSpace","delimiter","size","insideWhitespace","event","controller","next","value","selection","document","startText","isExpanded","anchorInline","endPoint","convertToTextPoints","end","text","slice","offset","getMatchDelimiterOffset","path","getPath","key","matchedDelimiterRange","create","anchor","start","focus","preventDefault","command","moveAnchorTo","moveFocusTo","del","toggleInlineCode","dispatch","mdType","trim","RegExp","test","normalPattern","normalMatchesArray","match","getMatchOffset","pattern","matchArray","matchStr","length"],"mappings":"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","sourcesContent":["import { Controller, Commands, Selection, TextPoint } from '@ali/4ever-cangjie';\nimport type { offsetConfig } from '../types';\nimport { commands } from '../commands';\nimport hasInlineCodeMark from './hasInlineCodeMark';\n\n/**\n * 通过分隔符创建一个Inline Node\n * @param delimiter\n * @param size\n * @param insideWhitespace\n */\nexport default function createInlineNodeOnSpace(\n  delimiter: string,\n  size: number,\n  insideWhitespace: boolean,\n) {\n  return (event, controller: Controller, next) => {\n    const { selection, document, startText } = controller.value;\n    if (selection.isExpanded || !startText || controller.value.anchorInline)\n      return next();\n    const endPoint = selection.convertToTextPoints(document).end;\n    const text = startText.text.slice(0, endPoint.offset);\n    if (!text) return next();\n    /**\n     * constraint:\n     * 1.当前text node含有匹配的另一个delimiter\n     * 2.两个delimiter区域内不含inline节点\n     */\n    const offset = getMatchDelimiterOffset(\n      text,\n      delimiter,\n      size,\n      insideWhitespace,\n    );\n    const path = document.getPath(startText.key);\n    if (!offset || !path) return next();\n\n    // 判断用`包裹的部分`是否含有InlineCodeMark 如果有，不能生成InlineCode\n    const matchedDelimiterRange = Selection.create({\n      anchor: TextPoint.create({\n        offset: offset.start - size,\n        key: startText.key,\n      }),\n      focus: TextPoint.create({\n        offset: offset.end + size,\n        key: startText.key,\n      }),\n    });\n    if (hasInlineCodeMark(document, matchedDelimiterRange)) return next();\n\n    event.preventDefault();\n    controller\n      // 1.删除后面的delimiter\n      .command(Commands.moveAnchorTo, path, offset.end)\n      .command(Commands.moveFocusTo, path, offset.end + size)\n      .command(Commands.del)\n      // 2.删除前面的delimiter\n      .command(Commands.moveAnchorTo, path, offset.start - size)\n      .command(Commands.moveFocusTo, path, offset.start)\n      .command(Commands.del)\n      // 3. 更新start/end，wrapInline\n      .command(Commands.moveAnchorTo, path, offset.start - size)\n      .command(Commands.moveFocusTo, path, offset.end - size)\n      .command(commands.toggleInlineCode);\n\n    // @ts-ignore\n    return controller.dispatch('createTriggerMarkdownAction', { mdType: 'inlineCode2' });\n  };\n}\n\n/**\n *\n * @param text\n * @param delimiter\n * @param size\n * @param insideWhitespace\n */\nconst getMatchDelimiterOffset = (\n  text: string,\n  delimiter: string,\n  size: number,\n  insideWhitespace: boolean,\n): offsetConfig | null => {\n  // 排除为空白字符串、仅包含 delimiter 的情况\n  if (!text.trim() || RegExp(`^(\\\\${delimiter})*$`).test(text)) {\n    return null;\n  }\n  // 先判断仅包含非 delimiter 且 非空白」的字符 or 允许空白符的情况\n  const normalPattern = `\\\\${delimiter}{${size}}([^\\\\${delimiter}${\n    insideWhitespace ? '' : '\\\\s'\n  }]+)\\\\${delimiter}{${size}}$`;\n  const normalMatchesArray = text.match(RegExp(normalPattern));\n  if (normalMatchesArray) {\n    return getMatchOffset(text, normalMatchesArray[0], size);\n  }\n\n  // 再判断含有空白符的情况\n  const pattern = insideWhitespace\n    ? `\\\\${delimiter}{${size}}[^\\\\${delimiter}]+\\\\${delimiter}{${size}}$`\n    : `\\\\${delimiter}{${size}}[^\\\\s\\\\${delimiter}]+[^\\\\${delimiter}]*[^\\\\s\\\\${delimiter}]+\\\\${delimiter}{${size}}$`;\n  const matchArray = text.match(RegExp(pattern));\n\n  if (matchArray) {\n    return getMatchOffset(text, matchArray[0], size);\n  }\n  return null;\n};\n\nfunction getMatchOffset(text: string, matchStr: string, size: number) {\n  return {\n    start: text.length - matchStr.length + size,\n    end: text.length - size,\n  };\n}\n"],"file":"createInlineNodeOnSpace.js"}