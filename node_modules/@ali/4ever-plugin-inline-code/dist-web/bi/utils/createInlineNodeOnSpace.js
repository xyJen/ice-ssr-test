import { Commands, Selection, TextPoint } from '@ali/4ever-cangjie';
import { commands } from "../commands";
import hasInlineCodeMark from "./hasInlineCodeMark";
/**
 * 通过分隔符创建一个Inline Node
 * @param delimiter
 * @param size
 * @param insideWhitespace
 */

export default function createInlineNodeOnSpace(delimiter, size, insideWhitespace) {
  return function (event, controller, next) {
    var _controller$value = controller.value,
        selection = _controller$value.selection,
        document = _controller$value.document,
        startText = _controller$value.startText;
    if (selection.isExpanded || !startText || controller.value.anchorInline) return next();
    var endPoint = selection.convertToTextPoints(document).end;
    var text = startText.text.slice(0, endPoint.offset);
    if (!text) return next();
    /**
     * constraint:
     * 1.当前text node含有匹配的另一个delimiter
     * 2.两个delimiter区域内不含inline节点
     */

    var offset = getMatchDelimiterOffset(text, delimiter, size, insideWhitespace);
    var path = document.getPath(startText.key);
    if (!offset || !path) return next(); // 判断用`包裹的部分`是否含有InlineCodeMark 如果有，不能生成InlineCode

    var matchedDelimiterRange = Selection.create({
      anchor: TextPoint.create({
        offset: offset.start - size,
        key: startText.key
      }),
      focus: TextPoint.create({
        offset: offset.end + size,
        key: startText.key
      })
    });
    if (hasInlineCodeMark(document, matchedDelimiterRange)) return next();
    event.preventDefault();
    controller // 1.删除后面的delimiter
    .command(Commands.moveAnchorTo, path, offset.end).command(Commands.moveFocusTo, path, offset.end + size).command(Commands.del) // 2.删除前面的delimiter
    .command(Commands.moveAnchorTo, path, offset.start - size).command(Commands.moveFocusTo, path, offset.start).command(Commands.del) // 3. 更新start/end，wrapInline
    .command(Commands.moveAnchorTo, path, offset.start - size).command(Commands.moveFocusTo, path, offset.end - size).command(commands.toggleInlineCode); // @ts-ignore

    return controller.dispatch('createTriggerMarkdownAction', {
      mdType: 'inlineCode2'
    });
  };
}
/**
 *
 * @param text
 * @param delimiter
 * @param size
 * @param insideWhitespace
 */

var getMatchDelimiterOffset = function getMatchDelimiterOffset(text, delimiter, size, insideWhitespace) {
  // 排除为空白字符串、仅包含 delimiter 的情况
  if (!text.trim() || RegExp("^(\\" + delimiter + ")*$").test(text)) {
    return null;
  } // 先判断仅包含非 delimiter 且 非空白」的字符 or 允许空白符的情况


  var normalPattern = "\\" + delimiter + "{" + size + "}([^\\" + delimiter + (insideWhitespace ? '' : '\\s') + "]+)\\" + delimiter + "{" + size + "}$";
  var normalMatchesArray = text.match(RegExp(normalPattern));

  if (normalMatchesArray) {
    return getMatchOffset(text, normalMatchesArray[0], size);
  } // 再判断含有空白符的情况


  var pattern = insideWhitespace ? "\\" + delimiter + "{" + size + "}[^\\" + delimiter + "]+\\" + delimiter + "{" + size + "}$" : "\\" + delimiter + "{" + size + "}[^\\s\\" + delimiter + "]+[^\\" + delimiter + "]*[^\\s\\" + delimiter + "]+\\" + delimiter + "{" + size + "}$";
  var matchArray = text.match(RegExp(pattern));

  if (matchArray) {
    return getMatchOffset(text, matchArray[0], size);
  }

  return null;
};

function getMatchOffset(text, matchStr, size) {
  return {
    start: text.length - matchStr.length + size,
    end: text.length - size
  };
}
//# sourceMappingURL=createInlineNodeOnSpace.js.map