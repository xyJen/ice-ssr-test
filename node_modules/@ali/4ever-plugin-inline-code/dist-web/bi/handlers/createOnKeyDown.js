import { isKeyHotkey } from 'is-hotkey';
import { Commands } from '@ali/4ever-cangjie';
import { commands } from "../commands";
import isCursorInInlineCode from "../utils/isCursorInInlineCode";
import getTextOffsetInsideInlineCode from "../utils/getTextOffsetInsideInlineCode";
import getCurTextNode from "../utils/getCurTextNode";
import getTextOffsetOutsideInlineCode from "../utils/getTextOffsetOutsideInlineCode";
export default function createOnKeyDown(hotKey) {
  var isInlineCodeHotkey = isKeyHotkey(hotKey);
  var isLeftHotkey = isKeyHotkey('left');
  var isRightHotkey = isKeyHotkey('right');
  return function onKeyDown(event, controller, next) {
    /**
     * 两种情况需要拦截默认行为：
     * 1.从左右侧text node进入Inline Node节点时，需设置anchor与focus至inline Node的首尾部
     * 2.从Inline Node节点左右侧移出时，需设置anchor与focus至前后Text Node的首尾部
     */
    var value = controller.value;

    if (isLeftHotkey(event)) {
      // 情况2：
      if (isCursorInInlineCode(value)) {
        var offset = getTextOffsetInsideInlineCode(value);
        var curTextNode = getCurTextNode(value);
        if (!curTextNode) return next();

        if (offset === 0) {
          event.preventDefault(); // 选区闭合，获取anchorInline即可，且不为null

          var inline = controller.value.anchorInline;
          var prevNode = controller.value.document.getPreviousSibling(inline.key);
          return controller.command(Commands.moveToEndOfNode, prevNode);
        } else if (offset === 1) {
          event.preventDefault();
          return controller.command(Commands.moveToStartOfNode, curTextNode);
        }
      } else {
        var _offset = getTextOffsetOutsideInlineCode(value, 'right');

        var _curTextNode = getCurTextNode(value);

        if (!_curTextNode) return next();

        if (_offset === 0) {
          event.preventDefault();

          var _prevNode = controller.value.document.getPreviousSibling(_curTextNode.key);

          return controller.command(Commands.moveToEndOfNode, _prevNode);
        } else if (_offset === 1) {
          event.preventDefault();
          return controller.command(Commands.moveToStartOfNode, _curTextNode);
        }
      }
    } //和left同理


    if (isRightHotkey(event)) {
      if (isCursorInInlineCode(value)) {
        var _offset2 = getTextOffsetInsideInlineCode(value);

        var _curTextNode2 = getCurTextNode(value);

        if (!_curTextNode2) return next();

        if (_offset2 === _curTextNode2.text.length) {
          event.preventDefault();
          var _inline = controller.value.anchorInline;
          var nextNode = controller.value.document.getNextSibling(_inline.key);
          return controller.command(Commands.moveToStartOfNode, nextNode);
        } else if (_offset2 === _curTextNode2.text.length - 1) {
          event.preventDefault();
          return controller.command(Commands.moveToEndOfNode, _curTextNode2);
        }
      } else {
        var _offset3 = getTextOffsetOutsideInlineCode(value, 'left');

        var _curTextNode3 = getCurTextNode(value);

        if (!_curTextNode3) return next();

        if (_offset3 === _curTextNode3.text.length) {
          event.preventDefault();

          var _nextNode = controller.value.document.getNextSibling(_curTextNode3.key);

          return controller.command(Commands.moveToStartOfNode, _nextNode);
        } else if (_offset3 === _curTextNode3.text.length - 1) {
          event.preventDefault();
          return controller.command(Commands.moveToEndOfNode, _curTextNode3);
        }
      }
    }

    if (isInlineCodeHotkey(event)) {
      event.preventDefault();
      event.stopPropagation();
      return controller.command(commands.toggleInlineCode);
    }

    return next();
  };
}
//# sourceMappingURL=createOnKeyDown.js.map