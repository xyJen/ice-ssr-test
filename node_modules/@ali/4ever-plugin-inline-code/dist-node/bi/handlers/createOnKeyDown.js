"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createOnKeyDown;

var _isHotkey = require("is-hotkey");

var _everCangjie = require("@ali/4ever-cangjie");

var _commands = require("../commands");

var _isCursorInInlineCode = _interopRequireDefault(require("../utils/isCursorInInlineCode"));

var _getTextOffsetInsideInlineCode = _interopRequireDefault(require("../utils/getTextOffsetInsideInlineCode"));

var _getCurTextNode = _interopRequireDefault(require("../utils/getCurTextNode"));

var _getTextOffsetOutsideInlineCode = _interopRequireDefault(require("../utils/getTextOffsetOutsideInlineCode"));

function createOnKeyDown(hotKey) {
  const isInlineCodeHotkey = (0, _isHotkey.isKeyHotkey)(hotKey);
  const isLeftHotkey = (0, _isHotkey.isKeyHotkey)('left');
  const isRightHotkey = (0, _isHotkey.isKeyHotkey)('right');
  return function onKeyDown(event, controller, next) {
    /**
     * 两种情况需要拦截默认行为：
     * 1.从左右侧text node进入Inline Node节点时，需设置anchor与focus至inline Node的首尾部
     * 2.从Inline Node节点左右侧移出时，需设置anchor与focus至前后Text Node的首尾部
     */
    const {
      value
    } = controller;

    if (isLeftHotkey(event)) {
      // 情况2：
      if ((0, _isCursorInInlineCode.default)(value)) {
        const offset = (0, _getTextOffsetInsideInlineCode.default)(value);
        const curTextNode = (0, _getCurTextNode.default)(value);
        if (!curTextNode) return next();

        if (offset === 0) {
          event.preventDefault(); // 选区闭合，获取anchorInline即可，且不为null

          const inline = controller.value.anchorInline;
          const prevNode = controller.value.document.getPreviousSibling(inline.key);
          return controller.command(_everCangjie.Commands.moveToEndOfNode, prevNode);
        } else if (offset === 1) {
          event.preventDefault();
          return controller.command(_everCangjie.Commands.moveToStartOfNode, curTextNode);
        }
      } else {
        const offset = (0, _getTextOffsetOutsideInlineCode.default)(value, 'right');
        const curTextNode = (0, _getCurTextNode.default)(value);
        if (!curTextNode) return next();

        if (offset === 0) {
          event.preventDefault();
          const prevNode = controller.value.document.getPreviousSibling(curTextNode.key);
          return controller.command(_everCangjie.Commands.moveToEndOfNode, prevNode);
        } else if (offset === 1) {
          event.preventDefault();
          return controller.command(_everCangjie.Commands.moveToStartOfNode, curTextNode);
        }
      }
    } //和left同理


    if (isRightHotkey(event)) {
      if ((0, _isCursorInInlineCode.default)(value)) {
        const offset = (0, _getTextOffsetInsideInlineCode.default)(value);
        const curTextNode = (0, _getCurTextNode.default)(value);
        if (!curTextNode) return next();

        if (offset === curTextNode.text.length) {
          event.preventDefault();
          const inline = controller.value.anchorInline;
          const nextNode = controller.value.document.getNextSibling(inline.key);
          return controller.command(_everCangjie.Commands.moveToStartOfNode, nextNode);
        } else if (offset === curTextNode.text.length - 1) {
          event.preventDefault();
          return controller.command(_everCangjie.Commands.moveToEndOfNode, curTextNode);
        }
      } else {
        const offset = (0, _getTextOffsetOutsideInlineCode.default)(value, 'left');
        const curTextNode = (0, _getCurTextNode.default)(value);
        if (!curTextNode) return next();

        if (offset === curTextNode.text.length) {
          event.preventDefault();
          const nextNode = controller.value.document.getNextSibling(curTextNode.key);
          return controller.command(_everCangjie.Commands.moveToStartOfNode, nextNode);
        } else if (offset === curTextNode.text.length - 1) {
          event.preventDefault();
          return controller.command(_everCangjie.Commands.moveToEndOfNode, curTextNode);
        }
      }
    }

    if (isInlineCodeHotkey(event)) {
      event.preventDefault();
      event.stopPropagation();
      return controller.command(_commands.commands.toggleInlineCode);
    }

    return next();
  };
}
//# sourceMappingURL=createOnKeyDown.js.map