"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createInlineNodeOnSpace;

var _everCangjie = require("@ali/4ever-cangjie");

var _commands = require("../commands");

var _hasInlineCodeMark = _interopRequireDefault(require("./hasInlineCodeMark"));

/**
 * 通过分隔符创建一个Inline Node
 * @param delimiter
 * @param size
 * @param insideWhitespace
 */
function createInlineNodeOnSpace(delimiter, size, insideWhitespace) {
  return (event, controller, next) => {
    const {
      selection,
      document,
      startText
    } = controller.value;
    if (selection.isExpanded || !startText || controller.value.anchorInline) return next();
    const endPoint = selection.convertToTextPoints(document).end;
    const text = startText.text.slice(0, endPoint.offset);
    if (!text) return next();
    /**
     * constraint:
     * 1.当前text node含有匹配的另一个delimiter
     * 2.两个delimiter区域内不含inline节点
     */

    const offset = getMatchDelimiterOffset(text, delimiter, size, insideWhitespace);
    const path = document.getPath(startText.key);
    if (!offset || !path) return next(); // 判断用`包裹的部分`是否含有InlineCodeMark 如果有，不能生成InlineCode

    const matchedDelimiterRange = _everCangjie.Selection.create({
      anchor: _everCangjie.TextPoint.create({
        offset: offset.start - size,
        key: startText.key
      }),
      focus: _everCangjie.TextPoint.create({
        offset: offset.end + size,
        key: startText.key
      })
    });

    if ((0, _hasInlineCodeMark.default)(document, matchedDelimiterRange)) return next();
    event.preventDefault();
    controller // 1.删除后面的delimiter
    .command(_everCangjie.Commands.moveAnchorTo, path, offset.end).command(_everCangjie.Commands.moveFocusTo, path, offset.end + size).command(_everCangjie.Commands.del) // 2.删除前面的delimiter
    .command(_everCangjie.Commands.moveAnchorTo, path, offset.start - size).command(_everCangjie.Commands.moveFocusTo, path, offset.start).command(_everCangjie.Commands.del) // 3. 更新start/end，wrapInline
    .command(_everCangjie.Commands.moveAnchorTo, path, offset.start - size).command(_everCangjie.Commands.moveFocusTo, path, offset.end - size).command(_commands.commands.toggleInlineCode); // @ts-ignore

    return controller.dispatch('createTriggerMarkdownAction', {
      mdType: 'inlineCode2'
    });
  };
}
/**
 *
 * @param text
 * @param delimiter
 * @param size
 * @param insideWhitespace
 */


const getMatchDelimiterOffset = (text, delimiter, size, insideWhitespace) => {
  // 排除为空白字符串、仅包含 delimiter 的情况
  if (!text.trim() || RegExp(`^(\\${delimiter})*$`).test(text)) {
    return null;
  } // 先判断仅包含非 delimiter 且 非空白」的字符 or 允许空白符的情况


  const normalPattern = `\\${delimiter}{${size}}([^\\${delimiter}${insideWhitespace ? '' : '\\s'}]+)\\${delimiter}{${size}}$`;
  const normalMatchesArray = text.match(RegExp(normalPattern));

  if (normalMatchesArray) {
    return getMatchOffset(text, normalMatchesArray[0], size);
  } // 再判断含有空白符的情况


  const pattern = insideWhitespace ? `\\${delimiter}{${size}}[^\\${delimiter}]+\\${delimiter}{${size}}$` : `\\${delimiter}{${size}}[^\\s\\${delimiter}]+[^\\${delimiter}]*[^\\s\\${delimiter}]+\\${delimiter}{${size}}$`;
  const matchArray = text.match(RegExp(pattern));

  if (matchArray) {
    return getMatchOffset(text, matchArray[0], size);
  }

  return null;
};

function getMatchOffset(text, matchStr, size) {
  return {
    start: text.length - matchStr.length + size,
    end: text.length - size
  };
}
//# sourceMappingURL=createInlineNodeOnSpace.js.map