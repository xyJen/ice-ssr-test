{"version":3,"sources":["../../../../src/bi/utils/createInlineNodeOnSpace.ts"],"names":["createInlineNodeOnSpace","delimiter","size","insideWhitespace","event","controller","next","selection","document","startText","value","isExpanded","anchorInline","endPoint","convertToTextPoints","end","text","slice","offset","getMatchDelimiterOffset","path","getPath","key","matchedDelimiterRange","Selection","create","anchor","TextPoint","start","focus","preventDefault","command","Commands","moveAnchorTo","moveFocusTo","del","commands","toggleInlineCode","dispatch","mdType","trim","RegExp","test","normalPattern","normalMatchesArray","match","getMatchOffset","pattern","matchArray","matchStr","length"],"mappings":"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","sourcesContent":["import { Controller, Commands, Selection, TextPoint } from '@ali/4ever-cangjie';\nimport type { offsetConfig } from '../types';\nimport { commands } from '../commands';\nimport hasInlineCodeMark from './hasInlineCodeMark';\n\n/**\n * 通过分隔符创建一个Inline Node\n * @param delimiter\n * @param size\n * @param insideWhitespace\n */\nexport default function createInlineNodeOnSpace(\n  delimiter: string,\n  size: number,\n  insideWhitespace: boolean,\n) {\n  return (event, controller: Controller, next) => {\n    const { selection, document, startText } = controller.value;\n    if (selection.isExpanded || !startText || controller.value.anchorInline)\n      return next();\n    const endPoint = selection.convertToTextPoints(document).end;\n    const text = startText.text.slice(0, endPoint.offset);\n    if (!text) return next();\n    /**\n     * constraint:\n     * 1.当前text node含有匹配的另一个delimiter\n     * 2.两个delimiter区域内不含inline节点\n     */\n    const offset = getMatchDelimiterOffset(\n      text,\n      delimiter,\n      size,\n      insideWhitespace,\n    );\n    const path = document.getPath(startText.key);\n    if (!offset || !path) return next();\n\n    // 判断用`包裹的部分`是否含有InlineCodeMark 如果有，不能生成InlineCode\n    const matchedDelimiterRange = Selection.create({\n      anchor: TextPoint.create({\n        offset: offset.start - size,\n        key: startText.key,\n      }),\n      focus: TextPoint.create({\n        offset: offset.end + size,\n        key: startText.key,\n      }),\n    });\n    if (hasInlineCodeMark(document, matchedDelimiterRange)) return next();\n\n    event.preventDefault();\n    controller\n      // 1.删除后面的delimiter\n      .command(Commands.moveAnchorTo, path, offset.end)\n      .command(Commands.moveFocusTo, path, offset.end + size)\n      .command(Commands.del)\n      // 2.删除前面的delimiter\n      .command(Commands.moveAnchorTo, path, offset.start - size)\n      .command(Commands.moveFocusTo, path, offset.start)\n      .command(Commands.del)\n      // 3. 更新start/end，wrapInline\n      .command(Commands.moveAnchorTo, path, offset.start - size)\n      .command(Commands.moveFocusTo, path, offset.end - size)\n      .command(commands.toggleInlineCode);\n\n    // @ts-ignore\n    return controller.dispatch('createTriggerMarkdownAction', { mdType: 'inlineCode2' });\n  };\n}\n\n/**\n *\n * @param text\n * @param delimiter\n * @param size\n * @param insideWhitespace\n */\nconst getMatchDelimiterOffset = (\n  text: string,\n  delimiter: string,\n  size: number,\n  insideWhitespace: boolean,\n): offsetConfig | null => {\n  // 排除为空白字符串、仅包含 delimiter 的情况\n  if (!text.trim() || RegExp(`^(\\\\${delimiter})*$`).test(text)) {\n    return null;\n  }\n  // 先判断仅包含非 delimiter 且 非空白」的字符 or 允许空白符的情况\n  const normalPattern = `\\\\${delimiter}{${size}}([^\\\\${delimiter}${\n    insideWhitespace ? '' : '\\\\s'\n  }]+)\\\\${delimiter}{${size}}$`;\n  const normalMatchesArray = text.match(RegExp(normalPattern));\n  if (normalMatchesArray) {\n    return getMatchOffset(text, normalMatchesArray[0], size);\n  }\n\n  // 再判断含有空白符的情况\n  const pattern = insideWhitespace\n    ? `\\\\${delimiter}{${size}}[^\\\\${delimiter}]+\\\\${delimiter}{${size}}$`\n    : `\\\\${delimiter}{${size}}[^\\\\s\\\\${delimiter}]+[^\\\\${delimiter}]*[^\\\\s\\\\${delimiter}]+\\\\${delimiter}{${size}}$`;\n  const matchArray = text.match(RegExp(pattern));\n\n  if (matchArray) {\n    return getMatchOffset(text, matchArray[0], size);\n  }\n  return null;\n};\n\nfunction getMatchOffset(text: string, matchStr: string, size: number) {\n  return {\n    start: text.length - matchStr.length + size,\n    end: text.length - size,\n  };\n}\n"],"file":"createInlineNodeOnSpace.js"}