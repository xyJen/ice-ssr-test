"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Channel = exports.getAllChannelNamespaces = exports.destroyChannel = exports.getChannel = void 0;
var mobile_1 = require("../entry/mobile");
var env_1 = require("../lib/env");
var channels = {};
/**
 * 获取对应 namespace 的 Channel，如果不存在则会新建
 * @param namespace
 * @returns Channel
 */
var getChannel = function (namespace) {
    if (!channels[namespace]) {
        channels[namespace] = new Channel(namespace);
    }
    return channels[namespace];
};
exports.getChannel = getChannel;
/**
 * 释放对应 Channel，在其上注册的事件也会一并被释放
 * @param namespace
 */
var destroyChannel = function (namespace) {
    var _a;
    (_a = channels[namespace]) === null || _a === void 0 ? void 0 : _a.destroy();
    delete channels[namespace];
};
exports.destroyChannel = destroyChannel;
/**
 *
 * @returns 所有 Channel 对应的 namespace 列表
 */
var getAllChannelNamespaces = function () {
    return Object.keys(channels);
};
exports.getAllChannelNamespaces = getAllChannelNamespaces;
var env = env_1.getENV();
var Channel = /** @class */ (function () {
    function Channel(namespace) {
        var _this = this;
        // 记录正在监听的promise
        this.subscribedMethodsPromise = {};
        // 记录取消监听的promise
        this.unSubscribedMethodsPromise = {};
        this.lastCacheMap = {};
        // 保存监听的listener以及option
        this.listenerMap = {};
        // 尝试注册事件，如果返回了数据，则作为缓存事件抛出
        this.trySubscribeEvent = function (eventName) {
            if (!_this.subscribedMethodsPromise[eventName]) {
                _this.subscribedMethodsPromise[eventName] = mobile_1._invoke('internal.channel.subscribe', { namespace: _this.namespace, eventName: eventName });
            }
            return _this.subscribedMethodsPromise[eventName];
        };
        // 尝试注销事件
        this.tryUnSubscribeEvent = function (eventName) {
            if (_this.listenerMap[eventName] && _this.listenerMap[eventName].length === 0
                && _this.subscribedMethodsPromise[eventName]) {
                if (!_this.unSubscribedMethodsPromise[eventName]) {
                    _this.unSubscribedMethodsPromise[eventName] =
                        _this.subscribedMethodsPromise[eventName].then(function () {
                            return mobile_1._invoke('internal.channel.unsubscribe', {
                                namespace: _this.namespace,
                                eventName: eventName,
                            }).then(function () {
                                // clean the cache about current eventName
                                delete _this.lastCacheMap[eventName];
                                delete _this.subscribedMethodsPromise[eventName];
                                delete _this.unSubscribedMethodsPromise[eventName];
                                return Promise.resolve();
                            });
                        });
                }
                return _this.unSubscribedMethodsPromise[eventName];
            }
        };
        this.addDTChannelEventListener = function (handler) {
            if ((env.platform === env_1.ENV_ENUM.ios || env.platform === env_1.ENV_ENUM.android || env.platform === env_1.ENV_ENUM.pc)
                && env.appType === env_1.APP_TYPE.MINI_APP
                && typeof dd.addDTChannelEventListener === 'function') {
                // Special logic: when in mobile miniApp runtime, only use dd.addDTChannelEventListener to listener
                dd.addDTChannelEventListener(function (data) {
                    handler(data.data);
                });
            }
            else {
                mobile_1.on('dtChannelEvent', function (data) {
                    // when pc
                    if (env.platform === env_1.ENV_ENUM.pc) {
                        handler(data);
                    }
                    else {
                        if (data && typeof data.detail === 'object') {
                            handler(data.detail);
                        }
                        else if (data && typeof data.data === 'object') {
                            handler(data.data);
                        }
                    }
                });
            }
        };
        this.namespace = namespace;
        this.addDTChannelEventListener(function (data) {
            _this.publishCurrentInnerEvent(data);
        });
    }
    Channel.prototype.destroy = function () {
        var _this = this;
        Object.keys(this.listenerMap).forEach(function (eventName) {
            if (_this.listenerMap[eventName]) {
                var listeners = _this.listenerMap[eventName].map(function (_a) {
                    var listener = _a.listener;
                    return listener;
                });
                listeners.forEach(function (listener) { return _this.unsubscribe(eventName, listener); });
            }
        });
    };
    Channel.prototype.subscribe = function (eventName, listener, options) {
        var _this = this;
        if (eventName && typeof listener === 'function') {
            var eventsHandle = this.listenerMap[eventName];
            if (eventsHandle) {
                var findIndex = eventsHandle.findIndex(function (item) {
                    return item.listener === listener;
                });
                if (findIndex === -1) {
                    eventsHandle.push({
                        listener: listener,
                        options: options,
                    });
                }
            }
            else {
                this.listenerMap[eventName] = [{
                        listener: listener,
                        options: options,
                    }];
            }
            this.trySubscribeEvent(eventName).then(function (data) {
                // 当第一次监听的时候(内存里没有数据)
                if (!_this.lastCacheMap[eventName] && typeof data === 'object'
                    && data.eventName === eventName) {
                    _this.publishCurrentInnerEvent(data);
                    // 当第二次监听且想使用缓存的时候，使用内存的数据替代
                }
                else if (_this.lastCacheMap[eventName] && (options === null || options === void 0 ? void 0 : options.useCache)) {
                    listener(_this.lastCacheMap[eventName]);
                }
            });
        }
        else {
            throw (new Error('eventName is null or listener is not a function, subscribe fail'));
        }
    };
    Channel.prototype.unsubscribe = function (eventName, listener) {
        if (eventName && typeof listener === 'function') {
            var eventsHandle = this.listenerMap[eventName];
            if (Array.isArray(eventsHandle)) {
                var findIndex = eventsHandle.findIndex(function (item) {
                    return item.listener === listener;
                });
                if (findIndex !== -1) {
                    eventsHandle.splice(findIndex, 1);
                }
            }
            // 时序有点复杂，后续考虑不调用unSubscribeEvent
            // this.tryUnSubscribeEvent(eventName);
        }
        else {
            throw (new Error('eventName is null or listener is not a function, unsubscribe fail'));
        }
    };
    Channel.prototype.publish = function (eventName, data, options) {
        return mobile_1._invoke('internal.channel.publish', {
            namespace: this.namespace,
            eventName: eventName,
            data: data,
            shouldUpdateCache: (options && options.shouldUpdateCache) || undefined,
        });
    };
    Channel.prototype.publishCurrentInnerEvent = function (data) {
        if (data.data && data.namespace === this.namespace) {
            var eventName = data.eventName;
            this.lastCacheMap[eventName] = data;
            if (this.listenerMap[eventName]) {
                this.listenerMap[eventName].forEach(function (listenerItem) {
                    // 设置了使用缓存的才吐回缓存
                    if (data.isCached !== true
                        || data.isCached === true && listenerItem.options && listenerItem.options.useCache) {
                        listenerItem.listener(data);
                    }
                });
            }
        }
    };
    return Channel;
}());
exports.Channel = Channel;
