{"version":3,"sources":["../../../src/bi/utils.ts"],"names":["isEmptyNode","controller","node","type","undefined","nodes","length","Text","isEmptyText","isList","data","list","isInlineCode","query","buildReplacer","replaceFns","replaceExp","RegExp","Object","keys","map","i","join","str","replace","match","slice","replaceTemplate","fragment","replacer","mapDescendants","isText","leafs","getLeaves","leaf","newText","text","set"],"mappings":";;;;;;;;AAAA;;AAIA;AACA;AACA;AACA;AACA;AACO,MAAMA,WAAW,GAAG,CAACC,UAAD,EAAyBC,IAAzB,KAAyC;AAClE,MAAIA,IAAI,CAACC,IAAL,KAAc,WAAlB,EAA+B;AAC7B,WAAOC,SAAP;AACD;;AACD,SACEF,IAAI,CAACG,KAAL,CAAWC,MAAX,KAAsB,CAAtB,IACCJ,IAAI,CAACG,KAAL,CAAWC,MAAX,KAAsB,CAAtB,IAA2BC,kBAAKC,WAAL,CAAiBN,IAAI,CAACG,KAAL,CAAW,CAAX,CAAjB,CAF9B;AAID,CARM;AAUP;AACA;AACA;AACA;AACA;;;;;AACO,MAAMI,MAAM,GAAIP,IAAD,IAAoC;AACxD,SAAOA,IAAI,CAACC,IAAL,KAAc,WAAd,IAA6BD,IAAI,CAACQ,IAAL,EAAWC,IAA/C;AACD,CAFM;AAIP;AACA;AACA;AACA;AACA;;;;;AACO,MAAMC,YAAY,GAAIX,UAAD,IAAqC;AAC/D,SAAOA,UAAU,CAACY,KAAX,CAAiB,cAAjB,CAAP;AACD,CAFM;;;;AAIA,SAASC,aAAT,CAAuBC,UAAvB,EAA8C;AACnD;AACA,QAAMC,UAAU,GAAG,IAAIC,MAAJ,CAChB,GAAEC,MAAM,CAACC,IAAP,CAAYJ,UAAZ,EACAK,GADA,CACKC,CAAD,IAAQ,IAAGA,CAAE,GADjB,EAEAC,IAFA,CAEK,GAFL,CAEU,EAHI,EAIjB,GAJiB,CAAnB;AAMA,SAAQC,GAAD,IAAiB;AACtB,WAAOA,GAAG,CAACC,OAAJ,CAAYR,UAAZ,EAAyBS,KAAD,IAAW;AACxC,aAAQ,GAAEV,UAAU,CAACU,KAAK,CAACC,KAAN,CAAY,CAAZ,EAAe,CAAC,CAAhB,CAAD,CAAV,EAAiC,EAA3C;AACD,KAFM,CAAP;AAGD,GAJD;AAKD;;AAEM,MAAMC,eAAe,GAAG,CAACC,QAAD,EAAqBC,QAArB,KAA2D;AACxF,SAAOD,QAAQ,CAACE,cAAT,CAAyB5B,IAAD,IAAU;AACvC,QAAIK,kBAAKwB,MAAL,CAAY7B,IAAZ,CAAJ,EAAuB;AACrB,YAAM8B,KAAK,GAAG9B,IAAI,CAAC+B,SAAL,GAAiBb,GAAjB,CAAsBc,IAAD,IAAU;AAC3C,cAAMC,OAAO,GAAGN,QAAQ,CAACK,IAAI,CAACE,IAAN,CAAxB;AACA,eAAOF,IAAI,CAACG,GAAL,CAAS,MAAT,EAAiBF,OAAjB,CAAP;AACD,OAHa,CAAd;AAIA,aAAOjC,IAAI,CAACmC,GAAL,CAAS,QAAT,EAAmBL,KAAnB,CAAP;AACD,KAND,MAMO;AACL,aAAO9B,IAAP;AACD;AACF,GAVM,CAAP;AAWD,CAZM","sourcesContent":["import { Block, Text, Document, Controller } from '@ali/4ever-cangjie';\nimport { Paragraph } from '@ali/4ever-plugin-paragraph';\nimport { Variables } from '../type';\n\n/**\n * 判断节点是否是空节点\n * @param node\n * @returns\n */\nexport const isEmptyNode = (controller: Controller, node: Block) => {\n  if (node.type !== 'paragraph') {\n    return undefined;\n  }\n  return (\n    node.nodes.length === 0 ||\n    (node.nodes.length === 1 && Text.isEmptyText(node.nodes[0]))\n  );\n};\n\n/**\n * 判断一个 node 是否是 list\n * @param node\n * @returns\n */\nexport const isList = (node: Block): node is Paragraph => {\n  return node.type === 'paragraph' && node.data?.list;\n};\n\n/**\n * 判断当前光标是否在 inline code 中\n * @param controller\n * @returns\n */\nexport const isInlineCode = (controller: Controller): boolean => {\n  return controller.query('isInlineCode');\n};\n\nexport function buildReplacer(replaceFns: Variables) {\n  // /%TODY%|%ME%.../g\n  const replaceExp = new RegExp(\n    `${Object.keys(replaceFns)\n      .map((i) => `%${i}%`)\n      .join('|')}`,\n    'g',\n  );\n  return (str: string) => {\n    return str.replace(replaceExp, (match) => {\n      return `${replaceFns[match.slice(1, -1)]()}`;\n    });\n  };\n}\n\nexport const replaceTemplate = (fragment: Document, replacer: (str: string) => string) => {\n  return fragment.mapDescendants((node) => {\n    if (Text.isText(node)) {\n      const leafs = node.getLeaves().map((leaf) => {\n        const newText = replacer(leaf.text);\n        return leaf.set('text', newText);\n      });\n      return node.set('leaves', leafs);\n    } else {\n      return node;\n    }\n  });\n};\n"],"file":"utils.js"}