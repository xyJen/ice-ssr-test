"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onCangjieSelect = void 0;

var _everCangjie = require("@ali/4ever-cangjie");

var _mo = require("../../mo");

;
/**
 * 与模板按钮相关的选区需要处理三种情况：
 * 1. 按钮内全选，表现为：原 focus anchor 均在模板按钮内，但事件发生后，focus anchor 均不在模板按钮内，且 focus !== anchor，此时仅选择模板按钮内容
 * 2. 从内向外选，表现为：原 focus anchor 均在模板按钮内，但事件发生后，focus 不在模板按钮内，此时需要忽略该事件
 * 3. 从外向内选，表现为：原 focus anchor 均不在模板按钮内，但事件发生后，focus 在模板按钮内，此时需要扩展选区包含整个模板按钮
 */

const onCangjieSelect = (event, controller, next) => {
  const {
    detail: {
      selection
    }
  } = event;
  const {
    focus,
    anchor
  } = selection; // perf: 此种情况无需关心

  if (selection.isCollapsed) {
    return next();
  }

  const {
    value: {
      selection: {
        focus: beforeFocus
      },
      document
    }
  } = controller;
  const focusBlock = getClosestTemplateButton(focus.key, document);
  const anchorBlock = getClosestTemplateButton(anchor.key, document); // 从内向外选 或 由外向内选

  if (focusBlock !== anchorBlock) {
    // 由内向外，限制在模板按钮内
    if (!focusBlock) {
      return;
    }

    const focusBlockPath = document.getPath(focusBlock.key);
    const anchorBlockPath = anchorBlock && document.getPath(anchorBlock.key); // 嵌套情况下的由内向外，限制在内部的模板按钮内

    if (focusBlockPath && anchorBlockPath && _everCangjie.Path.isAncestor(focusBlockPath, anchorBlockPath)) {
      return;
    } // 由外向内选则选中整个模板按钮


    let edge = 'before';
    const anchorPath = document.getPath(anchor.key);
    const focusPath = document.getPath(focus.key); // 模板按钮在初始选区后面

    if (_everCangjie.Path.isAfter(focusPath, anchorPath)) {
      edge = 'after';
    } else if (anchor.isEdgePoint()) {
      // 从边缘的 edgePoint 开始选，且与 focus 存在父子关系
      if (_everCangjie.Path.isDescendant(focusPath, anchorPath)) {
        edge = anchor.edge === 'after' ? 'before' : 'after';
      }
    }

    const newFocus = _everCangjie.EdgePoint.create({
      key: focusBlock.key,
      edge
    });

    const selection = _everCangjie.Selection.create({
      focus: newFocus,
      anchor
    });

    return controller.command(_everCangjie.Commands.select, selection);
  } // beforeFocusBlock 与 beforeAnchorBlock 必然相等，这是由要处理的三个条件所约束的，所以这里只需要查询一种情况


  const beforeFocusBlock = getClosestTemplateButton(beforeFocus.key, document); // 全选

  if (!focusBlock && !anchorBlock && beforeFocusBlock) {
    event.preventDefault();
    const {
      nodes
    } = beforeFocusBlock;
    return controller.command(_everCangjie.Commands.moveAnchorToStartOfNode, nodes[0]).command(_everCangjie.Commands.moveFocusToEndOfNode, nodes[nodes.length - 1]);
  }

  return next();
};

exports.onCangjieSelect = onCangjieSelect;

function getClosestTemplateButton(key, document) {
  return document.getClosest(key, _mo.TemplateButton.isTemplateButton);
}
//# sourceMappingURL=onCangjieSelect.js.map