"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onKeyDown = void 0;

var _everCangjie = require("@ali/4ever-cangjie");

var _mo = require("../../mo");

var _utils = require("../utils");

var _isSelectionInTemplateButton = _interopRequireDefault(require("../queries/isSelectionInTemplateButton"));

;

const onKeyDown = (event, controller, next) => {
  const isDelete = isDeleteHotKey(event); // perf 非关注的事件，趁早返回，减少计算

  if (!isDelete) {
    return next();
  }

  const {
    value
  } = controller;
  const {
    document,
    selection
  } = value;
  const isInTemplateButton = (0, _isSelectionInTemplateButton.default)(controller); // 开始、结束节点均不在模板按钮内，则交由其他插件处理

  if (!isInTemplateButton) {
    return next();
  } // 开始、结束节点只有一个在模板按钮内，则不要有响应


  if (isInTemplateButton !== 'all') {
    return controller;
  }

  const templateButton = document.getClosest(selection.focus.key, _mo.TemplateButton.isTemplateButton);
  const {
    nodes
  } = templateButton; // 删除 -> 必需得保留一个空段落

  if (isDelete) {
    const isOpen = _mo.TemplateButton.isOpen(controller, templateButton.key); // 关闭状态下，删除时会先选中，再继续退格需要直接删除


    if (!isOpen) {
      return controller.command(_everCangjie.Commands.replaceNodeByKey, templateButton.key, _everCangjie.Block.create('paragraph')).command(_everCangjie.Commands.moveForward, 1);
    } // 只处理单个子元素即将被删除的情况


    if (nodes.length !== 1) {
      return next();
    }

    const {
      anchor
    } = selection;
    const block = document.getClosestBlock(anchor.key); // 异常情况兜底

    if (!block) {
      return controller;
    }

    const isVoid = controller.query('isVoid', block); // 非空 & 非 void block，不处理

    if (!(0, _utils.isEmptyNode)(controller, block) && !isVoid) {
      return next();
    } // 空 list 与 void block 被删除时，需要插入一个空段落


    if ((0, _utils.isList)(block) || isVoid || (0, _utils.isInlineCode)(controller)) {
      controller.command(_everCangjie.Commands.replaceNodeByKey, block.key, _everCangjie.Block.create('paragraph')).command(_everCangjie.Commands.moveForward, 2);
      return controller;
    }

    event.preventDefault();
    return controller;
  }

  return next();
};
/**
 * 需要拦截删除事件
 * @param event
 * @returns
 */


exports.onKeyDown = onKeyDown;

const isDeleteHotKey = event => {
  return _everCangjie.hotkeys.isDeleteLineForward(event) || _everCangjie.hotkeys.isDeleteLineBackward(event) || _everCangjie.hotkeys.isDeleteForward(event) || _everCangjie.hotkeys.isDeleteBackward(event) || _everCangjie.hotkeys.isDeleteWordForward(event) || _everCangjie.hotkeys.isDeleteWordBackward(event);
};
//# sourceMappingURL=onKeyDown.js.map