import { Path, Commands, EdgePoint, Selection } from '@ali/4ever-cangjie';
import { TemplateButton } from "../../mo";
;
/**
 * 与模板按钮相关的选区需要处理三种情况：
 * 1. 按钮内全选，表现为：原 focus anchor 均在模板按钮内，但事件发生后，focus anchor 均不在模板按钮内，且 focus !== anchor，此时仅选择模板按钮内容
 * 2. 从内向外选，表现为：原 focus anchor 均在模板按钮内，但事件发生后，focus 不在模板按钮内，此时需要忽略该事件
 * 3. 从外向内选，表现为：原 focus anchor 均不在模板按钮内，但事件发生后，focus 在模板按钮内，此时需要扩展选区包含整个模板按钮
 */

export var onCangjieSelect = function onCangjieSelect(event, controller, next) {
  var selection = event.detail.selection;
  var focus = selection.focus,
      anchor = selection.anchor; // perf: 此种情况无需关心

  if (selection.isCollapsed) {
    return next();
  }

  var _controller$value = controller.value,
      beforeFocus = _controller$value.selection.focus,
      document = _controller$value.document;
  var focusBlock = getClosestTemplateButton(focus.key, document);
  var anchorBlock = getClosestTemplateButton(anchor.key, document); // 从内向外选 或 由外向内选

  if (focusBlock !== anchorBlock) {
    // 由内向外，限制在模板按钮内
    if (!focusBlock) {
      return;
    }

    var focusBlockPath = document.getPath(focusBlock.key);
    var anchorBlockPath = anchorBlock && document.getPath(anchorBlock.key); // 嵌套情况下的由内向外，限制在内部的模板按钮内

    if (focusBlockPath && anchorBlockPath && Path.isAncestor(focusBlockPath, anchorBlockPath)) {
      return;
    } // 由外向内选则选中整个模板按钮


    var edge = 'before';
    var anchorPath = document.getPath(anchor.key);
    var focusPath = document.getPath(focus.key); // 模板按钮在初始选区后面

    if (Path.isAfter(focusPath, anchorPath)) {
      edge = 'after';
    } else if (anchor.isEdgePoint()) {
      // 从边缘的 edgePoint 开始选，且与 focus 存在父子关系
      if (Path.isDescendant(focusPath, anchorPath)) {
        edge = anchor.edge === 'after' ? 'before' : 'after';
      }
    }

    var newFocus = EdgePoint.create({
      key: focusBlock.key,
      edge: edge
    });

    var _selection = Selection.create({
      focus: newFocus,
      anchor: anchor
    });

    return controller.command(Commands.select, _selection);
  } // beforeFocusBlock 与 beforeAnchorBlock 必然相等，这是由要处理的三个条件所约束的，所以这里只需要查询一种情况


  var beforeFocusBlock = getClosestTemplateButton(beforeFocus.key, document); // 全选

  if (!focusBlock && !anchorBlock && beforeFocusBlock) {
    event.preventDefault();
    var nodes = beforeFocusBlock.nodes;
    return controller.command(Commands.moveAnchorToStartOfNode, nodes[0]).command(Commands.moveFocusToEndOfNode, nodes[nodes.length - 1]);
  }

  return next();
};

function getClosestTemplateButton(key, document) {
  return document.getClosest(key, TemplateButton.isTemplateButton);
}
//# sourceMappingURL=onCangjieSelect.js.map