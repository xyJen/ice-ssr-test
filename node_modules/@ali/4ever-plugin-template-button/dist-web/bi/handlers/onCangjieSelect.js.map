{"version":3,"sources":["../../../../src/bi/handlers/onCangjieSelect.ts"],"names":["Path","Commands","EdgePoint","Selection","TemplateButton","onCangjieSelect","event","controller","next","selection","detail","focus","anchor","isCollapsed","value","beforeFocus","document","focusBlock","getClosestTemplateButton","key","anchorBlock","focusBlockPath","getPath","anchorBlockPath","isAncestor","edge","anchorPath","focusPath","isAfter","isEdgePoint","isDescendant","newFocus","create","command","select","beforeFocusBlock","preventDefault","nodes","moveAnchorToStartOfNode","moveFocusToEndOfNode","length","getClosest","isTemplateButton"],"mappings":"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","sourcesContent":["import {\n  Path,\n  Commands,\n  Document,\n  EdgePoint,\n  PointEdge,\n  Selection,\n  ZhiPlugin,\n  Controller,\n  CangjieSelectEvent\n} from '@ali/4ever-cangjie';\nimport { TemplateButton } from '../../mo';;\n\n/**\n * 与模板按钮相关的选区需要处理三种情况：\n * 1. 按钮内全选，表现为：原 focus anchor 均在模板按钮内，但事件发生后，focus anchor 均不在模板按钮内，且 focus !== anchor，此时仅选择模板按钮内容\n * 2. 从内向外选，表现为：原 focus anchor 均在模板按钮内，但事件发生后，focus 不在模板按钮内，此时需要忽略该事件\n * 3. 从外向内选，表现为：原 focus anchor 均不在模板按钮内，但事件发生后，focus 在模板按钮内，此时需要扩展选区包含整个模板按钮\n */\n\nexport const onCangjieSelect: ZhiPlugin['onCangjieSelect'] = (\n  event: CangjieSelectEvent,\n  controller: Controller,\n  next,\n) => {\n  const { detail: { selection } } = event;\n  const { focus, anchor } = selection;\n  // perf: 此种情况无需关心\n  if (selection.isCollapsed) {\n    return next();\n  }\n  const { value: { selection: { focus: beforeFocus }, document } } = controller;\n\n  const focusBlock = getClosestTemplateButton(focus.key, document);\n  const anchorBlock = getClosestTemplateButton(anchor.key, document);\n\n  // 从内向外选 或 由外向内选\n  if (focusBlock !== anchorBlock) {\n    // 由内向外，限制在模板按钮内\n    if (!focusBlock) {\n      return;\n    }\n    const focusBlockPath = document.getPath(focusBlock.key);\n    const anchorBlockPath = anchorBlock && document.getPath(anchorBlock.key);\n    // 嵌套情况下的由内向外，限制在内部的模板按钮内\n    if (focusBlockPath && anchorBlockPath && Path.isAncestor(focusBlockPath, anchorBlockPath)) {\n      return;\n    }\n    // 由外向内选则选中整个模板按钮\n    let edge: PointEdge = 'before';\n    const anchorPath = document.getPath(anchor.key)!;\n    const focusPath = document.getPath(focus.key)!;\n    // 模板按钮在初始选区后面\n    if (Path.isAfter(focusPath, anchorPath)) {\n      edge = 'after';\n    } else if (anchor.isEdgePoint()) {\n      // 从边缘的 edgePoint 开始选，且与 focus 存在父子关系\n      if (Path.isDescendant(focusPath, anchorPath)) {\n        edge = anchor.edge === 'after' ? 'before' : 'after';\n      }\n    }\n    const newFocus = EdgePoint.create({ key: focusBlock.key, edge });\n    const selection = Selection.create({ focus: newFocus, anchor });\n    return controller.command(Commands.select, selection)\n  }\n\n  // beforeFocusBlock 与 beforeAnchorBlock 必然相等，这是由要处理的三个条件所约束的，所以这里只需要查询一种情况\n  const beforeFocusBlock = getClosestTemplateButton(beforeFocus.key, document);\n  // 全选\n  if (!focusBlock && !anchorBlock && beforeFocusBlock) {\n    event.preventDefault();\n    const { nodes } = beforeFocusBlock;\n    return controller\n      .command(Commands.moveAnchorToStartOfNode, nodes[0])\n      .command(Commands.moveFocusToEndOfNode, nodes[nodes.length - 1]);\n  }\n  return next();\n}\n\n\nfunction getClosestTemplateButton(key: string, document: Document) {\n  return document.getClosest(key, TemplateButton.isTemplateButton);\n}\n"],"file":"onCangjieSelect.js"}