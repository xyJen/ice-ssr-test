import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";
import * as React from 'react';
import { IdleQueue } from "./idleQueue"; // Initialize the global queue manager

var queue = new IdleQueue();

var OnIdle = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(OnIdle, _React$Component);

  function OnIdle() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      ready: process.env.NODE_ENV === 'test'
    };

    _this.clearJob = function () {
      // Remove this task from the global queue
      queue.unshiftTask(_this.queueRendering);
    };

    _this.requestIdle = function () {
      // Clear the existing job if exists to avoid duplicates
      _this.clearJob();

      if (_this.props.skipSSR !== true) {
        // Queue up
        queue.pushTask(_this.queueRendering);
      }
    };

    _this.queueRendering = function () {
      // We request animation frame so that rendering doesn't happen during another ongoing process
      requestAnimationFrame(_this.readyToRender);
    };

    _this.readyToRender = function () {
      _this.setState({
        ready: true
      });
    };

    return _this;
  }

  var _proto = OnIdle.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.requestIdle();
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    // Cleanup
    this.clearJob();
  };

  _proto.render = function render() {
    return this.state.ready ? this.props.children : this.props.placeholder || null;
  };

  return OnIdle;
}(React.Component);

OnIdle.defaultProps = {
  placeholder: null
};
export default OnIdle;
export { default as OnIdlePlaceholder } from "./OnIdlePlaceholder";