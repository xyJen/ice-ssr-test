// @ts-nocheck
import { cIC, rIC } from "./idle-callback-polyfills";
import { queueMicrotask } from "./queueMicrotask";
var DEFAULT_MIN_TASK_TIME = 0;
var isSafari_ = !!(typeof safari === 'object' && safari.pushNotification);
/**
 * A class wraps a queue of requestIdleCallback functions for two reasons:
 *   1. So other callers can know whether or not the queue is empty.
 *   2. So we can provide some guarantees that the queued functions will
 *      run in unload-type situations.
 */

export var IdleQueue = /*#__PURE__*/function () {
  /**
   * Creates the IdleQueue instance and adds lifecycle event listeners to
   * run the queue if the page is hidden (with fallback behavior for Safari).
   * @param {{
   *   ensureTasksRun: boolean,
   *   defaultMinTaskTime: number,
   * }=} param1
   */
  function IdleQueue(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$ensureTasksRun = _ref.ensureTasksRun,
        ensureTasksRun = _ref$ensureTasksRun === void 0 ? false : _ref$ensureTasksRun,
        _ref$defaultMinTaskTi = _ref.defaultMinTaskTime,
        defaultMinTaskTime = _ref$defaultMinTaskTi === void 0 ? DEFAULT_MIN_TASK_TIME : _ref$defaultMinTaskTi;

    this.idleCallbackHandle_ = null;
    this.taskQueue_ = [];
    this.isProcessing_ = false;
    this.state_ = null;
    this.defaultMinTaskTime_ = defaultMinTaskTime;
    this.ensureTasksRun_ = ensureTasksRun; // Bind methods

    this.runTasksImmediately = this.runTasksImmediately.bind(this);
    this.runTasks_ = this.runTasks_.bind(this);
    this.onVisibilityChange_ = this.onVisibilityChange_.bind(this);

    if (this.ensureTasksRun_) {
      addEventListener('visibilitychange', this.onVisibilityChange_, true); // Safari does not reliably fire the `pagehide` or `visibilitychange`
      // events when closing a tab, so we have to use `beforeunload` with a
      // timeout to check whether the default action was prevented.
      // - https://bugs.webkit.org/show_bug.cgi?id=151610
      // - https://bugs.webkit.org/show_bug.cgi?id=151234
      // NOTE: we only add this to Safari because adding it to Firefox would
      // prevent the page from being eligible for bfcache.

      if (isSafari_) {
        addEventListener('beforeunload', this.runTasksImmediately, true);
      }
    }
  }
  /**
   * @param {...*} args
   */


  var _proto = IdleQueue.prototype;

  _proto.pushTask = function pushTask() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this.addTask_.apply(this, [Array.prototype.push].concat(args));
  }
  /**
   * @param {...*} args
   */
  ;

  _proto.unshiftTask = function unshiftTask() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    this.addTask_.apply(this, [Array.prototype.unshift].concat(args));
  }
  /**
   * Runs all scheduled tasks synchronously.
   */
  ;

  _proto.runTasksImmediately = function runTasksImmediately() {
    // By not passing a deadline, all tasks will be run sync.
    this.runTasks_();
  }
  /**
   * @return {boolean}
   */
  ;

  _proto.hasPendingTasks = function hasPendingTasks() {
    return this.taskQueue_.length > 0;
  }
  /**
   * Clears all pending tasks for the queue and stops any scheduled tasks
   * from running.
   */
  ;

  _proto.clearPendingTasks = function clearPendingTasks() {
    this.taskQueue_ = [];
    this.cancelScheduledRun_();
  }
  /**
   * Returns the state object for the currently running task. If no task is
   * running, null is returned.
   * @return {?Object}
   */
  ;

  _proto.getState = function getState() {
    return this.state_;
  }
  /**
   * Destroys the instance by unregistering all added event listeners and
   * removing any overridden methods.
   */
  ;

  _proto.destroy = function destroy() {
    this.taskQueue_ = [];
    this.cancelScheduledRun_();

    if (this.ensureTasksRun_) {
      removeEventListener('visibilitychange', this.onVisibilityChange_, true); // Safari does not reliably fire the `pagehide` or `visibilitychange`
      // events when closing a tab, so we have to use `beforeunload` with a
      // timeout to check whether the default action was prevented.
      // - https://bugs.webkit.org/show_bug.cgi?id=151610
      // - https://bugs.webkit.org/show_bug.cgi?id=151234
      // NOTE: we only add this to Safari because adding it to Firefox would
      // prevent the page from being eligible for bfcache.

      if (isSafari_) {
        removeEventListener('beforeunload', this.runTasksImmediately, true);
      }
    }
  }
  /**
   * @param {!Function} arrayMethod Either the Array.prototype{push|shift}.
   * @param {!Function} task
   * @param {{minTaskTime: number}=} param1
   * @private
   */
  ;

  _proto.addTask_ = function addTask_(arrayMethod, task, _temp2) {
    var _ref2 = _temp2 === void 0 ? {} : _temp2,
        _ref2$minTaskTime = _ref2.minTaskTime,
        minTaskTime = _ref2$minTaskTime === void 0 ? this.defaultMinTaskTime_ : _ref2$minTaskTime;

    var state = {
      time: Date.now(),
      visibilityState: document.visibilityState
    };
    arrayMethod.call(this.taskQueue_, {
      state: state,
      task: task,
      minTaskTime: minTaskTime
    });
    this.scheduleTasksToRun_();
  }
  /**
   * Schedules the task queue to be processed. If the document is in the
   * hidden state, they queue is scheduled as a microtask so it can be run
   * in cases where a macrotask couldn't (like if the page is unloading). If
   * the document is in the visible state, `requestIdleCallback` is used.
   * @private
   */
  ;

  _proto.scheduleTasksToRun_ = function scheduleTasksToRun_() {
    if (this.ensureTasksRun_ && document.visibilityState === 'hidden') {
      queueMicrotask(this.runTasks_);
    } else if (!this.idleCallbackHandle_) {
      this.idleCallbackHandle_ = rIC(this.runTasks_);
    }
  }
  /**
   * Runs as many tasks in the queue as it can before reaching the
   * deadline. If no deadline is passed, it will run all tasks.
   * If an `IdleDeadline` object is passed (as is with `requestIdleCallback`)
   * then the tasks are run until there's no time remaining, at which point
   * we yield to input or other script and wait until the next idle time.
   * @param {IdleDeadline=} deadline
   * @private
   */
  ;

  _proto.runTasks_ = function runTasks_(deadline) {
    if (deadline === void 0) {
      deadline = undefined;
    }

    this.cancelScheduledRun_();

    if (!this.isProcessing_) {
      this.isProcessing_ = true; // Process tasks until there's no time left or we need to yield to input.

      while (this.hasPendingTasks() && !shouldYield(deadline, this.taskQueue_[0].minTaskTime)) {
        var _this$taskQueue_$shif = this.taskQueue_.shift(),
            task = _this$taskQueue_$shif.task,
            state = _this$taskQueue_$shif.state;

        this.state_ = state;
        task(state);
        this.state_ = null;
      }

      this.isProcessing_ = false;

      if (this.hasPendingTasks()) {
        // Schedule the rest of the tasks for the next idle time.
        this.scheduleTasksToRun_();
      }
    }
  }
  /**
   * Cancels any scheduled idle callback and removes the handler (if set).
   * @private
   */
  ;

  _proto.cancelScheduledRun_ = function cancelScheduledRun_() {
    cIC(this.idleCallbackHandle_);
    this.idleCallbackHandle_ = null;
  }
  /**
   * A callback for the `visibilitychange` event that runs all pending
   * callbacks immediately if the document's visibility state is hidden.
   * @private
   */
  ;

  _proto.onVisibilityChange_ = function onVisibilityChange_() {
    if (document.visibilityState === 'hidden') {
      this.runTasksImmediately();
    }
  };

  return IdleQueue;
}();
/**
 * Returns true if the IdleDealine object exists and the remaining time is
 * less or equal to than the minTaskTime. Otherwise returns false.
 * @param {IdleDeadline|undefined} deadline
 * @param {number} minTaskTime
 * @return {boolean}
 * @private
 */

var shouldYield = function shouldYield(deadline, minTaskTime) {
  if (deadline && deadline.timeRemaining() <= minTaskTime) {
    return true;
  }

  return false;
};