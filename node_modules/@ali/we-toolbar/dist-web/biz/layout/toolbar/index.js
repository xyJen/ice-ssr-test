var _ToolbarMoreNormal, _div;

import React, { useMemo, useRef, useState, useEffect, useCallback } from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import { ToolbarArrowDownNormal as ArrowDownNormal, ToolbarMoreNormal, Dropdown } from '@ali/we-design';
import { ToolbarContext, OverLayContext } from "../contexts";
import { MODE_TYPE } from "../interface";
import { ToolbarWrapper, ToolbarLeftWrapper, ToolbarRightWrapper, MoreOverlay } from "./styled";
import { OffScreenWrapper } from "./OffScreenWrapper";
import ResizeObserver from 'resize-observer-polyfill';
import { debounce, uuid } from "../../../utils";
import IconButton from "../../../common/iconButton";
import CSSTransitionGroup from 'react-transition-group/CSSTransitionGroup';
import { useControlledValue } from "../../../hooks";
import { useGetContextLocale, useTranslate } from '@ali/we-util';
export { GroupWrapper as ToolbarGroupWrapper } from "./GroupWrapper";
export { RowWrapper as ToolbarRowWrapper } from "./RowWrapper";
export { ColumnWrapper as ToolbarColumnWrapper } from "./ColumnWrapper";
export var ToolbarLayout = /*#__PURE__*/React.memo(function (props) {
  var onModeChange = props.onModeChange,
      defaultMode = props.defaultMode,
      doubleLineToolbar = props.doubleLineToolbar,
      singleLineToolbar = props.singleLineToolbar,
      locale = props.locale,
      _props$safeDistance = props.safeDistance,
      safeDistance = _props$safeDistance === void 0 ? 100 : _props$safeDistance,
      hideSwitchBtn = props.hideSwitchBtn,
      backgroundColor = props.backgroundColor;
  var elRef = useRef();
  var leftElRef = useRef();
  var lockModeRef = useRef(false);
  var leftElResizeLock = useRef(false);

  var _useState = useState(),
      containment = _useState[0],
      setContainment = _useState[1];

  var _useState2 = useState([]),
      blocks = _useState2[0],
      setBlocks = _useState2[1];

  var _useState3 = useState([]),
      hideBlocks = _useState3[0],
      setHideBlocks = _useState3[1];

  var _useState4 = useState([]),
      overlayHideBlocks = _useState4[0],
      setOverlayShowBlocks = _useState4[1];

  var timer = useRef(0);

  var _useControlledValue = useControlledValue(props.mode, defaultMode),
      mode = _useControlledValue[0],
      setMode = _useControlledValue[1];

  var elRefWidth = useRef(0);

  var _useState5 = useState(0),
      elWidth = _useState5[0],
      setElwidth = _useState5[1];

  var _useState6 = useState(0),
      leftWrapWidth = _useState6[0],
      setLeftWrapWidth = _useState6[1];

  var _useState7 = useState(false),
      moreVisible = _useState7[0],
      setMoreVisible = _useState7[1];

  var _useState8 = useState(),
      moreOverlayCss = _useState8[0],
      setMoreOverlayCss = _useState8[1];

  var _useState9 = useState(),
      needReSize = _useState9[0],
      setNeedReSize = _useState9[1];

  var _useState10 = useState(0),
      needGetPositions = _useState10[0],
      setNeedGetPositions = _useState10[1];

  var _useState11 = useState(0),
      fontSizeMaxSelectSafeWidth = _useState11[0],
      setFontSizeMaxSelectSafeWidth = _useState11[1];

  var contextLocale = useGetContextLocale();
  var t = useTranslate(locale || contextLocale);
  var id = useMemo(function () {
    return uuid();
  }, []);
  var rightWrapWidth = 50;
  /**
   * 文字标题组件动态渲染逻辑
   */

  var resizeFontSizeMaxSelect = useCallback(function (width) {
    var fontSizeMaxSelect = blocks.find(function (o) {
      return o.hasFontSizeMaxSelect;
    });

    if (fontSizeMaxSelect && mode === fontSizeMaxSelect.mode) {
      var _blocks = blocks.filter(function (o) {
        return o.mode === fontSizeMaxSelect.mode;
      });

      var lastBlock = _blocks[_blocks.length - 1];

      if (lastBlock.offset + lastBlock.width < width - rightWrapWidth - safeDistance) {
        setFontSizeMaxSelectSafeWidth(width - rightWrapWidth - lastBlock.offset - lastBlock.width + fontSizeMaxSelect.width);
      } else {
        setFontSizeMaxSelectSafeWidth(fontSizeMaxSelect.width);
      }
    }
  }, [blocks, safeDistance, mode]); // useEffect(() => console.log(blocks), [blocks]);

  /**
   * 可视区域组件变化导致重新计算
   */

  useEffect(function () {
    setNeedGetPositions(new Date().getTime());
  }, [needReSize]);
  var layoutResize = useCallback(function (width) {
    if (elRef.current) {
      var hideEl = [];
      var showEl = [];
      blocks.forEach(function (o) {
        o.offset + safeDistance + rightWrapWidth < width ? showEl.push(o) : hideEl.push(o);
      });
      setHideBlocks(hideEl.map(function (o) {
        return o.id;
      }).concat(Array.from(new Set(hideEl.map(function (o) {
        return o.groupId || '';
      }))).filter(function (key) {
        return key && showEl.findIndex(function (o) {
          return o.groupId === key;
        }) === -1;
      })));
      setOverlayShowBlocks(showEl.map(function (o) {
        return o.id;
      }).concat(Array.from(new Set(showEl.map(function (o) {
        return o.groupId || '';
      }))).filter(function (key) {
        return key && hideEl.findIndex(function (o) {
          return o.groupId === key;
        }) === -1;
      })));
      resizeFontSizeMaxSelect(width);
    }
  }, [elRef, blocks, safeDistance, mode]);
  var controller = useMemo(function () {
    return {
      mode: mode,
      containment: containment,
      hideBlocks: hideBlocks,
      width: elWidth,
      layoutResize: layoutResize,
      leftWrapWidth: leftWrapWidth,
      fontSizeMaxSelectSafeWidth: fontSizeMaxSelectSafeWidth
    };
  }, [mode, containment, hideBlocks, elWidth, layoutResize, fontSizeMaxSelectSafeWidth]);
  /**
   * 切换单双行模式
   */

  var modeChange = useCallback(function () {
    // 1s内 不允许重复点击
    if (!lockModeRef.current) {
      var _mode = mode === MODE_TYPE.singleLine ? MODE_TYPE.doubleLine : MODE_TYPE.singleLine;

      setMode(_mode);
      onModeChange && onModeChange(_mode);
      lockModeRef.current = true;
      setTimeout(function () {
        lockModeRef.current = false;
      }, 600);
    }
  }, [mode, onModeChange, layoutResize, elRefWidth]);
  /**
   * 初始化绑定监听容器变化事件
   */

  useEffect(function () {
    if (!elRef.current) return;
    setContainment(elRef.current);
    var handleResize = debounce(function (w, lockMode) {
      if (elRef.current && !lockMode) {
        setElwidth(w);
        layoutResize(w);
        leftElRef.current && setLeftWrapWidth(leftElRef.current.clientWidth);
      }
    }, 50);
    var resizeObserver = new ResizeObserver(function (entries) {
      var entrie = entries.find(function (o) {
        return o.target.getAttribute('data-id') === "ToolbarWrapper_" + id;
      }); // Toolbar宽度变化时触发

      if (entrie) {
        elRefWidth.current = entrie.contentRect.width;
        handleResize(elRefWidth.current, lockModeRef.current);
        leftElResizeLock.current = true;
        clearTimeout(timer.current);
        timer.current = window.setTimeout(function () {
          leftElResizeLock.current = false;
        }, 500);
      } else if ( //  Toolbar宽度没有变化但是组件新增或者减少时触发
      entries.length === 1 && entries[0].target.getAttribute('data-id') === "ToolbarLeftWrapper_" + id && !leftElResizeLock.current) {
        setNeedReSize(new Date().getTime());
      }
    });

    if (resizeObserver && elRef.current && leftElRef.current) {
      resizeObserver.observe(elRef.current);
      resizeObserver.observe(leftElRef.current);
    }

    return function () {
      if (resizeObserver) {
        resizeObserver.disconnect();

        if (typeof handleResize.cancel === 'function') {
          handleResize.cancel();
        }
      }

      if (timer.current) clearTimeout(timer.current);
    };
  }, [elRef, layoutResize, resizeFontSizeMaxSelect]);
  var dropdownContextMemo = useMemo(function () {
    return {
      inOverlay: true,
      overlayHideBlocks: overlayHideBlocks,
      ignoreRegister: true
    };
  }, [overlayHideBlocks]);
  var toolbarContextMemo = useMemo(function () {
    return {
      inOverlay: false,
      overlayHideBlocks: [],
      ignoreRegister: true
    };
  }, []);
  var renderMoreBtn = useMemo(function () {
    if (hideBlocks.filter(function (o) {
      return o.startsWith(mode || '');
    }).length == 0) {
      return null;
    }
    /**
     * 展开收起动画
     */


    var moreTransition = function moreTransition() {
      setMoreOverlayCss(moreVisible ? 'scale-out' : 'scale-up');
      !moreVisible && setTimeout(function () {
        return setMoreOverlayCss('');
      }, 150);
      setTimeout(function () {
        return setMoreVisible(!moreVisible);
      }, !moreVisible ? 0 : 500);
    };

    return /*#__PURE__*/_createElement(Dropdown, {
      visible: moreVisible,
      overlayStyle: {
        backgroundColor: 'transparent',
        boxShadow: 'none',
        border: 'none'
      },
      overlay: /*#__PURE__*/_createElement(MoreOverlay, {
        className: moreOverlayCss
      }, /*#__PURE__*/_createElement(ToolbarLeftWrapper, null, /*#__PURE__*/_createElement(OverLayContext.Provider, {
        value: dropdownContextMemo
      }, mode === MODE_TYPE.doubleLine ? doubleLineToolbar : singleLineToolbar))),
      onVisibleChange: moreTransition,
      placement: "bottomRight",
      overlayAutoAlign: true,
      overlayAutoAlignDelay: 200
    }, /*#__PURE__*/_createElement("div", null, /*#__PURE__*/_createElement(IconButton, {
      icon: _ToolbarMoreNormal || (_ToolbarMoreNormal = /*#__PURE__*/_createElement(ToolbarMoreNormal, null)),
      size: mode === MODE_TYPE.singleLine ? 'medium' : 'large',
      title: t('we_toolbar_more'),
      testid: "toolbar_more",
      showTitle: mode !== MODE_TYPE.singleLine,
      className: "more-btn"
    })));
  }, [hideBlocks, overlayHideBlocks, mode, doubleLineToolbar, singleLineToolbar, moreVisible, moreOverlayCss]);
  return /*#__PURE__*/_createElement(React.Fragment, null, /*#__PURE__*/_createElement(OffScreenWrapper, {
    onBlockChange: setBlocks,
    needGetPositions: needGetPositions,
    mode: mode,
    doubleLineToolbar: doubleLineToolbar,
    singleLineToolbar: singleLineToolbar,
    id: id
  }), /*#__PURE__*/_createElement(ToolbarContext.Provider, {
    value: controller
  }, /*#__PURE__*/_createElement(ToolbarWrapper, {
    "data-id": "ToolbarWrapper_" + id,
    role: "toolbar" + mode,
    ref: elRef,
    mode: mode,
    backgroundColor: backgroundColor
  }, /*#__PURE__*/_createElement(ToolbarLeftWrapper, {
    "data-id": "ToolbarLeftWrapper_" + id,
    ref: leftElRef
  }, /*#__PURE__*/_createElement(OverLayContext.Provider, {
    value: toolbarContextMemo
  }, /*#__PURE__*/_createElement(CSSTransitionGroup, {
    transitionName: 'toolbar-left',
    transitionEnterTimeout: 500,
    transitionLeaveTimeout: 300
  }, mode === MODE_TYPE.singleLine ? /*#__PURE__*/_createElement("div", {
    key: "single",
    className: "single"
  }, singleLineToolbar, renderMoreBtn) : /*#__PURE__*/_createElement("div", {
    key: "double",
    className: "double"
  }, doubleLineToolbar, renderMoreBtn)))), !hideSwitchBtn && /*#__PURE__*/_createElement(ToolbarRightWrapper, {
    onClick: modeChange,
    mode: mode,
    backgroundColor: backgroundColor
  }, _div || (_div = /*#__PURE__*/_createElement("div", {
    className: "icon-wrap"
  }, /*#__PURE__*/_createElement(ArrowDownNormal, null)))))));
});
ToolbarLayout.defaultProps = {
  defaultMode: MODE_TYPE.singleLine,
  safeDistance: 100,
  hideSwitchBtn: false
};