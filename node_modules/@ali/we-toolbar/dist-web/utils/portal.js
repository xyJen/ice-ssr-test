import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";
import * as React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import * as ReactDOM from 'react-dom';
export var Portal = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Portal, _React$Component);

  function Portal(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.triggerRef = /*#__PURE__*/React.createRef();
    _this.portalRef = /*#__PURE__*/React.createRef();
    _this.portal = void 0;
    _this.oContainer = document.body;
    _this.hasAppended = false;

    _this.updatePortalPosition = function () {
      var _this$props = _this.props,
          visible = _this$props.visible,
          portalMatchTrigger = _this$props.portalMatchTrigger,
          triggerRect = _this$props.triggerRect;

      if (!visible) {
        return;
      }

      if (!_this.triggerRef.current && !triggerRect || !_this.portalRef.current) {
        return;
      }

      var trigger = _this.triggerRef.current;
      var portal = _this.portalRef.current;
      var curTriggerRect = triggerRect;

      if (!triggerRect && trigger) {
        var tRect = trigger.getBoundingClientRect();
        var tLeft = tRect.left,
            tTop = tRect.top,
            tWidth = tRect.width,
            tHeight = tRect.height;
        curTriggerRect = {
          left: tLeft,
          top: tTop,
          width: tWidth,
          height: tHeight
        };
      }

      if (!curTriggerRect) {
        return;
      }

      var _this$props2 = _this.props,
          offset = _this$props2.offset,
          position = _this$props2.position;

      var _portal$getBoundingCl = portal.getBoundingClientRect(),
          portalHeight = _portal$getBoundingCl.height,
          portalWidth = _portal$getBoundingCl.width;

      if (portalMatchTrigger) {
        portal.style.minWidth = curTriggerRect.width + "px";
      }
      /* 当有外部传入固定position时，优先采用position */


      if (position) {
        portal.style.top = position.top - portalHeight + "px";
        portal.style.left = position.left + "px";
      } else {
        // 计算底部剩余空间，若剩余空间能够容纳 portal，则向下展示 portal
        // 如果下方剩余空间无法容纳 portal，还需要判断上方空间能否容纳
        // 若上方也无法容纳(triggerRect.top < height)，则仍然放到下方
        // 左右则优先放右侧
        var offsetX = offset[0],
            offsetY = offset[1];
        var top = curTriggerRect.top + curTriggerRect.height + window.scrollY;
        var left = curTriggerRect.left + window.scrollX;
        var bottomSpace = _this.oContainer.clientHeight - top;
        var rightSpace = _this.oContainer.clientWidth - left;
        portal.style.top = bottomSpace < portalHeight && curTriggerRect.top > portalHeight ? curTriggerRect.top + window.scrollY + offsetY - portalHeight - 4 + "px" // 放到上方
        : top + offsetY + "px";
        portal.style.left = rightSpace < portalWidth && curTriggerRect.left + curTriggerRect.width > portalWidth ? left + curTriggerRect.width + offsetX - portalWidth - 4 + "px" : left + offsetX + "px";
      }

      portal.style.zIndex = '999';
    };

    var className = props.className; // Ref: https://reactjs.org/docs/portals.html#event-bubbling-through-portals

    _this.portal = document.createElement('div');

    if (className) {
      _this.portal.classList.add(className);
    }

    return _this;
  } // todo add throttle


  var _proto = Portal.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var getContainer = this.props.getContainer; // container 可能是 portal 的父组件，因此在 mount 后再获取 container

    if (getContainer) this.oContainer = getContainer() || document.body;
    this.appendIfVisible();
    this.updatePortalPosition();
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    this.appendIfVisible();
    this.updatePortalPosition();
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.hasAppended && this.portal) {
      this.oContainer.removeChild(this.portal);
    }

    if (this.portal) {
      this.portal = null;
    } // this.updatePortalPosition.cancel();

  };

  _proto.appendIfVisible = function appendIfVisible() {
    if (this.hasAppended) return;
    var oContainer = this.oContainer,
        portal = this.portal;
    var visible = this.props.visible;

    if (visible && portal) {
      oContainer.appendChild(portal);
      this.hasAppended = true;
    }
  };

  _proto.render = function render() {
    var _this$props3 = this.props,
        children = _this$props3.children,
        overlay = _this$props3.overlay,
        visible = _this$props3.visible;
    return /*#__PURE__*/_createElement(React.Fragment, null, children && /*#__PURE__*/React.cloneElement(children, {
      ref: this.triggerRef
    }), visible && this.portal ? /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/React.cloneElement(overlay, {
      ref: this.portalRef
    }), this.portal) : null);
  };

  return Portal;
}(React.Component);
Portal.defaultProps = {
  offset: [0, 0],
  portalMatchTrigger: true,
  className: '',
  visible: false
};