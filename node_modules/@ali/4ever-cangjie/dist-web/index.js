import _inheritsLoose from '@babel/runtime/helpers/inheritsLoose';
import _extends from '@babel/runtime/helpers/extends';
import isPlainObject from 'is-plain-object';
import _createClass from '@babel/runtime/helpers/createClass';
import equal from 'fast-deep-equal';
import _wrapNativeSuper from '@babel/runtime/helpers/wrapNativeSuper';
import _assertThisInitialized from '@babel/runtime/helpers/assertThisInitialized';
import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/objectWithoutPropertiesLoose';
import * as React from 'react';
import React__default, { useEffect, useCallback, useContext, createContext, useState, useRef, useReducer } from 'react';
import warning$1 from 'tiny-warning';
import { debounce, noop, curry, dropWhile, takeRightWhile, omitBy, isPlainObject as isPlainObject$1, isArray, isEmpty, forOwn, isObject, throttle, last, cond, stubTrue, omit, isEqual, difference, takeWhile, camelCase, trim, pick, union as union$1, once, merge } from 'lodash-es';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import UnicodeTrie from 'unicode-trie';
import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';
import ClipboardManager from '@ali/clipboard-manager';
import * as ReactDOM from 'react-dom';
import ReactDOM__default from 'react-dom';
import { isKeyHotkey } from 'is-hotkey';
import Debug from 'debug';
import { match, P } from 'ts-pattern';
import root from 'react-shadow';
import memoizeOne from 'memoize-one';
import { v1 } from 'uuid';
import * as ReactDOMServer from 'react-dom/server';
import { createHtmlParser } from '@ali/cangjie-lib-for-tree-shaking';

/**
 * @packageDocumentation
 * @module environment
 */
var IS_IOS = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var IS_ANDROID = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);
var IS_MOBILE = IS_IOS || IS_ANDROID;
var IS_TOUCH_DEVICE = typeof navigator !== 'undefined' && navigator.maxTouchPoints > 0;
var IS_IPAD = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad/.test(navigator.userAgent) && !window.MSStream;
var IS_MAC = typeof navigator !== 'undefined' && /Mac OS X/i.test(navigator.userAgent);
var IS_WINDOWS = typeof navigator !== 'undefined' && /Windows/i.test(navigator.userAgent);
var IS_FIREFOX = typeof navigator !== 'undefined' && /mozilla\/[a-z._\d]+ \((?:mobile)|(?:tablet)/i.test(navigator.userAgent); // Mac 容器内置的 Safari 内核浏览器在 userAgent 上没有 Safari 标识...
// 这里为了兼容钉钉容器内置 Safari 的情况

var IS_SAFARI = typeof navigator !== 'undefined' && navigator.vendor === 'Apple Computer, Inc.';
var IS_DEV = process.env.NODE_ENV === 'development';
var IS_NODE = !!(typeof process !== 'undefined' && process.versions && process.versions.node);
/**
 * 返回 Chrome 版本
 */

var getChromeVersion = function getChromeVersion() {
  var _navigator, _navigator$userAgent;

  var raw = (_navigator = navigator) == null ? void 0 : (_navigator$userAgent = _navigator.userAgent) == null ? void 0 : _navigator$userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
  return raw ? parseInt(raw[2], 10) : -1;
};

var environment = /*#__PURE__*/Object.freeze({
  __proto__: null,
  IS_IOS: IS_IOS,
  IS_ANDROID: IS_ANDROID,
  IS_MOBILE: IS_MOBILE,
  IS_TOUCH_DEVICE: IS_TOUCH_DEVICE,
  IS_IPAD: IS_IPAD,
  IS_MAC: IS_MAC,
  IS_WINDOWS: IS_WINDOWS,
  IS_FIREFOX: IS_FIREFOX,
  IS_SAFARI: IS_SAFARI,
  IS_DEV: IS_DEV,
  IS_NODE: IS_NODE,
  getChromeVersion: getChromeVersion
});

function _createForOfIteratorHelperLoose$b(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$b(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray$b(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$b(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$b(o, minLen); }

function _arrayLikeToArray$b(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * @packageDocumentation
 * @ignore
 */

/**
 * Freeze an object or array in Cangjie data to prevent modification
 *
 * Since Cangjie abandoned the immutableJS library, now it's developer's
 * responsibility to create new data object for any updated properties.
 * This function is used in Cangjie debug mode to prevent mistakes of altering
 * existing object.
 *
 * Note:
 * 1. use it in development mode, since it may cause bad performance
 *   https://immerjs.github.io/immer/docs/performance
 *
 * 2. use it in 'strict mode' to trigger a TypeError; otherwise the caller
 *   will just fails silently, which doesn't make any use it.
 */
function isFrozen(obj) {
  if (obj === null || typeof obj !== 'object') {
    return true;
  }

  return Object.isFrozen(obj);
}

function deepFreeze(obj) {
  if (isFrozen(obj)) {
    return;
  } // we don't use Object.keys here, as we want to incude Arrays


  var propNames = Object.getOwnPropertyNames(obj);

  for (var _iterator = _createForOfIteratorHelperLoose$b(propNames), _step; !(_step = _iterator()).done;) {
    var key = _step.value;
    var value = obj[key];

    if (!isFrozen(value)) {
      deepFreeze(value);
    }
  }

  return Object.freeze(obj);
}

/**
 * @packageDocumentation
 * @ignore
 */

var ImmutableRecord = /*#__PURE__*/function () {
  function ImmutableRecord() {}

  var _proto = ImmutableRecord.prototype;

  _proto.freeze = function freeze() {
    if (IS_DEV) {
      deepFreeze(this);
    }
  };

  return ImmutableRecord;
}();

var Node$1 = /*#__PURE__*/function (_ImmutableRecord) {
  _inheritsLoose(Node, _ImmutableRecord);

  Node.createProperties = function createProperties(attrs) {
    if (attrs === void 0) {
      attrs = {};
    }

    if (typeof attrs === 'string') {
      return {
        type: attrs
      };
    }

    if (isPlainObject(attrs)) {
      return attrs;
    }

    throw new Error("`Node.createProperties` only accepts objects, strings, but you passed it: " + attrs);
  };

  function Node(props) {
    var _this;

    _this = _ImmutableRecord.call(this) || this;
    _this.key = void 0;
    var key = props.key;
    _this.key = key;
    return _this;
  }

  var _proto = Node.prototype;

  /**
   * 把当前的 Node 转化成子类型（Text 或者 Element）
   */
  _proto.toSubType = function toSubType() {
    var node = this;

    if (node instanceof Text$1) {
      return node;
    } else if (node instanceof Element$1) {
      return node;
    }

    throw new Error(node + " is not a Node");
  }
  /**
   * 此节点是否是一个Text节点。see Text.isText
   */
  ;

  _proto.isText = function isText() {
    return this instanceof Text$1;
  }
  /**
   * 此节点是否是一个Element节点。see Element.isElement
   */
  ;

  _proto.isElement = function isElement() {
    return this instanceof Element$1;
  }
  /**
   * 获取第一个叶子Node；如果自身就是一个叶子Node，则返回自身
   * 根据目前Schema规范，返回的都都是一个text；但是后续Cangjie扩展，可能返回其它类型Node
   */
  ;

  _proto.getFirstNode = function getFirstNode() {
    if (!this.isElement() || !this.nodes.length) {
      return this;
    }

    return this.nodes[0].getFirstNode();
  }
  /**
   * 获取最后一个叶子Node；如果自身就是一个叶子Node，则返回自身
   * 根据目前Schema规范，返回的都都是一个text；但是后续Cangjie扩展，可能返回其它类型Node
   */
  ;

  _proto.getLastNode = function getLastNode() {
    if (!this.isElement() || !this.nodes.length) {
      return this;
    }

    return this.nodes[this.nodes.length - 1].getLastNode();
  }
  /**
   * 获取第一个Text
   * 根据目前Schema规范，都会返回一个text；但是后续Cangjie扩展，可能返回null
   */
  ;

  _proto.getFirstText = function getFirstText() {
    if (this.isText()) {
      return this;
    }

    if (!this.isElement() || !this.nodes.length) {
      return null;
    }

    return this.nodes[0].getFirstText();
  }
  /**
   * 获取最后一个Text
   * 根据目前Schema规范，都会返回一个text；但是后续Cangjie扩展，可能返回null
   */
  ;

  _proto.getLastText = function getLastText() {
    if (this.isText()) {
      return this;
    }

    if (!this.isElement() || !this.nodes.length) {
      return null;
    }

    return this.nodes[this.nodes.length - 1].getLastText();
  };

  return Node;
}(ImmutableRecord);

var Mark = /*#__PURE__*/function (_ImmutableRecord) {
  _inheritsLoose(Mark, _ImmutableRecord);

  Mark.create = function create(properties) {
    if (Mark.isMark(properties)) {
      return properties;
    }

    var props = properties;

    if (typeof props === 'string') {
      props = {
        type: props
      };
    }

    if (isPlainObject(props)) {
      var _props = props,
          type = _props.type,
          _props$data = _props.data,
          data = _props$data === void 0 ? {} : _props$data;

      if (typeof type !== 'string') {
        throw new Error('`Mark.fromJS` requires a `type` string.');
      }

      return new Mark({
        type: type,
        data: data
      });
    }

    throw new Error("`Mark.create` only accepts objects, strings or marks, but you passed it: " + properties);
  };

  Mark.fromJSON = function fromJSON(json) {
    return Mark.create(json);
  };

  Mark.isMark = function isMark(maybeMark) {
    return maybeMark instanceof Mark;
  };

  function Mark(props) {
    var _this;

    _this = _ImmutableRecord.call(this) || this;
    _this.type = void 0;
    _this.data = void 0;
    var type = props.type,
        data = props.data;
    _this.type = type;
    _this.data = _extends({}, data);

    _this.freeze();

    return _this;
  }

  var _proto = Mark.prototype;

  _proto.merge = function merge(props) {
    return new Mark(_extends({
      type: this.type,
      data: this.data
    }, props));
  };

  _proto.set = function set(key, value) {
    var _this$merge;

    return this.merge((_this$merge = {}, _this$merge[key] = value, _this$merge));
  };

  _proto.isEqual = function isEqual(mark) {
    return equal(this, mark);
  };

  _proto.toJSON = function toJSON() {
    return {
      klass: 'mark',
      type: this.type,
      data: _extends({}, this.data)
    };
  };

  return Mark;
}(ImmutableRecord);

/**
 * @packageDocumentation
 * @ignore
 */
var listUtils = {
  skipUntil: function skipUntil(as, func) {
    var index = as.findIndex(function (a) {
      return func(a);
    });

    if (index === -1) {
      return [];
    }

    return as.slice(index);
  },
  takeUntil: function takeUntil(as, func) {
    var index = as.findIndex(function (a) {
      return func(a);
    });

    if (index === -1) {
      return as.slice();
    }

    return as.slice(0, index);
  },
  hasSameMembers: function hasSameMembers(a, b) {
    if (a.length !== b.length) {
      return false;
    }

    return a.length === 0 || a.every(function (aElem) {
      return !!b.find(function (bElem) {
        return equal(aElem, bElem);
      });
    });
  }
};

function has(as, b) {
  return as.some(function (a) {
    return equal(a, b);
  });
}

function union(as, bs) {
  return bs.reduce(function (merged, b) {
    if (has(merged, b)) {
      return merged;
    }

    return [].concat(merged, [b]);
  }, as);
}

function except(as, bs) {
  return as.filter(function (a) {
    return !has(bs, a);
  });
}

var Leaf = /*#__PURE__*/function (_ImmutableRecord) {
  _inheritsLoose(Leaf, _ImmutableRecord);

  Leaf.create = function create(properties) {
    if (properties === void 0) {
      properties = '';
    }

    if (Leaf.isLeaf(properties)) {
      return properties;
    }

    var props = properties;

    if (typeof props === 'string') {
      props = {
        text: props
      };
    }

    if (isPlainObject(props)) {
      var _props = props,
          _props$text = _props.text,
          text = _props$text === void 0 ? '' : _props$text,
          _props$marks = _props.marks,
          marks = _props$marks === void 0 ? [] : _props$marks;
      return new Leaf({
        text: text,
        marks: marks.map(Mark.create)
      });
    }

    throw new Error("`Leaf.create` only accepts objects, strings or leaves, but you passed it: " + properties);
  };

  Leaf.fromJSON = function fromJSON(json) {
    var marks = json.marks;
    return Leaf.create(_extends({}, json, {
      marks: marks ? marks.map(Mark.fromJSON) : undefined
    }));
  };

  Leaf.isLeaf = function isLeaf(maybeLeaf) {
    return maybeLeaf instanceof Leaf;
  }
  /**
   * 对leaves进行normalize，并返回新Leafs
   */
  ;

  Leaf.normalizeLeaves = function normalizeLeaves(leaves) {
    if (leaves.length === 0) {
      return [Leaf.create()];
    }

    if (leaves.length === 1) {
      return leaves;
    }

    var invalid = false;
    var normalized = leaves.reduceRight(function (ls, leaf) {
      var next = ls[0];

      if (!next) {
        return [leaf];
      }

      if (listUtils.hasSameMembers(leaf.marks, next.marks)) {
        invalid = true;
        ls[0] = next.set('text', "" + leaf.text + next.text);
        return ls;
      }

      if (next.text === '') {
        invalid = true;
        ls[0] = leaf;
        return ls;
      }

      if (leaf.text === '') {
        invalid = true;
        return ls;
      }

      ls.unshift(leaf);
      return ls;
    }, []);

    if (!invalid) {
      return leaves;
    }

    return normalized;
  }
  /**
   * 对leaves执行split操作。
   * @offset text的偏移量，如果位于某一个leaf内部，则分割该leaf
   */
  ;

  Leaf.splitLeaves = function splitLeaves(leaves, offset) {
    if (offset < 0) {
      return [[], leaves];
    }

    if (leaves.length === 0) {
      return [[], []];
    }

    var endOffset = 0;
    var left;
    var right;
    var index = leaves.findIndex(function (leaf) {
      var startOffset = endOffset;
      var text = leaf.text;
      endOffset += text.length;

      if (endOffset < offset) {
        return false;
      }

      if (startOffset > offset) {
        return false;
      }

      var length = offset - startOffset;

      if (typeof text.slice !== 'function') {
        throw new Error("Unable to split leaf with text: " + text);
      }

      left = leaf.set('text', text.slice(0, length));
      right = leaf.set('text', text.slice(length));
      return true;
    });

    if (!left || !right) {
      // Same as `!left && !right`
      return [leaves, []];
    }

    if (left.text === '') {
      if (index === 0) {
        return [[left], leaves];
      }

      return [leaves.slice(0, index), leaves.slice(index)];
    }

    if (right.text === '') {
      if (index === leaves.length - 1) {
        return [leaves, [right]];
      }

      var splittedIndex = index + 1;
      return [leaves.slice(0, splittedIndex), leaves.slice(splittedIndex)];
    }

    return [[].concat(leaves.slice(0, index), [left]), [right].concat(leaves.slice(index + 1))];
  }
  /**
   * 在leaves中搜索第offset个字符对应的位置
   */
  ;

  Leaf.searchLeafAtOffset = function searchLeafAtOffset(leaves, offset) {
    var startOffset = 0;
    var endOffset = 0;
    var index = leaves.findIndex(function (leaf) {
      startOffset = endOffset;
      endOffset = startOffset + leaf.text.length;
      return endOffset >= offset;
    });
    var found = index !== -1;

    if (!found) {
      return null;
    }

    return {
      index: index,
      leaf: leaves[index],
      startOffset: startOffset,
      endOffset: endOffset
    };
  };

  function Leaf(props) {
    var _this;

    _this = _ImmutableRecord.call(this) || this;
    _this.text = void 0;
    _this.marks = void 0;
    var text = props.text,
        marks = props.marks;
    _this.text = text;
    _this.marks = marks;

    _this.freeze();

    return _this;
  }

  var _proto = Leaf.prototype;

  _proto.merge = function merge(props) {
    return new Leaf(_extends({
      text: this.text,
      marks: this.marks
    }, props));
  };

  _proto.set = function set(key, value) {
    var _this$merge;

    return this.merge((_this$merge = {}, _this$merge[key] = value, _this$merge));
  }
  /**
   * 拷贝一个新Leaf，并把Mark加上去
   */
  ;

  _proto.addMark = function addMark(mark) {
    return this.set('marks', union(this.marks, [mark]));
  }
  /**
   * 拷贝一个新Leaf，并把Marks加上去
   */
  ;

  _proto.addMarks = function addMarks(marks) {
    return this.set('marks', union(this.marks, marks));
  }
  /**
   * 拷贝一个新Leaf，并把Mark过滤掉
   */
  ;

  _proto.removeMark = function removeMark(mark) {
    return this.set('marks', except(this.marks, [mark]));
  }
  /**
   * 拷贝一个新Leaf，并把Mark替换掉
   * 如果mark不存在、mark和新mark相等，则返回当前的Leaf
   */
  ;

  _proto.setMark = function setMark(mark, newMark) {
    if (equal(mark, newMark)) {
      return this;
    }

    var marks = this.marks;

    if (!has(marks, mark)) {
      return this;
    }

    var newMarks = marks.map(function (m) {
      return equal(m, mark) ? newMark : mark;
    });
    return this.set('marks', newMarks);
  };

  _proto.toJSON = function toJSON() {
    return {
      klass: 'leaf',
      text: this.text,
      marks: this.marks.map(function (mark) {
        return mark.toJSON();
      })
    };
  };

  return Leaf;
}(ImmutableRecord);

/**
 * @packageDocumentation
 * @module keyUtils
 */

/**
 * cangjie key 生成逻辑，默认从 0 开始递增。
 *
 * key 在多版本、多实例 cangjie 嵌套时，保持全局唯一
 */
var localCount = 0;
var cangjieKeyGen = '__cangjieKeyGen';
var hasWindow = typeof window === 'object';

if (hasWindow && !window[cangjieKeyGen]) {
  window[cangjieKeyGen] = 0;
}

var keyUtils = {
  create: function create() {
    if (hasWindow) {
      var _keyStr = "" + window[cangjieKeyGen];

      window[cangjieKeyGen] = window[cangjieKeyGen] + 1;
      return _keyStr;
    }

    var keyStr = "" + localCount;
    localCount = localCount + 1;
    return keyStr;
  },
  parse: function parse(key) {
    var _key$split = key.split(':'),
        k = _key$split[0],
        o = _key$split[1];

    return [k, parseInt(o, 10)];
  },
  resetGenerator: function resetGenerator() {
    if (hasWindow) {
      window[cangjieKeyGen] = 0;
    }

    localCount = 0;
  }
};

/**
 * @packageDocumentation
 * @ignore
 */
var setUtils = {
  add: function add(as, b) {
    var index = as.findIndex(function (a) {
      return equal(a, b);
    });
    var newAs = [].concat(as);

    if (index !== -1) {
      newAs.splice(index, 1);
    }

    newAs.push(b);
    return newAs;
  },
  remove: function remove(as, b) {
    return as.filter(function (a) {
      return !equal(a, b);
    });
  },
  has: function has(as, b, isEqual) {
    if (isEqual === void 0) {
      isEqual = equal;
    }

    return as.some(function (a) {
      return isEqual(a, b);
    });
  },
  intersect: function intersect(as, bs) {
    return as.filter(function (a) {
      return bs.some(function (b) {
        return equal(a, b);
      });
    });
  },
  union: function union(as, bs, isEqual) {
    var _this = this;

    if (isEqual === void 0) {
      isEqual = equal;
    }

    return bs.reduce(function (merged, b) {
      if (_this.has(merged, b, isEqual)) {
        return merged;
      }

      merged.push(b);
      return merged;
    }, [].concat(as));
  },
  removeDuplicate: function removeDuplicate(as) {
    return as.filter(function (a, index) {
      return index === as.findIndex(function (b) {
        return equal(b, a);
      });
    });
  },
  isSuperSet: function isSuperSet(as, bs) {
    return bs.every(function (b) {
      return as.findIndex(function (a) {
        return equal(a, b);
      }) !== -1;
    });
  }
};

var SUPRESS_NORMALIZE = {
  normalize: false
};
var TEXTS = new WeakMap();

var Text$1 = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Text, _Node);

  Text.create = function create(properties) {
    if (properties === void 0) {
      properties = '';
    }

    if (Text.isText(properties)) {
      return properties;
    }

    var props = properties;

    if (typeof props === 'string') {
      props = {
        leaves: [Leaf.create(props)]
      };
    }

    if (isPlainObject(props)) {
      var _props = props,
          _props$key = _props.key,
          key = _props$key === void 0 ? keyUtils.create() : _props$key,
          _props$leaves = _props.leaves,
          leaves = _props$leaves === void 0 ? [] : _props$leaves;
      return new Text({
        key: key,
        leaves: leaves.map(Leaf.create)
      });
    }

    throw new Error("`Text.create` only accepts objects, strings or texts, but you passed it: " + properties);
  };

  Text.fromJSON = function fromJSON(json) {
    return Text.create(_extends({}, json, {
      leaves: json.leaves.map(Leaf.fromJSON)
    }));
  };

  Text.isText = function isText(maybeText) {
    return maybeText instanceof Text;
  };

  Text.isEmptyText = function isEmptyText(maybeText) {
    return maybeText instanceof Text && !maybeText.text;
  };

  Text.isTextList = function isTextList(maybeTextList) {
    return Array.isArray(maybeTextList) && maybeTextList.every(Text.isText);
  };

  function Text(props, options) {
    var _this;

    if (options === void 0) {
      options = {
        normalize: true
      };
    }

    _this = _Node.call(this, props) || this;
    _this.leaves = void 0;
    var leaves = props.leaves;
    _this.leaves = options.normalize ? Leaf.normalizeLeaves(leaves) : leaves;

    _this.freeze();

    return _this;
  }

  var _proto = Text.prototype;

  /**
   * 获取自身树下的所有 Text 节点
   * 如果自身是 Text，则返回只含有自身的数组
   */
  _proto.getTexts = function getTexts() {
    return [this];
  };

  _proto.merge = function merge(props) {
    return new Text(_extends({
      key: this.key,
      leaves: this.leaves
    }, props));
  };

  _proto.set = function set(key, value) {
    var _this$merge;

    return this.merge((_this$merge = {}, _this$merge[key] = value, _this$merge));
  };

  _proto.regenerateKey = function regenerateKey() {
    return this.set('key', keyUtils.create());
  };

  _proto.getLeaves = function getLeaves(decorations) {
    if (!decorations || decorations.length === 0) {
      return this.leaves;
    }

    if (this.leaves.length === 0) {
      var marks = decorations.map(function (_ref) {
        var mark = _ref.mark;
        return mark;
      });
      var leaf = Leaf.create({
        text: '',
        marks: marks
      });
      return [leaf];
    }

    if (this.text.length === 0) {
      var firstLeaf = this.leaves[0];

      var _marks = decorations.map(function (d) {
        return d.mark;
      });

      return [firstLeaf.addMarks(_marks)];
    }

    var key = this.key,
        text = this.text;
    var leaves = this.leaves;
    decorations.forEach(function (dec) {
      var start = dec.start,
          end = dec.end,
          mark = dec.mark;
      var hasStart = start.key === key;
      var hasEnd = end.key === key;

      if (hasStart || hasEnd) {
        var index = hasStart ? start.offset : 0;
        var length = hasEnd ? end.offset - index : text.length - index;

        if (length < 1) {
          return;
        }

        if (index >= text.length) {
          return;
        }

        if (index !== 0 || length < text.length) {
          var _Leaf$splitLeaves = Leaf.splitLeaves(leaves, index),
              before = _Leaf$splitLeaves[0],
              bundle = _Leaf$splitLeaves[1];

          var _Leaf$splitLeaves2 = Leaf.splitLeaves(bundle, length),
              middle = _Leaf$splitLeaves2[0],
              after = _Leaf$splitLeaves2[1];

          leaves = before.concat(middle.map(function (l) {
            return l.addMark(mark);
          }), after);
          return;
        }
      }

      leaves = leaves.map(function (l) {
        return l.addMark(mark);
      });
    });

    if (leaves === this.leaves) {
      return leaves;
    }

    return Leaf.normalizeLeaves(leaves);
  }
  /**
   * 获取所有的marks
   */
  ;

  _proto.getMarks = function getMarks() {
    if (this.leaves.length === 0) {
      return [];
    }

    return this.leaves.reduce(function (marks, leaf) {
      return setUtils.union(marks, leaf.marks);
    }, []);
  }
  /**
   * 获取text内所有文字都有的，公共marks
   */
  ;

  _proto.getActiveMarks = function getActiveMarks() {
    if (this.leaves.length === 0) {
      return [];
    }

    var firstMarks = this.leaves[0].marks;

    if (firstMarks.length === 0) {
      return firstMarks;
    }

    return this.leaves.slice(1).reduce(function (marks, leaf) {
      return setUtils.intersect(marks, leaf.marks);
    }, firstMarks);
  }
  /**
   * 根据offset区间，获取marks
   */
  ;

  _proto.getMarksBetweenOffsets = function getMarksBetweenOffsets(startOffset, endOffset) {
    if (startOffset <= 0 && endOffset >= this.text.length) {
      return this.getMarks();
    }

    if (startOffset >= endOffset) return []; // For empty text in a paragraph, use getActiveMarks;

    if (this.text === '') return this.getActiveMarks();
    var result = null;
    var leafEnd = 0;
    this.leaves.forEach(function (leaf) {
      var leafStart = leafEnd;
      leafEnd = leafStart + leaf.text.length;
      if (leafEnd <= startOffset) return;
      if (leafStart >= endOffset) return;

      if (!result) {
        result = leaf.marks;
        return;
      }

      result = setUtils.union(result, leaf.marks);
    });
    return result || [];
  }
  /**
   * 根据offset区间，获取区间内所有文字都含有的，公共marks
   */
  ;

  _proto.getActiveMarksBetweenOffsets = function getActiveMarksBetweenOffsets(startOffset, endOffset) {
    if (startOffset <= 0 && endOffset >= this.text.length) {
      return this.getActiveMarks();
    }

    if (startOffset >= endOffset) return []; // For empty text in a paragraph, use getActiveMarks;

    if (this.text === '') return this.getActiveMarks();
    var result = [];
    var leafEnd = 0;
    var foundNoMarks = false;
    this.leaves.forEach(function (leaf) {
      var leafStart = leafEnd;
      leafEnd = leafStart + leaf.text.length;
      if (leafEnd <= startOffset) return;
      if (leafStart >= endOffset) return;
      foundNoMarks = foundNoMarks || !leaf.marks.length;

      if (!result.length) {
        result = leaf.marks;
        return;
      }

      result = setUtils.intersect(result, leaf.marks);
    });

    if (foundNoMarks && result.length) {
      // aaaBBB: a has no marks, B has marks, so they have no intersected marks
      result = [];
    }

    return result || [];
  }
  /**
   * 获取第index个文字，对应的marks
   */
  ;

  _proto.getMarksAtIndex = function getMarksAtIndex(index) {
    var leafObj = Leaf.searchLeafAtOffset(this.leaves, index);
    return !leafObj ? [] : leafObj.leaf.marks;
  }
  /**
   * 拷贝出一个新的text节点，并在指定的位置添加mark
   * 如果offset不合法，则返回自身
   */
  ;

  _proto.addMark = function addMark(offset, length, mark) {
    return this.addMarks(offset, length, [mark]);
  }
  /**
   * 拷贝出一个新的text节点，并在指定的位置添加marks。
   * 如果marks是0，或者offset不合法，则返回自身
   */
  ;

  _proto.addMarks = function addMarks(offset, length, marks) {
    if (this.text === '' && offset === 0) {
      var leaves = this.leaves;
      var first = leaves[0];

      if (!first) {
        return this.set('leaves', [Leaf.create({
          text: '',
          marks: marks
        })]);
      }

      var newFirst = first.addMarks(marks);

      if (newFirst === first) {
        return this;
      }

      return this.set('leaves', [newFirst]);
    }

    if (length === 0 || offset >= this.text.length) {
      return this;
    }

    var _Leaf$splitLeaves3 = Leaf.splitLeaves(this.leaves, offset),
        before = _Leaf$splitLeaves3[0],
        bundle = _Leaf$splitLeaves3[1];

    var _Leaf$splitLeaves4 = Leaf.splitLeaves(bundle, length),
        middle = _Leaf$splitLeaves4[0],
        after = _Leaf$splitLeaves4[1];

    return this.set('leaves', [].concat(before, middle.map(function (leaf) {
      return leaf.addMarks(marks);
    }), after));
  }
  /**
   * 拷贝出一个新的text节点，并在指定的位置过滤掉对应的mark
   * 如果当前没有这个mark，或者offset不合法，则返回自身
   */
  ;

  _proto.removeMark = function removeMark(offset, length, mark) {
    if (this.text === '' && offset === 0) {
      var leaves = this.leaves;
      var first = leaves[0];

      if (!first) {
        return this;
      }

      var newFirst = first.removeMark(mark);

      if (newFirst === first) {
        return this;
      }

      return this.set('leaves', [newFirst]);
    }

    if (length === 0 || offset >= this.text.length) {
      return this;
    }

    var _Leaf$splitLeaves5 = Leaf.splitLeaves(this.leaves, offset),
        before = _Leaf$splitLeaves5[0],
        bundle = _Leaf$splitLeaves5[1];

    var _Leaf$splitLeaves6 = Leaf.splitLeaves(bundle, length),
        middle = _Leaf$splitLeaves6[0],
        after = _Leaf$splitLeaves6[1];

    return this.set('leaves', [].concat(before, middle.map(function (leaf) {
      return leaf.removeMark(mark);
    }), after));
  }
  /**
   * 在指定的区间，设置一个新的Mark
   * 如果指定区间不合法，或者区间内已经存在同样的mark，则返回自身
   */
  ;

  _proto.setMark = function setMark(offset, length, mark, properties) {
    var newMark = mark.merge(properties);

    if (this.text === '' && offset === 0 && length === 0) {
      var leaves = this.leaves;
      var first = leaves[0];

      if (!first) {
        return this;
      }

      var newFirst = first.setMark(mark, newMark);

      if (newFirst === first) {
        return this;
      }

      return this.set('leaves', [newFirst]);
    }

    if (length === 0 || offset >= this.text.length) {
      return this;
    }

    var _Leaf$splitLeaves7 = Leaf.splitLeaves(this.leaves, offset),
        before = _Leaf$splitLeaves7[0],
        bundle = _Leaf$splitLeaves7[1];

    var _Leaf$splitLeaves8 = Leaf.splitLeaves(bundle, length),
        middle = _Leaf$splitLeaves8[0],
        after = _Leaf$splitLeaves8[1];

    return this.set('leaves', [].concat(before, middle.map(function (leaf) {
      return leaf.setMark(mark, newMark);
    }), after));
  }
  /**
   * 复制出一个新的text，并在指定的位置，插入对应的文字和marks
   */
  ;

  _proto.insertText = function insertText(offset, text, marks) {
    if (marks === void 0) {
      marks = [];
    }

    if (this.text === '') {
      return this.set('leaves', [Leaf.create({
        text: text,
        marks: marks
      })]);
    }

    if (text.length === 0) {
      return this;
    }

    var leaves = this.leaves;
    var leafObj = Leaf.searchLeafAtOffset(leaves, offset);

    if (!leafObj) {
      throw new Error("Text.insertText, could not find leaf with offset: " + offset);
    }

    var index = leafObj.index,
        leaf = leafObj.leaf,
        startOffset = leafObj.startOffset;
    var delta = offset - startOffset;
    var beforeText = leaf.text.slice(0, delta);
    var afterText = leaf.text.slice(delta);
    var newLeaves = [].concat(leaves);

    if (listUtils.hasSameMembers(leaf.marks, marks)) {
      var newLeaf = leaf.set('text', beforeText + text + afterText);
      newLeaves[index] = newLeaf;
      return this.set('leaves', newLeaves);
    }

    newLeaves.splice(index, 1, leaf.set('text', beforeText), Leaf.create({
      text: text,
      marks: marks
    }), leaf.set('text', afterText));
    return this.set('leaves', newLeaves);
  }
  /**
   * 在指定的位置，删掉指定的text长度的文字
   * 本杰：TODO: check whether deleted text is same as text?
   */
  ;

  _proto.removeText = function removeText(offset, text) {
    if (text.length === 0 || offset >= this.text.length) {
      return this;
    } // PERF: For simple backspace, we can operate directly on the leaf


    if (text.length === 1) {
      var leafObj = Leaf.searchLeafAtOffset(this.leaves, offset + 1);

      if (!leafObj) {
        throw new Error("Text.removeText, could not find leaf with offset: " + offset);
      }

      var index = leafObj.index,
          leaf = leafObj.leaf,
          startOffset = leafObj.startOffset;
      var newLeaves = [].concat(this.leaves);

      if (leaf.text.length === 1) {
        if (newLeaves.length === 1) {
          // keep marks when delete the last leaf
          newLeaves[0] = Leaf.create({
            text: '',
            marks: leaf.marks
          });
        } else {
          newLeaves.splice(index, 1);
        } // PERF: Avoid normalizing twice for normalized `leaves`.


        return new Text({
          key: this.key,
          leaves: newLeaves
        }, SUPRESS_NORMALIZE);
      }

      var delta = offset - startOffset;
      var beforeText = leaf.text.slice(0, delta);
      var afterText = leaf.text.slice(delta + text.length);
      var newText = beforeText + afterText;
      newLeaves[index] = leaf.set('text', newText);
      return new Text({
        key: this.key,
        leaves: newLeaves
      }, SUPRESS_NORMALIZE);
    }

    var _Leaf$splitLeaves9 = Leaf.splitLeaves(this.leaves, offset),
        before = _Leaf$splitLeaves9[0],
        bundle = _Leaf$splitLeaves9[1];

    var after = Leaf.splitLeaves(bundle, text.length)[1]; // PERF: reduce `leaves` to be normalized.

    var middle = Leaf.normalizeLeaves([].concat(before.slice(-1), after.slice(0, 1)));
    var leaves = [].concat(before.slice(0, -1), middle, after.slice(1));

    if (leaves.length === 1) {
      var first = leaves[0];

      if (first.text === '') {
        return new Text({
          key: this.key,
          leaves: [first.set('marks', this.getActiveMarks())]
        }, SUPRESS_NORMALIZE);
      }
    }

    return new Text({
      key: this.key,
      leaves: leaves
    }, SUPRESS_NORMALIZE);
  }
  /**
   * 拷贝出一个新的text，并把传入的text的leaves添加上去
   */
  ;

  _proto.mergeText = function mergeText(other) {
    var leaves = this.leaves.concat(other.leaves);
    return this.set('leaves', leaves);
  }
  /**
   * 在指定的位置做一个split，返回split后的两个text
   */
  ;

  _proto.splitText = function splitText(position) {
    var _Leaf$splitLeaves10 = Leaf.splitLeaves(this.leaves, position),
        befores = _Leaf$splitLeaves10[0],
        afters = _Leaf$splitLeaves10[1];

    var a = this.set('leaves', befores);
    var b = this.set('leaves', afters).regenerateKey();
    return [a, b];
  };

  _proto.toJSON = function toJSON(options) {
    var object = {
      klass: 'text',
      leaves: this.leaves.map(function (leaf) {
        return leaf.toJSON();
      })
    };

    if (options != null && options.preserveKeys) {
      object.key = this.key;
    }

    return object;
  };

  _createClass(Text, [{
    key: "text",

    /**
     * 获取对应的文本string
     */
    get: function get() {
      if (process.env.NODE_ENV !== 'test' && TEXTS.has(this)) {
        return TEXTS.get(this);
      }

      var t = this.leaves.map(function (_ref2) {
        var text = _ref2.text;
        return text;
      }).join('');
      TEXTS.set(this, t);
      return t;
    }
    /**
     * 获取所有的marks
     */

  }, {
    key: "marks",
    get: function get() {
      return this.getMarks();
    }
  }]);

  return Text;
}(Node$1);

var Path = /*#__PURE__*/function (_Array) {
  _inheritsLoose(Path, _Array);

  function Path() {
    return _Array.apply(this, arguments) || this;
  }

  /**
   * Compare priority between `path` and `target`:
   *
   * - if `path` is before `target`, return -1
   * - if `path` is after `target`, return 1
   * - if `path` is equal to `target`, return 0
   * - else if something went wrong, return null
   *
   * @param path - path
   * @param target - target path
   *
   * # Example
   *
   * ```ts
   * Path.compare([1,0], [1,0])     // 0
   * Path.compare([1,1,1], [1,0])   // 1
   * Path.compare([1,0,0,1], [1,1]) // -1
   * ```
   */
  Path.compare = function compare(path, target) {
    var m = Math.min(path.length, target.length);

    for (var i = 0; i < m; i += 1) {
      var pv = path[i];
      var tv = target[i]; // If the path's value is ever less than the target's, it's before.

      if (pv < tv) {
        return -1;
      } // If the target's value is ever less than the path's, it's after.


      if (pv > tv) {
        return 1;
      }
    } // Paths should now be equal, otherwise something is wrong


    return path.length === target.length ? 0 : null;
  }
  /**
   * Crop `a` and `b` into the same size.
   *
   * @param a
   * @param b
   * @param size - crop size, default is the shortest between a and b
   *
   * # Example
   *
   * ```ts
   * Path.crop([1,1,0], [1,1])    // [1,1]
   * Path.crop([1,1,0], [1,1], 1) // [1]
   * ```
   */
  ;

  Path.crop = function crop(a, b, size) {
    if (size === void 0) {
      size = Math.min(a.length, b.length);
    }

    var ca = a.slice(0, size);
    var cb = b.slice(0, size);
    return [ca, cb];
  }
  /**
   * Decrement a `path` by `n` at `index`.
   *
   * @param path
   * @param n - default is 1
   * @param index - default is the last index
   *
   * # Example
   *
   * ```ts
   * Path.decrement([1,1,1])       // [1,1,0]
   * Path.decrement([1,1,3], 2)    // [1,1,1]
   * Path.decrement([1,1,3], 1, 1) // [1,0,3]
   * ```
   */
  ;

  Path.decrement = function decrement(path, n, index) {
    if (n === void 0) {
      n = 1;
    }

    if (index === void 0) {
      index = path.length - 1;
    }

    return Path.increment(path, 0 - n, index);
  }
  /**
   * Increment a `path` by `n` at `index`.
   *
   * @param path
   * @param n - default is 1
   * @param index - default is the last index
   *
   * # Example
   *
   * ```ts
   * Path.increment([1,1,1])       // [1,1,2]
   * Path.increment([1,1,1], 2)    // [1,1,3]
   * Path.increment([1,1,1], 2, 1) // [1,3,1]
   * ```
   */
  ;

  Path.increment = function increment(path, n, index) {
    if (n === void 0) {
      n = 1;
    }

    if (index === void 0) {
      index = path.length - 1;
    }

    var newPath = [].concat(path);
    newPath[index] += n;
    return newPath;
  }
  /**
   * Link the `subPath` to the `ancestor`.
   *
   * @param ancestor
   * @param subPath
   *
   * # Example
   *
   * ```ts
   * Path.link([1,0], [1]) // [1,0,1]
   * ```
   */
  ;

  Path.link = function link(ancestor, subPath) {
    return ancestor.concat(subPath);
  }
  /**
   * If the `path` is the ancestor of the `target`.
   *
   * @param path
   * @param target
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *         []
   *        /  \
   *     [0]   [1]
   *    /  \
   * [0,0]  [0,1]
   * ```
   *
   * ```ts
   * Path.isAncestor([], [0,0])  // true
   * Path.isAncestor([0], [0,0]) // true
   * ```
   */
  ;

  Path.isAncestor = function isAncestor(path, target) {
    var _Path$crop = Path.crop(path, target),
        p = _Path$crop[0],
        t = _Path$crop[1];

    return path.length < target.length && Path.isEqual(p, t);
  }
  /**
   * If the `path` is descendant of the `target`.
   *
   * @param path
   * @param target
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *         []
   *        /  \
   *      [0]   [1]
   *         __/ | \__
   *    [1,0]  [1,1]  [1,2]
   *      /
   *   [1,0,0]
   * ```
   *
   * ```ts
   * Path.isDescendant([1,0], [1]) // true
   * Path.isDescendant([1], [])   // true
   * ```
   */
  ;

  Path.isDescendant = function isDescendant(path, target) {
    return path.length > target.length && Path.isEqual(path.slice(0, target.length), target);
  }
  /**
   * If the `path` is before the `target`.
   *
   * @param path
   * @param target
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *         []
   *        / \
   *      [0] [1]
   *         /  \
   *    [1,0]   [1,1]
   * ```
   *
   * ```ts
   * Path.isBefore([0], [1,1])   // true
   * Path.isBefore([1,0], [1,1]) // true
   * ```
   */
  ;

  Path.isBefore = function isBefore(path, target) {
    var _Path$crop2 = Path.crop(path, target),
        p = _Path$crop2[0],
        t = _Path$crop2[1];

    return Path.compare(p, t) === -1;
  }
  /**
   * If the `path` is after the `target`.
   *
   * @param path
   * @param target
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *         []
   *        /  \
   *     [0]   [1]
   *          /  \
   *     [1,0]   [1,1]
   * ```
   *
   * ```ts
   * Path.isAfter([1], [0])   // true
   * Path.isAfter([1,0], [0]) // true
   * ```
   */
  ;

  Path.isAfter = function isAfter(path, target) {
    var _Path$crop3 = Path.crop(path, target),
        p = _Path$crop3[0],
        t = _Path$crop3[1];

    return Path.compare(p, t) === 1;
  }
  /**
   * If the `path` is equal to `target`.
   *
   * @param path
   * @param target
   *
   * # Example
   *
   * ```ts
   * Path.isEqual([], [])       // true
   * Path.isEqual([1,0], [1,0]) // true
   * Path.isEqual([0], [1])     // false
   * ```
   */
  ;

  Path.isEqual = function isEqual(path, target) {
    return equal(path, target);
  }
  /**
   * If the `path` is the sibling of the `target`.
   *
   * @param path
   * @param target
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *         []
   *        /  \
   *      [0]   [1]
   *         __/ | \__
   *    [1,0]  [1,1]  [1,2]
   * ```
   *
   * ```ts
   * Path.isSibling([1,0], [1,1]) // true
   * Path.isSibling([1,2], [1,1]) // true
   * ```
   */
  ;

  Path.isSibling = function isSibling(path, target) {
    if (path.length !== target.length) {
      return false;
    }

    var p = Path.parent(path);
    var t = Path.parent(target);
    return Path.isEqual(p, t) && path[path.length - 1] !== target[path.length - 1];
  }
  /**
   * If the `path` is the previous sibling of the `target`.
   *
   * @param path
   * @param target
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *         []
   *        /  \
   *      [0]   [1]
   *         __/ | \__
   *    [1,0]  [1,1]  [1,2]
   * ```
   *
   * ```ts
   * Path.isPrevSibling([0], [1]) // true
   * Path.isPrevsSibling([1,1], [1,2]) // true
   * Path.isPrevsSibling([0], [1,2]) // false
   * ```
   */
  ;

  Path.isPrevSibling = function isPrevSibling(path, target) {
    return Path.isSibling(path, target) && Path.isBefore(path, target);
  }
  /**
   * If the `path` is younger than the `target`.It means at the level which `path` lives, the `path` is ends before `target`.
   *
   * @param path
   * @param target
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *         []
   *        / \
   *     [0]   [1]
   *        __/ | \__
   *   [1,0]  [1,1]  [1,2]
   *          /   \
   *   [1,1,0]   [1,1,1]
   * ```
   *
   * ```ts
   * Path.isYounger([1,1,0], [1,1,1]) // true
   * Path.isYounger([1,0], [1,1,1])   // true
   * Path.isYounger([0], [1,1,1])     // true
   * ```
   */
  ;

  Path.isYounger = function isYounger(path, target) {
    var index = path.length - 1;

    var _Path$crop4 = Path.crop(path, target, index),
        p = _Path$crop4[0],
        t = _Path$crop4[1];

    var pl = path[index];
    var tl = target[index];
    return Path.isEqual(p, t) && pl < tl;
  }
  /**
   * If the `path` is deeper than the `target`.
   *
   * @param path
   * @param target
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *         []
   *        /  \
   *      [0]  [1]
   *           /  \
   *      [1,0]   [1,1]
   * ```
   *
   * ```ts
   * Path.isDeeper([1,0], [1]) // true
   * Path.isDeeper([1,0], [])  // true
   * ```
   */
  ;

  Path.isDeeper = function isDeeper(path, target) {
    return path.length > target.length;
  }
  /**
   * If the `path` is parent of the `target`.
   *
   * @param path
   * @param target
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *        []
   *       / \
   *    [0]  [1]
   *         /  \
   *    [1,0]   [1,1]
   * ```
   *
   * ```ts
   * Path.isParent([1], [1,0]) // true
   * Path.isParent([], [1])    // true
   * ```
   */
  ;

  Path.isParent = function isParent(path, target) {
    return path.length + 1 === target.length && Path.isEqual(path, Path.parent(target));
  }
  /**
   * If the `path` is child of the `target`
   *
   *
   * @param path
   * @param target
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *         []
   *        /  \
   *      [0]  [1]
   *          /  \
   *     [1,0]   [1,1]
   * ```
   *
   * ```ts
   * Path.isChild([1,0], [1]) // true
   * ```
   */
  ;

  Path.isChild = function isChild(path, target) {
    return path.length === target.length + 1 && Path.isEqual(path.slice(0, -1), target);
  }
  /**
   * Get the next sibiling of the `path`.
   *
   * @param path
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *         []
   *        /  \
   *      [0]  [1]
   *          /  \
   *     [1,0]   [1,1]
   * ```
   *
   * ```ts
   * Path.next([1,0]) // [1,1]
   * Path.next([])    // null
   * ```
   */
  ;

  Path.next = function next(path) {
    if (path.length === 0) {
      return null;
    }

    var last = path[path.length - 1];
    return path.slice(0, -1).concat(last + 1);
  }
  /**
   * Get the previous sibiling of the `path`.
   *
   * @param path
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *         []
   *        /  \
   *      [0]  [1]
   *          /  \
   *     [1,0]   [1,1]
   * ```
   *
   * ```ts
   * Path.previous([1,1]) // [1,0]
   * Path.previous([])    // null
   * Path.previous([1,0]) // null
   * ```
   */
  ;

  Path.previous = function previous(path) {
    if (path.length === 0) {
      return null;
    }

    var last = path[path.length - 1];

    if (last <= 0) {
      return null;
    }

    return path.slice(0, -1).concat(last - 1);
  }
  /**
   * Get the parent path of the `path`,
   * Note: the parent of root is still root.
   *
   * @param path
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *         []
   *        /  \
   *      [0]  [1]
   *          /  \
   *     [1,0]   [1,1]
   * ```
   *
   * ```ts
   * Path.parent([1,0]) // [1]
   * Path.parent([0])   // []
   * Path.parent([])    // []
   * ```
   */
  ;

  Path.parent = function parent(path) {
    return path.slice(0, -1);
  }
  /**
   * Get all ancestors of the `path`.
   *
   * @param path
   *
   * # Example
   *
   * Given the document tree:
   *
   *```txt
   *        []
   *       /  \
   *    [0]   [1]
   *       __/ | \__
   *  [1,0]  [1,1]  [1,2]
   *          /
   *      [1,1,0]
   * ```
   *
   * ```ts
   * Path.ancestors([1,1,0]) // [[], [1], [1,1]]
   * ```
   */
  ;

  Path.ancestors = function ancestors(path) {
    var ancestors = [];

    for (var i = 0; i < path.length; i += 1) {
      ancestors.push(path.slice(0, i));
    }

    return ancestors;
  }
  /**
   * Get the common ancestor between `a` and `b`.
   *
   * @param a
   * @param b
   *
   * # Example
   *
   * Given the document tree:
   *
   *```txt
   *        []
   *       /  \
   *    [0]   [1]
   *       __/ | \__
   *  [1,0]  [1,1]  [1,2]
   *          /       /
   *      [1,1,0]  [1,2,0]
   * ```
   *
   * ```ts
   * Path.common([1,1,0], [1,2,0]) // [1]
   * ```
   */
  ;

  Path.common = function common(a, b) {
    var path = []; // eslint-disable-next-line no-plusplus

    for (var i = 0; i < a.length && i < b.length; i++) {
      var av = a[i];
      var bv = b[i];
      if (av !== bv) break;
      path.push(av);
    }

    return path;
  }
  /**
   * Get the path of `path` relative to `ancestor`.
   *
   * @param a
   * @param b
   *
   * # Example
   *
   * Given the document tree:
   *
   *```txt
   *        []
   *       /  \
   *    [0]   [1]
   *       __/ | \__
   *  [1,0]  [1,1]  [1,2]
   *          /       /
   *      [1,1,0]  [1,2,0]
   * ```
   *
   * ```ts
   * Path.relative([1,1,0], [1]) // [1,0]
   * Path.relative([1,0,0], [0]) // null
   * ```
   */
  ;

  Path.relative = function relative(path, ancestor) {
    if (!Path.isAncestor(ancestor, path) || Path.isEqual(path, ancestor)) {
      return null;
    }

    return path.slice(ancestor.length);
  }
  /**
   * Transform the `path` based on `operation`.
   * @param path
   * @param operation
   */
  ;

  Path.transform = function transform(path, operation) {
    if (operation.type === 'set_selection') {
      return [path];
    }

    var type = operation.type,
        p = operation.path;

    if (type === 'add_mark' || type === 'insert_text' || type === 'remove_mark' || type === 'remove_text' || type === 'set_mark' || type === 'set_node' || path.length === 0) {
      return [path];
    }

    var pIndex = p.length - 1;
    var pEqual = Path.isEqual(p, path);
    var pYounger = Path.isYounger(p, path);
    var pAbove = Path.isAncestor(p, path);

    if (type === 'insert_node') {
      if (pEqual || pYounger || pAbove) {
        /**
         * ## Insert at the path
         *
         * ```js
         * path    = [1,0]
         * op.path = [1,0]
         * ```
         *
         * move path forward at op.path's level           [1,0] --> [1,1]
         *
         * ```txt
         *         []                                               []
         *      __/ \__                                          __/ \__
         *   [0]       [1]             --- transform -->      [0]       [1]
         *             /                                                / |
         *          *[1,0]*                                        [1,0]  *[1,1]*
         * ```
         *
         * ## Insert above the path
         *
         * ```js
         * path    = [1,0]
         * op.path = [1]
         * ```
         *
         * move path forward at op.path's level           [1,0] --> [2,0]
         *
         * ```txt
         *         []                                               [ ]
         *      __/ \__                                          __/ | \__
         *   [0]       [1]           --- transform -->        [0]   [1]   [2]
         *             /                                                  /
         *         *[1,0]*                                            *[2,0]*
         * ```
         *
         * ## Insert at younger
         *
         * ```js
         * path    = [1]
         * op.path = [0]
         * ```
         *
         * move path forward at op.path's level           [1] --> [2]
         *
         * ```txt
         *          [ ]                                             [ ]
         *         /  |                                          __/ | \__
         *       [0] *[1]*           --- transform -->        [0]   [1]   *[2]*
         * ```
         */
        return [Path.increment(path, 1, pIndex)];
      }
    } else if (type === 'remove_node') {
      if (pYounger) {
        /**
         * ## Remove at younger
         *
         * ```js
         * path    = [1,0]
         * op.path = [0]
         * ```
         *
         * move path forward at op.path's level           [1,0] --> [0,0]
         *
         * ```txt
         *         []                                               [ ]
         *      __/ \__                                          __/ | \__
         *   [0]       [1]           --- transform -->        [0]   [1]   [2]
         *             /                                      /
         *         *[1,0]*                                 *[0,0]*
         * ```
         */
        return [Path.decrement(path, 1, pIndex)];
      }

      if (pEqual || pAbove) {
        /**
         * ## Remove at the path
         *
         * ```js
         * path    = [1,0]
         * op.path = [1,0]
         * ```
         *
         * path is removed           [1,0] --> removed
         *
         * ```txt
         *         []                                               []
         *      __/ \__                                          __/ \__
         *   [0]       [1]             --- transform -->      [0]       [1]
         *             /
         *          *[1,0]*
         * ```
         *
         * ## Remove above the path
         *
         * ```js
         * path    = [1,0]
         * op.path = [1]
         * ```
         *
         * path is removed           [1,0] --> removed
         *
         * ```txt
         *         []                                               [ ]
         *      __/ \__                                          __/  \__
         *   [0]       [1]           --- transform -->        [0]        [1]
         *             /
         *         *[1,0]*
         * ```
         *
         */
        return [];
      }
    } else if (type === 'merge_node') {
      if (!Path.previous(p)) {
        return [path];
      }

      if (pEqual || pYounger) {
        /**
         * ## Merge at the path
         *
         * ```js
         * path         = [1]
         * op.path      = [1]
         * op.position  = 2
         * ```
         *
         * move path forward at op.path's level                 [0,1] -> [0]
         *
         * ```txt
         *            []                                                []
         *         __/ \__                                           __/ \__
         *      [0]      *[1]*                                    *[0]*
         *     /  \       /             ---- transform -->      __/  |  \__
         * [0,0] [0,1]  [1,0]                              [0,0]   [0,1]  [0,2]
         * ```
         *
         * ## Merge at younger
         *
         * ```js
         * path         = [1,0,2,0]
         * op.path      = [1,0,1]
         * op.position  = 1
         * ```
         *
         * move path forward at op.path's level         [1,0,2,0] -> [1,0,1,0]
         *
         *```txt
         *            []                                                []
         *         __/ \__                                           __/ \__
         *      [0]       [1]                                     [0]       [1]
         *     /  \       /             ---- transform -->        / \        /
         * [0,0] [0,1]  [1,0]                                 [0,0] [0,1]  [1,0]
         *          ___/  |  \___                                          /  \
         * [1,0,0] <-- [1,0,1]   [1,0,2]                            [1,0,0]   [1,0,1]
         *                         /                                             /
         *                   *[1,0,2,0]*                                    *[1,0,1,0]*
         *```
         */
        return [Path.decrement(path, 1, pIndex)];
      }

      if (pAbove) {
        /**
         *
         * ## Merge above the path
         *
         * ```js
         * path        = [1,0]
         * op.path     = [1]
         * op.position = 2
         * ```
         *
         * 1. move path forward at op.path's level    [1,0] -> [0,0]
         * 2. move sub path to the position               [0,0] -> [0,2]
         *
         * ```
         *            []                                                []
         *         __/ \__                                           __/
         *      [0]  <-- [1]                                      [0]
         *     /  \       /             ---- transform -->     __/ | \__
         * [0,0] [0,1] *[1,0]*                            [0,0] [0, 1]  *[0,2]*
         *          ___/  |  \___                                    ___/  |  \___
         *   [1,0,0]   [1,0,1]   [1,0,2]                      [0,2,0]   [0,2,1]   [0,2,2]
         * ```
         */
        var _ref = operation,
            position = _ref.position;
        return [Path.increment(Path.decrement(path, 1, pIndex), position, pIndex + 1)];
      }
    } else if (type === 'split_node') {
      if (pEqual) {
        /**
         * ## Split at the path
         *
         * ```js
         * path        = [1]
         * op.path     = [1]
         * op.position = 1
         * ```
         *
         * split path into 2 paths:  [1] -> [1], [2]
         *
         * ```
         *         []                                          [ ]
         *      __/ \__                                     __/ | \__
         *   [0]      *[1]*      --- transform -->       [0]  *[1]*  *[2]*
         *            /  \                                     /      /
         *       [1,0] s [1,1]                              [1,0]   [2,0]
         * ```
         */
        return [path, Path.increment(path)];
      }

      if (pYounger) {
        /**
         * ## Split at younger
         *
         * ```js
         * path        = [1,0,0]
         * op.path     = [0]
         * op.position = 1
         * ```
         *
         * move path foward at op.path's level: [1,0,0] -> [2,0,0]
         *
         * ```txt
         *              []                                          [ ]
         *           __/ \__                                     __/ | \__
         *        [0]       [1]      --- transform -->       [0]   [1]    [2]
         *       /  \       /                                /      /     /
         *  [0,0] s [0,1] [1,0]                           [0,0]  [1,0] [2,0]
         *                 /                                            /
         *             *[1,0,0]*                                   *[2,0,0]*
         * ```
         */
        return [Path.increment(path, 1, pIndex)];
      }

      if (pAbove) {
        /*
         * ## Split above
         *
         * If split happened before the path at op.path's level
         *
         * ```js
         * path        = [1,0,2]
         * op.path     = [1,0]
         * op.position = 1
         * ```
         *
         * 1. move path foward at op.path's level: [1,0,2] -> [1,1,2]
         * 2. move path backward to the split position:    [1,1,2] -> [1,1,1]
         *
         * ```txt
         *              []                                          []
         *           __/ \__                                     __/  \__
         *        [0]       [1]      --- transform -->        [0]        [1]
         *                   /                                        __/   \__
         *                [1,0]                                  [1,0]         [1,1]
         *            ____/ | \____                                /           /   \
         *     [1,0,0] s [1,0,1]   *[1,0,2]*                  [1,0,0]   [1,1,0]    *[1,1,1]*
         * ```
         */
        var _ref2 = operation,
            _position = _ref2.position;

        if (path[pIndex + 1] >= _position) {
          return [Path.decrement(Path.increment(path, 1, pIndex), _position, pIndex + 1)];
        }
      }
    }

    if (type === 'move_node') {
      var _ref3 = operation,
          np = _ref3.newPath;
      var npIndex = np.length - 1;
      var npEqual = Path.isEqual(np, path); // Stay

      if (Path.isEqual(p, np)) {
        return [path];
      }

      var npYounger = Path.isYounger(np, path);
      var npAbove = Path.isAncestor(np, path);

      if (pAbove) {
        /*
         * ## Move above the path
         *
         * If move node forward to the deeper
         *
         * ```js
         * path       = [1,0]
         * op.path    = [1]
         * op.newPath = [2,0]
         * ```
         *
         * 1. move new path to the left at op.path's level:    [2,0] -> [1,0]
         * 2. link sub path to the path:                       [1,0] + [0] -> [1,0,0]
         *
         * ```txt
         *         [  ]                                     [ ]
         *      __/ | \__                                __/  |__
         *   [0]   [1]  [2]    --- transform -->      [0]        [1]
         *         /     /                                       / \
         *    *[1,0]*  [2,0]                                [1,0]  [1,1]
         *              /                                    /      /
         *           [2,0,0]                          *[1,0,0]*   [1,1,0]
         * ```
         *
         * Else
         *
         * ```js
         * path       = [1,0]
         * op.path    = [1]
         * op.newPath = [0]
         * ```
         *
         * link sub path to new path:                                [0] + [0] -> [0,0]
         *
         * ```
         *         []                                         []
         *      __/ \__                                    __/ |__
         *   [0]       [1]       --- transform -->      [0]       [1]
         *              /                                /
         *          *[1,0]*                           *[0,0]*
         * ```
         */
        var subPath = Path.relative(path, p);

        if (Path.isAfter(np, p) && Path.isDeeper(np, p)) {
          return [Path.link(Path.decrement(np, 1, p.length - 1), subPath)];
        }

        return [Path.link(np, subPath)];
      } else if (pEqual) {
        /*
         * ## Move at the path
         *
         * If move forward to the deeper
         *
         * ```js
         * path       = [1]
         * op.path    = [1]
         * op.newPath = [2,0]
         * ```
         *
         * 1. move new path backward at op.path's level:      [2,0] -> [1,0]
         * 2. move path to the new path:                         [1]   -> [1,0]
         *
         * ```txt
         *         [  ]                                         []
         *      __/ | \__                                      / \
         *   [0]  *[1]*  [2]    --- transform -->           [0]  [1]
         *               /                                       /  \
         *            [2,0]                                 *[1,0]*  [1,1]
         * ```
         *
         * Else
         *
         * ```js
         * path       = [1,0]
         * op.path    = [1,0]
         * op.newPath = [2,0]
         * ```
         *
         * move path to new path:                               [1,0] -> [2,0]
         *
         * ```txt
         *         [  ]                                         [ ]
         *      __/ | \__                                    __/ | \__
         *   [0]   [1]   [2]    --- transform -->         [0]   [1]   [2]
         *          /     /                                          /  \
         *      *[1,0]* [2,0]                                  *[2,0]* [2,1]
         * ```
         */
        if (Path.isYounger(p, np) && Path.isDeeper(np, p)) {
          return [Path.decrement(np, 1, p.length - 1)];
        }

        return [np];
      } else if (Path.isSibling(p, np) && (npAbove || npEqual)) {
        if (pYounger) {
          /*
           * ## Move younger to sibling, the sibling is the ancestor of the path.
           *
           * ```js
           * path       = [1,0]
           * op.path    = [0]
           * op.newPath = [1]
           * ```
           *
           * move path forward at op.path's level:        [1,0] -> [0,0]
           *
           * ```txt
           *         []                                       []
           *        / \                                      / \
           *     [0]  [1]       --- transform -->          [0] [1]
           *           /                                    /
           *        *[1,0]*                              *[0,0]*
           * ```
           *
           * ## Move younger to sibling, the sibling is the path.
           *
           * ```js
           * path       = [2]
           * op.path    = [0]
           * op.newPath = [2]
           * ```
           *
           * move path forward at op.path's level:        [2] -> [1]
           *
           * ```txt
           *         [ ]                                        [ ]
           *        / | \         --- transform -->          __/ | \__
           *    [0] [1] *[2]*                             [0]  *[1]*  [2]
           * ```
           */
          return [Path.decrement(path, 1, pIndex)];
        } else {
          /*
           * ## Move older to sibling, the sibling is ancestor of the path.
           *
           * ```js
           * path       = [1, 0]
           * op.path    = [2]
           * op.newPath = [0]
           * ```
           *
           * move path foward at op.path's level:        [1,0] -> [2,0]
           *
           * ```txt
           *         [ ]                                       [ ]
           *        / | \                                     / | \
           *     [0] [1] [2]      --- transform -->        [0] [1] [2]
           *          /                                            /
           *       *[1,0]*                                      *[2,0]*
           *
           * ```
           *
           * ## Move older to sibling, the sibling is the path.
           *
           * ```js
           * path       = [1]
           * op.path    = [2]
           * op.newPath = [1]
           * ```
           *
           * move path forward at op.path's level:        [1] -> [2]
           *
           * ```txt
           *         [ ]                                        [ ]
           *        / | \         --- transform -->          __/ | \__
           *    [0] *[1]* [2]                             [0]   [1]  *[2]*
           * ```
           */
          return [Path.increment(path, 1, pIndex)];
        }
      } else if (npEqual || npYounger || npAbove) {
        if (pYounger) {
          /*
           * ## Move younger to path.
           *
           * ```js
           * path       = [1,1]
           * op.path    = [0]
           * op.newPath = [1,0]
           * ```
           *
           * 1. move path backward at op.path's level:        [1,1] -> [0,1]
           * 2. move path forward at op.newPath's level:      [0,1] -> [0,2]
           *
           * ```txt
           *        [ ]                                    [ ]
           *     __/ | \__                              __/ | \__
           *  [0]   [1]  [2]   --- transform -->    [0]  [1]   [2]
           *        / \                          __/ | \__
           *   [1,0]  *[1,1]*               [0,0]  [0,1]  *[0,2]*
           * ```
           *
           * ## Move younger to path's younger.
           *
           * ```js
           * path       = [1,1]
           * op.path    = [0]
           * op.newPath = [1,0]
           * ```
           *
           * 1. move path backward at op.path's level:        [1,1] -> [0,1]
           * 2. move path forward at op.newPath's level:      [0,1] -> [0,2]
           *
           * ```txt
           *        [ ]                                  [ ]
           *     __/  \__                                /
           *  [0]      [1]    --- transform -->        [0]
           *           /  \                         __/ | \__
           *      [1,0]  *[1,1]*               [0,0]  [0,1]  *[0,2]*
           * ```
           *
           * ## Move younger to path's ancestor.
           *
           * ```js
           * path       = [1,0,0]
           * op.path    = [0]
           * op.newPath = [1,0]
           * ```
           *
           * 1. move path backward at op.path's level:        [1,0,0] -> [0,0,0]
           * 2. move path forward at op.newPath's level:      [0,0,0] -> [0,1,0]
           *
           * ```txt
           *        [ ]                                    [ ]
           *     __/  \__                                 /
           *  [0]        [1]    --- transform -->      [0]
           *             /                             / \
           *          [1,0]                       [0,0]  [0,1]
           *           /                                   /
           *       *[1,0,0]*                            *[0,1,0]*
           * ```
           *
           */
          return [Path.increment(Path.decrement(path, 1, pIndex), 1, npIndex)];
        }
        /*
         * ## Move to path.
         *
         * ```js
         * path       = [1]
         * op.path    = [2]
         * op.newPath = [1]
         * ```
         *
         * move path to the right at op.newPath's level:      [1] -> [2]
         *
         * ```txt
         *        [ ]                                    [ ]
         *     __/ | \__                              __/ | \__
         *  [0]  *[1]*  [2]   --- transform -->     [0]  [1]   *[2]*
         * ```
         *
         * ## Move to path's younger.
         *
         * ```js
         * path       = [1,0]
         * op.path    = [1,1]
         * op.newPath = [0]
         * ```
         *
         * move path to the right at op.newPath's level:      [1,0] -> [2,0]
         *
         * ```txt
         *        [ ]                                  [ ]
         *     __/  \__                             __/ | \__
         *  [0]      [1]    --- transform -->    [0]   [1]   [2]
         *           /  \                                     /
         *      *[1,0]* [1,1]                             *[2,0]*
         * ```
         *
         * ## Move to path's ancestor.
         *
         * ```js
         * path       = [1,0]
         * op.path    = [0,0]
         * op.newPath = [1]
         * ```
         *
         * move path to the right at op.newPath's level:      [1,0] -> [2,0]
         *
         * ```txt
         *        [ ]                                    [ ]
         *     __/  \__                               __/ | \__
         *  [0]        [1]    --- transform -->    [0]   [1]   [2]
         *   /          /                                       /
         * [0,0]    *[1,0]*                                 *[2,0]*
         * ```
         *
         */


        return [Path.increment(path, 1, npIndex)];
      } else if (pYounger) {
        /**
         * ## Move younger to the right of the path.
         *
         * ```js
         * path       = [1,0]
         * op.path    = [0]
         * op.newPath = [1,1]
         * ```
         *
         * move path backward at op.path's level:          [1,0] -> [0,0]
         *
         * ```txt
         *         []                                       []
         *        / \                                      /
         *     [0]  [1]       --- transform -->          [0]
         *         /   \                                 / \
         *    *[1,0]*  [1,1]                       *[0,0]* [0,1]
         * ```
         *
         * ```js
         * path       = [1]
         * op.path    = [0]
         * op.newPath = [2,0]
         * ```
         *
         * move path backward at op.path's level:          [1] -> [0]
         *
         * ```txt
         *         [ ]                                       []
         *      __/ | \__                                   / \
         *   [0]  *[1]*  [2]     --- transform -->      *[0]*  [1]
         *               /                                     / \
         *            [2,0]                                [1,0] [1,1]
         * ```
         *
         * ## Move younger below the path.
         *
         * ```js
         * path       = [1,0]
         * op.path    = [0]
         * op.newPath = [1,1]
         * ```
         *
         * move path backward at op.path's level:          [1,0] -> [0,0]
         *
         * ```txt
         *         []                                       []
         *        / \                                      /
         *     [0]  [1]       --- transform -->          [0]
         *         /   \                                 / \
         *    *[1,0]*  [1,1]                       *[0,0]* [0,1]
         * ```
         */
        return [Path.decrement(path, 1, pIndex)];
      }
    }

    return [path];
  }
  /**
  * If the `path` is root path
  *
  *
  * @param path
  * @param target
  *
  * # Example
  *
  *
  * ```ts
  * Path.isRoot([]) // true
  * ```
  */
  ;

  Path.isRoot = function isRoot(path) {
    return path.length === 0;
  };

  return Path;
}( /*#__PURE__*/_wrapNativeSuper(Array));

function whereToStr(where) {
  if (typeof where === 'string') {
    return "with key: " + where + ".";
  } else if (Array.isArray(where)) {
    return "with path: " + where + ".";
  }

  return "with unknown: " + typeof where + ", " + where + ".";
}

/** 节点不存在 Error */
var NodeNotFoundError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(NodeNotFoundError, _Error);

  NodeNotFoundError.createAssertNotFoundError = function createAssertNotFoundError(type, ofType) {
    return function assertNotFound(maybeNode, method, where) {
      if (!maybeNode || !ofType(maybeNode)) {
        throw new NodeNotFoundError(method, type, where);
      }

      return maybeNode;
    };
  };

  function NodeNotFoundError(method, type, where) {
    var _this;

    _this = _Error.call(this, "[" + method + "] could not find " + type + " " + whereToStr(where)) || this;
    Object.setPrototypeOf(_assertThisInitialized(_this), NodeNotFoundError.prototype);
    return _this;
  }

  return NodeNotFoundError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
/** 路径不存在的 Error */

var PathNotFoundError = /*#__PURE__*/function (_Error2) {
  _inheritsLoose(PathNotFoundError, _Error2);

  function PathNotFoundError(key) {
    var _this2;

    _this2 = _Error2.call(this, "`Element.assertPath` could not find path with key: " + key) || this;
    Object.setPrototypeOf(_assertThisInitialized(_this2), PathNotFoundError.prototype);
    return _this2;
  }

  return PathNotFoundError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var KEYS_TO_EDGES_TABLE_CACHE = new WeakMap();
function linkKeysToEdgesTable(src, target) {
  var table = KEYS_TO_EDGES_TABLE_CACHE.get(src);

  if (table) {
    KEYS_TO_EDGES_TABLE_CACHE.set(target, table);
  }
}

var _assertNode = NodeNotFoundError.createAssertNotFoundError('node', function (node) {
  return node instanceof Node$1;
});

var _assertElement = NodeNotFoundError.createAssertNotFoundError('element', function (node) {
  return node instanceof Element$1;
});

var _assertText = NodeNotFoundError.createAssertNotFoundError('text', function (node) {
  return node instanceof Text$1;
});

var assertBlock = NodeNotFoundError.createAssertNotFoundError('block', function (node) {
  return node instanceof Block;
});

var Element$1 = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Element, _Node);

  /**
   * 判断 `maybeElement` 是否为 Element
   * @param maybeElement
   * @returns
   *
   * @example
   * ```tsx
   * const block = (<block type="paragraph">Hello</block>);
   * const inline = (<inline type="link">www.dingtalk.com</inline>);
   * const text = (<text>Hello</text>);
   *
   * assertTrue(Element.isElement(block));
   * assertTrue(Element.isElement(inline));
   * assertFlase(Element.isElement(text));
   * ```
   */
  Element.isElement = function isElement(maybeElement) {
    return maybeElement instanceof Element;
  };

  function Element(props) {
    var _this;

    _this = _Node.call(this, props) || this;
    _this.data = void 0;
    _this.nodes = void 0;
    _this.type = void 0;
    var data = props.data,
        nodes = props.nodes;
    _this.data = _extends({}, data);
    _this.nodes = nodes;
    return _this;
  }

  var _proto = Element.prototype;

  /**
   * 判断节点是否是 Inline 类型
   *
   * @example
   * ```tsx
   * const document = (<document><block type="paragraph">Hello</block></document>);
   * const block = (<block type="paragraph">Hello</block>);
   * const inline = (<inline type="link">www.dingtalk.com</inline>);
   *
   * assertTrue(inline.isInline());
   * assertFalse(block.isInline());
   * assertFalse(document.isInline());
   * ```
   */
  _proto.isInline = function isInline() {
    return this instanceof Inline;
  }
  /**
   * 判断节点是否是 Block 类型
   *
   * @example
   * ```tsx
   * const document = (<document><block type="paragraph">Hello</block></document>);
   * const block = (<block type="paragraph">Hello</block>);
   * const inline = (<inline type="link">www.dingtalk.com</inline>);
   *
   * assertTrue(block.isBlock());
   * assertFalse(inline.isBlock());
   * assertFalse(document.isBlock());
   * ```
   */
  ;

  _proto.isBlock = function isBlock() {
    return this instanceof Block;
  }
  /**
   * 重新生成节点 key，避免出现 key 重复的节点
   * @example
   * ```tsx
   * const block = (<block type="paragraph">Hello</block>);
   *
   * const newBlock = block.regenerateKey();
   * assertFalse(block.key === newBlock.key);
   * ```
   * @returns
   */
  ;

  _proto.regenerateKey = function regenerateKey() {
    return this.set('key', keyUtils.create());
  }
  /**
   * 获取子节点
   * @param key
   * @throws NodeNotFoundError 无法找到节点时，抛出异常
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(element.assertNode('own'), <block key="own" />);
   * assertEqual(element.assertNode('hello'), <text key="hello" />);
   * assertEqual(element.assertNode('world-block'), <block type="paragraph" key="world-block"/>);
   * assert(() => element.assertNode('not-exists')).toThrow();
   * ```
   */
  ;

  _proto.assertNode = function assertNode(key) {
    var node = this.getNode(key);
    return _assertNode(node, 'Element.assertNode', this.assertPath(key));
  }
  /**
   * 获取子节点
   * @param path
   * @throws NodeNotFoundError 无法找到节点时，抛出异常
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(element.assertNodeByPath([]), <block key="own" />);
   * assertEqual(element.assertNodeByPath([0,0]), <text key="hello" />);
   * assertEqual(element.assertNodeByPath([1]), <block type="paragraph" key="world-block"/>);
   * assert(() => element.assertNodeByPath([2])).toThrow();
   * ```
   *
   *
   */
  ;

  _proto.assertNodeByPath = function assertNodeByPath(path) {
    var node = this.getNodeByPath(path);
    return _assertNode(node, 'Element.assertNodeByPath', path);
  }
  /**
   * 获取子 text 节点
   * @param key
   * @throws NodeNotFoundError 无法找到节点时，抛出异常
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.assertText('hello'),
   *   <text key="hello">Hello</text>
   * );
   * assert(() => element.assertText('hello-block')).toThrow();
   * assert(() => element.assertText('not-exists')).toThrow();
   * ```
   */
  ;

  _proto.assertText = function assertText(key) {
    var node = this.getNode(key);
    return _assertText(node, 'Element.assertText', this.assertPath(key));
  }
  /**
   * 获取子 text 节点
   * @param path
   * @throws NodeNotFoundError 无法找到节点时，抛出异常
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.assertTextByPath([0,0]),
   *   <text key="hello">Hello</text>
   * );
   * assert(() => element.assertTextByPath([0])).toThrow();
   * assert(() => element.assertTextByPath([0,1])).toThrow();
   * ```
   */
  ;

  _proto.assertTextByPath = function assertTextByPath(path) {
    var node = this.getNodeByPath(path);
    return _assertText(node, 'Element.assertTextByPath', path);
  }
  /**
   * 根据 `key`，获取子 element 节点
   * @param key
   * @throws NodeNotFoundError 无法找到节点时，抛出异常
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.assertElement('hello-block'),
   *   <block type="paragraph" key="hello-block" />
   * );
   * assert(() => element.assertElement('hello')).toThrow();
   * assert(() => element.assertElement('not-exists')).toThrow();
   * ```
   */
  ;

  _proto.assertElement = function assertElement(key) {
    var node = this.getNode(key);
    return _assertElement(node, 'Element.assertElement', this.assertPath(key));
  }
  /**
   * 获取子 element 节点
   * @param path
   * @throws NodeNotFoundError 无法找到节点时，抛出异常
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.assertElementByPath([0]),
   *   <block type="paragraph" key="hello-block" />
   * );
   * assert(() => element.assertElementByPath([0,0])).toThrow();
   * assert(() => element.assertElementByPath([2])).toThrow();
   * ```
   */
  ;

  _proto.assertElementByPath = function assertElementByPath(path) {
    var node = this.getNodeByPath(path);
    return _assertElement(node, 'Element.assertElementByPath', path);
  }
  /**
   * 获取节点 path
   * @param key
   * @throws NodeNotFoundError 无法找到节点时，抛出异常
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(element.assertPath('own'), []);
   * assertEqual(element.assertPath('hello-block'), [0]);
   * assertEqual(element.assertPath('hello'), [0, 0]);
   * assert(() => element.assertPath('not-exists')).toThrow();
   * ```
   */
  ;

  _proto.assertPath = function assertPath(key) {
    var path = this.getPath(key);

    if (path === null) {
      throw new PathNotFoundError(key);
    }

    return path;
  }
  /**
   * 判断节点是否存在于当前的节点子树中
   * @param key
   * @returns
   *
   * @example
   *
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *   </block>
   * );
   *
   * assertTrue(element.hasNode('hello'));
   * assertFalse(element.hasNode('own));
   * assertFalse(element.hasNode('not-exists'));
   * ```
   */
  ;

  _proto.hasNode = function hasNode(key) {
    return Boolean(this.getKeysToEdgesTable()[key]);
  }
  /**
   * 判断节点是否为空：仅含有一个空的 text 节点
   *
   * @example
   *
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <text />
   *   </block>
   * );
   *
   * assertTrue(element.isEmpty());
   * ```
   */
  ;

  _proto.isEmpty = function isEmpty() {
    var nodes = this.nodes;
    return nodes.length === 1 && Text$1.isText(nodes[0]) && !nodes[0].text;
  }
  /**
   * 获取子节点
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(element.getNode('own'), <block key="own" />);
   * assertEqual(element.getNode('hello'), <text key="hello" />);
   * assertEqual(element.getNode('world-block'), <block type="paragraph" key="world-block"/>);
   * assertEqual(element.getNode(), null);
   * ```
   */
  ;

  _proto.getNode = function getNode(key) {
    var path = this.getPath(key);
    return this.getNodeByPath(path);
  }
  /**
   * 获取子节点，如果没有找到，将返回 null
   * @param path
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(element.getNodeByPath([]), <block key="own" />);
   * assertEqual(element.getNodeByPath([0,0]), <text key="hello" />);
   * assertEqual(element.getNodeByPath([1]), <block type="paragraph" key="world-block"/>);
   * assertEqual(element.getNodeByPath([2]), null);
   * ```
   */
  ;

  _proto.getNodeByPath = function getNodeByPath(path) {
    if (!path) {
      return null;
    }

    return path.reduce(function (n, index, idx) {
      if (!n) {
        return null;
      }

      var node = n.toSubType();

      if (node.isText()) {
        return idx === path.length - 1 ? node : null;
      }

      return node.nodes[index] || null;
    }, this);
  }
  /**
   * 获取相对于当前节点的 path，如果没有找到，就返回 `null`
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(element.getPath('own'), []);
   * assertEqual(element.getPath('hello'), [0,0]);
   * assertEqual(element.getPath('world-block'), [1]);
   * assertEqual(element.getPath('not-exists'), null);
   * ```
   */
  ;

  _proto.getPath = function getPath(key) {
    if (key === this.key) {
      return [];
    }

    var keysToEdgesTable = this.getKeysToEdgesTable();

    if (!keysToEdgesTable[key]) {
      return null;
    }

    var path = [];
    var k = key;

    while (keysToEdgesTable[k]) {
      var _keysToEdgesTable$k = keysToEdgesTable[k],
          parentKey = _keysToEdgesTable$k[0],
          _index = _keysToEdgesTable$k[1];
      path.push(_index);
      k = parentKey;
    }

    path.reverse();
    return path;
  }
  /**
   * 获取上一个兄弟节点，若不存在，将返回 null
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">Hello</block>
   *     <block type="paragraph" key="world-block">World</block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getPreviousSibling('world-block'),
   *   <block type="paragraph" key="hello-block">Hello</block>
   * );
   * assertEqual(
   *   element.getPreviousSibling('hello-block'),
   *   null
   * );
   * ```
   */
  ;

  _proto.getPreviousSibling = function getPreviousSibling(key) {
    var path = this.getPath(key);

    if (!path || path.length === 0) {
      return null;
    }

    return this.getPreviousSiblingByPath(path);
  }
  /**
   * 获取上一个兄弟节点，若不存在，将返回 null
   * @param path
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">Hello</block>
   *     <block type="paragraph" key="world-block">World</block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getPreviousSiblingByPath([1]),
   *   <block type="paragraph" key="hello-block">Hello</block>
   * );
   * assertEqual(
   *   element.getPreviousSiblingByPath([0]),
   *   null
   * );
   * ```
   */
  ;

  _proto.getPreviousSiblingByPath = function getPreviousSiblingByPath(path) {
    var lastIndex = path[path.length - 1];

    if (lastIndex <= 0) {
      return null;
    }

    return this.getNodeByPath(Path.decrement(path));
  }
  /**
   * 获取下一个兄弟节点，若不存在，返回 null
   * @param key
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">Hello</block>
   *     <block type="paragraph" key="world-block">World</block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getNextSibling('hello-block'),
   *   <block type="paragraph" key="world-block">World</block>
   * );
   * assertEqual(
   *   element.getNextSibling('world-block'),
   *   null
   * );
   * ```
   */
  ;

  _proto.getNextSibling = function getNextSibling(key) {
    var path = this.getPath(key);

    if (!path || path.length === 0) {
      return null;
    }

    return this.getNextSiblingByPath(path);
  }
  /**
   * 获取下一个兄弟节点，若不存在，返回 null
   * @param path
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">Hello</block>
   *     <block type="paragraph" key="world-block">World</block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getNextSiblingByPath([0]),
   *   <block type="paragraph" key="world-block">World</block>
   * );
   * assertEqual(
   *   element.getNextSiblingByPath([1]),
   *   null
   * );
   * ```
   */
  ;

  _proto.getNextSiblingByPath = function getNextSiblingByPath(path) {
    return this.getNodeByPath(Path.increment(path));
  }
  /**
   * 获取上一个叶子节点，若不存在，将返回 null
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *       <block type="paragraph" key="world-block">World</block>
   *     </block>
   *     <block type="container">
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getPreviousNode('cangjie-block'),
   *   <text>World</text>
   * );
   * assertEqual(
   *   element.getPreviousNode('hello-block'),
   *   null
   * );
   * ```
   */
  ;

  _proto.getPreviousNode = function getPreviousNode(key) {
    var path = this.getPath(key);

    if (!path) {
      return null;
    }

    return this.getPreviousNodeByPath(path);
  }
  /**
   * 获取上一个叶子节点，若不存在，将返回 null
   * @param path
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *       <block type="paragraph" key="world-block">World</block>
   *     </block>
   *     <block type="container">
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getPreviousNodeByPath([1,0]),
   *   <text>World</text>
   * );
   * assertEqual(
   *   element.getPreviousNodeByPath([0,0]),
   *   null
   * );
   * ```
   */
  ;

  _proto.getPreviousNodeByPath = function getPreviousNodeByPath(path) {
    var previousNode = this.getPreviousSiblingByPath(path);
    var parentPath = Path.parent(path);

    while (!previousNode && parentPath.length) {
      var parentPrevSibling = this.getPreviousSiblingByPath(parentPath);
      previousNode = parentPrevSibling && parentPrevSibling.getLastNode();
      parentPath = Path.parent(parentPath);
    }

    return previousNode;
  }
  /**
   * 获取下一个叶子节点，若不存在，将返回 null
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *     </block>
   *     <block type="container">
   *       <block type="paragraph" key="world-block">World</block>
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getNextNode('hello-block'),
   *   <text>World</text>
   * );
   * assertEqual(
   *   element.getNextNode('cangjie-block'),
   *   null
   * );
   * ```
   */
  ;

  _proto.getNextNode = function getNextNode(key) {
    var path = this.getPath(key);

    if (!path) {
      return null;
    }

    return this.getNextNodeByPath(path);
  }
  /**
   * 获取下一个叶子节点，若不存在，将返回 null
   * @param path
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *     </block>
   *     <block type="container">
   *       <block type="paragraph" key="world-block">World</block>
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getNextNodeByPath([0, 0]),
   *   <text>World</text>
   * );
   * assertEqual(
   *   element.getNextNodeByPath([1,1]),
   *   null
   * );
   * ```
   */
  ;

  _proto.getNextNodeByPath = function getNextNodeByPath(path) {
    var nextNode = this.getNextSiblingByPath(path);
    var parentPath = Path.parent(path);

    while (!nextNode && parentPath.length) {
      var parentNextSibling = this.getNextSiblingByPath(parentPath);
      nextNode = parentNextSibling && parentNextSibling.getFirstNode();
      parentPath = Path.parent(parentPath);
    }

    return nextNode;
  }
  /**
   * 获取上一个文本节点
   * @param key
   * @throws NodeNotFoundError 若节点不存在，则抛错
   * @returns
   *
   * * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *       <block type="paragraph" key="world-block">World</block>
   *     </block>
   *     <block type="container">
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.assertPreviousText('cangjie-block'),
   *   <text>World</text>
   * );
   * assert(() => element.assertPreviousText('hello-block')).toThrow();
   * ```
   */
  ;

  _proto.assertPreviousText = function assertPreviousText(key) {
    var text = this.getPreviousText(key);
    return _assertText(text, 'assertPreviousText', key);
  }
  /**
   * 获取上一个文本节点，若不存在，将返回 null
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *       <block type="paragraph" key="world-block">World</block>
   *     </block>
   *     <block type="container">
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getPreviousText('cangjie-block'),
   *   <text>World</text>
   * );
   * assertEqual(
   *   element.getPreviousText('hello-block'),
   *   null
   * );
   * ```
   */
  ;

  _proto.getPreviousText = function getPreviousText(key) {
    var path = this.getPath(key);

    if (!path || !path.length) {
      return null;
    }

    return this.getPreviousTextByPath(path);
  }
  /**
   * 获取上一个文本节点，若不存在，将返回 null
   * @param path
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *       <block type="paragraph" key="world-block">World</block>
   *     </block>
   *     <block type="container">
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getPreviousTextByPath([1,0]),
   *   <text>World</text>
   * );
   * assertEqual(
   *   element.getPreviousTextByPath([0]),
   *   null
   * );
   * ```
   */
  ;

  _proto.getPreviousTextByPath = function getPreviousTextByPath(path) {
    var previous = this.getPreviousNodeByPath(path);

    while ((_previous = previous) != null && _previous.isElement() && !previous.nodes.length) {
      var _previous;

      var previousPath = this.getPath(previous.key);

      if (!previousPath) {
        return null;
      }

      previous = this.getPreviousNodeByPath(previousPath);
    }

    if (!previous) {
      return null;
    }

    return previous.getLastText();
  }
  /**
   * 获取下一个文本节点，若不存在，将返回 null
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *     </block>
   *     <block type="container">
   *       <block type="paragraph" key="world-block">World</block>
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getNextText('hello-block'),
   *   <text>World</text>
   * );
   * assertEqual(
   *   element.getNextText('cangjie-block'),
   *   null
   * );
   * ```
   */
  ;

  _proto.getNextText = function getNextText(key) {
    var path = this.getPath(key);

    if (!path || !path.length) {
      return null;
    }

    return this.getNextTextByPath(path);
  }
  /**
   * 获取下一个文本节点，若不存在，将返回 null
   * @param path
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *     </block>
   *     <block type="container">
   *       <block type="paragraph" key="world-block">World</block>
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getNextTextByPath([0,0]),
   *   <text>World</text>
   * );
   * assertEqual(
   *   element.getNextTextByPath([1,1]),
   *   null
   * );
   * ```
   */
  ;

  _proto.getNextTextByPath = function getNextTextByPath(path) {
    var next = this.getNextNodeByPath(path);

    while ((_next = next) != null && _next.isElement() && !next.nodes.length) {
      var _next;

      var nextPath = this.getPath(next.key);

      if (!nextPath) {
        return null;
      }

      next = this.getNextNodeByPath(nextPath);
    }

    if (!next) {
      return null;
    }

    return next.getFirstText();
  }
  /**
   * 获取上一个 block，若不存在，将返回 null
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *       <block type="paragraph" key="world-block">World</block>
   *     </block>
   *     <block type="container">
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getPreviousBlock('cangjie-block'),
   *   <block type="paragraph" key="world-block">World</block>
   * );
   * assertEqual(
   *   element.getPreviousBlock('hello-block'),
   *   null
   * );
   * ```
   */
  ;

  _proto.getPreviousBlock = function getPreviousBlock(key) {
    var child = this.getNode(key);

    if (!child) {
      return null;
    }

    var first;

    if (Block.isBlock(child)) {
      first = child.getFirstText();
    } else {
      var block = this.getClosestBlock(key);
      first = block.getFirstText();
    }

    var previous = first && this.getPreviousText(first.key);

    if (!previous) {
      return null;
    }

    return this.getClosestBlock(previous.key);
  }
  /**
   * 获取下一个 block，若不存在，将返回 null
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *     </block>
   *     <block type="container">
   *       <block type="paragraph" key="world-block">World</block>
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getNextBlock('hello-block'),
   *   <block type="paragraph" key="world-block">World</block>
   * );
   * assertEqual(
   *   element.getNextBlock('cangjie-block'),
   *   null
   * );
   * ```
   */
  ;

  _proto.getNextBlock = function getNextBlock(key) {
    var child = this.getNode(key);

    if (!child) {
      return null;
    }

    var last;

    if (Block.isBlock(child)) {
      last = child.getLastText();
    } else {
      var block = this.getClosestBlock(key);
      last = block.getLastText();
    }

    if (!last) return null;
    var next = this.getNextText(last.key);
    if (!next) return null;
    var closest = this.getClosestBlock(next.key);
    return closest;
  }
  /**
   * 获取节点 Key-to-Path 的映射表
   *
   * @example
   * ```ts
   * const element = (
   *   <block type="container" key="container">
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *   </block>
   * );
   *
   * const table = element.getKeysToEdgesTable();
   * assertEqual(
   *   table,
   *   {
   *     'world-block': ['container', 0],
   *     'world':       ['world-block', 0],
   *     'hello-block': ['container', 1],
   *     'hello':       ['hello-block', 0]
   *   }
   * );
   * ```
   */
  ;

  _proto.getKeysToEdgesTable = function getKeysToEdgesTable() {
    var _this2 = this;

    if (!KEYS_TO_EDGES_TABLE_CACHE.has(this)) {
      (function () {
        var key = _this2.key,
            nodes = _this2.nodes;
        var length = nodes.length;
        var table = Object.create(null);

        var _loop = function _loop(i) {
          var node = nodes[i];
          table[node.key] = [key, i];

          if (!Element.isElement(node)) {
            return "continue";
          }

          var nested = node.getKeysToEdgesTable(); // PERF

          node.forEachDescendant(function (n) {
            table[n.key] = nested[n.key];
          });
        };

        for (var i = 0; i < length; i += 1) {
          var _ret = _loop(i);

          if (_ret === "continue") continue;
        }

        KEYS_TO_EDGES_TABLE_CACHE.set(_this2, table);
      })();
    }

    return KEYS_TO_EDGES_TABLE_CACHE.get(this);
  }
  /**
   * 获取节点下的文本
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *     </block>
   *     <block type="container">
   *       <block type="paragraph" key="world-block">World</block>
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(element.text, 'HelloWorldCangjie');
   * ```
   */
  ;

  /**
   * 获得最远的满足 `predicate` 断言的祖先节点
   * @param key
   * @param predicate
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container" key="container-1">
   *       <block type="container" key="container-2">
   *         <block type="paragraph">
   *           <text key="hello">Hello</text>
   *         </block>
   *       </block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getFurthsest('hello', (node) => node.type === 'container'),
   *   <block type="container" key="container-1" />
   * );
   * ```
   */
  _proto.getFurthsest = function getFurthsest(key, predicate) {
    var path = this.getPath(key);

    if (!path) {
      return null;
    }

    return this.getFurthsestByPath(path, predicate);
  }
  /**
   * 获得最远的满足 `predicate` 断言的祖先节点
   *
   * @param path
   * @param predicate
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container" key="container-1">
   *       <block type="container" key="container-2">
   *         <block type="paragraph">
   *           <text key="hello">Hello</text>
   *         </block>
   *       </block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getFurthsestByPath([0,0,0,0], (node) => node.type === 'container'),
   *   <block type="container" key="container-1" />
   * );
   * ```
   */
  ;

  _proto.getFurthsestByPath = function getFurthsestByPath(path, predicate) {
    var _this3 = this;

    var ancestors = this.getAncestorsByPath(path);

    if (!ancestors || !ancestors.length) {
      return null;
    }

    var fursest = ancestors.find(function (node, index) {
      if (node === _this3) {
        return false;
      }

      return predicate(node, index);
    }, []);
    return fursest || null;
  }
  /**
   * 获得最远的 Inline 祖先
   * @param key
   * @param returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <inline type="inline-block">
   *       <inline type="link">
   *         <text key="hello">Hello</text>
   *       </inline>
   *     </inline>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getFurthsestInline('hello'),
   *   <inline type="inline-block" />
   * );
   * ```
   */
  ;

  _proto.getFurthsestInline = function getFurthsestInline(key) {
    var node = this.getFurthsest(key, function (n) {
      return Inline.isInline(n);
    });

    if (node != null && node.isElement() && node.isInline()) {
      return node;
    }

    return null;
  }
  /**
   * 获得最远的 Block 祖先
   * @param key
   * @param returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container" key="container-1">
   *       <block type="container" data={{highlight: true}} key="container-2">
   *         <block type="paragraph">
   *           <text key="hello">Hello</text>
   *         </block>
   *       </block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getFurthsestBlock('hello'),
   *   <block type="container" key="container-1" />
   * );
   * ```
   */
  ;

  _proto.getFurthsestBlock = function getFurthsestBlock(key) {
    var node = this.getFurthsest(key, function (n) {
      return Block.isBlock(n);
    });

    if (node != null && node.isElement() && node.isBlock()) {
      return node;
    }

    return null;
  }
  /**
   * 获得最远的、仅含有一个子孙的祖先
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container" key="multiple-child">
   *       <block type="container" key="only-child">
   *         <block type="paragraph">
   *           <text key="hello">Hello</text>
   *         </block>
   *       </block>
   *       <block type="paragraph">World</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getFurthestOnlyChildAncestor('hello'),
   *   <block type="container" key="only-child" />
   * );
   * ```
   */
  ;

  _proto.getFurthestOnlyChildAncestor = function getFurthestOnlyChildAncestor(key) {
    var path = this.getPath(key);

    if (!path) {
      return null;
    }

    return this.getFurthestOnlyChildAncestorByPath(path);
  }
  /**
   * 获得最远的、仅含有一个子孙的祖先
   * @param path
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container" key="multiple-child">
   *       <block type="container" key="only-child">
   *         <block type="paragraph">
   *           <text key="hello">Hello</text>
   *         </block>
   *       </block>
   *       <block type="paragraph">World</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getFurthestOnlyChildAncestorByPath([0,0,0,0]),
   *   (<block type="container" key="only-child" />)
   * );
   * ```
   */
  ;

  _proto.getFurthestOnlyChildAncestorByPath = function getFurthestOnlyChildAncestorByPath(path) {
    var ancestors = this.getAncestorsByPath(path);

    if (!ancestors) {
      return null;
    }

    var furthest = ancestors.slice(1) // ignore self
    .find(function (node) {
      return node instanceof Element && node.nodes.length === 1;
    });
    return furthest || null;
  }
  /**
   * 获得节点所有的祖先
   * @param key
   * @returns 祖先序列
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container">
   *     <block type="paragraph">
   *       <text key="hello">Hello</text>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getAncestors('hello'),
   *   [
   *     <block type="container" />,
   *     <block type="paragraph" />
   *   ]
   * )
   * ```
   */
  ;

  _proto.getAncestors = function getAncestors(key) {
    var path = this.getPath(key);
    return this.getAncestorsByPath(path);
  }
  /**
   * 获得节点所有的祖先
   * @param path
   * @returns 祖先序列
   *
   * @example
   *
   * ```tsx
   * const element = (
   *   <block type="container">
   *     <block type="paragraph">
   *       <text key="hello">Hello</text>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getAncestorsByPath([0,0]),
   *   [
   *     <block type="container" />,
   *     <block type="paragraph" />
   *   ]
   * )
   * ```
   */
  ;

  _proto.getAncestorsByPath = function getAncestorsByPath(path) {
    var _this4 = this;

    if (!path || !this.getNodeByPath(path)) {
      return [];
    }

    var ancestors = [];
    path.forEach(function (_, index) {
      var subPath = path.slice(0, index);

      var ancestor = _this4.getNodeByPath(subPath);

      if (ancestor != null && ancestor.isElement()) {
        ancestors.push(ancestor);
      }
    });
    return ancestors;
  }
  /**
   * 获得最近的满足 `predicate` 断言的祖先，祖先不包含当前节点
   * @param key
   * @param predicate
   * @returns
   *
   * @example
   *
   * ```tsx
   * const element = (
   *   <block type="container" key="container-1">
   *    <block type="container" key="container-2">
   *      <block type="paragraph">
   *        <text key="hello">Hello</text>
   *       </block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getClosest('hello', (node) => node.type === 'container'),
   *   <block type="container" key="container-2" />,
   * );
   *
   * assertEqual(
   *   element.getClosest('hello', (node) => node.key === 'container-1'),
   *   null,
   * );
   * ```
   */
  ;

  _proto.getClosest = function getClosest(key, predicate) {
    var path = this.getPath(key);
    return this.getClosestByPath(path, predicate);
  }
  /**
   * 获得最近的满足 `predicate` 断言的祖先，祖先不包含当前节点
   * @param key
   * @param predicate
   * @returns
   *
   * @example
   *
   * ```tsx
   * const element = (
   *   <block type="container" key="container-1">
   *    <block type="container" key="container-2">
   *      <block type="paragraph">
   *        <text key="hello">Hello</text>
   *       </block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getClosestByPath([0,0,0], (node) => node.type === 'container'),
   *   <block type="container" key="container-2" />,
   * );
   * assertEqual(
   *   element.getClosestByPath([0,0,0], (node) => node.key === 'container-1'),
   *   null,
   * );
   * ```
   */
  ;

  _proto.getClosestByPath = function getClosestByPath(path, predicate) {
    var _this5 = this;

    if (!path) {
      return null;
    }

    var ancestors = this.getAncestorsByPath(path);
    var closest = ancestors.reverse().find(function (node, index, self) {
      if (node === _this5) return false;
      return predicate(node, index, self);
    });
    return closest || null;
  }
  /**
   * 获得最近的 Inline
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container">
   *    <inline type="highlight">
   *      <inline type="link">
   *        <text key="hello">Hello</text>
   *       </inline>
   *    </inline>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getClosestInline('hello'),
   *   <inline type="link" />,
   * );
   * ```
   */
  ;

  _proto.getClosestInline = function getClosestInline(key) {
    var path = this.getPath(key);

    if (!path) {
      return null;
    }

    return this.getClosestInlineByPath(path);
  }
  /**
   * 获得最近的 Inline
   * @param path
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container">
   *    <inline type="highlight">
   *      <inline type="link">
   *        <text key="hello">Hello</text>
   *       </inline>
   *    </inline>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getClosestInlineByPath([0,0,0]),
   *   <inline type="link" />,
   * );
   * ```
   */
  ;

  _proto.getClosestInlineByPath = function getClosestInlineByPath(path) {
    var closest = this.getClosestByPath(path, function (n) {
      return Inline.isInline(n);
    });

    if (closest != null && closest.isElement() && closest.isInline()) {
      return closest;
    }

    return null;
  }
  /**
   * 获取最近的 block 祖先
   * @param key
   * @returns
   * @throws NodeNotFoundError 若节点不存在，抛错
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container-1">
   *    <block type="container" key="container-2">
   *      <block type="paragraph">
   *        <text key="hello">Hello</text>
   *       </block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.assertClosestBlock('hello'),
   *   <block type="paragraph" />
   * );
   * assert(() =>element.assertClosestBlock('hello')).toThrow();
   * ```
   */
  ;

  _proto.assertClosestBlock = function assertClosestBlock(key) {
    var block = this.getClosestBlock(key);
    return assertBlock(block, 'assertClosestBlock', key);
  }
  /**
   * 获取最近的 block 祖先
   * @param key
   * @param returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container-1">
   *    <block type="container" key="container-2">
   *      <block type="paragraph">
   *        <text key="hello">Hello</text>
   *       </block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getClosestBlock('hello'),
   *   <block type="paragraph" />
   * );
   * assertEqual(
   *   element.getClosestBlock('hello'),
   *   null
   * );
   * ```
   */
  ;

  _proto.getClosestBlock = function getClosestBlock(key) {
    var path = this.getPath(key);
    return path ? this.getClosestBlockByPath(path) : null;
  }
  /**
   * 获取最近的 block 祖先
   * @param path
   * @param returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container-1">
   *    <block type="container" key="container-2">
   *      <block type="paragraph">
   *        <text key="hello">Hello</text>
   *       </block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getClosestBlockByPath([0,0,0]),
   *   <block type="paragraph" />
   * );
   * assertEqual(
   *   element.getClosestBlockByPath([]),
   *   null
   * );
   * ```
   */
  ;

  _proto.getClosestBlockByPath = function getClosestBlockByPath(path) {
    var closest = this.getClosestByPath(path, function (n) {
      return Block.isBlock(n);
    });

    if (closest != null && closest.isElement() && closest.isBlock()) {
      return closest;
    }

    return null;
  }
  /**
   * 获取最近的 block 祖先，如果节点本身就是 block，则返回节点
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container-1">
   *    <block type="container" key="container-2">
   *      <block type="paragraph" key="hello-block">
   *        <text key="hello">Hello</text>
   *       </block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getClosestBlockFromPoint('hello-block'),
   *   <block type="paragraph" />
   * );
   * assertEqual(
   *   element.getClosestBlockFromPoint('hello'),
   *   <block type="paragraph" />
   * );
   * ```
   */
  ;

  _proto.getClosestBlockFromPoint = function getClosestBlockFromPoint(key) {
    var node = this.getNode(key);

    if (node && node.isElement() && node.isBlock()) {
      return node;
    }

    return this.getClosestBlock(key);
  }
  /**
   * 获得最远的祖先
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container-1">
   *    <block type="container" key="container-2">
   *      <block type="paragraph" key="paragraph">
   *        <text key="hello">Hello</text>
   *       </block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getFurthestAncestor('hello'),
   *   <block type="container" key="container-2" />
   * );
   * assertEqual(
   *   element.getFurthestAncestor('container-1'),
   *   null,
   * );
   * ```
   */
  ;

  _proto.getFurthestAncestor = function getFurthestAncestor(key) {
    var childPath = this.getPath(key);

    if (!childPath || !childPath.length) {
      return null;
    }

    var node = this.nodes[childPath[0]];
    return node;
  }
  /**
   * 获得最远的祖先
   * @param key
   * @throws NodeNotFoundError 节点不存在时，抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container-1">
   *    <block type="container" key="container-2">
   *      <block type="paragraph" key="paragraph">
   *        <text key="hello">Hello</text>
   *       </block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.assertFurthestAncestor('hello'),
   *   <block type="container" key="container-2" />
   * );
   * assert(
   *   () =>element.assertFurthestAncestor('container-1'),
   * ).toThrow();
   * ```
   */
  ;

  _proto.assertFurthestAncestor = function assertFurthestAncestor(key) {
    var node = this.getFurthestAncestor(key);
    return _assertNode(node, 'assertFurthestAncestor', key);
  }
  /**
   * 获得节点的偏移位置，以文本为单位测算
   * @param key
   * @returns
   * @throws NodeNotFoundError 节点不存在时，抛错
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container-1">
   *    <block type="paragraph" key="world-block">World</block>
   *    <block type="container" key="container-2">
   *      <block type="paragraph" key="hello-block">
   *        <text key="hello">Hello</text>
   *       </block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(element.getOffset('hello'), 5);
   * assertEqual(element.getOffset('hello-block'), 5);
   * assertEqual(element.getOffset('world-block'), 0);
   * ```
   */
  ;

  _proto.getOffset = function getOffset(key) {
    this.assertNode(key); // Calculate the offset of the nodes before the highest child.

    var child = this.getFurthestAncestor(key);

    if (!child) {
      return 0;
    }

    var childIndex = this.nodes.findIndex(function (n) {
      return n === child;
    });
    var offset = this.nodes.slice(0, childIndex).reduce(function (memo, n) {
      return memo + n.text.length;
    }, 0);
    return key === child.key ? offset : offset + (child.isElement() ? child.getOffset(key) : 0);
  }
  /**
   * 获取父节点
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container-1">
   *    <block type="container" key="container-2">
   *      <block type="paragraph" key="paragraph">
   *        <text key="hello">Hello</text>
   *       </block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getParent('hello'),
   *   <block type="paragraph" />
   * );
   *
   * assertEqual(
   *   element.getParent('container-1'),
   *   null,
   * );
   * ```
   */
  ;

  _proto.getParent = function getParent(key) {
    var path = this.getPath(key);
    return this.getParentByPath(path);
  }
  /**
   * 获取父节点
   * @param key
   * @returns
   * @throws NodeNotFoundError 节点不存在时，抛错
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container-1">
   *    <block type="container" key="container-2">
   *      <block type="paragraph" key="paragraph">
   *        <text key="hello">Hello</text>
   *       </block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.assertParent('hello'),
   *   <block type="paragraph" />
   * );
   * assert(() => element.assertParent('container-1')).toThrow();
   * ```
   */
  ;

  _proto.assertParent = function assertParent(key) {
    var element = this.getParent(key);
    return _assertElement(element, 'assertParent', key);
  }
  /**
   * 获取父节点
   * @param path
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container-1">
   *    <block type="container" key="container-2">
   *      <block type="paragraph" key="paragraph">
   *        <text key="hello">Hello</text>
   *       </block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getParentByPath([0,0,0]),
   *   <block type="paragraph" />
   * );
   *
   * assertEqual(
   *   element.getParentByPath([]),
   *   null,
   * );
   * ```
   */
  ;

  _proto.getParentByPath = function getParentByPath(path) {
    if (!path || !path.length || !this.getNodeByPath(path)) {
      return null;
    }

    var node = this.getNodeByPath(path.slice(0, -1));

    if (node != null && node.isElement()) {
      return node;
    }

    return null;
  }
  /**
   * 获取公共祖先
   * @param a
   * @param b
   * @throws NodeNotFoundError 节点不存在，抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container">
   *    <block type="paragraph" key="hello">Hello</block>
   *    <block type="container">
   *      <block type="paragraph" key="world">World</block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.assertCommonAncestor('hello', 'world'),
   *   <block type="container" key="container" />
   * );
   * assertEqual(
   *   element.assertCommonAncestor('container', 'world'),
   *   <block type="container" key="container" />
   * );
   * assertEqual(
   *   () => element.assertCommonAncestor('not-exists', 'hello'),
   * ).toThrow();
   * ```
   */
  ;

  _proto.assertCommonAncestor = function assertCommonAncestor(a, b) {
    var element = this.getCommonAncestor(a, b);
    return _assertElement(element, 'assertCommonAncestor', "[" + a + ", " + b + "]");
  }
  /**
   * 获取公共祖先
   * @param a
   * @param b
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container">
   *    <block type="paragraph" key="hello">Hello</block>
   *    <block type="container">
   *      <block type="paragraph" key="world">World</block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getCommonAncestor('hello', 'world'),
   *   <block type="container" key="container" />
   * );
   * assertEqual(
   *   element.getCommonAncestor('container', 'world'),
   *   <block type="container" key="container" />
   * );
   * assertEqual(
   *   element.getCommonAncestor('not-exists', 'hello'),
   *   null,
   * );
   * ```
   */
  ;

  _proto.getCommonAncestor = function getCommonAncestor(a, b) {
    var aPath = this.getPath(a);
    var bPath = this.getPath(b);

    if (!aPath || !bPath) {
      return null;
    }

    var node = this.getNodeByPath(Path.common(aPath, bPath));
    return node != null && node.isElement() ? node : null;
  }
  /**
   * 获取 [`startKey`, `endKey`] 之间的所有 text
   * @param startKey 起始 text key
   * @param endKey   结束 text key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container">
   *    <block type="paragraph">
   *      <text key="hello">Hello</text>
   *    </block>
   *    <block type="paragraph">
   *      <text key="world">World</text>
   *    </block>
   *    <block type="container">
   *      <block type="paragraph">
   *        <text key="cangjie">Cangjie</text>
   *      </block>
   *    </block>
   *    <block type="paragraph">
   *      <text key="footer">Footer</text>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getTextsBetweenPositions('hello', 'cangjie'),
   *   [
   *     <text key="hello">Hello</text>,
   *     <text key="world">World</text>,
   *     <text key="cangjie">Cangjie</text>,
   *   ]
   * );
   * ```
   */
  ;

  _proto.getTextsBetweenPositions = function getTextsBetweenPositions(startKey, endKey) {
    var startText = this.getNode(startKey);

    if (!(startText != null && startText.isText())) {
      return [];
    }

    if (startKey === endKey) return [startText];
    var endText = this.getNode(endKey);

    if (!(endText != null && endText.isText())) {
      return [];
    }

    var texts = this.getTexts();
    var start = texts.indexOf(startText);
    var end = texts.indexOf(endText, start);
    var result = texts.slice(start, end + 1);
    return result;
  }
  /**
   * 获取节点树下所有 text
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container">
   *    <block type="paragraph">
   *      <text key="hello">Hello</text>
   *    </block>
   *    <block type="paragraph">
   *      <text key="world">World</text>
   *    </block>
   *    <block type="container">
   *      <block type="paragraph">
   *        <text key="cangjie">Cangjie</text>
   *      </block>
   *    </block>
   *    <block type="paragraph">
   *      <text key="footer">Footer</text>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getTexts(),
   *   [
   *     <text key="hello">Hello</text>,
   *     <text key="world">World</text>,
   *     <text key="cangjie">Cangjie</text>,
   *     <text key="footer">Footer</text>
   *   ]
   * );
   * ```
   */
  ;

  _proto.getTexts = function getTexts() {
    var texts = [];
    this.forEachDescendant(function (node) {
      if (Text$1.isText(node)) {
        texts.push(node);
      }
    });
    return texts;
  }
  /**
   * 获取节点树下所有 inline
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container">
   *    <inline type="link">www.dingtalk.com</inline>
   *    <block type="paragraph">
   *      <inline type="link">www.dingding.com</inline>
   *    </block>
   *    <inline type="mention" data={{name: 'john'}}/>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getInlines(),
   *   [
   *     <inline type="link">www.dingtalk.com</inline>,
   *     <inline type="link">www.dingding.com</type="link">,
   *     <inline type="mention" data={{name: 'john'}}/>,
   *   ]
   * );
   * ```
   */
  ;

  _proto.getInlines = function getInlines() {
    var inlines = [];
    this.forEachDescendant(function (node) {
      if (Inline.isLeafInline(node)) {
        inlines.push(node);
      }
    });
    return inlines;
  }
  /**
   * 获得节点树下所有类型为 `type` 的 inline
   * @param type
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container">
   *    <inline type="link">www.dingtalk.com</inline>
   *    <block type="paragraph">
   *      <inline type="link">www.dingding.com</inline>
   *    </block>
   *    <inline type="mention" data={{name: 'john'}} />
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getInlinesByType('link'),
   *   [
   *     <inline type="link">www.dingtalk.com</inline>,
   *     <inline type="link">www.dingding.com</type="link">,
   *   ]
   * );
   * ```
   */
  ;

  _proto.getInlinesByType = function getInlinesByType(type) {
    var inlines = [];
    this.forEachDescendant(function (node) {
      if (Inline.isLeafInline(node) && node.type === type) {
        inlines.push(node);
      }
    });
    return inlines;
  }
  /**
   * Map 节点树的所有子孙
   * @param map 节点映射函数
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container">
   *     <block type="paragraph">Hello</block>
   *     <block type="code">const foo = 'bar';</block>
   *     <block type="paragraph">World</block>
   *   </block>
   * );
   *
   * const newElement = element.mapDescendants(node => {
   *   if (node.isElement() && node.type === "paragraph") {
   *     return node.set('data', { highlight: true });
   *   }
   *   return node;
   * })
   *
   * assertEqual(
   *   newElement,
   *   <block type="container">
   *     <block type="paragraph" data={{ highlight: true }}>Hello</block>
   *     <block type="code">const foo = 'bar';</block>
   *     <block type="paragraph" data={{ highlight: true }}>World</block>
   *   </block>
   * )
   * ```
   */
  ;

  _proto.mapDescendants = function mapDescendants(map) {
    var newNodes = this.nodes.map(function (node) {
      var ret = node;

      if (Element.isElement(ret)) {
        ret = ret.mapDescendants(map);
      }

      return map(ret);
    });
    return this.set('nodes', newNodes);
  }
  /**
   * 遍历自身树下所有子节点：遍历顺序为前序遍历
   * @param iterator 遍历函数；如果返回 `false`，则停止遍历当前节点的子孙，防止冗余遍历引起的性能开销
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container">
   *     <block type="paragraph">Hello</block>
   *     <block type="code">const foo = 'bar';</block>
   *     <block type="paragraph">World</block>
   *   </block>
   * );
   *
   * const paragraphs: Block[] = [];
   * element.forEachDescendant(node => {
   *   if (node.isElement()) {
   *     if (node.type === "paragraph") {
   *       paragraphs.push(node);
   *     } else if (node.type === "code"){
   *       // code 下不再有 paragraph，可以提前终止对 code 的遍历
   *       return false;
   *     }
   *   }
   * });
   *
   * assertEqual(
   *   paragraphs,
   *   <block type="paragraph">Hello</block>
   *   <block type="paragraph">World</block>
   * )
   * ```
   */
  ;

  _proto.forEachDescendant = function forEachDescendant(iterator) {
    var ret = null;
    this.nodes.forEach(function (child) {
      if (iterator(child) === false) {
        ret = false;
        return;
      }

      if (Element.isElement(child)) {
        ret = child.forEachDescendant(iterator);
      }
    });
    return ret;
  }
  /**
   * 判断子孙节点中，是否有符合条件的节点
   * @param predicate 遍历函数, 相比 forEachDescendant 会降低节点遍历开销
   * @returns {boolean}
   * @example
   * ```tsx
   * const element = (
   *   <block type="container">
   *     <block type="paragraph">Hello</block>
   *     <block type="code">const foo = 'bar';</block>
   *     <block type="paragraph">World</block>
   *   </block>
   * );
   *
   * const hasCode = element.someDescendants(node => {
   *   return node.isElement() && node.type === 'code';
   * });
   *
   * const hasCard = element.someDescendants(node => {
   *  return node.isElement() && node.type === 'card';
   * })
   *
   * assertEqual(hasCode, true);
   * assertEqual(hasCard, false);
   * );
   * ```
   */
  ;

  _proto.someDescendant = function someDescendant(predicate) {
    return this.nodes.some(function (child) {
      if (predicate(child)) {
        return true;
      }

      if (Element.isElement(child)) {
        return child.someDescendant(predicate);
      }

      return false;
    });
  }
  /**
   * 过滤子孙，仅保留符合 `predicate` 断言的节点
   * @param predicate
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container">
   *     <block type="paragraph">Hello</block>
   *     <block type="code">const foo = 'bar';</block>
   *     <block type="paragraph">World</block>
   *   </block>
   * );
   *
   * const filtered = element.filterDescendants(node => {
   *   return node.isElement() && node.type !== 'code';
   * });
   *
   * assertEqual(
   *   filtered,
   *   [
   *     <block type="paragraph">Hello</block>,
   *     <block type="paragraph">World</block>
   *   ]
   * );
   * ```
   */
  ;

  _proto.filterDescendants = function filterDescendants(predicate) {
    var descendants = [];
    this.nodes.forEach(function (node) {
      if (predicate(node)) {
        descendants.push(node);
      }

      if (node instanceof Element) {
        descendants.push.apply(descendants, node.filterDescendants(predicate));
      }
    });
    return descendants;
  }
  /**
   * 查找节点树满足 `predicate` 断言的子孙
   * @param predicate
   * @returns
    * @example
   * ```tsx
   * const element = (
   *   <block type="container">
   *     <block type="paragraph">Hello</block>
   *     <block type="code">const foo = 'bar';</block>
   *     <block type="paragraph">World</block>
   *   </block>
   * );
   *
   * const code = element.findDescendant(node => {
   *   return node.isElement() && node.type === 'code'
   * });
   *
   * assertEqual(
   *   code,
   *   <block type="code">const foo = 'bar';</block>
   * );
   * ```
   */
  ;

  _proto.findDescendant = function findDescendant(predicate) {
    var found = null;
    this.forEachDescendant(function (node) {
      // if the node has been found, then don't assign value to it.
      if (predicate(node) && !found) {
        found = node;
        return false;
      }

      return true;
    });
    return found;
  }
  /**
   * 是否 `node` 位于节点子孙中
   * @param node
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container">
   *     <block type="paragraph" key="hello">Hello</block>
   *   </block>
   * );
   *
   * const hello = element.assertNode('hello');
   * const root = element.assertNodeByPath([]);
   * const cangjie = <block type="paragraph">World</block>;
   *
   * assertTrue(element.contains(hello));
   * assertFalse(element.contains(root));
   * assertFlase(element.contains(cangjie));
   * ```
   */
  ;

  _proto.contains = function contains(node) {
    if (node) {
      var found = this.findDescendant(function (child) {
        return child === node;
      });

      if (found) {
        return true;
      }
    }

    return false;
  }
  /**
   * 替换节点子树中 `path` 位置的节点为 `node`
   * @param path
   * @param node
   * @param noSpacialEffect 是否操作将影响空间，若不影响空间，将不进行 Key-to-Path Table 的重构
   * @throws NodeNotFoundError 如果节点路径错误，将抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *   </block>
   * );
   *
   * const newElement = element.replaceNode(
   *   [1],
   *   <block type="paragraph" key="cangjie-block">Cangjie</block>
   * );
   *
   * assertEqual(newElement, (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="cangjie-block">Cangjie</block>
   *   </block>
   * ));
   * ```
   */
  ;

  _proto.replaceNode = function replaceNode(path, node, noSpacialEffect) {
    if (noSpacialEffect === void 0) {
      noSpacialEffect = false;
    }

    var p = path;
    var n = node;

    if (noSpacialEffect && Element.isElement(node)) {
      linkKeysToEdgesTable(this.getNodeByPath(path), node);
    }

    while (p.length) {
      var _index2 = p[p.length - 1];
      p = p.slice(0, -1);
      var maybeParent = this.getNodeByPath(p);

      var parent = _assertElement(maybeParent, 'Element.replaceNode', p);

      var nodes = [].concat(parent.nodes);
      nodes[_index2] = n;
      n = parent.set('nodes', nodes);

      if (noSpacialEffect) {
        linkKeysToEdgesTable(parent, n);
      }
    }

    return n;
  }
  /**
   * 在对应 `path` 的 text 节点的 `offset` 位置，为长度为 `length` 的区间添加 `mark`
   *
   * @param path
   * @param offset 偏移位置
   * @param length 文本区间长度
   * @param mark
   * @throws NodeNotFoundError 如果节点路径错误，将抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">HelloWorld</text>
   *     </block>
   *   </block>
   * );
   *
   * const newElement = element.addMark(
   *   [0, 0],
   *   5,
   *   5,
   *   Mark.craete('bold')
   * );
   *
   * assertEqual(newElement, (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello<m type="world">World</m></text>
   *     </block>
   *   </block>
   * ));
   * ```
   */
  ;

  _proto.addMark = function addMark(path, offset, length, mark) {
    var maybeNode = this.getNodeByPath(path);

    var node = _assertText(maybeNode, 'Element.addMark', path);

    return this.replaceNode(path, node.addMark(offset, length, mark), true);
  }
  /**
   * 在对应 `path` 的 text 节点的 `offset` 位置，为长度为 `length` 的区间删除 `mark`
   * @param path
   * @param offset
   * @param length
   * @param mark
   * @throws NodeNotFoundError 如果节点路径错误，将抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *        <text key="hello">Hello<m type="world">World</m></text>
   *     </block>
   *   </block>
   * );
   *
   * const newElement = element.removeMark(
   *   [0, 0],
   *   5,
   *   5,
   *   Mark.craete('bold')
   * );
   *
   * assertEqual(newElement, (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">HelloWorld</text>
   *     </block>
   *   </block>
   * ));
   * ```
   */
  ;

  _proto.removeMark = function removeMark(path, offset, length, mark) {
    var maybeTextNode = this.getNodeByPath(path);

    var textNode = _assertText(maybeTextNode, 'Element.addMark', path);

    return this.replaceNode(path, textNode.removeMark(offset, length, mark), true);
  }
  /**
   * 在对应 `path` 的 text 节点的 `offset` 位置，为长度为 `length` 的区间设置 mark data
   * @param path
   * @param offset
   * @param length
   * @param mark
   * @param properties
   * @throws NodeNotFoundError 如果节点路径错误，将抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *        <text key="hello">Hello
   *          <m type="world" data={{ weight: 500 }}>World</m>
   *        </text>
   *     </block>
   *   </block>
   * );
   *
   * const newElement = element.setMark(
   *   [0, 0],
   *   5,
   *   5,
   *   Mark.craete('bold'),
   *   { data: { weight: 700 } }
   * );
   *
   * assertEqual(newElement, (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *        <text key="hello">Hello
   *          <m type="world" data={{ weight: 700 }}>World</m>
   *        </text>
   *     </block>
   *   </block>
   * ));
   * ```
   */
  ;

  _proto.setMark = function setMark(path, offset, length, mark, properties) {
    var maybeText = this.getNodeByPath(path);

    var text = _assertText(maybeText, 'Element.setMark', path);

    return this.replaceNode(path, text.setMark(offset, length, mark, properties), true);
  }
  /**
   * 在对应 `path` 的 text 节点的 `offset` 位置，插入文本 `text`，并指定这段文本的 `marks`
   * @param path
   * @param offset
   * @param text
   * @param marks
   * @throws NodeNotFoundError 如果节点路径错误，将抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">Hello</block>
   *   </block>
   * );
   *
   * const newElement = element.insertText(
   *   [0, 0],
   *   5,
   *   'World',
   *   [Mark.craete('bold'), Mark.create('italic)],
   * );
   *
   * assertEqual(newElement, (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       Hello
   *       <m type="bold"><m type="italic">World</m></m>
   *     </block>
   *   </block>
   * ));
   * ```
   */
  ;

  _proto.insertText = function insertText(path, offset, text, marks) {
    var maybeNode = this.getNodeByPath(path);

    var node = _assertText(maybeNode, 'Element.insertText', path);

    return this.replaceNode(path, node.insertText(offset, text, marks), true);
  }
  /**
   * 在对应 `path` 的 text 节点的 `offset` 位置，删除指定的文本 `text`
   * @param path
   * @param offset
   * @param text
   * @throws NodeNotFoundError 如果节点路径错误，将抛错
   * @returns
   *
   * @exmple
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">HelloWorld</block>
   *   </block>
   * );
   *
   * const newElement = element.removeText(
   *   [0, 0],
   *   5,
   *   'World'
   * );
   *
   * assertEqual(newElement, (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">Hello</block>
   *   </block>
   * ));
   * ```
   */
  ;

  _proto.removeText = function removeText(path, offset, text) {
    var maybeTextNode = this.getNodeByPath(path);

    var textNode = _assertText(maybeTextNode, 'Element.removeText', path);

    return this.replaceNode(path, textNode.removeText(offset, text), true);
  }
  /**
   * 在 `path` 位置插入节点 `node`
   * @param path
   * @param node
   * @throws NodeNotFoundError 如果节点路径错误，将抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *   </block>
   * );
   *
   * const newElement = element.insertNode(
   *   [1],
   *   <block type="paragraph" key="world">World</block>
   * );
   *
   * assertEqual(newElement, (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world">World</block>
   *   </block>
   * ));
   * ```
   */
  ;

  _proto.insertNode = function insertNode(path, node) {
    var index = path[path.length - 1];
    var parentPath = path.slice(0, -1);
    var maybeParent = this.getNodeByPath(parentPath);

    var parent = _assertElement(maybeParent, 'Element.insertNode', path);

    var nodes = [].concat(parent.nodes);
    nodes.splice(index, 0, node);
    return this.replaceNode(parentPath, parent.set('nodes', nodes));
  }
  /**
   * 删除节点子树中 `path` 位置的节点
   * @param path
   * @throws NodeNotFoundError 如果节点路径错误，将抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">Hello</block>
   *     <block type="container" key="container">
   *        <block type="paragraph" key="world-block">World</block>
   *        <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * const newElement = element.removeNode([1,0]);
   *
   * assertEqual(newElement, (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">Hello</block>
   *     <block type="container" key="container">
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * ));
   * ```
   */
  ;

  _proto.removeNode = function removeNode(path) {
    var node = this.getNodeByPath(path);

    _assertNode(node, 'Element.removeNode', path);

    var index = path[path.length - 1];
    var parentPath = path.slice(0, -1);
    var maybeParent = this.getNodeByPath(parentPath);

    var parent = _assertElement(maybeParent, 'Element.insertNode', path);

    var nodes = [].concat(parent.nodes);
    nodes.splice(index, 1);
    return this.replaceNode(parentPath, parent.set('nodes', nodes));
  }
  /**
   * 将 `path` 位置的节点，合并到其前一个兄弟节点
   * @param path
   * @throws NodeNotFoundError 如果节点路径错误，将抛错
   * @throws Error 如果节点与兄弟节点类型不一致，将抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">Hello</block>
   *     <block type="paragraph" key="world-block">World</block>
   *   </block>
   * );
   *
   * const newElement = element.mergeNode([1]);
   *
   * assertEqual(newElement, (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       HelloWorld
   *     </block>
   *   </block>
   * ));
   * ```
   */
  ;

  _proto.mergeNode = function mergeNode(path) {
    var maybeB = this.getNodeByPath(path);

    var b = _assertNode(maybeB, 'Element.mergeNode', path);

    var lastIndex = path[path.length - 1];

    if (lastIndex === 0) {
      throw new Error("Unable to merge node because it has no previous sibling: " + b);
    }

    var withPath = Path.decrement(path);
    var maybeA = this.getNodeByPath(withPath);

    var aNode = _assertNode(maybeA, 'Element.mergeNode', withPath);

    var a = aNode.toSubType();

    if (a.constructor !== b.constructor) {
      throw new Error("Unable to merge two different kinds of nodes: " + a + " and " + b);
    }

    var newNode = a.isText() ? a.mergeText(b) : a.set('nodes', [].concat(a.nodes, b.nodes));
    return this.removeNode(path).replaceNode(withPath, newNode);
  }
  /**
   * 对指定 `path` 位置的节点在 `position` 处进行拆分
   * @param path
   * @param position 拆分位置。如果是 text 节点，代表文字的偏移量；如果是 element 节点，代表子节点 index
   * @param properties 拆分 element 后，为拆分的节点设置 properties
   * @throws NodeNotFoundError 如果节点路径错误，将抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block>
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *       <block type="paragraph" key="world-block">World</block>
   *     </block>
   *   </block>
   * );
   *
   * // Split Element
   * const elementSplitted = element.splitNode([0], 1, { data: { highlight: true } });
   *
   * assertEqual(newElement, (
   *   <block>
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *     </block>
   *     <block type="container" data={{ highlight: true }}>
   *       <block type="paragraph" key="world-block">World</block>
   *     </block>
   *   </block>
   * ));
   *
   * // Split Text
   * const textSplitted = element.splitNode([0,0], 3);
   *
   * assertEqual(newElement, (
   *   <block>
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">
   *         <text>Hel</text><text>lo</text></block>
   *       </block>
   *     <block type="paragraph" key="world-block">World</block>
   *   </block>
   * ));
   * ```
   */
  ;

  _proto.splitNode = function splitNode(path, position, properties) {
    var maybeNode = this.getNodeByPath(path);

    var n = _assertNode(maybeNode, 'Element.splitNode', path);

    var node = n.toSubType();
    var a;
    var b;

    if (node.isText()) {
      var _node$splitText = node.splitText(position);

      a = _node$splitText[0];
      b = _node$splitText[1];
    } else {
      var element = node;
      var befores = element.nodes.slice(0, position);
      var afters = element.nodes.slice(position);
      a = element.set('nodes', befores);
      b = element.set('nodes', afters).regenerateKey();
    }

    if (properties && !Text$1.isText(node)) {
      b = b.merge(properties);
    }

    return this.removeNode(path).insertNode(path, b).insertNode(path, a);
  }
  /**
   * 将 `path` 位置的节点移动到新的位置 `newPath`
   * @param path
   * @param newPath
   * @throws NodeNotFoundError 如果节点路径错误，将抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">Hello</block>
   *     <block type="container" key="container">
   *        <block type="paragraph" key="world-block">World</block>
   *        <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * const newElement = element.moveNode([1,0], [1]);
   *
   * assertEqual(newElement, (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">Hello</block>
   *     <block type="paragraph" key="world-block">World</block>
   *     <block type="container" key="container">
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * ));
   * ```
   */
  ;

  _proto.moveNode = function moveNode(path, newPath) {
    var maybeNode = this.getNodeByPath(path);

    var node = _assertNode(maybeNode, 'Element.moveNode', path);

    var newParentPath = newPath.slice(0, -1);
    var newParent = this.getNodeByPath(newParentPath);

    _assertElement(newParent, 'Element.moveNode', path);

    var isYounger = Path.isYounger(path, newPath);
    var isSibling = Path.isSibling(path, newPath); // If the old path ends above and before a node in the new path, then
    // removing it will alter the target, so we need to adjust the new path.

    if (isYounger && !isSibling) {
      // eslint-disable-next-line no-param-reassign
      newPath = Path.decrement(newPath, 1, path.length - 1);
    }

    return this.removeNode(path).insertNode(newPath, node);
  }
  /**
   * 对指定 `path` 位置的节点设置属性
   * @param path
   * @param properties
   * @throws NodeNotFoundError 如果节点路径错误，将抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block" data={{ highlight: true }}>Hello</block>
   *     <block type="paragraph" key="world-block">World</block>
   *   </block>
   * );
   *
   * const newElement = element.setNode([0], { data: { highlight: false } });
   *
   * assertEqual(newElement, (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block" data={{ highlight: false }}>Hello</block>
   *     <block type="paragraph" key="world-block">World</block>
   *   </block>
   * ));
   * ```
   */
  ;

  _proto.setNode = function setNode(path, properties) {
    var maybeElement = this.getNodeByPath(path);

    var element = _assertElement(maybeElement, 'Element.setNode', path);

    element = element.merge(properties);
    return this.replaceNode(path, element, true);
  };

  _createClass(Element, [{
    key: "text",
    get: function get() {
      return this.getTexts().reduce(function (str, _ref) {
        var text = _ref.text;
        return "" + str + text;
      }, '');
    }
  }]);

  return Element;
}(Node$1);

function _createForOfIteratorHelperLoose$a(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$a(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray$a(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$a(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$a(o, minLen); }

function _arrayLikeToArray$a(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * @ignore
 */

var Inline = /*#__PURE__*/function (_Element) {
  _inheritsLoose(Inline, _Element);

  Inline.create = function create(properties) {
    if (Inline.isInline(properties)) {
      return properties;
    }

    var props = properties;

    if (typeof props === 'string') {
      props = {
        type: props
      };
    }

    if (isPlainObject(props)) {
      var _props = props,
          type = _props.type,
          _props$key = _props.key,
          key = _props$key === void 0 ? keyUtils.create() : _props$key,
          _props$data = _props.data,
          data = _props$data === void 0 ? {} : _props$data,
          _props$nodes = _props.nodes,
          nodes = _props$nodes === void 0 ? [Text$1.create()] : _props$nodes;

      if (typeof type !== 'string') {
        throw new Error('`Inline.create` requires a `type` string.');
      }

      return new Inline({
        type: type,
        key: key,
        data: data,
        nodes: nodes
      });
    }

    throw new Error("`Inline.create` only accepts objects, string or blocks, but you passed it: " + props);
  };

  Inline.childFromJSON = function childFromJSON(node) {
    var klass = node.klass;

    if (klass === 'inline') {
      return Inline.fromJSON(node);
    }

    if (klass === 'text') {
      return Text$1.fromJSON(node);
    }

    throw new Error('`Inline.childFromJSON` requires a valid `klass`(inline|text) string.');
  };

  Inline.fromJSON = function fromJSON(json) {
    var nodes = json.nodes;
    return Inline.create(_extends({}, json, {
      nodes: nodes ? nodes.map(Inline.childFromJSON) : undefined
    }));
  };

  Inline.isInline = function isInline(maybeInline) {
    return maybeInline instanceof Inline;
  }
  /**
   * 是否是叶子inline
   */
  ;

  Inline.isLeafInline = function isLeafInline(maybeLeafInline) {
    if (!this.isInline(maybeLeafInline)) {
      return false;
    }

    for (var _iterator = _createForOfIteratorHelperLoose$a(maybeLeafInline.nodes), _step; !(_step = _iterator()).done;) {
      var child = _step.value;

      if (child.isElement()) {
        return false;
      }
    }

    return true;
  };

  function Inline(props) {
    var _this;

    _this = _Element.call(this, props) || this;
    _this.type = void 0;
    _this.nodes = void 0;
    var type = props.type,
        nodes = props.nodes;
    _this.type = type;
    _this.nodes = nodes;

    _this.freeze();

    return _this;
  }

  var _proto = Inline.prototype;

  _proto.merge = function merge(props) {
    return new Inline(_extends({
      type: this.type,
      key: this.key,
      data: this.data,
      nodes: this.nodes
    }, props));
  };

  _proto.set = function set(key, value) {
    var _this$merge;

    return this.merge((_this$merge = {}, _this$merge[key] = value, _this$merge));
  };

  _proto.toJSON = function toJSON(options) {
    var object = {
      klass: 'inline',
      type: this.type,
      data: _extends({}, this.data),
      nodes: this.nodes.map(function (node) {
        return node.toJSON(options);
      })
    };

    if (options != null && options.preserveKeys) {
      object.key = this.key;
    }

    return object;
  };

  return Inline;
}(Element$1);

var Block = /*#__PURE__*/function (_Element) {
  _inheritsLoose(Block, _Element);

  Block.create = function create(properties) {
    if (Block.isBlock(properties)) {
      return properties;
    }

    var props = typeof properties === 'string' ? {
      type: properties
    } : properties;

    if (isPlainObject(props)) {
      var type = props.type,
          _props$key = props.key,
          key = _props$key === void 0 ? keyUtils.create() : _props$key,
          data = props.data,
          _props$nodes = props.nodes,
          nodes = _props$nodes === void 0 ? [Text$1.create()] : _props$nodes;

      if (typeof type !== 'string') {
        throw new Error('`Block.create` requires a `type` string.');
      }

      return new Block({
        type: type,
        key: key,
        data: data,
        nodes: nodes
      });
    }

    throw new Error("`Block.create` only accepts objects, string or blocks, but you passed it: " + props);
  };

  Block.childFromJSON = function childFromJSON(node) {
    var klass = node.klass;

    if (klass === 'block') {
      return Block.fromJSON(node);
    }

    return Inline.childFromJSON(node);
  };

  Block.fromJSON = function fromJSON(json) {
    var nodes = json.nodes;
    return Block.create(_extends({}, json, {
      // @ts-ignore
      nodes: nodes ? nodes.map(Block.childFromJSON) : nodes
    }));
  };

  Block.isBlock = function isBlock(maybeBlock) {
    return maybeBlock instanceof Block;
  };

  Block.isBlocks = function isBlocks(maybeBlocks) {
    return maybeBlocks.every(Block.isBlock);
  }
  /**
   * 是否是叶子 block
   */
  ;

  Block.isLeafBlock = function isLeafBlock(maybeLeafBlock) {
    var nodes = maybeLeafBlock.nodes;

    if (!this.isBlock(maybeLeafBlock)) {
      return false;
    }

    if (!nodes.length) {
      return true;
    }

    var first = nodes[0];
    return !this.isBlock(first);
  }
  /**
   * 循环获取所有的叶子 block 节点
   */
  ;

  Block.getBlocks = function getBlocks(nodes) {
    return nodes.reduce(function (array, child) {
      if (!Block.isBlock(child)) {
        return array;
      }

      if (!Block.isLeafBlock(child)) {
        return array.concat(child.getBlocks());
      }

      array.push(child);
      return array;
    }, []);
  }
  /**
   * 循环获取所有的满足指定 type 的叶子 block 节点
   */
  ;

  Block.getBlocksByType = function getBlocksByType(nodes, type) {
    return nodes.reduce(function (array, node) {
      if (!Block.isBlock(node)) {
        return array;
      } else if (Block.isLeafBlock(node) && node.type === type) {
        array.push(node);
        return array;
      } else {
        return array.concat(node.getBlocksByType(type));
      }
    }, []);
  };

  function Block(props) {
    var _this;

    _this = _Element.call(this, props) || this;
    _this.type = void 0;
    var type = props.type;
    _this.type = type;

    _this.freeze();

    return _this;
  }

  var _proto = Block.prototype;

  _proto.merge = function merge(props) {
    return new Block(_extends({
      type: this.type,
      key: this.key,
      data: this.data,
      nodes: this.nodes
    }, props));
  };

  _proto.set = function set(key, value) {
    var _this$merge;

    return this.merge((_this$merge = {}, _this$merge[key] = value, _this$merge));
  }
  /**
   * 自身的 nodes 中，是否有 block 类型的节点
   */
  ;

  _proto.hasBlockChildren = function hasBlockChildren() {
    return this.nodes.some(function (b) {
      return Block.isBlock(b);
    });
  }
  /**
   * 获取自身树下所有的叶子 block 节点
   */
  ;

  _proto.getBlocks = function getBlocks() {
    return Block.getBlocks(this.nodes);
  }
  /**
   * 循环获取所有的满足指定 type 的叶子 block 节点
   */
  ;

  _proto.getBlocksByType = function getBlocksByType(type) {
    return Block.getBlocksByType(this.nodes, type);
  };

  _proto.toJSON = function toJSON(options) {
    var object = {
      klass: 'block',
      type: this.type,
      data: _extends({}, this.data),
      nodes: this.nodes.map(function (node) {
        return node.toJSON(options);
      })
    };

    if (options != null && options.preserveKeys) {
      object.key = this.key;
    }

    return object;
  };

  return Block;
}(Element$1);

Block.DEFAULT_TYPE = 'paragraph';

/**
 * @packageDocumentation
 * @module Controller
 */

/**
 * @ignore
 */

/**
 * @ignore
 */
var PendingType;

(function (PendingType) {
  PendingType["input"] = "input";
  PendingType["selection"] = "selection";
})(PendingType || (PendingType = {}));

var PendingConfigType;

(function (PendingConfigType) {
  PendingConfigType["input"] = "input";
  PendingConfigType["selection"] = "selection";
})(PendingConfigType || (PendingConfigType = {}));

/**
 * 消费变更产生的热区
 * @param controller
 * @param onHots
 * @param pendingType
 * @param disabled 是否禁用监听 
 */

function useHots(controller, onHots, pendingType, disabled) {
  useEffect(function () {
    if (!controller.enableHots || disabled) {
      return function () {};
    }

    var handleOnHots = function handleOnHots(hots) {
      if (pendingType && controller.pendingType !== pendingType) {
        return;
      }

      onHots(hots);
    };

    var sub = controller.hots$.subscribe(handleOnHots);
    return function () {
      sub.unsubscribe();
    };
  }, [controller, onHots, pendingType, disabled]);
}
/**
 * 在下一帧时，消费变更产生的热区。当我们期望在热区重渲完成时，再消费热区信息时，可以使用这个 Hook.
 *
 * ## Example
 *
 * ```tsx
 * const Toolbar = props => {
 *   // 假设我们期望热区重渲完成后，获得热区对布局的影响
 *   const onHotsNextFrame = React.useCallback((hots) => {
 *     if (hots.find(hot => hot.node?.type === 'table-cell')) {
 *        const rects = getBoundingClientRect(domRef.current);
 *        // ...
 *     }
 *   }, []);
 *
 *   useHotsAtTheStartOfNextFrame(controller, onHotsNextFrame);
 * }
 * ```
 * @param controller
 * @param onHotsNextFrame
 * @param pendingType
 * @param disabled
 */

function useHotsAtTheStartOfNextFrame(controller, onHotsNextFrame, pendingType, disabled) {
  var animId = React__default.useRef(null);
  var onHots = useCallback(function (hots) {
    animId.current = window.requestAnimationFrame(function () {
      onHotsNextFrame(hots);
    });
  }, [onHotsNextFrame]);
  React__default.useEffect(function () {
    return function () {
      if (animId.current) {
        window.cancelAnimationFrame(animId.current);
      }
    };
  }, []);
  useHots(controller, onHots, pendingType, disabled);
}
/**
 * 消费选区 Pending 的热区 
 * @param controller 
 * @param onHots 
 */

function useSelectingHots(controller, onHots) {
  useHots(controller, onHots, PendingType.selection);
}
/**
 * 在下一帧消费选区 Pending 的热区  
 * @param controller 
 * @param onHotsNextFrame 
 */

function useSelectingHotsAtTheStartOfNextFrame(controller, onHotsNextFrame) {
  useHotsAtTheStartOfNextFrame(controller, onHotsNextFrame, PendingType.selection);
}
/**
 * 消费输入 Pending 的热区 
 * @param controller 
 * @param onHots 
 */

function useInputingHots(controller, onHots) {
  useHots(controller, onHots, PendingType.input);
}
/**
 * 在下一帧消费输入 Pending 的热区 
 * @param controller 
 * @param onHotsNextFrame 
 */

function useInputingHotsAtTheStartOfNextFrame(controller, onHotsNextFrame) {
  useHotsAtTheStartOfNextFrame(controller, onHotsNextFrame, PendingType.input);
}

/**
 * @packageDocumentation
 * @ignore
 */
var isSupportProxy = typeof Proxy !== 'undefined';

/**
 * 获得 Controller 实例，如果组件严格期望在编辑器内容变更后，不进行重渲，仅消费 Controller 实例，请使用 `useControllerStatic`
 * @param options 
 * @returns 
 */
function useController(options) {
  var _ref = options || {},
      _ref$maxPending = _ref.maxPending,
      maxPending = _ref$maxPending === void 0 ? 0 : _ref$maxPending;

  var context = React.useContext(ControllerContext);

  if (!context) {
    throw new Error("The `useController` hook must be used inside the <Cangjie.Provider> component's context.");
  }

  var isRendering = React.useRef(true);
  isRendering.current = true;
  React.useLayoutEffect(function () {
    isRendering.current = false;
  });

  var _React$useReducer = React.useReducer(function (s) {
    return s + 1;
  }, 0),
      forceRender = _React$useReducer[1];

  var hasConsumedValue = React.useRef(false);
  var lastConsumedValue = React.useRef(null);
  var controller = React.useMemo(function () {
    return !isSupportProxy ? context.controller : new Proxy(context.controller, {
      get: function get(ctrl, prop) {
        if (prop === 'value' && isRendering.current) {
          hasConsumedValue.current = true;
          lastConsumedValue.current = ctrl[prop];
        }

        return ctrl[prop];
      }
    });
  }, [context.controller]);
  var debouncedRerender = React.useMemo(function () {
    if (Number.isFinite(maxPending)) {
      return debounce(forceRender, maxPending);
    }

    return noop;
  }, [maxPending]);
  React.useEffect(function () {
    var sub = context.subject.subscribe(function () {
      if ((!isSupportProxy || hasConsumedValue.current) && context.controller.value !== lastConsumedValue.current) {
        forceRender();
      }
    });
    return sub.unsubscribe;
  }, [context]);
  useHots(controller, debouncedRerender);
  return controller;
}

var _createElement$r = React.createElement;
function connectController(Component) {
  return function (props) {
    var controller = useController(); // @ts-ignore

    return /*#__PURE__*/_createElement$r(Component, _extends({}, props, {
      controller: controller
    }));
  };
}

var OperationType;

(function (OperationType) {
  OperationType["AddMark"] = "add_mark";
  OperationType["InsertNode"] = "insert_node";
  OperationType["InsertText"] = "insert_text";
  OperationType["MergeNode"] = "merge_node";
  OperationType["MoveNode"] = "move_node";
  OperationType["RemoveMark"] = "remove_mark";
  OperationType["RemoveNode"] = "remove_node";
  OperationType["RemoveText"] = "remove_text";
  OperationType["SetMark"] = "set_mark";
  OperationType["SetNode"] = "set_node";
  OperationType["SetSelection"] = "set_selection";
  OperationType["SplitNode"] = "split_node";
})(OperationType || (OperationType = {}));

/**
 * op取反
 *
 * move_node 路径矫正说明：
 *
 * Given the document tree:
 * ```txt
 *         []
 *        / \
 *     [0]   [1]
 *            |
 *          [1,0]
 *            |
 *         [1,0,0]
 *         __/ \__
 * [1,0,0,0]      [1,0,0,1]
 * ```
 * case one:
 * ```ts
 * op.path = [0]
 * op.newPath = [1,0,0,1]
 * Path.isYounger([0], [1,0,0,1])   // true
 * // when path is been moved, the new path should decrement
 * Path.decrement([1,0,0,1], 1, 0) // [0,0,0,1]
 * // final inverted op: [0,0,0,1] -> [0]
 * ```
 * case two:
 * ```ts
 * op.path = [1,0,0,1]
 * op.newPath = [1]
 * Path.isAncestor([1], [1,0,0,1])   // true
 * // when move node to it's ancestor, the new path should increment
 * Path.increment([1,0,0,1], 1, 0) // [2,0,0,1]
 * // final inverted op: [2,0,0,1] -> [1]
 * ```
 */
function invert(operation) {
  var type = operation.type;

  if (type === 'add_mark') {
    return _extends({}, operation, {
      type: 'remove_mark'
    });
  }

  if (type === 'insert_node') {
    return _extends({}, operation, {
      type: 'remove_node'
    });
  }

  if (type === 'insert_text') {
    return _extends({}, operation, {
      type: 'remove_text'
    });
  }

  if (type === 'merge_node') {
    var _ref = operation,
        path = _ref.path;
    var invertedPath = Path.decrement(path);
    return _extends({}, operation, {
      type: 'split_node',
      path: invertedPath
    });
  }

  if (type === 'move_node') {
    var _ref2 = operation,
        _path = _ref2.path,
        newPath = _ref2.newPath;

    if (Path.isEqual(_path, newPath)) {
      return operation;
    }

    var _invertedPath = newPath;
    var invertedNewPath = _path;
    var isSibling = Path.isSibling(_path, newPath); // If the node's old position was a left sibling of an ancestor of
    // its new position, we need to adjust part of the path by -1.
    // If the node's new position is an ancestor of the old position,
    // or a left sibling of an ancestor of its old position, we need
    // to adjust part of the path by 1.

    if (!isSibling) {
      var isYounger = Path.isYounger(_path, newPath);
      var isInvertedYounger = Path.isYounger(_invertedPath, invertedNewPath);
      var isInvertedAncestor = Path.isAncestor(_invertedPath, invertedNewPath);

      if (isYounger) {
        _invertedPath = Path.decrement(newPath, 1, _path.length - 1);
      } else if (isInvertedYounger || isInvertedAncestor) {
        invertedNewPath = Path.increment(_path, 1, newPath.length - 1);
      }
    }

    return _extends({}, operation, {
      path: _invertedPath,
      newPath: invertedNewPath
    });
  }

  if (type === 'remove_mark') {
    return _extends({}, operation, {
      type: 'add_mark'
    });
  }

  if (type === 'remove_node') {
    return _extends({}, operation, {
      type: 'insert_node'
    });
  }

  if (type === 'remove_text') {
    return _extends({}, operation, {
      type: 'insert_text'
    });
  }

  if (type === 'set_mark') {
    var _ref3 = operation,
        mark = _ref3.mark,
        properties = _ref3.properties;
    var invertedMark = mark.merge(properties);
    var invertedProperties = Object.keys(properties).reduce(function (p, key) {
      var _extends2;

      return _extends({}, p, (_extends2 = {}, _extends2[key] = mark[key], _extends2));
    }, {});
    return _extends({}, operation, {
      mark: invertedMark,
      properties: invertedProperties
    });
  }

  if (type === 'set_node') {
    var _ref4 = operation,
        _properties = _ref4.properties,
        prevProperties = _ref4.prevProperties;
    return _extends({}, operation, {
      properties: prevProperties || {},
      prevProperties: _properties
    });
  }

  if (type === 'set_selection') {
    var _ref5 = operation,
        selection = _ref5.selection,
        prevSelection = _ref5.prevSelection;
    return _extends({}, operation, {
      selection: prevSelection,
      prevSelection: selection
    });
  }

  if (type === 'split_node') {
    var _ref6 = operation,
        _path2 = _ref6.path;

    var _invertedPath2 = Path.increment(_path2);

    return _extends({}, operation, {
      type: 'merge_node',
      path: _invertedPath2
    });
  }

  throw new Error("Unknown operation type: \"" + type + "\".");
}

var Operation = {
  invert: invert
}; // eslint-disable-next-line no-undef

var PATH_CACHE = new WeakMap();

var Point = /*#__PURE__*/function (_ImmutableRecord) {
  _inheritsLoose(Point, _ImmutableRecord);

  Point.createFromParams = function createFromParams(key, where) {
    if (typeof where === 'number') {
      return TextPoint.create({
        key: key,
        offset: where
      });
    } else {
      return EdgePoint.create({
        key: key,
        edge: where
      });
    }
  };

  Point.create = function create(props) {
    if (props instanceof Point) {
      return props.toSubType();
    }

    if ('edge' in props) {
      return EdgePoint.create(props);
    } else {
      return TextPoint.create(props);
    }
  };

  Point.fromJSON = function fromJSON(json) {
    if ('offset' in json) {
      return TextPoint.fromJSON(json);
    }

    return EdgePoint.fromJSON(json);
  };

  function Point(props) {
    var _this;

    _this = _ImmutableRecord.call(this) || this;
    _this.key = void 0;
    var key = props.key;
    _this.key = key;
    return _this;
  }
  /**
   * 创建一个新的 Point，并移到 node 的第一个子节点的起始位置
   */


  var _proto = Point.prototype;

  _proto.moveToStartOfNode = function moveToStartOfNode(node) {
    var firstNode = node.getFirstNode();
    return TextPoint.create({
      key: firstNode.key,
      offset: 0
    });
  }
  /**
   * 创建一个新的 Point，并移到 node 的最后一个子节点的终点位置
   */
  ;

  _proto.moveToEndOfNode = function moveToEndOfNode(node) {
    var lastNode = node.getLastNode();
    return TextPoint.create({
      key: lastNode.key,
      offset: lastNode.text.length
    });
  }
  /**
   * 是否在 node 的第一个节点的起始位置
   */
  ;

  _proto.isTextPoint = function isTextPoint() {
    return this instanceof TextPoint;
  };

  _proto.isEdgePoint = function isEdgePoint() {
    return this instanceof EdgePoint;
  };

  _proto.moveBackward = function moveBackward() {
    return this.toSubType();
  };

  _proto.moveForward = function moveForward() {
    return this.toSubType();
  };

  _proto.toSubType = function toSubType() {
    if (this.isTextPoint()) {
      return this;
    } else if (this.isEdgePoint()) {
      return this;
    }

    throw new Error("Target is not a valid point: " + this);
  };

  _proto.convertToTextPoint = function convertToTextPoint(document) {
    var _textNode2;

    var point = this.toSubType();

    if (point.isTextPoint()) {
      return point;
    }

    var node = document.getNode(this.key);
    var textNode = point.edge === EdgePoint.BEFORE ? node == null ? void 0 : node.getFirstText() : node == null ? void 0 : node.getLastText();

    if (!textNode) {
      textNode = point.edge === EdgePoint.BEFORE ? document.getFirstNode() : document.getLastNode();
    }

    var _textNode = textNode,
        key = _textNode.key;
    var offset = point.edge === EdgePoint.BEFORE ? 0 : (_textNode2 = textNode) == null ? void 0 : _textNode2.text.length;
    return TextPoint.create({
      key: key,
      offset: offset
    });
  }
  /**
   * 是否在 node 内部
   */
  ;

  _proto.isInNode = function isInNode(node) {
    if (node.isText() && node.key === this.key) return true;
    if (node.isElement() && node.getNode(this.key)) return true;
    return false;
  } // NOTE: point.getPathIn(document) === document.getPath(point.key)
  // PERF: ~5ms in Huge Document story
  //       Why do not memoize `document.getPath`? Node's path will not be re-get frequently, but Point's path does.
  ;

  _proto.getPathIn = function getPathIn(document) {
    if (!PATH_CACHE.has(this)) {
      PATH_CACHE.set(this, new WeakMap());
    }

    var DOCUMENT_TO_PATH_CACHE = PATH_CACHE.get(this);

    if (!DOCUMENT_TO_PATH_CACHE.has(document)) {
      DOCUMENT_TO_PATH_CACHE.set(document, document.getPath(this.key));
    }

    return DOCUMENT_TO_PATH_CACHE.get(document);
  };

  return Point;
}(ImmutableRecord);
var TextPoint = /*#__PURE__*/function (_Point) {
  _inheritsLoose(TextPoint, _Point);

  TextPoint.create = function create(props) {
    if (props instanceof TextPoint) {
      return props;
    }

    if (isPlainObject(props)) {
      var key = props.key,
          offset = props.offset;
      return new TextPoint({
        key: key,
        offset: offset
      });
    }

    throw new Error("`Point.create` only accepts objects or points, but you passed it: " + props);
  };

  TextPoint.fromJSON = function fromJSON(json) {
    return TextPoint.create(_extends({}, json, {
      key: json.key || 'NONE'
    }));
  };

  _createClass(TextPoint, [{
    key: "viewKey",
    get: function get() {
      return this.key + "-" + this.offset;
    }
  }]);

  function TextPoint(props) {
    var _this2;

    _this2 = _Point.call(this, props) || this;
    _this2.offset = void 0;
    var offset = props.offset;
    _this2.offset = offset;

    _this2.freeze();

    return _this2;
  }
  /**
   * 把 offset 加 n，并返回一个新的 Point。
   * @n 移动的个数，可以为正/负值，默认为 1；如果 n=0，则返回自身。
   */


  var _proto2 = TextPoint.prototype;

  _proto2.moveForward = function moveForward(n) {
    if (n === void 0) {
      n = 1;
    }

    if (n === 0) {
      return this;
    }

    if (n < 0) {
      return this.moveBackward(-n);
    }

    return this.set('offset', this.offset + n);
  }
  /**
   * 把 offset 减 n，并返回一个新的 Point。
   * @n 移动的个数，可以为正/负值，默认为 1；如果 n=0，则返回自身。
   */
  ;

  _proto2.moveBackward = function moveBackward(n) {
    if (n === void 0) {
      n = 1;
    }

    if (n === 0) {
      return this;
    }

    if (n < 0) {
      return this.moveForward(-n);
    }

    return this.set('offset', this.offset - n);
  }
  /**
   * 创建一个新的 Point
   * @offset 默认是 0
   */
  ;

  _proto2.moveTo = function moveTo(key, offset) {
    if (offset === void 0) {
      offset = 0;
    }

    return this.merge({
      key: key,
      offset: offset
    });
  }
  /**
   * 是否在 node 的第一个节点的起始位置
   */
  ;

  _proto2.isAtStartOfNode = function isAtStartOfNode(node) {
    if (this.offset !== 0) return false;
    var first = node.getFirstNode();
    return this.key === first.key;
  }
  /**
   * 是否在 node 的最后一个节点的终点位置
   */
  ;

  _proto2.isAtEndOfNode = function isAtEndOfNode(node) {
    var last = node.getLastNode();
    return this.key === last.key && this.offset === last.text.length;
  };

  _proto2.merge = function merge(props) {
    return new TextPoint(_extends({
      key: this.key,
      offset: this.offset
    }, props));
  };

  _proto2.set = function set(key, value) {
    var _this$merge;

    return this.merge((_this$merge = {}, _this$merge[key] = value, _this$merge));
  };

  _proto2.toJSON = function toJSON(options) {
    var object = {
      klass: 'point',
      offset: this.offset
    };

    if (options != null && options.preserveKeys) {
      object.key = this.key;
    }

    return object;
  };

  return TextPoint;
}(Point);
var EdgePoint = /*#__PURE__*/function (_Point2) {
  _inheritsLoose(EdgePoint, _Point2);

  EdgePoint.create = function create(props) {
    if (props instanceof EdgePoint) {
      return props;
    }

    if (isPlainObject(props)) {
      var key = props.key,
          edge = props.edge;
      return new EdgePoint({
        key: key,
        edge: edge
      });
    }

    throw new Error("`Point.create` only accepts objects or points, but you passed it: " + props);
  };

  EdgePoint.fromJSON = function fromJSON(json) {
    return EdgePoint.create(_extends({}, json, {
      key: json.key || 'NONE'
    }));
  };

  _createClass(EdgePoint, [{
    key: "viewKey",
    get: function get() {
      return this.key + "-" + this.edge;
    }
  }]);

  function EdgePoint(props) {
    var _this3;

    _this3 = _Point2.call(this, props) || this;
    _this3.edge = void 0;
    var edge = props.edge;
    _this3.edge = edge;

    _this3.freeze();

    return _this3;
  }
  /**
   * 是否在 node 的第一个节点的起始位置
   */


  var _proto3 = EdgePoint.prototype;

  _proto3.isAtStartOfNode = function isAtStartOfNode(node) {
    return this.key === node.key && this.edge === EdgePoint.BEFORE;
  }
  /**
   * 是否在 node 的最后一个节点的终点位置
   */
  ;

  _proto3.isAtEndOfNode = function isAtEndOfNode(node) {
    return this.key === node.key && this.edge === EdgePoint.AFTER;
  };

  _proto3.merge = function merge(props) {
    return new EdgePoint(_extends({
      key: this.key,
      edge: this.edge
    }, props));
  };

  _proto3.set = function set(key, value) {
    var _this$merge2;

    return this.merge((_this$merge2 = {}, _this$merge2[key] = value, _this$merge2));
  };

  _proto3.toJSON = function toJSON(options) {
    var object = {
      klass: 'point',
      edge: this.edge
    };

    if (options != null && options.preserveKeys) {
      object.key = this.key;
    }

    return object;
  };

  return EdgePoint;
}(Point);
EdgePoint.BEFORE = 'before';
EdgePoint.AFTER = 'after';

/**
 * @packageDocumentation
 * @ignore
 */
var classesmjs = {
  "trie": "ABAOAAAAAAAQmQAAAYAIf/ftmwuoFUUYx+d4z7nnHO+rUiF8gFHRBQ00CyQpJEtMUiwSSjLkViBlIqUhXnuoEXXpaWVkJFFWpj3EQCN6UdiVIKw0C4QSxbDkhkSKlUL/ZXe709yZ2XnvUfeDHzM7M/t937xn9+yZ3kTIDWAO6ALLwEoqzTbsAavBk2CNQvl14A1J/kawBXwIPgdfge/Aj2AfVe4g6AN/gL8BKRNSA1XQAYaCkeBF8ApYX47vTdkDLkDa2+BdsBV8Ar4EvWAn+AH8DPaBQ6CPuj4KTiblKxVC2irx/cMQvoNwVCW2cyHCOq4vrvTrn4D4pOR6CsJrwFjKfnTfDKSNq8Xx2YjfUun3fR7i85PrBQjvTeLdCFeBHjCUKr8a8bXgVbCx8v92uLHWz9yE28CSBLqsjDcVy7lmSyXmr3JMlPYBrj9L6jmf6ffxSN/OtMHXFbH+3UneXoQHkvgjYEii9zDSfgfHwAlQbiaktTnOG5KEw5sH6h2NtE5Oeko0r8ZJ8lVZCD8XR+MMumZS6VEdnkjq8zjVz88ivlaj319G2fVU+TT+FsL3JHq2SfI+Rt520At2gt0Ue5nr/eBXcAQcB/+AprpeG7Volqc5J7l3uIGOiUz/7uKMAdv+j7iSsjPVckyNtmirgoKCgoKCgoKCgoKCggIVZjTH79LS64WS9zYps3HPXOqZt7dKyGU1Qu5A2t1J+hKEy8HsWvw+cAXiVyD+WJL/FMIXwEvJ9WsIjyHclPEs/T7yH4CeB8FDYAVYCVaBh2tFXpFX5BV5RZ7rvLvAPeC+Wv57VkFBwenLNge/0clY09T/uzpLFyeNPh8vL/vxSYcNbTGHwDQFOtsJmdg+MH0pk7YB14dAZwch8zritOcQ7gDkLEJGgllgcgshi8D+OiHnDSbk+VLMzVScZVOLOI+mm9KxGfHDuG9MK54twOvgYKuanoKCgoKC048j2BcI9oUDOCccx35YKsffeUTfCV2C+OXJHj0I4W9IuxrPLEea4/yj4CpqDz/JOWtEuirV/u/I2hAfVuXvxSOQfj6VNwbxCYKyERORN5nKn1bt/+4pYhaVF33/dZNE11xJXsRU6J3JnFduxz0LwOLoXuR1JzrmGJxrVlL2exB/mvFnDa67Er3rMnylWa9R1ierGuCsx7IDbXN9QHs9aINvYHMPp09+apB+0iX6XreHYhlDj4RnygPLn2nYtP2nGc92Q5g51+v5WdCEnfBpl8Cv8Qq/n6jwrWa993LKd3hevzYm839zA6wDW+HDddjnP6J8+cKBX9Gc/6Uah30I/wQnGqC+qpTRJq0Z72xN++/sU+BdMFu3c08Bn02gv9/mcVE9/n48KjsW8UvBpHqc1wmmID49+g65nq2LZbRiue/BnAz9t9b59aHrOoK67kr03ZnctygJlyK8n7I1Kvo9A9ePGtSPtW/S/j6J2vXaptJ/lOO/7mTSRMUHKd6jQiH5SdH+7saxz/HfzvGZTTOVyhmOSwllp9Ek7z407Xc6FMVPdykJUBXdNm/kPacR15dQY1BWh1JGGVYHr6wPof3KSxpprDSynAnt4KpuvDlVUtTvmqqgDlUK9ppeM1TraSqsXdZ3Oj0Vnf2NJ7b305K2n2zfFbW/q/2lyoEwcdoPuo+rVJj33JWNYd784YnoPGQ7d3R9LmXc50No+z7OaeVEdxtx9/7H9bslV8/VqYR+H+bCBm/dp4W31qZjRoaL/ahR3zfy1hbR/q9aLpTI7LLrWV5Cj0lC5Pu+6BxAl6f3Ntm9Ov7ltf+x9Qltm/VB1Iasj3R5HVuqZUP2R4WJ5zVfZPODV5bnN1vWZTva6hfNd1o3e371MQ58jy/b9cilH7Q/Pua36Xqbh4jW2qznYVXdOvbzeObi7adpuuxMk6Uzz/6MhD0X8M4IvP51XT/2zJKnsP2p449ov+GdEejyvHcRrsc62+ema23WudOVqPprYjfvfSaEPXaM8ey5nG8qfcRD5Wxja8/GP1fYimq7sfXVWbNtRfXs7aM9THVEovrO0kZ8tH2otUtlzNFjTbaXqb6/0K2bzzaQ1ZGXzgqv/iI9IfvS51marq/K2kyHJOMe1XZUGVMi3SElq56i+tLpeYmPvS+vfqCFN5Z4c97nvGVt8Pqe55+uqKzbKnPRx97OXqui+5wj85vOUz0rhEBky0ZcjmeR3ya/N7r+jTJLfLUBL810jOqOYxfCWwN9+yBaj0KJy/lqYtvULx+iuwa73sNpvSJ7KvZDjp/UnqyNRNcmdlTK5H1m9KGPN/Zl7WjSxqrjy/TZSvSszL6HDz1+eZKnDyFs66ypoj1eRa9v0TlTqOpyKfQYz1tEa3Qee23qj0vRfVdi+zwp2ut03rnq+OxDaN/ZNV90rdpuOj6zelXbIeR4TcXm/QE9PnyKK/2yMylbH9EcyOO5hieyuqQieh7Lqw6ubZqOXZMxKxobsjGk6r/qPuZaTPaYkH2YCtuHdHlWV2hRabcQ80zVhs7abiMq73Vt54+qqPYRz8esevheV1XGE9uehFNGJrzfElh9tutnlrDj0KVOX/PQ53xn290EHd9tfFQVH+8ZdUW0/rD5Iddw33ZC7kMiu65xZUulDjr19SUi3122oQufXPmmOy+z7PqQ0O3pWtoDwquTqGxzIFyJr33N9Z4fQkL6YXM2ckGtAaClnjODPdPKoCsu68qK77qrwEoLGdhmPgltLxWf3xz51s3DREdIUbUZ0i9XtnTONLJ7Q/hqKrpjRrVs3vWihddXsn7UPc+a3OML0zaxtWfSXoTIfTbN45U1WUtltmT+i+qqY9u0X21E156NX3ndK9Np0095+6KiUyXNh5jOA54eV21ju36yemz8yPLJ1Vrgep8JtU/Zim4b88qp2vFFHjZ9rW8mvtvq9u2rrZ5Q9m3t+BpbJnk+x/e/",
  "classes": {
    "Other": 0,
    "Prepend": 1,
    "CR": 2,
    "LF": 3,
    "Control": 4,
    "Extend": 5,
    "Regional_Indicator": 6,
    "SpacingMark": 7,
    "L": 8,
    "V": 9,
    "T": 10,
    "LV": 11,
    "LVT": 12,
    "ZWJ": 13,
    "ExtPict": 14
  }
};

/**
 * @packageDocumentation
 * @ignore
 */
var trie = classesmjs.trie;
var _classesmjs$classes = classesmjs.classes,
    Other = _classesmjs$classes.Other,
    Prepend = _classesmjs$classes.Prepend,
    CR = _classesmjs$classes.CR,
    LF = _classesmjs$classes.LF,
    Control = _classesmjs$classes.Control,
    Extend = _classesmjs$classes.Extend,
    Regional_Indicator = _classesmjs$classes.Regional_Indicator,
    SpacingMark = _classesmjs$classes.SpacingMark,
    L = _classesmjs$classes.L,
    V = _classesmjs$classes.V,
    T = _classesmjs$classes.T,
    LV = _classesmjs$classes.LV,
    LVT = _classesmjs$classes.LVT,
    ZWJ = _classesmjs$classes.ZWJ,
    ExtPict = _classesmjs$classes.ExtPict;
var data = null;

if (typeof window !== 'undefined') {
  var bin = window.atob(trie);
  data = new Uint8Array(bin.length);

  for (var i = 0; i < bin.length; i++) {
    data[i] = bin.charCodeAt(i);
  }
} else {
  data = Buffer.from(trie, 'base64');
} // console.log(data, data.length)


var classTrie = new UnicodeTrie(data);

var codePointAt = function codePointAt(str, idx) {
  // different from String#codePointAt with low surrogate
  var code = str.charCodeAt(idx); // High surrogate

  if (code >= 0xD800 && code <= 0xDBFF) {
    var hi = code;
    var low = str.charCodeAt(idx + 1);

    if (low >= 0xDC00 && low <= 0xDFFF) {
      return (hi - 0xD800) * 0x400 + (low - 0xDC00) + 0x10000;
    }

    return hi;
  } // Low surrogate


  if (code >= 0xDC00 && code <= 0xDFFF) {
    var _hi = str.charCodeAt(idx - 1);

    var _low = code;

    if (_hi >= 0xD800 && _hi <= 0xDBFF) {
      return (_hi - 0xD800) * 0x400 + (_low - 0xDC00) + 0x10000;
    }

    return _low;
  }

  return code;
};

var isSurrogate$1 = function isSurrogate(str, pos) {
  var ref;
  var ref1; // eslint-disable-next-line no-return-assign

  return (ref = str.charCodeAt(pos)) >= 0xd800 && ref <= 0xdbff && (ref1 = str.charCodeAt(pos + 1)) >= 0xdc00 && ref1 <= 0xdfff;
};

var BreakType = {
  NotBreak: 0,
  BreakStart: 1,
  Break: 2,
  BreakLastRegional: 3,
  BreakPenultimateRegional: 4
}; // Returns whether a break is allowed within a sequence of grapheme breaking classes

var shouldBreak = function shouldBreak(reverse, start, mid, end) {
  var all = [start].concat(mid).concat([end]);
  var previous = reverse ? start : all[all.length - 2];
  var next = reverse ? all[1] : end; // Lookahead terminator for:
  // GB12. ^ (RI RI)* RI × RI
  // GB13. [^RI] (RI RI)* RI × RI

  var rIIndex = all.lastIndexOf(Regional_Indicator);

  if (rIIndex > 0 && all.slice(1, rIIndex).every(function (c) {
    return c === Regional_Indicator;
  }) && previous !== Prepend && previous !== Regional_Indicator) {
    if (all.filter(function (c) {
      return c === Regional_Indicator;
    }).length % 2 === 1) {
      return BreakType.BreakLastRegional;
    }

    return BreakType.BreakPenultimateRegional;
  } // GB3. CR X LF


  if (previous === CR && next === LF) {
    return BreakType.NotBreak;
  } // GB4. (Control|CR|LF) ÷


  if (previous === Control || previous === CR || previous === LF) {
    // return BreakType.BreakStart
    if (next !== Extend && mid.every(function (c) {
      return c === Extend;
    })) {
      return BreakType.Break;
    }

    return BreakType.BreakStart;
  } // GB5. ÷ (Control|CR|LF)


  if (next === Control || next === CR || next === LF) {
    return BreakType.BreakStart;
  } // GB6. L X (L|V|LV|LVT)


  if (previous === L && (next === L || next === V || next === LV || next === LVT)) {
    return BreakType.NotBreak;
  } // GB7. (LV|V) X (V|T)


  if ((previous === LV || previous === V) && (next === V || next === T)) {
    return BreakType.NotBreak;
  } // GB8. (LVT|T) X (T)


  if ((previous === LVT || previous === T) && next === T) {
    return BreakType.NotBreak;
  } // GB9.0 X (Extend|ZWJ)


  if (reverse) {
    if (next === Extend) {
      return BreakType.NotBreak;
    }

    if (next === ZWJ) {
      if (previous == Other && mid.length > 0 && mid[0] == ZWJ) {
        return end != ExtPict ? BreakType.BreakStart : BreakType.Break;
      }

      return BreakType.NotBreak;
    }
  } else if (next === Extend || next === ZWJ) {
    return BreakType.NotBreak;
  } // GB9.1 X SpacingMark


  if (next === SpacingMark) {
    return BreakType.NotBreak;
  } // GB9.2 Prepend X


  if (previous === Prepend) {
    return BreakType.NotBreak;
  } // GB11.0 ExtPict Extend * ZWJ × ExtPict


  if (reverse) {
    if (previous == ZWJ && next == ExtPict && (start == ZWJ || start == Other)) {
      return BreakType.NotBreak;
    }
  } else if (start == ExtPict && previous == ZWJ && next == ExtPict) {
    return BreakType.NotBreak;
  } // GB12. ^ (RI RI)* RI × RI
  // GB13. [^RI] (RI RI)* RI × RI


  if (!reverse && mid.indexOf(Regional_Indicator) >= 0) {
    return BreakType.Break;
  }

  if (previous === Regional_Indicator && next === Regional_Indicator) {
    return BreakType.NotBreak;
  } // GB999. Any ÷ Any


  return BreakType.BreakStart;
};

var getUnicodeByteOffset = function getUnicodeByteOffset(str, start, unicodeOffset) {
  while (unicodeOffset--) {
    start += isSurrogate$1(str, start) ? 2 : 1;
  }

  return start;
}; // Returns the next grapheme break in the string after the given index


function nextBreak(string, index) {
  if (index === void 0) {
    index = 0;
  }

  if (index < 0) {
    return 0;
  }

  if (index >= string.length - 1) {
    return string.length;
  }

  var prev = classTrie.get(string.codePointAt(index));
  var mid = [];
  var i;
  var j;
  var ref; // eslint-disable-next-line no-multi-assign

  for (i = j = index + 1, ref = string.length; j < ref; i = j += 1) {
    if (isSurrogate$1(string, i - 1)) {
      // check for already processed low surrogates
      continue;
    }

    var next = classTrie.get(string.codePointAt(i));

    if (shouldBreak(false, prev, mid, next)) {
      return i;
    }

    mid.push(next);
  }

  return string.length;
} // Returns the next grapheme break in the string before the given index


function previousBreak(string, index) {
  if (index === void 0) {
    index = string.length;
  }

  if (index > string.length) {
    return string.length;
  }

  if (index <= 1) {
    return 0;
  }

  index--;
  var mid = [];
  var next = classTrie.get(codePointAt(string, index));
  var i;
  var j; // eslint-disable-next-line no-multi-assign

  for (i = j = index - 1; j >= -1; i = j += -1) {
    if (isSurrogate$1(string, i)) {
      // check for already processed high surrogates
      continue;
    }

    var prev = classTrie.get(codePointAt(string, i));

    switch (shouldBreak(true, prev, mid, next)) {
      case BreakType.Break:
        return i + mid.length + 1;

      case BreakType.BreakStart:
        return i + 1;

      case BreakType.BreakLastRegional:
        // eslint-disable-next-line no-case-declarations
        var offset = getUnicodeByteOffset(string, i, mid.concat(next).lastIndexOf(Regional_Indicator) + 1);
        return offset;

      case BreakType.BreakPenultimateRegional:
        return getUnicodeByteOffset(string, i, mid.concat(next).lastIndexOf(Regional_Indicator));
    }

    mid.unshift(prev);
  }
} // Breaks the given string into an array of grapheme cluster strings


function breaks(str) {
  var res = [];
  var index = 0;
  var brk; // eslint-disable-next-line no-cond-assign

  while ((brk = nextBreak(str, index)) < str.length) {
    res.push(str.slice(index, brk));
    index = brk;
  }

  if (index < str.length) {
    res.push(str.slice(index));
  }

  return res;
} // Returns the number of grapheme clusters there are in the given string


function countBreaks$1(str) {
  var count = 0;
  var index = 0;
  var brk; // eslint-disable-next-line no-cond-assign

  while ((brk = nextBreak(str, index)) < str.length) {
    index = brk;
    count++;
  }

  if (index < str.length) {
    count++;
  }

  return count;
}

var GraphemesBreaker = {
  nextBreak: nextBreak,
  previousBreak: previousBreak,
  "break": breaks,
  countBreaks: countBreaks$1
};

/**
 * @packageDocumentation
 * @ignore
 */
var SURROGATE_START = 0xd800;
var SURROGATE_END = 0xdfff;
var SPACE = /\s/;
/**
 * 标点的定义各家不统一
 * 部分常用标点可以在 https://www.ascii-code.com/ 上查看
 * 目前至少确保标准键盘能输入的标点
 */

var PUNCTUATION = /[\u0021-\u002F\u003A-\u0040\u005B-\u0060\u007B-\u007E\u00A1-\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65\uFFE5]/;

function isChineseChar(_char) {
  return /[\u3400-\u9FBF]/.test(_char);
}

function isValidString(str) {
  return typeof str === 'string' && str !== '';
}

function isPunc(_char2) {
  return PUNCTUATION.test(_char2);
} // 当满足以下条件时，认为是同一类型：
// 1. 都是「标点/SPACE」或都不是「标点/SPACE」
// 2. 都是中文或都不是中文


function isSameCharType(charA, charB) {
  return isValidString(charA) && isValidString(charB) && isWord(charA) === isWord(charB) && isChineseChar(charA) === isChineseChar(charB);
}

function getNextLetter(str, i, reverse) {
  var nextBreak;
  if (!str || i < 0 || i > str.length) return '';

  if (reverse) {
    nextBreak = GraphemesBreaker.previousBreak(str, i);
    return str.substring(nextBreak, i);
  }

  nextBreak = GraphemesBreaker.nextBreak(str, i);
  return str.substring(i, nextBreak);
}

function countBreaks(str, i, reverse) {
  if (!str || i < 0 || i > str.length) return 0;
  var start = reverse ? i : 0;
  var end = reverse ? str.length : i;
  var text = str.substring(start, end);
  return GraphemesBreaker.countBreaks(text);
}

function isSurrogate(code) {
  return SURROGATE_START <= code && code <= SURROGATE_END;
}

function isWord(_char3) {
  if (SPACE.test(_char3)) {
    return false;
  }

  if (PUNCTUATION.test(_char3)) {
    return false;
  }

  return true;
}

function getCharOffset(text, offset, reverse) {
  return getNextLetter(text, offset, reverse).length;
}

function getCharOffsetBackward(text, offset) {
  return getNextLetter(text, offset, true).length || 1;
}

function getCharOffsetForward(text, offset) {
  return getNextLetter(text, offset).length || 1;
} // 在搜索结果处处理Unicode，避免光标focus到Unicode中间


function getCharRange(text, offset) {
  var start = 0;

  while (start <= offset) {
    var end = start + getCharOffsetForward(text, start);

    if (end > offset) {
      return [start, end];
    }

    start = end;
  }

  return [start, start + Math.min(text.length, 1)];
}

function getWordRange(text, offset) {
  if (!text) {
    return [0, 0];
  } // eslint-disable-next-line no-param-reassign


  offset = Math.min(offset, text.length);
  var charAtOffset = text[offset];
  var lastChar = text[offset - 1];
  var nextChar = text[offset + 1];
  var end = 0;
  var start = 0; // 当前字符不为空时，至少选中该字符

  if (isValidString(charAtOffset)) {
    end = 1;
  } // 当前字符为空时，说明在文本末尾需要 backward 遍历
  // backward 遍历，找到词的后半部分的长度


  if (!isValidString(charAtOffset) || isSameCharType(lastChar, charAtOffset)) {
    start = getWordOffsetBackward(text, offset);
  } // 当前字符为空或当前字符和前一字符同类型时
  // forward 遍历，找到词的前半部分的长度


  if (isSameCharType(nextChar, charAtOffset)) {
    end = getWordOffsetForward(text, offset);
  }

  return [offset - start, offset + end];
}

function getWordOffset(text, offset, reverse) {
  var length = 0;
  var i = offset;

  var _char4 = getNextLetter(text, i, reverse);

  var curChar = _char4;

  while (isSameCharType(_char4, curChar)) {
    length += _char4.length;

    if (reverse) {
      i -= _char4.length;
    } else {
      i += _char4.length;
    }

    _char4 = getNextLetter(text, i, reverse);
  } // 如果没有迭代到字符，至少保证选中前一个字符


  return length || _char4.length;
} // 计算光标以 word 为单位时移动的偏移量


function getMoveWordOffset(text, offset, reverse) {
  var _char5 = getNextLetter(text, offset, reverse);

  if (!isValidString(_char5)) {
    return 0;
  }

  var delta = 0;
  var i = offset; // 参考原生实现: 直接跳过光标附近的 SPACE

  while (SPACE.test(_char5)) {
    if (reverse) {
      i -= _char5.length;
      delta -= 1;
    } else {
      i += _char5.length;
      delta += 1;
    }

    _char5 = getNextLetter(text, i, reverse);
  }

  return Math.abs(delta) + getWordOffset(text, offset + delta, reverse);
}

function getWordOffsetBackward(text, offset) {
  var o = getWordOffset(text, offset, true);
  return o;
}

function getWordOffsetForward(text, offset) {
  var o = getWordOffset(text, offset);
  return o;
}

function graphemesBreak(text) {
  return GraphemesBreaker["break"](text);
}

var NEWLINE$1 = '\n';
var SECLINE = '\r';
var SIMPLE_SPACE = String.fromCharCode(32);
var spaceUniCode = {
  nbsp: "\xA0",
  zwnj: "\u200C",
  zwj: "\u200D"
};
/**
 *  处理字符串中的特殊字符
 * 
 *  1. 单独 \r 或 \r\n 效果类似 \n ，有折行效果
 *     \r\r 或 \n\n， 有隔行效果
 *  2. &nbsp; 替换成普通空格，移除 &zwnj;、&zwj 零宽字符
 * */

function normalizeText$2(text) {
  var result = '';

  for (var i = text.length - 1; i >= 0; i--) {
    if (text[i] === NEWLINE$1) {
      if (text[i - 1] === SECLINE) {
        i--;
      }

      result = NEWLINE$1 + result;
      continue;
    }

    if (text[i] === SECLINE) {
      result = NEWLINE$1 + result;
      continue;
    }

    if (text[i] === spaceUniCode.nbsp) {
      result = SIMPLE_SPACE + result;
      continue;
    }

    if (text[i] === spaceUniCode.zwnj || text[i] === spaceUniCode.zwj) {
      continue;
    }

    result = text[i] + result;
  }

  return result;
}
var textUtils = {
  countBreaks: countBreaks,
  getNextLetter: getNextLetter,
  getCharOffset: getCharOffset,
  getCharOffsetBackward: getCharOffsetBackward,
  getCharOffsetForward: getCharOffsetForward,
  getCharRange: getCharRange,
  getWordRange: getWordRange,
  getWordOffset: getWordOffset,
  getMoveWordOffset: getMoveWordOffset,
  getWordOffsetBackward: getWordOffsetBackward,
  getWordOffsetForward: getWordOffsetForward,
  isSurrogate: isSurrogate,
  isWord: isWord,
  isPunc: isPunc,
  isChineseChar: isChineseChar,
  graphemesBreak: graphemesBreak,
  normalizeText: normalizeText$2
};

function isValidElement(el) {
  return el !== null && el.nodeType === Node.ELEMENT_NODE && !el.getAttribute('data-cangjie-content');
}
/**
 * Find closest ancestor
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/closest
 * @returns
 */


function findClosestInContent(el, selector) {
  do {
    if (Element.prototype.matches.call(el, selector)) return el;
    el = el.parentElement || el.parentNode;
  } while (isValidElement(el));

  return null;
}

/**
 * @packageDocumentation
 * @module constants
 */
var CUSTOM_MIME_TYPES = {
  FRAGMENT: 'application/x-cangjie-fragment',
  PACKAGE: 'application/x-cangjie-fragment-pack',
  SYNC: 'application/x-hetu-sync',
  DOCKEY: 'application/x-doc-key',
  REFBLOCK: 'application/x-refblock',
  ENCRYPTION: 'application/x-cangjie-encryption',
  APPLICATION_VSCODE: 'vscode-editor-data'
};
var MIME_TYPES = _extends({
  HTML: 'text/html',
  TEXT: 'text/plain'
}, CUSTOM_MIME_TYPES);
var EVENTS = ['onAction', 'onChange', 'onCangjieFocus', 'onCangjieBlur', 'onCangjieInput', 'onCangjieSelect', 'onCangjieCopy', 'onCangjieCut', 'onCangjiePaste', 'onCangjieComposingChange', 'onClick', 'onCopy', 'onCut', 'onPaste', 'onKeyDown', 'onKeyUp', 'onMouseDown', 'onMouseMove', 'onMouseUp', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onContextMenu', 'onDragStart', 'onDragOver', 'onDrop', 'onDragEnter'];
/**
 * 光标宽度
 */

var CURSOR_WIDTH = 2;
/**
 * Edge 光标的最大高度
 */

var CURSOR_EDGE_MAX_HEIGHT = 21;
/**
 * Edge 光标和元素之间的偏移量
 */

var CURSOR_EDGE_OFFSET = 1;
var CANGJIE_EMPTY = "\uFEFF";
/**
 * 选区颜色
 */

var CANGJIE_SELECTION_COLOR = 'rgba(1, 134, 251, 0.3)';
/**
 * 空行时最小宽度
 */

var CANGJIE_SELECTION_EMPTY_WIDTH = 4;
/**
 * Blur的选区颜色
 */

var CANGJIE_SELECTION_INACTIVE_COLOR = 'rgba(136, 136, 136, 0.3)';
var Z_INDEX_CONTEXTMENU = 10000;
var Selector = {
  key: 'data-cangjie-key',
  content: 'data-cangjie-content',
  edgeSelectable: 'data-cangjie-edge-selectable',
  editable: 'data-cangjie-editable',
  "void": 'data-cangjie-void',
  leaf: 'data-cangjie-leaf',
  leafBlock: 'data-cangjie-leaf-block',
  nonSelect: 'data-cangjie-non-select',
  notEditable: 'data-cangjie-not-editable',
  dockey: 'data-cangjie-dockey',
  selectionLayer: 'data-cangjie-selection-layer',
  selectionWrapper: 'data-cangjie-selection-wrapper',
  groupBlock: 'data-cangjie-group-block',
  groupKey: 'data-cangjie-group-key',
  hoverWrapper: 'data-hover-box',
  uuid: 'data-block-uuid'
};
/**
 * 默认 undo 队列最大长度限制
 */

var MAX_HISTORY_SIZE = 100;
/** 仓颉 Group 折叠 key */

var GROUP_COLLAPSED_KEY = 'cangjieGroupCollpased';

var constants = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CUSTOM_MIME_TYPES: CUSTOM_MIME_TYPES,
  MIME_TYPES: MIME_TYPES,
  EVENTS: EVENTS,
  CURSOR_WIDTH: CURSOR_WIDTH,
  CURSOR_EDGE_MAX_HEIGHT: CURSOR_EDGE_MAX_HEIGHT,
  CURSOR_EDGE_OFFSET: CURSOR_EDGE_OFFSET,
  CANGJIE_EMPTY: CANGJIE_EMPTY,
  CANGJIE_SELECTION_COLOR: CANGJIE_SELECTION_COLOR,
  CANGJIE_SELECTION_EMPTY_WIDTH: CANGJIE_SELECTION_EMPTY_WIDTH,
  CANGJIE_SELECTION_INACTIVE_COLOR: CANGJIE_SELECTION_INACTIVE_COLOR,
  Z_INDEX_CONTEXTMENU: Z_INDEX_CONTEXTMENU,
  Selector: Selector,
  MAX_HISTORY_SIZE: MAX_HISTORY_SIZE,
  GROUP_COLLAPSED_KEY: GROUP_COLLAPSED_KEY
});

/**
 * @packageDocumentation
 * @module domUtils
 */
/**
 * 根据浏览器的节点和位置获取仓颉对应的 Point。
 */

function findPoint(nativeNode, nativeOffset, controller) {
  if (!nativeNode) {
    return null;
  }

  var node = nativeNode instanceof Text ? nativeNode.parentElement : nativeNode;

  if (!(node instanceof Element)) {
    return null;
  }

  var document = controller.value.document;
  var leaf;

  if (node.getAttribute(Selector["void"])) {
    // 原本这里有一层「判断 node 内部是否存在 leaf 节点，不存在才继续」的逻辑
    // 由于 hetu 等插件内部可能嵌套了编辑器，且 key 不可控，可能与宿主重复，造成问题（选区异常 or 页面奔溃）
    // 因此这里去掉 `!isLeaf` 判断
    var _key = node.getAttribute(Selector.key);

    if (!_key) {
      return null;
    }

    var voidNode = document.getNode(_key);

    if (!voidNode) {
      return null;
    }

    var _text = voidNode.getFirstText();

    if (!_text) {
      return null;
    }

    return TextPoint.create({
      key: _text.key,
      offset: 0
    });
  } else {
    leaf = node.getAttribute("[" + Selector.leaf + "]") ? node : findClosestInContent(node, "[" + Selector.leaf + "]");
  }

  if (!leaf) {
    return null;
  }

  var _keyUtils$parse = keyUtils.parse(leaf.getAttribute(Selector.key) || ''),
      key = _keyUtils$parse[0],
      offset = _keyUtils$parse[1];

  var text = document.getNode(key);

  if (!text) {
    return null;
  } // NOTE: what if user data has just one `CANGJIE_EMPTY` character?


  var nativeText = leaf.textContent && leaf.textContent !== CANGJIE_EMPTY ? leaf.textContent.slice(0, nativeOffset) : '';
  return TextPoint.create({
    key: key,
    offset: offset + nativeText.length
  });
}

/**
 * @packageDocumentation
 * @module domUtils
 */
/**
 * 根据浏览器的 Range 获取仓颉的 Selection
 */

function findRange(_native, controller) {
  var startContainer = _native.startContainer,
      startOffset = _native.startOffset,
      endContainer = _native.endContainer,
      endOffset = _native.endOffset,
      collapsed = _native.collapsed;
  var start = findPoint(startContainer, startOffset, controller);
  var end = collapsed ? start : findPoint(endContainer, endOffset, controller);

  if (!start || !end) {
    return null;
  }

  return Selection.create({
    anchor: start,
    focus: end
  });
}

function _createForOfIteratorHelperLoose$9(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$9(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray$9(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$9(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$9(o, minLen); }

function _arrayLikeToArray$9(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _marked$1 = /*#__PURE__*/_regeneratorRuntime.mark(getSeletableBlocksFromElement),
    _marked2$1 = /*#__PURE__*/_regeneratorRuntime.mark(getRectsFromElement);

var isPointOnLeftOfRect = function isPointOnLeftOfRect(x, _, rect) {
  return x < rect.left;
};

var isPointOnRightOfRect = function isPointOnRightOfRect(x, _, rect) {
  return x > rect.right;
};

var isPointOnTopOfRect = function isPointOnTopOfRect(_, y, rect) {
  return y < rect.top;
};

var isPointOnBottomOfRect = function isPointOnBottomOfRect(_, y, rect) {
  return y > rect.bottom;
};

var isPointHorzInsideRect = function isPointHorzInsideRect(x, _, rect) {
  return x >= rect.left && x <= rect.right;
};

var isPointVertInsideRect = function isPointVertInsideRect(_, y, rect) {
  return y >= rect.top && y <= rect.bottom;
};

var isPointInsideRect = function isPointInsideRect(x, y, rect) {
  return isPointHorzInsideRect(x, y, rect) && isPointVertInsideRect(x, y, rect);
};

var isPointOnRightOfRectNonStrict = function isPointOnRightOfRectNonStrict(x, _, rect) {
  return x > rect.left;
};

var isPointOnLeftOfRectNonStrict = function isPointOnLeftOfRectNonStrict(x, _, rect) {
  return x < rect.right;
}; // 认为是同一行的阈值：重叠部分占矮的高度的百分比（magic number: 上下标的重叠比例）


var SAME_LINE_THRESHOLD = 0.4;
var isRectOnSameLineOfRect = function isRectOnSameLineOfRect(newRect, rect) {
  // 底边对齐
  if (newRect.bottom === rect.bottom) {
    return true;
  } // 无交集


  if (newRect.top > rect.bottom || rect.top > newRect.bottom) {
    return false;
  } // 重叠部分
  // eg. 表情 + 文字：可能是包含 or 部分重叠关系


  var smallerHeight = Math.min(rect.height, newRect.height);
  var overlap = Math.min(newRect.bottom, rect.bottom) - Math.max(newRect.top, rect.top);
  return smallerHeight === 0 || overlap / smallerHeight > SAME_LINE_THRESHOLD;
};
var APPROXIMATE_THEREHOLD = 1e-5; // 近似相等的阈值，误差小于此则认为相等

var approximateEqual = function approximateEqual(a, b) {
  return Math.abs(a - b) < APPROXIMATE_THEREHOLD;
}; // 此类都是非严格判断，只检测同一个方位的边界


var isRectOnLeftOfRect = function isRectOnLeftOfRect(newRect, newContentNode, prevClosestRect) {
  return newRect.left < prevClosestRect.contentRect.left || newRect.left === prevClosestRect.contentRect.left && newContentNode.compareDocumentPosition(prevClosestRect.contentNode) === Node.DOCUMENT_POSITION_FOLLOWING;
};

var isRectOnRightOfRect = function isRectOnRightOfRect(newRect, newContentNode, prevClosestRect) {
  // 某些 win 触屏机下，inline 元素与右侧的空 Text 渲染的位置有重叠，存在细微的误差
  // https://aone.alibaba-inc.com/v2/project/897543/bug/41731721#
  return newRect.right > prevClosestRect.contentRect.right + APPROXIMATE_THEREHOLD || approximateEqual(newRect.right, prevClosestRect.contentRect.right) && newContentNode.compareDocumentPosition(prevClosestRect.contentNode) === Node.DOCUMENT_POSITION_PRECEDING;
};

var isRectOnTopOfRect = function isRectOnTopOfRect(newRect, newContentNode, prevClosestRect) {
  return newRect.top < prevClosestRect.contentRect.top || newRect.top === prevClosestRect.contentRect.top && newContentNode.compareDocumentPosition(prevClosestRect.contentNode) === Node.DOCUMENT_POSITION_FOLLOWING;
};

var isRectOnBottomOfRect = function isRectOnBottomOfRect(newRect, newContentNode, prevClosestRect) {
  return newRect.bottom > prevClosestRect.contentRect.bottom || newRect.top === prevClosestRect.contentRect.bottom && newContentNode.compareDocumentPosition(prevClosestRect.contentNode) === Node.DOCUMENT_POSITION_PRECEDING;
};

var getHorzDistance = function getHorzDistance(x, _, rect) {
  return Math.min(Math.abs(x - rect.left), Math.abs(x - rect.right));
};

function getClosestAncestorWithBiggerHorizontalRect(element) {
  var rect = element.getBoundingClientRect();
  var parent = element.parentElement;

  while (parent) {
    var parentRect = parent.getBoundingClientRect();

    if (parentRect.left < rect.left && parentRect.right > rect.right) {
      return parent;
    }

    parent = parent.getAttribute(Selector.content) ? null : parent.parentElement;
  }

  return null;
}

function getSeletableBlocksFromElement(element) {
  var edgeSelectableAncestor, edgeSelectableDescendants, _i, _Array$from, descendant;

  return _regeneratorRuntime.wrap(function getSeletableBlocksFromElement$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          edgeSelectableAncestor = element.closest("[" + Selector.edgeSelectable + "]");

          if (!edgeSelectableAncestor) {
            _context.next = 4;
            break;
          }

          _context.next = 4;
          return edgeSelectableAncestor;

        case 4:
          edgeSelectableDescendants = element.querySelectorAll("[" + Selector.edgeSelectable + "]");

          if (edgeSelectableDescendants) {
            _context.next = 7;
            break;
          }

          return _context.abrupt("return");

        case 7:
          _i = 0, _Array$from = Array.from(edgeSelectableDescendants);

        case 8:
          if (!(_i < _Array$from.length)) {
            _context.next = 15;
            break;
          }

          descendant = _Array$from[_i];
          _context.next = 12;
          return descendant;

        case 12:
          _i++;
          _context.next = 8;
          break;

        case 15:
        case "end":
          return _context.stop();
      }
    }
  }, _marked$1);
}

function getRectsFromElement(element) {
  var isNonSelect, elementParent, targetElement, cangjieLeafs, i, cangjieLeaf, cangjieVoids, _i2, cangjieVoid;

  return _regeneratorRuntime.wrap(function getRectsFromElement$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          // TODO: 处理点击 content 外元素时的定位逻辑，后续有更好的方案可移除
          isNonSelect = element.getAttribute(Selector.nonSelect);
          elementParent = findClosestInContent(element, "[" + Selector.leafBlock + "]") || element.parentElement || element;
          targetElement = isNonSelect ? elementParent : element;
          cangjieLeafs = targetElement.querySelectorAll("span[" + Selector.leaf + "]");
          i = 0;

        case 5:
          if (!(i < cangjieLeafs.length)) {
            _context2.next = 12;
            break;
          }

          cangjieLeaf = cangjieLeafs[i];
          _context2.next = 9;
          return {
            contentNode: cangjieLeaf,
            contentRects: Array.from(cangjieLeaf.getClientRects())
          };

        case 9:
          i += 1;
          _context2.next = 5;
          break;

        case 12:
          cangjieVoids = targetElement.querySelectorAll("[" + Selector["void"] + "]");
          _i2 = 0;

        case 14:
          if (!(_i2 < cangjieVoids.length)) {
            _context2.next = 21;
            break;
          }

          cangjieVoid = cangjieVoids[_i2];
          _context2.next = 18;
          return {
            contentNode: cangjieVoid,
            contentRects: [cangjieVoid.getBoundingClientRect()]
          };

        case 18:
          _i2 += 1;
          _context2.next = 14;
          break;

        case 21:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2$1);
}

function findClosestRectsInElement(element, x, y) {
  var closestBelow = null;
  var closestLeft = null;
  var closestRight = null;
  var closestTop = null;

  for (var _iterator = _createForOfIteratorHelperLoose$9(getRectsFromElement(element)), _step; !(_step = _iterator()).done;) {
    var rect = _step.value;
    var contentNode = rect.contentNode;

    for (var index = 0; index < rect.contentRects.length; index++) {
      var contentRect = rect.contentRects[index];

      if (!contentRect) {
        continue;
      }

      if (isPointInsideRect(x, y, contentRect)) {
        return {
          exactTarget: contentNode
        };
      }

      if (isPointOnTopOfRect(x, y, contentRect)) {
        var found = false; // 现在左下、正下、右下都算 closestBelow
        // 多个 rect 都符合 closestBelow 条件的时候，需要取我们最需要的那个

        if (!closestBelow) {
          // 之前没有 closestBelow 的时候，没有对比，设置它为 closestBelow
          found = true;
        } else if (isRectOnSameLineOfRect(contentRect, closestBelow.contentRect)) {
          // 之前的 closestBelow 和现在的 rect 处于同一条直线上时
          // 通过检查左右距离确定最终取哪个
          var prevExactBelow = isPointHorzInsideRect(x, y, closestBelow.contentRect);
          var newExactBelow = isPointHorzInsideRect(x, y, contentRect);
          var prevDistance = getHorzDistance(x, y, closestBelow.contentRect);
          var newDistance = getHorzDistance(x, y, contentRect); // 原先处于正下方，就是同行最优先的结果，不用再更新
          // 原先不处于正下方，现在处于正下方，需要更新
          // 两次都不处于正下方，使用距离更短的那个作为最终结果

          if (!prevExactBelow && (newExactBelow || newDistance < prevDistance)) {
            found = true;
          }
        } else if (isRectOnTopOfRect(contentRect, contentNode, closestBelow)) {
          // 之前的 closestBelow 和现在的 rect 不处于同一条直线上时
          // 取位置更高的，即纵向上更靠近的作为 closestBelow
          found = true;
        }

        if (found) {
          closestBelow = {
            contentRect: contentRect,
            contentNode: contentNode
          };
        }
      } else if (isPointOnBottomOfRect(x, y, contentRect)) {
        var _found = false;

        if (!closestTop) {
          _found = true;
        } else if (isRectOnSameLineOfRect(contentRect, closestTop.contentRect)) {
          var prevExactTop = isPointHorzInsideRect(x, y, closestTop.contentRect);
          var newExactTop = isPointHorzInsideRect(x, y, contentRect);

          var _prevDistance = getHorzDistance(x, y, closestTop.contentRect);

          var _newDistance = getHorzDistance(x, y, contentRect);

          if (!prevExactTop && (newExactTop || _newDistance < _prevDistance)) {
            _found = true;
          }
        } else if (isRectOnBottomOfRect(contentRect, contentNode, closestTop)) {
          _found = true;
        }

        if (_found) {
          closestTop = {
            contentRect: contentRect,
            contentNode: contentNode
          };
        }
      } else if (isPointVertInsideRect(x, y, contentRect) && isPointOnRightOfRectNonStrict(x, y, contentRect) && (!closestLeft || isRectOnRightOfRect(contentRect, contentNode, closestLeft))) {
        closestLeft = {
          contentRect: contentRect,
          contentNode: contentNode
        };
      } else if (isPointVertInsideRect(x, y, contentRect) && isPointOnLeftOfRectNonStrict(x, y, contentRect) && (!closestRight || isRectOnLeftOfRect(contentRect, contentNode, closestRight))) {
        closestRight = {
          contentRect: contentRect,
          contentNode: contentNode
        };
      }
    }
  }

  return {
    closestBelow: closestBelow,
    closestLeft: closestLeft,
    closestRight: closestRight,
    closestTop: closestTop
  };
}

function binarySearchOffset(textNode, mouseX, mouseY, rangeStart, rangeEnd, textLength) {
  var range = document.createRange();

  if (rangeEnd - rangeStart > 1) {
    var offset = Math.floor((rangeStart + rangeEnd) / 2);

    try {
      range.setStart(textNode, offset);
      range.setEnd(textNode, Math.max(Math.min(offset, textLength), 0));
    } catch (error) {
      return rangeStart;
    } // getClientBoundingRect不保险，在iOS10下结果不对


    var _rect = range.getClientRects()[0];

    if (!_rect) {
      return rangeStart;
    }

    if (mouseY < _rect.top) {
      return binarySearchOffset(textNode, mouseX, mouseY, rangeStart, offset, textLength);
    }

    if (mouseY > _rect.bottom) {
      return binarySearchOffset(textNode, mouseX, mouseY, offset, rangeEnd, textLength);
    }

    if (mouseX <= _rect.left + _rect.width) {
      return binarySearchOffset(textNode, mouseX, mouseY, rangeStart, offset, textLength);
    }

    return binarySearchOffset(textNode, mouseX, mouseY, offset, rangeEnd, textLength);
  }

  var _textUtils$getCharRan = textUtils.getCharRange(textNode.textContent, rangeStart),
      offsetStart = _textUtils$getCharRan[0],
      offsetEnd = _textUtils$getCharRan[1];

  try {
    range.setStart(textNode, offsetStart);
    range.setEnd(textNode, Math.max(Math.min(offsetEnd, textLength), 0));
  } catch (error) {
    return offsetStart;
  }

  var rangeRects = Array.from(range.getClientRects());
  var rect = rangeRects.find(function (r) {
    return r.width > 0;
  }) || rangeRects[0];

  if (!rect) {
    return offsetStart;
  }

  if (mouseY < rect.top) {
    return offsetStart;
  }

  if (mouseY > rect.bottom) {
    return offsetEnd;
  }

  if (mouseX <= rect.left + rect.width / 2) {
    return offsetStart;
  }

  return offsetEnd;
}

function caretPointFromTargetAndCoord(_ref) {
  var eventTarget = _ref.eventTarget,
      mouseX = _ref.mouseX,
      mouseY = _ref.mouseY,
      adjustedX = _ref.adjustedX,
      adjustedY = _ref.adjustedY;
  var target = eventTarget;
  var x = adjustedX,
      y = adjustedY;

  for (var _iterator2 = _createForOfIteratorHelperLoose$9(getSeletableBlocksFromElement(target)), _step2; !(_step2 = _iterator2()).done;) {
    var _node = _step2.value;

    var rect = _node.getBoundingClientRect();

    var parent = getClosestAncestorWithBiggerHorizontalRect(_node); // 检查 eventTarget 是否在 node 的左侧和右侧

    if (!parent || isPointHorzInsideRect(mouseX, mouseY, rect) || !isPointVertInsideRect(mouseX, mouseY, rect)) {
      continue;
    } // 如果 eventTarget 在父元素内部，才算命中（处理表格等情况）


    var parentRect = parent.getBoundingClientRect();
    var parentStyle = window.getComputedStyle(parent); // 父元素的 margin 也需要计算在内（排版等情况，用的是 margin）

    var parentLeft = parentRect.left - parseInt(parentStyle.marginLeft, 10);
    var parentRight = parentRect.right + parseInt(parentStyle.marginRight, 10);

    if (x >= parentLeft && x <= parentRight) {
      var edge = x > rect.left ? EdgePoint.AFTER : EdgePoint.BEFORE;
      return {
        node: _node,
        edge: edge
      };
    }
  }

  var closestLeftEdge;
  var closestRightEdge;

  if (!findClosestInContent(target, "span[" + Selector.leaf + "]") && !findClosestInContent(target, "[" + Selector["void"] + "]")) {
    var _findClosestRectsInEl = findClosestRectsInElement(target, x, y),
        exactTarget = _findClosestRectsInEl.exactTarget,
        closestBelow = _findClosestRectsInEl.closestBelow,
        closestLeft = _findClosestRectsInEl.closestLeft,
        closestRight = _findClosestRectsInEl.closestRight,
        closestTop = _findClosestRectsInEl.closestTop;

    closestLeftEdge = closestLeft == null ? void 0 : closestLeft.contentRect.right;
    closestRightEdge = closestRight == null ? void 0 : closestRight.contentRect.left;

    if (exactTarget) {
      target = exactTarget;
    } else if (closestBelow && closestLeft) {
      if (isRectOnSameLineOfRect(closestBelow.contentRect, closestLeft.contentRect)) {
        y = closestBelow.contentRect.top;
        target = closestBelow.contentNode;
      } else {
        x = closestLeft.contentRect.right;
        target = closestLeft.contentNode;
      }
    } else if (closestBelow && closestRight) {
      if (isRectOnSameLineOfRect(closestBelow.contentRect, closestRight.contentRect)) {
        y = closestBelow.contentRect.top;
        target = closestBelow.contentNode;
      } else {
        x = closestRight.contentRect.left;
        target = closestRight.contentNode;
      }
    } else if (closestLeft) {
      x = closestLeft.contentRect.right;
      target = closestLeft.contentNode;
    } else if (closestRight) {
      x = closestRight.contentRect.left;
      target = closestRight.contentNode;
    } else if (closestBelow) {
      // 如果不是正下方，是左下方或者右下方
      // 则x坐标需要进行左移或者右移
      if (isPointOnLeftOfRect(x, y, closestBelow.contentRect)) {
        x = closestBelow.contentRect.left;
      } else if (isPointOnRightOfRect(x, y, closestBelow.contentRect)) {
        x = closestBelow.contentRect.right;
      }

      y = closestBelow.contentRect.top;
      target = closestBelow.contentNode;
    } else if (closestTop) {
      if (isPointOnLeftOfRect(x, y, closestTop.contentRect)) {
        x = closestTop.contentRect.left;
      } else if (isPointOnRightOfRect(x, y, closestTop.contentRect)) {
        x = closestTop.contentRect.right;
      }

      y = closestTop.contentRect.bottom;
      target = closestTop.contentNode;
    }
  }

  if (!(target instanceof Element)) {
    return null;
  }

  if (findClosestInContent(target, "[" + Selector["void"] + "]")) {
    var node = findClosestInContent(target, "[" + Selector["void"] + "]");
    var textNode = null;
    var offset = 0;

    if (closestLeftEdge && Math.round(x) === Math.round(closestLeftEdge)) {
      var _node$nextElementSibl, _node$nextElementSibl2;

      var nextTextNode = node == null ? void 0 : (_node$nextElementSibl = node.nextElementSibling) == null ? void 0 : (_node$nextElementSibl2 = _node$nextElementSibl.querySelector("span[" + Selector.leaf + "]")) == null ? void 0 : _node$nextElementSibl2.firstChild;
      textNode = nextTextNode instanceof Text ? nextTextNode : null;
    } else if (closestRightEdge && Math.round(x) === Math.round(closestRightEdge)) {
      var _node$previousElement, _node$previousElement2, _textNode, _textNode$textContent;

      var _nextTextNode = node == null ? void 0 : (_node$previousElement = node.previousElementSibling) == null ? void 0 : (_node$previousElement2 = _node$previousElement.querySelector("span[" + Selector.leaf + "]")) == null ? void 0 : _node$previousElement2.firstChild;

      textNode = _nextTextNode instanceof Text ? _nextTextNode : null;
      offset = ((_textNode = textNode) == null ? void 0 : (_textNode$textContent = _textNode.textContent) == null ? void 0 : _textNode$textContent.length) || 0;
    }

    return {
      node: textNode || node,
      offset: offset
    };
  }

  if (findClosestInContent(target, "span[" + Selector.leaf + "]")) {
    var leafContent = target.getAttribute(Selector.leaf) ? target : target.querySelector("span[" + Selector.leaf + "]");

    var _textNode2 = leafContent && leafContent.firstChild;

    if (_textNode2 instanceof Text && _textNode2.textContent === CANGJIE_EMPTY) {
      return {
        node: _textNode2,
        offset: 0
      };
    }

    if (_textNode2 instanceof Text && _textNode2.textContent) {
      var _offset = binarySearchOffset(_textNode2, x, y, 0, _textNode2.textContent.length, _textNode2.textContent.length);

      return {
        node: _textNode2,
        offset: _offset
      };
    }

    return null;
  }

  return null;
}

function caretRangeFromTargetAndCoord(eventTarget, mouseX, mouseY, controller) {
  var target = eventTarget;

  if (target instanceof Text) {
    target = target.parentNode;
  } else if (target.shadowRoot) {
    target = target.shadowRoot.querySelector("[" + Selector.content + "]");
  }

  if (!target || !(target instanceof Element)) {
    return null;
  }

  var x = mouseX,
      y = mouseY;

  if (target.getAttribute(Selector.content)) {
    var editable = target.querySelector("[" + Selector.editable + "]");

    if (editable) {
      var editableRect = editable.getBoundingClientRect();

      if (x < editableRect.left) {
        x = editableRect.left;
      } else if (x > editableRect.right) {
        x = editableRect.right - 1;
      }

      if (y < editableRect.top) {
        y = editableRect.top;
      } else if (y > editableRect.bottom) {
        y = editableRect.bottom - 1;
      } // ref: https://developer.mozilla.org/en-US/docs/Web/API/Node/getRootNode


      var root = target.getRootNode();
      var adjustedTarget = typeof root.elementFromPoint === 'function' ? root.elementFromPoint(x, y) : null;

      if (adjustedTarget) {
        target = adjustedTarget;
      }
    }
  }

  var point = caretPointFromTargetAndCoord({
    eventTarget: target,
    adjustedX: x,
    adjustedY: y,
    mouseX: mouseX,
    mouseY: mouseY
  });

  if (!point || !point.node) {
    return null;
  }

  var nodeKey = point.node instanceof Element ? point.node.getAttribute(Selector.key) : null;

  if (point.edge && nodeKey) {
    var pointProperties = {
      key: nodeKey,
      edge: point.edge
    };
    var anchor = Point.create(pointProperties);
    return Selection.create({
      anchor: anchor,
      focus: anchor
    });
  }

  var _native = document.createRange();

  try {
    _native.setStart(point.node, point.offset);

    _native.setEnd(point.node, Math.max(point.offset, 0));
  } catch (error) {
    return null;
  }

  return _native && findRange(_native, controller);
}

var ROOT_TO_CONTROLLER = new WeakMap();
var CONTROLLER_TO_KEY_DOM = new WeakMap();

function getElementByCangjieKey(key, root) {
  var KEY_DOM;
  var controller = ROOT_TO_CONTROLLER.get(root);

  if (controller) {
    if (!CONTROLLER_TO_KEY_DOM.has(controller)) {
      CONTROLLER_TO_KEY_DOM.set(controller, new Map());
    }

    KEY_DOM = CONTROLLER_TO_KEY_DOM.get(controller);
  }

  if (KEY_DOM && KEY_DOM.has(key)) {
    return KEY_DOM.get(key);
  }

  if (root instanceof Element && key === root.getAttribute(Selector.key)) {
    return root;
  }

  return root.querySelector("[" + Selector.key + "=\"" + key + "\"]");
}

/**
 * @packageDocumentation
 * @module domUtils
 */
/**
 * 根据节点的 key 查找对应的 DOM 节点。如果找不到，就返回 null
 */

function findDOMNodeSafely(key, root) {
  if (root === void 0) {
    root = window;
  }

  var node = root !== window ? getElementByCangjieKey(key, root) : getElementByCangjieKey(key, root.document);
  return node || undefined;
}
/**
 * 根据节点的 key 查找对应的 DOM 节点。如果找不到，就 throw error。
 * 类似的 API：domUtils.findDOMNodeSafely
 */

function findDOMNode(key, root) {
  if (root === void 0) {
    root = window;
  }

  var node = findDOMNodeSafely(key, root);

  if (!node) {
    throw new Error("Unable to find a DOM node for \"" + key + "\". This is often because of forgetting to add `props.attributes` to a custom component.");
  }

  return node;
}

function findDOMLeaves(key, root) {
  if (root === void 0) {
    root = window;
  }

  var element = root instanceof Element ? root : root.document;
  var firstLeaf = getElementByCangjieKey(key + ":0", element);
  var leafBlock = firstLeaf == null ? void 0 : firstLeaf.closest("[" + Selector.leafBlock + "]");
  return leafBlock ? Array.from(leafBlock.querySelectorAll("[" + Selector.key + "^=\"" + key + ":\"]")) : [];
}

function _createForOfIteratorHelperLoose$8(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$8(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray$8(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$8(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$8(o, minLen); }

function _arrayLikeToArray$8(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * 根据 Point 来获取浏览器的 HTML 节点、offset。
 */

function findDOMPoint(point, root) {
  if (root === void 0) {
    root = window;
  }

  var leaves = findDOMLeaves(point.key, root);
  var start = 0; // eslint-disable-next-line no-restricted-syntax

  for (var _iterator = _createForOfIteratorHelperLoose$8(leaves), _step; !(_step = _iterator()).done;) {
    var leaf = _step.value;
    var node = leaf.firstChild;
    var length = node && node.textContent ? node.textContent.length : 0;
    var end = start + length;

    if (point.offset <= end) {
      var offset = point.offset - start;
      return {
        node: node,
        offset: offset
      };
    }

    start = end;
  }

  return null;
}

/* eslint-disable react/no-find-dom-node */
/**
 * 根据仓颉的 RangeSelection 获取浏览器的 Range。
 */

function findDOMRange(range, controller, root) {
  if (root === void 0) {
    root = window;
  }

  var document = controller.value.document;
  var isCollapsed = range.isCollapsed;

  var _range$convertToTextP = range.convertToTextPoints(document),
      start = _range$convertToTextP.start,
      end = _range$convertToTextP.end; // @ts-ignore


  var r = ('document' in root ? root.document : root.ownerDocument).createRange();
  var domStart = findDOMPoint(start, root);
  var domEnd = isCollapsed ? domStart : findDOMPoint(end, root); // 查找 Range 时，首先查找文字选区，若文字选区不存在，则判断是否存在 void 选区

  try {
    if (domStart && domStart.node) {
      r.setStart(domStart.node, domStart.offset);
    } else {
      var startVoidNode = document.getClosestVoid(start.key, controller);

      if (startVoidNode) {
        var domNode = findDOMNode(startVoidNode.key, root);
        r.setStartBefore(domNode);
      } else {
        return null;
      }
    }

    if (domEnd && domEnd.node) {
      r.setEnd(domEnd.node, domEnd.offset);
    } else {
      var endVoidNode = document.getClosestVoid(end.key, controller);

      if (endVoidNode) {
        var _domNode = findDOMNode(endVoidNode.key, root);

        r.setEndAfter(_domNode);
      } else {
        return null;
      }
    }
  } catch (error) {
    console.error(error);
    return null;
  }

  return r;
}

/**
 * @packageDocumentation
 * @ignore
 */
function getAroundRects(point) {
  if (!point.isTextPoint()) {
    return [];
  }

  var prevPoint = point.moveBackward();
  var nextPoint = point.moveForward();

  if (prevPoint.offset < 0) {
    return [];
  }

  var domPoint = null;
  var prevDomPoint = null;
  var nextDomPoint = null;

  try {
    domPoint = findDOMPoint(point);
    prevDomPoint = findDOMPoint(prevPoint);
    nextDomPoint = findDOMPoint(nextPoint);
  } catch (error) {// ignore
  }

  if (!domPoint || !domPoint.node || !prevDomPoint || !prevDomPoint.node || !nextDomPoint || !nextDomPoint.node) {
    return [];
  }

  var firstRange = window.document.createRange();
  var secondRange = window.document.createRange();

  try {
    firstRange.setStart(prevDomPoint.node, prevDomPoint.offset);
    firstRange.setEnd(domPoint.node, domPoint.offset);
    secondRange.setStart(domPoint.node, domPoint.offset);
    secondRange.setEnd(nextDomPoint.node, nextDomPoint.offset);
  } catch (error) {
    return [];
  }

  var firstRects = Array.from(firstRange.getClientRects()).filter(function (r) {
    return r.width > 0;
  });
  var secondRects = Array.from(secondRange.getClientRects()).filter(function (r) {
    return r.width > 0;
  });
  var firstRect = firstRects[firstRects.length - 1];
  var secondRect = secondRects[0];
  return [firstRect, secondRect];
}
function findRectsInEdgePoint(point) {
  var _getAroundRects = getAroundRects(point),
      firstRect = _getAroundRects[0],
      secondRect = _getAroundRects[1];

  if (!firstRect || !secondRect || typeof DOMRect === 'undefined') {
    return [];
  }

  return [new DOMRect(firstRect.right, firstRect.top, 0, firstRect.height), new DOMRect(secondRect.left, secondRect.top, 0, secondRect.height)];
}
function isPointAtEdge(point) {
  var _getAroundRects2 = getAroundRects(point),
      firstRect = _getAroundRects2[0],
      secondRect = _getAroundRects2[1];

  if (!firstRect || !secondRect) {
    return false;
  }
  /**
   * The comparsion was secondRect.left < firstRect.right, but it's 0.xx px
   * incorrect for adjusting bold mark.
   */


  return secondRect.left < firstRect.left;
}

/**
 * @packageDocumentation
 * @ignore
 */
function findRectFromPoint(point, isHanging, controller) {
  var _document$getNode;

  if (!point.isTextPoint()) {
    // eslint-disable-next-line react/no-find-dom-node
    var node = findDOMNode(point.key);
    return node.getBoundingClientRect();
  }

  var document = controller.value.document;
  var text = (_document$getNode = document.getNode(point.key)) == null ? void 0 : _document$getNode.text;
  var isAfterNewLine = text && text[point.offset - 1] === '\n';
  var isAtEdge = isPointAtEdge(point);

  if (isAtEdge) {
    var edgeRects = findRectsInEdgePoint(point);
    return isHanging ? edgeRects[edgeRects.length - 1] : edgeRects[0];
  }

  var domRange = findDOMRange(Selection.create({
    anchor: point,
    focus: point
  }), controller);

  if (!domRange) {
    return null;
  }

  var rangeRects = domRange.getClientRects(); // choose last rect when the point is hanging or after \n

  return isHanging || isAfterNewLine ? rangeRects[rangeRects.length - 1] : rangeRects[0];
}

var cache = new WeakMap();
var cacheLocalCaret = function cacheLocalCaret(controller, position, wrapper) {
  cache.set(controller, {
    caret: position,
    wrapper: wrapper
  });
};
var getLocalCaretPos = function getLocalCaretPos(controller) {
  var _cache$get;

  return (_cache$get = cache.get(controller)) == null ? void 0 : _cache$get.caret;
};
var getLocalCaretPosDetail = function getLocalCaretPosDetail(controller) {
  return cache.get(controller);
};

/**
 * @packageDocumentation
 * @ignore
 */
/**
 * 从 from 垂直变到 to 点时，新的点是否为 isHanging
 * @param from 起始 Point
 * @param to 目标 Point
 * @returns isHanging
 */

function shouldBeHangingByVertically(from, to, controller) {
  if (to.isEdgePoint()) {
    return false;
  }

  var _getAroundRects = getAroundRects(to),
      firstRect = _getAroundRects[0],
      secondRect = _getAroundRects[1];

  if (!firstRect || !secondRect) {
    return false;
  }

  if (from.isEdgePoint()) {
    return secondRect.left < firstRect.left && from.edge === EdgePoint.BEFORE;
  }

  var fromPos = getLocalCaretPos(controller);

  if (!fromPos || secondRect.left >= firstRect.left) {
    return false;
  } // to 在边界点上，且起点更靠近 secondRect.left 时，应为 isHanging


  return fromPos.left - secondRect.left < firstRect.right - fromPos.left;
}
function isCoordAtLeftSide(clientX, controller) {
  var document = controller.value.document; // eslint-disable-next-line react/no-find-dom-node

  var articleDom = findDOMNode(document.key);

  if (!articleDom) {
    return false;
  }

  var rect = articleDom.getBoundingClientRect();
  return clientX < rect.left + rect.width / 2;
}

function _createForOfIteratorHelperLoose$7(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$7(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray$7(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$7(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen); }

function _arrayLikeToArray$7(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _marked = /*#__PURE__*/_regeneratorRuntime.mark(iterateTextNodesFromPoint),
    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(iteratePositionsFromPoint);

/**
 *
 * move point out of inline IF it's located at inline edges
 *
 * Optimizition for non-void inlines (e.g. <Link> elements) for better experience
 *
 * Before: <link>[anchor]www.dingtalk.com[focus]</link>
 * After: [anchor]<link>www.dingtalk.com</link>[focus]
 */
var correctPointInsideInlineOrBlock = function correctPointInsideInlineOrBlock(controller, point) {
  var document = controller.value.document;
  var parent = document.getClosestInline(point.key);

  if (!parent || controller.query('isVoid', parent) || controller.query('isInlineBlock', parent)) {
    return point;
  }

  if (point.offset === 0) {
    var textNode = document.getPreviousText(point.key);

    if (textNode) {
      var key = textNode.key;
      var offset = textNode.text.length;
      return TextPoint.create({
        key: key,
        offset: offset
      });
    }
  } else if (point.offset === parent.text.length) {
    var _textNode = document.getNextText(point.key);

    if (_textNode) {
      var _key = _textNode.key;
      var _offset = 0;
      return TextPoint.create({
        key: _key,
        offset: _offset
      });
    }
  }

  return point;
};

function iterateTextNodesFromPoint(document, at, reverse) {
  var atNode, next, startText, goDeep, node;
  return _regeneratorRuntime.wrap(function iterateTextNodesFromPoint$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          atNode = document.getNode(at.key);

          if (atNode) {
            _context.next = 3;
            break;
          }

          return _context.abrupt("return");

        case 3:
          if (!atNode.isText()) {
            _context.next = 6;
            break;
          }

          _context.next = 6;
          return atNode;

        case 6:
          next = function next(key) {
            return reverse ? document.getPreviousText(key) : document.getNextText(key);
          };

          startText = function startText(element) {
            return reverse ? element.getLastText() : element.getFirstText();
          };

          goDeep = at.isEdgePoint() && (at.edge === EdgePoint.BEFORE && !reverse || at.edge === EdgePoint.AFTER && reverse);
          node = goDeep && atNode.isElement() ? startText(atNode) : next(atNode.key);

        case 10:
          if (!node) {
            _context.next = 16;
            break;
          }

          _context.next = 13;
          return node;

        case 13:
          node = next(node.key);
          _context.next = 10;
          break;

        case 16:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

function iteratePositionsFromPoint(controller, at, unit, reverse) {
  var document, step, shouldCountStartPoint, lastBlock, offset, getEdgePoint, _iterator, _step, node, text, key, closestBlock, nodePoint;

  return _regeneratorRuntime.wrap(function iteratePositionsFromPoint$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          getEdgePoint = function _getEdgePoint(nodeKey, isAtEntrance) {
            var _edgeText;

            var closestBlock = document.getClosestSelectableBlock(nodeKey, controller);

            if (!closestBlock) {
              return null;
            }

            var firstText = closestBlock.getFirstText();
            var lastText = closestBlock.getLastText();
            var edgeText = firstText;

            if (isAtEntrance) {
              // alway skip the entrance WHEN started at a selectable inside node
              if (closestBlock.getNode(at.key)) {
                return null;
              }

              edgeText = reverse ? lastText : firstText;
            } else {
              edgeText = reverse ? firstText : lastText;
            }

            var isTextAtEdge = ((_edgeText = edgeText) == null ? void 0 : _edgeText.key) === nodeKey;

            if (!isTextAtEdge) {
              return null;
            }

            var key = closestBlock.key;
            var edge = reverse && isAtEntrance || !reverse && !isAtEntrance ? EdgePoint.AFTER : EdgePoint.BEFORE;
            return {
              key: key,
              edge: edge
            };
          };

          document = controller.value.document;

          step = function step(t, o) {
            if (unit === 'offset') {
              var nextCharStep = textUtils.getCharOffset(t, o, reverse);
              return nextCharStep || 1;
            }

            var count = textUtils.getMoveWordOffset(t, o, reverse);
            return Math.max(count, 1);
          }; // We ignore the start point by default, since the start point is the same
          // point as the end point of the previous text


          shouldCountStartPoint = false;
          lastBlock = document.getClosestBlock(at.key);
          offset = 0;
          _iterator = _createForOfIteratorHelperLoose$7(iterateTextNodesFromPoint(document, at, reverse));

        case 7:
          if ((_step = _iterator()).done) {
            _context2.next = 36;
            break;
          }

          node = _step.value;
          text = node.text, key = node.key;
          closestBlock = document.getClosestBlock(key);
          nodePoint = getEdgePoint(key, true);

          if (!nodePoint) {
            _context2.next = 15;
            break;
          }

          _context2.next = 15;
          return nodePoint;

        case 15:
          if (!document.getClosestVoid(node.key, controller)) {
            _context2.next = 22;
            break;
          }

          nodePoint = getEdgePoint(key, false);

          if (!nodePoint) {
            _context2.next = 20;
            break;
          }

          _context2.next = 20;
          return nodePoint;

        case 20:
          shouldCountStartPoint = true;
          return _context2.abrupt("continue", 34);

        case 22:
          // it's another block, count the next start point
          if (lastBlock !== closestBlock) {
            lastBlock = closestBlock;
            shouldCountStartPoint = true;
          } // calculate the start point (offset)


          if (at.isTextPoint() && node.key === at.key) {
            // special case: first text
            offset = reverse ? at.offset - step(text, at.offset) : at.offset + step(text, at.offset);
          } else if (shouldCountStartPoint) {
            // special case: count the start point
            offset = reverse ? text.length : 0;
            shouldCountStartPoint = false;
          } else {
            offset = reverse ? text.length - step(text, text.length) : step(text, 0);
          } // now iterate the text node


        case 24:
          if (!(offset <= text.length && offset >= 0)) {
            _context2.next = 30;
            break;
          }

          _context2.next = 27;
          return {
            key: key,
            offset: offset
          };

        case 27:
          reverse ? offset -= step(text, offset) : offset += step(text, offset);
          _context2.next = 24;
          break;

        case 30:
          nodePoint = getEdgePoint(key, false);

          if (!nodePoint) {
            _context2.next = 34;
            break;
          }

          _context2.next = 34;
          return nodePoint;

        case 34:
          _context2.next = 7;
          break;

        case 36:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2);
}

function pointAtDistance(controller, at, distance, unit) {
  if (distance === void 0) {
    distance = 1;
  }

  if (unit === void 0) {
    unit = 'offset';
  }

  var document = controller.value.document;
  var reverse = distance < 0;
  var remaining = Math.abs(distance);

  if (unit === 'word' && at.isEdgePoint()) {
    var key = at.key;

    if (reverse && at.edge === EdgePoint.AFTER) {
      return EdgePoint.create({
        key: key,
        edge: EdgePoint.BEFORE
      });
    }

    if (!reverse && at.edge === EdgePoint.BEFORE) {
      return EdgePoint.create({
        key: key,
        edge: EdgePoint.AFTER
      });
    }
  }

  for (var _iterator2 = _createForOfIteratorHelperLoose$7(iteratePositionsFromPoint(controller, at, unit, reverse)), _step2; !(_step2 = _iterator2()).done;) {
    var pt = _step2.value;
    remaining -= 1;

    if (remaining <= 0) {
      return Point.create(pt);
    }
  }

  return controller.query(pointAtNodeEdge, document, reverse ? 'start' : 'end');
}
function pointAtStartOfNode(controller, node) {
  return controller.query(pointAtNodeEdge, node, 'start');
}
function pointAtEndOfNode(controller, node) {
  return controller.query(pointAtNodeEdge, node, 'end');
}

function pointAtNodeEdge(controller, node, where) {
  var document = controller.value.document;
  var targetNode = where === 'start' ? node.getFirstNode() : node.getLastNode(); // 获取 node 下距离 targetNode 最远的可 edgeSelectable 的 block 节点

  var furthestBlock = document.getFurthestSelectableBlock(targetNode.key, node.key, controller); // 若存在 furthestBlock 则返回该 block 的 edge point

  if (furthestBlock) {
    var _key2 = furthestBlock.key;
    var edge = where === 'start' ? EdgePoint.BEFORE : EdgePoint.AFTER;
    return EdgePoint.create({
      key: _key2,
      edge: edge
    });
  } // 否则返回 targetNode 内 的 text point


  var key = targetNode.key;
  var offset = where === 'start' ? 0 : targetNode.text.length;
  return TextPoint.create({
    key: key,
    offset: offset
  });
}

function getTrueRectFromPoint(controller, point, isHanging) {
  var document = controller.value.document;
  var node = document.assertNode(point.key);
  var closestVoid = controller.query('isVoid', node) ? node : document.getClosestVoid(point.key, controller);
  var rangeRect = null;

  if (closestVoid) {
    rangeRect = findDOMNode(closestVoid.key).getBoundingClientRect();
  } else {
    rangeRect = findRectFromPoint(point, isHanging, controller);
  }

  if (!rangeRect) {
    return null;
  }

  return rangeRect;
}

function getUpsidePoint(controller, point, isHanging, lockedX) {
  var value = controller.value;
  var document = value.document;
  var rangeRect = getTrueRectFromPoint(controller, point, isHanging);

  if (!rangeRect) {
    return null;
  }

  var rectX = point.isEdgePoint() && point.edge === EdgePoint.AFTER ? rangeRect.right : rangeRect.left;
  var x = typeof lockedX === 'number' ? lockedX : rectX;
  var y = rangeRect.top;
  var currentBlock = document.getClosestBlockFromPoint(point.key);
  var currentBlockDOM = null;
  var currentLeafDOMs;
  var found = false;

  while (!found) {
    if (!currentBlock) {
      return null;
    }

    var closestBlock = document.getClosestSelectableBlock(currentBlock.key, controller);

    if (closestBlock && closestBlock.key !== point.key && !closestBlock.getNode(point.key)) {
      var key = closestBlock.key;
      var edge = isCoordAtLeftSide(x, controller) ? EdgePoint.BEFORE : EdgePoint.AFTER;
      return EdgePoint.create({
        key: key,
        edge: edge
      });
    }

    try {
      currentBlockDOM = findDOMNode(currentBlock.key, window);
    } catch (e) {
      currentBlock = document.getPreviousBlock(currentBlock.key);
      continue;
    }

    currentLeafDOMs = Array.from(currentBlockDOM.querySelectorAll("span[" + Selector.leaf + "]")).reverse(); // eslint-disable-next-line no-restricted-syntax

    for (var _iterator3 = _createForOfIteratorHelperLoose$7(currentLeafDOMs), _step3; !(_step3 = _iterator3()).done;) {
      var leafDOM = _step3.value;

      if (found) {
        break;
      }

      var blockRects = Array.from(leafDOM.getClientRects()).filter(function (rect) {
        return rect.height > 0;
      });
      var blockRectsLength = blockRects.length; // eslint-disable-next-line no-plusplus

      for (var i = blockRectsLength - 1; i >= 0; i--) {
        var blockRect = blockRects[i];

        if (blockRect.bottom <= y) {
          found = true;
          y = blockRect.bottom - blockRect.height / 2;
          break;
        }
      }
    }

    currentBlock = document.getPreviousBlock(currentBlock.key);
  }

  var range = currentBlockDOM && caretRangeFromTargetAndCoord(currentBlockDOM, x, y, controller);

  if (!range) {
    return null;
  }

  return range.anchor;
}
function getUpsideRange(controller) {
  var value = controller.value;
  var document = value.document,
      selection = value.selection;

  if (!selection) {
    return null;
  }

  var start = selection.getStart(document);
  var isHanging = selection.isHanging;
  var point = getUpsidePoint(controller, start, isHanging);

  if (!point) {
    return selection.moveToStartOfDocument(controller);
  }

  var nextIsHanging = shouldBeHangingByVertically(start, point, controller);
  var newRange = selection.moveAnchorTo(point.key, point.isEdgePoint() ? point.edge : point.offset).moveToAnchor().setHanging(nextIsHanging);
  return newRange;
}
function getDownsidePoint(controller, point, isHanging, lockedX) {
  var value = controller.value;
  var document = value.document;
  var rangeRect = getTrueRectFromPoint(controller, point, isHanging);

  if (!rangeRect) {
    return null;
  }

  var rectX = point.isEdgePoint() && point.edge === EdgePoint.AFTER ? rangeRect.right : rangeRect.left;
  var x = typeof lockedX === 'number' ? lockedX : rectX;
  var y = rangeRect.bottom;
  var currentBlock = document.getClosestBlockFromPoint(point.key);
  var currentBlockDOM = null;
  var currentLeafDOMs;
  var found = false;

  while (!found) {
    if (!currentBlock) {
      return null;
    }

    var closestBlock = document.getClosestSelectableBlock(currentBlock.key, controller);

    if (closestBlock && closestBlock.key !== point.key && !closestBlock.getNode(point.key)) {
      var key = closestBlock.key;
      var edge = isCoordAtLeftSide(x, controller) ? EdgePoint.BEFORE : EdgePoint.AFTER;
      return EdgePoint.create({
        key: key,
        edge: edge
      });
    }

    try {
      currentBlockDOM = findDOMNode(currentBlock.key, window);
    } catch (e) {
      currentBlock = document.getNextBlock(currentBlock.key);
      continue;
    }

    currentLeafDOMs = Array.from(currentBlockDOM.querySelectorAll("span[" + Selector.leaf + "]")); // eslint-disable-next-line no-restricted-syntax

    for (var _iterator4 = _createForOfIteratorHelperLoose$7(currentLeafDOMs), _step4; !(_step4 = _iterator4()).done;) {
      var leafDOM = _step4.value;

      if (found) {
        break;
      }

      var blockRects = Array.from(leafDOM.getClientRects()).filter(function (rect) {
        return rect.height > 0;
      });
      var blockRectsLength = blockRects.length; // eslint-disable-next-line no-plusplus

      for (var i = 0; i <= blockRectsLength - 1; i++) {
        var blockRect = blockRects[i];

        if (blockRect.top >= y) {
          found = true;
          y = blockRect.top + blockRect.height / 2;
          break;
        }
      }
    }

    currentBlock = document.getNextBlock(currentBlock.key);
  }

  var range = currentBlockDOM && caretRangeFromTargetAndCoord(currentBlockDOM, x, y, controller);

  if (!range) {
    return null;
  }

  return range.anchor;
}
function getDownsideRange(controller) {
  var value = controller.value;
  var document = value.document,
      selection = value.selection;

  if (!selection) {
    return null;
  }

  var start = selection.getStart(document);
  var isHanging = selection.isHanging;
  var point = getDownsidePoint(controller, start, isHanging);

  if (!point) {
    return selection.moveToEndOfDocument(controller);
  }

  var nextIsHanging = shouldBeHangingByVertically(start, point, controller);
  var newRange = selection.moveAnchorTo(point.key, point.isEdgePoint() ? point.edge : point.offset).moveToAnchor().setHanging(nextIsHanging);
  return newRange;
}

var SelectionTrigger;

(function (SelectionTrigger) {
  SelectionTrigger["Selecting"] = "selecting";
  SelectionTrigger["SelectStart"] = "selectStart";
  SelectionTrigger["SelectAll"] = "selectAll";
  SelectionTrigger["MoveUpward"] = "moveUpward";
  SelectionTrigger["MoveDownward"] = "moveDownward";
  SelectionTrigger["MoveBackward"] = "moveBackward";
  SelectionTrigger["MoveForward"] = "moveForward";
  SelectionTrigger["MultipleClick"] = "multipleClick";
})(SelectionTrigger || (SelectionTrigger = {}));

var IS_COLLAPSED_CACHE = new WeakMap();
var IS_FORWARD_CACHE = new WeakMap();

var Selection = /*#__PURE__*/function (_ImmutableRecord) {
  _inheritsLoose(Selection, _ImmutableRecord);

  Selection.create = function create(props) {
    if (Selection.isSelection(props)) {
      return props;
    }

    if (isPlainObject(props)) {
      var _props$data = props.data,
          data = _props$data === void 0 ? {} : _props$data,
          anchor = props.anchor,
          focus = props.focus,
          marks = props.marks;
      return new Selection({
        data: data,
        anchor: Point.create(anchor),
        focus: Point.create(focus),
        marks: marks ? marks.map(function (mark) {
          return Mark.create(mark);
        }) : null
      });
    }

    throw new Error("`Selection.create` only accepts objects or range selections, but you passed it: " + props);
  }
  /**
   * 调整range的开始位置和结束位置，使其"收缩"到最小的位置， 如果ignoreEnd的值为true，则忽略对结束位置的调整
   * @param document
   * @param ignoreEnd 如果ignoreEnd的值为true，则忽略对结束位置的调整
   * @example
   * before:1234<anchor/><link>56<focus/>78</link>90
   * after:1234<link><anchor/>56<focus/>78</link>90
   */
  ;

  var _proto = Selection.prototype;

  _proto.shrinkBoundary = function shrinkBoundary(document, ignoreEnd) {
    var start = this.getStart(document);
    var end = this.getEnd(document);

    if (!start.isTextPoint() || !end.isTextPoint()) {
      return this;
    }

    var isForward = this.isForward(document);
    var targetRange = this;

    if (!ignoreEnd && end.offset === 0) {
      var targetEndText = document.getPreviousText(end.key);

      if (targetEndText) {
        targetRange = targetRange.set(isForward ? 'focus' : 'anchor', TextPoint.fromJSON({
          key: targetEndText.key,
          offset: targetEndText.text.length
        }));
      }
    }

    var beforeStartText = document.getNode(start.key);

    if (beforeStartText && start.offset === beforeStartText.text.length) {
      var targetStartText = document.getNextText(start.key);

      if (targetStartText) {
        targetRange = targetRange.set(isForward ? 'anchor' : 'focus', Point.fromJSON({
          key: targetStartText.key,
          offset: 0
        }));
      }
    }

    return targetRange;
  };

  Selection.fromJSON = function fromJSON(json) {
    var data = json.data,
        anchor = json.anchor,
        focus = json.focus,
        marks = json.marks;
    return Selection.create({
      data: data,
      anchor: Point.fromJSON(anchor),
      focus: Point.fromJSON(focus),
      marks: marks ? marks.map(function (mark) {
        return Mark.fromJSON(mark);
      }) : null
    });
  };

  Selection.isSelection = function isSelection(maybeSelection) {
    return maybeSelection instanceof Selection;
  };

  Selection.isRangeSelection = function isRangeSelection(maybeSelection) {
    return Selection.isSelection(maybeSelection);
  };

  Selection.isValidSelection = function isValidSelection(document, selection) {
    if (!Selection.isSelection(selection)) {
      return false;
    }

    var anchor = selection.anchor,
        focus = selection.focus;
    var anchorNode = document.getNode(anchor.key);
    var focusNode = document.getNode(focus.key);

    if (!anchorNode || !focusNode) {
      return false;
    }

    var isAnchorValid = anchor.isTextPoint() && anchor.offset >= 0 && anchor.offset <= anchorNode.text.length || anchor.isEdgePoint();
    var isFocusValid = focus.isTextPoint() && focus.offset >= 0 && focus.offset <= focusNode.text.length || focus.isEdgePoint();
    return isAnchorValid && isFocusValid;
  };

  Selection.isValidRangeSelection = function isValidRangeSelection(document, selection) {
    return Selection.isValidSelection(document, selection);
  };

  Selection.selectWordAtPoint = function selectWordAtPoint(document, point) {
    if (point.isEdgePoint()) {
      return Selection.create({
        anchor: point.set('edge', EdgePoint.BEFORE),
        focus: point.set('edge', EdgePoint.AFTER)
      });
    }

    var text = document.getNode(point.key);

    if (!text) {
      return null;
    }

    var _textUtils$getWordRan = textUtils.getWordRange(text.text, point.offset),
        start = _textUtils$getWordRan[0],
        end = _textUtils$getWordRan[1];

    return Selection.create({
      anchor: point.set('offset', start),
      focus: point.set('offset', end)
    });
  };

  Selection.isEqual = function isEqual(rangSelection, target) {
    return equal(rangSelection.anchor, target.anchor) && equal(rangSelection.focus, target.focus);
  };

  function Selection(props) {
    var _this;

    _this = _ImmutableRecord.call(this) || this;
    _this.data = void 0;
    _this.anchor = void 0;
    _this.focus = void 0;
    _this.marks = void 0;
    var data = props.data,
        anchor = props.anchor,
        focus = props.focus,
        _props$marks = props.marks,
        marks = _props$marks === void 0 ? null : _props$marks;
    _this.data = data;
    _this.anchor = anchor;
    _this.focus = focus;
    _this.marks = marks;

    _this.freeze();

    return _this;
  }
  /**
   * 选区是否指向同一个位置（caret）
   */


  _proto.merge = function merge(props) {
    return new Selection(_extends({
      data: this.data,
      anchor: this.anchor,
      focus: this.focus,
      marks: this.marks
    }, props));
  };

  _proto.set = function set(key, value) {
    var _this$merge;

    return this.merge((_this$merge = {}, _this$merge[key] = value, _this$merge));
  };

  _proto.isForwardInDocument = function isForwardInDocument(document) {
    var anchor = this.anchor,
        focus = this.focus; // same node

    if (anchor.key === focus.key) {
      if (anchor.isEdgePoint()) {
        return anchor.edge === EdgePoint.BEFORE;
      }

      if (focus.isEdgePoint()) {
        return focus.edge === EdgePoint.AFTER;
      }

      return anchor.offset <= focus.offset;
    } // parent-child


    if (anchor.isEdgePoint()) {
      var anchorNode = document.getNode(anchor.key);

      if (anchorNode != null && anchorNode.isElement() && anchorNode.getNode(focus.key)) {
        return anchor.edge === EdgePoint.BEFORE;
      }
    }

    if (focus.isEdgePoint()) {
      var focusNode = document.getNode(focus.key);

      if (focusNode != null && focusNode.isElement() && focusNode.getNode(anchor.key)) {
        return focus.edge === EdgePoint.AFTER;
      }
    } // other relationship


    var anchorPath = anchor.getPathIn(document);
    var focusPath = focus.getPathIn(document);
    return Boolean(anchorPath && focusPath && Path.isBefore(anchorPath, focusPath));
  }
  /**
   * 选区是不是正序的（anchor在前，focus在后）
   */
  ;

  _proto.isForward = function isForward(document) {
    if (!IS_FORWARD_CACHE.has(this)) {
      IS_FORWARD_CACHE.set(this, new WeakMap());
    }

    var DOCUMENT_TO_IS_FORWARD_CACHE = IS_FORWARD_CACHE.get(this);

    if (!DOCUMENT_TO_IS_FORWARD_CACHE.has(document)) {
      DOCUMENT_TO_IS_FORWARD_CACHE.set(document, this.isForwardInDocument(document));
    }

    return DOCUMENT_TO_IS_FORWARD_CACHE.get(document);
  }
  /**
   * 选区是不是倒序的（anchor在后，focus在前）
   */
  ;

  _proto.isBackward = function isBackward(document) {
    return !this.isForward(document);
  }
  /**
   * 获取start point
   */
  ;

  _proto.getStart = function getStart(document) {
    return this.isForward(document) ? this.anchor : this.focus;
  }
  /**
   * 获取end point
   */
  ;

  _proto.getEnd = function getEnd(document) {
    return this.isBackward(document) ? this.anchor : this.focus;
  }
  /**
   * 根据PointName，获取point
   */
  ;

  _proto.getPoint = function getPoint(pointName, document) {
    if (pointName === 'start') {
      return this.getStart(document);
    } else if (pointName === 'end') {
      return this.getEnd(document);
    } else {
      return this[pointName];
    }
  }
  /**
   * 同时获取start point、end point
   */
  ;

  _proto.sort = function sort(document) {
    return {
      start: this.getStart(document),
      end: this.getEnd(document)
    };
  }
  /**
   * 把当前的数据选区的 Points 转换成 TextPoints。
   */
  ;

  _proto.convertToTextPoints = function convertToTextPoints(document) {
    var _this$sort = this.sort(document),
        start = _this$sort.start,
        end = _this$sort.end;

    if (this.isCollapsed) {
      var _point = start.convertToTextPoint(document);

      return {
        anchor: _point,
        focus: _point,
        start: _point,
        end: _point
      };
    }

    if (start.isEdgePoint()) {
      if (start.edge === EdgePoint.BEFORE) {
        start = start.convertToTextPoint(document);
      } else {
        var startNode = document.getNextText(start.key) || document.getFirstNode();
        start = TextPoint.create({
          key: startNode.key,
          offset: 0
        });
      }
    }

    if (end.isEdgePoint()) {
      if (end.edge === EdgePoint.AFTER) {
        end = end.convertToTextPoint(document);
      } else {
        var endNode = document.getPreviousText(end.key) || document.getLastNode();
        end = TextPoint.create({
          key: endNode.key,
          offset: endNode.text.length
        });
      }
    }

    var isForward = this.isForward(document);
    var anchor = isForward ? start : end;
    var focus = isForward ? end : start;
    return {
      anchor: anchor,
      focus: focus,
      start: start,
      end: end
    };
  }
  /**
   * 获得当前选区所处的 Node
   * @param document
   */
  ;

  _proto.getClosestNode = function getClosestNode(document) {
    var _this$convertToTextPo = this.convertToTextPoints(document),
        start = _this$convertToTextPo.start,
        end = _this$convertToTextPo.end;

    var aPath = document.getPath(start.key);
    var bPath = document.getPath(end.key);

    if (!aPath || !bPath) {
      return null;
    }

    var node = document.getNodeByPath(Path.common(aPath, bPath));

    if (node != null && node.isText()) {
      return document.getClosestBlock(node.key);
    }

    return node;
  }
  /**
   * 选区是否在Hanging状态
   */
  ;

  /**
   * 拷贝出一个新的选区，并设置选区的Haning状态
   */
  _proto.setHanging = function setHanging(isHanging) {
    if (this.data.isHanging !== isHanging) {
      return this.merge({
        data: _extends({}, this.data, {
          isHanging: isHanging
        })
      });
    }

    return this;
  }
  /**
   * 拷贝出一个新的选区，并把start point移到end point的位置
   */
  ;

  _proto.moveToEnd = function moveToEnd(document) {
    if (this.isBackward(document)) {
      return this.merge({
        focus: this.getEnd(document)
      });
    }

    return this.merge({
      anchor: this.getEnd(document)
    });
  };

  _proto.moveStartToStartOfNode = function moveStartToStartOfNode(node, controller) {
    var document = controller.value.document;

    if (this.isForward(document)) {
      return this.moveAnchorToStartOfNode(node, controller);
    } else {
      return this.moveFocusToStartOfNode(node, controller);
    }
  };

  _proto.moveStartToEndOfNode = function moveStartToEndOfNode(node, controller) {
    var document = controller.value.document;

    if (this.isForward(document)) {
      return this.moveAnchorToEndOfNode(node, controller);
    } else {
      return this.moveFocusToEndOfNode(node, controller);
    }
  };

  _proto.moveEndToStartOfNode = function moveEndToStartOfNode(node, controller) {
    var document = controller.value.document;

    if (this.isForward(document)) {
      return this.moveFocusToStartOfNode(node, controller);
    } else {
      return this.moveAnchorToStartOfNode(node, controller);
    }
  };

  _proto.moveEndToEndOfNode = function moveEndToEndOfNode(node, controller) {
    var document = controller.value.document;

    if (this.isForward(document)) {
      return this.moveFocusToEndOfNode(node, controller);
    } else {
      return this.moveAnchorToEndOfNode(node, controller);
    }
  };

  _proto.moveAnchorToStartOfNode = function moveAnchorToStartOfNode(node, controller) {
    return this.set('anchor', controller.query(pointAtStartOfNode, node));
  };

  _proto.moveAnchorToEndOfNode = function moveAnchorToEndOfNode(node, controller) {
    return this.set('anchor', controller.query(pointAtEndOfNode, node));
  };

  _proto.moveFocusToStartOfNode = function moveFocusToStartOfNode(node, controller) {
    return this.set('focus', controller.query(pointAtStartOfNode, node));
  };

  _proto.moveFocusToEndOfNode = function moveFocusToEndOfNode(node, controller) {
    return this.set('focus', controller.query(pointAtEndOfNode, node));
  };

  _proto.moveAnchorTo = function moveAnchorTo(key, where) {
    return this.set('anchor', Point.createFromParams(key, where));
  };

  _proto.moveFocusTo = function moveFocusTo(key, where) {
    return this.set('focus', Point.createFromParams(key, where));
  };

  _proto.moveToStartOfNode = function moveToStartOfNode(node, controller) {
    var anchor = controller.query(pointAtStartOfNode, node);
    var focus = anchor;
    return this.merge({
      anchor: anchor,
      focus: focus
    });
  };

  _proto.moveToEndOfNode = function moveToEndOfNode(node, controller) {
    var anchor = controller.query(pointAtEndOfNode, node);
    var focus = anchor;
    return this.merge({
      anchor: anchor,
      focus: focus
    });
  }
  /**
   * 拷贝出一个新的选区，并把anchor和focus调换位置
   */
  ;

  _proto.flip = function flip() {
    return this.merge({
      anchor: this.focus,
      focus: this.anchor
    });
  };

  _proto.moveAnchorBackward = function moveAnchorBackward(n, mover) {
    if (n === void 0) {
      n = 1;
    }

    return mover ? mover('anchor', n)(this) : this.set('anchor', this.anchor.moveBackward(n));
  };

  _proto.moveAnchorForward = function moveAnchorForward(n, mover) {
    if (n === void 0) {
      n = 1;
    }

    return mover ? mover('anchor', n)(this) : this.set('anchor', this.anchor.moveForward(n));
  };

  _proto.moveFocusBackward = function moveFocusBackward(n, mover) {
    if (n === void 0) {
      n = 1;
    }

    return mover ? mover('focus', n)(this) : this.set('focus', this.focus.moveBackward(n));
  };

  _proto.moveFocusForward = function moveFocusForward(n, mover) {
    if (n === void 0) {
      n = 1;
    }

    return mover ? mover('focus', n)(this) : this.set('focus', this.focus.moveForward(n));
  };

  _proto.moveToFocus = function moveToFocus() {
    return this.set('anchor', this.focus);
  };

  _proto.moveToAnchor = function moveToAnchor() {
    return this.set('focus', this.anchor);
  };

  _proto.moveToStart = function moveToStart(document) {
    var start = this.getStart(document);
    return this.merge({
      anchor: start,
      focus: start
    });
  };

  _proto.moveToRangeOfNode = function moveToRangeOfNode(node, controller) {
    return this.moveAnchorToStartOfNode(node, controller).moveFocusToEndOfNode(node, controller);
  };

  _proto.moveForward = function moveForward(n, mover) {
    if (n === void 0) {
      n = 1;
    }

    if (!mover) {
      return this.updatePoints(function (point) {
        return point.isTextPoint() ? point.moveForward(n) : point;
      });
    }

    return this.moveAnchorForward(n, mover).moveFocusForward(n, mover);
  };

  _proto.moveStartBackward = function moveStartBackward(document, n) {
    if (this.isForward(document)) {
      return this.moveAnchorBackward(n);
    }

    return this.moveFocusBackward(n);
  };

  _proto.moveStartForward = function moveStartForward(document, n) {
    return this.moveStartBackward(document, -n);
  };

  _proto.moveEndBackward = function moveEndBackward(document, n) {
    if (this.isForward(document)) {
      return this.moveFocusBackward(n);
    }

    return this.moveAnchorBackward(n);
  };

  _proto.moveEndForward = function moveEndForward(document, n) {
    return this.moveEndBackward(document, -n);
  };

  _proto.moveBackward = function moveBackward(n, mover) {
    if (n === void 0) {
      n = 1;
    }

    if (!mover) {
      return this.updatePoints(function (point) {
        return point.isTextPoint() ? point.moveBackward(n) : point;
      });
    }

    return this.moveAnchorBackward(n, mover).moveFocusBackward(n, mover);
  };

  _proto.move = function move(mover) {
    return mover(this);
  };

  _proto.moveToStartOfDocument = function moveToStartOfDocument(controller) {
    return this.moveToStartOfNode(controller.value.document, controller);
  };

  _proto.moveToEndOfDocument = function moveToEndOfDocument(controller) {
    return this.moveToEndOfNode(controller.value.document, controller);
  };

  _proto.movePointEdgeKlass = function movePointEdgeKlass(controller, pointName, edge, klass) {
    var document = controller.value.document;
    var PName = pointName.slice(0, 1).toUpperCase() + pointName.slice(1);
    var Edge = edge.slice(0, 1).toUpperCase() + edge.slice(1);
    var Object = klass.slice(0, 1).toUpperCase() + klass.slice(1);
    var method = "move" + PName + "To" + Edge + "OfNode";
    var getNode = klass === 'text' ? 'getNode' : "getClosest" + Object;
    var p = this.getPoint(pointName, document);
    var node = p.isTextPoint() ? document[getNode](p.key) : document.getNode(p.key);

    if (!node) {
      return this;
    }

    var newSelection = this[method](node, controller);
    return newSelection;
  };

  _proto.movePointEdgeSideKlass = function movePointEdgeSideKlass(controller, pointName, edge, side, klass) {
    var document = controller.value.document;
    var PName = pointName.slice(0, 1).toUpperCase() + pointName.slice(1);
    var Edge = edge.slice(0, 1).toUpperCase() + edge.slice(1);
    var Side = side.slice(0, 1).toUpperCase() + side.slice(1);
    var Klass = klass.slice(0, 1).toUpperCase() + klass.slice(1);
    var method = "move" + PName + "To" + Edge + "OfNode";
    var getNode = klass === 'text' ? 'getNode' : "getClosest" + Klass;
    var getDirectionNode = "get" + Side + Klass;
    var p = this.getPoint(pointName, document);
    var node = document[getNode](p.key);

    if (!node) {
      return this;
    }

    var target = document[getDirectionNode](node.key);

    if (!target) {
      return this;
    }

    var newSelection = this[method](target, controller);
    return newSelection;
  };

  _proto.updatePoints = function updatePoints(updater) {
    var anchor = this.anchor,
        focus = this.focus;
    anchor = updater(anchor);
    focus = updater(focus);
    return this.merge({
      anchor: anchor,
      focus: focus
    });
  };

  _proto.toJSON = function toJSON(options) {
    return {
      klass: 'selection',
      anchor: this.anchor.toJSON(options),
      focus: this.focus.toJSON(options),
      marks: this.marks ? this.marks.map(function (m) {
        return m.toJSON();
      }) : null
    };
  };

  _createClass(Selection, [{
    key: "isCollapsed",
    get: function get() {
      if (!IS_COLLAPSED_CACHE.has(this)) {
        var anchor = this.anchor,
            focus = this.focus;
        IS_COLLAPSED_CACHE.set(this, equal(anchor, focus));
      }

      return IS_COLLAPSED_CACHE.get(this);
    }
    /**
     * 选区是否是扩展
     */

  }, {
    key: "isExpanded",
    get: function get() {
      return !this.isCollapsed;
    }
  }, {
    key: "viewKey",
    get: function get() {
      var keyStr = this.anchor.viewKey + "_" + this.focus.viewKey;

      try {
        return keyStr + "_" + JSON.stringify(this.data);
      } catch (error) {
        return keyStr;
      }
    }
  }, {
    key: "plainViewKey",
    get: function get() {
      return this.anchor.viewKey + "_" + this.focus.viewKey;
    }
  }, {
    key: "isHanging",
    get: function get() {
      return Boolean(this.data.isHanging);
    }
  }, {
    key: "isCollapsedAtEdge",
    get: function get() {
      return this.isCollapsed && this.anchor.isEdgePoint();
    }
  }]);

  return Selection;
}(ImmutableRecord);

function _createForOfIteratorHelperLoose$6(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray$6(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$6(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen); }

function _arrayLikeToArray$6(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var Document = /*#__PURE__*/function (_Element) {
  _inheritsLoose(Document, _Element);

  Document.create = function create(props) {
    if (props === void 0) {
      props = {};
    }

    if (Document.isDocument(props)) {
      return props;
    }

    if (isPlainObject(props)) {
      var _props = props,
          _props$key = _props.key,
          key = _props$key === void 0 ? keyUtils.create() : _props$key,
          _props$data = _props.data,
          data = _props$data === void 0 ? {} : _props$data,
          _props$nodes = _props.nodes,
          nodes = _props$nodes === void 0 ? [] : _props$nodes;
      return new Document({
        key: key,
        data: data,
        nodes: nodes
      });
    }

    throw new Error("`Document.create` only accepts objects or documents, but you passed it: " + props);
  };

  Document.fromJSON = function fromJSON(json) {
    return Document.create(_extends({}, json, {
      nodes: json.nodes ? json.nodes.map(Block.fromJSON) : []
    }));
  };

  Document.isDocument = function isDocument(maybeDocument) {
    return maybeDocument instanceof Document;
  };

  function Document(props) {
    var _this;

    _this = _Element.call(this, props) || this;
    _this.type = 'document';
    _this.nodes = void 0;
    var nodes = props.nodes;
    _this.nodes = nodes;
    return _this;
  }

  var _proto = Document.prototype;

  _proto.merge = function merge(props) {
    return new Document(_extends({
      key: this.key,
      data: this.data,
      nodes: this.nodes
    }, props));
  };

  _proto.set = function set(key, value) {
    var _this$merge;

    return this.merge((_this$merge = {}, _this$merge[key] = value, _this$merge));
  }
  /**
   * 获取selection内对应的所有marks
   */
  ;

  _proto.getMarksAtRange = function getMarksAtRange(range) {
    if (range.isCollapsed && range.anchor.isEdgePoint()) {
      return [];
    }

    var _range$convertToTextP = range.convertToTextPoints(this),
        start = _range$convertToTextP.start,
        end = _range$convertToTextP.end;

    if (range.isCollapsed) {
      return this.getMarksAtPosition(start.key, start.offset);
    }

    if (start.key === end.key) {
      var startText = this.getNode(start.key);
      return Text$1.isText(startText) ? startText.getMarksBetweenOffsets(start.offset, end.offset) : [];
    }

    var texts = this.getTextsBetweenPositions(start.key, end.key);
    return texts.reduce(function (marks, text) {
      if (text.key === start.key) {
        return setUtils.union(marks, text.getMarksBetweenOffsets(start.offset, text.text.length));
      }

      if (text.key === end.key) {
        return setUtils.union(marks, text.getMarksBetweenOffsets(0, end.offset));
      }

      return setUtils.union(marks, text.getMarks());
    }, []);
  }
  /**
   * 获取selection内对应的所有公共marks
   */
  ;

  _proto.getActiveMarksAtRange = function getActiveMarksAtRange(range) {
    if (range.isCollapsed && range.anchor.isEdgePoint()) {
      return [];
    }

    if (!Selection.isValidSelection(this, range)) {
      return [];
    }

    var _range$convertToTextP2 = range.convertToTextPoints(this),
        start = _range$convertToTextP2.start,
        end = _range$convertToTextP2.end;

    if (range.isCollapsed) {
      return this.getMarksAtPosition(start.key, start.offset);
    }

    var startNode = this.getNode(start.key);
    var startText = startNode != null && startNode.isText() ? startNode : null;

    if (!startText) {
      return [];
    }

    var startKey = start.key;
    var startOffset = start.offset;
    var endKey = end.key;
    var endOffset = end.offset;

    if (startKey === endKey) {
      return startText.getActiveMarksBetweenOffsets(startOffset, endOffset);
    }

    while (startKey !== endKey && endOffset === 0) {
      var _endText = this.getPreviousText(endKey);

      if (!_endText) {
        return [];
      }

      endKey = _endText.key;
      endOffset = _endText.text.length;
    }

    while (startKey !== endKey && startOffset === startText.text.length) {
      startText = this.getNextText(startKey);

      if (!startText) {
        return [];
      }

      startKey = startText.key;
      startOffset = 0;
    }

    var startMarks = startText.getActiveMarksBetweenOffsets(startOffset, startText.text.length);
    if (startMarks.length === 0) return [];
    var endText = this.getNode(endKey);
    var endMarks = endText != null && endText.isText() ? endText.getActiveMarksBetweenOffsets(0, endOffset) : [];
    var marks = setUtils.intersect(startMarks, endMarks); // If marks is already empty, the active marks is empty

    if (marks.length === 0) return marks;
    if (startKey === endKey) return marks;
    var text = this.getNextText(startKey);

    while (text && text.key !== endKey) {
      if (text.text.length !== 0) {
        marks = setUtils.intersect(marks, text.getActiveMarks());
        if (marks.length === 0) return [];
      }

      text = this.getNextText(text.key);
    }

    return marks;
  };

  _proto.getMarksAtPosition = function getMarksAtPosition(key, offset) {
    var text = this.getNode(key);
    var currentMarks = !(text != null && text.isText()) ? [] : text.getMarksAtIndex(offset);

    if (offset !== 0) {
      return currentMarks;
    }

    var closestBlock = this.getClosestBlock(key);

    if (!closestBlock || closestBlock.text === '') {
      // Insert mark for empty block; the empty block are often created by split node or add marks in a range including empty blocks
      return currentMarks;
    }

    var previous = this.getPreviousText(key);

    if (previous && closestBlock.getNode(previous.key)) {
      return previous.getMarksAtIndex(previous.text.length);
    }

    return currentMarks;
  }
  /**
   * 获取插入点对应的marks
   * 如果选区是collapse的，返回插入位置的marks;
   * 如果插入位置在新的text节点，则尝试获取同一block的前一个text对应的mark；
   * 如果选区是expand，则返回start位置对应的marks
   */
  ;

  _proto.getInsertMarksAtRange = function getInsertMarksAtRange(range) {
    if (range.isCollapsed && range.anchor.isEdgePoint()) {
      return [];
    }

    var _range$convertToTextP3 = range.convertToTextPoints(this),
        start = _range$convertToTextP3.start;

    if (range.isCollapsed) {
      return this.getMarksAtPosition(start.key, start.offset);
    }

    var text = this.getNode(start.key);
    return !(text != null && text.isText()) ? [] : text.getMarksAtIndex(start.offset + 1);
  };

  _proto.getNodesAtRange = function getNodesAtRange(range) {
    if (!range) {
      return [];
    }

    var doc = this;
    var start = range.getStart(doc);
    var end = range.getEnd(doc);
    var startPath = this.getPath(start.key);
    var endPath = this.getPath(end.key);
    var startIndex = startPath[0];
    var endIndex = endPath[0];
    var startBlock = this.nodes[startIndex];
    var endBlock = this.nodes[endIndex];
    var result = [];

    function push(node) {
      result.push(node);

      if (Block.isBlock(node) || Inline.isInline(node)) {
        node.nodes.forEach(push);
      }
    }

    function pushEdgeNode(node) {
      var path = doc.getPath(node.key);

      if (Path.isEqual(path, startPath) || Path.isAncestor(path, startPath) || Path.isAncestor(startPath, path) || Path.isEqual(path, endPath) || Path.isAncestor(path, endPath) || Path.isAncestor(endPath, path) || !range.isCollapsed && Path.isAfter(path, startPath) && Path.isBefore(path, endPath)) {
        result.push(node);

        if (Block.isBlock(node) || Inline.isInline(node)) {
          node.nodes.forEach(pushEdgeNode);
        }
      }
    } // Push the nodes in start path


    result.push(startBlock);
    startBlock.nodes.forEach(pushEdgeNode);

    if (startIndex === endIndex) {
      return result;
    } // Push the nodes between start and end


    this.nodes.slice(startIndex + 1, endIndex).forEach(function (node) {
      push(node);
    }); // Push the nodes in end path

    result.push(endBlock);
    endBlock.nodes.forEach(pushEdgeNode);
    return result;
  }
  /**
   * 获取最近的支持 edge 选择的 block 节点。
   * 如果 key 对应的节点满足条件，会直接返回此节点。
   */
  ;

  _proto.getClosestSelectableBlock = function getClosestSelectableBlock(key, controller) {
    var ans = this.getAncestors(key);
    var n = this.getNode(key);

    if (n != null && n.isElement()) {
      ans.push(n);
    }

    ans = ans.reverse();

    for (var _iterator = _createForOfIteratorHelperLoose$6(ans), _step; !(_step = _iterator()).done;) {
      var node = _step.value;

      if (controller.query('isEdgeSelectable', node)) {
        return node;
      } else if (node.isBlock() && controller.query('isVoid', node)) {
        return node;
      }
    }

    return null;
  }
  /**
   * 获取 rootKey 节点下距离 key 最远的支持 edge 选择的 block 节点。
   * 如果 key 对应的节点满足条件，也会返回此节点。
   */
  ;

  _proto.getFurthestSelectableBlock = function getFurthestSelectableBlock(key, rootKey, controller) {
    var ans = this.getAncestors(key);
    var n = this.getNode(key);

    if (n != null && n.isElement()) {
      ans.push(n);
    }

    var rootIndex = ans.findIndex(function (node) {
      return node.key === rootKey;
    });

    if (rootIndex === -1) {
      return null;
    }

    for (var i = rootIndex; i < ans.length; i++) {
      var node = ans[i];

      if (controller.query('isEdgeSelectable', node)) {
        return node;
      } else if (node.isBlock() && controller.query('isVoid', node)) {
        return node;
      }
    }

    return null;
  }
  /**
   * 获取最近的Void父节点
   */
  ;

  _proto.getClosestVoid = function getClosestVoid(key, controller) {
    var path = this.getPath(key);

    if (!path) {
      return null;
    }

    return this.getClosestVoidByPath(path, controller);
  }
  /**
   * 获取最近的Void父节点
   */
  ;

  _proto.getClosestVoidByPath = function getClosestVoidByPath(path, controller) {
    return this.getClosestByPath(path, function (node) {
      return controller.query('isVoid', node);
    });
  }
  /**
   * 是否有一个Void父节点
   */
  ;

  _proto.hasVoidParent = function hasVoidParent(key, controller) {
    var path = this.getPath(key);

    if (!path) {
      return false;
    }

    return this.hasVoidParentByPath(path, controller);
  };

  _proto.hasVoidParentByPath = function hasVoidParentByPath(path, controller) {
    var closest = this.getClosestVoidByPath(path, controller);
    return !!closest;
  }
  /**
   * 获取最顶层的一个Void节点
   */
  ;

  _proto.getFurthsestVoid = function getFurthsestVoid(key, controller) {
    return this.getFurthsest(key, function (node) {
      return controller.query('isVoid', node);
    });
  }
  /**
   * 根据选区，获取一个fragment
   */
  ;

  _proto.getFragmentAtRange = function getFragmentAtRange(range, controller) {
    var _range$convertToTextP4 = range.convertToTextPoints(this),
        start = _range$convertToTextP4.start,
        end = _range$convertToTextP4.end;

    var startTextPath = this.getPath(start.key);
    var endTextPath = this.getPath(end.key);

    if (!startTextPath || !endTextPath) {
      return Document.create();
    }

    var startVoid = controller && this.getClosestVoidByPath(startTextPath, controller);
    var endVoid = controller && this.getClosestVoidByPath(endTextPath, controller);
    var startPath = startVoid ? this.assertPath(startVoid.key) : startTextPath;
    var endPath = endVoid ? this.assertPath(endVoid.key) : endTextPath;
    var node = this;
    var targetPath = endPath;
    var targetPosition = endVoid ? endVoid.nodes.length : end.offset;
    var mode = 'end';

    while (targetPath.length) {
      var index = targetPath[targetPath.length - 1];
      node = node.splitNode(targetPath, targetPosition);
      targetPath = Path.parent(targetPath);
      targetPosition = index + 1;

      if (!targetPath.length && mode === 'end') {
        targetPath = startPath;
        targetPosition = startVoid ? 0 : start.offset;
        mode = 'start';
      }
    }

    var startIndex = startPath[0] + 1;
    var endIndex = endPath[0] + 2;
    var nodes = node.nodes.slice(startIndex, endIndex); // @ts-ignore

    return Document.create({
      nodes: nodes
    });
  }
  /**
   * 获取特定区间的所有叶子block
   */
  ;

  _proto.getLeafBlocksAtRange = function getLeafBlocksAtRange(range) {
    var _range$convertToTextP5 = range.convertToTextPoints(this),
        start = _range$convertToTextP5.start,
        end = _range$convertToTextP5.end;

    var startBlock = this.getClosestBlockFromPoint(start.key); // PERF: the most common case is when the range is in a single block node,
    // where we can avoid a lot of iterating of the tree.

    if (start.key === end.key) {
      return [startBlock];
    }

    var endBlock = this.getClosestBlockFromPoint(end.key);
    var blocks = this.getBlocks();
    var startIndex = blocks.indexOf(startBlock);
    var endIndex = blocks.indexOf(endBlock);
    return blocks.slice(startIndex, endIndex + 1);
  }
  /**
   * 循环获取document下的所有叶子blocks节点
   */
  ;

  _proto.getBlocks = function getBlocks() {
    return Block.getBlocks(this.nodes);
  }
  /**
   * 循环获取document下的所有叶子blocks节点
   */
  ;

  _proto.getBlocksByType = function getBlocksByType(type) {
    return Block.getBlocksByType(this.nodes, type);
  }
  /**
   * 循环获取document下的特定区间内的全部blocks节点
   */
  ;

  _proto.getRootBlocksAtRange = function getRootBlocksAtRange(range) {
    if (!range) {
      return [];
    }

    var _range$convertToTextP6 = range.convertToTextPoints(this),
        start = _range$convertToTextP6.start,
        end = _range$convertToTextP6.end;

    var startBlock = this.getFurthsestBlock(start.key);

    if (!startBlock) {
      return [];
    }

    if (start.key === end.key) {
      return [startBlock];
    }

    var endBlock = this.getFurthsestBlock(end.key);

    if (!endBlock) {
      return [];
    }

    return this.nodes.slice(this.nodes.indexOf(startBlock), this.nodes.indexOf(endBlock) + 1);
  }
  /**
   * 判断节点是否在Selection之内
   */
  ;

  _proto.isNodeInRange = function isNodeInRange(key, range) {
    var path = this.getPath(key);

    if (!path) {
      return false;
    }

    return this.isNodeInRangeByPath(path, range);
  }
  /**
   * 判断节点是否在Selection之内
   */
  ;

  _proto.isNodeInRangeByPath = function isNodeInRangeByPath(path, range) {
    if (!range || range.isCollapsedAtEdge) {
      return false;
    }

    var _range$sort = range.sort(this),
        start = _range$sort.start,
        end = _range$sort.end;

    var startPath = start.getPathIn(this);
    var endPath = end.getPathIn(this); // we cannot trust the selection

    if (!startPath || !endPath) {
      return false;
    } // edge cases


    if (start.isEdgePoint() && start.edge === EdgePoint.AFTER && (Path.isEqual(startPath, path) || Path.isAncestor(startPath, path))) {
      return false;
    }

    if (end.isEdgePoint() && end.edge === EdgePoint.BEFORE && (Path.isEqual(endPath, path) || Path.isAncestor(endPath, path))) {
      return false;
    }

    var isBeforeStart = Path.compare(path, startPath) === -1;
    var isAfterEnd = Path.compare(path, endPath) === 1;
    return !isBeforeStart && !isAfterEnd;
  }
  /**
   * 获取Selection内所有的Text节点
   */
  ;

  _proto.getTextsAtRange = function getTextsAtRange(range) {
    var _range$convertToTextP7 = range.convertToTextPoints(this),
        start = _range$convertToTextP7.start,
        end = _range$convertToTextP7.end;

    return this.getTextsBetweenPositions(start.key, end.key);
  }
  /**
   * 获取Selection内所有的叶子Inline节点
   */
  ;

  _proto.getLeafInlinesAtRange = function getLeafInlinesAtRange(range) {
    var _this2 = this;

    var array = this.getTextsAtRange(range).map(function (text) {
      return _this2.getClosestInline(text.key);
    }).filter(function (exists) {
      return Boolean(exists);
    });
    return array;
  }
  /**
   * 获取Selection内的所有最远Inline节点
   */
  ;

  _proto.getRootInlinesAtRange = function getRootInlinesAtRange(range) {
    var _this3 = this;

    if (!range) {
      return [];
    }

    var array = this.getTextsAtRange(range).map(function (text) {
      return _this3.getFurthsestInline(text.key);
    })
    /* eslint-disable @typescript-eslint/indent */
    .reduce(function (inlines, inline) {
      if (inline && !inlines.includes(inline)) {
        inlines.push(inline);
      }

      return inlines;
    }, []);
    /* eslint-enable @typescript-eslint/indent */

    return array;
  };

  _proto.toJSON = function toJSON(options) {
    var object = {
      klass: 'document',
      data: _extends({}, this.data),
      nodes: this.nodes.map(function (node) {
        return node.toJSON(options);
      })
    };

    if (options != null && options.preserveKeys) {
      object.key = this.key;
    }

    return object;
  };

  return Document;
}(Element$1);

function defaultMergeData(a, b) {
  return _extends({}, a, b);
}

var Injection = /*#__PURE__*/function (_ImmutableRecord) {
  _inheritsLoose(Injection, _ImmutableRecord);

  Injection.create = function create(props) {
    if (Injection.isInjection(props)) {
      return props;
    }

    if (isPlainObject(props)) {
      var key = props.key,
          data = props.data,
          mergeData = props.mergeData;
      return new Injection({
        key: key,
        data: data,
        mergeData: mergeData
      });
    }

    throw new Error("`Injection.create` only accepts objects or injections, but you passed it: " + props);
  };

  Injection.isInjection = function isInjection(maybeInjection) {
    return maybeInjection instanceof Injection;
  };

  Injection.injectIntoNode = function injectIntoNode(injections, node) {
    if (!injections.length || !Element$1.isElement(node)) {
      return node;
    }

    return injections.reduce(function (n, injection) {
      if (injection.key !== n.key) {
        return n;
      }

      var mergeData = injection.mergeData;
      return n.set('data', mergeData(n.data, injection.data));
    }, node);
  };

  Injection.fromJSON = function fromJSON(json) {
    var key = json.key,
        data = json.data;
    return Injection.create({
      key: key,
      data: data
    });
  };

  function Injection(props) {
    var _this;

    _this = _ImmutableRecord.call(this) || this;
    _this.key = void 0;
    _this.data = void 0;
    _this.mergeData = void 0;
    var key = props.key,
        data = props.data,
        _props$mergeData = props.mergeData,
        mergeData = _props$mergeData === void 0 ? defaultMergeData : _props$mergeData;
    _this.key = key;
    _this.data = data;
    _this.mergeData = mergeData;

    _this.freeze();

    return _this;
  }

  var _proto = Injection.prototype;

  _proto.merge = function merge(props) {
    return new Injection(_extends({
      key: this.key,
      data: this.data,
      mergeData: this.mergeData
    }, props));
  };

  _proto.set = function set(key, value) {
    var _this$merge;

    return this.merge((_this$merge = {}, _this$merge[key] = value, _this$merge));
  };

  _proto.toJSON = function toJSON() {
    return {
      key: this.key,
      data: this.data
    };
  };

  return Injection;
}(ImmutableRecord);

/**
 * @packageDocumentation
 * @ignore
 */
var movePointForward = curry(function (controller, pn, distance, unit) {
  return function (selection) {
    if (distance === 0) {
      return selection;
    }

    var document = controller.value.document;
    var pointName = pn;

    if (pointName === 'start') {
      pointName = selection.isForward(document) ? 'anchor' : 'focus';
    } else if (pointName === 'end') {
      pointName = selection.isForward(document) ? 'focus' : 'anchor';
    }

    var at = pointName === 'anchor' ? selection.anchor : selection.focus;
    var point = controller.query(pointAtDistance, at, distance, unit);
    return selection.set(pointName, point);
  };
});
var movePointBackward = curry(function (controller, pn, distance, unit) {
  return function (selection) {
    var mover = movePointForward(controller, pn, -distance, unit);
    return mover(selection);
  };
});
var movePointWordBackward = movePointBackward(curry.placeholder, curry.placeholder, 1, 'word');
var movePointWordForward = movePointForward(curry.placeholder, curry.placeholder, 1, 'word');
/**
 * 判断 `selection` 是否完全在 `node` 内部
 * @param node
 * @param document
 * @param selection
 * @returns
 */

var isSelectionInNode = function isSelectionInNode(node, document, selection) {
  var _selection$sort = selection.sort(document),
      start = _selection$sort.start,
      end = _selection$sort.end;

  if (Element$1.isElement(node)) {
    if (start.isEdgePoint() && start.key === node.key || end.isEdgePoint() && end.key === node.key) {
      return false;
    } else {
      var _selection$convertToT = selection.convertToTextPoints(document),
          startText = _selection$convertToT.start,
          endText = _selection$convertToT.end;

      return node.hasNode(startText.key) && node.hasNode(endText.key);
    }
  } else {
    // Node is Text
    return start.isTextPoint() && end.isTextPoint() && start.key === node.key && end.key === node.key;
  }
};

function getFirstDataElementPath(document, view, viewElement) {
  var start = viewElement.nodes[0];

  while (!document.hasNode(start.key)) {
    start = view.assertElement(start.key).nodes[0];
  }

  return document.assertPath(start.key);
}

function getLastDataElementPath(document, view, viewElement) {
  var end = viewElement.nodes[viewElement.nodes.length - 1];

  while (!document.hasNode(end.key)) {
    var endElement = view.assertElement(end.key);
    end = endElement.nodes[endElement.nodes.length - 1];
  }

  return document.assertPath(end.key);
}
/**
 * 获得裁剪后的选区
 * @param controller
 * @param selection
 * @param visibles
 */


function getCroppedSelection(controller, selection, visibles) {
  if (!controller.enableVirtualize) {
    return selection;
  }

  var document = controller.value.document;
  var view = controller.view;
  var validVisibles = visibles.filter(function (visible) {
    return document.hasNode(visible) || view.hasNode(visible);
  });

  if (!validVisibles.length) {
    return null;
  } else {
    var _selection$convertToT2 = selection.convertToTextPoints(document),
        start = _selection$convertToT2.start,
        end = _selection$convertToT2.end;

    var selectionStartPath = document.getPath(start.key);
    var selectionEndPath = document.getPath(end.key);

    if (!selectionStartPath || !selectionEndPath) {
      return null;
    }

    var visibleStartKey = validVisibles[0];
    var visibleEndKey = validVisibles[validVisibles.length - 1];
    var visibleStart;
    var visibleEnd;

    if (document.hasNode(visibleStartKey)) {
      visibleStart = document.assertPath(visibleStartKey)[0];
    } else {
      var viewElement = view.assertElement(visibleStartKey);
      visibleStart = getFirstDataElementPath(document, view, viewElement)[0];
    }

    if (document.hasNode(visibleEndKey)) {
      visibleEnd = document.assertPath(visibleEndKey)[0];
    } else {
      var _viewElement = view.assertElement(visibleEndKey);

      visibleEnd = getLastDataElementPath(document, view, _viewElement)[0];
    }

    var selectionStart = selectionStartPath[0];
    var selectionEnd = selectionEndPath[0];

    if (selectionStart > visibleEnd || selectionEnd < visibleStart) {
      return null;
    }

    var sel = selection;

    if (selectionStart < visibleStart) {
      sel = sel.moveStartToStartOfNode(document.assertNodeByPath([visibleStart]), controller);
    }

    if (selectionEnd > visibleEnd) {
      sel = sel.moveEndToEndOfNode(document.assertNodeByPath([visibleEnd]), controller);
    }

    return sel;
  }
}

/* eslint-disable no-restricted-syntax */

function getSiblingTextPoint(controller, key, isPrev) {
  var document = controller.value.document;
  var textNode = isPrev ? document.getPreviousText(key) : document.getNextText(key);

  if (textNode) {
    var _key = textNode.key;
    var offset = isPrev ? textNode.text.length : 0;
    return TextPoint.create({
      key: _key,
      offset: offset
    });
  }

  return undefined;
}
/**
 *
 * move point out of inline IF it's located at inline edges
 *
 * ### Normal Inline
 * Before: `<link><anchor/>www.dingtalk.com<focus/></link>`
 *
 * After: `<anchor/><link>www.dingtalk.com</link><focus/>`
 *
 * ### Side selectable Inline
 * Before: `<anchor/><ins>www.dingtalk.com</ins><focus/>`
 *
 * After: `<ins><anchor/>www.dingtalk.com<focus/></ins>`
 */


var correctPointAtInlineEdge = function correctPointAtInlineEdge(controller, point) {
  if (point.isEdgePoint()) {
    return point;
  }

  if (controller.query('disableCorrectPointAtInnerEdge', point)) {
    return point;
  }

  var document = controller.value.document;
  var key = point.key,
      offset = point.offset;
  var text = document.getNode(key);
  var parent = document.getParent(key); // 若当前选中点为 text 起始，则试探前一个节点是否为可选 inline

  if (offset === 0) {
    var node = document.getPreviousSibling(key);

    if (node && Inline.isInline(node) && controller.query('isSideSelectable', node)) {
      return getSiblingTextPoint(controller, key, true) || point;
    }
  } // 若当前选中点为 text 末尾，则试探后一个节点是否为可选 inline


  if (text && offset === text.text.length) {
    var _node = document.getNextSibling(key);

    if (_node && Inline.isInline(_node) && controller.query('isSideSelectable', _node)) {
      return getSiblingTextPoint(controller, key, false) || point;
    }
  }

  if (!parent || !parent.isInline() || controller.query('isVoid', parent) || controller.query('isSideSelectable', parent)) {
    return point;
  }

  if (offset !== 0 && offset !== parent.text.length) {
    return point;
  }

  return getSiblingTextPoint(controller, key, offset === 0) || point;
};
/**
 *
 * move point out of void
 *
 * Before: <img>[anchor]</img>cangjie[focus]
 * After: [anchor]<img></img>cangjie[focus]
 */


var correctPointInVoid = function correctPointInVoid(controller, point, isStart) {
  if (point.isEdgePoint()) {
    return point;
  }

  var document = controller.value.document;
  var key = point.key;
  var parent = document.getClosestInline(key);

  if (!parent || !controller.query('isVoid', parent)) {
    return point;
  }

  return getSiblingTextPoint(controller, key, isStart) || point;
};

function focus(controller) {
  if (!controller.value.isFocused) {
    return controller.setIsFocused(true);
  }

  return controller;
}
function blur(controller) {
  if (controller.value.isFocused) {
    return controller.setIsFocused(false);
  }

  return controller;
}
function select(controller, selection) {
  var prevSelection = controller.value.selection;

  if (equal(selection, prevSelection)) {
    return controller;
  }

  return controller.applyOperation({
    type: OperationType.SetSelection,
    selection: Selection.create(selection),
    prevSelection: prevSelection
  });
}
/**
 *
 * differences between `select` and `userSelect`:
 *
 * `select` will set exactly what you passed;
 * `userSelect` may adjust the selection to make the user feel expected.
 */

function userSelect(controller, selection) {
  var _controller$value = controller.value,
      prevSelection = _controller$value.selection,
      document = _controller$value.document;

  if (equal(selection, prevSelection)) {
    return controller;
  }

  var paramAnchor = selection.anchor,
      paramFocus = selection.focus;
  var anchor = correctPointAtInlineEdge(controller, paramAnchor);
  var focus = correctPointAtInlineEdge(controller, paramFocus);

  if (selection.isExpanded) {
    var isForward = selection.isForward(document);
    anchor = correctPointInVoid(controller, anchor, isForward);
    focus = correctPointInVoid(controller, focus, !isForward);
  }

  var correctedSelection = selection.set('anchor', anchor).set('focus', focus);
  return controller.applyOperation({
    type: OperationType.SetSelection,
    selection: correctedSelection,
    prevSelection: prevSelection
  });
}
function selectWordAtPoint(controller, point) {
  var document = controller.value.document;
  var selection = Selection.selectWordAtPoint(document, point);
  return selection ? controller.command(select, selection) : controller;
}
function moveAnchorBackward(controller, n, unit) {
  if (n === void 0) {
    n = 1;
  }

  var selection = controller.value.selection;
  var mover = movePointBackward(controller, 'anchor', n, unit || 'offset');
  return controller.command(userSelect, mover(selection));
}
function moveAnchorForward(controller, n, unit) {
  if (n === void 0) {
    n = 1;
  }

  var selection = controller.value.selection;
  var mover = movePointForward(controller, 'anchor', n, unit || 'offset');
  var newSelection = mover(selection);
  return controller.command(userSelect, newSelection);
}
function moveAnchorTo(controller, path, offset) {
  var _controller$value2 = controller.value,
      selection = _controller$value2.selection,
      document = _controller$value2.document;

  var _document$assertNodeB = document.assertNodeByPath(path),
      key = _document$assertNodeB.key;

  var newSelection = selection.moveAnchorTo(key, offset);
  return controller.command(select, newSelection);
}
function moveAnchorToKey(controller, key, offset) {
  var path = controller.value.document.assertPath(key);
  return controller.command(moveAnchorTo, path, offset);
}
function moveAnchorToStartOfBlock(controller) {
  var selection = controller.value.selection;
  return controller.command(select, selection.movePointEdgeKlass(controller, 'anchor', 'start', 'block'));
}
function moveAnchorToStartOfPreviousBlock(controller) {
  var selection = controller.value.selection;
  return controller.command(select, selection.movePointEdgeSideKlass(controller, 'anchor', 'start', 'previous', 'block'));
}
function moveAnchorToEndOfNextBlock(controller) {
  var selection = controller.value.selection;
  return controller.command(select, selection.movePointEdgeSideKlass(controller, 'anchor', 'end', 'next', 'block'));
}
function moveFocusTo(controller, path, offset) {
  var _controller$value3 = controller.value,
      selection = _controller$value3.selection,
      document = _controller$value3.document;

  var _document$assertNodeB2 = document.assertNodeByPath(path),
      key = _document$assertNodeB2.key;

  var newSelection = selection.moveFocusTo(key, offset);
  return controller.command(select, newSelection);
}
function moveFocusToKey(controller, key, offset) {
  var path = controller.value.document.assertPath(key);
  return controller.command(moveFocusTo, path, offset);
}
function moveTo(controller, path, offset) {
  return controller.command(moveAnchorTo, path, offset).command(moveFocusTo, path, offset);
}
function moveToKey(controller, key, offset) {
  var path = controller.value.document.assertPath(key);
  return controller.command(moveTo, path, offset);
}
function moveFocusBackward(controller, n) {
  if (n === void 0) {
    n = 1;
  }

  var selection = controller.value.selection;
  var mover = movePointBackward(controller, 'focus', n, 'offset');
  return controller.command(select, mover(selection));
}
function moveFocusForward(controller, n) {
  if (n === void 0) {
    n = 1;
  }

  var selection = controller.value.selection;
  var mover = movePointForward(controller, 'focus', n, 'offset');
  return controller.command(select, mover(selection));
}
function moveFocusWordBackward(controller) {
  var selection = controller.value.selection;
  var mover = movePointBackward(controller, 'focus', 1, 'word');
  return controller.command(select, mover(selection));
}
function moveFocusWordForward(controller) {
  var selection = controller.value.selection;
  var mover = movePointForward(controller, 'focus', 1, 'word');
  return controller.command(select, mover(selection));
}
function moveFocusToEndOfText(controller) {
  var selection = controller.value.selection;
  return controller.command(select, selection.movePointEdgeKlass(controller, 'focus', 'end', 'text'));
}
function moveFocusToStartOfBlock(controller) {
  var selection = controller.value.selection;
  return controller.command(select, selection.movePointEdgeKlass(controller, 'focus', 'start', 'block'));
}
function moveFocusToEndOfBlock(controller) {
  var selection = controller.value.selection;
  return controller.command(select, selection.movePointEdgeKlass(controller, 'focus', 'end', 'block'));
}
function moveFocusToStartOfDocument(controller) {
  var document = controller.value.document;
  return controller.command(moveFocusToStartOfNode, document);
}
function moveFocusToEndOfDocument(controller) {
  var document = controller.value.document;
  return controller.command(moveFocusToEndOfNode, document);
}
function moveStartBackward(controller, n) {
  if (n === void 0) {
    n = 1;
  }

  var selection = controller.value.selection;
  var mover = movePointBackward(controller, 'start', n, 'offset');
  return controller.command(select, mover(selection));
}
function moveStartForward(controller, n) {
  if (n === void 0) {
    n = 1;
  }

  var selection = controller.value.selection;
  var mover = movePointForward(controller, 'start', n, 'offset');
  return controller.command(select, mover(selection));
}
function moveEndBackward(controller, n) {
  if (n === void 0) {
    n = 1;
  }

  var selection = controller.value.selection;
  var mover = movePointBackward(controller, 'end', n, 'offset');
  return controller.command(select, mover(selection));
}
function moveEndForward(controller, n) {
  if (n === void 0) {
    n = 1;
  }

  var selection = controller.value.selection;
  var mover = movePointForward(controller, 'end', n, 'offset');
  return controller.command(select, mover(selection));
}
function moveBackward(controller, n) {
  if (n === void 0) {
    n = 1;
  }

  return controller.command(moveAnchorBackward, n).command(moveFocusBackward, n);
}
function moveForward(controller, n) {
  if (n === void 0) {
    n = 1;
  }

  return controller.command(moveAnchorForward, n).command(moveFocusForward, n);
}
function moveToEndOfPreviousBlock(controller) {
  return controller.command(moveStartToEndOfPreviousBlock).command(moveToStart);
}
function moveToEndOfNextBlock(controller) {
  return controller.command(moveEndToEndOfNextBlock).command(moveToEnd);
}
function moveToEndOfInline(controller) {
  return controller.command(moveEndToEndOfInline).command(moveToEnd);
}
function moveToAnchor(controller) {
  var selection = controller.value.selection;
  return controller.command(select, selection.moveToAnchor());
}
function moveToFocus(controller) {
  var selection = controller.value.selection;
  return controller.command(select, selection.moveToFocus());
}
function moveToRangeOfDocument(controller) {
  return controller.command(moveToRangeOfNode, controller.value.document);
}
function moveToRangeOfNode(controller, node) {
  var selection = controller.value.selection;
  return controller.command(select, selection.moveToRangeOfNode(node, controller));
}
function moveToStart(controller) {
  var _controller$value4 = controller.value,
      document = _controller$value4.document,
      selection = _controller$value4.selection;
  return controller.command(select, selection.moveToStart(document));
}
function moveToEnd(controller) {
  var _controller$value5 = controller.value,
      document = _controller$value5.document,
      selection = _controller$value5.selection;
  return controller.command(select, selection.moveToEnd(document));
}
function moveToEndOfDocument(controller) {
  return controller.command(moveEndToEndOfNode, controller.value.document).command(moveToEnd);
}
function moveToStartOfInline(controller) {
  return controller.command(moveStartToStartOfInline).command(moveToStart);
}
function moveToStartOfBlock(controller) {
  return controller.command(moveStartToStartOfBlock).command(moveToStart);
}
function moveToEndOfBlock(controller) {
  return controller.command(moveEndToEndOfBlock).command(moveToEnd);
}
function moveToEndOfNode(controller, node) {
  var selection = controller.value.selection;
  return controller.command(select, selection.moveToEndOfNode(node, controller));
}
function moveStartToStartOfInline(controller) {
  var selection = controller.value.selection;
  return controller.command(select, selection.movePointEdgeKlass(controller, 'start', 'start', 'inline'));
}
function moveStartToStartOfBlock(controller) {
  var selection = controller.value.selection;
  return controller.command(select, selection.movePointEdgeKlass(controller, 'start', 'start', 'block'));
}
function moveStartToStartOfPreviousBlock(controller) {
  var selection = controller.value.selection;
  return controller.command(select, selection.movePointEdgeSideKlass(controller, 'start', 'start', 'previous', 'block'));
}
function moveEndToEndOfBlock(controller) {
  var selection = controller.value.selection;
  return controller.command(select, selection.movePointEdgeKlass(controller, 'end', 'end', 'block'));
}
function moveToStartOfDocument(controller) {
  var _controller$value6 = controller.value,
      document = _controller$value6.document,
      selection = _controller$value6.selection;
  return controller.command(select, selection.moveFocusToStartOfNode(document, controller).moveToFocus());
}
function moveStartToEndOfNode(controller, node) {
  var selection = controller.value.selection;
  return controller.command(select, selection.moveStartToEndOfNode(node, controller));
}
function moveAnchorToStartOfNode(controller, node) {
  var selection = controller.value.selection;
  return controller.command(select, selection.moveAnchorToStartOfNode(node, controller));
}
function moveAnchorToEndOfNode(controller, node) {
  var selection = controller.value.selection;
  return controller.command(select, selection.moveAnchorToEndOfNode(node, controller));
}
function moveFocusToStartOfNode(controller, node) {
  var selection = controller.value.selection;
  return controller.command(select, selection.moveFocusToStartOfNode(node, controller));
}
function moveFocusToEndOfNode(controller, node) {
  var selection = controller.value.selection;
  return controller.command(select, selection.moveFocusToEndOfNode(node, controller));
}
function moveToEndOfPreviousText(controller) {
  return controller.command(moveStartToEndOfPreviousText).command(moveToStart);
}
function moveToStartOfNextText(controller) {
  return controller.command(moveEndToStartOfNextText).command(moveToEnd);
}
function moveToStartOfPreviousBlock(controller) {
  return controller.command(moveStartToStartOfPreviousBlock).command(moveToStart);
}
function moveToStartOfNextBlock(controller) {
  return controller.command(moveEndToStartOfNextBlock).command(moveToEnd);
}
function moveToStartOfNode(controller, node) {
  var selection = controller.value.selection;
  return controller.command(select, selection.moveToStartOfNode(node, controller));
}
function moveStartToStartOfNode(controller, node) {
  var selection = controller.value.selection;
  return controller.command(select, selection.moveStartToStartOfNode(node, controller));
}
function moveEndToStartOfNode(controller, node) {
  var selection = controller.value.selection;
  return controller.command(select, selection.moveEndToStartOfNode(node, controller));
}
function moveEndToEndOfNode(controller, node) {
  var selection = controller.value.selection;
  return controller.command(select, selection.moveEndToEndOfNode(node, controller));
}
function moveStartToEndOfPreviousText(controller) {
  var selection = controller.value.selection;
  return controller.command(select, selection.movePointEdgeSideKlass(controller, 'start', 'end', 'previous', 'text'));
}
function moveStartToEndOfPreviousBlock(controller) {
  var selection = controller.value.selection;
  return controller.command(select, selection.movePointEdgeSideKlass(controller, 'start', 'end', 'previous', 'block'));
}
function moveEndToEndOfInline(controller) {
  var selection = controller.value.selection;
  return controller.command(select, selection.movePointEdgeKlass(controller, 'end', 'end', 'inline'));
}
function moveEndToStartOfNextText(controller) {
  var selection = controller.value.selection;
  return controller.command(select, selection.movePointEdgeSideKlass(controller, 'end', 'start', 'next', 'text'));
}
function moveEndToStartOfNextBlock(controller) {
  var selection = controller.value.selection;
  return controller.command(select, selection.movePointEdgeSideKlass(controller, 'end', 'start', 'next', 'block'));
}
function moveEndToEndOfNextBlock(controller) {
  var selection = controller.value.selection;
  return controller.command(select, selection.movePointEdgeSideKlass(controller, 'end', 'end', 'next', 'block'));
}
function moveWordBackward(controller) {
  var selection = controller.value.selection;
  var mover = movePointWordBackward(controller, 'focus');
  return controller.command(select, mover(selection)).command(moveToFocus);
}
function moveWordForward(controller) {
  var selection = controller.value.selection;
  var mover = movePointWordForward(controller, 'focus');
  return controller.command(select, mover(selection)).command(moveToFocus);
}

/**
 * @packageDocumentation
 * @module Commands
 */
/**
 * 删除指定位置的节点。
 * 1. 如果传入无效的节点，会抛异常。
 */

function removeNodeByKey(controller, key) {
  var value = controller.value;
  var document = value.document;
  var path = document.assertPath(key);
  return controller.command(removeNodeByPath, path);
}
/**
 * 删除指定位置的节点。
 * 1. 如果传入无效的节点，会抛异常。
 */

function removeNodeByPath(controller, path) {
  var oldDoc = controller.value.document;
  var node = oldDoc.assertNodeByPath(path);
  var _controller$value = controller.value,
      selection = _controller$value.selection,
      document = _controller$value.document;
  var prev = document.getPreviousNodeByPath(path);
  var next = document.getNextNodeByPath(path);

  var mapPoint = function mapPoint(point) {
    if (node.key === point.key || node.isElement() && node.hasNode(point.key)) {
      if (prev) {
        return controller.query(pointAtEndOfNode, prev);
      }

      if (next) {
        return controller.query(pointAtStartOfNode, next);
      }
    }

    return point;
  };

  var newSelection = selection;

  if (prev || next) {
    // 为什么在这里调整选区？
    // 需要根据 controller 来获取 pointAtStartOfNode / pointAtEndOfNode。如果放到 Value 的
    // applyOperation 中调整，value 没有感知到 controller 的存在，就无法获取 edge point。
    var anchor = mapPoint(selection.anchor);
    var focus = mapPoint(selection.focus);
    newSelection = Selection.create({
      anchor: anchor,
      focus: focus
    });
  } // 调用select是方便后续撤销时恢复选区，表格选区不恢复可能会跑到隐藏单元格触发bug


  controller.command(select, newSelection);
  controller.applyOperation({
    type: OperationType.RemoveNode,
    path: path,
    node: node
  });

  if (newSelection !== selection) {
    return controller.command(select, newSelection);
  }

  return controller;
}
/**
 * 删除指定位置的文字。
 * 1. 如果传入无效的节点，会抛异常。
 */

function removeTextByKey(controller, key, offset, text) {
  var value = controller.value;
  var document = value.document;
  var path = document.assertPath(key);
  return controller.command(removeTextByPath, path, offset, text);
}
/**
 * 删除指定位置的文字。
 * 1. 如果传入无效的节点，会抛异常。
 * @text 删除的文字；如果长度大于可用长度，按照可用长度计算
 */

function removeTextByPath(controller, path, offset, text) {
  var value = controller.value;
  var decorations = value.decorations,
      document = value.document;
  var node = document.assertTextByPath(path);
  var updated = false;
  var key = node.key,
      leaves = node.leaves;
  var from = offset;
  var to = offset + text.length; // filter atomic decorations

  var decs = decorations.filter(function (dec) {
    var start = dec.start,
        end = dec.end,
        mark = dec.mark;
    var isAtomic = controller.query('isAtomic', mark);
    if (!isAtomic) return true;
    if (start.key !== key) return true;

    if (start.offset < from && (end.key !== key || end.offset > from)) {
      updated = true;
      return false;
    }

    if (start.offset < to && (end.key !== key || end.offset > to)) {
      updated = true;
      return null;
    }

    return true;
  });

  if (updated) {
    controller.setDecorations(decs);
  }

  var removals = [];
  var cursor = 0;
  leaves.forEach(function (leaf) {
    var startCursor = cursor;
    var endCursor = cursor + leaf.text.length;
    cursor += leaf.text.length; // Skip the leaf which is not overlapped

    if (endCursor < from || to < startCursor) return; // Remove the leaf text

    var start = Math.max(startCursor, from);
    var end = Math.min(endCursor, to);
    var string = node.text.slice(start, end);
    removals.push({
      type: OperationType.RemoveText,
      path: path,
      offset: start,
      text: string,
      marks: leaf.marks
    });
  });
  controller.command(select, value.selection);
  removals.reverse().forEach(function (op) {
    return controller.applyOperation(op);
  });
  return controller;
}

/**
 * @packageDocumentation
 * @module Commands
 */
/**
 * 删除指定位置的Node，并添加到parentPath的第index处
 * 1. 如果传入无效的节点，会抛异常。
 */

function moveNodeByKey(controller, key, parentKey, index) {
  var value = controller.value;
  var document = value.document;
  var path = document.assertPath(key);
  var parentPath = document.assertPath(parentKey);
  return controller.command(moveNodeByPath, path, parentPath, index);
}
/**
 * 删除指定位置的Node，并添加到parentPath的第index处
 * 1. 如果传入无效的节点，会抛异常。
 */

function moveNodeByPath(controller, path, parentPath, index) {
  if (Path.isEqual(path, parentPath)) {
    return controller;
  }

  var newPath = parentPath.concat(index);

  if (Path.isEqual(path, newPath)) {
    return controller;
  }

  return controller.applyOperation({
    type: OperationType.MoveNode,
    path: path,
    newPath: newPath
  });
}

/* eslint-disable no-param-reassign */
function deleteExpanded(controller) {
  var value = controller.value;
  var selection = value.selection;

  if (selection.isExpanded) {
    controller.command(del);
  }
}
/**
 * 删除选区的内容；返回一个拷贝选区，并定位到原选区的start位置
 */

function deleteExpandedAtRange(controller, range) {
  var value = controller.value;
  var document = value.document;

  var _range$sort = range.sort(document),
      start = _range$sort.start,
      end = _range$sort.end;

  if (range.isExpanded) {
    controller.command('deleteAtRange', range);
  }

  var newDocument = controller.value.document;

  if (newDocument.getNode(start.key)) {
    range = range.merge({
      anchor: start,
      focus: start
    });
  } else {
    var point = end.isTextPoint() ? end.set('offset', 0) : end;
    range = range.merge({
      anchor: point,
      focus: point
    });
  }

  return range;
}

var PREFIX = 'cj/cmd/split_';
var splitTpl = function splitTpl(node, path, position) {
  return "" + PREFIX + (node.isText() ? 'text' : 'node') + "(" + JSON.stringify([path, position]);
};

/* eslint-disable no-param-reassign */
/**
 * 从指定文本位置开始拆分节点子树
 * @param controller
 * @param key 节点子树的 root key
 * @param textKey 待拆分的文本 key
 * @param textOffset 待拆分的文本 offset
 * @returns
 * @example
 * ```ts
 * // 
 * //   ┌───────┐                      ┌───────┐   
 * //   │ root  │                      │ root  │   
 * //   └───────┘                      └───────┘   
 * //       │                         ┌─────────┐  
 * //       ▼                         ▼         ▼  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ A │                     │ A │     │A1 │
 * //     └───┘                     └───┘     └───┘
 * //       │         ──split─▶       │         │  
 * //       ▼                         ▼         ▼  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ B │                     │ B │     │B1 │
 * //     └───┘                     └───┘     └───┘
 * //       │                         │         │  
 * //      │▼                         ▼         ▼  
 * //   ┌──┼────┐                   ┌───┐     ┌───┐
 * //   │'a│bc' │                   │'a'│     │'bc│
 * //   └──┼────┘                   └───┘     └───┘
 * //      │                                       
 * //   offset=1                                    
 * //
 * 
 * const newDocument = controller.commands('splitDescendantsByKey', document.key, text.key, 1);
*                                                       
 * ```
 */

function splitDescendantsByKey(controller, key, textKey, textOffset) {
  var value = controller.value;
  var document = value.document;
  var path = document.assertPath(key);
  var textPath = document.assertPath(textKey);
  return controller.command('splitDescendantsByPath', path, textPath, textOffset);
}
/**
 * 从指定文本位置开始拆分节点子树
 * @param controller
 * @param path 节点子树的 path
 * @param textPath 待拆分的文本 path
 * @param textOffset 待拆分的文本 offset
 * @returns
 * @example
 * ```ts
 * // 
 * //   ┌───────┐                      ┌───────┐   
 * //   │ root  │                      │ root  │   
 * //   └───────┘                      └───────┘   
 * //       │                         ┌─────────┐  
 * //       ▼                         ▼         ▼  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ A │                     │ A │     │A1 │
 * //     └───┘                     └───┘     └───┘
 * //       │         ──split─▶       │         │  
 * //       ▼                         ▼         ▼  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ B │                     │ B │     │B1 │
 * //     └───┘                     └───┘     └───┘
 * //       │                         │         │  
 * //      │▼                         ▼         ▼  
 * //   ┌──┼────┐                   ┌───┐     ┌───┐
 * //   │'a│bc' │                   │'a'│     │'bc│
 * //   └──┼────┘                   └───┘     └───┘
 * //      │                                       
 * //   offset=1                                    
 * //
 * 
 * const newDocument = controller.commands('splitDescendantsByPath', [], [0,0,0], 1);
 *                                                     
 * ```
 */

function splitDescendantsByPath(controller, path, textPath, textOffset) {
  if (equal(path, textPath)) {
    controller.command(splitNodeByPath, textPath, textOffset);
    return controller;
  }

  var value = controller.value;
  var document = value.document; // 从待拆分文本 `text` 开始，自底向上逐个拆分节点，直到到达拆分节点 `node`

  var node = document.assertNodeByPath(path);
  var text = document.assertNodeByPath(textPath);
  var ancestors = document.getAncestorsByPath(textPath);
  var elements = ancestors.slice();
  elements = dropWhile(elements, function (a) {
    return a.key !== node.key;
  }).reverse();
  return controller.withoutNormalizing(function () {
    controller.command(splitNodeByKey, text.key, textOffset);
    var previous = text;
    elements.forEach(function (element) {
      controller.command(splitNodeByKey, element.key, element.nodes.indexOf(previous) + 1);
      previous = element;
    });
  });
}
/**
 * 对目标节点进行拆分
 *
 * ```txt
 * Split Text:
 *
 *       position=5                    Text      Text
 *          │                        ┌───────┐ ┌───────┐
 *     Hello│World     ─split─────▶  │ Hello │ │ World │
 *          │                        └───────┘ └───────┘
 *
 * Split Element:
 *
 *          position=1
 *             │
 * ┌───────────┼───────────┐                ┌─────────────┐   ┌─────────────┐
 * │ Element   │           │                │ Element     │   │ Element     │
 * │  ┌───────┐│┌───────┐  │                │  ┌───────┐  │   │  ┌───────┐  │
 * │  │ Hello │││ World │  │────split─────▶ │  │ Hello │  │   │  │ World │  │
 * │  └───────┘│└───────┘  │                │  └───────┘  │   │  └───────┘  │
 * └───────────┼───────────┘                └─────────────┘   └─────────────┘
 *             │
 *             │
 *
 * ```
 * @key 待拆分节点 key
 * @position 拆分位置。如果是 Text 节点，代表文字的偏移量；如果 Element节点，代表子节点 index。
 */

function splitNodeByKey(controller, key, position) {
  var value = controller.value;
  var document = value.document;
  var path = document.assertPath(key);
  return controller.command(splitNodeByPath, path, position);
}
/**
 * 对目标节点进行拆分
 * ```txt
 * Split Text:
 *
 *       position=5                    Text      Text
 *          │                        ┌───────┐ ┌───────┐
 *     Hello│World     ─split─────▶  │ Hello │ │ World │
 *          │                        └───────┘ └───────┘
 *
 * Split Element:
 *
 *          position=1
 *             │
 * ┌───────────┼───────────┐                ┌─────────────┐   ┌─────────────┐
 * │ Element   │           │                │ Element     │   │ Element     │
 * │  ┌───────┐│┌───────┐  │                │  ┌───────┐  │   │  ┌───────┐  │
 * │  │ Hello │││ World │  │────split─────▶ │  │ Hello │  │   │  │ World │  │
 * │  └───────┘│└───────┘  │                │  └───────┘  │   │  └───────┘  │
 * └───────────┼───────────┘                └─────────────┘   └─────────────┘
 *             │
 *             │
 *                                                      
 * ```
 * @path 待拆分节点 path
 * @position 拆分位置。如果是 Text 节点，代表文字的偏移量；如果 Element节点，代表子节点 index。
 */

function splitNodeByPath(controller, path, position) {
  var value = controller.value;
  var document = value.document;
  var node = document.assertNodeByPath(path);
  var parentPath = path.slice(0, -1);
  var parent = document.getNodeByPath(parentPath);
  var index = parent.nodes.indexOf(node);

  if (Element$1.isElement(node)) {
    node.type;
    node.data;
  }

  controller.withOpContext(splitTpl(node, path, position), function () {
    controller.withoutTracking(function () {
      controller.withoutNormalizing(function () {
        if (node.isText()) {
          /**
           * Split Text为：
           *
           * 1. 删除分裂位置后的文本
           * 2. 在分裂节点之后，插入新的文本节点（其内容为分裂位置后的文本）
           * ```txt
           *
           *        position=4
           *            │
           * ┌──────────┼────────┐                ┌──────┐                     ┌──────┐┌──────┐
           * │      ABCD│EF      │─remove 'EF'──▶ │ ABCD │─insert Text('EF')─▶ │ ABCD ││  EF  │
           * └──────────┼────────┘                └──────┘                     └──────┘└──────┘
           *            │
           * ```
           */
          var _node$splitText = node.splitText(position),
              after = _node$splitText[1];

          var _controller$value = controller.value,
              selection = _controller$value.selection,
              decorations = _controller$value.decorations;
          controller.command(removeTextByPath, path, position, after.text).command(insertNodeByPath, parentPath, index + 1, after);
          /**
           * 上面从 split op 换成 remove + insert 之后，updatePoints 无法处理，导致 selection
           * 和 decorations 都会失效。
           *
           * 这里取之前的 selection 和 decorations，主动调用 updatePoints 来矫正位置，模拟之前的
           * split op 处理方式。
           */

          var valueToUpdate = controller.value.set('decorations', decorations).set('selection', selection);
          var updatedValue = valueToUpdate.updatePoints(valueToUpdate.document, function (point) {
            if (point.key === node.key && position <= point.offset) {
              return point.merge({
                key: after.key,
                offset: point.offset - position
              });
            }

            return point;
          });
          controller.setValue(updatedValue, {
            clearOperations: false
          });
        } else {
          /**
           * Split Element：
           *
           * 1. 在分裂位置后，插入空节点
           * 2. 将分裂位置后的节点移入这个空间点
           * 2. 在分裂节点之后，插入新的文本节点（其内容为分裂位置后的文本）
           * ```txt
           *     position=1
           *         │
           * ┌───────┼────────────────┐                      ┌────────────────────────┐ ┌─────────┐                ┌─────────┐ ┌────────────────┐
           * │ Elemen│                │                      │ Element                │ │ Element │                │ Element │ │ Element        │
           * │  ┌───┐│┌───┐┌───┐┌───┐ │                      │  ┌───┐ ┌───┐┌───┐┌───┐ │ │         │                │  ┌───┐  │ │┌───┐┌───┐┌───┐ │
           * │  │ A │││ B ││ C ││ D │ │───insert container──▶│  │ A │ │ B ││ C ││ D │ │ │         │──move afters──▶│  │ A │  │ ││ B ││ C ││ D │ │
           * │  └───┘│└───┘└───┘└───┘ │                      │  └───┘ └───┘└───┘└───┘ │ │         │                │  └───┘  │ │└───┘└───┘└───┘ │
           * └───────┼────────────────┘                      └────────────────────────┘ └─────────┘                └─────────┘ └────────────────┘
           *         │
           *
           * ```
           */
          var element = node;
          var insertNode = element.set('nodes', []).regenerateKey();
          var afters = element.nodes.slice(position);
          var at = index + 1;
          controller.command(insertNodeByPath, parentPath, at, insertNode);
          var insertNodePath = parentPath.concat(at);
          var moveNodePath = path.concat(position);
          afters.forEach(function (_, idx) {
            controller.command(moveNodeByPath, moveNodePath, insertNodePath, idx);
          });
        }
      });
    });
  });
  return controller;
}
/**
 * 在当前选区拆分 Block
 * 
 * @param controller
 * @param depth 对于嵌套结构，可以指定拆分深度，默认拆分深度为 1 ，即只拆分距选区最近的 Block
 * @returns
 * @example
 * 
 * ```ts
 * // 
 * //   ┌───────┐                      ┌───────┐   
 * //   │ root  │                      │ root  │   
 * //   └───────┘                      └───────┘   
 * //       │                              │       
 * //       ▼                              ▼       
 * //     ┌───┐                          ┌───┐     
 * //     │ A │                          │ A │     
 * //     └───┘                          └───┘     
 * //       │       ──depth=3─▶            │       
 * //       ▼                         ┌─────────┐  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ B │                     │ B │     │B1 │
 * //     └───┘                     └───┘     └───┘
 * //       │                         │         │  
 * //      │▼                         ▼         ▼  
 * //   ┌──┼────┐                   ┌───┐     ┌───┐
 * //   │'a│bc' │                   │'a'│     │'bc│
 * //   └──┼────┘                   └───┘     └───┘
 * //      │                                       
 * //   cursor                                    
 * //
 * 
 * const newDocument = controller.commands('splitBlock');
 * 
 *  * // 
 * //   ┌───────┐                      ┌───────┐   
 * //   │ root  │                      │ root  │   
 * //   └───────┘                      └───────┘   
 * //       │                         ┌─────────┐  
 * //       ▼                         ▼         ▼  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ A │                     │ A │     │A1 │
 * //     └───┘                     └───┘     └───┘
 * //       │       ──depth=3─▶       │         │  
 * //       ▼                         ▼         ▼  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ B │                     │ B │     │B1 │
 * //     └───┘                     └───┘     └───┘
 * //       │                         │         │  
 * //      │▼                         ▼         ▼  
 * //   ┌──┼────┐                   ┌───┐     ┌───┐
 * //   │'a│bc' │                   │'a'│     │'bc│
 * //   └──┼────┘                   └───┘     └───┘
 * //      │                                       
 * //   cursor                                    
 * //
 * 
 * const newDocument = controller.commands('splitBlock', 3);
 *                                                      
 * ```
 */

function splitBlock(controller, depth) {
  if (depth === void 0) {
    depth = 1;
  }

  deleteExpanded(controller);
  var value = controller.value;
  var selection = value.selection,
      document = value.document;
  var marks = selection.marks || document.getInsertMarksAtRange(selection);
  controller.command('splitBlockAtRange', selection, depth);
  var range = controller.value.selection;
  var newRange = range.moveToEnd(document);

  if (marks.length || selection.marks) {
    // 允许清除样式后 selection.marks = [] 继承到下一行
    newRange = range.merge({
      marks: marks.length ? marks : selection.marks
    });
  }

  return controller.command(select, newRange);
}
/**
 * 在指定选区区间拆分 Block
 * @param controller
 * @param selection
 * @param depth 对于嵌套结构，可以指定拆分深度，默认拆分深度为 1 ，即只拆分距选区最近的 Block
 * @returns
 * @example
 * 
 * ```ts
 * // 
 * //   ┌───────┐                      ┌───────┐   
 * //   │ root  │                      │ root  │   
 * //   └───────┘                      └───────┘   
 * //       │                              │       
 * //       ▼                              ▼       
 * //     ┌───┐                          ┌───┐     
 * //     │ A │                          │ A │     
 * //     └───┘                          └───┘     
 * //       │       ──depth=3─▶            │       
 * //       ▼                         ┌─────────┐  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ B │                     │ B │     │B1 │
 * //     └───┘                     └───┘     └───┘
 * //       │                         │         │  
 * //      │▼                         ▼         ▼  
 * //   ┌──┼────┐                   ┌───┐     ┌───┐
 * //   │'a│bc' │                   │'a'│     │'bc│
 * //   └──┼────┘                   └───┘     └───┘
 * //      │                                       
 * //   cursor                                    
 * //
 * 
 * const newDocument = controller.commands('splitBlockAtRange', cursor);
 * 
 * //   ┌───────┐                      ┌───────┐   
 * //   │ root  │                      │ root  │   
 * //   └───────┘                      └───────┘   
 * //       │                         ┌─────────┐  
 * //       ▼                         ▼         ▼  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ A │                     │ A │     │A1 │
 * //     └───┘                     └───┘     └───┘
 * //       │       ──depth=3─▶       │         │  
 * //       ▼                         ▼         ▼  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ B │                     │ B │     │B1 │
 * //     └───┘                     └───┘     └───┘
 * //       │                         │         │  
 * //      │▼                         ▼         ▼  
 * //   ┌──┼────┐                   ┌───┐     ┌───┐
 * //   │'a│bc' │                   │'a'│     │'bc│
 * //   └──┼────┘                   └───┘     └───┘
 * //      │                                       
 * //   cursor                                    
 * //
 * 
 * const newDocument = controller.commands('splitBlockAtRange', cursor, 3);
 *                                                      
 * ```
 */

function splitBlockAtRange(controller, selection, depth) {
  if (depth === void 0) {
    depth = 1;
  }

  var range = selection;
  var value = controller.value;
  var _value = value,
      document = _value.document;

  if (range.isCollapsed && range.anchor.isEdgePoint()) {
    // 对于 edge selection，做特殊处理。
    var point = range.anchor;
    var isAtBefore = point.edge === EdgePoint.BEFORE;
    controller.command(insertEmptyBlock, point);

    if (isAtBefore) {
      controller.command(select, range);
    }

    return controller;
  }

  range = deleteExpandedAtRange(controller, range);

  var _range$convertToTextP = range.convertToTextPoints(document),
      start = _range$convertToTextP.start,
      end = _range$convertToTextP.end;

  var node = document.assertNode(start.key);
  var parent = document.getClosestBlock(node.key);
  var d = 0;

  while (parent && d < depth) {
    node = parent;
    parent = document.getClosestBlock(parent.key);
    d++;
  }

  return controller.withoutNormalizing(function () {
    controller.command(splitDescendantsByKey, node.key, start.key, start.offset);
    value = controller.value;
    document = value.document;

    if (range.isExpanded) {
      if (range.isBackward(document)) range = range.flip();
      var nextBlock = document.getNextBlock(node.key);
      range = range.moveAnchorToStartOfNode(nextBlock, controller);

      if (start.key === end.key) {
        range = range.moveFocusTo(range.anchor.key, end.offset - start.offset);
      }

      controller.command('deleteAtRange', range);
    }
  });
}
/**
 * 在当前选区拆分 Inline
 * 
 * @param controller
 * @param depth 对于嵌套结构，可以指定拆分深度，默认拆分深度为 1 ，即只拆分距选区最近的 Inline
 * @returns
 * @example
 * 
 * ```ts
 * // 
 * //   ┌───────┐                      ┌───────┐   
 * //   │ root  │                      │ root  │   
 * //   └───────┘                      └───────┘   
 * //       │                              │       
 * //       ▼                              ▼       
 * //     ┌───┐                          ┌───┐     
 * //     │ A │                          │ A │     
 * //     └───┘                          └───┘     
 * //       │       ──depth=3─▶            │       
 * //       ▼                         ┌─────────┐  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ B │                     │ B │     │B1 │
 * //     └───┘                     └───┘     └───┘
 * //       │                         │         │  
 * //      │▼                         ▼         ▼  
 * //   ┌──┼────┐                   ┌───┐     ┌───┐
 * //   │'a│bc' │                   │'a'│     │'bc│
 * //   └──┼────┘                   └───┘     └───┘
 * //      │                                       
 * //   cursor                                    
 * //
 * 
 * const newDocument = controller.commands('splitInline');
 * 
 *  * // 
 * //   ┌───────┐                      ┌───────┐   
 * //   │ root  │                      │ root  │   
 * //   └───────┘                      └───────┘   
 * //       │                         ┌─────────┐  
 * //       ▼                         ▼         ▼  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ A │                     │ A │     │A1 │
 * //     └───┘                     └───┘     └───┘
 * //       │       ──depth=3─▶       │         │  
 * //       ▼                         ▼         ▼  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ B │                     │ B │     │B1 │
 * //     └───┘                     └───┘     └───┘
 * //       │                         │         │  
 * //      │▼                         ▼         ▼  
 * //   ┌──┼────┐                   ┌───┐     ┌───┐
 * //   │'a│bc' │                   │'a'│     │'bc│
 * //   └──┼────┘                   └───┘     └───┘
 * //      │                                       
 * //   cursor                                    
 * //
 * 
 * const newDocument = controller.commands('splitInline', 3);
 *                                                      
 * ```
 */

function splitInline(controller, depth) {
  if (depth === void 0) {
    depth = 1;
  }

  deleteExpanded(controller);
  var selection = controller.value.selection;
  return controller.command(splitInlineAtRange, selection, depth);
}
/**
 * 在指定选区区间拆分 Inline
 * @param controller
 * @param selection
 * @param depth 对于嵌套结构，可以指定拆分深度，默认拆分深度为 Infinity ，即从根节点开始拆分 Inline
 * @returns
 * @example
 * 
 * ```ts
 * //
 * //   ┌───────┐                      ┌───────┐   
 * //   │ root  │                      │ root  │   
 * //   └───────┘                      └───────┘   
 * //       │                         ┌─────────┐  
 * //       ▼                         ▼         ▼  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ A │                     │ A │     │A1 │
 * //     └───┘                     └───┘     └───┘
 * //       │   ──depth=Infinity─▶    │         │  
 * //       ▼                         ▼         ▼  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ B │                     │ B │     │B1 │
 * //     └───┘                     └───┘     └───┘
 * //       │                         │         │  
 * //      │▼                         ▼         ▼  
 * //   ┌──┼────┐                   ┌───┐     ┌───┐
 * //   │'a│bc' │                   │'a'│     │'bc│
 * //   └──┼────┘                   └───┘     └───┘
 * //      │                                       
 * //   cursor                                    
 * // 
 * 
 * const newDocument = controller.commands('splitInlineAtRange', cursor);
 * 
 * // 
 * //   ┌───────┐                      ┌───────┐   
 * //   │ root  │                      │ root  │   
 * //   └───────┘                      └───────┘   
 * //       │                              │       
 * //       ▼                              ▼       
 * //     ┌───┐                          ┌───┐     
 * //     │ A │                          │ A │     
 * //     └───┘                          └───┘     
 * //       │       ──depth=1─▶            │       
 * //       ▼                         ┌─────────┐  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ B │                     │ B │     │B1 │
 * //     └───┘                     └───┘     └───┘
 * //       │                         │         │  
 * //      │▼                         ▼         ▼  
 * //   ┌──┼────┐                   ┌───┐     ┌───┐
 * //   │'a│bc' │                   │'a'│     │'bc│
 * //   └──┼────┘                   └───┘     └───┘
 * //      │                                       
 * //   cursor                                    
 * 
 * const newDocument = controller.commands('splitInlineAtRange', cursor, 1);
 *                                                      
 * ```
 */

function splitInlineAtRange(controller, range, depth) {
  if (depth === void 0) {
    depth = Infinity;
  }

  range = deleteExpandedAtRange(controller, range);
  var value = controller.value;
  var document = value.document;
  var start = range.getStart(document);
  var node = document.assertNode(start.key);
  var parent = document.getClosestInline(node.key);
  var d = 0;

  while (parent && Inline.isInline(parent) && d < depth) {
    node = parent;
    parent = document.getClosestInline(parent.key);
    d++;
  }

  return controller.command(splitDescendantsByKey, node.key, start.key, start.offset);
}

var insertBlockTpl = function insertBlockTpl() {
  return 'cj/cmd/insblock';
};
var insertInlineTpl = function insertInlineTpl() {
  return 'cj/cmd/insinline';
};
var insertTpl = function insertTpl(path) {
  return "cj/cmd/ins(" + JSON.stringify(path) + ")";
};

/* eslint-disable no-param-reassign */
/**
 * 在指定位置，插入一个node
 * @key 插入目标节点
 * @index 插入后在目标节点的顺序
 */

function insertNodeByKey(controller, key, index, node) {
  var value = controller.value;
  var document = value.document;
  var path = document.assertPath(key);
  return controller.command(insertNodeByPath, path, index, node);
}
/**
 * 在指定位置，插入一个node
 * @path 插入目标节点
 * @index 插入后在目标节点的顺序
 */

function insertNodeByPath(controller, path, index, node) {
  var insertPath = [].concat(path, [index]);
  return controller.withOpContext(insertTpl(insertPath), function () {
    return controller.applyOperation({
      type: OperationType.InsertNode,
      path: insertPath,
      node: node
    });
  });
}

function isBlockEmpty(controller, block) {
  return !controller.query('isVoid', block) && controller.query('isEmpty', block) && block.text === '' && !block.findDescendant(function (n) {
    return controller.query('isVoid', n);
  });
}
/**
 * 在当前选区插入一段文字，并附带marks。
 * 1. marks：会从参数里获取；如果参数没有提供，会尝试从当前selection获取；如果依然没有，就从当前的插入位置获取
 */


function insertText$1(controller, text, ms) {
  var value = controller.value;
  var document = value.document,
      selection = value.selection;

  if (!selection) {
    return controller;
  }

  var marks = ms || selection.marks || document.getInsertMarksAtRange(selection);
  return controller.command(insertTextAtRange, selection, text, marks);
}
/**
 * 在 EdgePoint 的 before 或者 after 位置，插入一个空白的段落。
 */

function insertEmptyBlock(controller, at) {
  var document = controller.value.document;
  var block = document.getNode(at.key);
  var parent = document.getParent(at.key);
  var isAtBefore = at.edge === EdgePoint.BEFORE;

  if (!block || !parent || !block.isElement() || !block.isBlock()) {
    return controller;
  }

  var index = parent.nodes.indexOf(block);
  var newBlock = Block.create(Block.DEFAULT_TYPE);
  var insertIndex = isAtBefore ? index : index + 1;
  controller.command(insertNodeByKey, parent.key, insertIndex, newBlock);
  document = controller.value.document;
  var node = newBlock.getFirstNode();
  var anchor = TextPoint.create({
    key: node.key,
    offset: 0
  });
  var focus = anchor;
  return controller.command(select, Selection.create({
    anchor: anchor,
    focus: focus
  }));
}
/**
 * 在目标位置插入一段文字，并附带marks。
 * 1. 目标位置需要对应一个Text节点，否则会抛出异常
 * 2. marks：会从参数里获取；如果参数没有提供，会尝试从当前的插入位置获取
 */

function insertTextAtRange(controller, r, text, marks) {
  if (r.isCollapsed && r.anchor.isEdgePoint()) {
    controller.command(insertEmptyBlock, r.anchor);
    var textNode = controller.value.focusText;

    if (!textNode) {
      return controller;
    }

    return controller.command(insertTextByKey, textNode.key, 0, text, marks);
  }

  var range = r.isExpanded ? deleteExpandedAtRange(controller, r) : r;
  var value = controller.value;
  var document = value.document;

  var _range$convertToTextP = range.convertToTextPoints(document),
      start = _range$convertToTextP.start;

  var parent = document.getParent(start.key);

  if (controller.query('isVoid', parent)) {
    return controller;
  }

  return controller.command(insertTextByKey, start.key, start.offset, text, marks);
}
/**
 * 在目标位置插入一段文字，并附带marks。
 * 1. 目标位置需要对应一个Text节点，否则会抛出异常
 * 2. marks：会从参数里获取；如果参数没有提供，会尝试从当前的插入位置获取
 */

function insertTextByKey(controller, key, offset, text, marks) {
  var value = controller.value;
  var document = value.document;
  var path = document.assertPath(key);
  return controller.command(insertTextByPath, path, offset, text, marks);
}
/**
 * 在目标位置插入一段文字，并附带marks。
 * 1. 目标位置需要对应一个Text节点，否则会抛出异常
 * 2. marks：会从参数里获取；如果参数没有提供，会尝试从当前的插入位置获取
 */

function insertTextByPath(controller, path, offset, text, ms) {
  var value = controller.value;
  var document = value.document,
      decorations = value.decorations;
  var node = document.assertNodeByPath(path);

  if (!node.isText()) {
    throw new Error("Commands.insertText, target([" + path.join(',') + "] type: " + node.type + ") is not a Text node");
  }

  var marks = ms || node.getMarksAtIndex(offset);
  var updated = false;
  var decs = decorations.filter(function (dec) {
    var start = dec.start,
        end = dec.end,
        mark = dec.mark;
    var isAtomic = controller.query('isAtomic', mark);

    if (!isAtomic) {
      return true;
    }

    var startPath = document.getPath(start.key);

    if (!startPath) {
      updated = true;
      return false;
    }

    if (!Path.isEqual(startPath, path)) {
      return true;
    }

    var endPath = document.getPath(end.key);

    if (!endPath) {
      updated = true;
      return false;
    }

    if (start.offset < offset && (!Path.isEqual(endPath, path) || end.offset > offset)) {
      updated = true;
      return false;
    }

    return true;
  });

  if (updated) {
    controller.setValue(value.set('decorations', decs), {
      normalize: false
    });
  }

  return controller.applyOperation({
    type: OperationType.InsertText,
    path: path,
    offset: offset,
    text: text || '',
    marks: marks.map(Mark.create)
  });
}
/**
 * 在指定的选区的start位置，插入一个block。
 * 1. 如果start节点在开始/结束位置，或者start节点是个空block，则直接插入；否则先split，后插入
 */

function insertBlockAtRange(controller, range, block) {
  var newRange = deleteExpandedAtRange(controller, range);
  var value = controller.value;
  var document = value.document;

  var _newRange$convertToTe = newRange.convertToTextPoints(document),
      start = _newRange$convertToTe.start;

  var startKey = start.key,
      startOffset = start.offset;
  var startBlock = document.getClosestBlock(startKey);
  var startInline = document.getClosestInline(startKey);
  var parent = document.getParent(startBlock.key);
  var index = parent.nodes.indexOf(startBlock);
  controller.withOpContext(insertBlockTpl(), function () {
    if (newRange.anchor.isEdgePoint()) {
      // If we insert block at edge point.
      controller.command(insertNodeByKey, parent.key, index + (newRange.anchor.edge === 'before' ? 0 : 1), block);
    } else if (!startInline && startBlock.text === '') {
      // if we insert block at an empty block
      controller.command(insertNodeByKey, parent.key, index + 1, block);
    } else if (start.isAtStartOfNode(startBlock)) {
      controller.command(insertNodeByKey, parent.key, index, block);
    } else if (start.isAtEndOfNode(startBlock)) {
      controller.command(insertNodeByKey, parent.key, index + 1, block);
    } else {
      // If we're in the middle of a block, we should consider split it first
      // If we're in a void inline, we should move cursor to the sibliting text of the inline before spliting
      if (startInline && controller.query('isVoid', startInline)) {
        var atEnd = start.isAtEndOfNode(startInline);
        var siblingText = atEnd ? document.getNextText(startKey) : document.getPreviousText(startKey);
        var splitRange = atEnd ? newRange.moveToStartOfNode(siblingText, controller) : newRange.moveToEndOfNode(siblingText, controller);

        var _splitRange$convertTo = splitRange.convertToTextPoints(controller.value.document),
            anchor = _splitRange$convertTo.anchor;

        startKey = anchor.key;
        startOffset = anchor.offset;
      }

      controller.withoutNormalizing(function () {
        controller.command(splitDescendantsByKey, startBlock.key, startKey, startOffset);
        controller.command(insertNodeByKey, parent.key, index + 1, block);
      });
    }
  });
  return controller;
}
/**
 * 在当前选区位置，插入一个block。
 * 1. 如果当前选区是expand，会先执行删除选区操作。
 * 2. 如果start节点在开始/结束位置，或者start节点是个空block，则直接插入；否则先split，后插入
 * @blockProps block或者block参数，会传递给Block.create来创建一个block
 */

function insertBlock(controller, blockProps) {
  var selection = controller.value.selection;
  var block = Block.create(blockProps);
  controller.command(insertBlockAtRange, deleteExpandedAtRange(controller, selection), block); // move to end of inserted block

  var node = controller.value.document.getNode(block.key);

  if (node) {
    controller.command(moveToEndOfNode, node);
  }

  return controller;
}
/**
 * 在当前选区位置，插入一个inline。
 * 1. 如果当前选区是expand，会先执行删除选区操作。
 */

function insertInlineAtRange(controller, range, inline) {
  controller.withOpContext(insertInlineTpl(), function () {
    controller.withoutNormalizing(function () {
      var point = deleteExpandedAtRange(controller, range).anchor;

      if (range.isCollapsed && point.isEdgePoint()) {
        controller.command(insertEmptyBlock, point);
      }

      var _controller$value = controller.value,
          document = _controller$value.document,
          selection = _controller$value.selection;

      var _selection$convertToT = selection.convertToTextPoints(document),
          start = _selection$convertToT.start;

      var parent = document.getParent(start.key);
      var startText = document.assertNode(start.key);
      var index = parent.nodes.indexOf(startText);
      if (controller.query('isVoid', parent)) return;
      controller.command(splitNodeByKey, start.key, start.offset);
      controller.command(insertNodeByKey, parent.key, index + 1, inline);
    });
  });
  return controller;
}
/**
 * 在当前选区位置，插入一个inline。
 * 1. 如果当前选区是expand，会先执行删除选区操作。
 */

function insertInline(controller, inlineProps) {
  var selection = controller.value.selection;
  var inline = Inline.create(inlineProps);
  controller.command(insertInlineAtRange, selection, inline); // move to end of inserted block

  var node = controller.value.document.getNode(inline.key);

  if (node) {
    controller.command(moveToEndOfNode, node);
  }

  return controller;
} // If the fragment is wrapped by/nested in blocks, and the nesting pattern
// already exists at the range, we meld the fragment contents into the
// document’s existing nesting pattern as much as possible
// Given a `fragment`, `document`, and `startKey`, it returns a Node from the
// `fragment` to be inserted into the document. By default, the node returned
// will be the `fragment`, but if a common nesting pattern is detected, a
// sub-node of the fragment will be returned.
// The detection algorithm is as follows:
// 1. Ensure the fragment has a single child node, call it `fragmentInner`
// 2. Find the furthest document ancestor of the `startKey` matching
//    `fragmentInner.type`. Call this `documentInner`
// 3. Drill into both `documentInner` and `fragmentInner` as long as each has
//    a single child node and their types match. The stopping point for the
//    fragment is the sub-node to insert into the document.

var findInsertionNode = function findInsertionNode(fragment, document, startKey) {
  var hasSingleNode = function hasSingleNode(object) {
    if (!object || Text$1.isText(object)) {
      return false;
    }

    return object.nodes.length === 1;
  };

  var firstNode = function firstNode(object) {
    return object && object.nodes[0];
  };

  var node = fragment;

  if (hasSingleNode(fragment)) {
    var fragmentInner = firstNode(fragment);
    var documentInner = document.getFurthsest(startKey, function (documentNode) {
      if (document instanceof Element$1) {
        return documentNode.type === fragmentInner.type;
      }

      return false;
    });

    if (documentInner === document.getParent(startKey)) {
      node = fragmentInner;
    }

    while (hasSingleNode(fragmentInner) && hasSingleNode(documentInner)) {
      fragmentInner = firstNode(fragmentInner);
      documentInner = firstNode(documentInner);

      if (fragmentInner.type === documentInner.type) {
        node = fragmentInner;
      } else {
        break;
      }
    }
  }

  return node;
};
/**
 * 在目标位置插入一个fragment
 * 1. 内部遍历fragment的每一个node，然后调用Commands.insertNode
 * 2. 如果针对复制粘贴等上层场景，需要考虑key重新生成等逻辑，请使用Commands.insertFragment
 */


function insertFragmentByKey(controller, key, index, fragment) {
  var value = controller.value;
  var document = value.document;
  var path = document.assertPath(key);
  return controller.command(insertFragmentByPath, path, index, fragment);
}
/**
 * 在目标位置插入一个fragment
 * 1. 内部遍历fragment的每一个node，然后调用Commands.insertNode
 * 2. 如果针对复制粘贴等上层场景，需要考虑key重新生成等逻辑，请使用Commands.insertFragment
 */

function insertFragmentByPath(controller, path, index, fragment) {
  fragment.nodes.forEach(function (node, i) {
    controller.command(insertNodeByPath, path, index + i, node);
  });
  return controller;
}
/**
 * 在当前插入一个fragment
 * 1. 内部会处理插入点、插入后的光标行为，以符合用户直觉
 */

function insertFragment(controller, fragment) {
  if (!fragment.nodes.length) {
    return controller;
  } // pre-step, delete the selection is it's expanded


  deleteExpanded(controller); // save the values before insert

  var value = controller.value;
  var _value = value,
      document = _value.document;
  var _value2 = value,
      selection = _value2.selection;

  if (!selection) {
    return controller;
  } // 获取插入位置祖先 Block 元素, 非容器节点插入祖先为 Document、Block, 容器节点插入祖先为 Document、Block、Block...


  var startAncestors = document.getAncestors(selection.anchor.key);
  var lastText = fragment.getLastText();

  if (!lastText) {
    return controller;
  }

  var _selection$sort = selection.sort(document),
      start = _selection$sort.start,
      end = _selection$sort.end;

  var _value3 = value,
      startText = _value3.startText,
      endText = _value3.endText;
  var keys = document.getTexts().map(function (text) {
    return text.key;
  }); // perform insert

  controller.command(insertFragmentAtRange, selection, fragment); // get the new values after insert

  value = controller.value;
  var _value4 = value;
  document = _value4.document;
  selection = value.selection;
  var updatedTexts = document.getTexts();
  var newTexts = updatedTexts.filter(function (n) {
    return !keys.includes(n.key);
  });
  var lastNewText = newTexts[newTexts.length - 1]; // selection - take the selection back if it's removed (e.g. the last one block is deleted)

  if (!selection && updatedTexts.length) {
    var firstText = updatedTexts[0];
    var point = TextPoint.create({
      key: firstText.key,
      offset: 0
    });
    controller.command(select, Selection.create({
      anchor: point,
      focus: point
    }));
  }
  /**
   * 插入 fragment 后移动光标的位置：
   * 1. 首先判断本次插入操作是否有产生新的 text，如果没有产生新 text 节点，则为纯文字的插入，光标会自动校正，不需要处理
   * 2. 若产生了新的 text 节点，则先移动至 lastText 的 end 点
   * 3. 如果插入的过程中产生了对一段文字的后半段做 split 操作，则需要做偏移校正，校正的距离为插入前光标距离末尾的偏移量
   */


  if (lastNewText) {
    controller.command(moveToEndOfNode, lastNewText);
    var blockParent = document.getClosestBlock(lastNewText.key);
    var nextText = blockParent == null ? void 0 : blockParent.getNextText(lastNewText.key); // lastText 节点的 nextText 节点与插入 fragment 前的 endText 相等
    // 这种状况是由于在段落的行首插入一个 inline 元素不会触发 split 操作，这种情况不需要校正偏移量，直接移动至 next 的首位

    if (nextText && nextText.key === end.key) {
      controller.command(moveToStartOfNode, nextText);
    } else if (endText && end.isTextPoint()) {
      // 如果 nextText 节点不相等，则说明出现了文字截断，此时要做偏移位校正，校正时需要先从光标点位和字符串中取分割的文字串，然后再计算字数
      // 注意这里有个小问题：Point 的 offset 表示的是字符的偏移量，但是 moveBackward 方法是做的字偏移，所以要计算 Unicode 字
      // 关于 Unicode 的一个小问题：存在一种组合 Unicode 会导致字数计算有偏差，例如【👩‍ 🦱】，如果将空格删除，则两个 emoji 会合并，这种组合性的 emoji 在
      // 字数计算的时候会被拆分出来成 2 个字
      var subText = endText.text.substring(end.offset);
      var offsetToEnd = GraphemesBreaker.countBreaks(subText);
      var firstChildHasBlockChildren = fragment.nodes[0].hasBlockChildren();
      var startBlock = startText && document.getClosestBlock(startText.key);
      var isAtStartOfUnEmptyNode = startBlock && start.isAtStartOfNode(startBlock);

      if (firstChildHasBlockChildren && isAtStartOfUnEmptyNode) ; else {
        controller.command(moveBackward, offsetToEnd);
      }

      var subRoot = document.getAncestors(lastNewText.key)[1]; // 插入 Void Block 节点时，光标移到 Block 节点外部

      if ( // 根据祖先元素长度判断是否在容器节点内插入内容, 如果根节点下插入容器节点，插入后光标最后移出容器
      // 如果在容器内插入普通节点，光标保持在容器内部
      startAncestors.length <= 2 && controller.query('isEdgeSelectable', subRoot) && subRoot.getLastText() === lastNewText) {
        controller.command(moveToStartOfNextBlock);
      }
    }

    if (controller.value.selection.isExpanded) {
      controller.command(moveToStart);
    }
  }

  return controller;
}
/**
 * 在指定的选区插入一个fragment
 * 1. 如果选区是expand，会先删除选区
 */

function insertFragmentAtRange(controller, range, fragment) {
  if (!fragment.nodes.length) {
    return controller;
  }

  return controller.withoutNormalizing(function () {
    range = deleteExpandedAtRange(controller, range);

    if (range.isCollapsed && range.anchor.isEdgePoint()) {
      controller.command(insertEmptyBlock, range.anchor);
      range = controller.value.selection;
    }

    fragment = fragment.mapDescendants(function (child) {
      return child.regenerateKey();
    }); // NOTE: 这里调用 command key 试插件 onCommand 时间触发，主要用于图片的复制转存逻辑
    // TODO: 在 model 增加一个可以不计入 asl 的 attributes，用于存储 key

    controller.command('insertFragmentWithRealKeyAtRange', range, fragment);
  });
}
/**
 * 在指定的选区插入一个fragment
 * 1. fragment必须包含有效的无冲突的key
 */

function insertFragmentWithRealKeyAtRange(controller, range, fragment) {
  var value = controller.value;
  var document = value.document; // checking the start point

  var _range$convertToTextP2 = range.convertToTextPoints(document),
      start = _range$convertToTextP2.start,
      end = _range$convertToTextP2.end;

  var startText = document.getNode(start.key);
  var startBlock = document.getClosestBlock(startText.key);
  var startChild = startBlock.getFurthestAncestor(startText.key);
  var isAtStart = start.isAtStartOfNode(startBlock);
  var isAtEnd = end.isAtEndOfNode(startBlock);
  var parent = document.getParent(startBlock.key);
  var index = parent.nodes.indexOf(startBlock);
  var blocks = fragment.getBlocks();

  if (blocks.length === 0) {
    return controller;
  }

  var firstChild = fragment.nodes[0];
  var lastChild = fragment.nodes[fragment.nodes.length - 1];
  var firstBlock = blocks[0];
  var lastBlock = blocks[blocks.length - 1];
  var insertionNode = findInsertionNode(fragment, document, startBlock.key); // 设置用户数据

  controller.userData.mergeUserData(fragment); // If the new fragment only contains a void block, use `insertBlockAtRange`

  if (firstBlock === lastBlock && controller.query('isVoid', firstBlock) && !controller.query('isContainer', insertionNode)) {
    controller.command(insertBlockAtRange, range, firstBlock);
    return controller;
  } // If the new fragment starts or ends with a single nested block,
  // e.g. a table, use `insertBlockAtRange`


  var firstChildHasBlockChildren = firstChild.hasBlockChildren();
  var lastChildHasBlockChildren = lastChild.hasBlockChildren();

  if (insertionNode === fragment && (firstChildHasBlockChildren || lastChildHasBlockChildren)) {
    // 如果插入的第一个节点是一个容器节点：
    //
    // Fragment:
    // ```tsx
    // <document>
    //   <block>
    //     <block>Hello</block>
    //     <block>World</block>
    //   </block>
    //   <block>Cangjie</block>
    // </document>
    // ```
    //
    // 插入到光标位置
    // ```tsx
    // <document>
    //   <block>Intro<cursor />123</block>
    //   <block>Command</block>
    // </document>
    // ```
    //
    // 期望是
    // ```tsx
    // <document>
    //   <block>Intro</block>
    //   <block>
    //     <block>Hello</block>
    //     <block>World</block>
    //   </block>
    //   <block>Cangjie</block>
    //   <block>123</block>
    //   <block>Command</block>
    // </document>
    // ```
    //
    if (firstChildHasBlockChildren) {
      // 非空节点插入内容，不需要进行 reverse
      var isAtStartOfUnEmptyNode = start.isAtStartOfNode(startBlock);
      var nodes = isAtStartOfUnEmptyNode ? fragment.nodes : [].concat(fragment.nodes).reverse();
      nodes.forEach(function (node) {
        controller.command(insertBlockAtRange, range, node);
      });
      return controller;
    } // 如果插入的最后一个节点是一个容器节点：
    //
    // Fragment:
    // ```tsx
    // <document>
    //   <block>Cangjie</block>
    //   <block>
    //     <block>Hello</block>
    //     <block>World</block>
    //   </block>
    // </document>
    // ```
    //
    // 插入到光标位置
    // ```tsx
    // <document>
    //   <block>Intro<cursor />123</block>
    // </document>
    // ```
    //
    // 期望是
    // ```tsx
    // <document>
    //   <block>IntroCangjie</block>
    //   <block>
    //     <block>Hello</block>
    //     <block>World</block>
    //   </block>
    //   <block>123</block>
    // </document>
    // ```
    //


    if (lastChildHasBlockChildren) {
      // 插入最后一个节点，再在原位置插入剩余节点
      controller.command(insertBlockAtRange, range, lastChild);
      var rest = fragment.removeNode([fragment.nodes.length - 1]);

      if (rest.nodes.length) {
        controller.command(insertFragmentWithRealKeyAtRange, range, rest);
      }
    }

    return controller;
  } // If the first and last block aren't the same, we need to insert all of the
  // nodes after the insertion node's first block at the index.


  if (firstBlock !== lastBlock) {
    var lonelyParent = insertionNode.getFurthsest(firstBlock.key, function (p) {
      return p.nodes.length === 1;
    });
    var lonelyChild = lonelyParent || firstBlock;
    var startIndex = parent.nodes.indexOf(startBlock);
    var excludingLonelyChild = insertionNode.removeNode(insertionNode.assertPath(lonelyChild.key));
    excludingLonelyChild.nodes.forEach(function (node, i) {
      var newIndex = startIndex + i + 1;
      controller.command(insertNodeByKey, parent.key, newIndex, node);
    });
  } // Check if we need to split the node.


  if (start.offset !== 0) {
    controller.command(splitDescendantsByKey, startChild.key, start.key, start.offset);
  }

  document = controller.value.document;
  startText = document.getNode(start.key);
  startBlock = document.getClosestBlock(start.key);
  parent = document.getParent(startBlock.key);
  startChild = startBlock.getFurthestAncestor(startText.key);

  if (firstBlock !== lastBlock) {
    var nextChild = isAtStart ? startChild : startBlock.getNextSibling(startChild.key);
    var nextNodes = nextChild ? listUtils.skipUntil(startBlock.nodes, function (n) {
      return n.key === nextChild.key;
    }) : [];
    var block = document.assertElement(lastBlock.key);

    if (!controller.query('isVoid', block)) {
      // 如果插入的最后一个节点是非 void block，则 split 后的 nodes 可以追加到 block 末尾
      // Fragment:
      // ```ts
      // <document>
      //   <block>Hello</block>
      //   <block>World</block>
      // </document>
      // ```
      //
      // 在如下光标位置插入:
      // ```ts
      // <document>
      //   <block>123<cursor />45</block>
      // </document>
      // ```
      //
      // 期望的插入结果是:
      // ```ts
      // <document>
      //   <block>123Hello</block>
      //   <block>World45</block>
      // </document>
      // ```
      var moveTo = block.nodes.length;
      nextNodes.forEach(function (node, i) {
        var newIndex = moveTo + i;
        controller.command(moveNodeByKey, node.key, block.key, newIndex);
      });
    } else {
      // 如果插入的最后一个节点是 void block，则 split 后的 nodes 可以插入到 block 之后
      // Fragment:
      // ```ts
      // <document>
      //   <block>Hello</block>
      //   <void-block />
      // </document>
      // ```
      //
      // 在如下光标位置插入:
      // ```ts
      //   <document>
      //     <block>123<cursor />45</block>
      //   </document>
      // ```
      //
      // 期望的插入结果为:
      // ```ts
      //   <document>
      //     <block>123Hello</block>
      //     <void-block />
      //     <block>45</block>
      //   </document>
      // ```
      var insertAt = document.assertElement(parent.key).nodes.indexOf(block) + 1;
      nextNodes.forEach(function (node) {
        controller.command(removeNodeByKey, node.key);
      }); // 新插入的节点继承原 block 的属性

      var restBlock = startBlock.set('nodes', nextNodes).regenerateKey();

      if (!isAtEnd) {
        controller.command(insertNodeByKey, parent.key, insertAt, restBlock);
      }
    }
  }

  if (isBlockEmpty(controller, startBlock)) {
    // 如果 start block 为空，则直接替换 start block 为待插入的 first block
    // 是否为空的断言需要插件实现 `isEmpty`，即由插件决定某个元素是否可以被判定为空，且被替换
    // Fragment:
    // ```ts
    //   <document>
    //     <block>Hello</block>
    //     <block>World</block>
    //   </document>
    // ```
    //
    // 在如下光标位置插入:
    // ```ts
    //   <document>
    //     <block><cursor /></block>
    //   </document>
    // ```
    //
    // 期望的插入结果是:
    // ```ts
    // <document>
    //   <block>Hello</block>
    //   <block>World</block>
    // </document>
    // ```
    controller.command(insertNodeByKey, parent.key, index, firstBlock).command(removeNodeByKey, startBlock.key);
  } else {
    // 否则，保留 start block，并在 start block 的分裂位置插入 first block 的子孙
    // 1. first block is non-void
    // Fragment:
    // ```ts
    // <document>
    //   <block>Hello</block>
    //   <block>World</block>
    // </document>
    // ```
    //
    // 在如下光标位置插入:
    // ```ts
    // <document>
    //   <block>Cangjie<cursor /></block>
    // </document>
    // ```
    //
    // 期望的插入结果是:
    // ```ts
    // <document>
    //   <block>CangjieHello</block>
    //   <block>World</block>
    // </document>
    // ```
    //
    // 2. first block is void
    // Fragment:
    // ```ts
    // <document>
    //   <void-block />
    //   <block>World</block>
    // </document>
    // ```
    //
    // 在如下光标位置插入:
    // ```ts
    // <document>
    //   <block>Cangjie<cursor /></block>
    // </document>
    // ```
    //
    // 期望的插入结果是:
    // ```ts
    // <document>
    //   <block>Cangjie</block>
    //   <void-block />
    //   <block>World</block>
    // </document>
    // ```
    // 否则，保留 start block，并在 start block 的分裂位置插入 first block 的子孙
    var inlineChild = startBlock.getFurthestAncestor(startText.key);
    var inlineIndex = startBlock.nodes.indexOf(inlineChild);

    if (controller.query('isVoid', firstBlock)) {
      var _insertAt = parent.nodes.indexOf(startBlock) + 1;

      controller.command(insertNodeByKey, parent.key, _insertAt, firstBlock);
    } else {
      firstBlock.nodes.forEach(function (inline, i) {
        var o = start.offset === 0 ? 0 : 1;
        var newIndex = inlineIndex + i + o;
        controller.command(insertNodeByKey, startBlock.key, newIndex, inline);
      });
    }
  }

  return controller;
}

var mergeTpl = function mergeTpl(node, path) {
  return "cj/cmd/merge_" + (node.isElement() ? 'node' : 'text') + "(" + JSON.stringify(path) + ")";
};

/**
 * @packageDocumentation
 * @module Commands
 */
/**
 * 把目标 path 的 Node，合并到其上一个 Sibling 上。
 * 1. 必须满足 Node 和上一个 Sibling 是同一种类型。
 * 2. 如果没有上一个 Sibling，直接抛异常。
 */

function mergeNodeByKey(controller, key) {
  var value = controller.value;
  var document = value.document;
  var path = document.assertPath(key);
  return controller.command(mergeNodeByPath, path);
}
/**
 * 把目标 path 的 Node，合并到其上一个 Sibling 上。
 * 1. 必须满足 Node 和上一个 Sibling 是同一种类型。
 * 2. 如果没有上一个 Sibling，直接抛异常。
 */

function mergeNodeByPath(controller, path) {
  var value = controller.value;
  var document = value.document;
  var original = document.getNodeByPath(path);
  var previous = original ? document.getPreviousSibling(original.key) : null;

  if (!previous) {
    throw new Error("Unable to merge node with path \"" + path + "\", because it has no previous sibling.");
  }

  if (previous.constructor !== original.constructor) {
    throw new Error("Unable to merge two different kinds of nodes: " + previous + " and " + original);
  }

  var previousPath = document.getPath(previous.key);
  var previousNode = previous.toSubType();
  var position = previousNode.isText() ? previousNode.text.length : previousNode.nodes.length;
  controller.withOpContext(mergeTpl(original, path), function () {
    controller.withoutNormalizing(function () {
      if (original.isElement()) {
        var moveNodePath = [].concat(path, [0]);
        original.nodes.forEach(function (node, index) {
          controller.command(moveNodeByPath, moveNodePath, previousPath, position + index);
        });
        controller.command(removeNodeByPath, path);
      } else {
        var _ref = original,
            leaves = _ref.leaves;
        var offset = previousNode.text.length;
        var _controller$value = controller.value,
            selection = _controller$value.selection,
            decorations = _controller$value.decorations;
        leaves.forEach(function (leaf) {
          controller.command(insertTextByPath, previousPath, offset, leaf.text, leaf.marks);
          offset += leaf.text.length;
        });
        controller.command(removeNodeByPath, path); // 处理 updatePoints 的问题；具体请参考 split 中同样的处理

        var valueToUpdate = controller.value.set('decorations', decorations).set('selection', selection);
        var updatedValue = valueToUpdate.updatePoints(valueToUpdate.document, function (point) {
          if (point.key === original.key) {
            return point.merge({
              key: previousNode.key,
              offset: point.offset + position
            });
          }

          return point;
        });
        controller.setValue(updatedValue, {
          clearOperations: false
        });
      }
    });
  });
  return controller;
}

/**
 * @packageDocumentation
 * @module Commands
 */
/**
 * 在当前选区，添加mark
 * 1. 如果选区是expand，会设置当前选中内容的mark
 * 2. 如果选区是collapse，会把m和当前的选区的marks，一起合并到当前selection内
 */

function addMark(controller, m) {
  var mark = Mark.create(m);
  var value = controller.value;
  var document = value.document,
      selection = value.selection;

  if (selection.isExpanded) {
    controller.command(addMarkAtRange, selection, mark);
  } else {
    var activeMarks = selection.marks || document.getActiveMarksAtRange(selection);
    var sel = selection.set('marks', setUtils.add(activeMarks, mark));
    controller.command('select', sel);
  }

  return controller;
}
/**
 * 对指定的选区内，增加mark
 * 1. 如果选区是collapse，则什么都不做
 */

function addMarkAtRange(controller, range, mark) {
  if (range.isCollapsed) return controller;
  var value = controller.value;
  var document = value.document;

  var _range$convertToTextP = range.convertToTextPoints(document),
      start = _range$convertToTextP.start,
      end = _range$convertToTextP.end;

  var texts = document.getTextsAtRange(range);
  controller.withoutNormalizing(function () {
    texts.forEach(function (node) {
      var key = node.key;
      var offset = 0;
      var length = node.text.length;

      if (key === start.key) {
        offset = start.offset;
      }

      if (key === end.key) length = end.offset;

      if (key === start.key && key === end.key) {
        length = end.offset - start.offset;
      }

      controller.command(addMarkByKey, key, offset, length, mark);
    });
  });
  return controller;
}
/**
 * 对指定的选区内，增加mark
 * 1. 如果选区是collapse，则什么都不做
 */

function addMarkByKey(controller, key, offset, length, mark) {
  var value = controller.value;
  var document = value.document;
  var path = document.assertPath(key);
  return controller.command(addMarkByPath, path, offset, length, mark);
}
/**
 * 对一个text节点的一部分文字，增加mark
 * 1. 如果目标无效，或者不是一个text，则什么都不做
 */

function addMarkByPath(controller, path, offset, length, mark) {
  var node = controller.value.document.getNodeByPath(path);
  if (!node || !Text$1.isText(node)) return controller; // Text start offset

  var bx = offset; // Text end offset

  var by = offset + length; // Current Leaf start offset

  var o = 0;
  node.leaves.forEach(function (leaf) {
    // Leaf start offset
    var ax = o; // Leaf end offset

    var ay = ax + leaf.text.length; // 叠加偏移量

    o += leaf.text.length; // If the leaf doesn't overlap with the operation, continue on.

    if (ay < bx || by < ax) return; // If the leaf already has the mark, continue on.

    if (leaf.marks.find(function (m) {
      return m.isEqual(mark);
    })) return; // Otherwise, determine which offset and characters overlap.

    var start = Math.max(ax, bx);
    var end = Math.min(ay, by);
    controller.applyOperation({
      type: OperationType.AddMark,
      path: path,
      offset: start,
      length: end - start,
      mark: mark
    });
  });
  return controller;
}
/**
 * 在当前选区，添加marks
 * 1. 如果选区是expand，会设置当前选中内容的marks
 * 2. 如果选区是collapse，会把marks和当前的选区的marks，一起合并到当前selection内
 */

function addMarks(controller, marks) {
  marks.forEach(function (mark) {
    return controller.command(addMark, mark);
  });
  return controller;
}
/**
 * 对指定的选区内，增加marks
 * 1. 如果选区是collapse，则什么都不做
 */

function addMarksAtRange(controller, range, marks) {
  marks.forEach(function (mark) {
    return controller.command(addMarkAtRange, range, mark);
  });
  return controller;
}
/**
 * 在当前的选区内，toggleMark
 * 1. 如果选区是expand，会设置到当前选中内容
 * 2. 如果选区是collapse，会设置到当前的selection
 */

function toggleMark(controller, m) {
  var mark = Mark.create(m);
  var value = controller.value;
  var selection = value.selection,
      document = value.document;

  if (selection.isExpanded) {
    return controller.command(toggleMarkAtRange, selection, mark);
  }

  var activeMarks = selection.marks || document.getActiveMarksAtRange(selection);
  var newMarks = setUtils.has(activeMarks, mark) ? setUtils.remove(activeMarks, mark) : setUtils.add(activeMarks, mark);
  var sel = selection.set('marks', newMarks);
  return controller.command('select', sel);
}
/**
 * 在指定的选区内，toggleMark
 * 1. 如果选区是collapse，什么都不做
 */

function toggleMarkAtRange(controller, range, m) {
  if (range.isCollapsed) {
    return controller;
  }

  var mark = Mark.create(m);
  var value = controller.value;
  var document = value.document;
  var activeMarks = document.getActiveMarksAtRange(range);

  if (setUtils.has(activeMarks, mark)) {
    controller.command(removeMarkAtRange, range, mark);
  } else {
    controller.command(addMarkAtRange, range, mark);
  }

  return controller;
}
/**
 * 在当前的选区内，删除mark
 * 1. 如果选区是expand，会设删除当前选中内容的mark
 * 2. 如果选区是collapse，会删除当前的selection的mark
 */

function removeMark(controller, m) {
  var mark = Mark.create(m);
  var value = controller.value;
  var document = value.document,
      selection = value.selection;

  if (selection.isExpanded) {
    return controller.command(removeMarkAtRange, selection, mark);
  }

  var activeMarks = selection.marks || document.getActiveMarksAtRange(selection);
  var sel = selection.set('marks', setUtils.remove(activeMarks, mark));
  return controller.command('select', sel);
}
/**
 * 在指定的选区内，删除mark
 * 1. 如果选区是collapse，什么都不做
 */

function removeMarkAtRange(controller, range, mark) {
  if (range.isCollapsed) return controller;
  var value = controller.value;
  var document = value.document;

  var _range$convertToTextP2 = range.convertToTextPoints(document),
      start = _range$convertToTextP2.start,
      end = _range$convertToTextP2.end;

  var texts = document.getTextsAtRange(range);
  controller.withoutNormalizing(function () {
    texts.forEach(function (node) {
      var key = node.key;
      var offset = 0;
      var length = node.text.length;

      if (key === start.key) {
        offset = start.offset;
      }

      if (key === end.key) length = end.offset;

      if (key === start.key && key === end.key) {
        length = end.offset - start.offset;
      }

      controller.command(removeMarkByKey, key, offset, length, mark);
    });
  });
  return controller;
}
/**
 * 对指定的节点，删除mark
 * 1. 如果指定的节点无效，会抛异常
 */

function removeMarkByKey(controller, key, offset, length, mark) {
  var value = controller.value;
  var document = value.document;
  var path = document.assertPath(key);
  return controller.command(removeMarkByPath, path, offset, length, mark);
}
/**
 * 对指定的节点，删除mark
 * 1. 如果指定的节点无效，会抛异常
 */

function removeMarkByPath(controller, path, offset, length, mark) {
  var text = controller.value.document.getNodeByPath(path);
  var totalOffset = 0;
  text.leaves.forEach(function (leaf) {
    // current start offset
    var o = totalOffset;
    var leafLength = leaf.text.length;
    totalOffset += leafLength;
    if (o + leafLength < offset || o > offset + length) return;
    if (!setUtils.has(leaf.marks, mark)) return;
    var start = Math.max(offset, o);
    var end = Math.min(offset + length, o + leafLength);
    controller.applyOperation({
      type: OperationType.RemoveMark,
      path: path,
      offset: start,
      length: end - start,
      mark: mark
    });
  });
  return controller;
}
/**
 * 对指定的节点，替换或者添加mark
 * 1. 如果指定的节点无效，会抛异常
 */

function replaceMark(controller, oldMark, newMark) {
  return controller.command(removeMark, oldMark).command(addMark, newMark);
}

/* eslint-disable prefer-destructuring */
/**
 * 删除 Selection 内的所有内容
 */

function deleteAtRange(controller, range) {
  var value = controller.value;
  var document = value.document;

  var _range$sort = range.sort(document),
      start = _range$sort.start,
      end = _range$sort.end; // edge point - shim them for hanging positions


  if (start.isEdgePoint() && start.edge === EdgePoint.AFTER) {
    start = controller.query(pointAtDistance, start, 1);
  }

  if (end.isEdgePoint() && end.edge === EdgePoint.BEFORE) {
    end = controller.query(pointAtDistance, end, -1);
  }

  var detectSelection = Selection.create({
    anchor: start,
    focus: end
  });

  if (detectSelection.isCollapsedAtEdge || detectSelection.isBackward(document)) {
    return controller;
  } // edge point - delete them


  if (start.isEdgePoint()) {
    var node = controller.value.document.getNode(start.key);
    controller.command(insertEmptyBlock, start).command(removeNodeByKey, start.key);

    if (start.key === end.key || node != null && node.isElement() && node.hasNode(end.key)) {
      return controller;
    } // selection is focused to the new text point


    start = controller.value.selection.anchor;
  }

  if (end.isEdgePoint()) {
    var _node = controller.value.document.getNode(end.key);

    controller.command(insertEmptyBlock, end).command(removeNodeByKey, end.key);

    if (_node != null && _node.isElement() && _node.hasNode(start.key)) {
      return controller;
    } // selection is focused to the new text point


    end = controller.value.selection.anchor;
  }

  document = controller.value.document; // now [start, end] are text points

  var startOffset = start.offset;
  var endOffset = end.offset;
  var startKey = start.key;
  var endKey = end.key;
  var startText = document.assertNode(start.key);
  var endText = document.assertNode(end.key);
  var startBlock = document.assertClosestBlock(startKey);
  var endBlock = document.assertClosestBlock(endKey);
  var isCrossBlock = startBlock.key !== endBlock.key;
  var isStartVoid = document.hasVoidParent(startKey, controller);
  var isEndVoid = document.hasVoidParent(endKey, controller); // BACKGROUND: Hanging Selection
  // If we select from one paragraph start point to another paragraph start point.
  // The selected content user sees is the first paragraph.
  // If we do a delete on hanging selection, we should delete selection that user sees.

  var isHanging = startOffset === 0 && endOffset === 0 && isStartVoid === false && isEndVoid === false && startKey === startBlock.getFirstNode().key && endKey === endBlock.getFirstNode().key && startKey !== endKey; // Remove all text nodes between start block & end block

  controller.withoutNormalizing(function () {
    var removeNode = function removeNode(node) {
      controller.command(removeNodeByKey, node.key);
    }; // In a single text node


    if (startKey === endKey && !isHanging && !isStartVoid) {
      controller.command(removeTextByKey, startKey, startOffset, startText.text.slice(startOffset, endOffset));
      return controller;
    } // Remove selected text in start text node


    if (startText && startText.text.length - startOffset > 0) {
      controller.command(removeTextByKey, startKey, startOffset, startText.text.slice(startOffset));
    } // Remove selected text in end text node


    if (endText && endOffset > 0) {
      controller.command(removeTextByKey, endKey, 0, endText.text.slice(0, endOffset));
    }

    if (startKey !== endKey) {
      // Remove nodes between start text and end text
      var ancestor = document.assertCommonAncestor(startKey, endKey);
      var ancestorNodes = ancestor.nodes;
      var startChild = ancestor.assertFurthestAncestor(startKey);
      var endChild = ancestor.assertFurthestAncestor(endKey); // Remove nodes from bottom to top in start child

      var child = startText;

      while (child.key !== startChild.key) {
        var parent = document.assertParent(child.key);
        var afters = parent.nodes.slice(parent.nodes.indexOf(child) + 1);
        afters.forEach(removeNode);
        child = parent;
      } // Remove nodes between start child & end child


      var middles = ancestorNodes.slice(ancestorNodes.indexOf(startChild) + 1, ancestorNodes.indexOf(endChild));
      middles.forEach(removeNode); // Remove nodes from top to bottom in end child

      child = endText;

      while (child.key !== endChild.key) {
        var _parent = document.assertParent(child.key);

        var befores = _parent.nodes.slice(0, _parent.nodes.indexOf(child));

        befores.forEach(removeNode);
        child = _parent;
      }
    }

    document = controller.value.document; // Find and remove furthest void ancestor

    if (isStartVoid) {
      var startVoidAncestor = document.getFurthsestVoid(startKey, controller);
      var nextText = document.getNextText(startVoidAncestor.key);
      removeNode(startVoidAncestor);

      if (startKey === endKey) {
        return controller;
      } // Move start to the start of next text


      if (!nextText) {
        // If we can't find the next text, we're done
        return controller;
      }

      startKey = nextText.key;
      startOffset = 0;
      document = controller.value.document;
    }

    if (isEndVoid) {
      var endVoidAncestor = document.getFurthsestVoid(endKey, controller);
      var prevText = document.getPreviousText(endVoidAncestor.key);
      removeNode(endVoidAncestor); // Move end to the end of previous text

      if (!prevText) {
        return controller;
      }

      if (startKey === endKey) {
        // endKey is removed!
        startKey = prevText.key;
        startOffset = prevText.text.length;
      }

      endKey = prevText.key;
      endOffset = prevText.text.length;
      document = controller.value.document;
    }

    startBlock = document.getClosestBlock(startKey);
    endBlock = document.getClosestBlock(endKey);

    if (endKey === startKey) {
      if (isHanging) {
        return removeNode(startBlock);
      }

      if (isCrossBlock && document.getPreviousSibling(endBlock.key)) {
        return controller.command(mergeNodeByKey, endBlock.key);
      }
    }

    if (!startBlock) {
      return controller;
    }

    var startParent = document.getParent(startBlock.key);
    var startParentIndex = startParent.nodes.indexOf(startBlock);
    var endParentIndex = startParent.nodes.indexOf(endBlock); // Move the end block into start block and merge them

    if (startBlock.key !== endBlock.key) {
      // If end block's ancestor is empty after merge, we should remove it
      var ancestors = document.getAncestors(endBlock.key);
      var lonely = ancestors ? takeRightWhile( // Ignore document
      ancestors.slice(1), function (node) {
        return node.nodes.length <= 1;
      })[0] : null; // Put end block under the start block

      if (endParentIndex !== startParentIndex + 1) {
        controller.command(moveNodeByKey, endBlock.key, startParent.key, startParentIndex + 1);
      } // If selection is hanging, we should remove start block(what user sees)


      if (isHanging) {
        removeNode(startBlock);
      } else {
        controller.command(mergeNodeByKey, endBlock.key);
      }

      if (lonely) {
        removeNode(lonely);
      }
    }

    return controller;
  });
  document = controller.value.document;

  var _controller$value$sel = controller.value.selection.convertToTextPoints(document),
      rangeStart = _controller$value$sel.start;

  var closest = document.getClosestBlock(rangeStart.key);
  var isEmptyParagraph = Text$1.isTextList(closest == null ? void 0 : closest.nodes) && (closest == null ? void 0 : closest.text) === '';
  return controller.withoutNormalizing(function () {
    var _document$getNextSibl;

    var nextStart = document.getNode(startKey);
    var nextEnd = document.getNode(endKey);
    if (!nextStart && !nextEnd) return;

    if (!nextStart || !nextEnd || nextStart.key === nextEnd.key) {
      // only one or same
      var nextNode = nextStart || nextEnd;

      if (!isEmptyParagraph && Text$1.isText(nextNode) && nextNode.text === '') {
        // don't keep empty text node with marks in non-empty paragraph
        nextNode.marks.forEach(function (mark) {
          controller.command(removeMarkByKey, nextNode.key, 0, 1, mark);
        });
      }

      return;
    }

    var isSibling = ((_document$getNextSibl = document.getNextSibling(nextStart.key)) == null ? void 0 : _document$getNextSibl.key) === nextEnd.key; // start and end is not sibling when one of them in inline node

    if (!isSibling) return;

    if (Text$1.isText(nextEnd) && nextEnd.text === '') {
      // empty end text node is useless
      controller.command(removeNodeByKey, nextEnd.key);
    }

    if (!isEmptyParagraph && Text$1.isText(nextStart) && nextStart.text === '') {
      // don't keep empty text node with marks in non-empty paragraph
      nextStart.marks.forEach(function (mark) {
        controller.command(removeMarkByKey, nextStart.key, 0, 1, mark);
      });
    }
  });
}
/**
 * 删除当前Selection内的所有内容
 * 1. 将选区开头的样式设置到 selection.marks 中
 */

function del(controller) {
  var _controller$value = controller.value,
      selection = _controller$value.selection,
      document = _controller$value.document;

  var _selection$convertToT = selection.convertToTextPoints(document),
      start = _selection$convertToT.start;

  var startNode = document.getNode(start.key);
  var startMarks = Text$1.isText(startNode) ? document.getMarksAtPosition(start.key, start.offset + 1) : [];
  controller.command('deleteAtRange', selection);
  var range = controller.value.selection; // set selection.marks to make sure inherit marks from deleted text

  range = range.set('marks', startMarks);
  return controller.command(select, range.moveToFocus());
}
/**
 * 在指定selection上，进行往后删除。
 * @range 如果是expand选区，会删除选区内的内容，并忽略掉后续参数；否则从anchor点往后计算n个unit进行删除
 */

function deleteBackwardAtRange(controller, range, n, unit) {
  if (n === void 0) {
    n = 1;
  }

  var document = controller.value.document;

  if (range.isExpanded) {
    return controller.command(del);
  }

  var anchor = range.anchor;

  if (anchor.isEdgePoint()) {
    var isBackward = n >= 0;
    var point = anchor;
    var deleteEdge = isBackward ? EdgePoint.AFTER : EdgePoint.BEFORE;
    var isToDelete = point.edge === deleteEdge;

    if (isToDelete) {
      // 在 edge block 的后面。直接删除掉，并插入新的段落
      return controller.command(insertEmptyBlock, point).command(removeNodeByKey, point.key);
    } else {
      // 在 edge block 的非删除边缘。需要看前/后一个 block。
      // 如果前/后一个 block 是空的，直接删掉；否则移动到末尾。
      var siblingBlock = isBackward ? document.getPreviousBlock(point.key) : document.getNextBlock(point.key);

      if (!siblingBlock) {
        return controller;
      }

      var closestBlock = document.getClosestSelectableBlock(siblingBlock.key, controller);
      anchor = point;

      if (closestBlock || siblingBlock.text || siblingBlock.nodes.length > 1) {
        anchor = controller.query(isBackward ? pointAtEndOfNode : pointAtStartOfNode, siblingBlock);
      } else {
        controller.command(removeNodeByKey, siblingBlock.key);
      }

      var focus = anchor;
      return controller.command(select, Selection.create({
        anchor: anchor,
        focus: focus
      }));
    }
  } // if we're in a void block, remove it


  var voidParent = document.getClosestVoid(anchor.key, controller);

  if (voidParent) {
    if (document.nodes.length === 1 && document.nodes[0] === voidParent) {
      controller.command(insertEmptyBlock, EdgePoint.create({
        key: voidParent.key,
        edge: EdgePoint.BEFORE
      }));
    }

    return controller.command(removeNodeByKey, voidParent.key);
  } // if we're in a empty block, remove it


  var block = document.getClosestBlock(anchor.key);

  if (document.nodes.length !== 1 && block && block.text === '' && block.nodes.length === 1) {
    controller.command(removeNodeByKey, block.key); // 向后删除时，光标移动到删除段落的下一段

    if (n === -1) {
      controller.command(moveToStartOfNextBlock);
    }

    return controller;
  }

  controller.command(moveAnchorBackward, n, unit);
  var updatedSelection = controller.value.selection;
  var updatedAnchor = updatedSelection == null ? void 0 : updatedSelection.anchor;

  if (updatedAnchor != null && updatedAnchor.isEdgePoint()) {
    return controller.command(moveToAnchor);
  }

  return controller.command(del);
}
/**
 * 在指定selection上，进行往前删除。
 * @range 如果是expand选区，会删除选区内的内容，并忽略掉后续参数；否则从anchor点往前计算n个unit进行删除
 */

function deleteForwardAtRange(controller, range, n, unit) {
  if (n === void 0) {
    n = 1;
  }

  return deleteBackwardAtRange(controller, range, -n, unit);
}
/**
 * 从所有当前选区的位置，往后删除n个offset
 */

function deleteBackward(controller, n) {
  if (n === void 0) {
    n = 1;
  }

  var selection = controller.value.selection;
  return controller.command(deleteBackwardAtRange, selection, n);
}
/**
 * 从所有当前选区的位置，往前删除n个offset
 */

function deleteForward(controller, n) {
  if (n === void 0) {
    n = 1;
  }

  return controller.command(deleteBackward, -n);
}

function createDeleteBoundry(dir) {
  return function deleteBoundray(controller, getBoundaryOrIteratePositionsFromPoint, unit) {
    var isBackward = dir === 'backward';
    var selection = controller.value.selection;
    var defaultBoundary = 1;
    var boundary = typeof getBoundaryOrIteratePositionsFromPoint === 'number' ? getBoundaryOrIteratePositionsFromPoint : defaultBoundary;

    if (selection.anchor.isTextPoint()) {
      var document = controller.value.document;
      var anchor = selection.anchor;

      var _block = document.getClosestBlock(anchor.key);

      if (!_block) {
        return controller;
      }

      var _offset = _block.getOffset(anchor.key);

      if (typeof getBoundaryOrIteratePositionsFromPoint === 'function') {
        boundary = getBoundaryOrIteratePositionsFromPoint(_block, _offset + anchor.offset);
      }
    }

    return controller.command(isBackward ? deleteBackwardAtRange : deleteForwardAtRange, selection, boundary, unit);
  };
}
/**
 * @ignore
 */


var deleteBoundrayBackward = createDeleteBoundry('backward');
/**
 * @ignore
 */

var deleteBoundrayForward = createDeleteBoundry('forward');
/**
 * 从所有当前选区的位置，往后删除1个文字（大多情况下，1个文字等于1个offset，但是1个emoji可能对应多个offset）
 */

function deleteCharBackward(controller) {
  return controller.command(deleteBoundrayBackward, 1);
}
/**
 * 从所有当前选区的位置，往前删除1个文字（大多情况下，1个文字等于1个offset，但是1个emoji可能对应多个offset）
 */

function deleteCharForward(controller) {
  return controller.command(deleteBoundrayForward, 1);
}
/**
 * 从所有当前选区的位置，往后删除1个词
 */

function deleteWordBackward(controller) {
  return controller.command(deleteBoundrayBackward, 1, 'word');
}
/**
 * 从所有当前选区的位置，往前删除1个词
 */

function deleteWordForward(controller) {
  return controller.command(deleteBoundrayForward, 1, 'word');
}
/**
 * 从所有当前选区的位置，往后删除1行文字
 */

function deleteLineBackward(controller) {
  return controller.command(deleteBoundrayBackward, function (startBlock, offset) {
    return textUtils.countBreaks(startBlock.text, offset);
  });
}
/**
 * 从所有当前选区的位置，往前删除1行文字
 */

function deleteLineForward(controller) {
  return controller.command(deleteBoundrayForward, function (startBlock, offset) {
    return textUtils.countBreaks(startBlock.text, offset, true);
  });
}

/**
 * @packageDocumentation
 * @module Commands
 */

/**
 * 在指定的位置上，替换node
 */
function replaceNodeByKey(controller, key, newNode) {
  var document = controller.value.document;
  var path = document.getPath(key);

  if (!path) {
    return controller;
  }

  return controller.command(replaceNodeByPath, path, newNode);
}
/**
 * 在指定的位置上，替换node
 */

function replaceNodeByPath(controller, path, newNode) {
  var index = path[path.length - 1];
  var parentPath = Path.parent(path);
  return controller.withoutNormalizing(function () {
    controller.command(removeNodeByPath, path).command(insertNodeByPath, parentPath, index, newNode);
  });
}
/**
 * 在指定的位置上，替换文本，并附加marks
 * 1. 提过oldText长度大于可用长度，按照可用长度计算
 */

function replaceTextByKey(controller, key, offset, oldText, text, marks) {
  var value = controller.value;
  var document = value.document;
  var path = document.assertPath(key);
  return controller.command(replaceTextByPath, path, offset, oldText, text, marks);
}
/**
 * 在指定的位置上，替换文本，并附加marks
 * 1. 提过oldText长度大于可用长度，按照可用长度计算
 */

function replaceTextByPath(controller, path, offset, oldText, text, marks) {
  if (marks === void 0) {
    marks = [];
  }

  var value = controller.value;
  var document = value.document;
  var node = document.assertNodeByPath(path);
  var activeMarks = document.getActiveMarksAtRange(Selection.create({
    anchor: TextPoint.create({
      key: node.key,
      offset: offset
    }),
    focus: TextPoint.create({
      key: node.key,
      offset: offset + oldText.length
    })
  }));
  var mergedMarks = setUtils.union(marks, activeMarks, function (a, b) {
    return a.type === b.type;
  });
  return controller.withoutNormalizing(function () {
    controller.command(removeTextByPath, path, offset, oldText).command(insertTextByPath, path, offset, text, mergedMarks.map(Mark.create));
  });
}

/**
 * @packageDocumentation
 * @module Commands
 */
function setNodeByKey(controller, key, properties) {
  var value = controller.value;
  var document = value.document;
  var path = document.assertPath(key);
  return controller.command(setNodeByPath, path, properties);
}
function setNodeByPath(controller, path, properties) {
  var prevNode = controller.value.document.assertNodeByPath(path);
  var prevProperties = Element$1.isElement(prevNode) ? {
    type: prevNode.type,
    data: prevNode.data
  } : {};
  return controller.applyOperation({
    type: OperationType.SetNode,
    path: [].concat(path),
    properties: Node$1.createProperties(properties),
    prevProperties: prevProperties
  });
}
function setBlocks(controller, properties) {
  var selection = controller.value.selection;
  return controller.command(setBlocksAtRange, selection, properties);
}
function setBlocksAtRange(controller, selection, properties) {
  var value = controller.value;
  var document = value.document;

  var _selection$convertToT = selection.convertToTextPoints(document),
      start = _selection$convertToT.start,
      end = _selection$convertToT.end;

  var hasVoidParent = document.hasVoidParent(start.key, controller);
  var startBlock = document.getClosestBlock(start.key);
  var endBlock = document.getClosestBlock(end.key);
  var startNodeKey = startBlock ? startBlock.getFirstNode().key : null;
  var endNodeKey = endBlock ? endBlock.getLastNode().key : null; // Check the "Hanging Selection" case for UX reasons.
  // For more detail, go read the comments in [deleteAtRange]

  var isHanging = selection.isCollapsed === false && hasVoidParent === false && start.offset === 0 && end.offset === 0 && start.key === startNodeKey && end.key === endNodeKey && start.key !== end.key;
  var allBlocks = document.getLeafBlocksAtRange(selection);
  var blocks = isHanging ? allBlocks.slice(0, -1) : allBlocks;
  return controller.withoutNormalizing(function () {
    blocks.forEach(function (block) {
      controller.command('setNodeByKey', block.key, properties);
    });
  });
}
function setInlines(controller, properties) {
  var selection = controller.value.selection;
  return controller.command(setInlinesAtRange, selection, properties);
}
function setInlinesAtRange(controller, selection, properties) {
  var value = controller.value;
  var document = value.document;
  return controller.withoutNormalizing(function () {
    var inlines = document.getLeafInlinesAtRange(selection);
    inlines.forEach(function (inline) {
      controller.command('setNodeByKey', inline.key, properties);
    });
  });
}
function setMarkByKey(controller, key, offset, length, mark, properties) {
  var value = controller.value;
  var document = value.document;
  var path = document.assertPath(key);
  return controller.command(setMarkByPath, path, offset, length, mark, properties);
}
function setMarkByPath(controller, path, offset, length, m, properties) {
  var mark = Mark.create(m);
  return controller.applyOperation({
    type: OperationType.SetMark,
    path: path,
    offset: offset,
    length: length,
    mark: mark,
    properties: properties
  });
}
function setTextByKey(controller, key, text, marks) {
  var value = controller.value;
  var document = value.document;
  var path = document.assertPath(key);
  return controller.command(setTextByPath, path, text, marks);
}
function setTextByPath(controller, path, text, marks) {
  var value = controller.value;
  var document = value.document;
  var node = document.assertNodeByPath(path);
  return controller.command(replaceTextByPath, path, 0, node.text, text, marks);
}

var wrapInlineTpl = function wrapInlineTpl() {
  return 'cj/cmd/wrapinline';
};

/**
 * @packageDocumentation
 * @module Commands
 */
/**
 * 在当前选区的start和end位置，插入一些文字，并更新选区位置。
 * 1. 不区分range是否是collapse
 */

function wrapText(controller, prefix, suffix) {
  if (suffix === void 0) {
    suffix = prefix;
  }

  var value = controller.value;
  var selection = value.selection,
      document = value.document;
  controller.command(wrapTextAtRange, selection, prefix, suffix);
  var sel = controller.value.selection;

  if (selection.isCollapsed) {
    sel = sel.moveStartBackward(document, prefix.length);
  } // Adding the suffix will have pushed the end of the selection further on, so
  // we need to move it back to account for this.


  sel = sel.moveEndBackward(document, suffix.length);
  return controller.command(select, sel);
}
/**
 * 在选区的start和end位置，插入一些文字
 * 1. 不区分range是否是collapse
 * 2. 此方法不会更新选区位置
 */

function wrapTextAtRange(controller, range, prefix, suffix) {
  if (suffix === void 0) {
    suffix = prefix;
  }

  var value = controller.value;
  var document = value.document;
  var startRange = range.moveToStart(document);
  var endRange = range.moveToEnd(document);
  controller.withoutNormalizing(function () {
    controller.command(insertTextAtRange, endRange, suffix);
    controller.command(insertTextAtRange, startRange, prefix);
  });
  return controller;
}
/**
 * 在range的公共父节点上插入block，然后把range对应的nodes都转到block中
 */

function wrapBlock(controller, block) {
  var selection = controller.value.selection;
  return controller.command(wrapBlockAtRange, selection, block);
}
/**
 * 在range的公共父节点上插入block，然后把range对应的nodes都转到block中
 */

function wrapBlockAtRange(controller, range, b) {
  var block = Block.create(b);
  block = block.set('nodes', []);
  var value = controller.value;
  var document = value.document;
  var blocks = document.getLeafBlocksAtRange(range);
  var firstblock = blocks[0];
  var lastblock = blocks[blocks.length - 1];
  var parent;
  var siblings;
  var index;

  if (blocks.length === 1) {
    parent = document.getParent(firstblock.key);
    siblings = blocks;
  } else {
    parent = document.getCommonAncestor(firstblock.key, lastblock.key);
  } // If no shared parent could be found then the parent is the document.


  if (parent == null) {
    parent = document;
  } // Create a list of direct children siblings of parent that fall in the
  // selection.


  if (siblings == null) {
    var indexes = parent.nodes.reduce(function (ind, node, i) {
      // eslint-disable-next-line no-param-reassign
      if (node === firstblock || node.getNode(firstblock.key)) ind[0] = i; // eslint-disable-next-line no-param-reassign

      if (node === lastblock || node.getNode(lastblock.key)) ind[1] = i;
      return ind;
    }, []);
    index = indexes[0];
    siblings = parent.nodes.slice(indexes[0], indexes[1] + 1);
  } // Get the index to place the new wrapped node at.


  if (index == null) {
    index = parent.nodes.indexOf(siblings[0]);
  }

  controller.withoutNormalizing(function () {
    // Inject the new block node into the parent.
    controller.command(insertNodeByKey, parent.key, index, block); // Move the sibling nodes into the new block node.

    siblings.forEach(function (node, i) {
      controller.command(moveNodeByKey, node.key, block.key, i);
    });
  });
  return controller;
}
/**
 * 把目标节点插入到一个新的block节点中，并把block放到原来的节点的位置
 */

function wrapBlockByKey(controller, key, block) {
  var value = controller.value;
  var document = value.document;
  var path = document.assertPath(key);
  return controller.command(wrapBlockByPath, path, Block.create(block));
}
/**
 * 把目标节点插入到一个新的block节点中，并把block放到原来的节点的位置
 */

function wrapBlockByPath(controller, path, b) {
  var block = Block.create(b).set('nodes', []);
  var parentPath = Path.parent(path);
  var index = path[path.length - 1];
  var newPath = Path.increment(path);
  controller.withoutNormalizing(function () {
    controller.command(insertNodeByPath, parentPath, index, block);
    controller.command(moveNodeByPath, newPath, path, 0);
  });
  return controller;
}
/**
 * 把当前选区wrap一个inline
 * 1. 如果range是collapse，则把对应节点的最近void inline节点进行wrap；
 * 如果没有最近的void inline，则什么都不做
 * 2. 如果选区里有block，会在每个block内部进行wrap inline操作
 */

function wrapInline(controller, inline) {
  var selection = controller.value.selection;
  return controller.command(wrapInlineAtRange, selection, inline);
}
/**
 * 把当前选区wrap一个inline
 * 1. 如果range是collapse，则把对应节点的最近void inline节点进行wrap；
 * 如果没有最近的void inline，则什么都不做
 * 2. 如果选区里有block，会在每个block内部进行wrap inline操作
 */

function wrapInlineAtRange(controller, range, i) {
  var value = controller.value;
  var document = value.document;

  var _range$convertToTextP = range.convertToTextPoints(document),
      start = _range$convertToTextP.start,
      end = _range$convertToTextP.end;

  var inline = Inline.create(i);

  if (range.isCollapsed) {
    // Wrapping an inline void
    var inlineParent = document.getClosestInline(start.key);

    if (!inlineParent) {
      return controller;
    }

    if (!controller.query('isVoid', inlineParent)) {
      return controller;
    }

    return controller.command(wrapInlineByKey, inlineParent.key, inline);
  }

  inline = inline.set('nodes', []);
  var blocks = document.getLeafBlocksAtRange(range);
  var startBlock = document.getClosestBlock(start.key);
  var endBlock = document.getClosestBlock(end.key);
  var startInline = document.getClosestInline(start.key);
  var endInline = document.getClosestInline(end.key);
  var startChild = startBlock.getFurthestAncestor(start.key);
  var endChild = endBlock.getFurthestAncestor(end.key);
  controller.withOpContext(wrapInlineTpl(), function () {
    controller.withoutNormalizing(function () {
      if (!startInline || startInline !== endInline) {
        controller.command(splitDescendantsByKey, endChild.key, end.key, end.offset);
        controller.command(splitDescendantsByKey, startChild.key, start.key, start.offset);
      }

      document = controller.value.document;
      startBlock = document.getNode(startBlock.key);
      endBlock = document.getNode(endBlock.key);
      startChild = startBlock.getFurthestAncestor(start.key);
      endChild = endBlock.getFurthestAncestor(end.key);
      var startIndex = startBlock.nodes.indexOf(startChild);
      var endIndex = endBlock.nodes.indexOf(endChild);

      if (startInline && startInline === endInline) {
        var text = document.getTextsAtRange(range)[0].splitText(start.offset)[1].splitText(end.offset - start.offset)[0];
        inline = inline.set('nodes', [text]);
        controller.command(insertInlineAtRange, range, inline);
        var inlinekey = text.key;
        var anchor = TextPoint.create({
          key: inlinekey,
          offset: 0
        });
        var focus = TextPoint.create({
          key: inlinekey,
          offset: end.offset - start.offset
        });
        var rng = Selection.create({
          anchor: anchor,
          focus: focus
        });
        controller.command(select, rng);
      } else if (startBlock === endBlock) {
        document = controller.value.document;
        startBlock = document.getClosestBlock(start.key);
        startChild = startBlock.getFurthestAncestor(start.key);
        var startInner = document.getNextSibling(startChild.key);
        var startInnerIndex = startBlock.nodes.indexOf(startInner);
        var endInner = start.key === end.key ? startInner : startBlock.getFurthestAncestor(end.key);
        var inlines = listUtils.skipUntil(startBlock.nodes, function (n) {
          return n === startInner;
        });
        inlines = listUtils.takeUntil(inlines, function (n) {
          return n === endInner;
        });
        inlines.push(endInner);
        var node = inline.regenerateKey();
        controller.command(insertNodeByKey, startBlock.key, startInnerIndex, node);
        inlines.forEach(function (child, idx) {
          controller.command(moveNodeByKey, child.key, node.key, idx);
        });
      } else {
        var startInlines = startBlock.nodes.slice(startIndex + 1);
        var endInlines = endBlock.nodes.slice(0, endIndex + 1);
        var startNode = inline.regenerateKey();
        var endNode = inline.regenerateKey();
        controller.command(insertNodeByKey, startBlock.key, startIndex + 1, startNode);
        controller.command(insertNodeByKey, endBlock.key, endIndex, endNode);
        startInlines.forEach(function (child, idx) {
          controller.command(moveNodeByKey, child.key, startNode.key, idx);
        });
        endInlines.forEach(function (child, idx) {
          controller.command(moveNodeByKey, child.key, endNode.key, idx);
        });
        blocks.slice(1, -1).forEach(function (block) {
          var node = inline.regenerateKey();
          controller.command(insertNodeByKey, block.key, 0, node);
          block.nodes.forEach(function (child, idx) {
            controller.command(moveNodeByKey, child.key, node.key, idx);
          });
        });
      }
    });
  });
  return controller;
}
/**
 * 把目标节点插入到一个新的inline节点中，并把inline放到原来的节点的位置
 */

function wrapInlineByKey(controller, key, inline) {
  var value = controller.value;
  var document = value.document;
  var path = document.assertPath(key);
  return controller.command(wrapInlineByPath, path, inline);
}
/**
 * 把目标节点插入到一个新的inline节点中，并把inline放到原来的节点的位置
 */

function wrapInlineByPath(controller, path, i) {
  var inline = Inline.create(i).set('nodes', []);
  var parentPath = Path.parent(path);
  var index = path[path.length - 1];
  var newPath = Path.increment(path);
  controller.withoutNormalizing(function () {
    controller.command(insertNodeByPath, parentPath, index, inline);
    controller.command(moveNodeByPath, newPath, path, 0);
  });
  return controller;
}

var unwrapBlockTpl = function unwrapBlockTpl() {
  return 'cj/cmd/unwrapblock';
};
var unwrapTpl = function unwrapTpl() {
  return 'cj/cmd/unwrapnode';
};

/**
 * @packageDocumentation
 * @module Commands
 */
function unwrapBlock(controller, p) {
  var selection = controller.value.selection;
  var properties = typeof p === 'string' ? {
    type: p
  } : p;
  return controller.command(unwrapBlockAtRange, selection, properties);
}
function unwrapBlockAtRange(controller, range, properties) {
  var value = controller.value;
  var document = value.document;
  var blocks = document.getLeafBlocksAtRange(range);
  var wraps = blocks.map(function (block) {
    return document.getClosest(block.key, function (parent) {
      if (!Block.isBlock(parent)) {
        return false;
      }

      if (properties.type != null && parent.type !== properties.type) {
        return false;
      }

      if (properties.data != null && !setUtils.isSuperSet(Object.values(parent.data), Object.values(properties.data))) {
        return false;
      }

      return true;
    });
  });
  var wrappers = wraps.filter(function (exists) {
    return Boolean((exists == null ? void 0 : exists.isElement()) && exists.isBlock());
  });
  controller.withOpContext(unwrapBlockTpl(), function () {
    controller.withoutNormalizing(function () {
      setUtils.removeDuplicate(wrappers).forEach(function (block) {
        var first = block.nodes[0];
        var last = block.nodes[block.nodes.length - 1];
        var parent = controller.value.document.getParent(block.key);
        var index = parent.nodes.indexOf(block);
        var children = block.nodes.filter(function (child) {
          return blocks.some(function (b) {
            return child === b || child.isElement() && child.getNode(b.key);
          });
        });
        var firstMatch = children[0];
        var lastMatch = children[children.length - 1];

        if (first === firstMatch && last === lastMatch) {
          block.nodes.forEach(function (child, idx) {
            controller.command(moveNodeByKey, child.key, parent.key, index + idx);
          });
          controller.command(removeNodeByKey, block.key);
        } else if (last === lastMatch) {
          listUtils.skipUntil(block.nodes, function (n) {
            return n === firstMatch;
          }).forEach(function (child, i) {
            controller.command(moveNodeByKey, child.key, parent.key, index + 1 + i);
          });
        } else if (first === firstMatch) {
          var nodes = listUtils.takeUntil(block.nodes, function (n) {
            return n === lastMatch;
          });
          nodes.push(lastMatch);
          nodes.forEach(function (child, i) {
            controller.command(moveNodeByKey, child.key, parent.key, index + i);
          });
        } else {
          var firstText = firstMatch.getFirstText();
          controller.command(splitDescendantsByKey, block.key, firstText.key, 0);
          document = controller.value.document;
          children.forEach(function (child, i) {
            var newChild = child;

            if (i === 0) {
              var extra = newChild;
              newChild = document.getNextBlock(child.key);
              controller.command(removeNodeByKey, extra.key);
            }

            controller.command(moveNodeByKey, newChild.key, parent.key, index + 1 + i);
          });
        }
      });
    });
  });
  return controller;
}
function unwrapBlockByKey(controller, key, p) {
  var value = controller.value;
  var document = value.document;
  var path = document.assertPath(key);
  var properties = typeof p === 'string' ? {
    type: p
  } : p;
  return controller.command(unwrapBlockByPath, path, properties);
}
function unwrapBlockByPath(controller, path, properties) {
  var value = controller.value;
  var document = value.document;
  var node = document.assertNodeByPath(path);
  var first = node.getFirstText();
  var last = node.getLastText();
  var anchor = TextPoint.create({
    key: first.key,
    offset: 0
  });
  var focus = TextPoint.create({
    key: last.key,
    offset: last.text.length
  });
  var range = Selection.create({
    anchor: anchor,
    focus: focus
  });
  return controller.command(unwrapBlockAtRange, range, properties);
}
function unwrapInline(controller, p) {
  var selection = controller.value.selection;
  var properties = typeof p === 'string' ? {
    type: p
  } : p;
  return controller.command(unwrapInlineAtRange, selection, properties);
}
function unwrapInlineAtRange(controller, range, properties) {
  var value = controller.value;
  var document = value.document;
  var texts = document.getTextsAtRange(range);
  var inlines = texts.map(function (text) {
    return document.getClosest(text.key, function (parent) {
      if (!Inline.isInline(parent)) return false;

      if (properties.type != null && parent.type !== properties.type) {
        return false;
      }

      if (properties.data != null && !setUtils.isSuperSet(Object.values(parent.data), Object.values(properties.data))) {
        return false;
      }

      return true;
    });
  }).filter(function (exists) {
    return exists;
  });
  controller.withoutNormalizing(function () {
    setUtils.removeDuplicate(inlines).forEach(function (inline) {
      var parent = controller.value.document.getParent(inline.key);
      var index = parent.nodes.indexOf(inline);
      inline.nodes.forEach(function (child, i) {
        controller.command(moveNodeByKey, child.key, parent.key, index + i);
      });
      controller.command(removeNodeByKey, inline.key);
    });
  });
  return controller;
}
function unwrapInlineByKey(controller, key, p) {
  var value = controller.value;
  var document = value.document;
  var path = document.assertPath(key);
  var properties = typeof p === 'string' ? {
    type: p
  } : p;
  return controller.command(unwrapInlineByPath, path, properties);
}
function unwrapInlineByPath(controller, path, properties) {
  var value = controller.value;
  var document = value.document;
  var node = document.assertNodeByPath(path);
  var first = node.getFirstText();
  var last = node.getLastText();
  var anchor = TextPoint.create({
    key: first.key,
    offset: 0
  });
  var focus = TextPoint.create({
    key: last.key,
    offset: last.text.length
  });
  var range = Selection.create({
    anchor: anchor,
    focus: focus
  });
  return controller.command(unwrapInlineAtRange, range, properties);
}
function unwrapNodeByKey(controller, key) {
  var value = controller.value;
  var document = value.document;
  var path = document.assertPath(key);
  return controller.command(unwrapNodeByPath, path);
}
function unwrapNodeByPath(controller, path) {
  var value = controller.value;
  var document = value.document;
  document.assertNodeByPath(path);
  var parentPath = Path.parent(path);
  var parent = document.assertNodeByPath(parentPath);
  var index = path[path.length - 1];
  var parentIndex = parentPath[parentPath.length - 1];
  var grandPath = Path.parent(parentPath);
  var isFirst = index === 0;
  var isLast = index === parent.nodes.length - 1;
  controller.withOpContext(unwrapTpl(), function () {
    controller.withoutNormalizing(function () {
      if (parent.nodes.length === 1) {
        controller.command(moveNodeByPath, path, grandPath, parentIndex + 1);
        controller.command(removeNodeByPath, parentPath);
      } else if (isFirst) {
        controller.command(moveNodeByPath, path, grandPath, parentIndex);
      } else if (isLast) {
        controller.command(moveNodeByPath, path, grandPath, parentIndex + 1);
      } else {
        var updatedPath = Path.increment(path, 1, parentPath.length - 1);
        updatedPath = updatedPath.map(function (p, idx) {
          return idx === updatedPath.length - 1 ? 0 : p;
        });
        controller.command(splitNodeByPath, parentPath, index);
        controller.command(moveNodeByPath, updatedPath, grandPath, parentIndex + 1);
      }
    });
  });
  return controller;
}

/**
 * @packageDocumentation
 * @ignore
 */

var Commands = /*#__PURE__*/Object.freeze({
  __proto__: null,
  deleteAtRange: deleteAtRange,
  del: del,
  deleteBackwardAtRange: deleteBackwardAtRange,
  deleteForwardAtRange: deleteForwardAtRange,
  deleteBackward: deleteBackward,
  deleteForward: deleteForward,
  deleteBoundrayBackward: deleteBoundrayBackward,
  deleteBoundrayForward: deleteBoundrayForward,
  deleteCharBackward: deleteCharBackward,
  deleteCharForward: deleteCharForward,
  deleteWordBackward: deleteWordBackward,
  deleteWordForward: deleteWordForward,
  deleteLineBackward: deleteLineBackward,
  deleteLineForward: deleteLineForward,
  insertNodeByKey: insertNodeByKey,
  insertNodeByPath: insertNodeByPath,
  insertText: insertText$1,
  insertEmptyBlock: insertEmptyBlock,
  insertTextAtRange: insertTextAtRange,
  insertTextByKey: insertTextByKey,
  insertTextByPath: insertTextByPath,
  insertBlockAtRange: insertBlockAtRange,
  insertBlock: insertBlock,
  insertInlineAtRange: insertInlineAtRange,
  insertInline: insertInline,
  insertFragmentByKey: insertFragmentByKey,
  insertFragmentByPath: insertFragmentByPath,
  insertFragment: insertFragment,
  insertFragmentAtRange: insertFragmentAtRange,
  insertFragmentWithRealKeyAtRange: insertFragmentWithRealKeyAtRange,
  mergeNodeByKey: mergeNodeByKey,
  mergeNodeByPath: mergeNodeByPath,
  moveNodeByKey: moveNodeByKey,
  moveNodeByPath: moveNodeByPath,
  focus: focus,
  blur: blur,
  select: select,
  userSelect: userSelect,
  selectWordAtPoint: selectWordAtPoint,
  moveAnchorBackward: moveAnchorBackward,
  moveAnchorForward: moveAnchorForward,
  moveAnchorTo: moveAnchorTo,
  moveAnchorToKey: moveAnchorToKey,
  moveAnchorToStartOfBlock: moveAnchorToStartOfBlock,
  moveAnchorToStartOfPreviousBlock: moveAnchorToStartOfPreviousBlock,
  moveAnchorToEndOfNextBlock: moveAnchorToEndOfNextBlock,
  moveFocusTo: moveFocusTo,
  moveFocusToKey: moveFocusToKey,
  moveTo: moveTo,
  moveToKey: moveToKey,
  moveFocusBackward: moveFocusBackward,
  moveFocusForward: moveFocusForward,
  moveFocusWordBackward: moveFocusWordBackward,
  moveFocusWordForward: moveFocusWordForward,
  moveFocusToEndOfText: moveFocusToEndOfText,
  moveFocusToStartOfBlock: moveFocusToStartOfBlock,
  moveFocusToEndOfBlock: moveFocusToEndOfBlock,
  moveFocusToStartOfDocument: moveFocusToStartOfDocument,
  moveFocusToEndOfDocument: moveFocusToEndOfDocument,
  moveStartBackward: moveStartBackward,
  moveStartForward: moveStartForward,
  moveEndBackward: moveEndBackward,
  moveEndForward: moveEndForward,
  moveBackward: moveBackward,
  moveForward: moveForward,
  moveToEndOfPreviousBlock: moveToEndOfPreviousBlock,
  moveToEndOfNextBlock: moveToEndOfNextBlock,
  moveToEndOfInline: moveToEndOfInline,
  moveToAnchor: moveToAnchor,
  moveToFocus: moveToFocus,
  moveToRangeOfDocument: moveToRangeOfDocument,
  moveToRangeOfNode: moveToRangeOfNode,
  moveToStart: moveToStart,
  moveToEnd: moveToEnd,
  moveToEndOfDocument: moveToEndOfDocument,
  moveToStartOfInline: moveToStartOfInline,
  moveToStartOfBlock: moveToStartOfBlock,
  moveToEndOfBlock: moveToEndOfBlock,
  moveToEndOfNode: moveToEndOfNode,
  moveStartToStartOfInline: moveStartToStartOfInline,
  moveStartToStartOfBlock: moveStartToStartOfBlock,
  moveStartToStartOfPreviousBlock: moveStartToStartOfPreviousBlock,
  moveEndToEndOfBlock: moveEndToEndOfBlock,
  moveToStartOfDocument: moveToStartOfDocument,
  moveStartToEndOfNode: moveStartToEndOfNode,
  moveAnchorToStartOfNode: moveAnchorToStartOfNode,
  moveAnchorToEndOfNode: moveAnchorToEndOfNode,
  moveFocusToStartOfNode: moveFocusToStartOfNode,
  moveFocusToEndOfNode: moveFocusToEndOfNode,
  moveToEndOfPreviousText: moveToEndOfPreviousText,
  moveToStartOfNextText: moveToStartOfNextText,
  moveToStartOfPreviousBlock: moveToStartOfPreviousBlock,
  moveToStartOfNextBlock: moveToStartOfNextBlock,
  moveToStartOfNode: moveToStartOfNode,
  moveStartToStartOfNode: moveStartToStartOfNode,
  moveEndToStartOfNode: moveEndToStartOfNode,
  moveEndToEndOfNode: moveEndToEndOfNode,
  moveStartToEndOfPreviousText: moveStartToEndOfPreviousText,
  moveStartToEndOfPreviousBlock: moveStartToEndOfPreviousBlock,
  moveEndToEndOfInline: moveEndToEndOfInline,
  moveEndToStartOfNextText: moveEndToStartOfNextText,
  moveEndToStartOfNextBlock: moveEndToStartOfNextBlock,
  moveEndToEndOfNextBlock: moveEndToEndOfNextBlock,
  moveWordBackward: moveWordBackward,
  moveWordForward: moveWordForward,
  addMark: addMark,
  addMarkAtRange: addMarkAtRange,
  addMarkByKey: addMarkByKey,
  addMarkByPath: addMarkByPath,
  addMarks: addMarks,
  addMarksAtRange: addMarksAtRange,
  toggleMark: toggleMark,
  toggleMarkAtRange: toggleMarkAtRange,
  removeMark: removeMark,
  removeMarkAtRange: removeMarkAtRange,
  removeMarkByKey: removeMarkByKey,
  removeMarkByPath: removeMarkByPath,
  replaceMark: replaceMark,
  splitDescendantsByKey: splitDescendantsByKey,
  splitDescendantsByPath: splitDescendantsByPath,
  splitNodeByKey: splitNodeByKey,
  splitNodeByPath: splitNodeByPath,
  splitBlock: splitBlock,
  splitBlockAtRange: splitBlockAtRange,
  splitInline: splitInline,
  removeNodeByKey: removeNodeByKey,
  removeNodeByPath: removeNodeByPath,
  removeTextByKey: removeTextByKey,
  removeTextByPath: removeTextByPath,
  replaceNodeByKey: replaceNodeByKey,
  replaceNodeByPath: replaceNodeByPath,
  replaceTextByKey: replaceTextByKey,
  replaceTextByPath: replaceTextByPath,
  setNodeByKey: setNodeByKey,
  setNodeByPath: setNodeByPath,
  setBlocks: setBlocks,
  setBlocksAtRange: setBlocksAtRange,
  setInlines: setInlines,
  setInlinesAtRange: setInlinesAtRange,
  setMarkByKey: setMarkByKey,
  setMarkByPath: setMarkByPath,
  setTextByKey: setTextByKey,
  setTextByPath: setTextByPath,
  wrapText: wrapText,
  wrapTextAtRange: wrapTextAtRange,
  wrapBlock: wrapBlock,
  wrapBlockAtRange: wrapBlockAtRange,
  wrapBlockByKey: wrapBlockByKey,
  wrapBlockByPath: wrapBlockByPath,
  wrapInline: wrapInline,
  wrapInlineAtRange: wrapInlineAtRange,
  wrapInlineByKey: wrapInlineByKey,
  wrapInlineByPath: wrapInlineByPath,
  unwrapBlock: unwrapBlock,
  unwrapBlockAtRange: unwrapBlockAtRange,
  unwrapBlockByKey: unwrapBlockByKey,
  unwrapBlockByPath: unwrapBlockByPath,
  unwrapInline: unwrapInline,
  unwrapInlineAtRange: unwrapInlineAtRange,
  unwrapInlineByKey: unwrapInlineByKey,
  unwrapInlineByPath: unwrapInlineByPath,
  unwrapNodeByKey: unwrapNodeByKey,
  unwrapNodeByPath: unwrapNodeByPath
});

var DATA_CLIPBORAD_CANGJIE = 'data-clipboard-cangjie';
var SLASH_PLACEHOLDER = '__slash__';

function _createForOfIteratorHelperLoose$5(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray$5(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$5(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen); }

function _arrayLikeToArray$5(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function isFileMimeType(mime_type) {
  return /^(image)|(audio)|(video)\//.test(mime_type);
}
/**
 * @description 从 html 中读取自定义数据
 */

function readClipboardDataFromHtml(html) {
  var domparser = new DOMParser();
  var root = domparser.parseFromString(html, 'text/html');
  var clipboardDataNode = root.querySelector("[" + DATA_CLIPBORAD_CANGJIE + "]");
  var clipboardData = [];

  if (clipboardDataNode && root.body.firstElementChild === clipboardDataNode) {
    Object.values(clipboardDataNode.attributes).forEach(function (item) {
      if (item.nodeName.startsWith('data-identifier-') && item.textContent) {
        var mimeType = item.nodeName.slice('data-identifier-'.length).replace(new RegExp(SLASH_PLACEHOLDER, 'gm'), '/');
        clipboardData.push([mimeType, item.textContent]);
      }
    });
  }

  return clipboardData;
}
/**
 * @description 获取剪切板权限并读取内容
 */

function getClipboardData() {
  return _getClipboardData.apply(this, arguments);
}

function _getClipboardData() {
  _getClipboardData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
    var _ret;

    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            return _context2.delegateYield( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
              var _nav$clipboard;

              var dataTransfer, nav, clipboardItems, _iterator, _step, clipboardItem, _iterator2, _step2, type, blob, file, text, customData;

              return _regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      dataTransfer = CangjieDataTransfer.create(); // 作为 any 类型处理，防止构建报错: Property 'read' does not exist on type 'Clipboard'.

                      nav = window.navigator;

                      if (nav != null && (_nav$clipboard = nav.clipboard) != null && _nav$clipboard.read) {
                        _context.next = 4;
                        break;
                      }

                      return _context.abrupt("return", {
                        v: Promise.reject(new Error('Your browser does not support navigator.clipboard.read method.'))
                      });

                    case 4:
                      _context.next = 6;
                      return nav.clipboard.read();

                    case 6:
                      clipboardItems = _context.sent;
                      _iterator = _createForOfIteratorHelperLoose$5(clipboardItems);

                    case 8:
                      if ((_step = _iterator()).done) {
                        _context.next = 30;
                        break;
                      }

                      clipboardItem = _step.value;
                      _iterator2 = _createForOfIteratorHelperLoose$5(clipboardItem.types);

                    case 11:
                      if ((_step2 = _iterator2()).done) {
                        _context.next = 28;
                        break;
                      }

                      type = _step2.value;
                      _context.next = 15;
                      return clipboardItem.getType(type);

                    case 15:
                      blob = _context.sent;

                      if (!isFileMimeType(type)) {
                        _context.next = 21;
                        break;
                      }

                      file = new window.File([blob], '', {
                        type: type
                      });
                      dataTransfer.setData(type, file);
                      _context.next = 26;
                      break;

                    case 21:
                      _context.next = 23;
                      return blob.text();

                    case 23:
                      text = _context.sent;
                      dataTransfer.setData(type, text);

                      if (type === 'text/html') {
                        customData = readClipboardDataFromHtml(text);
                        customData.forEach(function (_ref) {
                          var type = _ref[0],
                              data = _ref[1];
                          dataTransfer.setData(type, data);
                        });
                      }

                    case 26:
                      _context.next = 11;
                      break;

                    case 28:
                      _context.next = 8;
                      break;

                    case 30:
                      return _context.abrupt("return", {
                        v: Promise.resolve(dataTransfer)
                      });

                    case 31:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            })(), "t0", 2);

          case 2:
            _ret = _context2.t0;

            if (!(typeof _ret === "object")) {
              _context2.next = 5;
              break;
            }

            return _context2.abrupt("return", _ret.v);

          case 5:
            _context2.next = 10;
            break;

          case 7:
            _context2.prev = 7;
            _context2.t1 = _context2["catch"](0);
            return _context2.abrupt("return", Promise.reject(_context2.t1));

          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[0, 7]]);
  }));
  return _getClipboardData.apply(this, arguments);
}

var CustomDataTransfer = /*#__PURE__*/function () {
  function CustomDataTransfer() {
    this.data = void 0;
    this.dropEffect = void 0;
    this.effectAllowed = void 0;
    this.files = void 0;
    this.img = void 0;
    this.items = void 0;
    this.types = void 0;
    this.xOffset = void 0;
    this.yOffset = void 0;
    this.data = {
      dragX: '',
      dragY: ''
    };
    this.dropEffect = 'none';
    this.effectAllowed = 'all';
    this.files = [];
    this.img = '';
    this.items = [];
    this.types = [];
    this.xOffset = 0;
    this.yOffset = 0;
  }

  var _proto = CustomDataTransfer.prototype;

  _proto.clearData = function clearData() {
    this.data = {};
    this.items = [];
    this.types = [];
  };

  _proto.getData = function getData(format) {
    return this.data[format];
  };

  _proto.setData = function setData(format, data) {
    var toAdd = {
      kind: 'string',
      type: format
    };

    if (!this.items.some(function (i) {
      i.kind === toAdd.kind && i.type === toAdd.type;
    })) {
      this.items.push(toAdd);
    }

    if (isFileMimeType(format) && data instanceof Blob) {
      this.data[format] = '';

      if (!this.types.includes('Files')) {
        this.types.push('Files');
      }

      this.files.push(data);
    } else {
      this.data[format] = data;

      if (!this.types.includes(format)) {
        this.types.push(format);
      }
    }
  };

  _proto.setDragImage = function setDragImage(img, xOffset, yOffset) {
    this.img = img;
    this.xOffset = xOffset;
    this.yOffset = yOffset;
  };

  return CustomDataTransfer;
}();

var CangjieDataTransfer = /*#__PURE__*/function (_PolyfillDataTransfer) {
  _inheritsLoose(CangjieDataTransfer, _PolyfillDataTransfer);

  CangjieDataTransfer.create = function create(clipboardData) {
    return new CangjieDataTransfer(clipboardData);
  };

  function CangjieDataTransfer(clipboardData) {
    var _this;

    _this = _PolyfillDataTransfer.call(this) || this;

    if (!clipboardData) {
      return _assertThisInitialized(_this) || _assertThisInitialized(_this);
    } // 仅复制剪切板里基础类型数据，防止文件过大导致内存溢出，需要消费 File、Img 类型数据直接从 nativeEvent 上获取


    for (var _i = 0, _Object$values = Object.values(MIME_TYPES); _i < _Object$values.length; _i++) {
      var type = _Object$values[_i];

      if (!clipboardData.types.includes(type)) {
        continue;
      }

      var data = clipboardData.getData(type);

      _PolyfillDataTransfer.prototype.setData.call(_assertThisInitialized(_this), type, data);
    }

    return _assertThisInitialized(_this) || _assertThisInitialized(_this);
  }

  var _proto = CangjieDataTransfer.prototype;

  _proto.setData = function setData(type, data) {
    _PolyfillDataTransfer.prototype.setData.call(this, type, data);

    return Object.create(this, {
      clearData: {
        value: function value() {
          Object.getPrototypeOf(this).clearData();
        }
      },
      getData: {
        value: function value(t) {
          return Object.getPrototypeOf(this).getData(t);
        }
      }
    });
  };

  return CangjieDataTransfer;
}(CustomDataTransfer);

/**
 * @packageDocumentation
 * @module Events
 */

/**
 * 剪切板事件
 */
function CangjieClipboardEvent(type, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      nativeEvent = _ref.nativeEvent,
      clipboardData = _ref.clipboardData;

  var event = new CustomEvent(type);
  /**
   * https://bugs.webkit.org/show_bug.cgi?id=49739
   * webkit bug, safari 10 及以下会报 ERROR: Attempted to assign to readonly property.
   */

  if (clipboardData) {
    // @ts-ignore
    event.clipboardData = CangjieDataTransfer.create(clipboardData);
  } // @ts-ignore


  return Object.assign(event, {
    nativeEvent: nativeEvent,
    setClipboardData: function setClipboardData(clipboardData) {
      // @ts-ignore
      event.clipboardData = clipboardData;
      return Object.create(this, {
        clipboardData: {
          value: clipboardData
        }
      });
    }
  });
}

/**
 * @packageDocumentation
 * @module Events
 */
function CangjieSelectEvent(detail) {
  return new CustomEvent('cangjieSelect', {
    detail: detail
  });
}

/**
 * @packageDocumentation
 * @ignore
 */
var defaultLocale = {
  copy: '复制',
  cut: '剪切',
  select: '选择',
  selectAll: '全选',
  paste: '粘贴',
  pasteTips: '请用快捷键'
};

function getTransferType(data) {
  if (data.fragment) {
    return 'fragment';
  }

  if (data.files && data.files.length) {
    return 'files';
  }

  if (data.html) {
    return 'html';
  }

  if (data.text) {
    return 'text';
  }

  return 'unknown';
}

function getEventTransfer(event, controller) {
  var clipboardData = 'dataTransfer' in event ? event.dataTransfer : event.clipboardData;

  if (!clipboardData) {
    return {
      files: [],
      fragment: null,
      html: '',
      text: ''
    };
  }

  var html = clipboardData.getData(MIME_TYPES.HTML);
  var text = clipboardData.getData(MIME_TYPES.TEXT) || '';
  var encodedFragment = clipboardData.getData(MIME_TYPES.FRAGMENT);
  var fragment = null;

  if (encodedFragment) {
    try {
      fragment = decodeFragment(encodedFragment);
    } catch (e) {// do nothing
    }
  }

  if (!fragment && html && ~html.indexOf(" data-" + controller.biz + "-fragment=\"")) {
    var FRAGMENT_MATCHER = new RegExp(" data-" + controller.biz + "-fragment=\"([^\\s\"]+)\"");
    var matches = FRAGMENT_MATCHER.exec(html); // eslint-disable-next-line @typescript-eslint/no-unused-vars

    var _ref = matches || [];
        _ref[0];
        var encoded = _ref[1];

    if (encoded) {
      fragment = decodeFragment(encoded);
    }
  }

  var files = [];

  try {
    if (clipboardData.items && clipboardData.items.length) {
      files = Array.from(clipboardData.items).reduce(function (fs, item) {
        if (item.kind === 'file') {
          var file = item.getAsFile();

          if (file) {
            return [].concat(fs, [file]);
          }
        }

        return fs;
      }, []);
    } else if (clipboardData.files && clipboardData.files.length) {
      files = Array.from(clipboardData.files);
    }
  } catch (err) {
    if (clipboardData.files && clipboardData.files.length) {
      files = Array.from(clipboardData.files);
    }
  }

  var data = {
    files: files,
    fragment: fragment,
    html: html,
    text: text
  };
  return _extends({}, data, {
    type: getTransferType(data)
  });
}
/**
 * 编码 fragment
 * @param fragment
 */

function encodeFragment(fragment) {
  var string = JSON.stringify(fragment.toJSON());
  var encoded = window.btoa(encodeURIComponent(string));
  return encoded;
}
/**
 * 解码 fragment
 * @param text
 */

function decodeFragment(text) {
  var decoded = decodeURIComponent(window.atob(text));
  var json = JSON.parse(decoded);
  var fragment = Document.fromJSON(json);
  return fragment;
}
var clip;

var createClip = function createClip() {
  if (clip) return clip;
  var target = document.createElement('div');
  target.setAttribute('style', '-webkit-user-select: text !important');
  clip = new ClipboardManager({
    target: target
  });
  return clip;
};
/**
 * 数据写入系统剪切板
 * @param event
 * @param data
 * @param callback
 */


function setClipboardData(event, data, callback) {
  var _event$nativeEvent;

  var isFileData = Object.keys(data).some(function (type) {
    return type.startsWith('image');
  });

  if ((_event$nativeEvent = event.nativeEvent) != null && _event$nativeEvent.clipboardData) {
    var dataEntries = Object.entries(data);
    dataEntries.forEach(function (item) {
      var mimeType = item[0],
          content = item[1];

      if (!isFileMimeType(mimeType)) {
        var _event$nativeEvent2, _event$nativeEvent2$c;

        (_event$nativeEvent2 = event.nativeEvent) == null ? void 0 : (_event$nativeEvent2$c = _event$nativeEvent2.clipboardData) == null ? void 0 : _event$nativeEvent2$c.setData(mimeType, content);
      }
    });

    if (isFileData) {
      var clipManager = createClip();
      clipManager.writeFile(data, {
        succeeded: true,
        action: 'copy',
        text: ''
      })["finally"](function () {
        if (callback) {
          callback();
        }
      });
    } else if (callback) {
      callback();
    }
  } else {
    var _clipManager = createClip();

    _clipManager.write(data, false);

    window.requestAnimationFrame(function () {
      if (callback) {
        callback();
      }
    });
  }
}

function copyFragment(event, callback) {
  var _event$clipboardData, _event$clipboardData2, _event$clipboardData3, _data, _event$clipboardData4;

  var encodedFragment = (_event$clipboardData = event.clipboardData) == null ? void 0 : _event$clipboardData.getData(MIME_TYPES.FRAGMENT);
  var text = ((_event$clipboardData2 = event.clipboardData) == null ? void 0 : _event$clipboardData2.getData(MIME_TYPES.TEXT)) || encodedFragment && decodeFragment(encodedFragment).text || '';
  var html = ((_event$clipboardData3 = event.clipboardData) == null ? void 0 : _event$clipboardData3.getData(MIME_TYPES.HTML)) || text;
  var data = (_data = {}, _data[MIME_TYPES.FRAGMENT] = encodedFragment, _data[MIME_TYPES.HTML] = html, _data[MIME_TYPES.TEXT] = text, _data);
  var imageTypes = (_event$clipboardData4 = event.clipboardData) == null ? void 0 : _event$clipboardData4.types.filter(function (type) {
    return type.startsWith('image');
  });
  imageTypes == null ? void 0 : imageTypes.forEach(function (type) {
    var _event$clipboardData5;

    var imgData = (_event$clipboardData5 = event.clipboardData) == null ? void 0 : _event$clipboardData5.getData(type);

    if (imgData) {
      data[type] = imgData;
    }
  });
  setClipboardData(event, data, callback);
}

var transfer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getEventTransfer: getEventTransfer,
  encodeFragment: encodeFragment,
  decodeFragment: decodeFragment,
  copyFragment: copyFragment
});

function isEmptyObj(value) {
  if (isPlainObject$1(value) || isArray(value)) {
    return isEmpty(value);
  }

  return false;
}
function omitEmptyObj(obj) {
  return omitBy(obj, isEmptyObj);
}
function omitDeepBy(obj, predicate) {
  var nextObj = obj;
  forOwn(obj, function (value, key) {
    if (isObject(value)) {
      var _extends2;

      nextObj = _extends({}, nextObj, (_extends2 = {}, _extends2[key] = omitDeepBy(value, predicate), _extends2));
    }
  });
  return omitBy(nextObj, predicate);
}

function createClipboardDataFromSelection(controller) {
  var _document$data;

  var value = controller.value,
      uid = controller.uid;
  var document = value.document,
      selection = value.selection;
  var fragment = document.getFragmentAtRange(selection);
  fragment = withUserData(fragment, (_document$data = document.data) == null ? void 0 : _document$data.userData, uid);
  var dataTransfer = CangjieDataTransfer.create();
  var text = fragment.nodes.reduce(function (acc, node) {
    return acc + "\n" + node.text;
  }, '').slice(1);
  return dataTransfer.setData(MIME_TYPES.FRAGMENT, encodeFragment(fragment)).setData(MIME_TYPES.TEXT, text);
}
/**
 * 将节点的用户数据复制到 fragment 中
 * @param fragment 
 * @param userData 
 * @param uid 
 * @returns 
 */

function withUserData(fragment, userData, uid) {
  var originData = uid && (userData == null ? void 0 : userData[uid]);

  if (originData) {
    var nextData = {}; // 遍历 fragment 子节点，取出所有子节点的用户数据

    fragment.forEachDescendant(function (node) {
      var _node$data;

      var uuid = Element$1.isElement(node) ? (_node$data = node.data) == null ? void 0 : _node$data.uuid : null;

      if (uuid && originData != null && originData[uuid]) {
        nextData[uuid] = originData == null ? void 0 : originData[uuid];
      }
    }); // 用户数据复制到 fragment 中

    if (Object.keys(nextData).length > 0) {
      var _userData;

      return fragment.set('data', omitDeepBy(_extends({}, fragment.data, {
        userData: (_userData = {}, _userData[uid] = nextData, _userData)
      }), isEmptyObj));
    }
  }

  return fragment;
}

var _createElement$q = React__default.createElement;

var _ref$1 = /*#__PURE__*/_createElement$q("svg", {
  className: "icon",
  width: "24px",
  height: "24px",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg"
}, /*#__PURE__*/_createElement$q("path", {
  fill: "#ffffff",
  d: "M192 160a10.666667 10.666667 0 0 0-10.666667 10.666667v554.666666c0 5.888 4.778667 10.666667 10.666667 10.666667h42.666667v64h-42.666667A74.666667 74.666667 0 0 1 117.333333 725.333333V170.666667c0-41.216 33.450667-74.666667 74.666667-74.666667h469.333333c41.216 0 74.666667 33.450667 74.666667 74.666667v42.666666h-64V170.666667a10.666667 10.666667 0 0 0-10.666667-10.666667h-469.333333zM288 341.333333c0-41.216 33.450667-74.666667 74.666667-74.666666h469.333333c41.216 0 74.666667 33.450667 74.666667 74.666666v512a74.666667 74.666667 0 0 1-74.666667 74.666667h-469.333333A74.666667 74.666667 0 0 1 288 853.333333V341.333333z m74.666667-10.666666a10.666667 10.666667 0 0 0-10.666667 10.666666v512c0 5.888 4.778667 10.666667 10.666667 10.666667h469.333333a10.666667 10.666667 0 0 0 10.666667-10.666667V341.333333a10.666667 10.666667 0 0 0-10.666667-10.666666h-469.333333z"
}));

function Copy() {
  return _ref$1;
}

var _ref2 = /*#__PURE__*/_createElement$q("svg", {
  className: "icon",
  width: "24px",
  height: "24px",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg"
}, /*#__PURE__*/_createElement$q("path", {
  fill: "#ffffff",
  d: "M553.301333 484.48l259.712-318.378667-49.578666-40.448L384.426667 590.250667a160 160 0 1 0 46.208 44.586666L512 535.04l81.365333 99.754667a160 160 0 1 0 46.208-44.586667l-86.272-105.813333zM298.666667 629.333333c18.901333 0 36.565333 5.461333 51.413333 14.933334l17.621333 14.336A96 96 0 1 1 298.666667 629.333333zM210.986667 166.101333l182.058666 223.189334 41.216-50.773334-173.653333-212.906666-49.621333 40.490666zM673.92 644.266667a96 96 0 1 1-17.578667 14.336l17.578667-14.336z"
}));

function Cut() {
  return _ref2;
}

var _ref3$1 = /*#__PURE__*/_createElement$q("svg", {
  className: "icon",
  width: "24px",
  height: "24px",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg"
}, /*#__PURE__*/_createElement$q("path", {
  fill: "#ffffff",
  d: "M352 106.666667A32 32 0 0 1 384 74.666667h170.666667a32 32 0 0 1 32 32v32H640a32 32 0 0 1 32 32v10.666666H725.333333c41.216 0 74.666667 33.450667 74.666667 74.666667v85.333333h-64V256a10.666667 10.666667 0 0 0-10.666667-10.666667h-53.333333V298.666667a32 32 0 0 1-32 32H298.666667A32 32 0 0 1 266.666667 298.666667V245.333333H213.333333a10.666667 10.666667 0 0 0-10.666666 10.666667v554.666667c0 5.888 4.778667 10.666667 10.666666 10.666666h213.333334v64H213.333333A74.666667 74.666667 0 0 1 138.666667 810.666667V256c0-41.216 33.450667-74.666667 74.666666-74.666667h53.333334V170.666667A32 32 0 0 1 298.666667 138.666667h53.333333V106.666667z m64 32V170.666667a32 32 0 0 1-32 32H330.666667v64h277.333333v-64H554.666667a32 32 0 0 1-32-32v-32h-106.666667z m106.666667 352c0-41.216 33.450667-74.666667 74.666666-74.666667h256c41.216 0 74.666667 33.450667 74.666667 74.666667v341.333333A74.666667 74.666667 0 0 1 853.333333 906.666667h-256a74.666667 74.666667 0 0 1-74.666666-74.666667v-341.333333z m74.666666-10.666667a10.666667 10.666667 0 0 0-10.666666 10.666667v341.333333c0 5.888 4.778667 10.666667 10.666666 10.666667h256a10.666667 10.666667 0 0 0 10.666667-10.666667v-341.333333a10.666667 10.666667 0 0 0-10.666667-10.666667h-256z"
}));

function Paste() {
  return _ref3$1;
}

var _ref4 = /*#__PURE__*/_createElement$q("svg", {
  className: "icon",
  width: "24px",
  height: "24px",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg"
}, /*#__PURE__*/_createElement$q("path", {
  fill: "#ffffff",
  d: "M237.525333 187.178667a32 32 0 0 1 33.706667-1.962667l597.333333 324.266667a32 32 0 0 1-11.904 59.946666l-308.181333 32.426667-162.56 276.224a32 32 0 0 1-59.221333-11.221333L224.426667 218.325333a32 32 0 0 1 13.141333-31.146666z m60.16 85.205333l78.336 496.341333 125.44-213.205333a32 32 0 0 1 24.277334-15.616l221.781333-23.338667L297.728 272.384z"
}));

function Select() {
  return _ref4;
}

var _ref5 = /*#__PURE__*/_createElement$q("svg", {
  className: "icon",
  width: "24px",
  height: "24.00px",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg"
}, /*#__PURE__*/_createElement$q("path", {
  fill: "#ffffff",
  d: "M142.037333 154.965333l9.130667-3.797333 3.84-9.130667 9.130667 3.754667 7.424-3.072c6.357333-2.602667 13.226667-4.053333 20.437333-4.053333h85.333333v64H202.666667V277.333333h-64v-85.333333c0-7.168 1.450667-14.08 4.053333-20.437333l3.072-7.424-3.754667-9.173334zM352 138.666667H320v64h170.666667v-64H352z m213.333333 0h-32v64h170.666667v-64h-138.666667z m213.333334 0h-32v64h74.666666V277.333333h64v-85.333333c0-7.168-1.450667-14.08-4.053333-20.437333l-3.114667-7.424 3.84-9.173334-9.173333-3.797333-3.84-9.130667-9.130667 3.754667-7.424-3.072a53.248 53.248 0 0 0-20.437333-4.053333h-53.333333z m-576 213.333333V320h-64v170.666667h64V352z m682.666666 0V320h-64v170.666667h64V352z m-682.666666 213.333333v138.666667h-64v-170.666667h64v32z m682.666666 0v-32h-64v170.666667h64v-138.666667z m-682.666666 213.333334v-32h-64v85.333333c0 7.168 1.450667 14.08 4.053333 20.437333l3.072 7.424-3.754667 9.173334 9.130667 3.797333 3.84 9.173333 9.130667-3.84 7.424 3.114667c6.357333 2.602667 13.226667 4.053333 20.437333 4.053333h85.333333v-64H202.666667v-42.666666z m682.666666 0v-32h-64v74.666666H746.666667v64h85.333333c7.168 0 14.08-1.450667 20.437333-4.053333l7.424-3.114667 9.173334 3.84 3.797333-9.173333 9.173333-3.84-3.84-9.130667 3.114667-7.424a53.333333 53.333333 0 0 0 4.053333-20.437333v-53.333333z m-533.333333 42.666666H320v64h170.666667v-64H352z m213.333333 0h-32v64h170.666667v-64h-138.666667zM392.533333 580.181333L483.413333 298.666667h67.2l90.837334 281.514666 51.2 145.152h-67.84l-36.352-102.912h-142.933334L409.173333 725.333333H341.333333l51.2-145.152z m124.458667-177.28l-50.176 155.52h100.352l-50.176-155.52z"
}));

function SelectAll() {
  return _ref5;
}

/**
 * @packageDocumentation
 * @ignore
 */
var ACTION_COPY = Symbol('ACTION_COPY');
var ACTION_COPY_FAIL = Symbol('ACTION_COPY_FAIL');
var ACTION_CUT = Symbol('ACTION_CUT');
var ACTION_CUT_FAIL = Symbol('ACTION_CUT_FAIL');
var ACTION_PASTE = Symbol('ACTION_PASTE');
var ACTION_PASTE_FAIL = Symbol('ACTION_PASTE_FAIL');
var ACTION_SELECT = Symbol('ACTION_SELECT');
var ACTION_SELECT_ALL = Symbol('ACTION_SELECT_ALL');

function execCommandPolyfill(command) {
  var maybeHiddenTextArea = window.document.activeElement;
  var hiddenTextAreaOriginValue = '';
  var hiddenTextAreaOriginStart = 0;
  var hiddenTextAreaOriginEnd = 0;

  if (maybeHiddenTextArea instanceof HTMLTextAreaElement) {
    hiddenTextAreaOriginValue = maybeHiddenTextArea.value;
    hiddenTextAreaOriginStart = maybeHiddenTextArea.selectionStart;
    hiddenTextAreaOriginEnd = maybeHiddenTextArea.selectionEnd; // NOTE: `execCommand` will not trigger onCopy & onCut on Safari if selection is collapsed.

    maybeHiddenTextArea.value = ' ';
    maybeHiddenTextArea.selectionStart = 0;
    maybeHiddenTextArea.selectionEnd = maybeHiddenTextArea.value.length;
  }

  window.document.execCommand(command);

  if (maybeHiddenTextArea instanceof HTMLTextAreaElement) {
    maybeHiddenTextArea.value = hiddenTextAreaOriginValue;
    maybeHiddenTextArea.selectionStart = hiddenTextAreaOriginStart;
    maybeHiddenTextArea.selectionEnd = hiddenTextAreaOriginEnd;
  }
}

function execCommand(command, controller) {
  if (controller.value.isBlurred) {
    // 手动调用 flush, 触发 仓颉 HiddenTextarea 聚焦
    controller.command(focus).flush();
    requestAnimationFrame(function () {
      execCommandPolyfill(command);
    });
  } else {
    execCommandPolyfill(command);
  }
}

var pasteMenu = function pasteMenu(locale) {
  return {
    name: locale.paste,
    action: {
      type: ACTION_PASTE
    },
    key: 'paste',
    role: 'paste',
    icon: Paste,
    options: {
      hotKey: 'mod+v',
      mobile: true
    }
  };
}; // [defaultLocale] is the same as [configs.plugins.contextMenu]


function contextMenu(configs) {
  var _configs$plugins;

  var locale = (configs == null ? void 0 : (_configs$plugins = configs.plugins) == null ? void 0 : _configs$plugins.contextMenu) || defaultLocale;
  return function (controller, next) {
    var menus = [];
    var readOnly = controller.readOnly,
        canCopy = controller.canCopy;
    var _controller$value = controller.value,
        selection = _controller$value.selection,
        document = _controller$value.document;
    var isReadMode = Boolean(readOnly || controller.query('isQuickPreview'));
    var hasVoidParent = (selection == null ? void 0 : selection.isCollapsed) && document.hasVoidParent(selection.anchor.key, controller);

    if (hasVoidParent) ; else if (selection != null && selection.isExpanded) {
      var items = [{
        name: locale.cut,
        action: {
          type: ACTION_CUT
        },
        key: 'cut',
        role: 'cut',
        icon: Cut,
        options: {
          hotKey: 'mod+x',
          mobile: true,
          disable: isReadMode
        }
      }, {
        name: locale.copy,
        action: {
          type: ACTION_COPY
        },
        key: 'copy',
        role: 'copy',
        icon: Copy,
        options: {
          disable: isReadMode && !canCopy,
          hotKey: 'mod+c',
          mobile: true
        }
      }];

      if (!isReadMode) {
        items.push(pasteMenu(locale));
      }

      menus.push.apply(menus, items);
    } else if (selection != null && selection.isCollapsed && !selection.data.isByTable) {
      menus.push({
        name: locale.select,
        action: {
          type: ACTION_SELECT
        },
        key: 'select',
        icon: Select,
        options: {
          mobile: true,
          group: 10
        }
      }, {
        name: locale.selectAll,
        action: {
          type: ACTION_SELECT_ALL
        },
        key: 'select-all',
        icon: SelectAll,
        options: {
          hotKey: 'mod+a',
          mobile: true,
          group: 10
        }
      });
      menus.push({
        name: locale.cut,
        action: {
          type: ACTION_CUT
        },
        key: 'cut',
        role: 'cut',
        options: {
          hotKey: 'mod+x',
          disable: true
        }
      }, {
        name: locale.copy,
        action: {
          type: ACTION_COPY
        },
        key: 'copy',
        role: 'copy',
        options: {
          hotKey: 'mod+c',
          disable: true
        }
      });

      if (!isReadMode) {
        menus.push(pasteMenu(locale));
      }
    }

    var others = next() || [];
    return [].concat(menus, others);
  };
}

function handleAction(action, controller, next) {
  var type = action.type;

  if (type === ACTION_COPY) {
    if (IS_MOBILE) {
      // 移动端 document.activeElement 非 hiddenTextarea, 无法通过 execCommand 触发 copy 事件
      var event = CangjieClipboardEvent('cangjieCopy');

      try {
        controller.run('onCangjieCopy', event.setClipboardData(createClipboardDataFromSelection(controller)));
      } catch (error) {
        controller.run('onAction', {
          type: ACTION_COPY_FAIL,
          payload: {
            error: error
          }
        });
        throw error;
      }
    } else {
      execCommand('copy', controller);
    }
  } else if (type === ACTION_CUT) {
    if (IS_MOBILE) {
      var _event = CangjieClipboardEvent('cangjieCut');

      try {
        controller.run('onCangjieCut', _event.setClipboardData(createClipboardDataFromSelection(controller)));
      } catch (error) {
        controller.run('onAction', {
          type: ACTION_CUT_FAIL,
          payload: {
            error: error
          }
        });
        throw error;
      }
    } else {
      execCommand('cut', controller);
    }
  } else if (type === ACTION_PASTE) {
    var _event2 = CangjieClipboardEvent('cangjiePaste');

    if (IS_MOBILE) {
      var _event2$clipboardData;

      var customEvent = _event2.setClipboardData(CangjieDataTransfer.create());

      var html = (_event2$clipboardData = _event2.clipboardData) == null ? void 0 : _event2$clipboardData.getData('text/html');

      if (html) {
        var customData = readClipboardDataFromHtml(html);
        customData.forEach(function (_ref) {
          var _customEvent$clipboar;

          var dataType = _ref[0],
              data = _ref[1];
          (_customEvent$clipboar = customEvent.clipboardData) == null ? void 0 : _customEvent$clipboar.setData(dataType, data);
        });
      }

      try {
        controller.run('onCangjiePaste', customEvent);
      } catch (error) {
        controller.run('onAction', {
          type: ACTION_PASTE_FAIL,
          payload: {
            isShortcut: false,
            error: error
          }
        });
        throw error;
      }
    } else {
      var isPasteEnable = window.document.execCommand('paste');

      if (!isPasteEnable) {
        getClipboardData().then(function (clipboardData) {
          controller.run('onCangjiePaste', _event2.setClipboardData(clipboardData));
        }, function (error) {
          controller.run('onAction', {
            type: ACTION_PASTE_FAIL,
            payload: {
              isShortcut: false,
              error: error
            }
          });
          console.error(error);
        });
      }
    }
  } else if (type === ACTION_SELECT) {
    // Select
    var selection = controller.value.selection;
    selection && controller.command(selectWordAtPoint, selection.anchor);
  } else if (type === ACTION_SELECT_ALL) {
    // Select All
    var _controller$value2 = controller.value,
        document = _controller$value2.document,
        _selection = _controller$value2.selection;
    _selection && controller.run('onCangjieSelect', CangjieSelectEvent({
      selection: _selection.moveToRangeOfNode(document, controller)
    }));
  }

  return next();
}

var createContextMenuPlugin = (function (configs) {
  return {
    contextMenu: contextMenu(configs),
    onAction: handleAction,
    models: []
  };
});

var contextMenu$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ACTION_COPY: ACTION_COPY,
  ACTION_COPY_FAIL: ACTION_COPY_FAIL,
  ACTION_CUT: ACTION_CUT,
  ACTION_CUT_FAIL: ACTION_CUT_FAIL,
  ACTION_PASTE: ACTION_PASTE,
  ACTION_PASTE_FAIL: ACTION_PASTE_FAIL,
  ACTION_SELECT: ACTION_SELECT,
  ACTION_SELECT_ALL: ACTION_SELECT_ALL,
  'default': createContextMenuPlugin
});

/**
 * @packageDocumentation
 * @ignore
 */
function useScroll(_ref) {
  var onStart = _ref.onStart,
      onEnd = _ref.onEnd;
  React.useEffect(function () {
    var timeout = null;
    var isStarted = false;

    var handleScrollEvent = function handleScrollEvent() {
      timeout && clearTimeout(timeout);
      onStart();
      isStarted = true;
      timeout = window.setTimeout(function () {
        onEnd();
        isStarted = false;
      }, 300);
    };

    window.addEventListener('scroll', handleScrollEvent, true);
    return function () {
      if (isStarted) {
        onEnd();
        isStarted = false;
      }

      timeout && clearTimeout(timeout);
      window.removeEventListener('scroll', handleScrollEvent, true);
    };
  });
}

/**
 * @packageDocumentation
 * @module domUtils
 */

function isAfterNewLine(leaf, offset) {
  var _leaf$firstChild;

  return ((_leaf$firstChild = leaf.firstChild) == null ? void 0 : _leaf$firstChild.textContent) && leaf.firstChild.textContent[offset - 1] === '\n';
}
/**
 *
 * Caret Hanging Optimization
 *
 * By default, the [caret] is inserted **after the charactor**:
 *
 *   [charactor][caret][may-be-a-line-break][next charactor].
 *
 * For multi-lines paragraph, the start of the non-first line cannot be focused
 * by this behaviour. Then we optimize the caret insert position to **before
 * the last characotr** if the user is clicking/touching the very left side:
 *
 *   [charactor][may-be-a-line-break][caret][next charactor]
 *
 */
// If the caret can hanging, return the position; otheriwse return null


function findHangingPosition(node, offset, originLength) {
  /**
   * Detect is it can hanging.
   *
   * we get the rects of the newRange, whose offset is [originOffset + 1]
   * if the newRange have one more rect than the old one, then we know that
   * there is a line break between [offset, offset + 1]
   */
  var detectRange = window.document.createRange();

  try {
    detectRange.setStart(node, 0);
    detectRange.setEnd(node, Math.max(offset, 0));
  } catch (error) {
    return null;
  }

  var detectRects = detectRange.getClientRects();
  var length = detectRects.length;

  if (length > originLength && length > 1) {
    // the newRange has more rects than the old range
    var secondLastRect = detectRects[length - 2];
    var lastRect = detectRects[length - 1]; // skip is it's still in same line

    if (lastRect.left >= secondLastRect.right) {
      return null;
    } // it's a new line, binggo!


    var top = lastRect.top,
        left = lastRect.left,
        height = lastRect.height;
    return {
      top: top,
      left: left,
      height: height
    };
  }

  return null;
}

function getTextContentLength(childNode) {
  return childNode.textContent ? childNode.textContent.length : 0;
}

function findTextNodeAtOffset(element, offset) {
  var remainedOffset = offset;
  var childNodes = element.childNodes;

  for (var i = 0; i < childNodes.length; i += 1) {
    var childNode = childNodes[i];
    var textContentLength = getTextContentLength(childNode);

    if (childNode.nodeType === Node.TEXT_NODE) {
      if (textContentLength >= remainedOffset) {
        return [childNode, remainedOffset];
      }
    } else if (childNode.nodeType === Node.ELEMENT_NODE) {
      if (textContentLength >= remainedOffset) {
        return findTextNodeAtOffset(childNode, remainedOffset);
      }
    } // Ignore other Node.TYPE


    remainedOffset -= textContentLength;
  }

  return findTextNodeAtOffset(element, getTextContentLength(element));
}

function findEdgePointPosition(point, root, maxEdgeHeight, zoom) {
  if (root === void 0) {
    root = window;
  }

  if (maxEdgeHeight === void 0) {
    maxEdgeHeight = CURSOR_EDGE_MAX_HEIGHT;
  }

  if (zoom === void 0) {
    zoom = 1;
  }

  var key = point.key; // eslint-disable-next-line react/no-find-dom-node

  var node = findDOMNodeSafely(key, root);

  if (!node) {
    return undefined;
  }

  var edge = point.edge;
  var rect = node.getBoundingClientRect();
  var height = Math.min(Math.round(rect.height), maxEdgeHeight);
  var heightWithZoom = height > maxEdgeHeight ? height / zoom : height;
  var clientLeft = edge === EdgePoint.BEFORE ? rect.left - CURSOR_EDGE_OFFSET - CURSOR_WIDTH : rect.right + CURSOR_EDGE_OFFSET;
  return {
    node: node,
    clientTop: rect.bottom / zoom - heightWithZoom,
    clientLeft: clientLeft / zoom,
    height: heightWithZoom
  };
}
function findTextPointPosition(point, preferredEdge, root, zoom) {
  if (root === void 0) {
    root = window;
  }

  if (zoom === void 0) {
    zoom = 1;
  }

  var isHanging = preferredEdge === 'start';
  var leaves = findDOMLeaves(point.key, root);

  if (!leaves.length) {
    return undefined;
  }
  /**
   * Step 1, find the leaf DOM node
   */


  var offset = point.offset;
  var leaf = leaves.find(function (_, index) {
    var nextLeaf = leaves[index + 1];

    if (!nextLeaf) {
      return true;
    }

    var leafKey = nextLeaf.getAttribute(Selector.key);
    var startOffset = leafKey ? keyUtils.parse(leafKey)[1] : null;

    if (!startOffset) {
      return false;
    }

    return startOffset >= offset;
  });

  if (!leaf || !leaf.firstChild) {
    return undefined;
  }

  var leafKey = leaf.getAttribute(Selector.key);
  var startOffset = leafKey ? keyUtils.parse(leafKey)[1] : null;

  if (!startOffset && startOffset !== 0) {
    return undefined;
  }
  /**
   * Step 2, calculate the rects
   */


  var range = window.document.createRange();

  try {
    range.setStart.apply(range, findTextNodeAtOffset(leaf, 0));
    range.setEnd.apply(range, findTextNodeAtOffset(leaf, offset - startOffset));
  } catch (error) {
    return undefined;
  } // example: <span leaf-content key=`key:startOffset`>TEXT [offset] TEXT</span>


  var rangeRects = Array.from(range.getClientRects());
  var firstRangeRect = rangeRects[0];
  var lastRangeRect = rangeRects[rangeRects.length - 1];

  if (!firstRangeRect || !lastRangeRect) {
    return undefined;
  }
  /**
   * Step 3, detect hanging
   */


  var textContent = leaf.firstChild.textContent || '';
  var hangingPosition = null;
  var detectOffset = offset - startOffset + 1;

  if (isHanging && textContent.length >= detectOffset) {
    hangingPosition = findHangingPosition(leaf.firstChild, detectOffset, rangeRects.length);
  }

  var top = lastRangeRect.top,
      height = lastRangeRect.height;
  var left = lastRangeRect.right;
  /**
   * Step 4, detect soft line break
   */
  // if the point is after \n
  // calculate the following bounding rect (offset, offset + 1)
  // and choose left side of following bounding rect

  if (isAfterNewLine(leaf, offset)) {
    try {
      range.setStart(leaf.firstChild, offset - startOffset);
      range.setEnd(leaf.firstChild, Math.max(Math.min(detectOffset, textContent.length), 0));
    } catch (error) {
      return undefined;
    }

    var rects = range.getClientRects();
    var followingRect = rects[rects.length - 1];

    if (followingRect) {
      left = followingRect.left;
      top = followingRect.top;
      height = followingRect.height;
    }
  } // then we have the final position


  if (hangingPosition) {
    var _hangingPosition = hangingPosition;
    left = _hangingPosition.left;
    top = _hangingPosition.top;
    height = _hangingPosition.height;
  }

  var clientLeft = left,
      clientTop = top;
  return {
    node: leaf,
    clientTop: clientTop / zoom,
    clientLeft: clientLeft / zoom - CURSOR_WIDTH / 2,
    height: height / zoom
  };
}
function findCaretPosition(point, preferredEdge, root, maxEdgeHeight, // 缩放比例
zoom) {
  if (root === void 0) {
    root = window;
  }

  if (maxEdgeHeight === void 0) {
    maxEdgeHeight = CURSOR_EDGE_MAX_HEIGHT;
  }

  if (zoom === void 0) {
    zoom = 1;
  }

  return point.isEdgePoint() ? findEdgePointPosition(point, root, maxEdgeHeight, zoom) : findTextPointPosition(point, preferredEdge, root, zoom);
}

var ARROW_SIZE = 10;
var POPUP_MIN_SPACE = 6;
var TOP_SAFE_SPACE = 42;

function getSelectionRect(selection, controller) {
  var range = null;

  try {
    // get the dom rectangles from the selction
    range = findDOMRange(selection, controller);
  } catch (_) {
    return null;
  }

  if (!range) {
    return null;
  }

  var domRects = Array.from(range.getClientRects());

  if (!domRects.length) {
    return null;
  }

  var _domRects$ = domRects[0],
      left = _domRects$.left,
      right = _domRects$.right,
      top = _domRects$.top,
      bottom = _domRects$.bottom; // compute the rectangle area

  var rect = Array.from(domRects).reduce(function (obj, item) {
    obj.left = Math.min(item.left, obj.left);
    obj.top = Math.min(item.top, obj.top);
    obj.right = Math.max(item.right, obj.right);
    obj.bottom = Math.max(item.bottom, obj.bottom);
    return obj;
  }, {
    left: left,
    right: right,
    top: top,
    bottom: bottom
  });
  return rect;
}

function getCaretRect(selection, root) {
  var preferredEdge = selection.isHanging ? 'start' : 'end';
  var position = findCaretPosition(selection.anchor, preferredEdge, root);

  if (!position) {
    return null;
  }

  var left = position.clientLeft,
      top = position.clientTop,
      height = position.height;
  var right = left;
  var bottom = top + height;
  return {
    left: left,
    right: right,
    top: top,
    bottom: bottom
  };
}

var getPopupPosition = function getPopupPosition(selection, controller, popupWidth, popupHeight, defaultTop) {
  if (defaultTop === void 0) {
    defaultTop = true;
  }

  var document = controller.value.document;
  var root = findDOMNodeSafely(document.key);
  var rect = selection.isCollapsed ? getCaretRect(selection, root) : getSelectionRect(selection, controller);

  if (!rect) {
    return null;
  } // default position is on top of selection


  var isTop = defaultTop; // move to bottom if the top is reaching out of screen

  if (rect.top - (popupHeight + POPUP_MIN_SPACE) < TOP_SAFE_SPACE) {
    isTop = false;
  } // special case when the user select very long text that exceed screen bottom


  if (rect.bottom + (popupHeight + POPUP_MIN_SPACE) > window.innerHeight) {
    isTop = true;
  } // default arrow is at the middle


  var arrowOffset = popupWidth / 2 - ARROW_SIZE / 2;
  var x = (rect.left + rect.right) / 2 - popupWidth / 2;
  var y = isTop ? rect.top - popupHeight - ARROW_SIZE : rect.bottom + ARROW_SIZE; // if popup is exceed the left/right edge, move it by the [offsetX] value

  var offsetX = 0;

  if (x < POPUP_MIN_SPACE) {
    offsetX = POPUP_MIN_SPACE - x;
  }

  if (x + popupWidth > window.innerWidth - POPUP_MIN_SPACE) {
    offsetX = window.innerWidth - x - popupWidth - POPUP_MIN_SPACE;
  }

  if (offsetX !== 0) {
    x += offsetX;
    arrowOffset -= offsetX;
  }

  arrowOffset = Math.min(popupWidth - ARROW_SIZE * 2, Math.max(ARROW_SIZE, arrowOffset));
  y = Math.max(y, TOP_SAFE_SPACE);
  return {
    x: x,
    y: y,
    isTop: isTop,
    arrowOffset: arrowOffset
  };
};

function useSelectionData(selectionData$, key, onSelectionData, deps) {
  React__default.useEffect(function () {
    var subs = selectionData$.subscribe(function (_ref) {
      var range = _ref.range,
          blocksKeys = _ref.blocksKeys,
          isHideSelection = _ref.isHideSelection;
      var isSelected = key === null ? null : blocksKeys.has(key);
      onSelectionData({
        range: range,
        isSelected: isSelected,
        isHideSelection: isHideSelection
      });
    });
    return subs.unsubscribe;
  }, [key, onSelectionData].concat(deps));
}
function useSelectionDataAtTheStartOfNextFrame(selectionData$, key, onSelectionDataNextFrame, deps) {
  var animId = React__default.useRef(null);
  var onSelectionData = React__default.useCallback(function (pendingData) {
    animId.current = window.requestAnimationFrame(function () {
      onSelectionDataNextFrame(pendingData);
    });
  }, [onSelectionDataNextFrame]);
  React__default.useEffect(function () {
    return function () {
      if (animId.current) {
        window.cancelAnimationFrame(animId.current);
      }
    };
  }, []);
  useSelectionData(selectionData$, key, onSelectionData, deps);
}

var _createElement$p = React.createElement;
var ITEM_HEIGHT = 54;
var POPUP_HEIGHT = ITEM_HEIGHT + 8 * 2;
var POPUP_BOTTOM_EXTRA_HEIGHT = 20;
var wrapperStyle$1 = {
  position: 'fixed',
  zIndex: Z_INDEX_CONTEXTMENU,
  backgroundColor: '#585A5C',
  padding: '8px 4px',
  borderRadius: '8px',
  display: 'flex',
  flexDirection: 'row',
  opacity: '0',
  transition: 'opacity 0.3s'
};
var itemStyle = {
  height: ITEM_HEIGHT + "px",
  lineHeight: '16px',
  color: 'white',
  minWidth: '56px',
  width: '56px',
  fontSize: '10px',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  flexDirection: 'column',
  whiteSpace: 'nowrap',
  overflow: 'hidden'
};
var iconStyle = {
  width: '24px',
  height: '24px',
  marginBottom: '2px'
};
var arrowStyle = {
  position: 'absolute',
  bottom: '-4px',
  width: '10px',
  height: '10px',
  backgroundColor: '#585A5C',
  transform: 'rotate(45deg)'
};

var arrowStyleTop = _extends({}, arrowStyle, {
  bottom: 'inherit',
  top: '-4px'
});

function ContextMenu(props) {
  var selection = props.selection,
      controller = props.controller,
      hidePopup = props.hidePopup;

  var _React$useState = React.useState(null),
      position = _React$useState[0],
      setPosition = _React$useState[1];

  var rootRef = React.useRef(null);

  var updatePosition = function updatePosition() {
    if (rootRef.current) {
      var _rootRef$current$getB = rootRef.current.getBoundingClientRect(),
          width = _rootRef$current$getB.width;

      var pos = getPopupPosition(selection, controller, width, POPUP_HEIGHT, IS_MOBILE);
      setPosition(pos);
    }
  };

  React.useEffect(updatePosition, [selection]);
  var setNodeVisible = React.useCallback(function (visible) {
    var node = rootRef.current;

    if (selection.isCollapsed) {
      hidePopup && hidePopup(controller);
    } else if (node) {
      node.style.opacity = visible ? '1' : '0';
    }
  }, [selection, hidePopup]);
  useSelectionData(controller.selectionData$, null, function (_ref) {
    var range = _ref.range;

    if (range.isExpanded && selection.isCollapsed) {
      setNodeVisible(false);
    }
  }, []);
  useScroll({
    onStart: function onStart() {
      setNodeVisible(false);
    },
    onEnd: function onEnd() {
      updatePosition();
      setNodeVisible(true);
    }
  });
  var buttons = controller.run('contextMenu').filter(function (b) {
    var _b$options;

    return Boolean((_b$options = b.options) == null ? void 0 : _b$options.mobile);
  });
  buttons = buttons.sort(function (a, b) {
    var _a$options, _b$options2;

    var groupA = ((_a$options = a.options) == null ? void 0 : _a$options.group) || 0;
    var groupB = ((_b$options2 = b.options) == null ? void 0 : _b$options2.group) || 0;
    return groupA - groupB;
  });
  var styleForWrapper = position ? _extends({}, wrapperStyle$1, {
    left: position.x,
    top: position.isTop ? position.y : position.y + POPUP_BOTTOM_EXTRA_HEIGHT,
    opacity: 1
  }) : wrapperStyle$1;

  var handleAction = function handleAction(button) {
    return function (event) {
      event.stopPropagation();
      event.preventDefault();
      controller.run('onAction', button.action);
    };
  };

  var availableButtons = buttons.filter(function (btn) {
    if (btn.options && btn.options.disable) {
      return false;
    }

    return true;
  }); // 如果可用的 buttons 数为 0，则不渲染

  if (availableButtons.length <= 0) {
    return null;
  }

  var styleForArrow = position ? _extends({}, position.isTop ? arrowStyle : arrowStyleTop, {
    left: position.arrowOffset
  }) : arrowStyle;
  return /*#__PURE__*/_createElement$p("div", {
    "data-role": "mobileContextMenu",
    ref: rootRef,
    className: "cangjieContextMenu",
    style: styleForWrapper
  }, availableButtons.map(function (button, index) {
    var name = button.name,
        role = button.role,
        Icon = button.icon;
    return /*#__PURE__*/_createElement$p("div", {
      key: name,
      "data-role": role || '',
      onMouseDown: handleAction(button),
      onTouchEnd: handleAction(button),
      style: itemStyle
    }, typeof Icon !== 'function' && /*#__PURE__*/_createElement$p("img", {
      style: iconStyle,
      src: Icon || 'https://gw.alicdn.com/imgextra/i4/O1CN011xit6C1NdBJNUvlF9_!!6000000001592-55-tps-24-24.svg'
    }), typeof Icon === 'function' && /*#__PURE__*/_createElement$p(Icon, null), /*#__PURE__*/_createElement$p("div", null, name));
  }), /*#__PURE__*/_createElement$p("span", {
    style: styleForArrow
  }));
}

var ContextMenu$1 = (function (props) {
  return /*#__PURE__*/ReactDOM__default.createPortal( /*#__PURE__*/_createElement$p(ContextMenu, props), document.body);
});

/**
 * @packageDocumentation
 * @module Hooks
 */
/**
 * @ignore
 */

var ZoomContext = /*#__PURE__*/React.createContext(1);
/**
 * @ignore
 */

var ExternalZoomContext = /*#__PURE__*/React.createContext(1);
/**
 * @ignore
 */

var ZoomContainerContext = /*#__PURE__*/React.createContext(null);
function useZoom() {
  return React.useContext(ZoomContext);
}
/**
 * @ignore
 *
 * TODO: external zoom 是为了感知上层业务自行实现的缩放，但是这个设计是不合理的，上层业务从使
 * 用上看，没必要自行实现缩放功能，应该使用 cangjie 自带的缩放设计。后续希望移除此部分的 API。
 *
 * 目前已知的业务自行实现的缩放场景：PC 演示模式、生成长图
 * 2021-0222 新加：缩放状态下的评论
 */

function useExternalZoom() {
  return React.useContext(ExternalZoomContext);
}
function useZoomContainer() {
  return React.useContext(ZoomContainerContext);
}

var _createElement$o = React.createElement;
var WIDTH = 160;
var HEIGHT = 128;
var ZOOM = 1.8;
var POPUP_EXTRA_TOP = -4;
var POPUP_EXTRA_BOTTOM = 52;
var rootStyle = {
  position: 'fixed',
  overflow: 'hidden',
  left: '50px',
  top: '50px',
  zIndex: 10000,
  background: 'white',
  width: WIDTH,
  height: HEIGHT,
  border: '1px solid rgba(17,31,44,0.12)',
  boxShadow: '0 4px 8px 0 rgba(0,0,0,0.08), inset 0 10px 20px 0 rgba(0,0,0,0.08)',
  borderRadius: '8px',
  opacity: 0
};
var blockContainerStyle = {
  backfaceVisibility: 'hidden',
  transformOrigin: 'top left'
};

// remove all the *cangjie* attributes
function cleanNode(node) {
  Array.from(node.attributes).forEach(function (attr) {
    if (attr.name.indexOf('cangjie') >= 0) {
      node.removeAttribute(attr.name);
    }
  });
  Array.from(node.children).forEach(function (child) {
    cleanNode(child);
  });
}

function clearNode(node) {
  while (node && node.lastChild) {
    node.removeChild(node.lastChild);
  }
}

function Zoomer(pros) {
  var controller = useController();
  var container = useZoomContainer();
  var point = pros.point,
      isHanging = pros.isHanging;

  var _React$useState = React.useState(new WeakMap()),
      cachedBlocks = _React$useState[0];

  var blockRef = React.useRef(null);
  var rootRef = React.useRef(null);
  React.useEffect(function () {
    var blockNode = blockRef.current;
    var _controller$value = controller.value,
        document = _controller$value.document,
        selection = _controller$value.selection;

    var _selection$sort = selection.sort(document),
        start = _selection$sort.start;

    var preferredEdge = point === start ? 'start' : 'end';
    var pointPosition = findCaretPosition(point, preferredEdge, container || window);

    if (!blockNode || !pointPosition) {
      return;
    } // Get the DOM elements
    // eslint-disable-next-line react/no-find-dom-node


    var ancestor = document.getAncestors(point.key)[0];
    var dom = findDOMNode(ancestor.key);
    var maybePrevDom = dom.previousElementSibling;
    var prevDom = maybePrevDom && !maybePrevDom.getAttribute('data-cangjie-hidden') ? maybePrevDom : null;
    var nextDom = dom.nextElementSibling; // Clone the DOM elements and cache them if necessary

    var prevArticleBlock = prevDom ? cachedBlocks.get(prevDom) || prevDom.cloneNode(true) : null;
    var nextArticleBlock = nextDom ? cachedBlocks.get(nextDom) || nextDom.cloneNode(true) : null;

    if (prevDom && prevArticleBlock && !cachedBlocks.get(prevDom)) {
      cleanNode(prevArticleBlock);
      cachedBlocks.set(prevDom, prevArticleBlock);
    }

    if (nextDom && nextArticleBlock && !cachedBlocks.get(nextDom)) {
      cleanNode(nextArticleBlock);
      cachedBlocks.set(nextDom, nextArticleBlock);
    } // We never cache the focused DOM element


    var articleBlock = dom.cloneNode(true);
    cleanNode(articleBlock); // Calculate the offset positions

    var domRect = dom.getBoundingClientRect();
    var marginTop = parseInt(window.getComputedStyle(dom).marginTop, 10) || 0;
    var offsetX = pointPosition.clientLeft - domRect.left - WIDTH / ZOOM / 2;
    var offsetY = pointPosition.clientTop + pointPosition.height / 2 - domRect.top + marginTop - HEIGHT / ZOOM / 2;

    if (prevDom && prevArticleBlock) {
      var prevStyle = window.getComputedStyle(prevDom);
      var prevMarginTop = parseInt(prevStyle.marginTop, 10) || 0;
      var prevMarginBottom = parseInt(prevStyle.marginBottom, 10) || 0;
      offsetY += prevDom.getBoundingClientRect().height + prevMarginTop + prevMarginBottom;
    }

    var focusedSelection = Selection.create({
      anchor: point,
      focus: point
    }).setHanging(isHanging);
    var popupPosition = getPopupPosition(focusedSelection, controller, WIDTH, HEIGHT); // Attach the DOM elements and apply all positions

    clearNode(blockNode);

    if (prevArticleBlock) {
      blockNode.appendChild(prevArticleBlock);
    }

    blockNode.appendChild(articleBlock);

    if (nextArticleBlock) {
      blockNode.appendChild(nextArticleBlock);
    }

    if (rootRef.current && popupPosition) {
      var isTop = popupPosition.isTop,
          x = popupPosition.x,
          y = popupPosition.y;
      var extraOffset = isTop ? POPUP_EXTRA_TOP : POPUP_EXTRA_BOTTOM;
      rootRef.current.style.left = x + "px";
      rootRef.current.style.top = y + extraOffset + "px";
      rootRef.current.style.opacity = '1';
    }

    blockNode.style.width = domRect.width + "px";
    blockNode.style.transform = "translate(" + -offsetX * ZOOM + "px, " + -offsetY * ZOOM + "px) scale(" + ZOOM + ")";
  }, [cachedBlocks, container, controller, point]);
  return /*#__PURE__*/_createElement$o("div", {
    "data-cangjie-mobile-zoomer": true,
    style: rootStyle,
    ref: rootRef
  }, /*#__PURE__*/_createElement$o("div", {
    style: blockContainerStyle,
    ref: blockRef
  }));
}

var Zoomer$1 = (function (props) {
  var container = useZoomContainer();
  var attachNode = container == null ? void 0 : container.querySelector('[data-cangjie-zoomer]');

  if (!attachNode) {
    return null;
  }

  return /*#__PURE__*/ReactDOM__default.createPortal( /*#__PURE__*/_createElement$o(Zoomer, props), attachNode);
});

/**
 * @packageDocumentation
 * @ignore
 */
// 参考 mac 下最大字号 72pt * 1.7 行高 = 163px 设置的 magic number

var MAX_LINE_HEIGHT = 150; // 往上滚动时，底部预留额外距离。参考竞品 (G Docs)，移动端间距会大一些 (一行 + 4px)

var EXTRA_BOTTOM_OFFSET = IS_MOBILE ? 66 : 12;
function findScrollableContainer(el, window) {
  if (!el) {
    return null;
  }

  var scroller;
  var parent = el.parentNode;

  while (!scroller) {
    if (!parent.parentNode) break;
    var style = window.getComputedStyle(parent);
    var overflowY = style.overflowY;

    if (['auto', 'overlay', 'scroll'].includes(overflowY)) {
      scroller = parent;
      break;
    }

    parent = parent.parentNode;
  } // COMPAT: Because Chrome does not allow doucment.body.scrollTop, we're
  // assuming that window.scrollTo() should be used if the scrollable element
  // turns out to be document.body or document.documentElement. This will work
  // unless body is intentionally set to scrollable by restricting its height
  // (e.g. height: 100vh).


  if (!scroller) {
    return window.document.body;
  }

  return scroller;
}
function getScrollableContainerInfo(scroller) {
  var isWindow = scroller === window || scroller === window.document.body || scroller === window.document.documentElement; // @ts-ignore

  var _window = window,
      innerHeight = _window.innerHeight,
      visualViewport = _window.visualViewport,
      _visualHeight = _window._visualHeight;
  var width;
  var height;
  var yOffset;
  var xOffset;
  var scrollerTop = 0;
  var scrollerLeft = 0;
  var scrollerBordersY = 0;
  var scrollerBordersX = 0;
  var scrollerPaddingTop = 0;
  var scrollerPaddingBottom = 0;
  var scrollerPaddingLeft = 0;
  var scrollerPaddingRight = 0; // iOS 13/14 Safari浏览器，去除键盘高度后的视口高度

  var viewportHeight = visualViewport ? visualViewport.height : innerHeight; // 底部工具条弹出时，下面区域视为 viewport 之外

  if (typeof _visualHeight === 'number' && _visualHeight > 0) {
    viewportHeight = _visualHeight;
  }

  if (isWindow) {
    // @ts-ignore
    var _window2 = window,
        innerWidth = _window2.innerWidth,
        pageYOffset = _window2.pageYOffset,
        pageXOffset = _window2.pageXOffset;
    width = innerWidth;
    height = innerHeight;
    yOffset = pageYOffset;
    xOffset = pageXOffset;
  } else {
    var _ref = scroller,
        offsetWidth = _ref.offsetWidth,
        offsetHeight = _ref.offsetHeight,
        scrollTop = _ref.scrollTop,
        scrollLeft = _ref.scrollLeft;

    var _window$getComputedSt = window.getComputedStyle(scroller),
        borderTopWidth = _window$getComputedSt.borderTopWidth,
        borderBottomWidth = _window$getComputedSt.borderBottomWidth,
        borderLeftWidth = _window$getComputedSt.borderLeftWidth,
        borderRightWidth = _window$getComputedSt.borderRightWidth,
        paddingTop = _window$getComputedSt.paddingTop,
        paddingBottom = _window$getComputedSt.paddingBottom,
        paddingLeft = _window$getComputedSt.paddingLeft,
        paddingRight = _window$getComputedSt.paddingRight;

    var scrollerRect = scroller.getBoundingClientRect();
    width = offsetWidth;
    height = offsetHeight;
    scrollerTop = scrollerRect.top + parseInt(borderTopWidth, 10);
    scrollerLeft = scrollerRect.left + parseInt(borderLeftWidth, 10);
    scrollerBordersY = parseInt(borderTopWidth, 10) + parseInt(borderBottomWidth, 10);
    scrollerBordersX = parseInt(borderLeftWidth, 10) + parseInt(borderRightWidth, 10);
    scrollerPaddingTop = parseInt(paddingTop, 10);
    scrollerPaddingBottom = parseInt(paddingBottom, 10);
    scrollerPaddingLeft = parseInt(paddingLeft, 10);
    scrollerPaddingRight = parseInt(paddingRight, 10);
    yOffset = scrollTop;
    xOffset = scrollLeft;
  }

  return {
    isWindow: isWindow,
    width: width,
    height: height,
    viewportHeight: viewportHeight,
    scrollerTop: scrollerTop,
    scrollerLeft: scrollerLeft,
    xOffset: xOffset,
    yOffset: yOffset,
    scrollerPaddingLeft: scrollerPaddingLeft,
    scrollerPaddingRight: scrollerPaddingRight,
    scrollerPaddingTop: scrollerPaddingTop,
    scrollerPaddingBottom: scrollerPaddingBottom,
    scrollerBordersX: scrollerBordersX,
    scrollerBordersY: scrollerBordersY
  };
}
function getDOMRectFromSelection(selection, content, controller) {
  var collapsedSelection = selection.moveToFocus();

  if (!collapsedSelection) {
    return null;
  }

  var anchor = collapsedSelection.anchor;

  if (anchor.isEdgePoint()) {
    var node = null;

    try {
      // eslint-disable-next-line react/no-find-dom-node
      node = findDOMNode(anchor.key);
    } catch (error) {// ignore
    }

    if (!node) {
      return null;
    }

    var domRect = node.getBoundingClientRect();
    var top = domRect.top,
        height = domRect.height;
    var left = anchor.edge === EdgePoint.BEFORE ? domRect.left : domRect.right;
    return typeof DOMRect !== 'undefined' ? new DOMRect(left, top, 1, height) : null;
  }

  var range = null;

  try {
    range = findDOMRange(collapsedSelection, controller, content);
  } catch (e) {
    return null;
  }

  if (!range) {
    return null;
  }

  var cursorRect = range.getClientRects()[0];

  if (!cursorRect) {
    return null;
  }

  return cursorRect;
}
function scrollToSelection(selection, content, scroller, controller) {
  var inline = controller.value.document.getClosestInline(selection.focus.key);
  var rect; // 光标在 inline 元素内部

  if (inline) {
    var inlineDOM = findDOMNodeSafely(inline.key);

    if (!inlineDOM) {
      return;
    }

    var inlineRect = inlineDOM.getBoundingClientRect();
    rect = {
      node: inlineDOM,
      clientLeft: inlineRect.left + inlineRect.width / 2,
      clientTop: inlineRect.top,
      height: inlineRect.height // 以 inline 的尺寸为准

    };
  } else {
    rect = findCaretPosition(selection.focus, selection.isHanging ? 'start' : 'end', content, Infinity);
  }

  if (!rect) {
    return;
  }

  var _getScrollableContain = getScrollableContainerInfo(scroller),
      isWindow = _getScrollableContain.isWindow,
      width = _getScrollableContain.width,
      height = _getScrollableContain.height,
      viewportHeight = _getScrollableContain.viewportHeight,
      scrollerTop = _getScrollableContain.scrollerTop,
      scrollerLeft = _getScrollableContain.scrollerLeft,
      xOffset = _getScrollableContain.xOffset,
      yOffset = _getScrollableContain.yOffset,
      scrollerPaddingLeft = _getScrollableContain.scrollerPaddingLeft,
      scrollerPaddingRight = _getScrollableContain.scrollerPaddingRight,
      scrollerPaddingTop = _getScrollableContain.scrollerPaddingTop,
      scrollerPaddingBottom = _getScrollableContain.scrollerPaddingBottom,
      scrollerBordersX = _getScrollableContain.scrollerBordersX,
      scrollerBordersY = _getScrollableContain.scrollerBordersY;

  var cursorTop = rect.clientTop + yOffset - scrollerTop;
  var cursorLeft = rect.clientLeft + xOffset - scrollerLeft;
  var x = xOffset;
  var y = yOffset;
  var inView = true;

  if (cursorLeft < xOffset) {
    // selection to the left of viewport
    x = cursorLeft - scrollerPaddingLeft;
    inView = false;
  } else if (cursorLeft + CURSOR_WIDTH + scrollerBordersX > xOffset + width) {
    // selection to the right of viewport
    x = cursorLeft + scrollerBordersX + scrollerPaddingRight - width;
    inView = false;
  }

  if (cursorTop < yOffset) {
    // selection above viewport
    y = cursorTop - scrollerPaddingTop;
    inView = false;
  } else if (cursorTop + rect.height + scrollerBordersY > yOffset + height - EXTRA_BOTTOM_OFFSET // 此条件为被iOS键盘遮挡
  // iOS弹出键盘只会改变 visualViewport，不会影响其他任何地方
  || rect.clientTop + rect.height > viewportHeight - EXTRA_BOTTOM_OFFSET) {
    // selection below viewport
    y = Math.max(cursorTop + scrollerBordersY + scrollerPaddingBottom + rect.height - height, // 此数值为避免被iOS键盘遮挡
    scrollerTop + cursorTop + rect.height - viewportHeight);
    y += EXTRA_BOTTOM_OFFSET;
    inView = false;
  } // 对于大元素（超过 1/2 屏幕高度以上），特殊处理一下。


  var quaterHeight = height / 4;
  var isHugeElement = rect.height > quaterHeight * 2; // 如果大元素已经大部分在视图内（1/4 以上），就不要滚动了。

  var partInView = rect.clientTop < scrollerTop + quaterHeight * 3 && rect.clientTop + rect.height > scrollerTop + quaterHeight;

  if (isHugeElement && partInView) {
    inView = true;
  }

  if (inView) {
    return;
  }

  var deltaY = Math.abs(y - scroller.scrollTop);
  (isWindow ? window : scroller).scrollTo({
    left: x,
    top: y,
    // 纵向滚动距离小于 Min(视口高度/4, 特定高度) 时，采用顺滑滚动
    //    > 一般用于输入文字导致的换行到视口外，然后滚动进视口
    // 否则滚动距离过大就直接跳转到指定位置，避免滚动动画时间过长，体感不好
    behavior: deltaY < Math.min(quaterHeight, MAX_LINE_HEIGHT) ? 'smooth' : 'auto'
  });
}

var stateMap = new WeakMap(); // 检测 move 事件的 Throttle

var THROTTLE_MOVE = 300; // 用户每移动这么多 pixel，就加一个速度

var SPEED_PIXEL = 20; // 用户最大速度（最小是 1）

var MAX_SPEED = 6; // 底部热区大一些，提前就滚动

var BOTTOM_EXTRA_HOT_SIZE = IS_MOBILE ? 100 : 50; // 移动端顶部热区大一些，提前滚动

var TOP_EXTRA_HOT_SIZE = IS_MOBILE ? 100 : 0;

var scheduleScroll = function scheduleScroll(params) {
  var controller = params.controller,
      isWindow = params.isWindow,
      scroller = params.scroller,
      left = params.left,
      from = params.from,
      speed = params.speed,
      isTop = params.isTop;
  var state = stateMap.get(controller);

  if (!state || !state.isStarted) {
    return;
  }

  cancelSchedule(controller); // step 从用户体验角度，做了指数加速，一般是：2, 6, 12, 20, 30, ... 72

  var px = speed * (speed + 1);
  var step = isTop ? -px : px;
  var top = Math.round(from + step);

  if (isWindow) {
    window.scrollTo(left, top);
  } else {
    scroller.scrollTop = top;
  }

  var newSpeed = Math.min(MAX_SPEED, speed + 0.1);
  state.timer = requestAnimationFrame(function () {
    scheduleScroll(_extends({}, params, {
      from: top,
      speed: newSpeed
    }));
  });
};

var cancelSchedule = function cancelSchedule(controller) {
  var state = stateMap.get(controller);

  if (state != null && state.timer) {
    cancelAnimationFrame(state.timer);
    state.timer = undefined;
  }
};

var startScroll = function startScroll(_ref) {
  var scroller = _ref.scroller,
      controller = _ref.controller;
  stopScroll(controller);
  stateMap.set(controller, {
    isStarted: true
  });
  return throttle(function (event) {
    // PC Safari 下，不支持 TouchEvent
    var _ref2 = typeof TouchEvent === 'function' && event instanceof TouchEvent ? event.touches[0] : event,
        clientY = _ref2.clientY;

    var _getScrollableContain = getScrollableContainerInfo(scroller),
        isWindow = _getScrollableContain.isWindow,
        top = _getScrollableContain.scrollerTop,
        height = _getScrollableContain.height,
        xOffset = _getScrollableContain.xOffset,
        yOffset = _getScrollableContain.yOffset;

    var bottom = top + height;
    var topOffset = top - clientY + SPEED_PIXEL + TOP_EXTRA_HOT_SIZE;
    var bottomOffset = clientY - bottom + SPEED_PIXEL + BOTTOM_EXTRA_HOT_SIZE;

    if (topOffset <= 0 && bottomOffset <= 0) {
      cancelSchedule(controller);
      return;
    }

    var isTop = topOffset > 0; // speed 一般是：1 - 8

    var speed = Math.max(1, Math.min(MAX_SPEED, Math.round(isTop ? topOffset / SPEED_PIXEL : bottomOffset / SPEED_PIXEL)));
    scheduleScroll({
      controller: controller,
      isWindow: isWindow,
      scroller: scroller,
      left: xOffset,
      from: yOffset,
      isTop: isTop,
      speed: speed
    });
  }, THROTTLE_MOVE);
};
var stopScroll = function stopScroll(controller) {
  var state = stateMap.get(controller);

  if (!state || !state.isStarted) {
    return;
  }

  cancelSchedule(controller);
  state.isStarted = false;
};
var isScrolling = function isScrolling(controller) {
  var state = stateMap.get(controller);
  return Boolean((state == null ? void 0 : state.isStarted) && state.timer);
};

var ScrollableContainerContext = /*#__PURE__*/createContext(typeof window !== 'undefined' ? window : null);
/**
 * 滚动container，默认是window
 */

function useScrollableContainer() {
  return useContext(ScrollableContainerContext);
}

var _createElement$n = React.createElement;
// handle needle width
var HANDLE_WIDTH = 2; // handle round dot size

var HANDLE_DOT_SIZE = 10; // handle touchable rect size

var HANDLE_TOUCH_SIZE = 30;
var TYPE_START = 'start';
var TYPE_END = 'end';
var cursorStyle = {
  position: 'fixed',
  background: '#0089ff',
  opacity: 1,
  width: HANDLE_WIDTH + "px"
};
var handleRectStyle = {
  position: 'absolute',
  width: HANDLE_TOUCH_SIZE + "px",
  height: HANDLE_TOUCH_SIZE + "px",
  left: "-" + (HANDLE_TOUCH_SIZE / 2 - HANDLE_WIDTH / 2) + "px",
  bottom: "-" + (HANDLE_TOUCH_SIZE / 2 + HANDLE_DOT_SIZE / 2) + "px",
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center'
};
var handleRectTop = {
  left: "-" + HANDLE_TOUCH_SIZE / 2 + "px",
  top: "-" + HANDLE_TOUCH_SIZE / 2 + "px",
  bottom: 'auto'
};
var handleRoundDotStyle = {
  background: '#0089ff',
  width: HANDLE_DOT_SIZE + "px",
  height: HANDLE_DOT_SIZE + "px",
  borderRadius: HANDLE_DOT_SIZE + "px"
};

var handleRectTopStyle = _extends({}, handleRectStyle, handleRectTop);

var isPointVisible = function isPointVisible(_ref) {
  var node = _ref.node,
      clientLeft = _ref.clientLeft;
  var visible = true;
  var pElement = node.parentElement;

  while (pElement && !pElement.getAttribute("[" + Selector.content + "]")) {
    if (pElement.scrollWidth > pElement.offsetWidth) {
      var pRect = pElement.getBoundingClientRect();

      if (clientLeft < pRect.left || clientLeft > pRect.right) {
        visible = false;
        break;
      }
    }

    pElement = pElement.parentElement;
  }

  return visible;
};

var updateHandlePosition = function updateHandlePosition(node, loc) {
  node.style.top = loc.clientTop + "px";
  node.style.left = loc.clientLeft + "px";
  node.style.height = loc.height + "px";
};

var blockEvent$1 = function blockEvent(e) {
  e.preventDefault();
  e.stopPropagation();
}; // get a range from a client point (x, y)


var caretRangeFromPoint = function caretRangeFromPoint(x, y, controller) {
  var key = controller.value.document.key;
  var docNode = findDOMNodeSafely(key);
  var ele = docNode == null ? void 0 : docNode.closest("[" + Selector.content + "]");

  if (!ele) {
    return null;
  }

  return caretRangeFromTargetAndCoord(ele, x, y, controller);
}; // Handle component


var _ref3 = /*#__PURE__*/_createElement$n("span", {
  style: handleRoundDotStyle
});

var Handle = /*#__PURE__*/React.forwardRef(function (_ref2, ref) {
  var style = _ref2.style,
      onDrag = _ref2.onDrag,
      onDragStart = _ref2.onDragStart,
      onDragEnd = _ref2.onDragEnd,
      type = _ref2.type,
      _ref2$isHidden = _ref2.isHidden,
      isHidden = _ref2$isHidden === void 0 ? false : _ref2$isHidden;

  // prevent page scroll when dragging
  var handleTouchStart = function handleTouchStart(e) {
    blockEvent$1(e);
    e.nativeEvent.stopImmediatePropagation();
    onDragStart(type);
  };

  var handleTouchEnd = function handleTouchEnd(e) {
    blockEvent$1(e);
    e.nativeEvent.stopImmediatePropagation();
    onDragEnd(type);
  };

  var handleDrag = React.useCallback(function (event) {
    onDrag(type, event);
  }, [type, onDrag]);
  var touchMoveRef = React.useRef(null);
  React.useEffect(function () {
    var element = touchMoveRef ? touchMoveRef.current : null;

    if (element !== null) {
      element.addEventListener('touchmove', handleDrag, {
        passive: false,
        capture: true
      });
    }

    return function () {
      if (element !== null) {
        element.removeEventListener('touchmove', handleDrag, {
          capture: true
        });
      }
    };
  }, [handleDrag]);
  return /*#__PURE__*/_createElement$n("span", {
    ref: ref,
    "data-testid": "mobile-range-handle",
    style: isHidden ? _extends({}, cursorStyle, {
      opacity: 0
    }) : cursorStyle
  }, /*#__PURE__*/_createElement$n("span", {
    ref: touchMoveRef,
    onTouchStart: handleTouchStart,
    onTouchEnd: handleTouchEnd,
    style: style
  }, _ref3));
}); // Handles component, contains two handles at start and end of a selection

function Handles(_ref4) {
  var selection = _ref4.selection,
      controller = _ref4.controller,
      enableZoomer = _ref4.enableZoomer;
  var document = controller.value.document;
  var scrollableContainer = useScrollableContainer();
  var startRef = React.useRef(null);
  var endRef = React.useRef(null);
  var outsideScoller = React.useRef(null);

  var _selection$sort = selection.sort(document),
      start = _selection$sort.start,
      end = _selection$sort.end;

  var setNodeVisible = React.useCallback(function (nodeRef, visible) {
    var node = nodeRef.current;

    if (node) {
      node.style.visibility = visible ? 'unset' : 'hidden';
    }
  }, []);

  var updatePosition = function updatePosition() {
    var root = findDOMNodeSafely(document.key);
    var posStart = findCaretPosition(start, 'start', root);
    var posEnd = findCaretPosition(end, 'end', root);
    var pairs = [[posStart, startRef], [posEnd, endRef]];
    pairs.forEach(function (_ref5) {
      var position = _ref5[0],
          ref = _ref5[1];

      if (position && isPointVisible(position) && ref.current) {
        setNodeVisible(ref, true);
        updateHandlePosition(ref.current, position);
      } else {
        setNodeVisible(ref, false);
      }
    });
  };

  React.useEffect(updatePosition);
  useScroll({
    onStart: function onStart() {
      setNodeVisible(startRef, false);
      setNodeVisible(endRef, false);
    },
    onEnd: function onEnd() {
      updatePosition();
    }
  });
  var optimizeVerticalPosition = React.useCallback(function (isStart, orginalY) {
    var friendNode = isStart ? endRef.current : startRef.current;

    if (friendNode) {
      var friendRect = friendNode.getBoundingClientRect();
      var friendY = friendRect.top + friendRect.height / 2;
      return isStart ? Math.min(friendY, orginalY) : Math.max(friendY, orginalY);
    }

    return orginalY;
  }, []); // update the selection when the user drags the handle bar

  var handleDrag = React.useCallback(function (type, event) {
    blockEvent$1(event);
    outsideScoller.current && outsideScoller.current(event);
    var isStart = type === TYPE_START;
    event.stopImmediatePropagation();
    var touchPoint = event.touches[0];
    var clientX = touchPoint.clientX,
        clientY = touchPoint.clientY;
    var x = clientX;
    var orginalY = isStart ? clientY + HANDLE_TOUCH_SIZE : clientY - HANDLE_TOUCH_SIZE;
    var y = optimizeVerticalPosition(isStart, orginalY);
    var range = caretRangeFromPoint(x, y, controller);
    var _controller$value = controller.value,
        doc = _controller$value.document,
        selection = _controller$value.selection;

    if (!range) {
      return;
    }

    var targetPoint = range.focus;
    var voidParent = document.getClosestVoid(targetPoint.key, controller);

    if (voidParent) {
      // Handle Drag will skip the point inside void elements
      try {
        // eslint-disable-next-line react/no-find-dom-node
        var voidNode = findDOMNode(voidParent.key);
        var voidRect = voidNode.getBoundingClientRect();
        var voidCenterX = voidRect.x + voidRect.width / 2;
        var distance = clientX > voidCenterX ? 1 : -1;
        targetPoint = controller.query(pointAtDistance, targetPoint, distance);
      } catch (error) {// ignore
      }
    }

    var newSelection = selection.set('anchor', targetPoint);

    if (newSelection.isCollapsed || newSelection.isBackward(doc) !== selection.isBackward(doc) || equal(newSelection, selection)) {
      return;
    }

    controller.run('onCangjieSelect', CangjieSelectEvent({
      selection: newSelection,
      trigger: 'dragging'
    }));
  }, [controller]);

  var _React$useState = React.useState(null),
      dragging = _React$useState[0],
      setDragging = _React$useState[1];

  var onDragStart = React.useCallback(function (type) {
    /**
     * Some android devices scroll to the HiddenTextArea after drag, it
     * use 'anchor' point for positioning. So we make sure the user always
     * drag the 'anchor' point here.
     */
    var isBackward = selection.isBackward(document); // if we're dragging the 'focus' point, flip the selection

    if (type === TYPE_START && isBackward || type === TYPE_END && !isBackward) {
      var newSelection = selection.merge({
        anchor: selection.focus,
        focus: selection.anchor
      });
      controller.run('onCangjieSelect', CangjieSelectEvent({
        selection: newSelection,
        trigger: 'dragging'
      }));
    }

    setDragging(type);

    if (scrollableContainer) {
      outsideScoller.current = startScroll({
        scroller: scrollableContainer,
        controller: controller
      });
    }
  }, [controller, document, selection]);
  var onDragEnd = React.useCallback(function () {
    setDragging(null);

    if (outsideScoller.current) {
      outsideScoller.current.cancel();
      outsideScoller.current = null;
    }

    stopScroll(controller);
  }, []);
  React.useEffect(function () {
    return function () {
      if (outsideScoller.current) {
        outsideScoller.current.cancel();
        outsideScoller.current = null;
      }
    };
  }, [controller]);
  var dragProps = {
    onDragStart: onDragStart,
    onDragEnd: onDragEnd
  };
  var draggingPoint = null;

  if (dragging === TYPE_START) {
    draggingPoint = start;
  } else if (dragging === TYPE_END) {
    draggingPoint = end;
  }

  return /*#__PURE__*/_createElement$n(React.Fragment, null, /*#__PURE__*/_createElement$n(Handle, _extends({}, dragProps, {
    type: TYPE_START,
    isHidden: enableZoomer && dragging === TYPE_END,
    onDrag: handleDrag,
    ref: startRef,
    style: handleRectTopStyle
  })), /*#__PURE__*/_createElement$n(Handle, _extends({}, dragProps, {
    type: TYPE_END,
    isHidden: enableZoomer && dragging === TYPE_START,
    onDrag: handleDrag,
    ref: endRef,
    style: handleRectStyle
  })), enableZoomer && draggingPoint && /*#__PURE__*/_createElement$n(Zoomer$1, {
    isHanging: dragging === TYPE_START,
    point: draggingPoint
  }), !dragging && /*#__PURE__*/_createElement$n(ContextMenu$1, {
    selection: selection,
    controller: controller
  }));
}

var Handles$1 = (function (props) {
  var propsSelection = props.selection,
      controller = props.controller;

  var _React$useState2 = React.useState(propsSelection),
      selection = _React$useState2[0],
      setSelection = _React$useState2[1];

  React.useMemo(function () {
    setSelection(propsSelection);
  }, [propsSelection]);
  useSelectionData(controller.selectionData$, null, function (_ref6) {
    var range = _ref6.range;
    setSelection(range);
  }, []);

  if (selection.isCollapsed) {
    return null;
  }

  return /*#__PURE__*/ReactDOM__default.createPortal( /*#__PURE__*/_createElement$n(Handles, _extends({}, props, {
    selection: selection
  })), document.body);
});

var _createElement$m = React.createElement;
var ACTION_CLEAR_MOBILE_MENU = Symbol('ACTION_CLEAR_MOBILE_MENU');

function getDraggingSelection(controller) {
  // eslint-disable-next-line no-underscore-dangle
  return controller.value.data._mobileDraggingSelection;
}

function hidePopup(controller) {
  showPopup(controller, undefined);
}

function showPopup(controller, selection) {
  var data = controller.value.data;
  var prevRange = getPopupSelection(controller);
  var focusedSelection = prevRange && selection && Selection.isEqual(prevRange, selection) ? undefined : selection;
  controller.setData(_extends({}, data, {
    _mobileFocusedSelection: focusedSelection
  }));
}

function getPopupSelection(controller) {
  // eslint-disable-next-line no-underscore-dangle
  return controller.value.data._mobileFocusedSelection;
}
/**
 * 兼容 鼠标 + 触屏 场景
 *
 * 背景：
 * touch 事件会触发 onTouchStart 和 onMouseDown
 * mouse 事件会触发 onMouseDown
 *
 * 方案：
 * touch 事件，touchCount 值重置为 2
 * mouse 事件，touchCount 值减 1
 *
 * 结果：
 * 用户使用了 mouse：touchCount <= 0
 * 用户使用了 touch：touchCount === 1
 */


var touchCount = 0;
function createMobilePlugin(configs) {
  var _configs$plugins;

  var _ref = (configs == null ? void 0 : (_configs$plugins = configs.plugins) == null ? void 0 : _configs$plugins.mobile) || {},
      _ref$enableZoomer = _ref.enableZoomer,
      enableZoomer = _ref$enableZoomer === void 0 ? false : _ref$enableZoomer;

  function onTouchStart(event, controller, next) {
    var _controller$value = controller.value,
        selection = _controller$value.selection,
        isFocused = _controller$value.isFocused;
    var isCollapsed = selection.isCollapsed;

    if (isFocused && isCollapsed) {
      var _event$touches$ = event.touches[0],
          target = _event$touches$.target,
          clientX = _event$touches$.clientX,
          clientY = _event$touches$.clientY;
      var range = caretRangeFromTargetAndCoord(target, clientX, clientY, controller);

      if (range && Selection.isEqual(selection, range)) {
        showPopup(controller, selection);
      } else if (range && getPopupSelection(controller)) {
        hidePopup(controller);
      }
    }

    touchCount = 2;
    return next();
  }

  function onMouseDown(event, controller, next) {
    touchCount = touchCount > 0 ? touchCount - 1 : 0;
    return next();
  }

  function renderContent(_, controller, next) {
    var value = controller.value;
        controller.readOnly;
    var selection = value.selection,
        isFocused = value.isFocused;
    var contextData = value.data.contextData;
    var focusedSelection = getPopupSelection(controller);
    var shouldRenderH5Controls = Boolean(isFocused || controller.query('shouldRenderH5Controls')); // 鼠标 + 触屏 场景，如果是鼠标触发的，就不显示菜单

    var isDisabled = !IS_MOBILE && IS_TOUCH_DEVICE && touchCount === 0;
    var isInFocusedSelection = focusedSelection && Selection.isEqual(focusedSelection, selection); // 当处于 focusedSelection 或者 插件允许的区域，可以渲染 contextMenu

    var isInRenableSelection = isInFocusedSelection || controller.query('shouldRenderContextMenu');
    var shouldRenderContextMenu = Boolean(shouldRenderH5Controls && !contextData && !isDisabled && isInRenableSelection);
    var shouldRenderHandles = shouldRenderH5Controls && !contextData && !isDisabled && !controller.query('isHideSelection');
    return /*#__PURE__*/_createElement$m(React.Fragment, null, next(), selection.isCollapsed && shouldRenderContextMenu && /*#__PURE__*/_createElement$m(ContextMenu$1, {
      selection: selection,
      controller: controller,
      hidePopup: hidePopup
    }), shouldRenderHandles && /*#__PURE__*/_createElement$m(Handles$1, {
      enableZoomer: enableZoomer,
      selection: selection,
      controller: controller
    }));
  }

  function renderCaret(props, controller, next) {
    var caret = next();

    if (!caret) {
      return null;
    }

    var isDragging = getDraggingSelection(controller);
    var mode = isDragging ? 'placeholder' : 'caret';
    return /*#__PURE__*/React.cloneElement(caret, {
      mode: mode
    });
  }

  function onAction(action, controller, next) {
    if (action.type === ACTION_CLEAR_MOBILE_MENU) {
      var data = controller.value.data; // eslint-disable-next-line no-underscore-dangle

      if (data._mobileFocusedSelection) {
        controller.setData(_extends({}, data, {
          _mobileFocusedSelection: undefined
        }));
      }
    }

    return next();
  }

  return {
    onAction: onAction,
    onTouchStart: onTouchStart,
    onMouseDown: onMouseDown,
    renderContent: renderContent,
    renderCaret: renderCaret,
    models: []
  };
}

/**
 * @packageDocumentation
 * @ignore
 */
function createQueriesPlugin(qrys) {
  if (qrys === void 0) {
    qrys = {};
  }

  // PERF: drop prototype
  var queries = Object.assign(Object.create(null), qrys);

  function onQuery(qry, controller, next) {
    var type = qry.type,
        args = qry.args;
    var query = queries[type];

    if (!query) {
      return next();
    }

    var ret = query.apply(void 0, [controller].concat(args));
    return ret === undefined ? next() : ret;
  }

  return {
    models: [],
    onQuery: onQuery
  };
}

/**
 * @packageDocumentation
 * @ignore
 */
function createRenderNodePlugin(renders) {
  if (renders === void 0) {
    renders = {};
  }

  // PERF: drop prototype
  var renderNodes = Object.assign(Object.create(null), renders); // @ts-ignore

  var renderNode = function renderNode(props, controller, n) {
    var _props$node;

    // @ts-ignore
    var renders = renderNodes[(_props$node = props.node) == null ? void 0 : _props$node.type];

    if (!renders) {
      return n();
    }

    var prevArgs = [props, controller, n];
    var i = 0;

    function next() {
      for (var _len = arguments.length, as = new Array(_len), _key = 0; _key < _len; _key++) {
        as[_key] = arguments[_key];
      }

      var currentArgs = as.length === 0 ? prevArgs : [].concat(as, prevArgs.slice(as.length));
      prevArgs = currentArgs;
      var fn = renders[i];

      if (!fn) {
        return null;
      }

      i += 1;
      return fn(currentArgs[0], controller, next);
    }

    return next();
  };

  return {
    models: [],
    renderNode: renderNode
  };
}

/**
 * @packageDocumentation
 * @ignore
 */
function createCommandsPlugin(cmds) {
  if (cmds === void 0) {
    cmds = {};
  }

  // PERF: drop prototype
  var commands = Object.assign(Object.create(null), cmds);

  function onCommand(cmd, controller, next) {
    var type = cmd.type,
        args = cmd.args;
    var command = commands[type];

    if (!command) {
      return next();
    }

    return command.apply(void 0, [controller].concat(args));
  }

  return {
    models: [],
    onCommand: onCommand
  };
}

var klassToIsType = {
  document: Document.isDocument,
  block: Block.isBlock,
  inline: Inline.isInline,
  text: Text$1.isText,
  mark: Mark.isMark
};

function validateKlass(node, rule) {
  if (!rule.klass) {
    return null;
  } // FIXME: remove `.toJSON()`


  if (typeof rule.klass === 'function' && rule.klass(node.toJSON().klass)) {
    return null;
  }

  var isType = klassToIsType[rule.klass];

  if (isType && isType(node)) {
    return null;
  }

  return {
    code: 'node_klass_invalid',
    rule: rule,
    node: node
  };
}

function validateType(node, rule) {
  if (!rule.type) {
    return null;
  }

  if (rule.type === node.type) {
    return null;
  }

  if (typeof rule.type === 'function' && rule.type(node.type)) {
    return null;
  }

  return {
    code: 'node_type_invalid',
    rule: rule,
    node: node
  };
}

function validateFirst(node, rule) {
  if (!rule.first) {
    return null;
  }

  var first = node.nodes[0];

  if (!first) {
    return null;
  }

  var error = validateRules(first, rule.first);

  if (!error) {
    return null;
  }

  return Object.assign({}, error, {
    rule: rule,
    node: node,
    child: first,
    code: error.code.replace('node_', 'first_child_')
  });
}

function validateLast(node, rule) {
  if (!rule.last) {
    return null;
  }

  var last = node.nodes[node.nodes.length - 1];

  if (!last) {
    return null;
  }

  var error = validateRules(last, rule.last);

  if (!error) {
    return null;
  } // PERF


  return Object.assign({}, error, {
    rule: rule,
    node: node,
    child: last,
    code: error.code.replace('node_', 'last_child_')
  });
}

function validateParent(node, child, rules) {
  // PERF: For loop is faster than for of.
  var length = rules.length;

  for (var i = 0; i < length; i++) {
    var rule = rules[i];

    if (!rule.parent) {
      continue;
    }

    if (rule.match && !testRules(child, rule.match)) {
      continue;
    }

    var _error = validateRules(node, rule.parent);

    if (!_error) {
      continue;
    } // PERF


    return Object.assign({}, _error, {
      rule: rule,
      parent: node,
      node: child,
      code: _error.code.replace('node_', 'parent_')
    });
  }

  return null;
}

function validatePrevious(node, child, previous, index, rules) {
  if (!previous) {
    return null;
  } // PERF: For loop is faster than for of.


  var length = rules.length;

  for (var i = 0; i < length; i++) {
    var rule = rules[i];

    if (!rule.previous) {
      continue;
    }

    if (rule.match && !testRules(child, rule.match)) {
      continue;
    }

    var _error2 = validateRules(previous, rule.previous);

    if (!_error2) {
      continue;
    } // PERF


    return Object.assign({}, _error2, {
      rule: rule,
      node: node,
      child: child,
      index: index,
      previous: previous,
      code: _error2.code.replace('node_', 'previous_sibling_')
    });
  }

  return null;
}

function validateNext(node, child, next, index, rules) {
  if (!next) {
    return null;
  } // PERF: For loop is faster than for of.


  var length = rules.length;

  for (var i = 0; i < length; i++) {
    var rule = rules[i];

    if (!rule.next) {
      continue;
    }

    if (rule.match && !testRules(child, rule.match)) {
      continue;
    }

    var _error3 = validateRules(next, rule.next);

    if (!_error3) {
      continue;
    } // PERF


    return Object.assign({}, _error3, {
      rule: rule,
      node: node,
      child: child,
      index: index,
      next: next,
      code: _error3.code.replace('node_', 'next_sibling_')
    });
  }

  return null;
}

function validateNodes(node, rule, rules) {
  if (rules === void 0) {
    rules = [];
  }

  if (!node.nodes) {
    return null;
  }

  var children = node.nodes;
  var defs = rule.nodes ? [].concat(rule.nodes) : [];
  var count = 0;
  var lastCount = 0;
  var min = null;
  var index = -1;
  var def = null;
  var max = null;
  var child = null;
  var previous = null;
  var next = null;

  function nextDef() {
    if (defs.length === 0) {
      return false;
    }

    def = defs.shift();
    lastCount = count;
    count = 0;
    min = def.min || null;
    max = def.max || null;
    return true;
  }

  function nextChild() {
    index += 1;
    previous = child;
    child = children[index] || null;
    next = children[index + 1] || null;

    if (!child) {
      return false;
    }

    lastCount = count;
    count += 1;
    return true;
  }

  function rewind() {
    if (index > 0) {
      index -= 1;
      count = lastCount;
    }
  }

  if (rule.nodes) {
    nextDef();
  }

  while (nextChild()) {
    var _error4 = validateParent(node, child, rules) || validatePrevious(node, child, previous, index, rules) || validateNext(node, child, next, index, rules);

    if (_error4) {
      return _error4;
    }

    if (rule.nodes) {
      if (!def) {
        return {
          code: 'child_unknown',
          rule: rule,
          node: node,
          child: child,
          index: index
        };
      }

      if (def.match) {
        // @ts-ignore
        var err = validateRules(child, def.match);

        if (err) {
          // Since we want to report overflow on last matching child we don't
          // immediately check for count > max, but instead do so once we find
          // a child that doesn't match.
          if (max !== null && count - 1 > max) {
            rewind();
            return {
              code: 'child_max_invalid',
              rule: rule,
              node: node,
              index: index,
              child: children[index],
              count: count,
              limit: max
            };
          }

          var lastMin = min; // If there are more groups after this one then child might actually
          // be valid.

          if (nextDef()) {
            // If we've already satisfied the minimum for the current group,
            // then we can rewind and proceed to the next group.
            if (lastMin === null || lastCount - 1 >= lastMin) {
              index -= 1;
              continue;
            } // Otherwise we know that current value is underflowing. There are
            // three possible causes for this...
            // 1. There might just not be enough elements for current group, and
            // current child is in fact the first of the next group. If so, the
            // next def will not report errors, in which case we can rewind and
            // report an minimum error.
            // @ts-ignore


            if (validateRules(child, def.match) === null) {
              rewind();
              return {
                code: 'child_min_invalid',
                rule: rule,
                node: node,
                index: index,
                count: lastCount - 1,
                limit: lastMin
              };
            } // 2. The current group is underflowing, but there is also an
            // invalid child before the next group.
            // 3. Or the current group is not underflowing but it appears so
            // because there's an invalid child between its members.
            // It's either the second or third case. If it's the second then
            // we could report an underflow, but presence of an invalid child
            // is arguably more important, so we report it first. It also lets
            // us avoid checking for which case exactly is it.
            // PERF


            return Object.assign({}, err, {
              rule: rule,
              node: node,
              child: child,
              index: index,
              code: err.code.replace('node_', 'child_')
            });
          } // Otherwise either we exhausted the last group, in which case it's
          // an unknown child, ...


          if (max != null && count > max) {
            return {
              code: 'child_unknown',
              rule: rule,
              node: node,
              child: child,
              index: index
            };
          }

          return Object.assign({}, err, {
            rule: rule,
            node: node,
            child: child,
            index: index,
            code: err.code.replace('node_', 'child_')
          });
        }
      }
    }
  } // Since we want to report overflow on last matching child we don't
  // immediately check for count > max, but do so after processing all nodes.


  if (max !== null && count > max) {
    return {
      code: 'child_max_invalid',
      rule: rule,
      node: node,
      index: index - 1,
      count: count,
      child: children[index - 1],
      limit: max
    };
  }

  if (rule.nodes) {
    do {
      if (min !== null && count < min) {
        return {
          code: 'child_min_invalid',
          rule: rule,
          node: node,
          index: index,
          count: count,
          limit: min
        };
      }
    } while (nextDef());
  }

  return null;
}

function validateRules(object, rule, rules, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$every = _options.every,
      every = _options$every === void 0 ? false : _options$every;

  if (Array.isArray(rule)) {
    var array = rule.length ? rule : [{}];
    var first = null; // PERF: For loop is faster than for of.

    var length = array.length;

    for (var i = 0; i < length; i++) {
      var r = array[i];

      var _error5 = validateRules(object, r, rules);

      first = first || _error5;

      if (every && _error5) {
        return _error5;
      }

      if (!every && !_error5) {
        return null;
      }
    }

    return first;
  }

  return validateKlass(object, rule) || // @ts-ignore
  validateType(object, rule) || // @ts-ignore
  validateFirst(object, rule) || // @ts-ignore
  validateLast(object, rule) || // @ts-ignore
  validateNodes(object, rule, rules);
}

function testRules(object, rules) {
  return !validateRules(object, rules);
}

function defaultNormalize(controller, error) {
  var code = error.code,
      node = error.node,
      child = error.child,
      next = error.next,
      previous = error.previous;

  switch (code) {
    case 'child_max_invalid':
    case 'child_klass_invalid':
    case 'child_type_invalid':
    case 'child_unknown':
    case 'first_child_klass_invalid':
    case 'first_child_type_invalid':
    case 'last_child_klass_invalid':
    case 'last_child_type_invalid':
      {
        return Text$1.isText(child) && Block.isBlock(node) && node.nodes.length === 1 ? controller.command(removeNodeByKey, node.key) : controller.command(removeNodeByKey, child.key);
      }

    case 'previous_sibling_klass_invalid':
    case 'previous_sibling_type_invalid':
      {
        return Text$1.isText(previous) && Block.isBlock(node) && node.nodes.length === 1 ? controller.command(removeNodeByKey, node.key) : controller.command(removeNodeByKey, previous.key);
      }

    case 'next_sibling_klass_invalid':
    case 'next_sibling_type_invalid':
      {
        return Text$1.isText(next) && Block.isBlock(node) && node.nodes.length === 1 ? controller.command(removeNodeByKey, node.key) : controller.command(removeNodeByKey, next.key);
      }

    case 'child_min_invalid':
    case 'parent_klass_invalid':
    case 'parent_type_invalid':
      {
        return Document.isDocument(node) ? node.nodes.forEach(function (n) {
          return controller.command(removeNodeByKey, n.key);
        }) : controller.command(removeNodeByKey, node.key);
      }

    default:
      {
        return controller.command(removeNodeByKey, node.key);
      }
  }
}

function isOnlyContainsVoidAndEdgeSelectable(rule) {
  return !Object.keys(rule).filter(function (key) {
    return key !== 'isVoid' && key !== 'isEdgeSelectable';
  }).length;
}

function isOnlyContainsAtomic(rule) {
  return !Object.keys(rule).filter(function (key) {
    return key !== 'isAtomic';
  }).length;
}

function createNormalizationPlugin(schema) {
  var _schema$rules = schema.rules,
      rules = _schema$rules === void 0 ? [] : _schema$rules,
      document = schema.document,
      _schema$blocks = schema.blocks,
      blocks = _schema$blocks === void 0 ? {} : _schema$blocks,
      _schema$inlines = schema.inlines,
      inlines = _schema$inlines === void 0 ? {} : _schema$inlines,
      _schema$marks = schema.marks,
      marks = _schema$marks === void 0 ? {} : _schema$marks;
  var schemaRules = [].concat(rules);

  if (document) {
    schemaRules.push(_extends({
      match: [{
        klass: 'document'
      }]
    }, document));
  }

  Object.keys(blocks).filter(function (type) {
    return !isOnlyContainsVoidAndEdgeSelectable(blocks[type]);
  }).forEach(function (type) {
    schemaRules.push(_extends({
      match: [{
        klass: 'block',
        type: type
      }]
    }, blocks[type]));
  });
  Object.keys(inlines).filter(function (type) {
    return !isOnlyContainsVoidAndEdgeSelectable(inlines[type]);
  }).forEach(function (type) {
    schemaRules.push(_extends({
      match: [{
        klass: 'inline',
        type: type
      }]
    }, inlines[type]));
  });
  Object.keys(marks).filter(function (type) {
    return isOnlyContainsAtomic(marks[type]);
  }).forEach(function (type) {
    schemaRules.push(_extends({
      match: [{
        klass: 'mark',
        type: type
      }]
    }, marks[type]));
  }); // Check if a `mark` is atomic

  var isAtomicDict = Object.create(null);
  Object.keys(marks).forEach(function (type) {
    if ('isAtomic' in marks[type]) {
      isAtomicDict[type] = marks[type].isAtomic;
    }
  });

  function isAtomic(_, mark) {
    return isAtomicDict[mark.type];
  }

  var isVoidDict = {
    block: Object.create(null),
    inline: Object.create(null)
  };
  var isEdgeSelectableDict = {
    block: Object.create(null),
    inline: Object.create(null)
  };
  var isSideSelectableDict = Object.create(null);
  Object.keys(blocks).forEach(function (type) {
    if ('isVoid' in blocks[type]) {
      isVoidDict.block[type] = blocks[type].isVoid;
    }

    if ('isEdgeSelectable' in blocks[type]) {
      isEdgeSelectableDict.block[type] = blocks[type].isEdgeSelectable;
    }
  });
  Object.keys(inlines).forEach(function (type) {
    if ('isVoid' in inlines[type]) {
      isVoidDict.inline[type] = inlines[type].isVoid;
    }

    if ('isEdgeSelectable' in inlines[type]) {
      isEdgeSelectableDict.inline[type] = inlines[type].isEdgeSelectable;
    }

    if ('isSideSelectable' in inlines[type]) {
      isSideSelectableDict[type] = inlines[type].isSideSelectable;
    }
  }); // Check if a `node` is void.

  function isVoid(controller, node) {
    var klass = '';

    if (Block.isBlock(node)) {
      klass = 'block';
    }

    if (Inline.isInline(node)) {
      klass = 'inline';
    }

    if (!klass) {
      return undefined;
    }

    var predict = isVoidDict[klass][node.type];
    return typeof predict === 'function' ? predict(controller, node) : predict;
  } // Check if the side of `node` is selectable


  function isSideSelectable(controller, node) {
    if (Inline.isInline(node)) {
      return isSideSelectableDict[node.type];
    }

    return undefined;
  } // Check if a `node` is selectable.


  function isEdgeSelectable(_, node) {
    var klass = '';

    if (Block.isBlock(node)) {
      klass = 'block';
    }

    if (Inline.isInline(node)) {
      klass = 'inline';
    }

    if (!klass) {
      return undefined;
    }

    return isEdgeSelectableDict[klass][node.type];
  }

  function validateNode(node, controller, next) {
    var matches = schemaRules.filter(function (r) {
      return r.match && testRules(node, r.match);
    });
    var error = validateRules(node, matches, schemaRules, {
      every: true
    });

    if (!error) {
      return next();
    }

    return error;
  }

  function normalizeNode(node, controller, next) {
    var error = validateNode(node, controller, function () {
      return null;
    });

    if (!error) {
      return next();
    }

    return function () {
      var rule = error.rule;
      var $document = controller.value.document;

      if (rule.normalize) {
        rule.normalize(controller, error);
      }

      if (controller.value.document === $document) {
        defaultNormalize(controller, error);
      }
    };
  }

  return {
    models: [],
    queries: {
      isAtomic: isAtomic,
      isVoid: isVoid,
      isEdgeSelectable: isEdgeSelectable,
      isSideSelectable: isSideSelectable
    },
    validateNode: validateNode,
    normalizeNode: normalizeNode
  };
}

/**
 * @packageDocumentation
 * @ignore
 */

function isInlineOrText(node) {
  return Inline.isInline(node) || Text$1.isText(node);
}

function normalizeNode(node, controller, next) {
  if (Document.isDocument(node)) {
    // Only allow block nodes in documents.
    var length = node.nodes.length;

    var _loop = function _loop(i) {
      var child = node.nodes[i];

      if (!Block.isBlock(child)) {
        return {
          v: function v() {
            return controller.command(removeNodeByKey, child.key);
          }
        };
      }
    };

    for (var i = 0; i < length; i += 1) {
      var _ret = _loop(i);

      if (typeof _ret === "object") return _ret.v;
    }
  } else if (Block.isBlock(node) || Inline.isInline(node)) {
    var _length = node.nodes.length; // Ensure that block and inline nodes have at least one text child.

    if (_length < 1) {
      return function () {
        return controller.command(insertNodeByKey, node.key, 0, Text$1.create());
      };
    } // 1. Only allow block nodes or inline and text nodes in blocks.
    // 2. Only allow inline and text nodes in inlines.


    var predicate = Block.isBlock(node) && Block.isBlock(node.nodes[0]) ? Block.isBlock : isInlineOrText;

    var _loop2 = function _loop2(_i) {
      var child = node.nodes[_i];

      if (!predicate(child)) {
        return {
          v: function v() {
            return controller.command(removeNodeByKey, child.key);
          }
        };
      } // Ensure that inline nodes are surrounded by text nodes.


      if (_i === 0 && Inline.isInline(child)) {
        return {
          v: function v() {
            return controller.command(insertNodeByKey, node.key, 0, Text$1.create());
          }
        };
      }

      var next = node.nodes[_i + 1];

      if (Inline.isInline(child)) {
        if (!Text$1.isText(next)) {
          return {
            v: function v() {
              return controller.command(insertNodeByKey, node.key, _i + 1, Text$1.create());
            }
          };
        }
      } else if (Text$1.isText(child)) {
        // Merge adjacent text nodes.
        if (Text$1.isText(next)) {
          return {
            v: function v() {
              return controller.command(mergeNodeByKey, next.key);
            }
          };
        }
      }
    };

    for (var _i = 0; _i < _length; _i += 1) {
      var _ret2 = _loop2(_i);

      if (typeof _ret2 === "object") return _ret2.v;
    }
  }

  return next();
}

function createCoreSchemaPlugin() {
  return {
    normalizeNode: normalizeNode
  };
}

var BATCH_UNDO_MERGE_TIME = 1000;

function shouldClear(op) {
  return op.type !== OperationType.SetSelection;
}

function shouldMerge(op, prevOp) {
  if (!prevOp) return false;
  return op.type === OperationType.InsertText && prevOp.type === OperationType.InsertText && op.offset === prevOp.offset + prevOp.text.length && Path.isEqual(op.path, prevOp.path) || op.type === OperationType.RemoveText && prevOp.type === OperationType.RemoveText && op.offset + op.text.length === prevOp.offset && Path.isEqual(op.path, prevOp.path);
}

function shouldOverwrite(op, prevOp) {
  return prevOp && op.type === OperationType.SetSelection && prevOp.type === OperationType.SetSelection;
}

var History = /*#__PURE__*/function (_ImmutableRecord) {
  _inheritsLoose(History, _ImmutableRecord);

  History.create = function create(params) {
    return new History(params);
  };

  function History(props) {
    var _this;

    if (props === void 0) {
      props = {};
    }

    _this = _ImmutableRecord.call(this) || this;
    _this.redos = void 0;
    _this.undos = void 0;
    _this.lastUndoCreatedTime = 0;
    _this.maxHistorySize = void 0;
    var _props = props,
        _props$redos = _props.redos,
        redos = _props$redos === void 0 ? [] : _props$redos,
        _props$undos = _props.undos,
        undos = _props$undos === void 0 ? [] : _props$undos,
        _props$lastUndoCreate = _props.lastUndoCreatedTime,
        lastUndoCreatedTime = _props$lastUndoCreate === void 0 ? 0 : _props$lastUndoCreate,
        _props$maxHistorySize = _props.maxHistorySize,
        maxHistorySize = _props$maxHistorySize === void 0 ? MAX_HISTORY_SIZE : _props$maxHistorySize;
    _this.redos = redos;
    _this.undos = undos.slice(-maxHistorySize);
    _this.lastUndoCreatedTime = lastUndoCreatedTime;
    _this.maxHistorySize = maxHistorySize;

    _this.freeze();

    return _this;
  }

  var _proto = History.prototype;

  _proto.merge = function merge(props) {
    return new History(_extends({
      redos: this.redos,
      undos: this.undos,
      maxHistorySize: this.maxHistorySize
    }, props, {
      lastUndoCreatedTime: this.lastUndoCreatedTime
    }));
  };

  _proto.set = function set(key, value) {
    var _this$merge;

    return this.merge((_this$merge = {}, _this$merge[key] = value, _this$merge));
  };

  _proto.moveLastRedoRecordToUndos = function moveLastRedoRecordToUndos() {
    var redos = this.redos;

    if (!redos.length) {
      return this;
    }

    var newRedos = redos.slice(0, -1);
    var lastRedoRecord = redos[redos.length - 1];
    var newUndos = [].concat(this.undos, [lastRedoRecord]);
    return this.merge({
      undos: newUndos,
      redos: newRedos
    });
  };

  _proto.moveLastUndoRecordToRedos = function moveLastUndoRecordToRedos(undoRecord) {
    var undos = this.undos;

    if (!undos.length) {
      return this;
    }

    var newUndos = undos.slice(0, -1);
    var lastUndoRecord = undoRecord || undos[undos.length - 1];
    var newRedos = [].concat(this.redos, [lastUndoRecord]);
    return this.merge({
      undos: newUndos,
      redos: newRedos
    });
  };

  _proto.mergeToLastUndoIfNeed = function mergeToLastUndoIfNeed(operation, forceMerge) {
    var undos = [].concat(this.undos);
    var lastBatch = undos[undos.length - 1];
    var lastOp = lastBatch && lastBatch[lastBatch.length - 1];
    var overwrite = shouldOverwrite(operation, lastOp);
    var merge = !!lastBatch && (this.lastUndoCreatedTime === 0 || Date.now() - this.lastUndoCreatedTime <= BATCH_UNDO_MERGE_TIME) && (shouldMerge(operation, lastOp) || overwrite);

    if (lastBatch && (merge || forceMerge)) {
      if (overwrite) {
        lastBatch = lastBatch.slice(0, -1);
      }

      lastBatch = [].concat(lastBatch, [operation]);
      undos = [].concat(undos.slice(0, -1), [lastBatch]);
    } else {
      var batch = [operation];
      undos = [].concat(undos, [batch]);
    }

    return this.merge({
      undos: undos,
      redos: shouldClear(operation) ? [] : this.redos
    });
  };

  return History;
}(ImmutableRecord);

/**
 * @packageDocumentation
 * @ignore
 */
var HOTKEYS = {
  bold: 'mod+b',
  compose: ['left', 'right', 'down', 'up', 'space', 'shift?+backspace', 'shift?+enter', 'shift?+delete', 'shift?+tab'],
  moveBackward: 'left',
  moveForward: 'right',
  moveUpward: 'up',
  moveDownward: 'down',
  deleteBackward: 'shift?+backspace',
  deleteForward: 'shift?+delete',
  extendBackward: 'shift+left',
  extendForward: 'shift+right',
  extendUpward: 'shift+up',
  extendDownward: 'shift+down',
  italic: 'mod+i',
  splitBlock: 'shift?+enter',
  undo: 'mod+z',
  space: 'space',
  enter: 'enter',
  tab: 'tab',
  copy: 'mod+c',
  cut: 'mod+x',
  paste: 'mod+v'
}; // https://support.apple.com/en-us/HT201236

var APPLE_HOTKEYS = {
  selectAll: 'cmd+a',
  moveBackward: 'ctrl+b',
  moveForward: 'ctrl+f',
  moveUpward: 'ctrl+p',
  moveDownward: 'ctrl+n',
  moveWordBackward: 'opt+left',
  moveWordForward: 'opt+right',
  moveLineBackward: ['cmd+left', 'home'],
  moveLineForward: ['cmd+right', 'end'],
  moveBlockBackward: ['opt+up', 'ctrl+a'],
  moveBlockForward: ['opt+down', 'ctrl+e'],
  moveToDocumentStart: 'cmd+up',
  moveToDocumentEnd: 'cmd+down',
  deleteBackward: ['ctrl+backspace'],
  deleteForward: ['ctrl+delete', 'ctrl+d', 'fn+delete'],
  deleteLineBackward: 'cmd+shift?+backspace',
  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],
  deleteWordBackward: 'opt+shift?+backspace',
  deleteWordForward: 'opt+shift?+delete',
  extendWordBackward: 'opt+shift+left',
  extendWordForward: 'opt+shift+right',
  extendLineBackward: 'cmd+shift+left',
  extendLineForward: 'cmd+shift+right',
  extendBlockBackward: ['opt+shift+up', 'ctrl+shift+a'],
  extendBlockForward: ['opt+shift+down', 'ctrl+shift+e'],
  extendToDocumentStart: ['cmd+shift+up', 'fn+left'],
  extendToDocumentEnd: ['cmd+shift+down', 'fn+right'],
  splitBlock: 'ctrl+o',
  redo: 'cmd+shift+z',
  transposeCharacter: 'ctrl+t'
}; // https://support.microsoft.com/en-us/help/12445/windows-keyboard-shortcuts

var WINDOWS_HOTKEYS = {
  moveWordBackward: 'ctrl+left',
  moveWordForward: 'ctrl+right',
  moveLineBackward: 'home',
  moveLineForward: 'end',
  moveBlockBackward: 'ctrl+up',
  moveBlockForward: 'ctrl+down',
  moveToDocumentStart: 'ctrl+home',
  moveToDocumentEnd: 'ctrl+end',
  extendWordBackward: 'ctrl+shift+left',
  extendWordForward: 'ctrl+shift+right',
  extendLineBackward: 'shift+home',
  extendLineForward: 'shift+end',
  extendBlockBackward: 'ctrl+shift+up',
  extendBlockForward: 'ctrl+shift+down',
  selectAll: 'ctrl+a',
  deleteWordBackward: 'ctrl+shift?+backspace',
  deleteWordForward: 'ctrl+shift?+delete',
  redo: ['ctrl+y', 'ctrl+shift+z']
};

var create$1 = function create(key) {
  var generic = HOTKEYS[key];
  var apple = APPLE_HOTKEYS[key];
  var windows = WINDOWS_HOTKEYS[key];
  var isGeneric = generic && isKeyHotkey(generic);
  var isApple = apple && isKeyHotkey(apple);
  var isWindows = windows && isKeyHotkey(windows);
  return function (event) {
    if (isGeneric && isGeneric(event)) {
      return true;
    }

    if (IS_MAC && isApple && isApple(event)) {
      return true;
    }

    if (!IS_MAC && isWindows && isWindows(event)) {
      return true;
    }

    return false;
  };
};

var hotkeys = {
  isBold: create$1('bold'),
  isCompose: create$1('compose'),
  isSelectAll: create$1('selectAll'),
  isMoveBackward: create$1('moveBackward'),
  isMoveForward: create$1('moveForward'),
  isMoveUpward: create$1('moveUpward'),
  isMoveDownward: create$1('moveDownward'),
  isDeleteBackward: create$1('deleteBackward'),
  isDeleteForward: create$1('deleteForward'),
  isDeleteLineBackward: create$1('deleteLineBackward'),
  isDeleteLineForward: create$1('deleteLineForward'),
  isDeleteWordBackward: create$1('deleteWordBackward'),
  isDeleteWordForward: create$1('deleteWordForward'),
  isExtendBackward: create$1('extendBackward'),
  isExtendForward: create$1('extendForward'),
  isExtendUpward: create$1('extendUpward'),
  isExtendDownward: create$1('extendDownward'),
  isExtendWordBackward: create$1('extendWordBackward'),
  isExtendWordForward: create$1('extendWordForward'),
  isExtendLineBackward: create$1('extendLineBackward'),
  isExtendLineForward: create$1('extendLineForward'),
  isExtendBlockBackward: create$1('extendBlockBackward'),
  isExtendBlockForward: create$1('extendBlockForward'),
  isExtendToDocumentStart: create$1('extendToDocumentStart'),
  isExtendToDocumentEnd: create$1('extendToDocumentEnd'),
  isItalic: create$1('italic'),
  isMoveWordBackward: create$1('moveWordBackward'),
  isMoveWordForward: create$1('moveWordForward'),
  isMoveLineBackward: create$1('moveLineBackward'),
  isMoveLineForward: create$1('moveLineForward'),
  isMoveBlockBackward: create$1('moveBlockBackward'),
  isMoveBlockForward: create$1('moveBlockForward'),
  isMoveToDocumentStart: create$1('moveToDocumentStart'),
  isMoveToDocumentEnd: create$1('moveToDocumentEnd'),
  isRedo: create$1('redo'),
  isSplitBlock: create$1('splitBlock'),
  isTransposeCharacter: create$1('transposeCharacter'),
  isUndo: create$1('undo'),
  isSpace: create$1('space'),
  isEnter: create$1('enter'),
  isCopy: create$1('copy'),
  isCut: create$1('cut'),
  isPaste: create$1('paste')
};

var SUPRESS_WITHOUT_SAVING_ERROR = {
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: true
};

function deserializeSelection(document, selection) {
  var anchor = selection.anchor,
      focus = selection.focus;
  return Selection.fromJSON({
    anchor: _extends({}, anchor, {
      // @ts-ignore
      key: anchor.path ? document.assertNodeByPath(anchor.path).key : anchor.key
    }),
    focus: _extends({}, focus, {
      // @ts-ignore
      key: focus.path ? document.assertNodeByPath(focus.path).key : focus.key
    })
  });
}

function deserializeOperation(document, operation) {
  if (operation.type !== OperationType.SetSelection) {
    return operation;
  }

  var selection = deserializeSelection(document, operation.selection);
  var prevSelection = deserializeSelection(document, operation.prevSelection);
  return _extends({}, operation, {
    selection: selection,
    prevSelection: prevSelection
  });
}

function serializeSelection(document, selection) {
  var anchor = selection.anchor,
      focus = selection.focus;
  return {
    anchor: _extends({}, anchor.toJSON(), {
      path: document.getPath(anchor.key)
    }),
    focus: _extends({}, focus.toJSON(), {
      path: document.getPath(focus.key)
    })
  };
}

function createHistoryPlugin(configs) {
  var _configs$history;

  var maxHistorySize = configs == null ? void 0 : (_configs$history = configs.history) == null ? void 0 : _configs$history.maxHistorySize;

  function redo(controller) {
    var value = controller.value;
    var history = value.data.history || History.create({
      maxHistorySize: maxHistorySize
    });
    var redos = history.redos;

    if (!redos.length) {
      return controller;
    }

    var batch = redos[redos.length - 1];
    controller.withoutNormalizing(function () {
      controller.withoutSaving(function () {
        batch.forEach(function (op) {
          controller.applyOperation(deserializeOperation(controller.value.document, op));
        });
      }, SUPRESS_WITHOUT_SAVING_ERROR);
    });
    var newHistory = history.moveLastRedoRecordToUndos();
    return controller.setData(_extends({}, value.data, {
      history: newHistory
    }));
  }

  function undo(controller) {
    var value = controller.value;
    var history = value.data.history || History.create({
      maxHistorySize: maxHistorySize
    });
    var undos = history.undos;

    if (!undos.length) {
      return controller;
    }

    var undoRecord = [];
    controller.withoutNormalizing(function () {
      controller.withoutSaving(function () {
        var reversed = [].concat(undos[undos.length - 1]).reverse();
        reversed.forEach(function (op) {
          undoRecord.unshift(undoOperation(controller, op));
          controller.applyOperation(deserializeOperation(controller.value.document, Operation.invert(op)));
        });
      }, SUPRESS_WITHOUT_SAVING_ERROR);
    });
    var newHistory = history.moveLastUndoRecordToRedos(undoRecord);
    return controller.setData(_extends({}, value.data, {
      history: newHistory
    }));
  }

  function undoOperation(controller, operation) {
    if (operation.type === OperationType.InsertNode) {
      var document = controller.value.document;
      return _extends({}, operation, {
        node: document.assertNodeByPath(operation.path)
      });
    }

    return operation;
  }

  function onConstruct(controller, next) {
    // @ts-ignore
    var privateApplyOperation = controller.privateApplyOperation; // @ts-ignore

    controller.privateApplyOperation = function (op) {
      // @ts-ignore
      if (controller.flag.saving) {
        var value = controller.value,
            operations = controller.operations;
        var document = value.document,
            data = value.data; // @ts-ignore

        var operation = op.type === OperationType.SetSelection ? _extends({}, op, {
          selection: serializeSelection(document, op.selection),
          prevSelection: serializeSelection(document, op.prevSelection)
        }) : op;
        var history = data.history || History.create({
          maxHistorySize: maxHistorySize
        });
        var newHistory = history.mergeToLastUndoIfNeed(operation, operations.length !== 0);
        var newValue = value.set('data', _extends({}, value.data, {
          history: newHistory
        }));
        controller.setValue(newValue, {
          clearOperations: false,
          normalize: false,
          clearHots: false
        });
      }

      return privateApplyOperation.call(controller, op);
    };

    return next();
  }

  function onKeyDown(event, controller, next) {
    if (hotkeys.isRedo(event)) {
      event.preventDefault();
      return controller.withoutPending(function (ctrl) {
        return ctrl.command('redo');
      });
    }

    if (hotkeys.isUndo(event)) {
      event.preventDefault();
      return controller.withoutPending(function (ctrl) {
        return ctrl.command('undo');
      });
    }

    return next();
  }

  return {
    commands: {
      redo: redo,
      undo: undo
    },
    onConstruct: onConstruct,
    onKeyDown: onKeyDown,
    models: []
  };
}

var _createElement$l = React.createElement;
var CURSOR_BLINK_ANIMATION_TIME = 530;
var CURSOR_STYLE = {
  position: 'absolute',
  top: 0,
  left: 0,
  width: CURSOR_WIDTH,
  opacity: 1,
  zIndex: 1,
  pointerEvents: 'none',
  willChange: 'transform,height,opacity'
};

function useBlinkAnimation(cursorRef, pointStr, controller, // Placeholder Mode: disable the blink animation and add an opacity style
mode) {
  var isVisible = React.useRef(true);
  var timeout = React.useRef(null);
  var prevPoint = React.useRef(null);
  React.useLayoutEffect(function () {
    var caretNode = cursorRef.current;

    if (!caretNode || !pointStr) {
      return undefined;
    }

    if (mode === 'placeholder') {
      caretNode.style.opacity = '0.5';
      return undefined;
    }

    function toggleBackgroundColor() {
      if (caretNode) {
        // 输入过程中不闪烁
        if (controller.isPending && controller.pendingType === PendingType.input) {
          caretNode.style.opacity = '1';
        } else {
          var visible = prevPoint.current !== pointStr || isVisible.current;
          caretNode.style.opacity = visible ? '1' : '0';
          isVisible.current = !visible;
        }
      }

      timeout.current = window.setTimeout(toggleBackgroundColor, CURSOR_BLINK_ANIMATION_TIME);
    }

    toggleBackgroundColor();
    prevPoint.current = pointStr;
    return function () {
      if (timeout.current) {
        clearTimeout(timeout.current);
      }
    };
  }, [pointStr, mode, controller]);
}

function LocalCaret(props) {
  var ref = React.useRef(null);
  var position = props.position,
      color = props.color,
      style = props.style,
      mode = props.mode,
      controller = props.controller,
      selection = props.selection;
  /* https://aone.alibaba-inc.com/v2/bug/35876239# 《【0730闪会BugBash】左侧 edge selection 定位到高亮条外面去了》 */
  // 外部无法通过样式直接影响选区，需要通过 query 指定自定义偏移量

  var _React$useMemo = React.useMemo(function () {
    if (selection.isExpanded) {
      return {};
    }

    return controller.query('getCaretOffset', selection) || {};
  }, [selection, controller]),
      _React$useMemo$left = _React$useMemo.left,
      left = _React$useMemo$left === void 0 ? 0 : _React$useMemo$left,
      _React$useMemo$top = _React$useMemo.top,
      top = _React$useMemo$top === void 0 ? 0 : _React$useMemo$top;

  var point = selection.anchor;
  var pointStr = selection.isCollapsed ? point.viewKey : '';
  var where = point.isTextPoint() ? point.offset + controller.value.composing.length : point.edge;

  var cursorStyle = _extends({}, CURSOR_STYLE, {
    backgroundColor: color,
    height: position.height
  }, style || {}, {
    transform: "translateX(" + (position.left + left) + "px) translateY(" + (position.top + top) + "px)"
  });

  useBlinkAnimation(ref, pointStr, controller, mode);
  return /*#__PURE__*/_createElement$l("span", {
    ref: ref,
    "data-testid": "cangjie-caret",
    "data-cangjie-caret": "true",
    "data-cangjie-point": pointStr,
    key: pointStr,
    "data-where": where,
    style: cursorStyle
  });
}

var _createElement$k = React.createElement;

var isComponentPropsEqual$1 = function isComponentPropsEqual(prevProps, nextProps) {
  return prevProps.isFocused === nextProps.isFocused && prevProps.isRemote === nextProps.isRemote && prevProps.color === nextProps.color && prevProps.selection === nextProps.selection && equal(prevProps.position, nextProps.position);
}; // eslint-disable-next-line prefer-arrow-callback


var Caret = /*#__PURE__*/React.memo(function Caret(props) {
  var controller = props.controller,
      isRemote = props.isRemote,
      isFocused = props.isFocused,
      selection = props.selection,
      color = props.color,
      position = props.position;

  var _ref = controller.showCaret || {},
      showCaretOnBlur = _ref.onBlur,
      showCaretOnReadOnly = _ref.onReadOnly;

  if (selection.isExpanded) {
    return null;
  }

  if ( // 大多数情况，focused && 编辑态
  isFocused && !controller.readOnly || // blur 时，配置 showCaretOnBlur 时可以显示远程光标
  !isFocused && isRemote && showCaretOnBlur || // 只读时，配置 showCaretOnReadOnly 时可以显示远程光标
  controller.readOnly && isRemote && showCaretOnReadOnly) {
    return /*#__PURE__*/_createElement$k(React.Fragment, null, isRemote ? controller.run('renderRemoteCaret', {
      selection: selection,
      position: position
    }) : controller.run('renderCaret', {
      position: position,
      color: color
    }));
  }

  return null;
}, isComponentPropsEqual$1);

/**
 * @packageDocumentation
 * @module Events
 */

function CangjieInputEvent(detail) {
  return new CustomEvent('cangjieInput', {
    detail: detail
  });
}

/**
 * @packageDocumentation
 * @module domUtils
 */
/**
 * 根据浏览器的 HTML Element 获取仓颉的 Node。
 */

function findNode(element, controller) {
  var closest = findClosestInContent(element, "[" + Selector.key + "]");
  if (!closest) return null;
  var key = closest.getAttribute(Selector.key);
  if (!key) return null;
  var value = controller.value;
  var document = value.document;
  var node = document.getNode(key);
  return node || null;
}

/**
 * Detect if the cursor should be moved inside when deleting/moving at void edges
 */

function shoudStopInsideVoid(controller, direciton) {
  var isBackward = direciton === 'moveBackward';
  var _controller$value = controller.value,
      selection = _controller$value.selection,
      document = _controller$value.document;
  var anchor = selection.anchor;
  var node = document.getNode(anchor.key);

  if (selection.isExpanded || !node) {
    return false;
  }

  var voidNode = null;

  if (anchor.isEdgePoint()) {
    // edge point cases, current node maybe void block
    var isBackwardCase = isBackward && anchor.edge === EdgePoint.AFTER;
    var isForwardCase = !isBackward && anchor.edge === EdgePoint.BEFORE;
    var directionHit = isBackwardCase || isForwardCase;
    var isVoid = controller.query('isVoid', node);
    voidNode = isVoid && directionHit ? node : null;
  } else if (isBackward && node.isText() && anchor.offset === 0) {
    // text cases, previous node maybe void inline
    var prev = document.getPreviousText(anchor.key);
    var parent = prev && document.getParent(prev.key);

    var _isVoid = parent && controller.query('isVoid', parent);

    voidNode = _isVoid && parent != null && parent.isElement() && parent.isInline() ? parent : null;
  } else if (!isBackward && node.isText() && node.text.length === anchor.offset) {
    // text cases, next node maybe void inline
    var next = document.getNextText(anchor.key);

    var _parent = next && document.getParent(next.key);

    var _isVoid2 = _parent && controller.query('isVoid', _parent);

    voidNode = _isVoid2 && _parent != null && _parent.isElement() && _parent.isInline() ? _parent : null;
  }

  var point = voidNode && voidNode.getFirstText();

  if (!point) {
    return false;
  } // now we found the void, move inside!


  var newPoint = TextPoint.create({
    key: point.key,
    offset: 0
  });
  var newSelection = selection.set('anchor', newPoint).moveToAnchor();
  controller.run('onCangjieSelect', CangjieSelectEvent({
    selection: newSelection,
    trigger: direciton
  }));
  return true;
}

function perfMark(key) {
  if (typeof performance.mark === 'function') {
    performance.mark(key);
  }
}
function perfMeasure(name, start, end) {
  if (typeof performance.measure === 'function') {
    performance.measure(name, start, end);
  }
}

var _createElement$j = React.createElement;
var warn = Debug('EDITOR:CANGJIE:PLUGIN');

if (typeof console !== 'undefined') {
  warn.log = console.warn.bind(console);
}

var IS_TOUCH_MOBILE$1 = IS_MOBILE || IS_TOUCH_DEVICE;
function createCorePlugin() {
  function decorateNode() {
    return [];
  }

  function injectToNode() {
    return [];
  }

  function onApplyOperation(op, controller) {
    return controller.applyOperation(op);
  }

  function groupNodes(_ref, _ref2) {
    var start = _ref[0],
        end = _ref[1];
    var parent = _ref2.parent;
    var nodes = parent.nodes;
    return {
      node: nodes[start],
      remainedRange: [start + 1, end]
    };
  }

  function onCopy(event, controller) {
    event.preventDefault();

    if (controller.readOnly && !controller.canCopy) {
      warn('Copy command is prohibited.');
      return;
    }

    var cangjieCopyEvent = CangjieClipboardEvent('cangjieCopy', {
      nativeEvent: event.nativeEvent
    });

    try {
      controller.run('onCangjieCopy', cangjieCopyEvent.setClipboardData(createClipboardDataFromSelection(controller)));
    } catch (error) {
      controller.run('onAction', {
        type: ACTION_COPY_FAIL,
        payload: {
          error: error
        }
      });
      throw error;
    }
  }

  function onCut(event, controller) {
    event.preventDefault();

    if (controller.readOnly && !controller.canCopy) {
      warn('Cut command is prohibited.');
      return;
    }

    var cangjieCutEvent = CangjieClipboardEvent('cangjieCut', {
      nativeEvent: event.nativeEvent
    });

    try {
      controller.run('onCangjieCut', cangjieCutEvent.setClipboardData(createClipboardDataFromSelection(controller)));
    } catch (error) {
      controller.run('onAction', {
        type: ACTION_CUT_FAIL,
        payload: {
          error: error
        }
      });
      throw error;
    }
  }

  function onPaste(event, controller) {
    event.preventDefault();
    var cangjiePasteEvent = CangjieClipboardEvent('cangjiePaste', {
      nativeEvent: event.nativeEvent
    });

    try {
      controller.run('onCangjiePaste', cangjiePasteEvent.setClipboardData(CangjieDataTransfer.create(event.clipboardData)));
    } catch (error) {
      controller.run('onAction', {
        type: ACTION_PASTE_FAIL,
        payload: {
          isShortcut: true,
          error: error
        }
      });
      throw error;
    }
  }

  function onCangjieFocus(controller) {
    return controller.command(focus);
  }

  function onCangjieBlur(controller) {
    return controller.command(blur);
  }

  function onCangjieInput(e, controller, next) {
    var _controller$value = controller.value,
        document = _controller$value.document,
        selection = _controller$value.selection;
    var detail = e.detail;
    var type = detail.type,
        data = detail.data;

    if (type === 'insertText' && data) {
      // 在这里 flush 会导致 Android 联想状态回车后续的 splitBlock 无效
      // 但不 flush 会导致桌面端中文输入选词失效
      return controller.command(insertText$1, data);
    }

    if (type === 'compositionStart') {
      perfMark('compositionStart');

      if (selection != null && selection.isExpanded) {
        return controller.command('del');
      }

      if (selection != null && selection.isCollapsed && document.hasVoidParent(selection.anchor.key, controller)) {
        return controller.command(moveToStartOfNextText);
      }
    }

    if (type === 'deleteContentBackward') {
      if (!selection) {
        return next();
      }

      var length = (data || '').length;
      return controller.command(deleteBackwardAtRange, selection, length);
    }

    if (type === 'insertParagraph') {
      if (selection != null && selection.isCollapsed && document.hasVoidParent(selection.anchor.key, controller)) {
        var parent = document.getClosestVoid(selection.anchor.key, controller);

        if (document.getLastNode().key === selection.anchor.key && parent) {
          return controller.command(insertEmptyBlock, EdgePoint.create({
            key: parent.key,
            edge: EdgePoint.AFTER
          }));
        }

        var nextText = document.getNextText(selection.focus.key);

        if (nextText) {
          var newRange = selection.moveAnchorTo(nextText.key, 0).moveToAnchor();
          return controller.run('onCangjieSelect', CangjieSelectEvent({
            selection: newRange
          }));
        }
      }

      return controller.command(splitBlock);
    }

    return next();
  }

  function onCangjieSelect(event, controller) {
    var detail = event.detail;
    var selection = detail.selection,
        trigger = detail.trigger;
    var _controller$value2 = controller.value,
        document = _controller$value2.document,
        prevSelection = _controller$value2.selection;

    if (!Selection.isValidSelection(document, selection)) {
      var selectionJSONString = JSON.stringify(selection.toJSON({
        preserveKeys: true
      }), null, 2);
      throw new Error("Core[onCangjieSelect] receive invalid selection: " + selectionJSONString);
    } // 发现selection除mark外没变化则不设置
    // 这里是行为层，不是command层，做这种处理是安全的


    if (equal(prevSelection.data, selection.data) && equal(prevSelection.anchor, selection.anchor) && equal(prevSelection.focus, selection.focus)) {
      return controller;
    }

    if (trigger) {
      var selectionWithData = trigger === SelectionTrigger.Selecting ? selection.merge({
        data: _extends({}, selection.data, {
          trigger: trigger
        })
      }) : selection;
      return controller.command(userSelect, selectionWithData);
    }

    return controller.command(select, selection);
  }

  function onCangjieCopy(event, controller) {
    if (!controller.canCopy) {
      warn('Copy command is prohibited.');
      return;
    }

    copyFragment(event, function () {
      if (IS_MOBILE || IS_TOUCH_DEVICE) {
        controller.command(moveToEnd);
      }
    });
  }

  function onCangjieCut(event, controller) {
    var selection = controller.value.selection;

    if (!controller.canCopy) {
      warn('Cut command is prohibited.');
      return;
    }

    copyFragment(event, function () {
      // 修复移动端点击触发 copy 后，仓颉选区 collapsed，造成无法删除（iOS 12 系列及 iOS 14.6 ）
      controller.command(select, selection).command(del);
    });
  }

  function onCangjieComposingChange(composing, controller) {
    if (composing === void 0) {
      composing = '';
    }

    if (!composing.length) {
      perfMark('compositionEnd');
    }

    controller.setComposing(composing);
  }

  function onCangjiePaste(event, controller) {
    if (!event.clipboardData) {
      throw new Error('`event` is invalid, please pass clipbaord data with event.');
    }

    var transfer = getEventTransfer(event, controller);

    if (transfer.fragment) {
      controller.command(insertFragment, transfer.fragment);
      return;
    }

    if (!transfer.text) {
      return;
    }

    var texts = transfer.text.split('\n');
    texts.forEach(function (line, index) {
      if (index !== 0) {
        controller.command(splitBlock);
      }

      controller.command(insertText$1, line);
    });
  }

  function onClick(e, controller, next) {
    var value = controller.value;
    var document = value.document;
    var node = findNode(e.target, controller);
    if (!node) return next();
    var ancestors = document.getAncestors(node.key);
    var isVoid = node && (controller.query('isVoid', node) || ancestors.some(function (a) {
      return controller.query('isVoid', a);
    }));
    var firstText = node.getFirstText();

    if (isVoid && firstText) {
      var selection = value.selection.moveAnchorTo(firstText.key, 0).moveToAnchor();
      controller.run('onCangjieSelect', CangjieSelectEvent({
        selection: selection
      }));
    }

    return next();
  }

  function onKeyDown(event, controller, next) {
    var _controller$value3 = controller.value,
        selection = _controller$value3.selection,
        document = _controller$value3.document;

    if (!selection) {
      return next();
    }

    if (hotkeys.isSplitBlock(event)) {
      event.preventDefault(); // 如果光标在一个 void 元素中，则不进行 split 操作，直接移动光标到下一个 Text 节点
      // 这个行为主要用于处理 image/mention 等 inline 元素的断行问题

      return controller.run('onCangjieInput', CangjieInputEvent({
        type: 'insertParagraph',
        data: null
      }));
    }

    if (hotkeys.isDeleteBackward(event)) {
      if (IS_MOBILE) {
        // 移动端由于删除事件不准确，这里不 preventDefault，走 onChange 路径
        return;
      }

      var isProceeded = shoudStopInsideVoid(controller, 'moveBackward');
      event.preventDefault();

      if (isProceeded) {
        return controller;
      }

      return controller.command(deleteCharBackward);
    }

    if (hotkeys.isDeleteForward(event)) {
      var _isProceeded = shoudStopInsideVoid(controller, 'moveForward');

      event.preventDefault();

      if (_isProceeded) {
        return controller;
      }

      return controller.command(deleteCharForward);
    }

    if (hotkeys.isDeleteLineBackward(event)) {
      event.preventDefault();
      return controller.command(deleteLineBackward);
    }

    if (hotkeys.isDeleteLineForward(event)) {
      event.preventDefault();
      return controller.command(deleteLineForward);
    }

    if (hotkeys.isDeleteWordBackward(event)) {
      event.preventDefault();
      return controller.command(deleteWordBackward);
    }

    if (hotkeys.isDeleteWordForward(event)) {
      event.preventDefault();
      return controller.command(deleteWordForward);
    }

    if (hotkeys.isMoveBlockBackward(event)) {
      event.preventDefault();
      var newSelection = selection.movePointEdgeKlass(controller, 'start', 'start', 'block').moveToStart(document);
      return controller.command(select, newSelection);
    }

    if (hotkeys.isMoveBlockForward(event)) {
      event.preventDefault();

      var _newSelection = selection.movePointEdgeKlass(controller, 'end', 'end', 'block').moveToEnd(document);

      return controller.command(select, _newSelection);
    }

    if (hotkeys.isExtendBlockBackward(event)) {
      event.preventDefault();

      var _newSelection2 = selection.movePointEdgeKlass(controller, 'focus', 'start', 'block');

      return controller.command(select, _newSelection2);
    }

    if (hotkeys.isExtendBlockForward(event)) {
      event.preventDefault();

      var _newSelection3 = selection.movePointEdgeKlass(controller, 'focus', 'end', 'block');

      return controller.command(select, _newSelection3);
    }

    if (hotkeys.isCopy(event) && IS_TOUCH_MOBILE$1) {
      controller.run('onAction', {
        type: ACTION_COPY
      });
      return controller;
    }

    if (hotkeys.isCut(event) && IS_TOUCH_MOBILE$1) {
      controller.run('onAction', {
        type: ACTION_CUT
      });
      return controller;
    }

    return next();
  }

  function renderEditable(props) {
    var children = props.children;
    return children();
  }

  function renderNode(props, _, next) {
    var attributes = props.attributes,
        node = props.node,
        children = props.children;
    var Tag = Block.isBlock(node) ? 'div' : 'span';
    var result = next();

    if (result === null) {
      return /*#__PURE__*/_createElement$j(Tag, attributes, children());
    }

    return result;
  }

  function renderMark(props) {
    var children = props.children;
    return children();
  }

  function renderCaret(_ref3, controller) {
    var position = _ref3.position,
        color = _ref3.color;
    var value = controller.value;
    var document = value.document,
        selection = value.selection;

    if (!selection) {
      return null;
    }

    if (document.getClosest(selection.focus.key, function (node) {
      return controller.query('isVoid', node);
    })) {
      return null;
    }

    return /*#__PURE__*/_createElement$j(LocalCaret, {
      "data-cangjie-selection": selection.viewKey,
      controller: controller,
      selection: selection,
      position: position,
      color: color
    });
  }

  function selectionColor(controller) {
    var isFocused = controller.value.isFocused;
    return isFocused ? CANGJIE_SELECTION_COLOR : CANGJIE_SELECTION_INACTIVE_COLOR;
  }

  function isEditorBusy(controller) {
    // OP Pending 或热区过程中
    if (controller.isPending) {
      return true;
    } // 输入法输入过程中


    if (controller.value.composing) {
      return true;
    }

    return false;
  }

  function onCleanup(controller, next) {
    if (CONTROLLER_TO_KEY_DOM.has(controller)) {
      // weakmap的value是map,引用到了dom
      var map = CONTROLLER_TO_KEY_DOM.get(controller);
      map && Object.keys(map).forEach(function (key) {
        map == null ? void 0 : map["delete"](key);
      });
      CONTROLLER_TO_KEY_DOM["delete"](controller);
    }

    return next();
  }

  function mapOperation(op) {
    return op;
  }

  function isElementInGroup(controller, element, group) {
    return true;
  }

  return {
    queries: {
      selectionColor: selectionColor,
      isEditorBusy: isEditorBusy,
      isElementInGroup: isElementInGroup
    },
    decorateNode: decorateNode,
    injectToNode: injectToNode,
    groupNodes: groupNodes,
    onApplyOperation: onApplyOperation,
    onCangjieFocus: onCangjieFocus,
    onCangjieBlur: onCangjieBlur,
    onCangjieInput: onCangjieInput,
    onCangjieSelect: onCangjieSelect,
    onCangjieCopy: onCangjieCopy,
    onCangjieCut: onCangjieCut,
    onCangjiePaste: onCangjiePaste,
    onCangjieComposingChange: onCangjieComposingChange,
    onClick: onClick,
    onCopy: onCopy,
    onCut: onCut,
    onKeyDown: onKeyDown,
    onPaste: onPaste,
    onCleanup: onCleanup,
    renderEditable: renderEditable,
    renderContent: renderEditable,
    renderNode: renderNode,
    renderMark: renderMark,
    renderCaret: renderCaret,
    mapOperation: mapOperation,
    models: []
  };
}

var createMapOperations = function createMapOperations(gen, uuidKey, getUUIDs) {
  function generateUUID(node, diff) {
    var uuids = getUUIDs();
    var uuid = node.data[uuidKey]; // 如果无 UUID，或者 UUID 重复，则需要重新创建 UUID

    if (!uuid || uuids[uuid]) {
      var _extends2;

      var newUUID = gen();
      uuids[newUUID] = node.key;
      diff.adds.push({
        uuid: newUUID,
        key: node.key
      });
      return node.merge({
        data: _extends({}, node.data, (_extends2 = {}, _extends2[uuidKey] = newUUID, _extends2))
      });
    }

    return node;
  }

  var genUUIDForTree = function genUUIDForTree(root, diff) {
    var newRoot = root.mapDescendants(function (n) {
      if (n.isElement()) {
        return generateUUID(n, diff);
      }

      return n;
    });
    return generateUUID(newRoot, diff);
  };

  var adjustSetNodeOperation = function adjustSetNodeOperation(op, document) {
    var uuids = getUUIDs();
    var properties = op.properties,
        prevProperties = op.prevProperties,
        path = op.path;
    var node = document.assertElementByPath(path);
    /* istanbul ignore next */

    var data = properties.data || {};
    /* istanbul ignore next */

    var prevData = prevProperties.data || {};
    var theUUID = data[uuidKey];
    var thePrevUUID = prevData[uuidKey];
    return match({
      uuid: theUUID,
      prevUUID: thePrevUUID,
      reset: theUUID !== thePrevUUID
    })["with"]( // 若设置节点时，丢失 UUID，则写回 UUID
    {
      uuid: P.nullish,
      prevUUID: P.not(P.nullish)
    }, function (_ref) {
      var _extends3;

      var prevUUID = _ref.prevUUID;
      return {
        op: _extends({}, op, {
          properties: _extends({}, properties, {
            data: _extends({}, data, (_extends3 = {}, _extends3[uuidKey] = prevUUID, _extends3))
          })
        }),
        diff: {
          adds: [],
          removes: [],
          updates: []
        }
      };
    })["with"]( // 若设置节点时，UUID 不重复，则允许生成
    {
      uuid: P.when(function (id) {
        return id && !uuids[id];
      }),
      prevUUID: P.not(P.nullish),
      reset: true
    }, function (_ref2) {
      var uuid = _ref2.uuid,
          prevUUID = _ref2.prevUUID;
      return {
        op: op,
        diff: {
          adds: [],
          removes: [],
          updates: [{
            oldUUID: prevUUID,
            newUUID: uuid
          }]
        }
      };
    })["with"]( // 若设置节点时，UUID 重复，则重新生成 UUID
    {
      uuid: P.when(function (id) {
        return id && uuids[id] !== node.key;
      }),
      prevUUID: P.not(P.nullish),
      reset: true
    }, function (_ref3) {
      var _extends4;

      var prevUUID = _ref3.prevUUID;
      var newUUID = gen();
      return {
        op: _extends({}, op, {
          properties: _extends({}, properties, {
            data: _extends({}, data, (_extends4 = {}, _extends4[uuidKey] = newUUID, _extends4))
          })
        }),
        diff: {
          adds: [],
          removes: [],
          updates: [{
            oldUUID: prevUUID,
            newUUID: newUUID
          }]
        }
      };
    })["with"]( // 设置不含有 UUID 的节点时，若新的属性缺失 UUID，则生成 UUID
    {
      uuid: P.nullish,
      prevUUID: P.nullish
    }, // 设置不含有 UUID 的节点时，若新的属性有 UUID，但重复，则生成 UUIID
    {
      uuid: P.when(function (id) {
        return uuids[id] && uuids[id] !== node.key;
      }),
      prevUUID: P.nullish
    }, function () {
      var _extends5;

      var newUUID = gen();
      return {
        op: _extends({}, op, {
          properties: _extends({}, properties, {
            data: _extends({}, data, (_extends5 = {}, _extends5[uuidKey] = newUUID, _extends5))
          })
        }),
        diff: {
          adds: [{
            uuid: newUUID,
            key: node.key
          }],
          removes: [],
          updates: []
        }
      };
    })["with"]( // 设置不含有 UUID 的节点时，若新的属性中含有不重复的 UUID，允许生成
    {
      uuid: P.when(function (id) {
        return id && !uuids[id];
      }),
      prevUUID: P.nullish
    }, function (_ref4) {
      var uuid = _ref4.uuid;
      return {
        op: op,
        diff: {
          adds: [{
            uuid: uuid,
            key: node.key
          }],
          removes: [],
          updates: []
        }
      };
    })
    /* istanbul ignore next */
    .otherwise(function () {
      return {
        op: op,
        diff: {
          adds: [],
          removes: [],
          updates: []
        }
      };
    });
  };

  var adjustRemoveNodeOperation = function adjustRemoveNodeOperation(op) {
    var node = op.node;

    if (node.isElement() && node.data[uuidKey]) {
      var uuid = node.data[uuidKey];
      return {
        op: op,
        diff: {
          adds: [],
          removes: [uuid],
          updates: []
        }
      };
    }

    return {
      op: op,
      diff: {
        adds: [],
        removes: [],
        updates: []
      }
    };
  };

  var adjustInsertNodeOperation = function adjustInsertNodeOperation(op) {
    var node = op.node;
    var diff = {
      adds: [],
      removes: [],
      updates: []
    };

    if (node.isElement()) {
      return {
        op: _extends({}, op, {
          node: genUUIDForTree(node, diff)
        }),
        diff: diff
      };
    }

    return {
      op: op,
      diff: diff
    };
  };

  return function mapOperation(operation, document) {
    return match(operation)["with"]({
      type: OperationType.RemoveNode
    }, function (op) {
      return adjustRemoveNodeOperation(op);
    })["with"]({
      type: OperationType.SetNode
    }, function (op) {
      return adjustSetNodeOperation(op, document);
    })["with"]({
      type: OperationType.InsertNode
    }, function (op) {
      return adjustInsertNodeOperation(op);
    }).otherwise(function (op) {
      return {
        op: op,
        diff: {
          adds: [],
          removes: [],
          updates: []
        }
      };
    });
  };
};

var createUUIDQuery = function createUUIDQuery(uuidKey) {
  return function (_, node) {
    return node.data[uuidKey];
  };
};
function createGetNodeKeyByUUID(getUUIDS) {
  var getNodeKeyByUUID = function getNodeKeyByUUID(_, uuid) {
    var uuids = getUUIDS();
    return uuids[uuid];
  };

  return getNodeKeyByUUID;
}

function getUUIDSFromDocument(document, uuidKey) {
  var uuids = {};
  var duplications = [];
  document.forEachDescendant(function (desendant) {
    if (desendant.isElement() && desendant.data[uuidKey]) {
      var uuid = desendant.data[uuidKey];

      if (uuids[uuid]) {
        duplications.push(desendant.key);
      } else {
        uuids[uuid] = desendant.key;
      }
    }
  });
  return {
    uuids: uuids,
    duplications: duplications
  };
}

function toKeyUUIDMap(map) {
  return Object.keys(map).reduce(function (ret, uuid) {
    ret[map[uuid]] = uuid;
    return ret;
  }, {});
}

function diffUUIDS(a, b) {
  var aKeyToUUIDMap = toKeyUUIDMap(a);
  var bKeyToUUIDMap = toKeyUUIDMap(b);
  var diff = {
    adds: [],
    removes: [],
    updates: []
  };
  Object.keys(aKeyToUUIDMap).forEach(function (nodeKey) {
    var aUUID = aKeyToUUIDMap[nodeKey];
    var bUUID = bKeyToUUIDMap[nodeKey];

    if (aUUID !== bUUID) {
      diff.updates.push({
        oldUUID: aUUID,
        newUUID: bUUID
      });
    }

    if (!bKeyToUUIDMap[nodeKey]) {
      diff.removes.push(aUUID);
    }
  });
  Object.keys(bKeyToUUIDMap).forEach(function (nodeKey) {
    if (!aKeyToUUIDMap[nodeKey]) {
      diff.adds.push({
        uuid: bKeyToUUIDMap[nodeKey],
        key: nodeKey
      });
    }
  });
  return diff;
}
function isEmptyDiff(diff) {
  return !diff.adds.length && !diff.removes.length && !diff.updates.length;
}

var UPDATE_UUIDS = Symbol('update_uuids');
var GENERATE_UUID = Symbol('generate_uuid');
function updateUUIDs(payload) {
  return {
    type: UPDATE_UUIDS,
    payload: payload
  };
}
function isUpdateUUIDs(action) {
  return action.type === UPDATE_UUIDS;
}
function generateUUID(payload) {
  return {
    type: GENERATE_UUID,
    payload: payload
  };
}
function isGenerateUUID(action) {
  return action.type === GENERATE_UUID;
}
var actions = {
  updateUUIDs: updateUUIDs,
  generateUUID: generateUUID
};
var isActions = {
  isUpdateUUIDs: isUpdateUUIDs,
  isGenerateUUID: isGenerateUUID
};

function setNodeUUID(controller, node, uuid, uuidKey) {
  return controller.withoutSaving(function () {
    var _extends2;

    controller.command('setNodeByKey', node.key, {
      type: node.type,
      data: _extends({}, node.data, (_extends2 = {}, _extends2[uuidKey] = uuid, _extends2))
    });
  });
}
function createGenerateUUID(gen, uuidKey) {
  return function generateUUID(controller, node) {
    if (node.isElement() && !node.data[uuidKey]) {
      var uuid = gen();
      controller.command(setNodeUUID, node, uuid, uuidKey);
    }

    return controller;
  };
}

function onAction$1(action, controller, next) {
  var isGenerateUUID = controller.isActionFactory('isGenerateUUID');

  if (isGenerateUUID != null && isGenerateUUID(action)) {
    return controller.command('generateUUID', action.payload.node);
  }

  return next();
}

var DEFAULT_UUID_KEY = '__uuid__';

function createUUIDPlugin(config) {
  // 初始化 UUID 映射
  var uuids = {};

  function getUUIDS() {
    return uuids;
  }

  var uuidKey = config.uuidKey || DEFAULT_UUID_KEY;

  function regenerateDuplicateUUIDS(controller, value) {
    var befores = _extends({}, getUUIDS());

    var ret = getUUIDSFromDocument(value.document, uuidKey); // 为重复的 id 重新生成 uuid

    var newUUIDS = ret.duplications.reduce(function (ids, key) {
      var element = value.document.assertElement(key);
      var uuid = config.gen();
      controller.command(setNodeUUID, element, uuid, uuidKey);
      ids[uuid] = key;
      return ids;
    }, ret.uuids);
    var diff = diffUUIDS(befores, newUUIDS);

    if (!isEmptyDiff(diff)) {
      uuids = newUUIDS;
      controller.dispatch('updateUUIDs', {
        // Immutable，防止外部改动了 uuid
        uuids: _extends({}, newUUIDS),
        diff: diff
      });
    }
  }

  var _mapOperation = createMapOperations(config.gen, uuidKey, getUUIDS);

  return {
    actions: actions,
    isActions: isActions,
    commands: {
      generateUUID: createGenerateUUID(config.gen, uuidKey)
    },
    onConstruct: function onConstruct(controller, next) {
      regenerateDuplicateUUIDS(controller, controller.value);
      return next();
    },
    onResetValue: function onResetValue(value, _, controller, next) {
      regenerateDuplicateUUIDS(controller, value);
      return next();
    },
    onAction: onAction$1,
    mapOperation: function mapOperation(operation, controller, next) {
      var _mapOperation2 = _mapOperation(operation, controller.value.document),
          op = _mapOperation2.op,
          diff = _mapOperation2.diff;

      if (isEmptyDiff(diff)) {
        return op;
      }

      diff.removes.forEach(function (uuid) {
        delete uuids[uuid];
      });
      diff.adds.forEach(function (_ref) {
        var uuid = _ref.uuid,
            key = _ref.key;
        uuids[uuid] = key;
      });
      diff.updates.forEach(function (_ref2) {
        var oldUUID = _ref2.oldUUID,
            newUUID = _ref2.newUUID;
        var nodeKey = uuids[oldUUID];
        uuids[newUUID] = nodeKey;
        delete uuids[oldUUID];
      });
      controller.dispatch('updateUUIDs', {
        // Immutable，防止外部改动了 uuid
        uuids: _extends({}, uuids),
        diff: diff
      });
      return next(op);
    },
    queries: {
      uuid: createUUIDQuery(uuidKey),
      anchor: createUUIDQuery(uuidKey),
      getNodeKeyByUUID: createGetNodeKeyByUUID(getUUIDS)
    }
  };
}

var TOGGLE_GROUP_FOLD = Symbol('toggleGroupFold');
var FOLD_GROUP = Symbol('fold');
var EXPAND_GROUP = Symbol('expand');

/**
 * 折叠/展开分组
 * @param key
 * @returns
 */
function toggleGroupFold(key) {
  return {
    type: TOGGLE_GROUP_FOLD,
    payload: {
      key: key
    }
  };
}
/**
 * 折叠分组
 * @param key
 * @returns
 */

function fold(key) {
  return {
    type: FOLD_GROUP,
    payload: {
      key: key
    }
  };
}
/**
 * 展开分组
 * @param key
 * @returns
 */

function expand(key) {
  return {
    type: EXPAND_GROUP,
    payload: {
      key: key
    }
  };
}

var groupActions = /*#__PURE__*/Object.freeze({
  __proto__: null,
  TOGGLE_GROUP_FOLD: TOGGLE_GROUP_FOLD,
  FOLD_GROUP: FOLD_GROUP,
  EXPAND_GROUP: EXPAND_GROUP,
  toggleGroupFold: toggleGroupFold,
  fold: fold,
  expand: expand
});

var onAction = function onAction(action, controller, next) {
  var type = action.type,
      payload = action.payload;
  var groupManager = controller.groupManager;

  if (type === TOGGLE_GROUP_FOLD || type === FOLD_GROUP || type === EXPAND_GROUP) {
    var _ref = payload,
        key = _ref.key;
    var group = groupManager.getGroup(key);

    if (group) {
      if (type === TOGGLE_GROUP_FOLD) {
        var _groupManager$mergeGr;

        groupManager.mergeGroupData(key, (_groupManager$mergeGr = {}, _groupManager$mergeGr[GROUP_COLLAPSED_KEY] = !group.data[GROUP_COLLAPSED_KEY], _groupManager$mergeGr));
        return controller;
      } else {
        var _groupManager$mergeGr2;

        groupManager.mergeGroupData(key, (_groupManager$mergeGr2 = {}, _groupManager$mergeGr2[GROUP_COLLAPSED_KEY] = type === FOLD_GROUP, _groupManager$mergeGr2));
        return controller;
      }
    }
  }

  return next();
};

var renderNode$1 = function renderNode(props, controller, next) {
  return next();
};

var renderGroup = function renderGroup(props, controller, next) {
  var group = next();
  return group;
};

var onResetValue = function onResetValue(_value, _controllerValue, controller, next) {
  controller.groupManager.generateAllGroups().notifyNewGroups();
  return next();
};

var createGroupPlugin = function createGroupPlugin() {
  return {
    onAction: onAction,
    renderNode: renderNode$1,
    renderGroup: renderGroup,
    onResetValue: onResetValue
  };
};

/**
 * @packageDocumentation
 * @ignore
 */
var Status;
/**
 * WARN: Sometimes request idle callback in Safari will never be called!
 */

(function (Status) {
  Status["Idle"] = "Idle";
  Status["Pending"] = "Pending";
  Status["Canceled"] = "Canceled";
  Status["Done"] = "Done";
})(Status || (Status = {}));

/**
 * 默认的 flush 类型
 */
var DEFAULT_FLUSH_TYPE = 'microtask';
/**
 * flush 最大等待时间（100ms 是为了保证常规情况下反馈不会过长，同时大文档在连续情况下每隔 100ms 做一次渲染也能保障流畅度）
 * @description 浏览器的调度有时候会将线程长时间闲置，导致 flush 延迟过高
 * @example 一个典型的例子是当滚动区域触发一个滑动后，光标的再次点击，使浏览器的线程调度闲置（具体原因还在研究中）
 */

var FLUSH_MAX_WAIT = 100;

/**
 * 是否支持 idleCallback
 */
var IS_SUPPORT_IDLE_TASK = typeof window === 'object' && 'requestIdleCallback' in window && 'cancelIdleCallback' in window;
/**
 * 是否支持 animationFrame
 */

var IS_SUPPORT_FRAME_TASK = typeof window === 'object' && 'requestAnimationFrame' in window && 'cancelAnimationFrame' in window;
/**
 * 决议能够使用的 flushType
 * @param flushType 需要的 flushType
 */

function resolveSupportedType(flushType) {
  if (flushType === 'microtask') {
    return 'microtask';
  }

  if (flushType === 'idletask') {
    if (IS_SUPPORT_IDLE_TASK) {
      return 'idletask';
    } else if (IS_SUPPORT_FRAME_TASK) {
      return 'frametask';
    }
  }

  if (flushType === 'frametask' && IS_SUPPORT_FRAME_TASK) {
    return 'frametask';
  }

  return 'microtask';
}

var FlushTask = /*#__PURE__*/function () {
  FlushTask.create = function create(task, options) {
    return new FlushTask(task, options);
  }
  /**
   * 等待执行的微任务
   */
  ;

  function FlushTask(task, options) {
    if (options === void 0) {
      options = {};
    }

    this.task = void 0;
    this.status = Status.Idle;
    this.resolved = false;
    this.flushType = void 0;
    this.supportedFlushType = void 0;
    this.taskId = -1;
    this.task = task;
    var _options = options,
        _options$flushType = _options.flushType,
        flushType = _options$flushType === void 0 ? DEFAULT_FLUSH_TYPE : _options$flushType;
    this.flushType = flushType;
    this.supportedFlushType = resolveSupportedType(flushType);
  }

  var _proto = FlushTask.prototype;

  _proto.start = function start() {
    this.status = Status.Pending;

    if (!this.resolved) {
      this.requestTask();
      this.resolved = true;
    }

    return this;
  };

  _proto.cancel = function cancel() {
    this.status = Status.Canceled;
    this.cancelTask();
    return this;
  };

  _proto.getStatus = function getStatus() {
    return this.status;
  };

  _proto.requestTask = function requestTask() {
    var _this = this;

    if (this.supportedFlushType === 'idletask') {
      this.taskId = window.requestIdleCallback(function () {
        return _this.run();
      }, {
        timeout: FLUSH_MAX_WAIT
      });
    } else if (this.supportedFlushType === 'frametask') {
      this.taskId = window.requestAnimationFrame(function () {
        return _this.run();
      });
    } else {
      Promise.resolve().then(function () {
        return _this.run();
      });
    }
  };

  _proto.cancelTask = function cancelTask() {
    if (this.supportedFlushType === 'idletask') {
      window.cancelIdleCallback(this.taskId);
    } else if (this.supportedFlushType === 'frametask') {
      window.cancelAnimationFrame(this.taskId);
    }
  };

  _proto.run = function run() {
    if (this.status === Status.Pending && typeof this.task === 'function') {
      this.task.call(null);
      this.status = Status.Done;
    }
  };

  return FlushTask;
}();

/**
 * @packageDocumentation
 * @ignore
 */

function isChild(item) {
  return 'child' in item;
}

function isRangeStart(item) {
  return 'start' in item;
}

function isRangeEnd(item) {
  return 'end' in item;
}

function isEdgeAfter(edgePoint, edgePath, nodePath) {
  return edgePoint.isEdgePoint() && edgePoint.edge === EdgePoint.AFTER && (Path.isEqual(edgePath, nodePath) || Path.isAncestor(edgePath, nodePath));
}

function isEdgeBefore(edgePoint, edgePath, nodePath) {
  return edgePoint.isEdgePoint() && edgePoint.edge === EdgePoint.BEFORE && (Path.isEqual(edgePath, nodePath) || Path.isAncestor(edgePath, nodePath));
}

function sort(a, b) {
  if (a.order > b.order) {
    return 1;
  } else if (a.order === b.order) {
    return isRangeEnd(b) ? 1 : -1;
  }

  return -1;
}

function getChildrenDecorations(document, node, decorations) {
  var childrenDecorations = []; // 初始化排序数组，先放入节点子孙

  var orderArray = node.nodes.map(function (child, index) {
    return {
      child: child,
      order: index
    };
  });
  var nodePath = document.assertPath(node.key);
  var depth = nodePath.length;
  var last = node.nodes.length - 1; // 遍历 decorations，将其放入排序数组

  decorations.forEach(function (decoration) {
    var startPoint = decoration.start,
        endPoint = decoration.end;
    var startPath = document.getPath(startPoint.key);
    var endPath = document.getPath(endPoint.key);

    if (!startPath || !endPath) {
      return;
    }

    if (Path.isAfter(startPath, nodePath) || Path.isBefore(endPath, nodePath)) {
      return;
    } // 获得 decoration 相对于 node children 的起始位置


    var start = Path.isBefore(startPath, nodePath) ? 0 : startPath[depth];
    var end = Path.isAfter(endPath, nodePath) ? last : endPath[depth];
    orderArray.push({
      start: true,
      range: decoration,
      order: start - 0.5
    });
    orderArray.push({
      end: true,
      range: decoration,
      order: end + 0.5
    });
  });
  var activeDecorations = new Set();
  orderArray.sort(sort).forEach(function (item) {
    if (isRangeStart(item)) {
      activeDecorations.add(item.range);
    } else if (isRangeEnd(item)) {
      activeDecorations["delete"](item.range);
    } else if (isChild(item)) {
      childrenDecorations.push(Array.from(activeDecorations));
    }
  });
  return childrenDecorations;
}
function getChildrenIsSelected(document, node, selection) {
  var childrenIsSelected = node.nodes.map(function () {
    return false;
  });

  if (selection.isCollapsedAtEdge) {
    return childrenIsSelected;
  }

  var _selection$sort = selection.sort(document),
      startPoint = _selection$sort.start,
      endPoint = _selection$sort.end;

  var startPath = document.getPath(startPoint.key);
  var endPath = document.getPath(endPoint.key);

  if (!startPath || !endPath) {
    return childrenIsSelected;
  }

  var nodePath = document.assertPath(node.key);

  if (Path.isAfter(startPath, nodePath) || isEdgeAfter(startPoint, startPath, nodePath)) {
    return childrenIsSelected;
  }

  if (Path.isBefore(endPath, nodePath) || isEdgeBefore(endPoint, endPath, nodePath)) {
    return childrenIsSelected;
  }

  var depth = nodePath.length;
  var last = node.nodes.length - 1;
  var start = Path.isBefore(startPath, nodePath) || isEdgeBefore(startPoint, startPath, nodePath) ? 0 : startPath[depth];
  var end = Path.isAfter(endPath, nodePath) || isEdgeAfter(endPoint, endPath, nodePath) ? last : endPath[depth];

  for (var i = start; i <= end; i += 1) {
    childrenIsSelected[i] = true;
  }

  return childrenIsSelected;
}

/**
 * @packageDocumentation
 * @ignore
 */
function getChildrenInjections(document, node, injections) {
  var nodePath = document.assertPath(node.key);
  var depth = nodePath.length;
  var childInjections = node.nodes.map(function () {
    return [];
  });
  injections.forEach(function (injection) {
    var path = document.getPath(injection.key);

    if (path) {
      var index = path[depth];
      var injects = childInjections[path[depth]];

      if (index >= 0 && injects) {
        injects.push(injection);
      }
    }
  });
  return childInjections;
}

var CONTEXT_SPLIT = '@';
function getContexts(context) {
  return context ? context.split(CONTEXT_SPLIT) : [];
}
function getContextMeta(context) {
  if (typeof context !== 'string') {
    return null;
  }

  var matched = context.match(/\((.*?)\)$/);

  if (matched) {
    try {
      return JSON.parse(matched[1]);
    } catch (_unused) {
      return null;
    }
  }

  return null;
}

var opContext = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CONTEXT_SPLIT: CONTEXT_SPLIT,
  getContexts: getContexts,
  getContextMeta: getContextMeta
});

var Observable = /*#__PURE__*/function () {
  function Observable() {
    this.linkHead = null;
  }

  var _proto = Observable.prototype;

  _proto.subscribe = function subscribe(observer) {
    var _this = this;

    var link = {
      next: this.linkHead,
      prev: null,
      element: observer
    };

    if (this.linkHead) {
      this.linkHead.prev = link;
    }

    this.linkHead = link;
    return {
      unsubscribe: function unsubscribe() {
        if (link.next) {
          link.next.prev = link.prev;
        }

        if (link.prev) {
          link.prev.next = link.next;
        } else {
          _this.linkHead = link.next;
        }
      }
    };
  };

  _proto.onData = function onData(data) {
    var link = this.linkHead;

    while (link) {
      link.element(data);
      link = link.next;
    }
  };

  return Observable;
}();
var Subject = /*#__PURE__*/function (_Observable) {
  _inheritsLoose(Subject, _Observable);

  function Subject() {
    return _Observable.call(this) || this;
  }

  var _proto2 = Subject.prototype;

  _proto2.next = function next(data) {
    this.onData(data);
  };

  return Subject;
}(Observable);
var ReplaySubject = /*#__PURE__*/function (_Observable2) {
  _inheritsLoose(ReplaySubject, _Observable2);

  function ReplaySubject(max) {
    var _this2;

    if (max === void 0) {
      max = 1;
    }

    _this2 = _Observable2.call(this) || this;
    _this2.replays = [];
    _this2.max = void 0;
    _this2.max = max;
    return _this2;
  }

  var _proto3 = ReplaySubject.prototype;

  _proto3.subscribe = function subscribe(observer) {
    var sub = _Observable2.prototype.subscribe.call(this, observer);

    this.replays.forEach(function (data) {
      observer(data);
    });
    return sub;
  };

  _proto3.next = function next(data) {
    this.onData(data);

    if (this.replays.length === this.max) {
      this.replays.shift();
    }

    this.replays.push(data);
  };

  return ReplaySubject;
}(Observable);

var isSetSelection = function isSetSelection(_ref) {
  var operation = _ref.operation;
  return operation && operation.type === OperationType.SetSelection;
};

function getSelectionData(controller) {
  var _controller$value = controller.value,
      document = _controller$value.document,
      selection = _controller$value.selection;
  var blocks = selection.isCollapsedAtEdge ? [document.getNode(selection.anchor.key)] : document.getLeafBlocksAtRange(selection);
  var isHideSelection = controller.query('isHideSelection');
  return {
    range: selection,
    blocksKeys: new Set(blocks.map(function (b) {
      return b.key;
    })),
    isHideSelection: isHideSelection
  };
}
var isSelect = function isSelect(params) {
  var ops = params.ops,
      controller = params.controller;

  if (ops.length === 0) {
    return false;
  } // 从 blur 状态开始选区（点选/拖选），会有个先 focus 再 set_selction 的过程，可以 pending


  return ops.every(function (op, index) {
    if (index === 0) {
      return op.key === 'isFocused' && controller.value.isFocused || isSetSelection(op);
    }

    return isSetSelection(op);
  });
};
var getPending$2 = function getPending(_ref2) {
  var controller = _ref2.controller;
  return {
    type: PendingType.selection,
    effect: function effect() {
      controller.selectionData$.next(getSelectionData(controller));
    }
  };
};
var pattern$1 = [isSelect, getPending$2];

function isInsertTextOperation(op) {
  return op !== null && op.type === OperationType.InsertText;
}

function isRemoveTextOperation(op) {
  return op !== null && op.type === OperationType.RemoveText;
}

function isInsertOrRemove(operation) {
  return (isInsertTextOperation(operation) || isRemoveTextOperation(operation)) && operation.text.length === 1;
}

function isSetSelectionOperation(op) {
  return op !== null && op.type === OperationType.SetSelection;
}

function isContinuousOp(prevOp, operation) {
  // @ts-ignore
  if (!Path.isEqual(operation.path, prevOp.path)) {
    return false;
  }

  if (isInsertTextOperation(prevOp) && isInsertTextOperation(operation)) {
    return operation.offset === prevOp.offset + prevOp.text.length;
  } else if (isInsertTextOperation(prevOp) && isRemoveTextOperation(operation)) {
    return operation.offset === prevOp.offset + prevOp.text.length - operation.text.length;
  } else if (isRemoveTextOperation(prevOp) && isInsertTextOperation(operation)) {
    return operation.offset === prevOp.offset;
  } else if (isRemoveTextOperation(prevOp) && isRemoveTextOperation(operation)) {
    return operation.offset === prevOp.offset - operation.text.length;
  }

  return false;
}

function isContinuousInput(ops) {
  var operations = ops.filter(function (_ref) {
    var operation = _ref.operation;
    return !operation || !isSetSelectionOperation(operation);
  });

  if (!operations.length) {
    return false;
  }

  var operationsWithoutComposing = operations.filter(function (_ref2) {
    var key = _ref2.key;
    return key !== 'composing';
  });
  return operationsWithoutComposing.every(function (_ref3, index) {
    var operation = _ref3.operation;

    if (!isInsertOrRemove(operation)) {
      return false;
    }

    if (index === 0) {
      return true;
    }

    var prevOp = operationsWithoutComposing[index - 1].operation;
    return !prevOp || isContinuousOp(prevOp, operation);
  });
}
/**
 * 是否为连续输入
 * @param params
 * @returns
 */


var isTextInput = function isTextInput(params) {
  var ops = params.ops;
  return isContinuousInput(ops);
};

var shouldAppend = function shouldAppend(prevOps, ops) {
  // 找到最后一个非 set_selection op，做连续性比较
  var _ref4 = last(prevOps.filter(function (_ref5) {
    var key = _ref5.key,
        operation = _ref5.operation;
    return key !== 'composing' && !isSetSelectionOperation(operation);
  })) || {},
      prevOp = _ref4.operation;

  var _ref6 = ops.find(function (_ref7) {
    var key = _ref7.key,
        operation = _ref7.operation;
    return key !== 'composing' && !isSetSelectionOperation(operation);
  }) || {},
      operation = _ref6.operation;

  return !prevOp || !operation || isContinuousOp(prevOp, operation);
};

var getPending$1 = function getPending(_ref8) {
  var controller = _ref8.controller;
  return {
    type: PendingType.input,
    decorate: function decorate(ops) {
      var _ref9 = ops.find(function (_ref10) {
        var operation = _ref10.operation;
        return !isSetSelectionOperation(operation);
      }),
          operation = _ref9.operation,
          value = _ref9.value;

      if (operation === null) {
        // NOTE: operation is composing, need to get meta from controller.value
        var _controller$value = controller.value,
            selection = _controller$value.selection,
            document = _controller$value.document;
        var _ref11 = selection.focus,
            key = _ref11.key,
            _offset = _ref11.offset;
        return {
          key: key,
          startOffset: _offset,
          startPath: document.getPath(key)
        };
      }

      var _ref12 = operation,
          path = _ref12.path,
          offset = _ref12.offset;
      var text = value.document.getNodeByPath(path);
      return {
        key: text.key,
        startPath: path,
        startOffset: offset
      };
    },
    effect: function effect(ops, ctx) {
      ops.forEach(function (_ref13) {
        var operation = _ref13.operation;

        // send input op
        if (isSetSelectionOperation(operation)) {
          return;
        }

        controller.inputData$.next({
          key: ctx.key,
          startPath: ctx.startPath,
          startOffset: ctx.startOffset
        });
      });
      controller.selectionData$.next(getSelectionData(controller));
    },
    shouldAppend: shouldAppend
  };
};

var pattern = [isTextInput, getPending$1];

var getPending = cond([pattern, pattern$1, [stubTrue, function () {
  return null;
}]]);

var PendingQueue = /*#__PURE__*/function () {
  PendingQueue.create = function create(props) {
    return new PendingQueue(props);
  };

  function PendingQueue(props) {
    var _this = this;

    this.operations = [];
    this.pending = null;
    this.ctx = void 0;
    this.pendingGetter = void 0;
    this.debouncedFlush = void 0;
    this.controller = void 0;
    this.value = null;
    this.enablePending = void 0;

    this.flush = function () {
      _this.controller.flush();

      _this.clear();
    };

    var debounceTime = props.debounceTime,
        controller = props.controller,
        _props$pendingGetter = props.pendingGetter,
        pendingGetter = _props$pendingGetter === void 0 ? getPending : _props$pendingGetter,
        enablePending = props.enablePending;
    this.pendingGetter = pendingGetter;
    this.controller = controller;
    this.debouncedFlush = debounce(this.flush, debounceTime);

    if (typeof enablePending === 'boolean') {
      this.enablePending = Object.values(PendingType).reduce(function (result, key) {
        result[key] = enablePending;
        return result;
      }, {});
    } else {
      this.enablePending = enablePending;
    }
  }

  var _proto = PendingQueue.prototype;

  _proto.run = function run(operations) {
    var _ref = this.pending,
        effect = _ref.effect;
    this.value = this.controller.value;
    effect(operations, this.ctx);

    if (this.shouldDebouncedFlush) {
      this.debouncedFlush();
    }
  };

  _proto.isType = function isType(type) {
    var _this$pending;

    return ((_this$pending = this.pending) == null ? void 0 : _this$pending.type) === type;
  };

  _proto.queue = function queue(operations) {
    var params = {
      controller: this.controller,
      ops: operations
    };
    var pending = this.pendingGetter(params);

    if (!pending || !this.enablePending[pending.type]) {
      // 若 operations 不可 pending，则立即倾倒
      this.flush();
      this.controller.dispatchPendingTerminal();
    } else {
      var _pending$decorate = pending.decorate,
          decorate = _pending$decorate === void 0 ? function () {
        return null;
      } : _pending$decorate,
          _pending$shouldAppend = pending.shouldAppend,
          shouldAppend = _pending$shouldAppend === void 0 ? function () {
        return true;
      } : _pending$shouldAppend,
          type = pending.type;

      if (this.isType(type) && shouldAppend(this.operations, operations)) {
        // 如果是同类型且可合并的 pending，则合并
        Array.prototype.push.apply(this.operations, operations);
        this.run(operations);
      } else if (!this.pending) {
        // 如果 pending queue 不存在 pending 对象，则创建
        this.pending = pending;
        this.ctx = decorate(operations);
        this.operations = operations;
        this.run(operations);
      } else {
        // 若产生了不能合并的 pending，则立即倾倒 pending queue
        this.flush();
        this.controller.dispatchPendingTerminal();
      }
    }

    return this;
  };

  _proto.clear = function clear() {
    this.pending = null;
    this.operations = [];
    this.debouncedFlush.cancel();
    return this;
  };

  _proto.isEmpty = function isEmpty() {
    return this.size() === 0;
  };

  _proto.size = function size() {
    return this.operations.length;
  };

  _createClass(PendingQueue, [{
    key: "shouldDebouncedFlush",
    get: function get() {
      // 需要周期性倾倒 pending queue 需满足以下条件之一：
      // 1. 如果驻留有 operation
      // 2. 如果驻留有堆 isFocused 的设置
      return this.operations.some(function (_ref2) {
        var operation = _ref2.operation,
            key = _ref2.key;
        return operation !== null || key === 'isFocused';
      });
    }
  }, {
    key: "type",
    get: function get() {
      var _this$pending2;

      return (_this$pending2 = this.pending) == null ? void 0 : _this$pending2.type;
    }
  }]);

  return PendingQueue;
}();

function setInjection(controller, node, data) {
  var injections = controller.value.injections;
  var curInjection = injections.find(function (inj) {
    return inj.key === node.key;
  }) || {};
  var injection = Injection.create({
    key: node.key,
    data: _extends({}, curInjection.data || {}, data)
  });
  controller.setInjections([].concat(injections.filter(function (inj) {
    return inj.key !== node.key;
  }), [injection]));
}
function deleteInjection(controller, node, keys) {
  var injections = controller.value.injections;
  var curInjection = injections.find(function (inj) {
    return inj.key === node.key;
  }) || {};
  var nextData = omit(curInjection.data, keys);
  var nextInjections = injections.filter(function (inj) {
    return inj.key !== node.key;
  });

  if (!isEmpty(nextData)) {
    var injection = Injection.create({
      key: node.key,
      data: nextData
    });
    nextInjections.push(injection);
  }

  controller.setInjections(nextInjections);
}

var UserDataManager = /*#__PURE__*/function () {
  function UserDataManager(controller) {
    var _this = this;

    this.update$ = new Subject();
    this.controller = void 0;
    this.localData = {};

    this.flush = function (ops) {
      _this.updateNodes(ops);

      _this.refreshData(ops);
    };

    this.mergeUserData = function (target) {
      var _this$controller = _this.controller,
          uid = _this$controller.uid,
          value = _this$controller.value;
      var document = value.document;
      var userData = document.data.userData;
      var targetData = target.data.userData;

      if (uid && targetData != null && targetData[uid]) {
        var uuids = Object.keys(targetData[uid]);

        if (uuids.length > 0) {
          var _extends2;

          var data = omitDeepBy(_extends({}, document.data, {
            userData: _extends({}, userData || {}, (_extends2 = {}, _extends2[uid] = _extends({}, (userData == null ? void 0 : userData[uid]) || {}, targetData[uid]), _extends2))
          }), isEmptyObj);

          if (data.userData !== document.data.userData) {
            return _this.controller.withOpContext("userdata/" + uid + "/" + uuids.join(','), function () {
              _this.controller.command(setNodeByKey, document.key, {
                data: data
              });
            });
          }
        }
      }

      return _this.controller;
    };

    this.controller = controller;
  }

  var _proto = UserDataManager.prototype;

  _proto.get = function get(node, key) {
    if (Element$1.isElement(node)) {
      var _node$data;

      var _uid = this.controller.uid;

      var _uuid = (_node$data = node.data) == null ? void 0 : _node$data.uuid;

      var nData = node.data[key];

      if (_uid && _uuid) {
        var _userData$_uid, _userData$_uid$_uuid, _this$localData, _this$localData$_uid, _this$localData$_uid$, _ref;

        var userData = this.controller.value.document.data.userData;
        var uData = userData == null ? void 0 : (_userData$_uid = userData[_uid]) == null ? void 0 : (_userData$_uid$_uuid = _userData$_uid[_uuid]) == null ? void 0 : _userData$_uid$_uuid[key];
        var lData = (_this$localData = this.localData) == null ? void 0 : (_this$localData$_uid = _this$localData[_uid]) == null ? void 0 : (_this$localData$_uid$ = _this$localData$_uid[_uuid]) == null ? void 0 : _this$localData$_uid$[key];
        return (_ref = lData != null ? lData : uData) != null ? _ref : nData;
      }

      return nData;
    }

    return undefined;
  };

  _proto.set = function set(node, properties) {
    var _this2 = this;

    if (Element$1.isElement(node)) {
      var _node$data2;

      var _this$controller2 = this.controller,
          _uid2 = _this$controller2.uid,
          value = _this$controller2.value;
      var document = value.document;
      var userData = document.data.userData;

      var _uuid2 = (_node$data2 = node.data) == null ? void 0 : _node$data2.uuid;

      if (_uid2 && _uuid2) {
        // 有 uid 和 uuid，设置用户数据
        var data = omitDeepBy(_extends({}, document.data, {
          userData: this.mergeProperties(userData, _uid2, _uuid2, properties)
        }), isEmptyObj);

        if (data.userData !== document.data.userData) {
          return this.controller.withOpContext("userdata/" + _uid2 + "/" + _uuid2, function () {
            _this2.controller.command(setNodeByKey, document.key, {
              data: data
            });
          });
        }
      } else {
        // 设置 node.data 数据
        var n = document.getNode(node == null ? void 0 : node.key);

        if (n && Element$1.isElement(n)) {
          var _data = _extends({}, n.data, properties);

          if (!isEqual(_data, n.data)) {
            return this.controller.withOpContext("userdata", function () {
              _this2.controller.command(setNodeByKey, n.key, {
                data: _data
              });
            });
          }
        }
      }
    }

    return this.controller;
  };

  _proto.setLocal = function setLocal(node, properties) {
    if (Element$1.isElement(node)) {
      var _node$data3;

      var _uid3 = this.controller.uid;

      var _uuid3 = (_node$data3 = node.data) == null ? void 0 : _node$data3.uuid;

      if (_uid3 && _uuid3) {
        this.localData = this.mergeProperties(this.localData, _uid3, _uuid3, properties);
        this.update$.next({
          uuid: _uuid3
        });
      } else {
        setInjection(this.controller, node, properties);
      }
    }

    return this.controller;
  };

  _proto["delete"] = function _delete(node, keys) {
    var _this3 = this;

    if (Element$1.isElement(node)) {
      var _node$data4;

      var _uuid4 = (_node$data4 = node.data) == null ? void 0 : _node$data4.uuid;

      var _this$controller3 = this.controller,
          _uid4 = _this$controller3.uid,
          value = _this$controller3.value;
      var document = value.document;
      var userData = document.data.userData;

      if (_uid4 && _uuid4) {
        var data = omitDeepBy(_extends({}, document.data, {
          userData: this.deleteProperties(userData, _uid4, _uuid4, keys)
        }), isEmptyObj);

        if (data.userData !== document.data.userData) {
          return this.controller.withOpContext("userdata/" + _uid4 + "/" + _uuid4, function () {
            _this3.controller.command(setNodeByKey, document.key, {
              data: data
            });
          });
        }
      } else {
        // 删除 node.data 数据
        var n = document.getNode(node == null ? void 0 : node.key);

        if (n && Element$1.isElement(n)) {
          var _data2 = omit(n.data, keys);

          if (!isEqual(_data2, n.data)) {
            return this.controller.withOpContext("userdata", function () {
              _this3.controller.command(setNodeByKey, n.key, {
                data: _data2
              });
            });
          }
        }
      }
    }

    return this.controller;
  };

  _proto.deleteLocal = function deleteLocal(node, keys) {
    if (Element$1.isElement(node)) {
      var _node$data5;

      var _uid5 = this.controller.uid;

      var _uuid5 = (_node$data5 = node.data) == null ? void 0 : _node$data5.uuid;

      if (_uid5 && _uuid5) {
        this.localData = this.deleteProperties(this.localData, _uid5, _uuid5, keys);
        this.update$.next({
          uuid: _uuid5
        });
      } else {
        deleteInjection(this.controller, node, keys);
      }
    }

    return this.controller;
  };

  _proto.refreshData = function refreshData(ops) {
    var _this4 = this;

    // 根据 OP 类型，刷新 document.data 上数据
    var value = this.controller.value;
    var document = value.document;
    var originData = document.data.userData;
    var uuids = [];
    var uids = Object.keys(originData || {});
    var userData = originData;
    ops.forEach(function (op) {
      // op 是删除节点，将 document.data 中对应数据也删除
      if (op.type === 'remove_node' && Element$1.isElement(op.node) && !/merge_node|split_node/.test(op.context || '')) {
        // 遍历节点及子节点
        var iterator = function iterator(node) {
          var _data3;

          var uuid = (_data3 = node.data) == null ? void 0 : _data3.uuid;

          if (Element$1.isElement(node) && uuid) {
            uids.forEach(function (uid) {
              userData = _this4.deleteData(userData, uid, uuid);
            });

            if (userData !== originData) {
              uuids.push(uuid);
            }
          }
        };

        iterator(op.node);
        op.node.forEachDescendant(iterator);
      }
    }); // 批量更新

    if (uuids.length) {
      var data = omitDeepBy(_extends({}, document.data, {
        userData: userData
      }), isEmptyObj);
      this.controller.withOpContext("userdata/*/" + uuids.join(','), function () {
        _this4.controller.command(setNodeByKey, document.key, {
          data: data
        });
      });
    }
  };

  _proto.updateNodes = function updateNodes(ops) {
    var _this5 = this;

    ops.forEach(function (op) {
      // update$.next 刷新节点视图
      var context = op.context;

      if (op.type === 'set_node') {
        var matched = context == null ? void 0 : context.match(/userdata\/(.*)\/(.*)/);

        if (matched) {
          // context 上携带此次修改用户数据的 uid 和块 uuid
          var _uid6 = matched[1];
          var uuids = matched[2].split(',');

          if (_uid6 === _this5.controller.uid || _uid6 === '*') {
            uuids.forEach(function (uuid) {
              return uuid && _this5.update$.next({
                uuid: uuid
              });
            });
          }
        }
      }
    });
  };

  _proto.mergeProperties = function mergeProperties(data, uid, uuid, properties) {
    var _data$uid, _extends3, _extends4;

    return _extends({}, data || {}, (_extends4 = {}, _extends4[uid] = _extends({}, (data == null ? void 0 : data[uid]) || {}, (_extends3 = {}, _extends3[uuid] = _extends({}, (data == null ? void 0 : (_data$uid = data[uid]) == null ? void 0 : _data$uid[uuid]) || {}, properties), _extends3)), _extends4));
  };

  _proto.deleteData = function deleteData(data, uid, uuid) {
    var _data$uid2;

    if ((data == null ? void 0 : (_data$uid2 = data[uid]) == null ? void 0 : _data$uid2[uuid]) !== undefined) {
      var _extends5;

      // 删除对应 uuid 下所有数据
      return _extends({}, data, (_extends5 = {}, _extends5[uid] = omit(data == null ? void 0 : data[uid], uuid), _extends5));
    }

    return data || {};
  };

  _proto.deleteProperties = function deleteProperties(data, uid, uuid, keys) {
    var _data$uid3;

    if (typeof (data == null ? void 0 : (_data$uid3 = data[uid]) == null ? void 0 : _data$uid3[uuid]) === 'object') {
      var _data$uid4, _extends6, _extends7;

      // 对应 block uuid 下有数据，去除相应 keys 属性
      return _extends({}, data, (_extends7 = {}, _extends7[uid] = _extends({}, data == null ? void 0 : data[uid], (_extends6 = {}, _extends6[uuid] = omit(data == null ? void 0 : (_data$uid4 = data[uid]) == null ? void 0 : _data$uid4[uuid], keys), _extends6)), _extends7));
    }

    return data || {};
  };

  return UserDataManager;
}();

var PerfType;

(function (PerfType) {
  PerfType["input"] = "input";
  PerfType["composing"] = "composing";
  PerfType["selection"] = "selection";
})(PerfType || (PerfType = {}));

/**
 * @packageDocumentation
 * @module Events
 */
function CangjiePerfEvent(detail) {
  return new CustomEvent('cangjiePerf', {
    detail: _extends({
      dropped: false
    }, detail)
  });
}

function isTextOp(operation) {
  return [OperationType.InsertText, OperationType.RemoveText, OperationType.AddMark, OperationType.RemoveMark, OperationType.SetMark].includes(operation.type);
}

function getHotAmongNodes(srcNodes, newDoc) {
  return srcNodes.map(function (srcNode) {
    if (!srcNode) {
      return null;
    } // 如果操作节点在新的内容无法找到，则不继续查找其热区


    var node = newDoc.getNode(typeof srcNode === 'string' ? srcNode : srcNode.key);

    if (!node) {
      return null;
    }

    return Block.isBlock(node) ? node : newDoc.getClosest(node.key, function (node) {
      return Block.isBlock(node);
    });
  }).filter(function (node) {
    return !!node;
  }).map(function (node) {
    return {
      node: node,
      path: newDoc.assertPath(node.key)
    };
  });
}

function getHotsAtRange(range, afterChangeDoc, ancestorPath) {
  if (ancestorPath === void 0) {
    ancestorPath = [];
  }

  var blocks = [];

  if (Path.isRoot(ancestorPath)) {
    blocks = afterChangeDoc.getRootBlocksAtRange(range);
  } else {
    var ancestor = afterChangeDoc.assertNodeByPath(ancestorPath);

    var _range$convertToTextP = range.convertToTextPoints(afterChangeDoc),
        start = _range$convertToTextP.start,
        end = _range$convertToTextP.end;

    var startBlock = ancestor.getFurthsest(start.key, Block.isBlock);

    if (!startBlock) {
      return [];
    }

    if (start.key === end.key) {
      return [{
        node: startBlock,
        path: afterChangeDoc.assertPath(startBlock.key)
      }];
    }

    var endBlock = ancestor.getFurthsest(end.key, Block.isBlock);

    if (!endBlock) {
      return [];
    }

    blocks = ancestor.nodes.slice(ancestor.nodes.indexOf(startBlock), ancestor.nodes.indexOf(endBlock) + 1);
  }

  return blocks.map(function (node) {
    return {
      node: node,
      path: afterChangeDoc.assertPath(node.key)
    };
  });
}

function getOpHots(op, controller) {
  var operation = op.operation,
      key = op.key,
      value = op.value,
      newValue = op.newValue;
  var beforeChangeDoc = value.document;
  var afterChangeDoc = newValue.document;
  var newDoc = controller.value.document;
  /* 增量变更热区 */

  if (operation) {
    // 文本类型的操作，热区为当前文本所在容器
    if (isTextOp(operation)) {
      var path = operation.path;
      var text = beforeChangeDoc.assertNodeByPath(path);
      var newText = newDoc.getNode(text.key);
      return getHotAmongNodes([newText], newDoc);
    } // 节点子孙的变更：插入/删除/分裂/合并，热区为变更所在的节点
    else if (operation.type === OperationType.InsertNode || operation.type === OperationType.RemoveNode || operation.type === OperationType.SplitNode || operation.type === OperationType.MergeNode) {
        var _ref = operation,
            _path = _ref.path;
        var parent = beforeChangeDoc.assertNodeByPath(Path.parent(_path));
        return getHotAmongNodes([parent], newDoc);
      } // 设置节点
      // 1. 若改变节点内容
      //   a. 若变更不影响分组，则热区为被设置的节点
      //   b. 若变更影响分组，则热区设置为上游节点
      // 2. 若改变节点类型，可能影响上游分组，热区为设置节点的 parent
      else if (operation.type === OperationType.SetNode) {
          var _ref2 = operation,
              _path2 = _ref2.path,
              properties = _ref2.properties,
              prevProperties = _ref2.prevProperties;

          if (properties.type !== prevProperties.type) {
            return getHotAmongNodes([beforeChangeDoc.assertNodeByPath(Path.parent(_path2))], newDoc);
          }

          return getHotAmongNodes([beforeChangeDoc.assertNodeByPath(_path2)], newDoc);
        } // 移动节点，热区为：
        // 1. 起始节点的 parent
        // 2. 结束节点的 parent
        else if (operation.type === OperationType.MoveNode) {
            var _ref3 = operation,
                _path3 = _ref3.path,
                newPath = _ref3.newPath;
            return getHotAmongNodes([beforeChangeDoc.assertNodeByPath(Path.parent(_path3)), beforeChangeDoc.assertNodeByPath(Path.parent(newPath))], newDoc);
          } // 设置选区，热区为跨越选区的所有最高层 block
          else if (operation.type === OperationType.SetSelection) {
              var selection = operation.selection,
                  prevSelection = operation.prevSelection;
              return getHotsAtRange(prevSelection, afterChangeDoc).concat(getHotsAtRange(selection, afterChangeDoc));
            }
  } else {
    /* 全量变更热区 */
    // 输入法的热区为输入法所在文本的容器
    if (key === 'composing') {
      return getHotAmongNodes([value.startText], newDoc);
    } // focus 状态不影响热区


    if (key === 'isFocused') {
      return 'ignore';
    } // injections 变更，找到变更前后的受影响的节点所在的热区


    if (key === 'injections') {
      return getHotAmongNodes([].concat(difference(newValue.injections, value.injections), difference(value.injections, newValue.injections)).map(function (inj) {
        return inj.key;
      }), newDoc);
    } // decorations 变更，找到变更前后受影响的区间所在的热区


    if (key === 'decorations') {
      return [].concat(difference(newValue.decorations, value.decorations), difference(value.decorations, newValue.decorations)).map(function (decoration) {
        return Selection.create({
          anchor: decoration.start,
          focus: decoration.end
        });
      }).reduce(function (hots, range) {
        hots.push.apply(hots, getHotsAtRange(range, afterChangeDoc));
        return hots;
      }, []);
    }
  }

  return [];
}
/**
 * 如果在 hots 找到祖先或者自己，则不再添加
 * @param path
 * @returns
 */


function isExistedHot(path, searchTable) {
  var ancestorsAndSelf = Path.ancestors(path).slice(1);
  ancestorsAndSelf.push(path);
  return ancestorsAndSelf.some(function (p) {
    return searchTable.has(p.join(','));
  });
}
/**
 * 获得变更热区
 * @param srcOps
 * @param controller
 * @returns
 */


function getHots(srcOps, controller) {
  try {
    var ops = srcOps.filter(function (_ref4) {
      var operation = _ref4.operation;
      return !operation || operation.type !== 'set_selection';
    }); // 所有热区

    var all = []; // 去重热区，仅保留最高级祖先

    var uniq = [];
    /**
     * 用于 hots 去重的查找表
     * ```
     * {
     *   '0,1,0': true,
     *   '1,0': true,
     * }
     * ```
     */

    var searchTable = new Set();

    for (var i = 0; i < ops.length; i++) {
      var op = ops[i];
      var hots = getOpHots(op, controller);

      if (hots === 'ignore') {
        continue;
      } // 如果任意 op 未找到热区，即变更影响了全局，提前返回


      if (!hots.length) {
        return [];
      }

      all.push.apply(all, hots);
    }

    var _srcOps$0$value = srcOps[0].value,
        prevSelection = _srcOps$0$value.selection,
        prevDocument = _srcOps$0$value.document;
    var _controller$value = controller.value,
        selection = _controller$value.selection,
        document = _controller$value.document; // 选区发生变更时，计算热区

    if (prevSelection !== selection) {
      // 获得变更前选区所在的节点
      var prevSelectionIn = prevSelection.getClosestNode(prevDocument);
      var prevSelectionInPath = prevDocument.assertPath(prevSelectionIn.key);
      var selectionIn = selection.getClosestNode(document);
      var selectionInPath = document.assertPath(selectionIn.key);
      var ancestor = Path.common(prevSelectionInPath, selectionInPath); // 如果在同节点移动，热区仅放入新选区所在的节点

      if (Path.isEqual(prevSelectionInPath, selectionInPath)) {
        all.push({
          node: selectionIn,
          path: selectionInPath
        });
      } // 如果是平层移动，放入老/新选区所在的节点
      else if (Path.isSibling(prevSelectionInPath, selectionInPath)) {
          all.push({
            node: prevSelectionIn,
            path: prevSelectionInPath
          });
          all.push({
            node: selectionIn,
            path: selectionInPath
          });
        } // 否则放入新老选区各自所在的，直到公共祖先的节点，保证节点子树每个节点的选中态都符合预期
        else {
            all.push.apply(all, getHotsAtRange(prevSelection, document, ancestor));
            all.push.apply(all, getHotsAtRange(selection, document, ancestor));
          }
    }

    all.sort(function (a, b) {
      return a.path.length - b.path.length;
    });
    all.forEach(function (hot) {
      if (!isExistedHot(hot.path, searchTable)) {
        uniq.push(hot);
        searchTable.add(hot.path.join(','));
      }
    });
    return uniq;
  } catch (_e) {
    // 热区计算失败时，清空热区
    return [];
  }
}
var FIELD_SHOULD_NOT_BREAK_PENDING = ['decorations', 'injections', 'remoteSelections', 'selection'];
/**
 * 是否是文本输入
 * @param context
 * @returns
 */

function isInputing(context) {
  var operations = context.operations,
      value = context.value;

  if (value.selection.isExpanded) {
    return false;
  }

  var rest = operations.filter(function (operation) {
    return operation.operation || !FIELD_SHOULD_NOT_BREAK_PENDING.includes(operation.key);
  });

  if (!rest.length) {
    return false;
  } // PERF: for-loop


  var opsLen = rest.length;
  var path = null;

  for (var i = 0; i < opsLen; i++) {
    var operation = rest[i].operation;

    if (!operation) {
      return false;
    }

    if (operation.type === 'set_selection') {
      continue;
    }

    var op = operation;

    if (!path) {
      path = op.path;
    } // 在同一个文本连续输入/删除时，可以 pending


    if (op.type !== 'insert_text' && op.type !== 'remove_text' || !Path.isEqual(path, op.path)) {
      return false;
    }
  }

  return true;
}
/**
 * 是否是设置选区
 * @param context
 * @returns
 */

function isSelecting(context) {
  return context.operations.every(function (_ref5, index) {
    var operation = _ref5.operation,
        key = _ref5.key;

    if (index === 0 && !operation) {
      return key === 'isFocused' && context.value.isFocused;
    }

    return operation && operation.type === 'set_selection';
  });
}
/**
 * 是否在输入法
 * @param context
 * @returns
 */

function isComposing(context) {
  var composing = context.value.composing;
  return !!composing.length;
}
/**
 * 对于需要以动画速率运行的变更，周期性倾倒：
 * 1. 输入/删除文本
 * 2. 拖动选区
 *
 * ```plaintext
 *    +-------+       +-------+      +-------+     +-------+     +-------+
 *    |   h   |       |   e   |      |   l   |     |   l   |     |   o   |
 *    +-------+       +-------+      +-------+     +-------+     +-------+
 *        |               |              |             |             |
 *        v               v              v             v             v
 *    .-------.       .-------.      .-------.     .-------.     .-------.
 *   (  flush  )     (  flush  )    (  flush  )   (  flush  )   (  flush  )
 *    `-------'       `-------'      `-------'     `-------'     `-------'
 *
 *                                        |
 *                                        |
 *                                 debounced flush
 *                                        |
 *                                        v
 * + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
 *    +-------+       +-------+      +-------+     +-------+     +-------+
 * |  |   h   |       |   e   |      |   l   |     |   l   |     |   o   | |
 *    +-------+       +-------+      +-------+     +-------+     +-------+
 * + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
 *                                                                   |
 *                                                                   v
 *                                                               .-------.
 *                                                              (  flush  )
 *                                                               `-------'
 * ```
 * @param context
 * @returns
 */

var shouldDebounceFlush = cond([[isSelecting, function () {
  return PendingType.selection;
}], [isInputing, function () {
  return PendingType.input;
}], [stubTrue, function () {
  return null;
}]]);
/**
 * 对于输入法等类型的临时变更，不进行 flush
 *
 * ```plaintext
 *  +-------+      +-------+     +-------+
 *  |   n   |      |   i   |     |   你   |
 *  +-------+      +-------+     +-------+
 *      |              |             |
 *      v              v             v
 *  .-------.      .-------.     .-------.
 * (  flush  )    (  flush  )   (  flush  )
 *  `-------'      `-------'     `-------'
 *
 *                      |
 *                      |
 *               suppress flush
 *                      |
 *                      v
 *                  +-------+
 *                  |   你   |
 *                  +-------+
 *                      |
 *                      v
 *                  .-------.
 *                 (  flush  )
 *                  `-------'
 * ```
 * @param context
 * @returns
 */

var shouldSuppressFlush = cond([[isComposing, function () {
  return PendingType.input;
}], [stubTrue, function () {
  return null;
}]]);

var EVENTS_SET = new Set(EVENTS);
function isEventHandler(name) {
  return EVENTS_SET.has(name);
}

var DEFAULT_BUFFER_RANGE = 500;
var BLOCK_DEFAULT_MIN_HEIGHT = 25;
var DEFAULT_SCROLL_THROTTLE_INTERVAL = 50;
var DEFAULT_FIRST_PAINT_BLOCK_SIZE = 10;

/**
 * 循环查询元素
 * @param selector query 函数
 * @param remain 剩余时间
 */
function waitForElementByAnimationFrame(selector, remain) {
  if (remain === void 0) {
    remain = 1000;
  }

  var start = Date.now();
  return new Promise(function (resolve, reject) {
    if (remain < 0) {
      if (typeof selector === 'function') {
        return reject("waitForElementByAnimationFrame: element wait timeout");
      }

      return reject("waitForElementByAnimationFrame\uFF1A " + selector + " wait timeout");
    }

    var element = typeof selector === 'function' ? selector() : window.document.querySelector(selector);

    if (element) {
      return resolve(element);
    } else {
      window.requestAnimationFrame(function () {
        var cost = Date.now() - start;
        var nextRemain = remain - cost;
        waitForElementByAnimationFrame(selector, nextRemain).then(resolve)["catch"](reject);
      });
    }
  });
}
function scrollContainerIsTop(scrollContainer) {
  return scrollContainer === document.body || scrollContainer === document.documentElement || scrollContainer === window;
}
function checkArrayAHasElementNotIncludedInArrayB(arrayA, arrayB) {
  return arrayA.some(function (arrayAElement) {
    return !arrayB.includes(arrayAElement);
  });
}

function formatMarginFromStyle(margin) {
  var result = parseFloat(margin);

  if (isNaN(result)) {
    return 0;
  }

  return result;
}

function measureBlockInfo(element) {
  // offsetHeight 一定是正数, boundingClientRect 可能是小数，和 mutationObserver 的对应
  var boundingClientRect = element.getBoundingClientRect();
  var computedStyle = window.getComputedStyle(element); // TODO: 专门为节点搞一个隐藏态，隐藏前的高度也记录，而非直接变 0

  var isVisible = computedStyle.display !== 'none';
  return {
    height: isVisible ? boundingClientRect.height : 0,
    marginTop: isVisible ? formatMarginFromStyle(computedStyle == null ? void 0 : computedStyle.marginTop) : 0,
    marginBottom: isVisible ? formatMarginFromStyle(computedStyle == null ? void 0 : computedStyle.marginBottom) : 0
  };
}
function calculateViewPort(scrollElement, scrollContainer, bufferRange, editorContainerToScrollContainerDistance, _viewPortStartY) {
  var scrollTop = scrollElement.scrollTop;

  if (scrollContainer === document.documentElement && scrollTop === 0 && document.body.scrollTop > 0) {
    scrollTop = document.body.scrollTop;
  }

  var viewPortStartY = typeof _viewPortStartY === 'number' ? _viewPortStartY : scrollTop - editorContainerToScrollContainerDistance;
  var viewPortEndY = viewPortStartY + (scrollContainerIsTop(scrollContainer) ? window.innerHeight : scrollContainer.offsetHeight);
  var bufferStartY = Math.max(0, viewPortStartY - bufferRange);
  var bufferEndY = viewPortEndY + bufferRange;
  return {
    viewPortStartY: viewPortStartY,
    viewPortEndY: viewPortEndY,
    bufferStartY: bufferStartY,
    bufferEndY: bufferEndY
  };
}
/**
 * 计算编辑器容器到最近的滚动容器的距离
 * 编辑器容器是各种计算的原点，而视口是基于滚动容器
 * 在滚动容器高度发生变化时需要重算，典型场景是 插入封面
 * 检测这个变化非常难，目前想到两种方案，一是开发者手动触发，二是 scrollContainer 下包一层大容器，监听这个容器高度的变化
 */

function calculateEditorContainerToScrollContainerDistance(editorContainer, scrollContainer, scrollElement, scrollContainerIsBody) {
  var editorContainerRect = editorContainer.getBoundingClientRect();
  var scrollContainerRect = scrollElement.getBoundingClientRect();
  var editorContainerStyle = window.getComputedStyle(editorContainer);
  var editorContainerToScrollContainerDistance = scrollContainerIsBody ? editorContainerRect.top - scrollContainerRect.top : editorContainerRect.top - scrollContainerRect.top + scrollElement.scrollTop;
  return editorContainerToScrollContainerDistance + formatMarginFromStyle(editorContainerStyle.paddingTop) + formatMarginFromStyle(editorContainerStyle.borderTopWidth);
}
function calculateExpectedLayoutInfo(bufferStartY, bufferEndY, viewStartY, view, nodeManager) {
  var nodeSize = view.nodes.length;
  var accHeight = 0;
  var lastMarginBottom = 0;
  var expectedBufferStartBlockFound = false;
  var expectedViewStartBlockFound = false;
  var expectedBufferEndBlockFound = false;
  var expectedBufferStartBlockOffset = 0;
  var expectedViewStartBlockOffset = 0;
  var expectedBufferEndBlockOffset = nodeSize - 1;
  var expectedBufferStartBlockY = 0;
  var expectedViewStartBlockY = 0;
  var expectedBufferEndBlockY = 0;

  for (var i = 0; i < nodeSize; i++) {
    var block = view.nodes[i];
    var cachedBlockProps = nodeManager.getCachedBlockPropsByKey(block.key);

    var _ref = cachedBlockProps || {},
        inputHeight = _ref.height,
        inputMarginTop = _ref.marginTop,
        inputMarginBottom = _ref.marginBottom;

    var marginTop = typeof inputMarginTop === 'number' ? inputMarginTop > lastMarginBottom ? inputMarginTop - lastMarginBottom : 0 : 0;
    var height = typeof inputHeight === 'number' ? inputHeight : BLOCK_DEFAULT_MIN_HEIGHT;
    var marginBottom = typeof inputMarginBottom === 'number' ? inputMarginBottom : 0;
    lastMarginBottom = marginBottom;
    var lastAccHeight = accHeight;
    accHeight += marginTop + height + marginBottom;

    if (!expectedBufferStartBlockFound && (lastAccHeight < bufferStartY || i === 0) && accHeight >= bufferStartY) {
      expectedBufferStartBlockFound = true;
      expectedBufferStartBlockOffset = i;
      expectedBufferStartBlockY = lastAccHeight;
    }

    if (!expectedViewStartBlockFound && (lastAccHeight < viewStartY || i === 0) && accHeight >= viewStartY) {
      expectedViewStartBlockFound = true;
      expectedViewStartBlockOffset = i;
      expectedViewStartBlockY = lastAccHeight;
    }

    if (!expectedBufferEndBlockFound && lastAccHeight < bufferEndY && accHeight >= bufferEndY) {
      expectedBufferEndBlockFound = true;
      expectedBufferEndBlockOffset = i;
      expectedBufferEndBlockY = accHeight;
    }
  }

  if (!expectedBufferEndBlockFound) {
    expectedBufferEndBlockY = accHeight;
    expectedBufferEndBlockOffset = nodeSize;
  }

  if (!expectedViewStartBlockFound) {
    expectedViewStartBlockOffset = nodeSize - 1;
  } // 极端情况，例如划到评论框，远远超出视口范围


  if (!expectedBufferEndBlockFound && !expectedBufferStartBlockFound) {
    if (bufferEndY < 0) {
      expectedBufferEndBlockOffset = -1;
      expectedBufferStartBlockOffset = -1;
      expectedBufferStartBlockY = 0;
      expectedBufferEndBlockY = 0;
    } else {
      expectedBufferEndBlockOffset = nodeSize;
      expectedBufferStartBlockOffset = nodeSize;
      expectedBufferStartBlockY = accHeight;
      expectedBufferEndBlockY = accHeight;
    }
  }

  return {
    expectedBufferStartBlockOffset: expectedBufferStartBlockOffset,
    expectedViewStartBlockOffset: expectedViewStartBlockOffset,
    expectedBufferEndBlockOffset: expectedBufferEndBlockOffset,
    expectedBufferStartBlockY: expectedBufferStartBlockY,
    expectedViewStartBlockY: expectedViewStartBlockY,
    expectedBufferEndBlockY: expectedBufferEndBlockY,
    accHeight: accHeight
  };
}
function calculateBlockStartYByBlockIndex(blockIndex, view, nodeManager, includeLastMarginBottom) {
  if (includeLastMarginBottom === void 0) {
    includeLastMarginBottom = false;
  }

  var accHeight = 0;
  var lastMarginBottom = 0;

  for (var i = 0; i < blockIndex; i++) {
    var block = view.nodes[i];
    var cachedBlockProps = nodeManager.getCachedBlockPropsByKey(block.key);

    var _ref2 = cachedBlockProps || {},
        inputHeight = _ref2.height,
        inputMarginTop = _ref2.marginTop,
        inputMarginBottom = _ref2.marginBottom;

    var marginTop = typeof inputMarginTop === 'number' ? inputMarginTop > lastMarginBottom ? inputMarginTop - lastMarginBottom : 0 : 0;
    var height = typeof inputHeight === 'number' ? inputHeight : BLOCK_DEFAULT_MIN_HEIGHT;
    var marginBottom = typeof inputMarginBottom === 'number' ? inputMarginBottom : 0;
    lastMarginBottom = marginBottom;
    accHeight += marginTop + height + (includeLastMarginBottom || i < blockIndex - 1 ? marginBottom : 0);
  }

  return accHeight;
}
var fastDiffOnValueChange = function fastDiffOnValueChange(prevView, currView, startBlockKey, startBlockOffset, endBlockOffset) {
  if (prevView === currView) {
    return {
      type: 'equal'
    };
  }

  var oldStartKeyNewPath = currView.getPath(startBlockKey);

  if (!(oldStartKeyNewPath && oldStartKeyNewPath.length === 1)) {
    return {
      type: 'changed'
    };
  }

  var startKeyOffsetChange = oldStartKeyNewPath[0] - startBlockOffset;

  for (var i = startBlockOffset + 1; i <= endBlockOffset; i++) {
    var prevBlock = prevView.nodes[i];
    var currBlock = currView.nodes[i + startKeyOffsetChange];

    if ((prevBlock == null ? void 0 : prevBlock.key) !== (currBlock == null ? void 0 : currBlock.key)) {
      return {
        type: 'changed'
      };
    }
  }

  if (startKeyOffsetChange === 0) {
    if (endBlockOffset >= prevView.nodes.length - 1 && currView.nodes[endBlockOffset + 1]) {
      return {
        type: 'changed'
      };
    }

    return {
      type: 'equal'
    };
  } // 用户视口在顶端，且在文章之前插入节点的情况


  if (startBlockOffset === 0 && startKeyOffsetChange > 0) {
    return {
      type: 'changed'
    };
  }

  return {
    type: 'translation',
    offset: startKeyOffsetChange
  };
};
function calculateBlockKeysNeedToMeasure(view, _prevView, layoutInfoResult, prevLayoutInfoResult) {
  var expectedBufferStartBlockOffset = layoutInfoResult.expectedBufferStartBlockOffset,
      expectedBufferEndBlockOffset = layoutInfoResult.expectedBufferEndBlockOffset;
  var prevView = _prevView || view;

  if (!prevLayoutInfoResult) {
    return view.nodes.map(function (node) {
      return node.key;
    }).slice(expectedBufferStartBlockOffset, expectedBufferEndBlockOffset + 1);
  }

  var prevExpectedBufferStartBlockOffset = prevLayoutInfoResult.expectedBufferStartBlockOffset,
      prevExpectedBufferEndBlockOffset = prevLayoutInfoResult.expectedBufferEndBlockOffset; // 当内容没有变化时，使用更快的算法

  if (prevView === view) {
    if (expectedBufferStartBlockOffset < prevExpectedBufferStartBlockOffset) {
      var endIndex = Math.min(expectedBufferEndBlockOffset + 1, prevExpectedBufferStartBlockOffset);
      return view.nodes.map(function (node) {
        return node.key;
      }).slice(expectedBufferStartBlockOffset, endIndex);
    } else if (expectedBufferEndBlockOffset > prevExpectedBufferEndBlockOffset) {
      var startIndex = Math.max(expectedBufferStartBlockOffset, prevExpectedBufferEndBlockOffset + 1);
      return view.nodes.map(function (node) {
        return node.key;
      }).slice(startIndex, expectedBufferEndBlockOffset + 1);
    }

    return [];
  } else {
    var prevVisibleKeys = prevView.nodes.slice(prevExpectedBufferStartBlockOffset, prevExpectedBufferEndBlockOffset + 1).map(function (node) {
      return node.key;
    });
    var currentVisibleKeys = view.nodes.slice(expectedBufferStartBlockOffset, expectedBufferEndBlockOffset + 1).map(function (node) {
      return node.key;
    });
    var newBlockKeys = [];
    currentVisibleKeys.forEach(function (key) {
      if (!prevVisibleKeys.includes(key)) {
        newBlockKeys.push(key);
      }
    });
    return newBlockKeys;
  }
}

var NodeManager = /*#__PURE__*/function () {
  function NodeManager(options) {
    this.controller = void 0;
    this.blockCacheByKey = new Map();
    this.blockKeyQueue = [];
    var controller = options.controller;
    this.controller = controller;
  }

  var _proto = NodeManager.prototype;

  _proto.getCachedBlockPropsByKey = function getCachedBlockPropsByKey(key) {
    return this.blockCacheByKey.get(key);
  };

  _proto.gc = function gc() {
    var _this = this;

    var view = this.controller.view;
    var viewTopBlockLength = view.nodes.length;

    if (this.blockKeyQueue.length > viewTopBlockLength) {
      var gcBlockKeyQueue = this.blockKeyQueue.splice(0, this.blockKeyQueue.length - viewTopBlockLength);
      gcBlockKeyQueue.forEach(function (key) {
        _this.blockCacheByKey["delete"](key);
      });
    }
  };

  _proto.setCachedBlockPropsByKey = function setCachedBlockPropsByKey(key, blockInfo) {
    var prevBlockInfo = this.blockCacheByKey.get(key);
    this.blockCacheByKey.set(key, _extends({}, prevBlockInfo, blockInfo));
    var index = this.blockKeyQueue.indexOf(key);

    if (index !== -1) {
      this.blockKeyQueue.splice(index, 1);
    }

    this.blockKeyQueue.push(key);
    this.gc();
    return;
  };

  _proto.loadMeasureResult = function loadMeasureResult(measureResults) {
    var document = this.controller.view;

    for (var key in measureResults) {
      var _block$data;

      var prevBlockInfo = this.blockCacheByKey.get(key) || {
        key: key,
        persistStateNode: []
      };
      var measureResult = measureResults[key];
      var block = document.getNode(key);

      var blockInfo = _extends({}, prevBlockInfo, measureResult, {
        key: key,
        uuid: block == null ? void 0 : (_block$data = block.data) == null ? void 0 : _block$data.uuid
      });

      this.setCachedBlockPropsByKey(key, blockInfo);
    }
  };

  _proto.getVirtualizePersistState = function getVirtualizePersistState(key) {
    var blockCache = this.blockCacheByKey.get(key);

    if (!(blockCache != null && blockCache.persistStateNode)) {
      return [];
    }

    return blockCache.persistStateNode;
  };

  _proto.updateVirtualizePersistState = function updateVirtualizePersistState(key, topBlockKey, shouldPersistState) {
    var _blockCache$persistSt;

    var blockCache = this.getCachedBlockPropsByKey(topBlockKey);
    var persistStateNode = (blockCache == null ? void 0 : (_blockCache$persistSt = blockCache.persistStateNode) == null ? void 0 : _blockCache$persistSt.slice()) || [];
    var keyIndex = persistStateNode.indexOf(key);

    if (shouldPersistState && keyIndex === -1) {
      persistStateNode.push(key);
    }

    if (!shouldPersistState && keyIndex >= 0) {
      persistStateNode.splice(keyIndex, 1);
    }

    this.setCachedBlockPropsByKey(topBlockKey, _extends({}, blockCache, {
      key: topBlockKey,
      persistStateNode: persistStateNode
    }));
  };

  return NodeManager;
}();

var OutputManager = /*#__PURE__*/function () {
  // 暂时以 offset 为标准
  function OutputManager(options) {
    this.controller = void 0;
    this.nodeManager = void 0;
    this.firstPaintBlockSize = void 0;
    this.startBlockOffset = void 0;
    this.endBlockOffset = void 0;
    this.startBlockKey = void 0;
    this.endBlockKey = void 0;
    this.startViewBlockOffset = 0;
    this.beforePlaceholderHeight = 0;
    this.afterPlaceholderHeight = 0;
    var nodeManager = options.nodeManager,
        controller = options.controller,
        firstPaintBlockSize = options.firstPaintBlockSize;
    this.controller = controller;
    this.nodeManager = nodeManager;
    this.firstPaintBlockSize = typeof firstPaintBlockSize === 'number' ? firstPaintBlockSize : DEFAULT_FIRST_PAINT_BLOCK_SIZE;
    this.setStartEndInfoByOffset(0, this.firstPaintBlockSize - 1);
    this.setPlaceholderHeight();
  }

  var _proto = OutputManager.prototype;

  _proto.precheckOutputByLayoutInfo = function precheckOutputByLayoutInfo(layoutInfoResult) {
    var expectedBufferStartBlockOffset = layoutInfoResult.expectedBufferStartBlockOffset,
        expectedBufferEndBlockOffset = layoutInfoResult.expectedBufferEndBlockOffset,
        expectedBufferStartBlockY = layoutInfoResult.expectedBufferStartBlockY,
        expectedBufferEndBlockY = layoutInfoResult.expectedBufferEndBlockY,
        accHeight = layoutInfoResult.accHeight;

    var _this$calculatePlaceh = this.calculatePlaceholderHeight(expectedBufferStartBlockY, expectedBufferEndBlockY, accHeight),
        beforePlaceholderHeight = _this$calculatePlaceh.beforePlaceholderHeight,
        afterPlaceholderHeight = _this$calculatePlaceh.afterPlaceholderHeight;

    var visibles = this.calculateVisibles(expectedBufferStartBlockOffset, expectedBufferEndBlockOffset);
    return {
      beforePlaceholderHeight: beforePlaceholderHeight,
      afterPlaceholderHeight: afterPlaceholderHeight,
      visibles: visibles
    };
  };

  _proto.loadCalculateLayoutInfo = function loadCalculateLayoutInfo(layoutInfoResult) {
    var expectedBufferStartBlockOffset = layoutInfoResult.expectedBufferStartBlockOffset,
        expectedBufferEndBlockOffset = layoutInfoResult.expectedBufferEndBlockOffset,
        expectedBufferStartBlockY = layoutInfoResult.expectedBufferStartBlockY,
        expectedBufferEndBlockY = layoutInfoResult.expectedBufferEndBlockY,
        expectedViewStartBlockOffset = layoutInfoResult.expectedViewStartBlockOffset,
        accHeight = layoutInfoResult.accHeight;
    this.setStartEndInfoByOffset(expectedBufferStartBlockOffset, expectedBufferEndBlockOffset);
    this.setPlaceholderHeight(expectedBufferStartBlockY, expectedBufferEndBlockY, accHeight);
    this.startViewBlockOffset = expectedViewStartBlockOffset;
  };

  _proto.calculatePlaceholderHeight = function calculatePlaceholderHeight(expectedBlockStartY, expectedBlockEndY, accHeight) {
    if (typeof expectedBlockStartY === 'number' && typeof expectedBlockEndY === 'number' && typeof accHeight === 'number') {
      return {
        beforePlaceholderHeight: expectedBlockStartY,
        afterPlaceholderHeight: accHeight - expectedBlockEndY
      };
    }

    return {
      beforePlaceholderHeight: 0,
      afterPlaceholderHeight: Math.max(0, this.controller.view.nodes.length - this.firstPaintBlockSize) * BLOCK_DEFAULT_MIN_HEIGHT
    };
  };

  _proto.setPlaceholderHeight = function setPlaceholderHeight(expectedBlockStartY, expectedBlockEndY, accHeight) {
    if (typeof expectedBlockStartY === 'number' && typeof expectedBlockEndY === 'number' && typeof accHeight === 'number') {
      this.beforePlaceholderHeight = expectedBlockStartY;
      this.afterPlaceholderHeight = accHeight - expectedBlockEndY;
      return;
    }

    this.afterPlaceholderHeight = Math.max(0, this.controller.view.nodes.length - this.firstPaintBlockSize) * BLOCK_DEFAULT_MIN_HEIGHT;
    return;
  };

  _proto.setStartEndInfoByOffset = function setStartEndInfoByOffset(startOffset, endOffset) {
    var view = this.controller.view;
    this.startBlockOffset = startOffset;
    this.endBlockOffset = endOffset;
    var startBlock = view.getNodeByPath([startOffset]);
    var endBlock = view.getNodeByPath([endOffset]);
    this.startBlockKey = startBlock == null ? void 0 : startBlock.key;
    this.endBlockKey = endBlock == null ? void 0 : endBlock.key;
  };

  _proto.calculateVisibles = function calculateVisibles(startBlockOffset, endBlockOffset) {
    var _this = this;

    var view = this.controller.view;
    var visibleBlockKeys = [];
    var blockFinalVisibleStates = view.nodes.map(function (node, index) {
      if (index < startBlockOffset || index > endBlockOffset) {
        var cachedBlockProps = _this.nodeManager.getCachedBlockPropsByKey(node.key);

        if (cachedBlockProps != null && cachedBlockProps.persistStateNode && cachedBlockProps.persistStateNode.length > 0) {
          return 'hide';
        }

        return 'destroy';
      }

      visibleBlockKeys.push(node.key);
      return 'show';
    });
    return {
      blockFinalVisibleStates: blockFinalVisibleStates,
      visibleBlockKeys: visibleBlockKeys
    };
  } // todo: cache
  ;

  _createClass(OutputManager, [{
    key: "visibles",
    get: function get() {
      var result = this.calculateVisibles(this.startBlockOffset, this.endBlockOffset);
      return result;
    }
  }]);

  return OutputManager;
}();

/**
 * @packageDocumentation
 * @module domUtils
 */

/**
 * 查找 node 节点下 first/last 的 Text 节点
 * @param node 查找的节点
 * @param order 遍历的顺序 pre-前序遍历 post-后序遍历
 */
function findTextNode(node, order) {
  if (order === void 0) {
    order = 'pre';
  }

  var childNodes = order === 'post' ? Array.from(node.childNodes).reverse() : node.childNodes;

  for (var i = 0; i < childNodes.length; i += 1) {
    var child = childNodes[i];

    if (child instanceof Text) {
      return child;
    }

    var text = findTextNode(child, order);

    if (text instanceof Text) {
      return text;
    }
  }

  return null;
}
/**
 * 获取 DOM 的真实选区
 * @param root
 * @description 由于编辑器层没有浏览器的选区，所以使用 mark 的方式自行构造选区
 */


function findCurrentDOMRange(root) {
  if (root === void 0) {
    root = window.document;
  }

  var nodes = root.querySelectorAll('[data-cangjie-range');

  if (nodes.length <= 0) {
    return null;
  }

  var range = document.createRange();
  var start = nodes[0];
  var end = nodes[nodes.length - 1];
  var anchor = findTextNode(start, 'pre');
  var focus = findTextNode(end, 'post');

  if (!anchor || !focus) {
    return null;
  }

  try {
    range.setStart(anchor, 0);
    range.setEnd(focus, Math.max(focus.length, 0));
  } catch (error) {
    return null;
  }

  return range;
}

/**
 * @packageDocumentation
 * @module domUtils
 */
/**
 * 根据用户的 click 或 touch 事件获取仓颉的 Selection
 */

function findRangeByEvent(event, controller) {
  var target = event.target,
      x = event.x,
      y = event.y;
  return caretRangeFromTargetAndCoord(target, x, y, controller);
}

/**
 * 遍历节点内的每一个 cangjie content 节点，获取 getClientRects 列表
 */
function getDOMRects(node) {
  var rects = [];
  var leafContents = node.querySelectorAll("[" + Selector.leaf + "]");
  var voidContents = node.querySelectorAll("[" + Selector["void"] + "]"); // TODO：代码块特殊处理，后期需要移除

  var specialCodes = node.querySelectorAll('.CodeMirror');

  var addRect = function addRect(rect) {
    if (rect) {
      var left = rect.left,
          top = rect.top,
          width = rect.width,
          height = rect.height;
      rects.push({
        left: left,
        top: top,
        width: width,
        height: height
      });
    }
  };

  Array.from(leafContents).forEach(function (leaf) {
    if (!leaf.closest("[" + Selector["void"] + "]")) {
      Array.from(leaf.getClientRects()).forEach(addRect);
    }
  });
  Array.from(voidContents).forEach(function (voidNode) {
    var rect = voidNode.getBoundingClientRect();
    addRect(rect);
  });
  Array.from(specialCodes).forEach(function (codeNode) {
    var _codeNode$closest;

    var rect = (_codeNode$closest = codeNode.closest("[" + Selector.leafBlock + "]")) == null ? void 0 : _codeNode$closest.getBoundingClientRect();
    addRect(rect);
  });
  return rects;
}
/**
 * 获取分行。`rows` 构建了分行的结构，每一个 row 表示一行
 */


function splitRows(blockDOMNode, extendToFill) {
  if (extendToFill === void 0) {
    extendToFill = false;
  }

  var parentRect = blockDOMNode.getBoundingClientRect();
  var linesRects = getDOMRects(blockDOMNode);

  var newRow = function newRow(rect) {
    var top = rect.top,
        height = rect.height;
    return {
      top: top,
      height: height
    };
  };

  var rows = [];

  var sortIntoRows = function sortIntoRows(rect) {
    if (!rows.length) {
      rows.push(newRow(rect));
      return;
    } // 尝试找到插入行（如果 rect 的 top 比某一行的 bottom 小，就算插入行）


    var insertRow = rows.find(function (row) {
      return rect.top < row.top + row.height;
    }); // 没有插入行的话，就创建一个

    if (!insertRow) {
      rows.push(newRow(rect));
      return;
    } // rect 的 bottom 比插入行的 top 小，则 rect 可以重新创建一行了


    if (rect.top + rect.height <= insertRow.top) {
      rows.splice(rows.indexOf(insertRow), 0, newRow(rect));
      return;
    } // rect 属于某个 row，更新一下 row


    if (rect.top < insertRow.top) {
      insertRow.top = rect.top;
    }

    if (rect.top + rect.height > insertRow.top + insertRow.height) {
      insertRow.height = rect.top + rect.height - insertRow.top;
    }
  }; // 对 block DOM 的所有 rects 进行分行


  linesRects.forEach(sortIntoRows);

  if (!rows.length) {
    rows.push(newRow(parentRect));
  }

  if (!extendToFill) {
    return rows;
  }

  var first = rows[0];
  var last = rows[rows.length - 1];
  first.height += first.top - parentRect.top;
  first.top = parentRect.top;
  last.height = parentRect.bottom - last.top; // extendToFill：扩展行高，填充行之间的空隙

  for (var i = 1; i < rows.length; i++) {
    var prev = rows[i - 1];
    var now = rows[i];
    var margin = now.top - prev.top - prev.height;
    prev.height += margin / 2;
    now.height += margin / 2;
    now.top -= margin / 2;
  }

  return rows;
}
/**
 * 选区、色块抗锯齿优化，调整 rect 的高度，使属于同一行的 rect 高度相同。
 */

function fitRows(rows, rects, offsetRect) {
  var newRects = [];
  rects.forEach(function (rect) {
    // 尝试找到插入行（如果 rect 的 top 比某一行的 bottom 小，就算插入行）
    var insertRow = rows.find(function (row) {
      return rect.top < row.top + row.height;
    }); // 如果没有找到，或者 rect 的 bottom 比插入行的 top 还要小，就不返回

    if (!insertRow || rect.top + rect.height < insertRow.top) {
      return;
    }

    var height = insertRow.height,
        top = insertRow.top;
    var left = rect.left,
        width = rect.width;
    newRects.push({
      left: left - offsetRect.left,
      top: top - offsetRect.top,
      height: height,
      width: width
    });
  });
  return newRects;
}
/**
 * 相邻的 rect 进行合并，避免碎片化的色块
 */

function mergeRects(rects) {
  var sortedRects = rects.sort(function (l, r) {
    if (l.top !== r.top) {
      return l.top - r.top;
    }

    return l.left - r.left;
  }); // 左右相邻的 rects 合并成一个

  var newRects = [];
  sortedRects.forEach(function (rect) {
    var prev = newRects[newRects.length - 1];
    var left = rect.left,
        width = rect.width;
    var top = rect.top,
        height = rect.height;

    if (prev && Math.round(prev.top) === Math.round(top) && // top 相等且 prev.right >= left，此 rect 可以和前一个合并
    Math.round(prev.left + prev.width) >= Math.round(left)) {
      // right 取最大值
      var right = Math.max(prev.left + prev.width, left + width);
      left = prev.left;
      width = right - left;
      newRects.pop();
      newRects.push({
        left: left,
        top: top,
        width: width,
        height: height
      });
    } else {
      newRects.push(rect);
    }
  });
  return newRects;
}

/**
 * 查找指定节点下的选区容器
 * @param root 查询的根节点
 * @param layerFor 查找的指定容器的 selection-layer，若为空则不指定具体值
 */

function getSelectionLayers(root, layerFor) {
  if (root === void 0) {
    root = window.document.body;
  }

  if (layerFor === void 0) {
    layerFor = '';
  }

  var selector = layerFor ? "[" + Selector.selectionLayer + "=\"" + layerFor + "\"]" : "[" + Selector.selectionLayer + "]";
  return root.querySelectorAll(selector) || [];
}
/**
 * 获取本地光标 DOM
 * @param root
 * @returns
 */

function getCaretDom(root) {
  if (root === void 0) {
    root = window.document.body;
  }

  var layers = getSelectionLayers(root);

  for (var i = layers.length - 1; i >= 0; i--) {
    var layer = layers[i];
    var target = layer.shadowRoot ? layer.shadowRoot.querySelector('[data-cangjie-caret="true"]') : layer.querySelector('[data-cangjie-caret="true"]');

    if (target) {
      return target;
    }
  }

  return undefined;
}
/**
 * 查找归属于特定 data-cangjie-key 的容器 DOM 节点内的选区根节点
 * @param containerKey 指定容器 key
 * @returns
 */

function findSelectionSlot(containerKey) {
  var containerDOM = findDOMNodeSafely(containerKey);

  try {
    var selectionLayer = getSelectionLayers(containerDOM, containerKey)[0];
    var wrapper = selectionLayer.shadowRoot ? selectionLayer.shadowRoot.querySelector('div') : selectionLayer.querySelector('div');
    return wrapper;
  } catch (e) {
    console.warn("[Selection] Get selection slot dom for [" + containerKey + "] failed", e);
  }

  return null;
}

function scrollToNodeByPath(_x, _x2, _x3, _x4) {
  return _scrollToNodeByPath.apply(this, arguments);
}

function _scrollToNodeByPath() {
  _scrollToNodeByPath = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(path, controller, preventScrollWhenNodeIsVisible, doNothingWhenVirtualizeDisabled) {
    var node, key, index, topBlock, targetNode, dom, virtualizeManager, selector, nodeElement;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (preventScrollWhenNodeIsVisible === void 0) {
              preventScrollWhenNodeIsVisible = false;
            }

            if (doNothingWhenVirtualizeDisabled === void 0) {
              doNothingWhenVirtualizeDisabled = false;
            }
            node = controller.view.getNodeByPath(path);

            if (node) {
              _context.next = 6;
              break;
            }

            return _context.abrupt("return");

          case 6:
            if (!(!controller.enableVirtualize && doNothingWhenVirtualizeDisabled)) {
              _context.next = 8;
              break;
            }

            return _context.abrupt("return");

          case 8:
            key = node.key;
            index = path[0];
            topBlock = controller.view.getNodeByPath([index]);
            targetNode = Text$1.isText(node) ? controller.view.getParent(key) : node;

            if (!(targetNode != null && targetNode.key && preventScrollWhenNodeIsVisible)) {
              _context.next = 16;
              break;
            }

            dom = findDOMNodeSafely(targetNode.key);

            if (!dom) {
              _context.next = 16;
              break;
            }

            return _context.abrupt("return");

          case 16:
            if (!(controller.enableVirtualize && controller.virtualizeManager && topBlock && !controller.isNodeVisible(topBlock))) {
              _context.next = 23;
              break;
            }

            virtualizeManager = controller.virtualizeManager;

            if (virtualizeManager.viewInitialized) {
              _context.next = 21;
              break;
            }

            _context.next = 21;
            return virtualizeManager.waitUntilViewInitialized;

          case 21:
            _context.next = 23;
            return virtualizeManager.workflowToScrollToNode(index);

          case 23:
            if (!targetNode) {
              _context.next = 35;
              break;
            }

            _context.prev = 24;
            selector = "[data-cangjie-key=\"" + targetNode.key + "\"]";
            _context.next = 28;
            return waitForElementByAnimationFrame(selector);

          case 28:
            nodeElement = _context.sent;

            if (nodeElement && typeof nodeElement.scrollIntoView === 'function') {
              nodeElement.scrollIntoView();
            }

            _context.next = 35;
            break;

          case 32:
            _context.prev = 32;
            _context.t0 = _context["catch"](24);
            console.warn("Failed to scrollToNodeByPath");

          case 35:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[24, 32]]);
  }));
  return _scrollToNodeByPath.apply(this, arguments);
}

function scrollToNodeByKey(_x5, _x6, _x7, _x8) {
  return _scrollToNodeByKey.apply(this, arguments);
}

function _scrollToNodeByKey() {
  _scrollToNodeByKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(key, controller, preventScrollWhenNodeIsVisible, doNothingWhenVirtualizeDisabled) {
    var path;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (preventScrollWhenNodeIsVisible === void 0) {
              preventScrollWhenNodeIsVisible = false;
            }

            if (doNothingWhenVirtualizeDisabled === void 0) {
              doNothingWhenVirtualizeDisabled = false;
            }

            path = controller.view.getPath(key);

            if (path) {
              _context2.next = 5;
              break;
            }

            return _context2.abrupt("return");

          case 5:
            _context2.next = 7;
            return scrollToNodeByPath(path, controller, preventScrollWhenNodeIsVisible, doNothingWhenVirtualizeDisabled);

          case 7:
            return _context2.abrupt("return");

          case 8:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _scrollToNodeByKey.apply(this, arguments);
}

/**
 * @packageDocumentation
 * @ignore
 */

var index$3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  findNode: findNode,
  findPoint: findPoint,
  findRange: findRange,
  findDOMNode: findDOMNode,
  findDOMNodeSafely: findDOMNodeSafely,
  findDOMPoint: findDOMPoint,
  findDOMRange: findDOMRange,
  findCurrentDOMRange: findCurrentDOMRange,
  findRangeByEvent: findRangeByEvent,
  caretRangeFromTargetAndCoord: caretRangeFromTargetAndCoord,
  findCaretPosition: findCaretPosition,
  splitRows: splitRows,
  fitRows: fitRows,
  mergeRects: mergeRects,
  findClosestInContent: findClosestInContent,
  getLocalCaretPos: getLocalCaretPos,
  getLocalCaretPosDetail: getLocalCaretPosDetail,
  scrollToNodeByPath: scrollToNodeByPath,
  scrollToNodeByKey: scrollToNodeByKey,
  findScrollableContainer: findScrollableContainer,
  getScrollableContainerInfo: getScrollableContainerInfo,
  getDOMRectFromSelection: getDOMRectFromSelection,
  scrollToSelection: scrollToSelection,
  getSelectionLayers: getSelectionLayers,
  getCaretDom: getCaretDom,
  findSelectionSlot: findSelectionSlot
});

var RESIZE_DEBOUNCE_TIME = 150;

var ViewManager = /*#__PURE__*/function () {
  // 暂时没用到的方法 未来可能用到 注释掉避免影响覆盖率
  // get viewPort() {
  //   return {
  //     viewPortStartY: this.viewPortStartY,
  //     viewPortEndY: this.viewPortEndY,
  //     bufferStartY: this.bufferStartY,
  //     bufferEndY: this.bufferEndY,
  //   }
  // }
  function ViewManager(options) {
    var _this = this;

    this.nodeManager = void 0;
    this.editorContainer = void 0;
    this.scrollContainer = void 0;
    this.scrollElement = void 0;
    this.scrollListenerElement = void 0;
    this.scrollHandler = void 0;
    this.scrollInterval = void 0;
    this.resizeHandler = void 0;
    this.resizeObserver = null;
    this.bufferRange = void 0;
    this.editorContainerToScrollContainerDistance = void 0;
    this.scrollHistoryArray = [];
    this.throttledScrollListener = void 0;
    this.triggerViewUpdate = void 0;
    this.viewPortStartY = void 0;
    this.viewPortEndY = void 0;
    this.bufferStartY = void 0;
    this.bufferEndY = void 0;
    this.prevViewPortStartY = 0;

    this.scrollListener = function () {
      var _this$calculateViewPo = _this.calculateViewPort(),
          viewPortStartY = _this$calculateViewPo.viewPortStartY;

      var timestamp = new Date().valueOf();
      var value = {
        timestamp: timestamp,
        viewPortStartY: viewPortStartY
      };

      var index = _this.scrollHistoryArray.findIndex(function (scrollHistory) {
        return scrollHistory.viewPortStartY === viewPortStartY && timestamp - scrollHistory.timestamp < 1000;
      });

      if (index >= 0) {
        return;
      }

      _this.scrollHistoryArray.push(value);

      if (_this.scrollHistoryArray.length > 2) {
        _this.scrollHistoryArray.shift();
      }

      _this.scrollHandler();
    };

    var editorContainer = options.editorContainer,
        scrollContainer = options.scrollContainer,
        scrollHandler = options.scrollHandler,
        scrollInterval = options.scrollInterval,
        resizeHandler = options.resizeHandler,
        bufferRange = options.bufferRange,
        triggerViewUpdate = options.triggerViewUpdate,
        nodeManager = options.nodeManager;
    this.nodeManager = nodeManager;
    this.editorContainer = editorContainer;
    this.scrollContainer = scrollContainer;
    this.scrollHandler = scrollHandler;
    this.resizeHandler = resizeHandler;
    this.bufferRange = bufferRange || DEFAULT_BUFFER_RANGE;
    this.scrollElement = scrollContainerIsTop(this.scrollContainer) ? document.documentElement : scrollContainer;
    this.scrollListenerElement = scrollContainerIsTop(this.scrollContainer) ? document : scrollContainer;
    this.scrollInterval = typeof scrollInterval === 'number' ? scrollInterval : DEFAULT_SCROLL_THROTTLE_INTERVAL;
    this.triggerViewUpdate = triggerViewUpdate;
    this.updateEditorContainerToScrollContainerDistance();
    this.updateViewPort();
    this.throttledScrollListener = throttle(this.scrollListener, this.scrollInterval);
  }

  var _proto = ViewManager.prototype;

  _proto.updateEditorContainerToScrollContainerDistance = function updateEditorContainerToScrollContainerDistance() {
    this.editorContainerToScrollContainerDistance = calculateEditorContainerToScrollContainerDistance(this.editorContainer, this.scrollContainer, this.scrollElement, scrollContainerIsTop(this.scrollContainer));
  };

  _proto.calculateViewPort = function calculateViewPort$1(_viewPortStartY) {
    return calculateViewPort(this.scrollElement, this.scrollContainer, this.bufferRange, this.editorContainerToScrollContainerDistance, _viewPortStartY);
  };

  _proto.updateViewPort = function updateViewPort() {
    this.prevViewPortStartY = this.viewPortStartY;

    var _this$calculateViewPo2 = this.calculateViewPort(),
        viewPortStartY = _this$calculateViewPo2.viewPortStartY,
        viewPortEndY = _this$calculateViewPo2.viewPortEndY,
        bufferStartY = _this$calculateViewPo2.bufferStartY,
        bufferEndY = _this$calculateViewPo2.bufferEndY;

    this.viewPortStartY = viewPortStartY;
    this.viewPortEndY = viewPortEndY;
    this.bufferStartY = bufferStartY;
    this.bufferEndY = bufferEndY; // const gap = this.viewPortStartY - this.prevViewPortStartY;

    return;
  };

  _proto.initScrollListener = function initScrollListener() {
    this.scrollListenerElement.addEventListener('scroll', this.throttledScrollListener);
  };

  _proto.destroyScrollListener = function destroyScrollListener() {
    this.scrollListenerElement.removeEventListener('scroll', this.throttledScrollListener);
  };

  _proto.initResizeObserver = function initResizeObserver() {
    var _this2 = this;

    if (typeof ResizeObserver === 'undefined') {
      return;
    }

    var handleResize = debounce(function (entries) {
      _this2.resizeHandler(entries);
    }, RESIZE_DEBOUNCE_TIME);
    var resizeObserver = new ResizeObserver(handleResize);
    this.resizeObserver = resizeObserver;
  };

  _proto.detroyResizeObserver = function detroyResizeObserver() {
    this.resizeObserver = null;
  };

  _proto.addResizeObserverByKeys = function addResizeObserverByKeys(blockKeys) {
    var _this3 = this;

    if (!this.resizeObserver) {
      return;
    }

    blockKeys.forEach(function (blockKey) {
      var blockElement = findDOMNodeSafely(blockKey);

      if (!blockElement) {
        return;
      }

      _this3.addResizeObserver(blockElement);
    });
  };

  _proto.addResizeObserver = function addResizeObserver(element) {
    if (!this.resizeObserver) {
      return;
    }

    this.resizeObserver.observe(element);
  };

  _proto.removeResizeObserver = function removeResizeObserver(element) {
    if (!this.resizeObserver) {
      return;
    }

    this.resizeObserver.unobserve(element);
  }
  /**
   * 测量所有当前上屏节点的高度
   * @returns Object, key 为节点 key, value 为高度
   */
  ;

  _proto.measureCurrentViewBlocks = function measureCurrentViewBlocks(documentKey) {
    var documentElement = findDOMNodeSafely(documentKey);
    var result = {};
    documentElement == null ? void 0 : documentElement.childNodes.forEach(function (childNode) {
      var element = childNode;
      var cangjieKey = element.getAttribute(Selector.key);

      if (cangjieKey) {
        var measuredInfo = measureBlockInfo(element);
        result[cangjieKey] = measuredInfo;
      }
    });
    return result;
  };

  _proto.measureBlocksByKeys = /*#__PURE__*/function () {
    var _measureBlocksByKeys = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(blockKeys) {
      var result, measureTasks;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              result = {};
              measureTasks = blockKeys.map(function (blockKey) {
                var promise = Promise.resolve().then(function () {
                  var blockElement = findDOMNodeSafely(blockKey);

                  if (!blockElement) {
                    return {};
                  }

                  var measuredInfo = measureBlockInfo(blockElement);
                  result[blockKey] = measuredInfo;
                  return measuredInfo;
                });
                return promise;
              });
              _context.next = 4;
              return Promise.all(measureTasks);

            case 4:
              return _context.abrupt("return", result);

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function measureBlocksByKeys(_x) {
      return _measureBlocksByKeys.apply(this, arguments);
    }

    return measureBlocksByKeys;
  }();

  _proto.calculateExpectedLayoutInfo = function calculateExpectedLayoutInfo$1(view, bufferStartY, bufferEndY, viewStartY) {
    var result = calculateExpectedLayoutInfo(typeof bufferStartY === 'number' ? bufferStartY : this.bufferStartY, typeof bufferEndY === 'number' ? bufferEndY : this.bufferEndY, typeof viewStartY === 'number' ? viewStartY : this.viewPortStartY, view, this.nodeManager);

    return result;
  };

  _proto.calculateBlockStartYByBlockIndex = function calculateBlockStartYByBlockIndex$1(index, view, includeLastMarginBottom) {
    if (includeLastMarginBottom === void 0) {
      includeLastMarginBottom = false;
    }

    return calculateBlockStartYByBlockIndex(index, view, this.nodeManager, includeLastMarginBottom);
  } // 这里仅仅是滚最外层
  ;

  _proto.scrollToNodeByIndex = function scrollToNodeByIndex(index, view) {
    // this.updateEditorContainerToScrollContainerDistance();
    var startY = calculateBlockStartYByBlockIndex(index, view, this.nodeManager);

    var totalStartY = startY + this.editorContainerToScrollContainerDistance;
    this.scrollElement.scrollTo(this.scrollElement.scrollLeft, totalStartY);
  };

  return ViewManager;
}();

var VirtualizeManager = /*#__PURE__*/function () {
  _createClass(VirtualizeManager, [{
    key: "isActive",
    // active 状态，用于运行时关闭虚拟化
    // 虚拟化配置项
    // 节点缓存管理器，用于缓存节点的测量结果等，并提供了一些方便使用的加载测量结果的方法
    // 输出管理器，通过加载测算结果，生成节点是否可视等输出信息，Cangjie 渲染时 useVirtualize 依赖
    // 视图管理器，所有跟 视图、DOM 相关的逻辑均收敛到这里
    // 虚拟化 id，为虚拟化流程执行次数的标记，同时用于触发虚拟化流程导致的视图重渲；为 -1 时代表虚拟化关闭
    // 当前正忙的虚拟化 id，用于禁止其他流程的进行
    // 虚拟化的当前测算结果与上次测算结果，outputManager load 此结果后才会改变输出
    // 虚拟化视图是否初始化，这里提供一个 Promise，在虚拟化初始化后，此 Promise 会 resolve
    // 当前的 Controller
    // 之前的 view
    // 配置的 buffer 范围
    // 虚拟化是否在正常运行态
    get: function get() {
      return this._isActive;
    }
    /**
     * 虚拟化控制器初始化逻辑，在仓颉新建 Controller 时触发
     * @returns void
     */

  }]);

  function VirtualizeManager(controller, options) {
    var _this = this;

    this._isActive = false;
    this.options = void 0;
    this.nodeManager = void 0;
    this.outputManager = void 0;
    this.viewManager = void 0;
    this.virtualizeId = 0;
    this.currentLockedVirtualizeId = null;
    this.prevLayoutInfoResult = void 0;
    this.layoutInfoResult = void 0;
    this.viewInitialized = false;

    this.setViewInitialized = function () {};

    this.waitUntilViewInitialized = void 0;
    this.controller = void 0;
    this.prevView = void 0;
    this.bufferRange = void 0;
    this.initViewWorkflow = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var view, currentVirtualizeId, measureResult, layoutInfoResult, visibles, virtualizeId, nextMeasureResult;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              view = _this.controller.view;
              currentVirtualizeId = _this.virtualizeId + 1; // Step 1：视图管理器测量所有已上屏节点

              measureResult = _this.viewManager.measureCurrentViewBlocks(view.key); // Step 2：节点管理器保存测量结果

              _this.nodeManager.loadMeasureResult(measureResult); // Step 3：根据当前视窗和 Step 2 保存的节点测量结果
              // 进行计算流程，计算当前的布局，并保存。同时会记录上一次的布局信息


              _this.prevLayoutInfoResult = _this.layoutInfoResult;
              layoutInfoResult = _this.viewManager.calculateExpectedLayoutInfo(view);
              _this.layoutInfoResult = layoutInfoResult; // Step 4：输出管理器加载布局计算结果，输出管理器控制着最后的输出，只有加载测算结果才会影响输出

              _this.outputManager.loadCalculateLayoutInfo(layoutInfoResult); // Step 5：更新虚拟化模型控制器中的当前可见节点，触发模型重算


              visibles = _this.outputManager.visibles;

              _this.controller.setVirtualize('visibles', visibles.visibleBlockKeys); // Step 6：刷新虚拟化结果，触发重渲


              virtualizeId = _this.flushVirtualize(currentVirtualizeId);

              if (!(visibles.visibleBlockKeys.length === 0)) {
                _context.next = 13;
                break;
              }

              return _context.abrupt("return");

            case 13:
              _context.next = 15;
              return waitForElementByAnimationFrame("[data-virtualize-id=\"" + virtualizeId + "\"]");

            case 15:
              // Step 8: 为渲染上屏的节点添加 resizeObserver
              _this.viewManager.addResizeObserverByKeys(visibles.visibleBlockKeys); // Step 9: 测量渲染上屏的节点的高度并保存，结束


              _context.next = 18;
              return _this.viewManager.measureBlocksByKeys(visibles.visibleBlockKeys);

            case 18:
              nextMeasureResult = _context.sent;

              _this.nodeManager.loadMeasureResult(nextMeasureResult);

            case 20:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    this.coreWorkflow = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(triggerReRenderActively, measureOnly, shouldAddLock) {
        var currentVirtualizeId, _this$outputManager, afterPlaceholderHeight, beforePlaceholderHeight, visibles, view, newBlockKeys, nextMeasureResult, layoutInfoResult, _this$outputManager$p, newAfterPlaceholderHeight, newBeforePlaceholderHeight, newVisibles, needToReRender, needToStartNextWorkflow;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (triggerReRenderActively === void 0) {
                  triggerReRenderActively = true;
                }

                if (measureOnly === void 0) {
                  measureOnly = false;
                }

                if (shouldAddLock === void 0) {
                  shouldAddLock = false;
                }

                // Step 1: 前置流程，递增 virtualizeId，检查是否状态忙，状态忙则终止流程
                currentVirtualizeId = _this.virtualizeId + 1;

                if (!_this.checkLocked(currentVirtualizeId)) {
                  _context2.next = 6;
                  break;
                }

                return _context2.abrupt("return", {
                  layoutInfoResult: null,
                  needToReRender: false,
                  needToStartNextWorkflow: false
                });

              case 6:
                // Step 2：加载上一次的测算结果
                // 上个流程测算结束后，测算结果会保存，但不会直接改变输出 (不会 load 进 OutputManager)
                // 会简单判断是否需要开启下一个流程后，交给下一个虚拟化流程去重渲
                _this.outputManager.loadCalculateLayoutInfo(_this.layoutInfoResult);

                _this$outputManager = _this.outputManager, afterPlaceholderHeight = _this$outputManager.afterPlaceholderHeight, beforePlaceholderHeight = _this$outputManager.beforePlaceholderHeight, visibles = _this$outputManager.visibles; // Step 2.1：根据上一次的测算结果，改变虚拟化模型中的可见节点

                _this.controller.setVirtualize('visibles', visibles.visibleBlockKeys);

                view = _this.controller.view; // Step 3：根据上一次的测算结果（即将上屏的节点）和之前的测算结果（已经上屏的节点）
                // 判断新增了哪些节点，稍后只测量新增的节点，以提高性能

                newBlockKeys = calculateBlockKeysNeedToMeasure(view, _this.prevView, _this.layoutInfoResult, _this.prevLayoutInfoResult); // Step 4：根据传入参数，决定是否需要设置 busy 状态

                if (shouldAddLock) {
                  _this.lock(currentVirtualizeId);
                } // Step 5：保存新虚拟化 id；触发重渲，上屏根据上次测算结果得到的新节点


                _this.flushVirtualize(currentVirtualizeId, triggerReRenderActively); // Step 6：等待重渲完毕，测量新上屏的节点并保存节点测量结果到 nodeManager
                // 如果因为被其他流程覆盖等原因等不到此虚拟化 id，则放弃此流程
                // 同时为新增的节点增加 resizeObserver


                if (!(newBlockKeys.length > 0)) {
                  _context2.next = 28;
                  break;
                }

                _context2.prev = 14;
                _context2.next = 17;
                return waitForElementByAnimationFrame("[data-virtualize-id=\"" + currentVirtualizeId + "\"]");

              case 17:
                _context2.next = 23;
                break;

              case 19:
                _context2.prev = 19;
                _context2.t0 = _context2["catch"](14);

                _this.unlock(currentVirtualizeId);

                return _context2.abrupt("return", {
                  layoutInfoResult: null,
                  needToReRender: false,
                  needToStartNextWorkflow: false
                });

              case 23:
                _this.viewManager.addResizeObserverByKeys(newBlockKeys);

                _context2.next = 26;
                return _this.viewManager.measureBlocksByKeys(newBlockKeys);

              case 26:
                nextMeasureResult = _context2.sent;

                _this.nodeManager.loadMeasureResult(nextMeasureResult);

              case 28:
                // Step 7：解除 busy 状态
                _this.unlock(currentVirtualizeId); // 对只需要测量的流程，结束流程


                if (!measureOnly) {
                  _context2.next = 31;
                  break;
                }

                return _context2.abrupt("return", {
                  layoutInfoResult: null,
                  needToReRender: false,
                  needToStartNextWorkflow: false
                });

              case 31:
                // Step 8：根据测量的结果，进行对布局的计算
                layoutInfoResult = _this.viewManager.calculateExpectedLayoutInfo(view); // Step 9: 根据布局的结果，进行对节点详细布局情况和 placeholder 高度的计算
                // 使用 precheckOutputByLayoutInfo 意味着这个计算结果不会影响最终输出，只供 Step 10 的判断

                _this$outputManager$p = _this.outputManager.precheckOutputByLayoutInfo(layoutInfoResult), newAfterPlaceholderHeight = _this$outputManager$p.afterPlaceholderHeight, newBeforePlaceholderHeight = _this$outputManager$p.beforePlaceholderHeight, newVisibles = _this$outputManager$p.visibles; // Step 10: 根据 Step 9 的计算结果，判断是否要发起下一个虚拟化工作流，或者是否需要重渲 Placeholder
                // 如果需要上屏的节点有变化，则需要发起下一个工作流，在下一个工作流中上屏这些节点（并测量与计算）
                // 如果需要上屏的节点没有变化，但 Placeholder 高度发生了变化，直接触发重渲即可

                needToReRender = false;
                needToStartNextWorkflow = false; // 节点还是那些老的，没有变化

                if (equal(visibles, newVisibles)) {
                  // 但是 placeholder 高度有变化，要重渲
                  if (afterPlaceholderHeight !== newAfterPlaceholderHeight || beforePlaceholderHeight !== newBeforePlaceholderHeight) {
                    needToReRender = true;
                  } // 出现新节点

                } else {
                  needToReRender = true;

                  if (checkArrayAHasElementNotIncludedInArrayB(newVisibles.visibleBlockKeys, visibles.visibleBlockKeys)) {
                    needToStartNextWorkflow = true;
                  }
                }

                return _context2.abrupt("return", {
                  layoutInfoResult: layoutInfoResult,
                  needToReRender: needToReRender,
                  needToStartNextWorkflow: needToStartNextWorkflow
                });

              case 37:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[14, 19]]);
      }));

      return function (_x, _x2, _x3) {
        return _ref2.apply(this, arguments);
      };
    }();

    this.workflowByCurrentViewPort = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
      var view, _yield$_this$coreWork, needToStartNextWorkflow, needToReRender, layoutInfoResult, visibles, newVirtualizeId;

      return _regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              view = _this.controller.view; // Step 1: 根据当前视口情况，更新视口位置信息，根据视口位置信息和过去缓存的节点测量高度，算出一个新的布局结果
              // 同时储存上一次计算的布局结果

              _this.prevLayoutInfoResult = _this.layoutInfoResult;

              _this.viewManager.updateViewPort();

              _this.layoutInfoResult = _this.viewManager.calculateExpectedLayoutInfo(view); // Step 2: 执行 coreWorkflow，Step 1 中的新的布局结果会上屏并进行测算
              // 根据新的测算结果，可能需要补充节点，或者剔除节点（needToStartNextWorkflow），出现这种情况需要发起下个工作流
              // 根据新的测算结果，placeholder 高度也可能发生变化，需要重渲一下

              _context3.next = 6;
              return _this.coreWorkflow();

            case 6:
              _yield$_this$coreWork = _context3.sent;
              needToStartNextWorkflow = _yield$_this$coreWork.needToStartNextWorkflow;
              needToReRender = _yield$_this$coreWork.needToReRender;
              layoutInfoResult = _yield$_this$coreWork.layoutInfoResult;

              if (!needToStartNextWorkflow) {
                _context3.next = 15;
                break;
              }

              _context3.next = 13;
              return _this.workflowByCurrentViewPort();

            case 13:
              _context3.next = 24;
              break;

            case 15:
              if (!needToReRender) {
                _context3.next = 24;
                break;
              }

              _this.prevLayoutInfoResult = _this.layoutInfoResult;

              _this.outputManager.loadCalculateLayoutInfo(layoutInfoResult);

              _this.layoutInfoResult = layoutInfoResult;
              visibles = _this.outputManager.visibles;

              _this.controller.setVirtualize('visibles', visibles.visibleBlockKeys);

              newVirtualizeId = _this.virtualizeId + 1;

              _this.flushVirtualize(newVirtualizeId);

              return _context3.abrupt("return");

            case 24:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    this.workflowToScrollToNode = /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(nodeIndex) {
        var view, startY, _calculateViewPort, bufferStartY, bufferEndY, viewPortStartY, layoutInfoResult;

        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                view = _this.controller.view;

                _this.viewManager.updateEditorContainerToScrollContainerDistance(); // Step 1：通过节点的 index，根据当前的测算结果，得到视口滚动到恰好显示此节点时，视口的 y 坐标
                // 指定 y 坐标是本工作流与其他工作流最大的不同之处，上面的工作流是通过视口位置得到 y 坐标


                startY = _this.viewManager.calculateBlockStartYByBlockIndex(nodeIndex, view);
                _calculateViewPort = _this.viewManager.calculateViewPort(startY), bufferStartY = _calculateViewPort.bufferStartY, bufferEndY = _calculateViewPort.bufferEndY, viewPortStartY = _calculateViewPort.viewPortStartY; // Step 2：假设视口滚动到此 y 坐标时，根据当前缓存的测算结果，计算布局信息

                _this.prevLayoutInfoResult = _this.layoutInfoResult;
                layoutInfoResult = _this.viewManager.calculateExpectedLayoutInfo(view, bufferStartY, bufferEndY, viewPortStartY);
                _this.layoutInfoResult = layoutInfoResult; // Step 3：发起 coreWorkflow，上屏布局信息中需要上屏的节点，并测量

                _context4.next = 9;
                return _this.coreWorkflow(true, true, true);

              case 9:
                // Step 4: 触发一次滚动，将视口滚动到指定 y 坐标处，此时浏览器会触发 scroll 时事件，引发 workflowByCurrentViewPort 工作流
                _this.viewManager.scrollToNodeByIndex(nodeIndex, view);

              case 10:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));

      return function (_x4) {
        return _ref4.apply(this, arguments);
      };
    }();

    this.workflowOnValueChange = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
      var prevView, currView, view, _this$outputManager2, startBlockOffset, startBlockKey, endBlockOffset, diffResult, layoutInfoResult;

      return _regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              prevView = _this.prevView;
              currView = _this.controller.view;
              view = _this.controller.view;
              _this$outputManager2 = _this.outputManager, startBlockOffset = _this$outputManager2.startBlockOffset, startBlockKey = _this$outputManager2.startBlockKey, endBlockOffset = _this$outputManager2.endBlockOffset;
              diffResult = fastDiffOnValueChange(prevView, currView, startBlockKey, startBlockOffset, endBlockOffset);

              if (!(diffResult.type === 'changed')) {
                _context5.next = 11;
                break;
              }

              // Step 1：如果 diff 发现节点发生了变化，且不是平移，会根据最新的 viewModel 和视口信息，以及之前缓存的测量结果，计算布局信息
              _this.prevLayoutInfoResult = _this.layoutInfoResult;
              layoutInfoResult = _this.viewManager.calculateExpectedLayoutInfo(view);
              _this.layoutInfoResult = layoutInfoResult; // Step 2: 发起 coreWorkflow，可能这里直接发起 workflowByCurrentViewPort 更好，后续修改

              _context5.next = 11;
              return _this.coreWorkflow(false);

            case 11:
              _this.prevView = currView;

            case 12:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    this.scrollHandler = function () {
      _this.workflowByCurrentViewPort();
    };

    this.resizeHandler = /*#__PURE__*/function () {
      var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(entries) {
        var view, _this$outputManager3, afterPlaceholderHeight, beforePlaceholderHeight, visibles, visibleBlockKeys, resizedNodeEntries, resizedBlockKeys, nextMeasureResult, layoutInfoResult, _this$outputManager$p2, newAfterPlaceholderHeight, newBeforePlaceholderHeight, newVisibles, needToReRender, needToStartNextWorkflow, _visibles, currentVirtualizeId;

        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                view = _this.controller.view;
                _this$outputManager3 = _this.outputManager, afterPlaceholderHeight = _this$outputManager3.afterPlaceholderHeight, beforePlaceholderHeight = _this$outputManager3.beforePlaceholderHeight, visibles = _this$outputManager3.visibles;
                visibleBlockKeys = visibles.visibleBlockKeys;
                resizedNodeEntries = entries.filter(function (entry) {
                  var target = entry.target,
                      contentRect = entry.contentRect;
                  var key = target.getAttribute('data-cangjie-key');
                  var parent = view.getParent(key);

                  if (!(parent && Document.isDocument(parent))) {
                    return false;
                  }

                  var hidden = target.style.display === 'none';

                  if (!key || !view.nodes.some(function (node) {
                    return node.key === key;
                  })) {
                    return false;
                  }

                  if (hidden && !visibleBlockKeys.includes(key)) {
                    return false;
                  }

                  var nodeProp = _this.nodeManager.getCachedBlockPropsByKey(key); // 这里出于性能考虑暂不判断 marginTop 和 marginBottom


                  if ((nodeProp == null ? void 0 : nodeProp.height) !== contentRect.height) {
                    return true;
                  }

                  return false;
                });
                resizedBlockKeys = resizedNodeEntries.map(function (entry) {
                  var target = entry.target;
                  return target.getAttribute('data-cangjie-key');
                });
                _context6.next = 7;
                return _this.viewManager.measureBlocksByKeys(resizedBlockKeys);

              case 7:
                nextMeasureResult = _context6.sent;

                _this.nodeManager.loadMeasureResult(nextMeasureResult);

                layoutInfoResult = _this.viewManager.calculateExpectedLayoutInfo(view);

                if (resizedBlockKeys.length > 0) {
                  _this$outputManager$p2 = _this.outputManager.precheckOutputByLayoutInfo(layoutInfoResult), newAfterPlaceholderHeight = _this$outputManager$p2.afterPlaceholderHeight, newBeforePlaceholderHeight = _this$outputManager$p2.beforePlaceholderHeight, newVisibles = _this$outputManager$p2.visibles;
                  needToReRender = false;
                  needToStartNextWorkflow = false;

                  if (equal(visibles, newVisibles)) {
                    // 还是老节点，但是 placeholder 要变
                    if (afterPlaceholderHeight !== newAfterPlaceholderHeight || beforePlaceholderHeight !== newBeforePlaceholderHeight) {
                      needToReRender = true;
                    } // 根据新结果，应出现新节点，通常有个东西高度大幅缩小了

                  } else {
                    needToReRender = true;

                    if (checkArrayAHasElementNotIncludedInArrayB(newVisibles.visibleBlockKeys, visibles.visibleBlockKeys)) {
                      needToStartNextWorkflow = true;
                    }
                  }

                  if (needToStartNextWorkflow) {
                    _this.workflowByCurrentViewPort();
                  } else if (needToReRender) {
                    _this.prevLayoutInfoResult = _this.layoutInfoResult;

                    _this.outputManager.loadCalculateLayoutInfo(layoutInfoResult);

                    _this.layoutInfoResult = layoutInfoResult;
                    _visibles = _this.outputManager.visibles;

                    _this.controller.setVirtualize('visibles', _visibles.visibleBlockKeys);

                    currentVirtualizeId = _this.virtualizeId + 1;

                    _this.flushVirtualize(currentVirtualizeId);
                  }
                }

              case 11:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));

      return function (_x5) {
        return _ref6.apply(this, arguments);
      };
    }();

    var bufferRange = options.bufferRange,
        firstPaintBlockSize = options.firstPaintBlockSize;
    this.options = options;
    this.bufferRange = bufferRange;
    this.controller = controller;
    this.prevView = controller.view;
    this.waitUntilViewInitialized = new Promise(function (resolve) {
      _this.setViewInitialized = resolve;
    });
    this.nodeManager = new NodeManager({
      controller: controller
    });
    this.outputManager = new OutputManager({
      controller: controller,
      firstPaintBlockSize: firstPaintBlockSize,
      nodeManager: this.nodeManager
    });
    this.controller.setVirtualize('visibles', this.outputManager.visibles.visibleBlockKeys);
  }
  /**
   * 在仓颉首屏渲染后的 Effect 中触发的逻辑，用于初始化 View/DOM 相关逻辑，如建立滚动事件监听
   * @returns void
   */


  var _proto = VirtualizeManager.prototype;

  _proto.initView = function initView(InitViewOptions) {
    var editorContainer = InitViewOptions.editorContainer,
        scrollContainer = InitViewOptions.scrollContainer,
        scrollInterval = InitViewOptions.scrollInterval,
        triggerViewUpdate = InitViewOptions.triggerViewUpdate;
    this.viewManager = new ViewManager({
      editorContainer: editorContainer,
      scrollContainer: scrollContainer,
      scrollInterval: scrollInterval,
      scrollHandler: this.scrollHandler,
      resizeHandler: this.resizeHandler,
      triggerViewUpdate: triggerViewUpdate,
      nodeManager: this.nodeManager,
      bufferRange: this.bufferRange
    });
    this.initViewWorkflow();
    this.viewInitialized = true;
    this.setViewInitialized();
  }
  /**
   * 启动虚拟化流程
   * @param flush 是否主动触发重渲
   * @returns void
   */
  ;

  _proto.start = function start(flush) {
    if (flush === void 0) {
      flush = false;
    }

    if (!this.viewInitialized) {
      console.error('VirtualizeManager error: start invoked before UI Related Manager initialization');
    }

    if (!this.isActive) {
      this.viewManager.initScrollListener();
      this.viewManager.initResizeObserver();
    }

    if (flush) {
      this.flushVirtualize(this.virtualizeId + 1, true);
    }

    this._isActive = true;
  }
  /**
   * 关闭虚拟化流程
   * @param flush 是否主动触发重渲，如外界未触发重渲，需要主动触发重渲来显示所有节点
   * @returns void
   */
  ;

  _proto.stop = function stop(flush) {
    if (flush === void 0) {
      flush = false;
    }

    if (!this.viewInitialized) {
      console.error('VirtualizeManager error: stop invoked before UI Related Manager initialization');
    }

    if (this.isActive) {
      this.viewManager.destroyScrollListener();
      this.viewManager.detroyResizeObserver();
    }

    if (flush) {
      // virtualizeId 归零
      this.flushVirtualize(-1, true);
    }

    this._isActive = false;
  }
  /**
   * 为某个虚拟化工作流增加 busy 状态位，此时可以阻止其他虚拟化工作流的发起
   * @param virtualizeId 虚拟化 id
   * @returns virtualizeId 虚拟化 id
   */
  ;

  _proto.lock = function lock(virtualizeId) {
    if (this.currentLockedVirtualizeId !== null) {
      console.warn('warning: current has virtualizeId locked, unlock it first');
      return this.currentLockedVirtualizeId;
    }

    this.currentLockedVirtualizeId = virtualizeId;
    return virtualizeId;
  }
  /**
   * 为某个虚拟化工作流移除 busy 状态位
   * @param virtualizeId 虚拟化 id
   * @returns boolean 是否成功移除
   */
  ;

  _proto.unlock = function unlock(virtualizeId) {
    if (this.currentLockedVirtualizeId === virtualizeId) {
      this.currentLockedVirtualizeId = null;
      return true;
    }

    return false;
  }
  /**
   * 检查是否存在 busy 状态位
   * @param virtualizeId 虚拟化 id
   * @returns boolean 是否存在 busy 状态位
   */
  ;

  _proto.checkLocked = function checkLocked(virtualizeId) {
    if (this.currentLockedVirtualizeId !== null && virtualizeId !== this.currentLockedVirtualizeId) {
      return true;
    }

    return false;
  }
  /**
   * 更新虚拟化 id，刷新虚拟化结果（可选是否主动强制重渲）
   * @param virtualizeId 虚拟化 id
   * @param triggerReRenderActively 是否主动强制重渲
   * @returns 保存后的虚拟化 id
   */
  ;

  _proto.flushVirtualize = function flushVirtualize(virtualizeId, triggerReRenderActively) {
    if (triggerReRenderActively === void 0) {
      triggerReRenderActively = true;
    }

    this.virtualizeId = virtualizeId;

    if (triggerReRenderActively) {
      var _this$viewManager;

      (_this$viewManager = this.viewManager) == null ? void 0 : _this$viewManager.triggerViewUpdate == null ? void 0 : _this$viewManager.triggerViewUpdate(this.virtualizeId);
    }

    return this.virtualizeId;
  }
  /**
   * 在 Cangjie 首屏渲染后执行的工作流，会测量首屏渲染的结果 (固定节点数，也不是全量节点)，并根据测量结果适当收缩节点数量
   * 最简单的虚拟化工作流，可以用于入门流程
   * @returns void
   */
  ;

  return VirtualizeManager;
}();

/**
 * 模型分组管理
 */
var GroupManager = /*#__PURE__*/function () {
  function GroupManager(controller) {
    this.groups = {
      current: {},
      prev: {}
    };
    this.groups$ = new ReplaySubject();
    this.controller = void 0;
    this.CACHE = {
      NODE_GROUP: new Map()
    };
    this.controller = controller;
  }
  /**
   * 清理 group manager 内存占用
   */


  var _proto = GroupManager.prototype;

  _proto.cleanup = function cleanup() {
    this.groups = {
      current: {},
      prev: {}
    };
    this.CACHE.NODE_GROUP.clear();
  }
  /**
   * 获得指定 key 的分组
   * @param key
   * @returns
   */
  ;

  _proto.getGroup = function getGroup(key) {
    return this.groups.current[key];
  }
  /**
   * 获得所有分组
   * @returns
   */
  ;

  _proto.getGroups = function getGroups() {
    return this.groups.current;
  }
  /**
   * 向订阅节点通知最新的分组信息
   * @param force
   * @returns
   */
  ;

  _proto.notifyNewGroups = function notifyNewGroups(force) {
    if (force === void 0) {
      force = false;
    }

    if (force || this.groups.current !== this.groups.prev) {
      this.groups.prev = this.groups.current;
      this.groups$.next(this.groups.current);
    }

    return this;
  }
  /**
   * 设置分组数据
   * @param key
   * @param data
   * @returns
   */
  ;

  _proto.setGroupData = function setGroupData(key, data) {
    var _extends2, _extends3;

    var group = this.getGroup(key);
    this.groups.current = _extends({}, this.groups.current, (_extends3 = {}, _extends3[key] = _extends({}, group, {
      data: _extends({}, data, (_extends2 = {}, _extends2[GROUP_COLLAPSED_KEY] = group.data[GROUP_COLLAPSED_KEY], _extends2))
    }), _extends3));
    this.notifyNewGroups();
    return this;
  }
  /**
   * 融合分组数据
   * @param key
   * @param data
   * @returns
   */
  ;

  _proto.mergeGroupData = function mergeGroupData(key, data) {
    var _extends4;

    var group = this.getGroup(key);
    this.groups.current = _extends({}, this.groups.current, (_extends4 = {}, _extends4[key] = _extends({}, group, {
      data: _extends({}, group.data, data)
    }), _extends4));
    this.notifyNewGroups();
    return this;
  }
  /**
   * 生成全文所有的 Groups
   */
  ;

  _proto.generateAllGroups = function generateAllGroups() {
    var _this = this;

    this.controller.value.document.forEachDescendant(function (node) {
      if (node.isElement()) {
        _this.generateGroup(node);
      }
    });
    return this;
  };

  _proto.initGroups = function initGroups(groups) {
    if (groups) {
      this.groups.current = groups;
      this.groups.prev = groups;
    }

    return this;
  }
  /**
   * 获得节点所在的分组序列
   * @param node
   * @returns
   */
  ;

  _proto.getNodeGroups = function getNodeGroups(node) {
    var document = this.controller.value.document;
    var groups = [];
    var elementGroup = this.getGroup(node.key);

    if (elementGroup) {
      groups.push(_extends({
        key: node.key
      }, elementGroup));
    }

    var groupKey = this.CACHE.NODE_GROUP.get(node.key);

    while (groupKey !== undefined) {
      var group = this.getGroup(groupKey);

      if (group) {
        groups.push(_extends({
          key: groupKey
        }, group));
      }

      var groupElement = document.getNode(groupKey);

      if (!groupElement) {
        break;
      }

      groupKey = this.CACHE.NODE_GROUP.get(groupElement.key);

      while (groupKey === undefined && groupElement && groupElement !== document) {
        var parent = document.assertParent(groupElement.key);
        groupKey = this.CACHE.NODE_GROUP.get(parent.key);
        groupElement = parent;
      }
    }

    return groups;
  }
  /**
   * 针对特殊变更，重新分组
   * @param operationWithValue
   */
  ;

  _proto.regenerateGroup = function regenerateGroup(operationWithValue) {
    var _this2 = this;

    var operation = operationWithValue.operation,
        value = operationWithValue.value,
        newValue = operationWithValue.newValue;

    if (operation.type === OperationType.RemoveNode && operation.node.isElement()) {
      var prevGroup = this.getGroup(operation.node.key); // 节点删除后，对应删除其分组

      this.removeGroup(operation.node.key); // 从删除节点前一个节点开始重新分组

      this.regenerateGroupFrom(value.document.getPreviousSibling(operation.node.key), (prevGroup == null ? void 0 : prevGroup.data[GROUP_COLLAPSED_KEY]) || false);
    } else if (operation.type === OperationType.InsertNode && operation.node.isElement()) {
      var node = newValue.document.assertNodeByPath(operation.path);
      var prevNode = newValue.document.getPreviousSibling(node.key);

      var _prevGroup = prevNode && this.getGroup(prevNode.key); // 从当前重新节点进行分组


      this.regenerateGroupFrom(operation.node, (_prevGroup == null ? void 0 : _prevGroup.data[GROUP_COLLAPSED_KEY]) || false); // 对新插入节点的子节点进行分组

      operation.node.forEachDescendant(function (n) {
        if (n.isElement()) {
          _this2.generateGroup(n, (_prevGroup == null ? void 0 : _prevGroup.data[GROUP_COLLAPSED_KEY]) || false);
        }
      });
    } else if (operation.type === OperationType.SetNode) {
      // 删除节点原来的分组
      var _node = newValue.document.assertNodeByPath(operation.path);

      var oldNode = value.document.assertNodeByPath(operation.path);

      var _prevGroup2 = this.getGroup(_node.key);

      this.getGroup(oldNode.key);
      this.removeGroup(_node.key); // 从当前节点开始，重新分组

      this.regenerateGroupFrom(_node, (_prevGroup2 == null ? void 0 : _prevGroup2.data[GROUP_COLLAPSED_KEY]) || false);
    } else if (operation.type === OperationType.MergeNode) {
      var _node2 = value.document.assertNodeByPath(operation.path);

      var _prevGroup3 = this.getGroup(_node2.key);

      if (_node2.isElement()) {
        // 删除节点所在分组
        this.removeGroup(_node2.key); // 从合并到的节点开始重新分组

        this.regenerateGroupFrom(newValue.document.getPreviousSiblingByPath(operation.path), (_prevGroup3 == null ? void 0 : _prevGroup3.data[GROUP_COLLAPSED_KEY]) || false);
      }
    } else if (operation.type === OperationType.SplitNode) {
      var _node3 = value.document.assertNodeByPath(operation.path);

      if (_node3.isElement()) {
        var _prevGroup4 = this.getGroup(_node3.key); // 删除节点所在分组


        this.removeGroup(_node3.key); // 从合并到的节点开始重新分组

        this.regenerateGroupFrom(newValue.document.getNextSiblingByPath(operation.path), (_prevGroup4 == null ? void 0 : _prevGroup4.data[GROUP_COLLAPSED_KEY]) || false);
      }
    } else if (operation.type === OperationType.MoveNode) {
      // 从移动起点开始重新分组
      var _node4 = value.document.assertNodeByPath(operation.path);

      this.regenerateGroupFrom(value.document.getPreviousSibling(_node4.key)); // 从移动终点开始重新分组

      this.regenerateGroupFrom(_node4);
    }

    return this;
  };

  _proto.removeGroup = function removeGroup(key) {
    if (!key) {
      return this;
    }

    this.groups.current = omit(this.groups.current, key);
    this.CACHE.NODE_GROUP["delete"](key);
    return this;
  };

  _proto.generateGroup = function generateGroup(element, isCollapsed) {
    var _this3 = this;

    if (isCollapsed === void 0) {
      isCollapsed = false;
    }

    var group = this.controller.run('generateGroup', element);
    var currentGroup = this.getGroup(element.key); // 如果分组已经不存在，则分组列表中丢弃该分组

    if (!group && currentGroup) {
      this.groups.current = omit(this.groups.current, element.key);
    } // 若产生了新的分组，则添加该分组
    else if (group) {
        // 如果分组类型变更，则新建分组
        if ((currentGroup == null ? void 0 : currentGroup.type) !== group.type) {
          var _extends5, _extends6;

          this.groups.current = _extends({}, this.groups.current, (_extends6 = {}, _extends6[element.key] = _extends({}, group, {
            data: _extends({}, group.data, (_extends5 = {}, _extends5[GROUP_COLLAPSED_KEY] = isCollapsed, _extends5))
          }), _extends6));
        }

        var nodesInGroup = this.getNodesInGroup(element, this.getGroup(element.key));
        nodesInGroup.forEach(function (n) {
          _this3.CACHE.NODE_GROUP.set(n.key, element.key);
        });
      }

    return this;
  };

  _proto.getNodesInGroup = function getNodesInGroup(node, group) {
    var document = this.controller.value.document;
    var next = document.getNextSibling(node.key);
    var nodes = [];
    var groups = [group];
    var closestGroup = group;

    while (next && next.isElement() && closestGroup) {
      var isElementInGroup = this.controller.query('isElementInGroup', next, closestGroup);

      if (isElementInGroup !== false) {
        if (closestGroup === group) {
          nodes.push(next);
        }
      } else {
        groups.pop();
        closestGroup = groups[groups.length - 1];
        continue;
      }

      var maybeGroup = this.getGroup(next.key);

      if (maybeGroup) {
        groups.push(maybeGroup);
        closestGroup = maybeGroup;
      }

      next = document.getNextSibling(next.key);
    }

    return nodes;
  };

  _proto.regenerateGroupFrom = function regenerateGroupFrom(node, isCollapsed) {
    if (isCollapsed === void 0) {
      isCollapsed = false;
    }

    if (!node || !node.isElement()) {
      return this;
    }

    var document = this.controller.value.document; // 对变更节点所在的前序分组进行重新分组

    while (node) {
      this.generateGroup(node, isCollapsed);
      node = document.getPreviousSibling(node.key);
    }

    return this;
  };

  return GroupManager;
}();

/**
 * 获得不可见节点序列，按照距离可见节点的次序排序
 *
 * ```ts
 * // document.nodes: ['1', '2', '3', '4', '5', '6', '7'];
 *
 * const invisibles = getInvisibles(document, ['3', '4']);
 * // invisibles: ['7', '6', '1', '5',  '2']
 * ```
 * @param document
 * @param visibles
 * @returns
 */
function getInsivibleNodes(document, visibles) {
  if (!visibles.length) {
    return [];
  }

  var invisibles = [];
  var start = visibles[0];
  var end = visibles[visibles.length - 1];
  var topHalfInvisibles = takeWhile(document.nodes, function (n) {
    return n.key !== start;
  });
  var bottomHalfInvisibles = takeRightWhile(document.nodes, function (n) {
    return n.key !== end;
  }).reverse();

  while (topHalfInvisibles.length || bottomHalfInvisibles.length) {
    if (topHalfInvisibles.length) {
      invisibles.push(topHalfInvisibles.pop());
    }

    if (bottomHalfInvisibles.length) {
      invisibles.push(bottomHalfInvisibles.pop());
    }
  }

  return invisibles.reverse();
}

function _createForOfIteratorHelperLoose$4(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray$4(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$4(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }

function _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function jsonMLGetDescription(asl, options) {
  // 仅最外层会用到currParagraph
  var currParagraph = asl[0] === 'root' ? 0 : null;
  var children = jsonMLGetChildren(asl);
  var validChildren = [];

  if (!Array.isArray(children)) {
    return asl;
  }

  for (var _iterator = _createForOfIteratorHelperLoose$4(children), _step; !(_step = _iterator()).done;) {
    var childAsl = _step.value;

    if (typeof currParagraph === 'number') {
      currParagraph++;

      if (options && typeof options.maxParagraph === 'number' && currParagraph > options.maxParagraph) {
        break;
      }
    }

    if (!(options && Array.isArray(options.ignore) && options.ignore.includes(childAsl[0]))) {
      validChildren.push(jsonMLGetDescription(childAsl, options));
    }
  }

  return [].concat(jsonMLGetTagNameAndAttributes(asl), validChildren);
}
function jsonMLGetTagName(elem) {
  return elem[0] || '';
}

function isElement(maybeElem) {
  return Array.isArray(maybeElem) && typeof maybeElem[0] === 'string' || typeof maybeElem === 'string';
}

function isAttributes(maybeAttrs) {
  return !!maybeAttrs && typeof maybeAttrs === 'object' && !Array.isArray(maybeAttrs);
}

function jsonMLGetLastChild(node) {
  var children = jsonMLGetChildren(node);
  return children.length ? children[children.length - 1] : null;
}
function JsonMLHasAttributes(maybeElem) {
  return isElement(maybeElem) && isAttributes(maybeElem[1]);
}
function jsonMLGetAttributes(elem) {
  return JsonMLHasAttributes(elem) ? elem[1] : null;
}

function jsonMLGetTagNameAndAttributes(elem) {
  return JsonMLHasAttributes(elem) ? elem.slice(0, 2) : elem.slice(0, 1);
}

function jsonMLGetChildren(elem) {
  return JsonMLHasAttributes(elem) ? elem.slice(2) : elem.slice(1);
}
function jsonMLAppend(elem) {
  for (var _len = arguments.length, children = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    children[_key - 1] = arguments[_key];
  }

  return [].concat(elem.slice(0), children.slice(0));
}
function jsonMLAppendAt(elem, index) {
  var meta = JsonMLHasAttributes(elem) ? elem.slice(0, 2) : elem.slice(0, 1);
  var ch = jsonMLGetChildren(elem);

  for (var _len2 = arguments.length, children = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
    children[_key2 - 2] = arguments[_key2];
  }

  ch.splice.apply(ch, [index, 0].concat(children));
  return [].concat(meta, ch);
}
function jsonMLIsEmptyContent(content) {
  var children = jsonMLGetChildren(content);

  if (children.length > 1) {
    return false;
  }

  var child = children[0];

  if (!child) {
    return true;
  }

  if (jsonMLGetTagName(child) !== 'p') {
    return false;
  }

  var grandChildren = jsonMLGetChildren(child);

  if (grandChildren.length > 1) {
    return false;
  }

  var grandChild = grandChildren[0];
  var grandChildAttrs = jsonMLGetAttributes(grandChild);

  if (grandChildAttrs && grandChildAttrs['data-type'] !== 'text') {
    return false;
  }

  var grandGrandChildren = jsonMLGetChildren(grandChild);

  if (grandGrandChildren.length > 1) {
    return false;
  }

  var grandGrandChild = grandGrandChildren[0];

  if (grandGrandChild) {
    var grandGrandChildAttrs = jsonMLGetAttributes(grandGrandChild);

    if (grandGrandChildAttrs && grandGrandChildAttrs['data-type'] !== 'leaf') {
      return false;
    }

    if (jsonMLGetChildren(grandGrandChild).join('')) {
      return false;
    }
  }

  return true;
}
/**
 * 读取 asl 中的纯文本（leaf 节点）
 * @param jsonML
 */

function jsonMLGetText(jsonML) {
  // 如果当前节点是叶子节点，则直接返回字符串
  var attrs = jsonMLGetAttributes(jsonML);

  if (attrs && attrs['data-type'] === 'leaf') {
    return jsonML[2] || '';
  } // 遍历孩子节点


  var children = jsonMLGetChildren(jsonML);
  return children.reduce(function (text, child) {
    return text + jsonMLGetText(child);
  }, '');
}
function jsonMLIsText(node) {
  var _jsonMLGetAttributes;

  return jsonMLGetTagName(node) === 'span' && ((_jsonMLGetAttributes = jsonMLGetAttributes(node)) == null ? void 0 : _jsonMLGetAttributes['data-type']) === 'text';
}

function isElementValue(node) {
  return Element$1.isElement(node);
}
function isDocumentValue(node) {
  return Document.isDocument(node);
}

/**
 * @export
 * @param {NamedNodeMap} attrs
 * @description 将 Node 节点的 attributes 属性转成 JSON 对象
 */

function nodeMapToObject(attrs) {
  var obj = {
    styleObj: {}
  };

  for (var i = attrs.length - 1; i >= 0; i--) {
    if (attrs[i].value !== '') {
      obj[attrs[i].name] = attrs[i].value;
    }
  }

  return obj;
}
/**
 * @export
 * @param {string} [styleStr='']
 * @return {*}  {Partial<CSSStyleDeclaration>}
 * @description 将 inlineStyle 字符串转为 驼峰格式的 JSON 对象
 */

function toStyleObject(styleStr) {
  if (styleStr === void 0) {
    styleStr = '';
  }

  if (!styleStr) {
    return {};
  }

  var output = {};
  var style = styleStr.split(';');

  for (var i = style.length - 1; i >= 0; i--) {
    var rule = style[i];

    if (rule) {
      var kv = rule.split(':');
      output[camelCase(trim(kv[0] || ''))] = trim(kv[1] || '');
    }
  }

  return output;
}
/**
 * @export
 * @param {string} str
 * @return {*}
 */

function normalizeSpacesInHTML(str) {
  return str.replace(/\s*\n\s*/g, '');
}

function createTextWithString(text) {
  return ['span', {
    'data-type': 'text'
  }, ['span', {
    'data-type': 'leaf'
  }, text]];
}
var createEmptyText = function createEmptyText() {
  return createTextWithString('');
};

function createEmptyParagraph(type) {
  if (type === void 0) {
    type = 'p';
  }

  return [type, createTextWithString('')];
}

function createJsonMLToValue$1(jsonMLToNode, strictSchema) {
  /**
   * 序列化整个 ASL 文档
   * @param jsonML content ASL
   * @param options 序列化参数
   */
  function jsonMLToValue(jsonML, options) {
    if (options === void 0) {
      options = {};
    }

    var children = jsonMLGetChildren(jsonML);
    var newJsonML = jsonML;

    if (!(children && children.length > 0)) {
      newJsonML = jsonMLAppend(jsonML, createEmptyParagraph());
    }

    var document = jsonMLToNode(newJsonML); // 非 document 节点直接抛错

    if (!isDocumentValue(document)) {
      throw new Error("Invalid jsonML, expect a document at the root of jsonML, but received " + JSON.stringify(jsonML, null, 2));
    }

    var value = Value.create({
      document: document
    });
    var _options = options,
        _options$normalize = _options.normalize,
        normalize = _options$normalize === void 0 ? true : _options$normalize,
        _options$strict = _options.strict,
        strict = _options$strict === void 0 ? false : _options$strict;
    var toNormalize = normalize || strict;
    if (!toNormalize) return value; // 加载一个 scheme plugin 对 value 进行 normalize

    var schemaPlugin = strict ? [{
      schema: strictSchema,
      models: []
    }] : [];
    var controller = Controller.create({
      value: value,
      plugins: schemaPlugin
    });
    return controller.value;
  }

  return jsonMLToValue;
}

function createAsyncValueToJsonML(asyncNodeToJsonML) {
  /**
   * 序列化 value to ASL
   * @param value
   */
  function valueToJsonML(_x) {
    return _valueToJsonML.apply(this, arguments);
  }

  function _valueToJsonML() {
    _valueToJsonML = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(value) {
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", asyncNodeToJsonML(value.document));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _valueToJsonML.apply(this, arguments);
  }

  return valueToJsonML;
}
function createValueToJsonML$1(nodeToJsonML) {
  /**
   * 序列化 value to ASL
   * @param value
   */
  function valueToJsonML(value) {
    return nodeToJsonML(value.document);
  }

  return valueToJsonML;
}

function createJsonMLToNode(plugins) {
  var rules = plugins.map(function (plugin) {
    return plugin.jsonMLToValue;
  }).filter(function (rule) {
    return !!rule;
  });
  return function jsonMLToNode(jsonML, parent) {
    var rule = rules.find(function (r) {
      return r.match(jsonML, parent);
    });

    if (!rule) {
      throw new Error("Cannot find any rule which match " + JSON.stringify(jsonML, null, 2));
    }

    var node = rule.convert(jsonML, parent); // Only element value has nodes children

    if (isElementValue(node)) {
      var children = jsonMLGetChildren(jsonML);
      node = node.merge({
        nodes: children.map(function (c) {
          return jsonMLToNode(c, jsonML);
        })
      });
    }

    node = rule.decorate ? rule.decorate(node) : node;
    return node;
  };
}

function safeAppend(elem, children) {
  // BACKGROUND: Safari 下，`...children` 结果可能出现 null child
  if (IS_SAFARI) {
    return elem.slice(0).concat(children.slice(0));
  }

  return jsonMLAppend.apply(void 0, [elem].concat(children));
}

function createAsyncNodeToJsonML(plugins) {
  var rules = plugins.map(function (plugin) {
    return plugin.valueToJsonML;
  }).filter(function (rule) {
    return !!rule;
  });
  /**
   * 序列化 node to jsonML
   * @param node
   */

  function nodeToJsonML(_x) {
    return _nodeToJsonML.apply(this, arguments);
  }

  function _nodeToJsonML() {
    _nodeToJsonML = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(node) {
      var rule, _node$toJSON, klass, type, decorated, jsonML, _node$toJSON2, _klass, _type, children;

      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              rule = rules.find(function (r) {
                return r.match(node);
              });

              if (rule) {
                _context.next = 4;
                break;
              }

              _node$toJSON = node.toJSON(), klass = _node$toJSON.klass, type = _node$toJSON.type;
              throw new Error("Cannot find any rule which match " + JSON.stringify({
                klass: klass,
                type: type
              }));

            case 4:
              decorated = rule.decorate ? rule.decorate(node) : node;

              if (!rule.asyncConvert) {
                _context.next = 11;
                break;
              }

              _context.next = 8;
              return rule.asyncConvert(decorated);

            case 8:
              jsonML = _context.sent;
              _context.next = 12;
              break;

            case 11:
              jsonML = rule.convert(decorated);

            case 12:
              if (jsonML) {
                _context.next = 15;
                break;
              }

              _node$toJSON2 = node.toJSON(), _klass = _node$toJSON2.klass, _type = _node$toJSON2.type;
              throw new Error("Invalid JsonML! JsonML is " + JSON.stringify({
                klass: _klass,
                type: _type
              }));

            case 15:
              if (!isElementValue(decorated)) {
                _context.next = 20;
                break;
              }

              _context.next = 18;
              return Promise.all(decorated.nodes.map(function (child) {
                return nodeToJsonML(child);
              }));

            case 18:
              children = _context.sent;
              return _context.abrupt("return", safeAppend(jsonML, children));

            case 20:
              return _context.abrupt("return", jsonML);

            case 21:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _nodeToJsonML.apply(this, arguments);
  }

  return nodeToJsonML;
}
function createNodeToJsonML(plugins) {
  var rules = plugins.map(function (plugin) {
    return plugin.valueToJsonML;
  }).filter(function (rule) {
    return !!rule;
  });
  /**
   * 序列化 node to jsonML
   * @param node
   */

  function nodeToJsonML(node) {
    var rule = rules.find(function (r) {
      return r.match(node);
    });

    if (!rule) {
      var _node$toJSON3 = node.toJSON(),
          klass = _node$toJSON3.klass,
          type = _node$toJSON3.type;

      throw new Error("Cannot find any rule which match " + JSON.stringify({
        klass: klass,
        type: type
      }));
    }

    var decorated = rule.decorate ? rule.decorate(node) : node;
    var jsonML = rule.convert(decorated);

    if (!jsonML) {
      var _node$toJSON4 = node.toJSON(),
          _klass2 = _node$toJSON4.klass,
          _type2 = _node$toJSON4.type;

      throw new Error("Invalid JsonML! JsonML is " + JSON.stringify({
        klass: _klass2,
        type: _type2
      }));
    } // Only element value has nodes children


    if (isElementValue(decorated)) {
      var children = decorated.nodes.map(function (child) {
        return nodeToJsonML(child);
      });
      return safeAppend(jsonML, children);
    }

    return jsonML;
  }

  return nodeToJsonML;
}

var MeasureStyle = {
  left: '-999px',
  position: 'absolute',
  visibility: 'hidden',
  whiteSpace: 'nowrap',
  zIndex: -999
};
var createIframe = function createIframe() {
  var iframe = document.createElement('iframe');

  for (var type in MeasureStyle) {
    iframe.style[type] = MeasureStyle[type];
  } // 开启沙盒模式，防止 xss 攻击


  iframe.setAttribute('sandbox', 'allow-same-origin');
  return iframe;
};

var DomParser = function DomParser() {
  var _this = this;

  this.domParser = new DOMParser();
  this.doc = void 0;
  this.skipTags = ['HEAD', 'STYLE'];
  this.state = void 0;
  this.onOpenTag = void 0;
  this.onText = void 0;
  this.onCloseTag = void 0;
  this.iframe = createIframe();

  this.init = function (callback, options) {
    var onOpenTag = callback.onOpenTag,
        onText = callback.onText,
        onCloseTag = callback.onCloseTag;
    _this.onOpenTag = onOpenTag;
    _this.onText = onText;
    _this.onCloseTag = onCloseTag;
    _this.state = options.state;
  };

  this.write = function (chunk) {
    document.body.appendChild(_this.iframe);
    _this.doc = _this.iframe.contentDocument;

    if (_this.doc.body) {
      _this.doc.body.innerHTML = chunk;
    }

    if (_this.state) {
      _this.state.htmlDom = _this.doc.body;
    }

    _this.traverse(_this.doc.body);

    document.body.removeChild(_this.iframe);
  };

  this.end = function () {
    _this.doc = null;
    _this.onOpenTag = null;
    _this.onText = null;
    _this.onCloseTag = null;
  };

  this.traverse = function (node) {
    if (!_this.onText || !_this.onOpenTag || !_this.onCloseTag) {
      return;
    }

    if (node.nodeType === Node.TEXT_NODE) {
      if (node.textContent && normalizeSpacesInHTML(node.textContent)) {
        _this.onText(node.textContent);
      }

      return;
    }

    if ([Node.ELEMENT_NODE, Node.DOCUMENT_NODE, Node.DOCUMENT_FRAGMENT_NODE].includes(node.nodeType)) {
      var _ref = node,
          originTagName = _ref.tagName,
          attributes = _ref.attributes;

      if (_this.skipTags.includes(originTagName)) {
        return;
      }

      var traverseChildNodes = function traverseChildNodes() {
        Array.from(node.childNodes || []).forEach(function (child) {
          _this.traverse(child);
        });
      };

      if (originTagName) {
        var tagName = originTagName.toLowerCase();
        var attrs = nodeMapToObject(attributes);
        var element = node;
        attrs.styleObj = window.getComputedStyle(element);
        var id = v1();

        if (_this.state) {
          _this.state.currentDom = element;
        }

        _this.onOpenTag(tagName, attrs, id);

        traverseChildNodes();

        _this.onCloseTag(tagName, attrs, id);
      } else {
        traverseChildNodes();
      }
    }
  };
};

var State = /*#__PURE__*/function () {
  // 这里用于记录zhi渲染的list的level, TODO 需要和getListLevel统一
  function State(props) {
    this.root = ['root'];
    this.current = this.root;
    this.stack = [];
    this.marksList = [];
    this.listsList = [];
    this.htmlDom = void 0;
    this.currentDom = void 0;
    this.currentListId = null;
    this.currentListLevel = null;

    if (props.htmlDom) {
      this.htmlDom = props.htmlDom;
    }
  }

  var _proto = State.prototype;

  _proto.addMarks = function addMarks(marks) {
    this.marksList.push(marks);
  };

  _proto.removeMarks = function removeMarks(marks) {
    this.marksList = this.marksList.filter(function (m) {
      return m.id !== marks.id;
    });
  };

  _proto.getMarks = function getMarks() {
    return this.marksList.reduce(function (attrs, marks) {
      return _extends({}, attrs, marks.value);
    }, {});
  };

  _proto.wrapList = function wrapList(type) {
    this.listsList.push(type);
  };

  _proto.unwrapList = function unwrapList() {
    this.listsList.pop();
  };

  _proto.isParentOrderedList = function isParentOrderedList() {
    return this.listsList[this.listsList.length - 1] === 'ordered-list';
  };

  _proto.getListItemLevel = function getListItemLevel() {
    return this.listsList.length - 1;
  };

  _proto.append = function append() {
    var _this = this;

    for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {
      nodes[_key] = arguments[_key];
    }

    nodes.forEach(function (node) {
      _this.current.push(node);
    });
  };

  _proto.push = function push(node) {
    this.stack.push(this.current);
    this.current = node;
  };

  _proto.pop = function pop() {
    var node = this.current;
    this.current = this.stack.pop() || this.root;
    return node;
  };

  _proto.peek = function peek() {
    return this.current;
  };

  _proto.closest = function closest(type) {
    if (jsonMLGetTagName(this.current) === type) {
      return this.current;
    }

    for (var i = this.stack.length - 1; i >= 0; i -= 1) {
      if (jsonMLGetTagName(this.stack[i]) === type) {
        return this.stack[i];
      }
    }

    return null;
  };

  _proto.isStackEmpty = function isStackEmpty() {
    return this.stack.length === 0;
  };

  _proto.getParent = function getParent() {
    return this.stack.length > 0 ? this.stack[this.stack.length - 1] : null;
  };

  _proto.getJsonML = function getJsonML() {
    return this.root;
  };

  return State;
}();

var Deserializer = /*#__PURE__*/function () {
  function Deserializer(options) {
    this.plugins = void 0;
    this.htmlFrom = void 0;
    this.parser = void 0;
    this.iframe = createIframe();
    this.plugins = options.plugins;
    this.htmlFrom = options.htmlFrom;
    this.parser = options.parser || new DomParser();
  }

  var _proto = Deserializer.prototype;

  _proto.isDomParser = function isDomParser() {
    return this.parser instanceof DomParser;
  };

  _proto.deserialize = function deserialize(html, configs) {
    var _this = this;

    if (configs === void 0) {
      configs = {};
    }

    var state = new State({});

    if (!this.isDomParser()) {
      document.body.appendChild(this.iframe);
      var _ref = this.iframe.contentDocument,
          htmlDom = _ref.body;

      if (htmlDom) {
        htmlDom.innerHTML = html;
      }

      state.htmlDom = htmlDom;
    }

    var rules = this.plugins.map(function (plugin) {
      var htmlToJsonML = plugin.htmlToJsonML;

      if (htmlToJsonML) {
        return typeof htmlToJsonML === 'function' ? htmlToJsonML(_this.htmlFrom) : htmlToJsonML;
      }

      return null;
    }).filter(function (rule) {
      return !!rule;
    });
    rules = rules.map(function (rule) {
      if (!!rule.name && rule.name in configs) {
        rule = _extends({}, rule, configs[rule.name]);
      }

      return rule;
    });

    function onEvent(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      for (var i = 0; i < rules.length; i += 1) {
        var rule = rules[i][event];

        if (!rule) {
          continue; // eslint-disable-line no-continue
        } // @ts-ignore


        var ok = rule.apply(void 0, [state].concat(args));
        if (ok) break;
      }
    }

    this.parser.init({
      onOpenTag: function onOpenTag() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        onEvent.apply(void 0, ['onOpenTag'].concat(args));
      },
      onText: function onText() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        onEvent.apply(void 0, ['onText'].concat(args));
      },
      onCloseTag: function onCloseTag() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        onEvent.apply(void 0, ['onCloseTag'].concat(args));
      }
    }, {
      decodeEntities: true,
      state: state
    });
    this.parser.write(html);
    this.parser.end();

    if (!this.isDomParser()) {
      document.body.removeChild(this.iframe);
    }

    return state.getJsonML();
  };

  return Deserializer;
}();

var MS_WORD = 'MS_WORD';
var MS_EXCEL = 'MS_EXCEL'; // word、excel 以外的 office

var MS_OFFICE = 'MS_OFFICE';
var MS_OFFICES = [MS_WORD, MS_EXCEL, MS_OFFICE];
var YUQUE = 'YUQUE'; // 以下复制来源，保留所有样式

var REMAIN_STYLE_SOURCES = [MS_WORD, MS_EXCEL, MS_OFFICE, YUQUE];
function isMicrosoftWord(html) {
  return Boolean(html == null ? void 0 : html.includes('xmlns:w="urn:schemas-microsoft-com:office:word"'));
}
function isMicrosoftExcel(html) {
  return Boolean(html == null ? void 0 : html.includes('xmlns:x="urn:schemas-microsoft-com:office:excel"'));
}
function isMicrosoftOffice(html) {
  return Boolean(html == null ? void 0 : html.includes('xmlns:x="urn:schemas-microsoft-com"'));
}
function isYuqueDocs(html) {
  return Boolean((html == null ? void 0 : html.includes('<meta name="source" content="lake"/>')) || (html == null ? void 0 : html.includes('class="lake-content"')));
}
function getHtmlFrom(html) {
  if (isMicrosoftWord(html)) {
    return MS_WORD;
  }

  if (isMicrosoftExcel(html)) {
    return MS_EXCEL;
  }

  if (isMicrosoftOffice(html)) {
    return MS_OFFICE;
  }

  if (isYuqueDocs(html)) {
    return YUQUE;
  }

  return 'web';
}

function getJsonMLFromAttr(root) {
  var clipboardDataNode = root.querySelector("[" + DATA_CLIPBORAD_CANGJIE + "]");
  /**
   * 需要判断数据节点是否是第一个，防止一些 html 夹杂着无用的 data-clipboard-data 节点，导致误解析
   */

  if (clipboardDataNode && root.body.firstElementChild === clipboardDataNode) {
    var clipboardData = clipboardDataNode.getAttribute(DATA_CLIPBORAD_CANGJIE);

    try {
      return JSON.parse(clipboardData);
    } catch (e) {
      // @ali/4ever-logger 依赖库里面有浏览器环境依赖，导致 server cp 脚本无法运行
      console.error(e);
    }
  }

  return null;
}

function createHtmlToJsonML(plugins, parser) {
  return function htmlToJsonML(html, configs) {
    if (configs === void 0) {
      configs = {};
    }

    var htmlFrom = getHtmlFrom(html);
    var domParser = new DOMParser();
    var parsedDocument = domParser.parseFromString(html, 'text/html');
    var domJsonML = getJsonMLFromAttr(parsedDocument);
    if (domJsonML) return domJsonML;
    var deserializer = new Deserializer({
      plugins: plugins,
      htmlFrom: htmlFrom,
      parser: parser
    });
    var parsedHTML = parsedDocument.lastElementChild;
    return deserializer.deserialize(parsedHTML.outerHTML, configs);
  };
}

var _createElement$i = React.createElement;

function jsonMLToHTML$1(props, node, path) {
  if (path === void 0) {
    path = [];
  }

  var rules = props.rules;
  var rule = rules.find(function (r) {
    return r.match(node);
  });

  if (!rule) {
    rule = {
      name: 'default',
      match: function match() {
        return false;
      },
      convert: function convert(node, key, _convert) {
        if (key === void 0) {
          key = [];
        }

        var children = jsonMLGetChildren(node).map(function (child, index) {
          return _convert(child, [].concat(key, [index]));
        });
        return /*#__PURE__*/_createElement$i(React.Fragment, null, children);
      }
    };
  }

  var convert = function convert() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return jsonMLToHTML$1.apply(void 0, [props].concat(args));
  };

  var element = rule.convert(node, path, convert);
  if (!element) return null;
  var elementWithKey = /*#__PURE__*/React.isValidElement(element) ? /*#__PURE__*/React.cloneElement(element, {
    key: (element.props.path || []).toString()
  }) : element;
  return elementWithKey;
}

function HTMLProvider(props) {
  var content = props.content;
      props.rules;
      var rest = _objectWithoutPropertiesLoose(props, ["content", "rules"]);

  var elem = jsonMLToHTML$1(props, content);
  if (!elem) return null;
  return /*#__PURE__*/React.cloneElement(elem, rest);
}

function createJsonMLToHTML$1(plugins) {
  // 遍历取出 jsonMLToHTML 插件
  var defaultRules = plugins.map(function (plugin) {
    return plugin.jsonMLToHTML;
  }).filter(function (rule) {
    return !!rule;
  });
  /**
   * 序列化 JsonML to HTML，主要适用于富文本拷贝导出
   * @param content JsonML 内容
   * @param configs 自定义插件，如果插件名已经存在，则会覆盖原插件的方法
   */

  function contentJsonMLToHTML(content, configs) {
    if (configs === void 0) {
      configs = {};
    }

    // 加载 configs 中的插件
    var rules = defaultRules.map(function (rule) {
      if (rule.name in configs) {
        return _extends({}, rule, configs[rule.name]);
      }

      return rule;
    });
    var before = plugins.map(function (p) {
      var _p$jsonMLToHTML, _p$jsonMLToHTML$hooks;

      return (_p$jsonMLToHTML = p.jsonMLToHTML) == null ? void 0 : (_p$jsonMLToHTML$hooks = _p$jsonMLToHTML.hooks) == null ? void 0 : _p$jsonMLToHTML$hooks.before;
    }).filter(function (p) {
      return !!p;
    }).reduce(function (acc, p) {
      return function (value) {
        return p(acc(value));
      };
    }, function (value) {
      return value;
    });

    var elem = _createElement$i(HTMLProvider, {
      content: before(content),
      rules: rules
    });

    return ReactDOMServer.renderToStaticMarkup(elem);
  }

  return contentJsonMLToHTML;
}

var NEWLINE = '\n';
function createTextToJsonML(plugins) {
  var rules = plugins.map(function (plugin) {
    return plugin.textToJsonML;
  }).filter(function (rule) {
    return !!rule;
  });
  /**
   * 纯文本序列化成 ASL
   * @param text
   */

  function textToJsonML(text) {
    return normalizeText$2(text).split(NEWLINE).reduce(function (jsonML, line) {
      var rule = rules.find(function (r) {
        return r.match(line);
      });
      var children;

      if (rule) {
        children = rule.convert(line) || [];
      } else {
        children = [createTextWithString(line)];
      }

      var paragraph = jsonMLAppend.apply(void 0, [['p']].concat(children));
      return jsonMLAppend(jsonML, paragraph);
    }, ['root']);
  }

  return textToJsonML;
}

function createNodeToText(plugins) {
  var rules = plugins.map(function (plugin) {
    return plugin.valueToText;
  }).filter(function (rule) {
    return !!rule;
  });

  function nodeToText(node) {
    var rule = rules.find(function (item) {
      return item.match(node);
    });

    if (!rule) {
      rule = {
        name: 'default',
        match: function match() {
          return false;
        },
        convert: function convert(n) {
          var text = n.text; // 块级元素在末尾追加换行

          if (Block.isBlock(node)) {
            return text + "\n";
          }

          return text;
        }
      };
    }

    var text = rule.convert(node, nodeToText);
    return text;
  }

  return nodeToText;
}

function createValueToText$1(nodeToText, injectValueData) {
  if (injectValueData === void 0) {
    injectValueData = function injectValueData(v) {
      return v;
    };
  }

  function valueToText(value) {
    // 计算好 injection
    var injectedValue = injectValueData(value);
    var texts = injectedValue.document.nodes.map(function (node) {
      return nodeToText(node);
    });
    var text = texts.join(''); // 末尾处的断行要移除掉
    // block 节点会附带一个 \n，但是用户选区中的断行需要保留，所以这里只移除一个 \n

    if (text.endsWith('\n')) {
      text = text.substring(0, text.length - 1);
    }
    /**
     * 从 Excel 中复制表格，纯文本粘贴会附带 \t,当 \t 足够多时会造成渲染性能问题。
     * https://notes.dingtalk.com/doc/E0Vzg7l3wnjKAzJe?orgId=16872003&dd_progress=false&showmenu=false
     * */


    text = text.replace(/\t+/g, '    ');
    return text;
  }

  return valueToText;
}

function _createForOfIteratorHelperLoose$3(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }

function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var markdownRuleNameMap = {
  table: ['table'],
  code: ['code', 'fence'],
  blockquote: ['blockquote'],
  hr: ['hr'],
  list: ['list'],
  heading: ['heading', 'lheading'],
  codespan: ['backticks'],
  strikethrough: ['strikethrough'],
  emphasis: ['emphasis'],
  link: ['link', 'autolink'],
  image: ['image'],
  html: ['html_block', 'html_inline']
};
function createMarkdownToHTML(_x) {
  return _createMarkdownToHTML.apply(this, arguments);
}

function _createMarkdownToHTML() {
  _createMarkdownToHTML = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(plugins) {
    var rules, MarkdownIt, md, summary, name, _iterator, _step, _step$value, pluginLoader, data, plugin, d, markdownToHTML;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            markdownToHTML = function _markdownToHTML(markdown) {
              var res = md.render(markdown);
              return res;
            };

            rules = plugins.map(function (plugin) {
              return plugin.markdownToHTML;
            }).filter(function (rule) {
              return !!rule;
            }); // default，从原 basic 插件迁移

            rules.push({
              ruleName: 'html',
              options: {
                html: true,
                xhtmlOut: true
              }
            }); // async loading markdown-it

            _context.next = 5;
            return import(
            /* webpackChunkName: 'cangjie-lib-markdown-it'*/
            'markdown-it');

          case 5:
            MarkdownIt = _context.sent["default"];
            md = new MarkdownIt('zero'); // 应用 rule 到 md

            summary = {
              names: [],
              options: {},
              rewrite: {},
              uses: []
            };
            rules.forEach(function (rule) {
              if (rule.ruleName) {
                var _summary$names;

                (_summary$names = summary.names).push.apply(_summary$names, markdownRuleNameMap[rule.ruleName]);
              }

              if (rule.options) {
                summary.options = _extends({}, summary.options, rule.options);
              }

              if (rule.rewrite) {
                rule.rewrite.forEach(function (_ref) {
                  var name = _ref.name,
                      createRenderer = _ref.createRenderer;

                  if (createRenderer) {
                    summary.rewrite[name] = {
                      renderer: createRenderer(md)
                    };
                  }
                });
              }

              if (rule.uses) {
                var _summary$uses;

                (_summary$uses = summary.uses).push.apply(_summary$uses, rule.uses);
              }
            });
            md.enable(summary.names).set(summary.options);

            for (name in summary.rewrite) {
              if (md.renderer.rules[name] && summary.rewrite[name].renderer) {
                md.renderer.rules[name] = summary.rewrite[name].renderer;
              }
            }

            _iterator = _createForOfIteratorHelperLoose$3(summary.uses);

          case 12:
            if ((_step = _iterator()).done) {
              _context.next = 28;
              break;
            }

            _step$value = _step.value, pluginLoader = _step$value.plugin, data = _step$value.data;
            _context.next = 16;
            return pluginLoader();

          case 16:
            plugin = _context.sent;

            if (!(typeof data === 'function')) {
              _context.next = 23;
              break;
            }

            _context.next = 20;
            return data();

          case 20:
            _context.t0 = _context.sent;
            _context.next = 24;
            break;

          case 23:
            _context.t0 = data;

          case 24:
            d = _context.t0;
            md.use.apply(md, [plugin["default"]].concat(d || []));

          case 26:
            _context.next = 12;
            break;

          case 28:
            return _context.abrupt("return", markdownToHTML);

          case 29:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _createMarkdownToHTML.apply(this, arguments);
}

function createHtmlToMarkdown(_x) {
  return _createHtmlToMarkdown.apply(this, arguments);
}

function _createHtmlToMarkdown() {
  _createHtmlToMarkdown = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(plugins) {
    var rules, Turndown, turndownService;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            rules = plugins.map(function (plugin) {
              return plugin.htmlToMarkdown;
            }).filter(function (rule) {
              return !!rule;
            });
            _context.next = 3;
            return import(
            /* webpackChunkName: 'cangjie-lib-turndown'*/
            'turndown');

          case 3:
            Turndown = _context.sent["default"];
            turndownService = new Turndown({
              headingStyle: 'atx'
            });
            rules.forEach(function (rule) {
              var pluginRule = pick(rule, ['filter', 'replacement']);

              if (!isEmpty(pluginRule)) {
                turndownService.addRule(rule.name, pluginRule);
              }

              if (rule.use) {
                turndownService.use(rule.use);
              }
            });
            return _context.abrupt("return", function (html) {
              return turndownService.turndown(html);
            });

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _createHtmlToMarkdown.apply(this, arguments);
}

var _createElement$h = React.createElement;
var jsonMLToHTML = {
  name: 'root',
  match: function match(node) {
    return jsonMLGetTagName(node) === 'root';
  },
  convert: function convert(node, key, _convert) {
    if (key === void 0) {
      key = [];
    }

    var children = jsonMLGetChildren(node).map(function (child, index) {
      return _convert(child, [].concat(key, [index]));
    });
    return /*#__PURE__*/_createElement$h("article", {
      className: "4ever-article"
    }, children);
  }
};

var jsonMLToValue = {
  name: 'document',
  match: function match(node) {
    return jsonMLGetTagName(node) === 'root';
  },
  convert: function convert(node) {
    return Document.create({
      data: jsonMLGetAttributes(node) || {}
    });
  }
};

var valueToJsonML = {
  match: function match(node) {
    return Document.isDocument(node);
  },
  convert: function convert(node) {
    return ['root', node.data];
  }
};

var schema = {
  document: {
    nodes: [{
      min: 1
    }],
    normalize: function normalize(controller, error) {
      var code = error.code,
          node = error.node;

      if (code === 'child_min_invalid' && !node.nodes.length) {
        var defaultBlock = controller.query('getDefaultBlock');

        if (!defaultBlock) {
          defaultBlock = Block.create({
            type: Block.DEFAULT_TYPE
          });
        }

        if (defaultBlock) {
          controller.command(insertNodeByKey, node.key, 0, defaultBlock);
        } else {
          throw Error('normalize error in document plugin schema, no plugin implement getDefaultBlock query');
        }
      }
    }
  }
};

var createSerializerPlugin$1 = function createSerializerPlugin() {
  return {
    jsonMLToHTML: jsonMLToHTML,
    jsonMLToValue: jsonMLToValue,
    valueToJsonML: valueToJsonML
  };
};

function createSchema(plugins) {
  var s = plugins.reduce(function (prevSchema, plugin) {
    if (!plugin.schemas) {
      return prevSchema;
    }

    var schemas = Array.isArray(plugin.schemas) ? plugin.schemas : [plugin.schemas];
    schemas.forEach(function (schema) {
      // document 是内部插件, 用到特殊定义，在内部处理
      var type = schema.type,
          isBlock = schema.isBlock,
          isVoid = schema.isVoid,
          isEdgeSelectable = schema.isEdgeSelectable,
          oldSchema = schema.schema;
      var val = {};

      if (['boolean', 'function'].includes(typeof isVoid)) {
        val.isVoid = isVoid;
      }

      if (typeof isEdgeSelectable === 'boolean') {
        val.isEdgeSelectable = isEdgeSelectable;
      }

      if (oldSchema) {
        val = _extends({}, val, oldSchema);
      }

      if (type === 'document') {
        prevSchema['document'] = _extends({}, prevSchema['document'], val);
      } else {
        prevSchema[isBlock || isBlock === undefined ? 'blocks' : 'inlines'][type] = val;
      }
    });
    return prevSchema;
  }, _extends({}, schema, {
    blocks: {},
    inlines: {}
  }));
  return s;
}
/**
 * 兼容原先 strictSchema 定义。新增的规则都在插件中指定，schema 和 strictSchema 都支持。
 * 
 * 1. document 下只能是已注册的 block type
 * 2. heading1-5, paragraph 下只能是已注册的 inline type
 * 3. table 的 schema 跟 @一辙 讨论了下， 考虑存量数据兼容，还是不在 table 里指定，保留在 strictSchema 中。
 */

function createStrictSchema(plugins) {
  var _schema$blocks2;

  var schema = createSchema(plugins);
  var blockTypes = Object.keys(schema.blocks);
  var inlineTypes = Object.keys(schema.inlines);
  schema.document = _extends({}, schema.document, {
    nodes: [{
      match: blockTypes.map(function (t) {
        return {
          type: t
        };
      }),
      min: 1
    }]
  });
  ['paragraph', 'heading-1', 'heading-2', 'heading-3', 'heading-4', 'heading-5', 'heading-6'].forEach(function (type) {
    var _schema$blocks;

    if ((_schema$blocks = schema.blocks) != null && _schema$blocks[type]) {
      schema.blocks[type] = _extends({}, schema.blocks[type], {
        nodes: [{
          match: [].concat(inlineTypes.map(function (t) {
            return {
              type: t
            };
          }), [{
            klass: 'text'
          }])
        }],
        normalize: function normalize(controller, error) {
          var code = error.code,
              child = error.child,
              node = error.node;

          if (code === 'child_type_invalid' && blockTypes.includes(child.type)) {
            var parent = controller.value.document.getParent(node.key);

            if (parent) {
              var index = parent.nodes.indexOf(node.key);
              controller.command(moveNodeByKey, child.key, parent.key, index);
            }
          }
        }
      });
    }
  }); // 指定 table 插件时的特殊处理

  if ((_schema$blocks2 = schema.blocks) != null && _schema$blocks2['table']) {
    var extra = {
      'table': {
        isEdgeSelectable: true,
        nodes: [{
          match: {
            type: 'table-row'
          },
          min: 1
        }]
      },
      'table-row': {
        nodes: [{
          match: {
            type: 'table-cell'
          },
          min: 1
        }]
      },
      'table-cell': {
        nodes: [{
          match: blockTypes.map(function (t) {
            return {
              type: t
            };
          }),
          min: 1
        }],
        normalize: function normalize(controller, error) {
          var code = error.code,
              child = error.child,
              node = error.node;

          if (code === 'child_type_invalid' && node.nodes.length === 1) {
            controller.command(removeNodeByKey, child.key);
            var defaultBlock = controller.query('getDefaultBlock', node.nodes);

            if (!defaultBlock) {
              if (!defaultBlock) {
                defaultBlock = Block.create({
                  type: Block.DEFAULT_TYPE
                });
              }
            }

            controller.command(insertNodeByKey, node.key, 0, defaultBlock);
          } else if (!node.nodes.length) {
            var _defaultBlock = Block.create({
              type: 'paragraph'
            });

            if (!_defaultBlock) {
              _defaultBlock = Block.create({
                type: Block.DEFAULT_TYPE
              });
            }

            controller.command(insertNodeByKey, node.key, 0, _defaultBlock);
          } else {
            controller.command(removeNodeByKey, child.key);
            var index = node.nodes.indexOf(child);

            for (var i = index + 1; i < node.nodes.length - 1; i++) {
              var c = node.nodes[i];

              if (!blockTypes.includes(c.type)) {
                controller.command(removeNodeByKey, c.key);
              }
            }
          }
        }
      }
    };
    Object.keys(extra).forEach(function (type) {
      schema.blocks[type] = _extends({}, schema.blocks[type] || {}, extra[type]);
    });
  }

  return schema;
}

/**
 * 一般使用的有两种空白符，空格敲击的空白符（Simple space）码点是 32，Non-breaking space 的码点是 160
 * 在 Word 的规范中，32 码点的字符会被裁剪掉，160 码点会保留，裁剪规则如下：
 * - 文字头端的所有连续 32 码点空白符会被全部裁剪（同时也包括了 \n 符号）；
 * - 文字中端和尾端的所有连续 32 码点空白符会合并（Collapse）成一个空白符；
 * @see https://stackoverflow.com/questions/11984029/difference-between-32-and-nbsp
 */

var SIMPLE_SPACE_CODE = 32; // \n 符号

var BREAK_CODE = 10; // 需要被替换为\n的字符
var HEAD_TAG_REG = /^h\d$/i; // TODO: 兼容原 text 插件逻辑，待重构

var paragraphTags = {
  h1: 'h1',
  h2: 'h2',
  h3: 'h3',
  h4: 'h4',
  h5: 'h5',
  h6: 'h6',
  p: 'p',
  div: 'p',
  section: 'p'
}; // 解析非文档 html, 使用仓颉默认的字体大小等样式

function normalizeMarks(tagName, marks) {
  if (HEAD_TAG_REG.test(tagName)) {
    return omit(marks, ['vertAlign', 'sz', 'szUnit']);
  }

  return marks;
}
/**
 * Normalize 一行文本，剔除文本前面的空白符
 * @note 注意 Word 的规范中只会对 text/html 中的空白符进行裁剪，text/plain 中的空白符会保留
 * @param text
 */


function normalizeText$1(text) {
  var index = 0;

  for (; index < text.length; index++) {
    var code = text.charCodeAt(index);

    if (code === SIMPLE_SPACE_CODE || // 空格符号过滤
    code === BREAK_CODE // 断行符号过滤
    ) {
        continue;
      }

    break;
  } // 裁剪头端所有的空格符和断行符


  text = text.slice(index, text.length); // 合并中端和尾端的空格符

  text = text.replace(/ +/g, String.fromCharCode(SIMPLE_SPACE_CODE));
  return normalizeText$2(text);
}

function createHTMLToJsonML(htmlToAttrs) {

  var converts = htmlToAttrs.filter(function (f) {
    return !!f;
  });

  function generateMarks(tag, attrs) {
    var marks = converts.reduce(function (prev, convert) {
      return convert(tag, _extends({}, attrs), _extends({}, prev));
    }, {});
    return isEmpty(marks) ? null : marks;
  }

  return function (pasteFrom) {
    return {
      name: 'text',
      onOpenTag: function onOpenTag(state, name, attrs, id) {
        var marks = generateMarks(name, attrs);

        if (marks) {
          state.addMarks({
            id: id,
            value: marks
          }); // fall through
        }

        return false;
      },
      onText: function onText(state, text) {
        var texts = [text]; // ['p']

        var parent = state.peek(); // ['span', { 'data-type': 'text' }]

        var prevSibling = jsonMLGetLastChild(parent);
        var parentTagName = jsonMLGetTagName(parent); // TODO 待改造

        if (!paragraphTags[parentTagName] && parentTagName !== 'a' && parentTagName !== 'inlineCode') {
          if (!prevSibling || !prevSibling.isPhantom) {
            var phantom = ['p'];
            phantom.isPhantom = true;
            parent = phantom;
            prevSibling = null;
            state.append(phantom);
          } else {
            parent = prevSibling;
            prevSibling = jsonMLGetLastChild(parent);
          }
        } // \n 只有出现在 a 及 p 中才被转换


        if (MS_OFFICES.includes(pasteFrom)) {
          // office 中的 \n 没有包含在 white-space: pre 中，统一作空格字符串使用
          texts = texts.map(function (txt) {
            return txt.replace(/\n/g, ' ');
          });
        }

        var marks = state.getMarks();
        var parentType = parent[0];

        if (HEAD_TAG_REG.test(parentType) && !REMAIN_STYLE_SOURCES.includes(pasteFrom)) {
          marks = normalizeMarks(parentType, marks);
        }

        var leafAttrs = _extends({}, marks, {
          'data-type': 'leaf'
        }); // 如果 p 下面没有 text 节点


        if (!prevSibling || !jsonMLIsText(prevSibling)) {
          prevSibling = ['span', {
            'data-type': 'text'
          }];
          parent.push(prevSibling);
        }

        texts.forEach(function (txt, index) {

          var prevLeaf = jsonMLGetLastChild(prevSibling); // 如果是空段落，则 normalize text

          if (!prevLeaf || jsonMLGetText(parent) === '') {
            txt = normalizeText$1(txt);
          }

          var leaf = ['span', leafAttrs, txt]; // 如果是空 text 或者与上一个 leaf 属性不匹配，则 push

          if (!prevLeaf || !equal(leafAttrs, jsonMLGetAttributes(prevLeaf))) {
            prevSibling.push(leaf);
          } else {
            // 相同属性的 leaf 则 concat
            prevLeaf[prevLeaf.length - 1] += txt;
          }
        });
        return false;
      },
      onCloseTag: function onCloseTag(state, name, attrs, id) {
        state.removeMarks({
          id: id
        }); // fall through

        return false;
      }
    };
  };
}

function attrsToMarks(attrs, converts) {
  var handledKeys = new Set();
  var marks = converts.reduce(function (prev, convert) {
    var rst = convert(attrs);
    if (!rst) return [].concat(prev);
    var keys = rst.keys,
        marks = rst.marks;
    keys.forEach(function (k) {
      return handledKeys.add(k);
    });
    return [].concat(prev, marks);
  }, []);
  var restKeys = Object.keys(attrs).filter(function (k) {
    return k !== 'data-type' && !handledKeys.has(k);
  });
  restKeys.forEach(function (key) {
    var data = attrs[key];
    var markData = data;
    var isObj = typeof data === 'object' && !!data && !Array.isArray(data);

    if (!isObj) {
      // not a object
      markData = {
        value: data
      };
    }

    marks.push({
      type: key,
      data: markData
    });
  });
  return marks;
}

function createJsonMLToValue(attrToMarks) {
  var converts = attrToMarks.filter(function (f) {
    return !!f;
  });
  var rule = {
    name: 'text',
    match: function match(node) {
      return jsonMLIsText(node);
    },
    convert: function convert(node) {
      return Text$1.create({
        // @ts-ignore 
        leaves: jsonMLGetChildren(node).map(function (leaf) {
          var marks = attrsToMarks(jsonMLGetAttributes(leaf), converts);
          return {
            text: String(jsonMLGetChildren(leaf)[0]),
            marks: marks
          };
        })
      });
    }
  };
  return rule;
}

var _createElement$g = React.createElement;

/**
 * 在 Word 的 CCP 导出规范中，文档中的空白符（Simple space）在 text/html 中会全部替换成 &nbsp;（码点 160）
 * 在导出 text/plain 中，则会保留 Simple space 的码点（32）
 */
var NON_BREAKING_SPACE_CODE = 160;

function normalizeText(text) {
  text = text.replace(/ /g, String.fromCharCode(NON_BREAKING_SPACE_CODE));
  return text;
}

function createLeafToElement(jsonMLAttrsToStyles) {
  return function (leaf, key) {
    var attrs = jsonMLGetAttributes(leaf) || {};
    var style = jsonMLAttrsToStyles.reduce(function (prev, attrToStyle) {
      return attrToStyle(_extends({}, attrs), _extends({}, prev));
    }, {}); // dataType 不需要透出给插件处理，兼容一下旧的 inlineCode

    var dataType = attrs.inlineCode ? 'inlineCode' : 'text';
    var text = normalizeText(jsonMLGetChildren(leaf)[0]);
    return /*#__PURE__*/_createElement$g("span", {
      "data-type": dataType,
      style: style,
      key: key.toString()
    }, text);
  };
}

function createJsonMLToHTML(jsonMLAttrsToStyles) {
  var leafToElement = createLeafToElement(jsonMLAttrsToStyles.filter(function (f) {
    return !!f;
  }));
  return {
    name: 'text',
    match: function match(node) {
      return jsonMLIsText(node);
    },
    convert: function convert(node, key) {
      var children = jsonMLGetChildren(node).map(function (leaf, index) {
        return leafToElement(leaf, [].concat(key, [index]));
      });
      return /*#__PURE__*/_createElement$g(React.Fragment, null, children);
    }
  };
}

function marksToAttrs(marks, converts) {
  return marks.reduce(function (attrs, mark) {
    var textMark;

    for (var i = 0, len = converts.length; i < len; i++) {
      var m = converts[i](mark);

      if (m) {
        textMark = m;
        break;
      }
    }

    if (!textMark) {
      var _textMark;

      textMark = (_textMark = {}, _textMark[mark.type] = mark.data, _textMark);
    }

    return _extends({}, attrs, textMark);
  }, {});
}
function createValueToJsonML(markToAttrs) {
  var converts = markToAttrs.filter(function (f) {
    return !!f;
  });
  var rule = {
    match: function match(node) {
      return Text$1.isText(node);
    },
    convert: function convert(node) {
      return ['span', {
        'data-type': 'text'
      }].concat(node.leaves.reduce(function (acc, leaf) {
        return [].concat(acc, [['span', _extends({}, marksToAttrs(leaf.marks, converts), {
          'data-type': 'leaf'
        }), leaf.text]]);
      }, []));
    }
  };
  return rule;
}

var valueToText = {
  name: 'text',
  match: function match(node) {
    return Text$1.isText(node);
  },
  convert: function convert(node) {
    return node.text;
  }
};
function createValueToText() {
  return valueToText;
}

var createSerializerPlugin = function createSerializerPlugin(plugins) {
  return {
    htmlToJsonML: createHTMLToJsonML(plugins.map(function (p) {
      var _p$leaf;

      return (_p$leaf = p.leaf) == null ? void 0 : _p$leaf.htmlToJsonMLAttrs;
    })),
    jsonMLToHTML: createJsonMLToHTML(plugins.map(function (p) {
      var _p$leaf2;

      return (_p$leaf2 = p.leaf) == null ? void 0 : _p$leaf2.jsonMLAttrsToStyle;
    })),
    jsonMLToValue: createJsonMLToValue(plugins.map(function (p) {
      var _p$leaf3;

      return (_p$leaf3 = p.leaf) == null ? void 0 : _p$leaf3.jsonMLAttrsToMarks;
    })),
    valueToJsonML: createValueToJsonML(plugins.map(function (p) {
      var _p$leaf4;

      return (_p$leaf4 = p.leaf) == null ? void 0 : _p$leaf4.markToJsonMLAttrs;
    })),
    valueToText: createValueToText()
  };
};

function createBase(p, schema) {
  var plugins = [createSerializerPlugin$1(), createSerializerPlugin(p)].concat(p);
  var jsonMLToNode = createJsonMLToNode(plugins);
  var jsonMLToValue = createJsonMLToValue$1(jsonMLToNode, schema);
  var nodeToJsonML = createNodeToJsonML(plugins);
  var valueToJsonML = createValueToJsonML$1(nodeToJsonML);
  return {
    // 反序列化 ASL
    jsonMLToValue: jsonMLToValue,
    // 序列化 ASL
    valueToJsonML: valueToJsonML,
    // 主要用于 operation 序列化、反序列化
    jsonMLToNode: jsonMLToNode,
    nodeToJsonML: nodeToJsonML
  };
}

function createText(p, base) {
  var plugins = [createSerializerPlugin(p)].concat(p, [createSerializerPlugin$1()]);
  var beforeValueToText = plugins.map(function (p) {
    var _p$valueToText, _p$valueToText$hooks;

    return (_p$valueToText = p.valueToText) == null ? void 0 : (_p$valueToText$hooks = _p$valueToText.hooks) == null ? void 0 : _p$valueToText$hooks.before;
  }).filter(function (p) {
    return !!p;
  }).reduce(function (acc, p) {
    return function (value) {
      return p(acc(value));
    };
  }, function (value) {
    return value;
  });
  var textToJsonML = createTextToJsonML(plugins);
  var nodeToText = createNodeToText(plugins);
  var valueToText = createValueToText$1(nodeToText, beforeValueToText);
  return {
    // 纯文本粘贴
    textToJsonML: textToJsonML,
    textToValue: function textToValue(text) {
      return base.jsonMLToValue(textToJsonML(text));
    },
    // 纯文本导出
    valueToText: valueToText
  };
}

function createHtml(p, base, parser) {
  var plugins = [createSerializerPlugin(p)].concat(p, [createSerializerPlugin$1()]);
  var htmlToJsonML = createHtmlToJsonML(plugins, parser);
  var jsonMLToHTML = createJsonMLToHTML$1(plugins);
  return {
    // 富文本粘贴
    htmlToJsonML: htmlToJsonML,
    htmlToValue: function htmlToValue(html) {
      return base.jsonMLToValue(htmlToJsonML(html), {
        strict: true
      });
    },
    // 输出 HTML
    jsonMLToHTML: jsonMLToHTML,
    valueToHTML: function valueToHTML(value) {
      return jsonMLToHTML(base.valueToJsonML(value));
    }
  };
}

function createAsync(p) {
  var plugins = [createSerializerPlugin(p)].concat(p, [createSerializerPlugin$1()]);
  var asyncNodeToJsonML = createAsyncNodeToJsonML(plugins);
  var asyncValueToJsonML = createAsyncValueToJsonML(asyncNodeToJsonML);
  return {
    asyncValueToJsonML: asyncValueToJsonML
  };
}

function createMarkdown(p, base, hs) {
  var plugins = [createSerializerPlugin(p)].concat(p, [createSerializerPlugin$1()]);

  var markdownToJsonML = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(markdown) {
      var markdownToHTML, html;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return createMarkdownToHTML(plugins);

            case 2:
              markdownToHTML = _context.sent;
              html = markdownToHTML(markdown);
              return _context.abrupt("return", hs.htmlToJsonML(html));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function markdownToJsonML(_x) {
      return _ref.apply(this, arguments);
    };
  }();

  var jsonMLToMarkdown = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(jsonML) {
      var jsonMLToHTML, htmlToMarkdown;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              jsonMLToHTML = createJsonMLToHTML$1(plugins);
              _context2.next = 3;
              return createHtmlToMarkdown(plugins);

            case 3:
              htmlToMarkdown = _context2.sent;
              return _context2.abrupt("return", htmlToMarkdown(jsonMLToHTML(jsonML)));

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function jsonMLToMarkdown(_x2) {
      return _ref2.apply(this, arguments);
    };
  }();

  return {
    // markdown 粘贴
    markdownToJsonML: markdownToJsonML,
    markdownToValue: function () {
      var _markdownToValue = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(markdown) {
        var jsonML;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return markdownToJsonML(markdown);

              case 2:
                jsonML = _context3.sent;
                return _context3.abrupt("return", base.jsonMLToValue(jsonML));

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function markdownToValue(_x3) {
        return _markdownToValue.apply(this, arguments);
      }

      return markdownToValue;
    }(),
    jsonMLToMarkdown: jsonMLToMarkdown
  };
}

function create(plugins, schema, parser) {
  var baseSerialzer = createBase(plugins, schema);
  var textSerializer = createText(plugins, baseSerialzer);
  var htmlSerializer = createHtml(plugins, baseSerialzer, parser);
  var mdSerializer = createMarkdown(plugins, baseSerialzer, htmlSerializer);
  var asyncSerializer = createAsync(plugins);
  return _extends({}, baseSerialzer, textSerializer, htmlSerializer, mdSerializer, asyncSerializer);
}

function getSchemaAndPluginsFromMoPlugins(plugins) {
  var schema = createSchema(plugins);
  var serializerPlugins = plugins.map(function (p) {
    return p.serializer;
  }).filter(function (s) {
    return !!s;
  });
  return {
    schema: schema,
    serializerPlugins: serializerPlugins
  };
}
/**
 * @deprecated create serializer with `serializations plugins`
 * @returns serializer
 */


var createSerializerOld = create;
/**
 * create serializer only support jsonMl <=> value
 * @param plugins mo plugins
 * @returns serializer
 */

function createBaseSerializer(plugins) {
  var _getSchemaAndPluginsF = getSchemaAndPluginsFromMoPlugins(plugins),
      schema = _getSchemaAndPluginsF.schema,
      serializerPlugins = _getSchemaAndPluginsF.serializerPlugins;

  return createBase(serializerPlugins, schema);
}
/**
 * create serializer with jsonMl、html、text、markdown
 * @param plugins mo plugins
 * @param parser optional html parser
 * @returns serializer
 */

function createSerializer(plugins, parser) {
  var _getSchemaAndPluginsF2 = getSchemaAndPluginsFromMoPlugins(plugins),
      schema = _getSchemaAndPluginsF2.schema,
      serializerPlugins = _getSchemaAndPluginsF2.serializerPlugins;

  return create(serializerPlugins, schema, parser);
}

var Parser = /*#__PURE__*/function () {
  function Parser() {
    var _this = this;

    this.skipTags = ['head', 'style'];
    this.isInSkipTag = false;
    this.stack = [];
    this.callbacks = void 0;
    this.parser = void 0;

    this.init = function (callbacks, options) {
      _this.callbacks = callbacks;
      _this.parser = createHtmlParser({
        onopentag: _this.onOpenTag,
        ontext: _this.onText,
        // @ts-ignore
        onclosetag: _this.onCloseTag
      }, options);
    };

    this.onOpenTag = function (name, attrs) {
      var _this$callbacks;

      if (_this.skipTags.includes(name)) {
        _this.isInSkipTag = true;
        return;
      }

      if (_this.isInSkipTag) return; // @ts-ignore

      attrs.styleObj = toStyleObject(attrs.style);
      var id = v1();
      (_this$callbacks = _this.callbacks) == null ? void 0 : _this$callbacks.onOpenTag(name, attrs, id);

      _this.stack.push({
        name: name,
        attrs: attrs,
        id: id
      });
    };

    this.onText = function (text) {
      var _this$callbacks2;

      if (_this.isInSkipTag || !normalizeSpacesInHTML(text)) return;
      (_this$callbacks2 = _this.callbacks) == null ? void 0 : _this$callbacks2.onText(text);
    };

    this.onCloseTag = function (name) {
      var _this$callbacks3;

      if (_this.skipTags.includes(name)) {
        _this.isInSkipTag = false;
        return;
      }

      if (_this.isInSkipTag) return;

      var open = _this.stack.pop();

      if (!open || open.name !== name) {
        throw new Error("htmlparser2 doesn't close tag(" + name + ") correctly!");
      }

      (_this$callbacks3 = _this.callbacks) == null ? void 0 : _this$callbacks3.onCloseTag(name, open.attrs, open.id);
    };
  }

  var _proto = Parser.prototype;

  _proto.write = function write(chunk) {
    var _this$parser;

    (_this$parser = this.parser) == null ? void 0 : _this$parser.write(chunk);
  };

  _proto.end = function end() {
    var _this$parser2;

    (_this$parser2 = this.parser) == null ? void 0 : _this$parser2.end();
  };

  return Parser;
}();

/**
 * 边框样式枚举
 */
var BorderStyleEnum;

(function (BorderStyleEnum) {
  BorderStyleEnum["Single"] = "single";
  BorderStyleEnum["Thick"] = "thick";
  BorderStyleEnum["Double"] = "double";
  BorderStyleEnum["Dotted"] = "dotted";
  BorderStyleEnum["Dashed"] = "dashed";
  BorderStyleEnum["DotDash"] = "dotDash";
  BorderStyleEnum["DotDotDash"] = "dotDotDash";
  BorderStyleEnum["Triple"] = "triple";
  BorderStyleEnum["ThinThickSmallGap"] = "thinThickSmallGap";
  BorderStyleEnum["ThickThinSmallGap"] = "thickThinSmallGap";
  BorderStyleEnum["ThinThickThinSmallGap"] = "thinThickThinSmallGap";
  BorderStyleEnum["ThinThickMediumGap"] = "thinThickMediumGap";
  BorderStyleEnum["ThickThinMediumGap"] = "thickThinMediumGap";
  BorderStyleEnum["ThinThickThinMediumGap"] = "thinThickThinMediumGap";
  BorderStyleEnum["ThinThickLargeGap"] = "thinThickLargeGap";
  BorderStyleEnum["ThickThinLargeGap"] = "thickThinLargeGap";
  BorderStyleEnum["ThinThickThinLargeGap"] = "thinThickThinLargeGap";
  BorderStyleEnum["Wave"] = "wave";
  BorderStyleEnum["DoubleWave"] = "doubleWave";
  BorderStyleEnum["DashSmallGap"] = "dashSmallGap";
  BorderStyleEnum["DashDotStroked"] = "dashDotStroked";
  BorderStyleEnum["ThreeDEmboss"] = "threeDEmboss";
  BorderStyleEnum["ThreeDEngrave"] = "threeDEngrave";
  BorderStyleEnum["Outset"] = "outset";
  BorderStyleEnum["Inset"] = "inset";
  BorderStyleEnum["Apples"] = "apples";
  BorderStyleEnum["ArchedScallops"] = "archedScallops";
  BorderStyleEnum["BabyPacifier"] = "babyPacifier";
  BorderStyleEnum["BabyRattle"] = "babyRattle";
  BorderStyleEnum["Balloons3Colors"] = "balloons3Colors";
  BorderStyleEnum["BalloonsHotAir"] = "balloonsHotAir";
  BorderStyleEnum["BasicBlackDashes"] = "basicBlackDashes";
  BorderStyleEnum["BasicBlackDots"] = "basicBlackDots";
  BorderStyleEnum["BasicBlackSquares"] = "basicBlackSquares";
  BorderStyleEnum["BasicThinLines"] = "basicThinLines";
  BorderStyleEnum["BasicWhiteDashes"] = "basicWhiteDashes";
  BorderStyleEnum["BasicWhiteDots"] = "basicWhiteDots";
  BorderStyleEnum["BasicWhiteSquares"] = "basicWhiteSquares";
  BorderStyleEnum["BasicWideInline"] = "basicWideInline";
  BorderStyleEnum["BasicWideMidline"] = "basicWideMidline";
  BorderStyleEnum["BasicWideOutline"] = "basicWideOutline";
  BorderStyleEnum["Bats"] = "bats";
  BorderStyleEnum["Birds"] = "birds";
  BorderStyleEnum["BirdsFlight"] = "birdsFlight";
  BorderStyleEnum["Cabins"] = "cabins";
  BorderStyleEnum["CakeSlice"] = "cakeSlice";
  BorderStyleEnum["CandyCorn"] = "candyCorn";
  BorderStyleEnum["CelticKnotwork"] = "celticKnotwork";
  BorderStyleEnum["CertificateBanner"] = "certificateBanner";
  BorderStyleEnum["ChainLink"] = "chainLink";
  BorderStyleEnum["ChampagneBottle"] = "champagneBottle";
  BorderStyleEnum["CheckedBarBlack"] = "checkedBarBlack";
  BorderStyleEnum["CheckedBarColor"] = "checkedBarColor";
  BorderStyleEnum["Checkered"] = "checkered";
  BorderStyleEnum["ChristmasTree"] = "christmasTree";
  BorderStyleEnum["CirclesLines"] = "circlesLines";
  BorderStyleEnum["CirclesRectangles"] = "circlesRectangles";
  BorderStyleEnum["ClassicalWave"] = "classicalWave";
  BorderStyleEnum["Clocks"] = "clocks";
  BorderStyleEnum["Compass"] = "compass";
  BorderStyleEnum["Confetti"] = "confetti";
  BorderStyleEnum["ConfettiGrays"] = "confettiGrays";
  BorderStyleEnum["ConfettiOutline"] = "confettiOutline";
  BorderStyleEnum["ConfettiStreamers"] = "confettiStreamers";
  BorderStyleEnum["ConfettiWhite"] = "confettiWhite";
  BorderStyleEnum["CornerTriangles"] = "cornerTriangles";
  BorderStyleEnum["CouponCutoutDashes"] = "couponCutoutDashes";
  BorderStyleEnum["CouponCutoutDots"] = "couponCutoutDots";
  BorderStyleEnum["CrazyMaze"] = "crazyMaze";
  BorderStyleEnum["CreaturesButterfly"] = "creaturesButterfly";
  BorderStyleEnum["CreaturesFish"] = "creaturesFish";
  BorderStyleEnum["CreaturesInsects"] = "creaturesInsects";
  BorderStyleEnum["CreaturesLadyBug"] = "creaturesLadyBug";
  BorderStyleEnum["CrossStitch"] = "crossStitch";
  BorderStyleEnum["Cup"] = "cup";
  BorderStyleEnum["DecoArch"] = "decoArch";
  BorderStyleEnum["DecoArchColor"] = "decoArchColor";
  BorderStyleEnum["DecoBlocks"] = "decoBlocks";
  BorderStyleEnum["DiamondsGray"] = "diamondsGray";
  BorderStyleEnum["DoubleD"] = "doubleD";
  BorderStyleEnum["DoubleDiamonds"] = "doubleDiamonds";
  BorderStyleEnum["Earth1"] = "earth1";
  BorderStyleEnum["Earth2"] = "earth2";
  BorderStyleEnum["EclipsingSquares1"] = "eclipsingSquares1";
  BorderStyleEnum["EclipsingSquares2"] = "eclipsingSquares2";
  BorderStyleEnum["EggsBlack"] = "eggsBlack";
  BorderStyleEnum["Fans"] = "fans";
  BorderStyleEnum["Film"] = "film";
  BorderStyleEnum["Firecrackers"] = "firecrackers";
  BorderStyleEnum["FlowersBlockPrint"] = "flowersBlockPrint";
  BorderStyleEnum["FlowersDaisies"] = "flowersDaisies";
  BorderStyleEnum["FlowersModern1"] = "flowersModern1";
  BorderStyleEnum["FlowersModern2"] = "flowersModern2";
  BorderStyleEnum["FlowersPansy"] = "flowersPansy";
  BorderStyleEnum["FlowersRedRose"] = "flowersRedRose";
  BorderStyleEnum["FlowersRoses"] = "flowersRoses";
  BorderStyleEnum["FlowersTeacup"] = "flowersTeacup";
  BorderStyleEnum["FlowersTiny"] = "flowersTiny";
  BorderStyleEnum["Gems"] = "gems";
  BorderStyleEnum["GingerbreadMan"] = "gingerbreadMan";
  BorderStyleEnum["Gradient"] = "gradient";
  BorderStyleEnum["Handmade1"] = "handmade1";
  BorderStyleEnum["Handmade2"] = "handmade2";
  BorderStyleEnum["HeartBalloon"] = "heartBalloon";
  BorderStyleEnum["HeartGray"] = "heartGray";
  BorderStyleEnum["Hearts"] = "hearts";
  BorderStyleEnum["HeebieJeebies"] = "heebieJeebies";
  BorderStyleEnum["Holly"] = "holly";
  BorderStyleEnum["HouseFunky"] = "houseFunky";
  BorderStyleEnum["Hypnotic"] = "hypnotic";
  BorderStyleEnum["IceCreamCones"] = "iceCreamCones";
  BorderStyleEnum["LightBulb"] = "lightBulb";
  BorderStyleEnum["Lightning1"] = "lightning1";
  BorderStyleEnum["Lightning2"] = "lightning2";
  BorderStyleEnum["MapPins"] = "mapPins";
  BorderStyleEnum["MapleLeaf"] = "mapleLeaf";
  BorderStyleEnum["MapleMuffins"] = "mapleMuffins";
  BorderStyleEnum["Marquee"] = "marquee";
  BorderStyleEnum["MarqueeToothed"] = "marqueeToothed";
  BorderStyleEnum["Moons"] = "moons";
  BorderStyleEnum["Mosaic"] = "mosaic";
  BorderStyleEnum["MusicNotes"] = "musicNotes";
  BorderStyleEnum["Northwest"] = "northwest";
  BorderStyleEnum["Ovals"] = "ovals";
  BorderStyleEnum["Packages"] = "packages";
  BorderStyleEnum["PalmsBlack"] = "palmsBlack";
  BorderStyleEnum["PalmsColor"] = "palmsColor";
  BorderStyleEnum["PaperClips"] = "paperClips";
  BorderStyleEnum["Papyrus"] = "papyrus";
  BorderStyleEnum["PartyFavor"] = "partyFavor";
  BorderStyleEnum["PartyGlass"] = "partyGlass";
  BorderStyleEnum["Pencils"] = "pencils";
  BorderStyleEnum["People"] = "people";
  BorderStyleEnum["PeopleWaving"] = "peopleWaving";
  BorderStyleEnum["PeopleHats"] = "peopleHats";
  BorderStyleEnum["Poinsettias"] = "poinsettias";
  BorderStyleEnum["PostageStamp"] = "postageStamp";
  BorderStyleEnum["Pumpkin1"] = "pumpkin1";
  BorderStyleEnum["PushPinNote2"] = "pushPinNote2";
  BorderStyleEnum["PushPinNote1"] = "pushPinNote1";
  BorderStyleEnum["Pyramids"] = "pyramids";
  BorderStyleEnum["PyramidsAbove"] = "pyramidsAbove";
  BorderStyleEnum["Quadrants"] = "quadrants";
  BorderStyleEnum["Rings"] = "rings";
  BorderStyleEnum["Safari"] = "safari";
  BorderStyleEnum["Sawtooth"] = "sawtooth";
  BorderStyleEnum["SawtoothGray"] = "sawtoothGray";
  BorderStyleEnum["ScaredCat"] = "scaredCat";
  BorderStyleEnum["Seattle"] = "seattle";
  BorderStyleEnum["ShadowedSquares"] = "shadowedSquares";
  BorderStyleEnum["SharksTeeth"] = "sharksTeeth";
  BorderStyleEnum["ShorebirdTracks"] = "shorebirdTracks";
  BorderStyleEnum["Skyrocket"] = "skyrocket";
  BorderStyleEnum["SnowflakeFancy"] = "snowflakeFancy";
  BorderStyleEnum["Snowflakes"] = "snowflakes";
  BorderStyleEnum["Sombrero"] = "sombrero";
  BorderStyleEnum["Southwest"] = "southwest";
  BorderStyleEnum["Stars"] = "stars";
  BorderStyleEnum["StarsTop"] = "starsTop";
  BorderStyleEnum["Stars3d"] = "stars3d";
  BorderStyleEnum["StarsBlack"] = "starsBlack";
  BorderStyleEnum["StarsShadowed"] = "starsShadowed";
  BorderStyleEnum["Sun"] = "sun";
  BorderStyleEnum["Swirligig"] = "swirligig";
  BorderStyleEnum["TornPaper"] = "tornPaper";
  BorderStyleEnum["TornPaperBlack"] = "tornPaperBlack";
  BorderStyleEnum["Trees"] = "trees";
  BorderStyleEnum["TriangleParty"] = "triangleParty";
  BorderStyleEnum["Triangles"] = "triangles";
  BorderStyleEnum["Tribal1"] = "tribal1";
  BorderStyleEnum["Tribal2"] = "tribal2";
  BorderStyleEnum["Tribal3"] = "tribal3";
  BorderStyleEnum["Tribal4"] = "tribal4";
  BorderStyleEnum["Tribal5"] = "tribal5";
  BorderStyleEnum["Tribal6"] = "tribal6";
  BorderStyleEnum["TwistedLines1"] = "twistedLines1";
  BorderStyleEnum["TwistedLines2"] = "twistedLines2";
  BorderStyleEnum["Vine"] = "vine";
  BorderStyleEnum["Waveline"] = "waveline";
  BorderStyleEnum["WeavingAngles"] = "weavingAngles";
  BorderStyleEnum["WeavingBraid"] = "weavingBraid";
  BorderStyleEnum["WeavingRibbon"] = "weavingRibbon";
  BorderStyleEnum["WeavingStrips"] = "weavingStrips";
  BorderStyleEnum["WhiteFlowers"] = "whiteFlowers";
  BorderStyleEnum["Woodwork"] = "woodwork";
  BorderStyleEnum["XIllusions"] = "xIllusions";
  BorderStyleEnum["ZanyTriangles"] = "zanyTriangles";
  BorderStyleEnum["ZigZag"] = "zigZag";
  BorderStyleEnum["ZigZagStitch"] = "zigZagStitch";
})(BorderStyleEnum || (BorderStyleEnum = {}));

var PageBorderDisplay;

(function (PageBorderDisplay) {
  PageBorderDisplay["ALL_PAGES"] = "allPages";
  PageBorderDisplay["FIRST_PAGE"] = "firstPage";
  PageBorderDisplay["NOT_FIRST_PAGE"] = "notFirstPage";
})(PageBorderDisplay || (PageBorderDisplay = {}));

var PageBorderOffsetFrom;

(function (PageBorderOffsetFrom) {
  PageBorderOffsetFrom["PAGE"] = "page";
  PageBorderOffsetFrom["TEXT"] = "text";
})(PageBorderOffsetFrom || (PageBorderOffsetFrom = {}));

var PageBorderZOrder;

(function (PageBorderZOrder) {
  PageBorderZOrder["BACK"] = "back";
  PageBorderZOrder["FRONT"] = "front";
})(PageBorderZOrder || (PageBorderZOrder = {}));

var index$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get BorderStyleEnum () { return BorderStyleEnum; },
  get PageBorderDisplay () { return PageBorderDisplay; },
  get PageBorderOffsetFrom () { return PageBorderOffsetFrom; },
  get PageBorderZOrder () { return PageBorderZOrder; }
});

var border = /*#__PURE__*/Object.freeze({
  __proto__: null
});

var tableBorder = /*#__PURE__*/Object.freeze({
  __proto__: null
});

var WrapPr = /*#__PURE__*/Object.freeze({
  __proto__: null
});

var FramePr = /*#__PURE__*/Object.freeze({
  __proto__: null
});

var TblpPr = /*#__PURE__*/Object.freeze({
  __proto__: null
});

var TblW = /*#__PURE__*/Object.freeze({
  __proto__: null
});

var CalloutPr = /*#__PURE__*/Object.freeze({
  __proto__: null
});

var index$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Border: border,
  TableBorder: tableBorder,
  WrapPr: WrapPr,
  FramePr: FramePr,
  TblpPr: TblpPr,
  TblW: TblW,
  CalloutPr: CalloutPr
});

/**
 * 获得 Controller 实例，使用 `useControllerStatic` hook 的组件，不会随着编辑器内容的变化而发生重渲
 * @returns 
 */

function useControllerStatic() {
  var context = useContext(ControllerContext);

  if (!context) {
    throw new Error("The `useControllerStatic` hook must be used inside the <Cangjie.Provider> component's context.");
  }

  return context.controller;
}

var FieldsNotAffectSpace = ['composing', 'isFocused', 'decorations', 'selection', 'remoteSelections'];
var OperationsNotAffectSpace = [OperationType.InsertText, OperationType.RemoveText, OperationType.SetMark, OperationType.AddMark, OperationType.RemoveMark, OperationType.SetSelection];

function isSetValueNotAffectSpace(key) {
  return FieldsNotAffectSpace.includes(key);
}

function isOperationNotAffectSpace(operation) {
  return OperationsNotAffectSpace.includes(operation.type);
}

function getDirtyKeysFromOperation(value, operation) {
  var type = operation.type,
      path = operation.path,
      node = operation.node;
  var document = value.document;
  var opNode = node || document.getNodeByPath(path);
  var opNodeKey = opNode == null ? void 0 : opNode.key;

  switch (type) {
    // PERF: Cangjie does not support normalizing `text.text` `leaf.marks`, just ignore changes for performance(~10ms in Huge Document story)
    // PERF: 🚫🚫🚫 No [...xxx]. Spread syntax will affect performance when huge node changed.
    // Ref: packages/cangjie/src/plugins/schema.ts
    // case 'add_mark':
    // case 'insert_text':
    // case 'remove_mark':
    // case 'remove_text':
    // case 'set_mark':
    case OperationType.SetNode:
      {
        var ancestors = document.getAncestorsByPath(path).map(function (n) {
          return n == null ? void 0 : n.key;
        });
        ancestors.push(opNodeKey);
        return ancestors;
      }

    case OperationType.InsertNode:
      {
        var table = Text$1.isText(node) ? {} : node.getKeysToEdgesTable();

        var _ancestors = document.getAncestorsByPath(path).map(function (n) {
          return n == null ? void 0 : n.key;
        });

        _ancestors.push(node.key);

        Array.prototype.push.apply(_ancestors, Object.keys(table));
        return _ancestors;
      }

    case OperationType.SplitNode:
      {
        var _ancestors2 = document.getAncestorsByPath(path).map(function (n) {
          return n == null ? void 0 : n.key;
        }); // @ts-ignore


        var nextKey = document.getNextNodeByPath(path).key;

        _ancestors2.push(opNodeKey, nextKey);

        return _ancestors2;
      }

    case OperationType.MergeNode:
      {
        var _ancestors3 = Path.ancestors(path);

        var previousPath = Path.decrement(path);

        _ancestors3.push(previousPath);

        return _ancestors3.map(function (p) {
          return document.getNodeByPath(p);
        }).map(function (n) {
          return n == null ? void 0 : n.key;
        });
      }

    case OperationType.MoveNode:
      {
        // Path is more accurate than key when node moved.
        var _ref = operation,
            newPath = _ref.newPath;

        if (Path.isEqual(path, newPath)) {
          return [];
        }

        var parentPath = Path.parent(path);
        var newParentPath = Path.parent(newPath); // HACK: this clause only exists because the `move_path` logic isn't
        // consistent when it deals with siblings.

        if (!Path.isSibling(path, newPath)) {
          if (newParentPath.length && Path.isYounger(path, newPath)) {
            newParentPath = Path.decrement(newParentPath, 1, path.length - 1);
          }

          if (parentPath.length && (Path.isYounger(newPath, path) || Path.isAncestor(newPath, path))) {
            parentPath = Path.increment(parentPath, 1, newPath.length - 1);
          }
        }

        var oldAncestors = Path.ancestors(parentPath);
        var newAncestors = Path.ancestors(newParentPath);
        oldAncestors.push(parentPath);
        Array.prototype.push.apply(oldAncestors, newAncestors);
        oldAncestors.push(newParentPath);
        return oldAncestors.map(function (p) {
          return document.getNodeByPath(p);
        }).map(function (n) {
          return n == null ? void 0 : n.key;
        });
      }

    case OperationType.RemoveNode:
      {
        // The node has been deleted, ancestors connot be getted by "document.getAncestors"
        var _ancestors4 = Path.ancestors(path);

        return _ancestors4.map(function (p) {
          return document.getNodeByPath(p);
        }).map(function (n) {
          return n == null ? void 0 : n.key;
        });
      }

    default:
      {
        return [];
      }
  }
}
/**
 * diff比较（严格：顺序改变算diff）
 * @param element
 * @param prevElement
 * @param curIndexKey
 * @param preIndexKey
 * @deprecated
 */

function getDirtyKeysFromElementDiffStrictly(element, prevElement, curIndexKey, preIndexKey) {
  var dirtyKeys = [];

  if (element === prevElement && curIndexKey === preIndexKey) {
    return dirtyKeys;
  }

  dirtyKeys.push(element.key);

  if (!Element$1.isElement(element)) {
    return dirtyKeys;
  }

  if (!Element$1.isElement(prevElement)) {
    return Object.keys(element.getKeysToEdgesTable()).concat(element.key);
  }

  for (var i = 0; i < element.nodes.length; i += 1) {
    var _prevElement$nodes$i;

    var child = element.nodes[i];
    var prevChild = prevElement.getNode(child.key);
    var preChildIndexKey = prevElement == null ? void 0 : (_prevElement$nodes$i = prevElement.nodes[i]) == null ? void 0 : _prevElement$nodes$i.key;

    if (child !== prevChild || child.key !== preChildIndexKey) {
      dirtyKeys.push.apply(dirtyKeys, getDirtyKeysFromElementDiffStrictly(child, prevChild, child.key, preChildIndexKey));
    }
  }

  return dirtyKeys;
}

function getDirtyKeysFromElementDiff(element, prevElement) {
  var dirtyKeys = [];

  if (element === prevElement) {
    return dirtyKeys;
  }

  dirtyKeys.push(element.key);

  if (!Element$1.isElement(element)) {
    return dirtyKeys;
  }

  if (!Element$1.isElement(prevElement)) {
    return Object.keys(element.getKeysToEdgesTable()).concat(element.key);
  }

  for (var i = 0; i < element.nodes.length; i += 1) {
    var child = element.nodes[i];
    var prevChild = prevElement.getNode(child.key);

    if (child !== prevChild) {
      getDirtyKeysFromElementDiff(child, prevChild).forEach(function (key) {
        return dirtyKeys.push(key);
      });
    }
  }

  return dirtyKeys;
}

var composingMark = Mark.create('cangjieComposing');
var defaultScrollType = 'toSelection';
function insertComposingIntoLeaves(leaves, offset, composing, selection, decorations) {
  var _before$, _after$;

  var _Leaf$splitLeaves = Leaf.splitLeaves(leaves, offset),
      before = _Leaf$splitLeaves[0],
      after = _Leaf$splitLeaves[1];

  var beforeLastLeaf = before[before.length - 1];
  var beforeLastMarks = beforeLastLeaf ? beforeLastLeaf.marks : [];
  var marks = null;

  if (selection.marks) {
    var decorationsMarks = decorations.map(function (_ref2) {
      var mark = _ref2.mark;
      return mark;
    });
    var activeDecorationsMarks = beforeLastMarks.filter(function (mark) {
      return decorationsMarks.some(function (m) {
        return equal(m, mark);
      });
    });
    marks = [].concat(activeDecorationsMarks, selection.marks);
  } else {
    marks = beforeLastMarks;
  }

  var middle = Leaf.create({
    text: composing,
    marks: [].concat(marks, [composingMark])
  });
  var shouldConcatBefore = before.length > 1 || ((_before$ = before[0]) == null ? void 0 : _before$.text);
  var shouldConcatAfter = after.length > 1 || ((_after$ = after[0]) == null ? void 0 : _after$.text);
  return [].concat(shouldConcatBefore ? before : [], [middle], shouldConcatAfter ? after : []);
}
var DEFAULT_VIRTUALIZE_OPTIONS = {
  enable: false,
  enableOnDemandViewCalculation: true,
  pendingDebounceTime: 500,
  invisibleCalculationDebounceTime: 500,
  maxOPsForHotsAnalyze: 10,
  bufferRange: DEFAULT_BUFFER_RANGE,
  firstPaintBlockSize: DEFAULT_FIRST_PAINT_BLOCK_SIZE,
  disableViewVirtualize: false
};

var Controller = /*#__PURE__*/function () {
  /**
   * 内部使用了[[Controller.useController]]，把Wrapper封装为一个高阶组件，并传入controller
   */

  /**
   * 构建一个新的Controller对象
   * @param props 构建参数
   * @param options 构建选项
   */
  Controller.create = function create(props, options) {
    return new Controller(props, options);
  };

  var _proto = Controller.prototype;

  _proto.registerPlugin = function registerPlugin(plugin) {
    var _this = this;

    if (Array.isArray(plugin)) {
      plugin.forEach(function (p) {
        return _this.registerPlugin(p);
      });
      return;
    }

    var cmds = plugin.commands,
        actions = plugin.actions,
        isActions = plugin.isActions,
        queries = plugin.queries,
        renderNode = plugin.renderNode,
        pluginSchema = plugin.schema,
        rest = _objectWithoutPropertiesLoose(plugin, ["commands", "actions", "isActions", "queries", "renderNode", "schema"]);

    if (cmds) {
      // NOTE: `commands` which has registered will have higher priority.
      this.commands = Object.assign({}, cmds, this.commands);
    }

    if (actions) {
      this.actions = Object.assign({}, actions, this.actions);
    }

    if (isActions) {
      this.isActions = Object.assign({}, isActions, this.isActions);
    }

    if (queries) {
      // NOTE: `queries` which has registered will have higher priority.
      Object.keys(queries).forEach(function (query) {
        var prevQuery = _this.queries[query];
        var nextQuery = queries[query];

        if (!prevQuery) {
          _this.queries[query] = nextQuery;
          return;
        }

        _this.queries[query] = function () {
          var ret = prevQuery.apply(void 0, arguments);
          return ret === undefined ? nextQuery.apply(void 0, arguments) : ret;
        };
      });
    }

    if (renderNode) {
      if (typeof renderNode === 'function') {
        if (!this.handlers.renderNode) {
          this.handlers.renderNode = [];
        }

        this.handlers.renderNode.push(renderNode);
      } else {
        Object.keys(renderNode).forEach(function (nodeType) {
          if (!_this.renderNodes[nodeType]) {
            _this.renderNodes[nodeType] = [renderNode[nodeType]];
          } else {
            _this.renderNodes[nodeType].push(renderNode[nodeType]);
          }
        });
      }
    }

    if (pluginSchema) {
      this.registerPlugin(createNormalizationPlugin(pluginSchema));
    }

    Object.keys(rest).forEach(function (key) {
      if (!_this.handlers[key]) {
        _this.handlers[key] = [];
      }

      _this.handlers[key].push(plugin[key]);
    });
  };

  _createClass(Controller, [{
    key: "value",

    /**
     * 文档的数据[[Value]]对象，参照[[ControllerProperties]]
     */
    get: function get() {
      return this.$value;
    }
  }, {
    key: "operations",

    /**
     * 获取当前的历史operations
     */
    get: function get() {
      return this.$operations;
    }
  }]);

  function Controller(props, options) {
    var _this2 = this;

    this.flag = {
      normalizing: true,
      pending: true,
      saving: true,

      /**
       * @experimental
       */
      tracking: true,
      withCommand: false,
      destroyed: false,
      perf: {
        input: [],
        composing: [],
        selection: []
      },
      scrollType: defaultScrollType,
      opRelatedId: null
    };
    this.VIEW_CACHE = {
      /** 内存模型缓存 */
      VALUE: new WeakSet(),

      /** 节点视图模型缓存，若节点的视图数据不变，则复用缓存，避免计算 */
      ELEMENT: new WeakMap(),

      /** 已装饰的节点，key 为节点数据模型，value 为视图数据 */
      DECORATED_ELEMENT: new WeakMap(),

      /** 已注入数据的节点缓存，key 为分组节点，value 为 [注入数据的节点，节点被注入的 injections] */
      INJECTED_ELEMENT: new WeakMap(),

      /** 分组节点缓存，key 装饰后的及节点视图，value 为分组节点 */
      GROUPED_ELEMENT: new WeakMap(),

      /** 文本节点缓存 */
      TEXT: new WeakMap(),

      /** 叶子节点缓存 */
      LEAVES: new WeakMap(),

      /** 数据节点调用 `decorateNode` 结果缓存 */
      DECORATE_NODE: new WeakMap(),

      /** 数据节点调用 `injectToNode` 结果缓存 */
      INJECT_TO_NODE: new WeakMap(),

      /** 节点视图模型缓存 */
      DATA: new WeakMap(),

      /** 视图节点最终被注入的 injections, decorations 缓存  */
      INJECT_TO_VIEW_ELEMENT: new WeakMap(),

      /** 视图文本节点最终被注入的 decorations 缓存 */
      INJECT_TO_VIEW_TEXT: new WeakMap(),

      /** 节点选中态计算缓存 */
      IS_SELECTED: new Set(),

      /** 为计算过视图模型的节点 */
      VIEW_NEVER_CALCULATED: new Set()
    };
    this.dirtyKeys = new Set();
    this.context = [];
    this.biz = void 0;
    this.uid = void 0;
    this.userData = new UserDataManager(this);
    this.inputData$ = new Subject();
    this.selectionData$ = new Subject();
    this.hots$ = new Subject();
    this.terminal$ = new Subject();
    this.virtualizeManager = null;
    this.serializer = void 0;
    this.baseSerializer = void 0;
    this.schema = void 0;
    this.strictSchema = void 0;
    this.$value = null;
    this.$viewDoc = null;
    this.$scrollableContainer = null;
    this.$operations = [];
    this.$operationWithValues = [];
    this.onChange = void 0;
    this.commands = {};
    this.queries = {};
    this.actions = {};
    this.isActions = {};
    this.handlers = {};
    this.renderNodes = {};
    this.flushType = void 0;
    this.flushTask = null;
    this.canCopy = void 0;
    this.readOnly = void 0;
    this.autoFocus = void 0;
    this.hideSelectionOnBlur = void 0;
    this.showCaret = void 0;
    this.testType = void 0;
    this.onBusyStateChange = void 0;
    this.pendingQueue = void 0;
    this.virtualizeOptions = void 0;
    this.debouncedFlush = void 0;
    this.debouncedStartInvisibleCalculationScheduler = void 0;
    this.groupManager = new GroupManager(this);
    this.onPending = void 0;
    this.uuidConfig = void 0;
    this.hots = {
      hots: [],
      keys: {},
      pendingType: null,
      lengthOfPending: 0,
      forceRecalculate: false
    };
    this.virtualize = {
      visibles: [],
      invisibleCalculationId: null
    };
    this.visibles$ = new Subject();

    this.setComposing = function (composing) {
      return _this2.setValueField('composing', composing);
    };

    this.setIsFocused = function (isFocused) {
      return _this2.setValueField('isFocused', isFocused);
    };

    this.startInvisibleCalculationScheduler = function (visibles) {
      /** 若浏览器不支持 requestIdleCallback，则不开启闲时计算 */
      if (typeof window.requestIdleCallback !== 'function') {
        return;
      }

      if (_this2.virtualize.invisibleCalculationId) {
        window.cancelIdleCallback(_this2.virtualize.invisibleCalculationId);
      }

      var invisibles = getInsivibleNodes(_this2.value.document, visibles);

      _this2.scheduleInvisibleCalculation(invisibles);
    };

    this.scheduleInvisibleCalculation = function (invisibles) {
      _this2.virtualize.invisibleCalculationId = window.requestIdleCallback(function (deadline) {
        return _this2.runInvisibleViewCalculation(deadline, invisibles);
      });
    };

    this.runInvisibleViewCalculation = function (deadline, invisibles) {
      while ((deadline.timeRemaining() > 0 || deadline.didTimeout) && invisibles.length) {
        // 每次取出一个不可见节点计算
        _this2.calculateInvisibleView(invisibles.pop());
      }

      if (invisibles.length) {
        // 继续下一个计算
        _this2.scheduleInvisibleCalculation(invisibles);
      } else {
        _this2.virtualize.invisibleCalculationId = null;
      }
    };

    this.calculateInvisibleView = function (invisible) {
      var _this2$value = _this2.value,
          injections = _this2$value.injections,
          decorations = _this2$value.decorations,
          document = _this2$value.document;
      var docInjections = _this2.VIEW_CACHE.INJECT_TO_NODE.get(document) || [];
      var docDecorations = _this2.VIEW_CACHE.DECORATE_NODE.get(document) || [];

      var viewElement = _this2.toViewElement(invisible, decorations.concat(docDecorations), injections.concat(docInjections));

      if (!_this2.VIEW_CACHE.ELEMENT.get(document)) {
        var _this2$value2 = _this2.value,
            _decorations = _this2$value2.decorations,
            _injections = _this2$value2.injections;

        _this2.toView(document, _decorations, _injections);
      }

      var _ref3 = _this2.VIEW_CACHE.ELEMENT.get(document),
          viewDocument = _ref3[0],
          prevDecorations = _ref3[1],
          prevInjections = _ref3[2],
          prevComposing = _ref3[3];

      var newViewDocument = viewDocument.replaceNode(_this2.view.assertPath(viewElement.key), viewElement,
      /** 重新 toView，会带来新的视图子树，因此需要重构 key-to-path table */
      false);

      _this2.VIEW_CACHE.ELEMENT.set(document, [newViewDocument, prevDecorations, prevInjections, prevComposing]);

      _this2.VIEW_CACHE.VALUE["delete"](_this2.value);

      _this2.$viewDoc = newViewDocument;
      return viewElement;
    };

    this.calculateViewInVisibleNode = function (node, parentVisible) {
      if (parentVisible === void 0) {
        parentVisible = false;
      }

      var document = _this2.value.document; // 如果是视图模型节点，递归计算其子树下未被计算过的视图模型

      if (!document.hasNode(node.key) && _this2.isNodeVisible(node)) {
        return node.mapDescendants(function (descendant) {
          return descendant.isElement() ? _this2.calculateViewInVisibleNode(descendant, true) : descendant;
        });
      } // 如果可见节点下，存在未被计算的视图模型，则计算之保证可见节点的视图正确
      else if (document.hasNode(node.key) && parentVisible && _this2.VIEW_CACHE.VIEW_NEVER_CALCULATED.has(node.key)) {
          return _this2.calculateInvisibleView(node);
        }

      return node;
    };

    var _props$biz = props.biz,
        biz = _props$biz === void 0 ? 'cangjie' : _props$biz,
        dataUid = props.dataUid,
        _props$plugins = props.plugins,
        plugins = _props$plugins === void 0 ? [] : _props$plugins,
        value = props.value,
        _props$onChange = props.onChange,
        onChange = _props$onChange === void 0 ? function () {} : _props$onChange,
        readOnly = props.readOnly,
        _props$canCopy = props.canCopy,
        canCopy = _props$canCopy === void 0 ? true : _props$canCopy,
        autoFocus = props.autoFocus,
        _props$flushType = props.flushType,
        flushType = _props$flushType === void 0 ? 'microtask' : _props$flushType,
        configs = props.configs,
        onBusyStateChange = props.onBusyStateChange,
        onPending = props.onPending;
    this.biz = biz;
    this.setUid(dataUid);

    this.onChange = function (change) {
      onChange(change);
    };

    this.readOnly = !!readOnly;
    this.autoFocus = !!autoFocus;
    this.showCaret = options == null ? void 0 : options.showCaret;
    this.canCopy = canCopy;
    this.flushType = flushType;
    this.onBusyStateChange = onBusyStateChange;
    this.onPending = onPending || noop;

    var _ref4 = options || {},
        _ref4$enablePending = _ref4.enablePending,
        enablePending = _ref4$enablePending === void 0 ? false : _ref4$enablePending,
        _ref4$virtualize = _ref4.virtualize,
        virtualize = _ref4$virtualize === void 0 ? DEFAULT_VIRTUALIZE_OPTIONS : _ref4$virtualize; // 虚拟化和 OP Pending 互斥


    if (virtualize.enable) {
      enablePending = false;
    }

    if (enablePending) {
      virtualize.enable = false;
    }

    var _ref5 = options || {},
        _ref5$__pendingQueue_ = _ref5.__pendingQueue__,
        __pendingQueue__ = _ref5$__pendingQueue_ === void 0 ? {} : _ref5$__pendingQueue_,
        _ref5$hideSelectionOn = _ref5.hideSelectionOnBlur,
        hideSelectionOnBlur = _ref5$hideSelectionOn === void 0 ? false : _ref5$hideSelectionOn,
        _ref5$uuid = _ref5.uuid,
        uuid = _ref5$uuid === void 0 ? {
      enable: false
    } : _ref5$uuid;

    this.hideSelectionOnBlur = hideSelectionOnBlur;
    this.pendingQueue = PendingQueue.create(_extends({
      debounceTime: 500
    }, __pendingQueue__, {
      controller: this,
      enablePending: enablePending
    }));
    this.virtualizeOptions = virtualize;
    this.virtualizeOptions = _extends({}, DEFAULT_VIRTUALIZE_OPTIONS, virtualize);
    this.debouncedFlush = debounce(this.flush, this.virtualizeOptions.pendingDebounceTime);
    this.debouncedStartInvisibleCalculationScheduler = debounce(this.startInvisibleCalculationScheduler, this.virtualizeOptions.invisibleCalculationDebounceTime);

    if (IS_MOBILE || IS_TOUCH_DEVICE) {
      this.registerPlugin(createMobilePlugin(configs));
    }

    if (uuid.enable && !uuid.gen) {
      throw new Error('[Cangjie-UUID]: Missing uuid generator');
    }

    this.uuidConfig = {
      enable: uuid.enable
    }; // Step 1: collect `commands` & `queries` from `plugins`.

    this.registerPlugin([createCoreSchemaPlugin(), createGroupPlugin()].concat(plugins, [uuid.enable && !!uuid.gen ? createUUIDPlugin(uuid) : {}, createHistoryPlugin(configs), createCorePlugin(), createContextMenuPlugin(configs)])); // Step 2: wrap `commands` & `queries` into `onCommand` & `onQuery` respectively.

    this.registerPlugin([createCommandsPlugin(_extends({}, Commands, this.commands)), createQueriesPlugin(_extends({
      isAtomic: function isAtomic() {
        return false;
      },
      isEmpty: function isEmpty$1(_, block) {
        return isEmpty(block);
      },
      isVoid: function isVoid() {
        return false;
      }
    }, this.queries)), createRenderNodePlugin(this.renderNodes)]);
    /**
     * schema and serializer: used by other plugins(like clipboard) to deal with model normalize and serialization
     */
    // step 3: create serializer

    this.serializer = createSerializer(plugins); // 迁移期间，原 Plugin 定义不能加 key，待迁移完成再去掉 as any

    this.baseSerializer = createBaseSerializer(plugins); // step 4: create schema

    this.schema = createSchema(plugins);
    this.strictSchema = createStrictSchema(plugins);
    this.setValue(value, options);

    if (virtualize.enable && !virtualize.disableViewVirtualize) {
      this.virtualizeManager = new VirtualizeManager(this, virtualize);
    }

    this.run('onConstruct');
  }

  _proto.setReadOnly = function setReadOnly(readOnly) {
    // @ts-ignore Internal set only
    this.readOnly = readOnly;
  }
  /**
   * 设置一个新的value对象
   * @param value 新的value对象
   * @param options 设置选项
   */
  ;

  _proto.setValue = function setValue(value, options) {
    var _this$value,
        _this$value2,
        _this3 = this;

    var _ref6 = options || {},
        _ref6$clearOperations = _ref6.clearOperations,
        clearOperations = _ref6$clearOperations === void 0 ? true : _ref6$clearOperations,
        _ref6$clearHots = _ref6.clearHots,
        clearHots = _ref6$clearHots === void 0 ? true : _ref6$clearHots,
        _ref6$normalize = _ref6.normalize,
        normalize = _ref6$normalize === void 0 ? value !== this.value : _ref6$normalize; // this.value 初始值为 null


    var prevDocument = (_this$value = this.value) == null ? void 0 : _this$value.document;
    var prevSelection = (_this$value2 = this.value) == null ? void 0 : _this$value2.selection;
    this.$value = value;

    if (clearOperations) {
      this.$operations = [];
    }

    if (clearHots) {
      this.clearHots();
    } // Next Value


    var _this$value3 = this.value,
        document = _this$value3.document,
        selection = _this$value3.selection; // document 变更

    if (normalize && !equal(document, prevDocument)) {
      var dirtyKeys = prevDocument ? getDirtyKeysFromElementDiff(document, prevDocument) : Object.keys(document.getKeysToEdgesTable()).concat(document.key);
      dirtyKeys.forEach(function (key) {
        _this3.dirtyKeys.add(key);
      });
      this.withoutTracking(function () {
        return _this3.normalizeDirtyKeys();
      });
    } // selection 变更


    if (normalize && !equal(selection, prevSelection)) {
      this.normalizeSelection();
    }

    return this;
  };

  _proto.setValueField = function setValueField(key, value) {
    var beforeSetValue = this.value; // @ts-ignore

    this.setValue(this.value.set(key, value), {
      normalize: false,
      clearOperations: false,
      clearHots: false
    });
    this.$operationWithValues.push({
      operation: null,
      key: key,
      value: beforeSetValue,
      newValue: this.value
    });
    this.scheduleFlush();
    return this;
  }
  /**
   * 重置编辑器的 value，服务于受控组件的 `props.value` 变化时
   * `controller.resetValue(value)` 内部将驱动各个插件在重置 value 时所要完成的任务或者副作用
   * @param value
   * @param options
   */
  ;

  _proto.resetValue = function resetValue(value, options) {
    var controllerValue = this.value;
    this.setValue(value, options);
    this.run('onResetValue', value, controllerValue);
  }
  /**
   * 1. 设置Value的data字段
   * 2. 并更新Value
   * 3. 调用flush刷新
   */
  ;

  _proto.setData = function setData(data) {
    return this.setValueField('data', data);
  }
  /**
   * 1. 设置Value的injection字段
   * 2. 并更新Value
   * 3. 调用flush刷新
   */
  ;

  _proto.setInjections = function setInjections(injections) {
    return this.setValueField('injections', injections);
  }
  /**
   * 1. 设置Value的decoration字段
   * 2. 并更新Value
   * 3. 调用flush刷新
   */
  ;

  _proto.setDecorations = function setDecorations(decorations) {
    return this.setValueField('decorations', decorations);
  };

  /**
   * 依次调用所有plugin的key字段，并传入下方的args字段，以及controller和next
   * @param key 对应plugin的key字段
   * @param args 传入plugin的参数
   */
  _proto.run = function run(key) {
    var fns = this.handlers[key];

    if (!fns) {
      // @ts-ignore
      return null;
    }

    var controller = this;
    var i = 0;

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var prevArgs = args;

    function next() {
      for (var _len2 = arguments.length, as = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        as[_key2] = arguments[_key2];
      }

      // PERF
      var currentArgs = as.length === 0 ? prevArgs : [].concat(as, prevArgs.slice(as.length)); // @ts-ignore

      prevArgs = currentArgs;
      var fn = fns[i];

      if (!fn) {
        return null;
      }

      i += 1; // PERF

      switch (currentArgs.length) {
        case 0:
          return fn(controller, next);

        case 1:
          return fn(currentArgs[0], controller, next);

        case 2:
          return fn(currentArgs[0], currentArgs[1], controller, next);

        default:
          return fn.apply(void 0, currentArgs.concat([controller, next]));
      }
    }

    if (isEventHandler(key)) {
      var prevWithCommand = this.flag.withCommand;
      this.flag.withCommand = true;
      var ret = next();
      this.flag.withCommand = prevWithCommand;
      return ret;
    }

    return next();
  }
  /**
   * 执行刷新操作。这里会调用normalize，并执行onChange Plugin和onChange回调
   */
  ;

  _proto.flush = function flush() {
    var _this$onBusyStateChan;

    if (this.flag.destroyed) {
      return this;
    }

    this.run('onChange');
    this.normalizeSelection();
    var value = this.value,
        operations = this.operations;
    var change = {
      value: value,
      operations: operations
    };
    this.$operations = [];
    this.pendingQueue.clear();
    this.hots.lengthOfPending = 0;
    this.perfClearAll();
    this.hots.pendingType = null;
    this.debouncedFlush.cancel(); // 先取消 task，再置空

    if (this.flushTask) {
      this.flushTask.cancel();
      this.flushTask = null;
    }

    this.$operationWithValues = [];
    this.onChange(change);
    (_this$onBusyStateChan = this.onBusyStateChange) == null ? void 0 : _this$onBusyStateChan.call(this, !!this.query('isEditorBusy'));
    this.groupManager.notifyNewGroups();
    return this;
  }
  /**
   * 调度执行 flush，在微任务中执行
   */
  ;

  _proto.scheduleFlush = function scheduleFlush() {
    var _this4 = this;

    // 如果 task 不存在则创建
    if (!this.flushTask) {
      this.flushTask = FlushTask.create(function () {
        // 在下一次任务调度时，判断 operations 是否需要 pending 或 hots
        // 重置 flush task，使下一个周期内的 operations 能被 pending 判定
        if (_this4.flushTask) {
          _this4.flushTask.cancel();

          _this4.flushTask = null;
        } // 获得 flush task 周期内产生的热区


        if (_this4.enableHots) {
          var flushContext = {
            operations: _this4.$operationWithValues,
            value: _this4.$value
          };
          var suppressed = shouldSuppressFlush(flushContext);
          var debounced = !suppressed ? shouldDebounceFlush(flushContext) : null;

          if (suppressed) {
            // 是否抑制 Flush
            // PERF：更新时沿用计算好的热区
            _this4.setHots(_this4.hots.pendingType === suppressed && _this4.hots.hots.length ? _this4.hots.hots : getHots(_this4.$operationWithValues, _this4), suppressed);

            _this4.onPending(_this4.$value);
          } else if (debounced) {
            // 是否 Debounce Flush
            _this4.setHots(getHots(_this4.$operationWithValues.slice(_this4.hots.lengthOfPending), _this4), debounced);

            _this4.onPending(_this4.$value);

            _this4.debouncedFlush();
          } else {
            _this4.setHots([], null);

            _this4.flush();
          }
        } else if (_this4.isPendingEnable) {
          // 需要 pending
          _this4.pendingQueue.queue(_this4.$operationWithValues.slice(_this4.pendingQueue.size()));
        } else {
          // 不需要 pending，立即 flush 堆积的 operations
          _this4.flush();
        }

        _this4.onBusyStateChange == null ? void 0 : _this4.onBusyStateChange(!!_this4.query('isEditorBusy'));
      }, {
        flushType: this.flushType
      }).start();
    }
  };

  _proto.transformDirtyKey = function transformDirtyKey(operation) {
    if (operation.type === 'split_node') {
      // @ts-ignore
      var node = operation.node,
          path = operation.path;
      var operationNode = node || this.value.document.getNodeByPath(path);

      if (this.dirtyKeys.has(operationNode == null ? void 0 : operationNode.key)) {
        var extraDirty = this.value.document.getNodeByPath(Path.increment(path));

        if (extraDirty) {
          this.dirtyKeys.add(extraDirty.key);
        }
      }
    }
  }
  /**
   * Apply operation directly
   * @param operation
   * @returns
   */
  ;

  _proto.privateApplyOperation = function privateApplyOperation(op) {
    var _this5 = this;

    // PERF: 无 Context 时，不向 OP 注入 `context`
    var opWithContext = this.context.length ? _extends({}, op, {
      context: this.context.join(CONTEXT_SPLIT)
    }) : op;
    var operation = this.run('mapOperation', opWithContext);
    var beforeApplyValue = this.value;
    this.$value = this.value.applyOperation(operation);
    var operationWithValue = {
      operation: operation,
      value: beforeApplyValue,
      newValue: this.value
    };
    this.$operationWithValues.push(operationWithValue);
    this.groupManager.regenerateGroup(operationWithValue);
    this.operations.push(operation);
    var dirtyKeysFromOp = getDirtyKeysFromOperation(this.value, operation);
    dirtyKeysFromOp.forEach(function (key) {
      if (key) {
        _this5.dirtyKeys.add(key);
      }
    });
    this.transformDirtyKey(operation);
    this.scheduleFlush();
    this.userData.flush([operation]);
    return this;
  }
  /**
   * 执行单个Operation
   * @param operation 需要执行的operation
   */
  ;

  _proto.applyOperation = function applyOperation(operation) {
    var _this6 = this;

    if (this.flag.tracking) {
      // 插件内部不允许嵌套执行
      this.withoutTracking(function () {
        return _this6.run('onApplyOperation', operation);
      });
      return this;
    }

    return this.privateApplyOperation(operation);
  };

  _proto.normalizeNodeByKey = function normalizeNodeByKey(key) {
    var node = this.value.document.getNode(key);
    if (!node) return;
    var iterations = 0;
    var childrenLength = 1;

    if (!Text$1.isText(node)) {
      if (Element$1.isElement(node)) {
        childrenLength = node.nodes.length;
      } else {
        throw new Error('Unknown node, this is probably caused by multiple instances of Cangjie.');
      }
    }

    var max = 100 + childrenLength;

    while (node) {
      var fn = this.run('normalizeNode', node);

      if (!fn) {
        break;
      }

      this.withCommand(fn);
      var newValue = this.value;
      var newDocument = newValue.document;
      var found = newDocument.getNode(node.key);

      if (found && found.key === node.key) {
        node = found;
      } else {
        found = newDocument.getNode(node.key);

        if (found) {
          node = found;
        } else {
          break;
        }
      } // eslint-disable-next-line no-plusplus


      iterations++;

      if (iterations > max) {
        throw new Error('A schema rule could not be normalized after sufficient iterations. This is usually due to a `rule.normalize` or `plugin.normalizeNode` function of a schema being incorrectly written, causing an infinite loop.');
      }
    }
  };

  _proto.normalizeDirtyKeys = function normalizeDirtyKeys() {
    var _this7 = this;

    if (!this.flag.normalizing || !this.dirtyKeys.size) {
      return;
    }

    this.withoutNormalizing(function (self) {
      while (self.dirtyKeys.size) {
        self.dirtyKeys.forEach(function (key) {
          self.dirtyKeys["delete"](key);

          _this7.normalizeNodeByKey(key);
        });
      }
    });
  };

  _proto.normalizeSelection = function normalizeSelection() {
    var _this$value4 = this.value,
        document = _this$value4.document,
        selection = _this$value4.selection;
    var anchor = selection.anchor,
        focus = selection.focus;
    var anchorNode = document.getNode(anchor.key);
    var focusNode = document.getNode(focus.key);

    if (!anchorNode || !focusNode) {
      this.command(moveToStartOfDocument);
    } else {
      if (anchor.isTextPoint() && anchor.offset > anchorNode.text.length) {
        this.command(moveAnchorToEndOfNode, anchorNode);
      }

      if (focus.isTextPoint() && focus.offset > focusNode.text.length) {
        this.command(moveFocusToEndOfNode, focusNode);
      }
    }
  };

  _proto.groupNodes = function groupNodes(range, parent, groups) {
    var _this8 = this;

    if (groups === void 0) {
      groups = [];
    }

    var groupedNodes = [];
    var remainedRange = range;
    var isChildrenGrouped = false;

    while (remainedRange[0] < remainedRange[1]) {
      var _remainedRange = remainedRange,
          start = _remainedRange[0];
      var first = parent.nodes[start];

      var _this$run = this.run('groupNodes', remainedRange, {
        parent: parent,
        groups: groups
      }),
          node = _this$run.node,
          remained = _this$run.remainedRange;

      if (node !== first) {
        isChildrenGrouped = true;
        var maybeNestedGroup = node.merge({
          nodes: this.groupNodes([start, remained[0]], parent, [].concat(groups, [node]))
        });
        groupedNodes.push(maybeNestedGroup);

        if (!maybeNestedGroup.nodes[0] && process.env.NODE_ENV === 'development') {
          throw new Error('Cangjie.Plugin[groupNodes] expect return non-empty group.');
        }
      } else {
        groupedNodes.push(node);
      }

      remainedRange = remained;
    }

    var lastGroup = groups[groups.length - 1] || parent;

    if (isChildrenGrouped) {
      // 如果分组可见，需保证分组下的不可见节点的视图模型被成功计算
      if (this.enableOnDemandViewCalculation) {
        return groupedNodes.map(function (node) {
          return _this8.calculateViewInVisibleNode(node);
        });
      }

      return groupedNodes;
    }

    return isChildrenGrouped ? groupedNodes : lastGroup.nodes;
  };

  _proto.toViewText = function toViewText(text, decorations) {
    this.VIEW_CACHE.VIEW_NEVER_CALCULATED["delete"](text.key);
    var _this$value5 = this.value,
        selection = _this$value5.selection,
        composing = _this$value5.composing;
    var point = selection.anchor;
    var isCollapsedInText = selection.isCollapsed && point.isTextPoint() && point.key === text.key;

    if (!decorations.length && (!isCollapsedInText || !composing)) {
      return text;
    } // split leaves


    var leaves = text.leaves;

    if (decorations.length) {
      var _ref7 = this.VIEW_CACHE.LEAVES.get(leaves) || [],
          cachedViewLeaves = _ref7[0],
          cachedDepDecorations = _ref7[1];

      if (cachedViewLeaves && equal(cachedDepDecorations, decorations)) {
        leaves = cachedViewLeaves;
      } else {
        var viewLeaves = text.getLeaves(decorations);
        this.VIEW_CACHE.LEAVES.set(leaves, [viewLeaves, decorations]);
        leaves = viewLeaves;
      }
    }

    if (isCollapsedInText && composing && point.isTextPoint()) {
      var hasComposingLeaf = leaves.some(function (leaf) {
        return leaf.marks.some(function (mark) {
          return mark.type === 'cangjieComposing';
        });
      });

      if (!hasComposingLeaf) {
        leaves = insertComposingIntoLeaves(leaves, point.offset, composing, selection, decorations);
      }
    }

    var _ref8 = this.VIEW_CACHE.TEXT.get(text) || [],
        cachedViewText = _ref8[0],
        cachedDepLeaves = _ref8[1];

    if (cachedViewText && equal(cachedDepLeaves, leaves)) {
      return cachedViewText;
    }

    var viewText = text.set('leaves', leaves);
    this.VIEW_CACHE.TEXT.set(text, [viewText, leaves]);
    this.VIEW_CACHE.DATA.set(viewText, {
      decorations: decorations,
      injections: []
    });
    this.VIEW_CACHE.INJECT_TO_VIEW_TEXT.set(viewText, {
      decorations: decorations
    });
    return viewText;
  };

  _proto.toViewElement = function toViewElement(element, decorations, injections,
  /** 若当前节点可见，则其子孙节点也被认为可见 */
  isNodeVisible) {
    var _this9 = this;

    if (isNodeVisible === void 0) {
      isNodeVisible = false;
    }

    this.VIEW_CACHE.VIEW_NEVER_CALCULATED["delete"](element.key);
    var _this$value6 = this.value,
        document = _this$value6.document,
        selection = _this$value6.selection,
        composing = _this$value6.composing;
    var point = selection.anchor;
    var isCollapsedInElement = selection.isCollapsed && point.isTextPoint() && !!element.getKeysToEdgesTable()[point.key];
    var isCollapsedInEmptyElement = isCollapsedInElement && element.isEmpty();
    var computedComposing = isCollapsedInElement ? composing : '';

    var _ref9 = this.VIEW_CACHE.ELEMENT.get(element) || [],
        viewElement = _ref9[0],
        prevDecorations = _ref9[1],
        prevInjections = _ref9[2],
        prevComposing = _ref9[3];

    if (viewElement && equal(decorations, prevDecorations) && equal(injections, prevInjections) && computedComposing === prevComposing && !isCollapsedInEmptyElement) {
      return viewElement;
    }

    var nodeDecorations = this.VIEW_CACHE.DECORATE_NODE.get(element);

    if (isCollapsedInEmptyElement || !nodeDecorations) {
      nodeDecorations = this.run('decorateNode', element);
    }

    this.VIEW_CACHE.DECORATE_NODE.set(element, nodeDecorations);
    var allDecorations = nodeDecorations.length ? nodeDecorations.concat(decorations) : decorations;
    var nodeInjections = this.VIEW_CACHE.INJECT_TO_NODE.get(element);

    if (isCollapsedInEmptyElement || !nodeInjections) {
      nodeInjections = this.run('injectToNode', element);
    }

    this.VIEW_CACHE.INJECT_TO_NODE.set(element, nodeInjections);
    var allInjections = nodeInjections.length ? nodeInjections.concat(injections) : injections;
    var selfInjections = [];
    var descendantsInjections = [];
    allInjections.forEach(function (injection) {
      if (injection.key === element.key) {
        selfInjections.push(injection);
      } else {
        descendantsInjections.push(injection);
      }
    });
    var decoratedElement = element;

    var _ref10 = this.VIEW_CACHE.DECORATED_ELEMENT.get(element) || [],
        cachedDecoratedElement = _ref10[0],
        cachedDepsData = _ref10[1];

    var depsData = {
      decorations: allDecorations,
      injections: descendantsInjections,
      composing: computedComposing
    };

    if (cachedDecoratedElement && equal(cachedDepsData, depsData)) {
      decoratedElement = cachedDecoratedElement;
    } else {
      // delegate view data to children
      var childrenDecorations = allDecorations.length ? getChildrenDecorations(document, element, allDecorations) : null;
      var childrenInjections = descendantsInjections.length ? getChildrenInjections(document, element, descendantsInjections) : null;
      var isChildrenDecorated = false;
      var decoratedNodes = element.nodes.map(function (child, index) {
        var decoratedChild = _this9.toView(child, childrenDecorations ? childrenDecorations[index] : [], childrenInjections ? childrenInjections[index] : [], isNodeVisible);

        isChildrenDecorated = isChildrenDecorated || decoratedChild !== child;
        return decoratedChild;
      });
      var decorated = isChildrenDecorated ? element.set('nodes', decoratedNodes) : element;
      this.VIEW_CACHE.DECORATED_ELEMENT.set(element, [decorated, depsData]);
      decoratedElement = decorated;
    }

    var groupedElement = decoratedElement;
    var cachedGroupedElement = this.VIEW_CACHE.GROUPED_ELEMENT.get(decoratedElement);

    if (cachedGroupedElement) {
      groupedElement = cachedGroupedElement;
    } else {
      var groupedNodes = Block.isBlocks(decoratedElement.nodes) ? this.groupNodes([0, decoratedElement.nodes.length], decoratedElement) : decoratedElement.nodes;
      groupedElement = groupedNodes === decoratedElement.nodes ? decoratedElement : decoratedElement.set('nodes', groupedNodes);
      this.VIEW_CACHE.GROUPED_ELEMENT.set(decoratedElement, groupedElement);
    }

    var _ref11 = this.VIEW_CACHE.INJECTED_ELEMENT.get(groupedElement) || [],
        cachedViewElement = _ref11[0],
        cachedDepInjections = _ref11[1];

    if (cachedViewElement && equal(cachedDepInjections, selfInjections)) {
      return cachedViewElement;
    }

    var injectedElement = Injection.injectIntoNode(selfInjections, groupedElement);
    this.VIEW_CACHE.INJECTED_ELEMENT.set(groupedElement, [injectedElement, selfInjections]);
    this.VIEW_CACHE.ELEMENT.set(element, [injectedElement, decorations, injections, composing]);
    this.VIEW_CACHE.DATA.set(injectedElement, depsData);
    this.VIEW_CACHE.INJECT_TO_VIEW_ELEMENT.set(injectedElement, {
      decorations: decorations,
      injections: injections
    });
    return injectedElement;
  }
  /**
   * 将 Data Model 上的节点转换为 View Model 的节点
   * @param node
   * @param data
   */
  ;

  _proto.toView = function toView(node, decorations, injections, isNodeVisible) {
    if (isNodeVisible === void 0) {
      isNodeVisible = false;
    }

    var n = node.toSubType(); // 开启视图模型的按需重算后，节点视图模型将根据其可见与否决定是否重算

    if (this.enableOnDemandViewCalculation) {
      if (Document.isDocument(n)) {
        return this.toViewElement(n, decorations, injections);
      }

      if (isNodeVisible || this.isNodeVisible(node)) {
        return n.isText() ? this.toViewText(n, decorations) : this.toViewElement(n, decorations, injections, true);
      } else {
        if (n.isText()) {
          var _ref12 = this.VIEW_CACHE.TEXT.get(n) || [],
              viewCache = _ref12[0];

          if (!viewCache) {
            this.VIEW_CACHE.VIEW_NEVER_CALCULATED.add(n.key);
          }

          return viewCache || n;
        } else {
          var _ref13 = this.VIEW_CACHE.ELEMENT.get(n) || [],
              _viewCache = _ref13[0];

          if (!_viewCache) {
            this.VIEW_CACHE.VIEW_NEVER_CALCULATED.add(n.key);
          }

          return _viewCache || n;
        }
      }
    } else {
      return n.isText() ? this.toViewText(n, decorations) : this.toViewElement(n, decorations, injections);
    }
  }
  /**
   * 热区计算时，获得应当注入 Hot View Node 的 View Data
   * 根据当前变更判断是否需要重算 View Data
   * 1. 若需要：则携带（1）parent node 的被分发的视图数据（2） Top-Level(`controller.value.injections`, `controller.value.decorations`) 的视图数据， 重新为 node 分发视图数据
   * 2. 否则，使用缓存的视图数据
   * @param viewNode
   * @param dataNode
   * @returns
   */
  ;

  _proto.getInjectedViewData = function getInjectedViewData(viewNode, dataNode) {
    if (Document.isDocument(dataNode)) {
      return {
        decorations: this.value.decorations,
        injections: this.value.injections
      };
    }

    var document = this.value.document;
    var parent = document.assertParent(dataNode.key);
    var firstOp = this.$operationWithValues[0];
    var cacheKey = Element$1.isElement(viewNode) ? viewNode : parent;
    var cache = this.VIEW_CACHE.INJECT_TO_VIEW_ELEMENT.get(cacheKey);

    var deps = _extends({
      decorations: [],
      injections: []
    }, cache || {}); // 当上一次注入的 cache 无法获取时，也需要重新分发


    var decorationsChanged = !cache || firstOp && firstOp.value.decorations !== this.$value.decorations;
    var injectionsChanged = !cache || firstOp && firstOp.value.injections !== this.$value.injections;
    var injectedDecorations = deps.decorations;
    var injectedInjections = deps.injections; // 获得缓存的 deps

    if (decorationsChanged) {
      var _ref14 = this.VIEW_CACHE.INJECT_TO_VIEW_ELEMENT.get(parent) || {},
          _ref14$decorations = _ref14.decorations,
          parentDecorations = _ref14$decorations === void 0 ? [] : _ref14$decorations;

      injectedDecorations = parent ? getChildrenDecorations(document, parent, this.value.decorations.concat(parentDecorations))[parent.nodes.indexOf(dataNode)] : this.value.decorations;
    }

    if (injectionsChanged) {
      var _ref15 = this.VIEW_CACHE.INJECT_TO_VIEW_ELEMENT.get(parent) || {},
          _ref15$injections = _ref15.injections,
          parentInjections = _ref15$injections === void 0 ? [] : _ref15$injections; // BACKGGROUND: 部分插件 `injectToNode` 的实现有 anti-pattern，
      // 并非从当前节点测算，而从顶层节点（`document`）测算，因而其 injections 会写入顶层节点缓存
      // 故而这里要并入顶层节点的 injections 重新分发


      var docInjects = this.VIEW_CACHE.INJECT_TO_NODE.get(document) || [];
      injectedInjections = parent ? getChildrenInjections(document, parent, this.value.injections.concat(parentInjections).concat(docInjects))[parent.nodes.indexOf(dataNode)] : this.value.injections;
    } // 重新计算后，更新缓存


    this.VIEW_CACHE.INJECT_TO_VIEW_ELEMENT.set(cacheKey, {
      injections: injectedInjections,
      decorations: injectedDecorations
    });
    return {
      decorations: injectedDecorations,
      injections: injectedInjections
    };
  }
  /**
   * 重新计算热区中的视图模型
   * @param viewNode
   * @returns
   */
  ;

  _proto.recalculateView = function recalculateView(viewNode) {
    var cachedViewNode = this.$viewDoc.assertNode(viewNode.key);
    var dataNode = this.value.document.getNode(viewNode.key); // 诸如分组节点这样不存在与数据模型上的视图节点，不会被热区计算考虑，直接返回

    if (!dataNode) {
      return {
        node: viewNode,
        document: this.$viewDoc
      };
    }

    var newViewNode = cachedViewNode;
    var newViewDoc = this.$viewDoc; // 2. 结合最新的依赖，重算视图模型

    if (Element$1.isElement(viewNode)) {
      var _this$getInjectedView = this.getInjectedViewData(viewNode, dataNode),
          decorations = _this$getInjectedView.decorations,
          injections = _this$getInjectedView.injections;

      newViewNode = this.toViewElement(dataNode, decorations, injections, true);
      var path = this.$viewDoc.assertPath(newViewNode.key);
      newViewDoc = this.$viewDoc.replaceNode(path, newViewNode, this.noSpacialEffect());
    } // 3. 刷新视图模型缓存，并返回重新计算得到的 Node 和 Document 视图


    this.$viewDoc = newViewDoc;
    return {
      node: newViewNode,
      document: newViewDoc
    };
  }
  /**
   * 是否当前未产生节点空间的影响
   * 1. 协同变更无法评估是否对空间有影响
   * 2. 非协同变更：
   *   * Pending 时，无空间影响
   *   * 非 Pending 时，判断累积的操作是否有空间影响
   * @returns
   */
  ;

  _proto.noSpacialEffect = function noSpacialEffect() {
    return !this.hots.forceRecalculate && (this.isPending || this.$operationWithValues.every(function (op) {
      var operation = op.operation,
          key = op.key;

      if (!operation) {
        return isSetValueNotAffectSpace(key);
      }

      return isOperationNotAffectSpace(operation);
    }));
  }
  /**
   * 获得热区状态下的视图
   * @param node
   * @param document
   * @param shouldRecalculate
   * @returns
   */
  ;

  _proto.getView = function getView(node, document, shouldRecalculate) {
    if (this.hots.forceRecalculate) {
      return this.recalculateView(node);
    }

    if (shouldRecalculate && this.pendingType !== PendingType.selection) {
      return this.recalculateView(node);
    } // 如果没有变更，直接返回缓存的计算结果


    if (this.hasHots()) {
      var view = this.$viewDoc.assertNode(node.key);
      return {
        node: view,
        document: this.$viewDoc
      };
    }

    return {
      node: node,
      document: document
    };
  }
  /**
   * 执行一个函数，并在执行过程中，禁止任何的 normalize
   * @param fn 执行函数
   */
  ;

  _proto.withoutNormalizing = function withoutNormalizing(fn) {
    var prevNormalizing = this.flag.normalizing;
    this.flag.normalizing = false;
    fn(this);
    this.flag.normalizing = prevNormalizing;
    return this;
  }
  /**
   * 执行一个函数，并在执行过程中，禁止任何的 pending
   * @param fn 执行函数
   * @returns
   */
  ;

  _proto.withoutPending = function withoutPending(fn) {
    var prevPending = this.flag.pending;
    this.flag.pending = false;
    fn(this);
    this.flag.pending = prevPending;
    return this;
  }
  /**
   * 执行一个函数，并在执行过程中，不记录 undo stack
   * @param fn 执行函数
   * @returns
   */
  ;

  _proto.withoutSaving = function withoutSaving(fn, _temp) {
    var _this10 = this;

    var _ref16 = _temp === void 0 ? {} : _temp,
        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = _ref16.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

    var prevSaving = this.flag.saving;
    this.flag.saving = false;
    var nextOperationIndex = this.operations.length;
    this.withOpContext('cj/history/withoutsaving', function () {
      return fn(_this10);
    });

    if (!__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) {
      while (nextOperationIndex < this.operations.length) {
        var operation = this.operations[nextOperationIndex];
        var operationType = operation.type;

        if (operationType !== 'set_node' && operationType !== 'set_mark' && operationType !== 'add_mark' && operationType !== 'remove_mark' && operationType !== 'set_selection') {
          throw new Error('Cangjie.Controller.withoutSaving only support Operation[type=set_node|set_mark|add_mark|remove_mark|set_selection].');
        }

        nextOperationIndex += 1;
      }
    }

    this.flag.saving = prevSaving;
    return this;
  }
  /**
   * 执行一个函数，并在执行过程中禁止 op tracking
   * @param fn 执行函数
   * @returns
   */
  ;

  _proto.withoutTracking = function withoutTracking(fn) {
    var prevTracking = this.flag.tracking;
    this.flag.tracking = false;
    fn(this);
    this.flag.tracking = prevTracking;
    return this;
  };

  _proto.withCommand = function withCommand(fn) {
    var prevWithCommand = this.flag.withCommand;
    this.flag.withCommand = true;
    fn(this);
    this.flag.withCommand = prevWithCommand;
    return this;
  };

  _proto.withOpContext = function withOpContext(context, fn, meta) {
    if (meta) {
      this.context.push(context + "(" + JSON.stringify(meta) + ")");
    } else {
      this.context.push(context);
    }

    fn(this);
    this.context.pop();
    return this;
  }
  /**
   * 执行一个command
   * @param cmd command函数或者字符串。传入函数会直接执行，字符串则会调用所有插件的onCommand中对应的处理函数
   * @param args command的参数
   */
  ;

  _proto.command = function command(cmd) {
    var _this11 = this;

    if (process.env.NODE_ENV === 'development') {
      warning$1(this.flag.withCommand, 'Should not use Cangjie.Controller.command out of handlers or normalizer.');
    }

    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }

    if (typeof cmd === 'function') {
      cmd.apply(void 0, [this].concat(args));
    } else {
      this.run('onCommand', {
        type: cmd,
        args: args
      });
    }

    this.withoutTracking(function () {
      return _this11.normalizeDirtyKeys();
    });
    return this;
  }
  /**
   * 执行一个query
   * @param qry query函数或者字符串。传入函数会直接执行，字符串则会调用所有插件的onQuery中对应的处理函数
   * @param args query的参数
   */
  ;

  _proto.query = function query(qry) {
    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      args[_key4 - 1] = arguments[_key4];
    }

    if (typeof qry === 'function') {
      return qry.apply(void 0, [this].concat(args));
    }

    return this.run('onQuery', {
      type: qry,
      args: args
    });
  }
  /**
   * 触发一个插件的 action
   * @param name string action 名称
   * @param args  action 调用参数
   *
   * TODO: 插件迁移完成后，删掉 string 的定义
   */
  ;

  _proto.dispatch = function dispatch(name) {
    var creator = this.actions[name];

    if (creator) {
      for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        args[_key5 - 1] = arguments[_key5];
      }

      this.run('onAction', creator.apply(void 0, args));
    }
  }
  /**
   * 获取 action 判断函数。 返回的结果用于判断入参是否是某种 action, 支持 type predicate
   * @param name action Name: 插件基于 PluginActionPredicates 注册
   * @returns (action: any): action is SomeAction
   *
   * TODO: 插件迁移完成后，删掉 string 的定义
   */
  ;

  _proto.isActionFactory = function isActionFactory(name) {
    return this.isActions[name];
  }
  /**
   * 销毁当前 controller 实例
   */
  ;

  _proto.destroy = function destroy() {
    this.flag.destroyed = true;
    this.groupManager.cleanup();

    if (this.virtualize.invisibleCalculationId) {
      window.cancelIdleCallback(this.virtualize.invisibleCalculationId);
    }

    this.debouncedFlush.cancel();
    this.debouncedStartInvisibleCalculationScheduler.cancel();
    this.cleanup();
  }
  /**
   * 清理编辑器以及插件的cache
   */
  ;

  _proto.cleanup = function cleanup() {
    this.run('onCleanup');
  }
  /**
   * 获得当前编辑器的视图模型
   */
  ;

  /**
   * 获得 `node`  的视图数据
   * @param node
   */
  _proto.getViewData = function getViewData(node) {
    return this.VIEW_CACHE.DATA.get(node) || {
      decorations: [],
      injections: []
    };
  };

  _proto.setOpRelatedId = function setOpRelatedId(id) {
    this.flag.opRelatedId = id;
    return this;
  };

  _proto.setScrollType = function setScrollType(type) {
    this.flag.scrollType = type;
  };

  // 通知 pending 结束事件
  _proto.dispatchPendingTerminal = function dispatchPendingTerminal() {
    this.terminal$.next(null);
  };

  _proto.perfStart = function perfStart(payload) {
    var type = payload.type,
        subtype = payload.subtype;
    var perf = this.flag.perf[type];
    var timestamp = performance.now();
    perf.push({
      type: type,
      subtype: subtype || type,
      timestamp: timestamp
    });
    perfMark("cangjie-perf-" + (subtype || type) + "-start-" + timestamp);
  };

  _proto.perfEnd = function perfEnd(type, dropped) {
    if (dropped === void 0) {
      dropped = false;
    }

    var perf = this.flag.perf[type];
    var start = perf.shift();

    if (!start) {
      return;
    }

    var subtype = start.subtype,
        timestamp = start.timestamp;
    var endKey = "cangjie-perf-" + (subtype || type) + "-end-" + timestamp;
    var startKey = "cangjie-perf-" + (subtype || type) + "-start-" + timestamp;
    perfMark(endKey);

    if (start.ignore) {
      perfMeasure('cangjie-perf-ignore', startKey, endKey);
      return;
    }

    perfMeasure("cangjie-perf-" + subtype, startKey, endKey); // 计算准确时间

    var current = performance.now();
    var duration = current - timestamp;

    if (perf.length > 0) {
      duration -= current - perf[0].timestamp;
    }

    this.run('onCangjiePerf', CangjiePerfEvent({
      type: subtype,
      duration: duration,
      dropped: dropped
    }));
  }
  /**
   * 丢弃 perf 数据
   * @description BACKGROUND:
   * 通常 perf 队列遵循 **先进先出** 的原则，每一次入队都意味着一次交互事件的产生，正常出队的时机是在渲染后的 setTimeout 任务里（通过 perfEnd 出队）。
   * - 有些情况下我们不需要记录此次 perf 值（eg. 交互事件后未触发视图改变），所以通过 `perfDrop(type)` 异步地丢弃之；
   * - 特殊情况下，如果在正常出队前发现数据无效（eg. 丢帧：marcoTask 先于渲染执行）需要丢弃，则通过 `perfDrop(type, true)` 同步地丢弃之。
   * @param type PerfType
   * @param immediately 是否立即丢弃
   */
  ;

  _proto.perfDrop = function perfDrop(type, immediately) {
    var _this12 = this;

    if (immediately === void 0) {
      immediately = false;
    }

    if (immediately) {
      var _ref17 = this.flag.perf[type].shift() || {},
          subtype = _ref17.subtype,
          timestamp = _ref17.timestamp;

      var endKey = "cangjie-perf-" + subtype + "-end-" + timestamp;
      subtype && perfMark(endKey);
      return;
    } // 延迟丢弃时，先标记该数据 ignore


    var lastIndex = this.flag.perf[type].length - 1;

    if (lastIndex >= 0 && this.flag.perf[type][lastIndex]) {
      this.flag.perf[type][lastIndex].ignore = true;
      setTimeout(function () {
        var _ref18 = _this12.flag.perf[type].shift() || {},
            subtype = _ref18.subtype,
            timestamp = _ref18.timestamp;

        var endKey = "cangjie-perf-" + subtype + "-end-" + timestamp;
        subtype && perfMark(endKey);
      });
    }
  };

  _proto.perfClearAll = function perfClearAll() {
    var _this13 = this;

    Object.keys(this.flag.perf).forEach(function (type) {
      _this13.flag.perf[type] = [];
    });
  };

  _proto.setUid = function setUid(dataUid) {
    this.uid = dataUid === undefined ? undefined : String(dataUid);
  };

  _proto.switchUid = function switchUid(dataUid) {
    this.setUid(dataUid);
    this.userData.update$.next({
      uuid: '*'
    });
  };

  _proto.getHots = function getHots$1() {
    if (this.$operationWithValues.length <= (this.virtualizeOptions.maxOPsForHotsAnalyze || 0)) {
      return getHots(this.$operationWithValues, this);
    }

    return [];
  };

  _proto.setHots = function setHots(hots, pendingType, forceRecalculate) {
    if (forceRecalculate === void 0) {
      forceRecalculate = false;
    }

    this.hots = {
      hots: hots,
      keys: hots.reduce(function (ret, hot) {
        ret[hot.node.key] = true;
        return ret;
      }, {}),
      pendingType: pendingType,
      lengthOfPending: pendingType ? this.$operationWithValues.length : 0,
      forceRecalculate: forceRecalculate
    };

    if (hots.length) {
      this.hots$.next(hots);
    }

    return this;
  };

  _proto.clearHots = function clearHots() {
    this.hots = {
      hots: [],
      keys: {},
      pendingType: null,
      lengthOfPending: 0,
      forceRecalculate: false
    };
    return this;
  };

  _proto.hasHots = function hasHots() {
    return this.hots.hots.length > 0;
  }
  /** 是否开启热区 */
  ;

  /**
   * 当前节点视图是否热
   * @param viewNode
   * @returns
   */
  _proto.isViewHot = function isViewHot(viewNode) {
    if (!this.enableHots) {
      return false;
    }

    return !!this.hots.keys[viewNode.key] && this.$value.document.hasNode(viewNode.key);
  };

  _proto.addIsSelected = function addIsSelected(key) {
    this.VIEW_CACHE.IS_SELECTED.add(key);
  };

  _proto.getIsSelected = function getIsSelected(key) {
    return this.VIEW_CACHE.IS_SELECTED.has(key);
  };

  _proto.removeIsSelected = function removeIsSelected(key) {
    this.VIEW_CACHE.IS_SELECTED["delete"](key);
  }
  /**
   * 1. 若配置了闪享光标，则 blur 时需要显示远程光标
   * 2. 否则，根据配置项 hideSelectionOnBlur 决定是否需要隐藏
   * @returns 是否需要不显示选区
   */
  ;

  _proto.shouldHideSelectionOnBlur = function shouldHideSelectionOnBlur() {
    var _this$showCaret;

    return !((_this$showCaret = this.showCaret) != null && _this$showCaret.onBlur) && this.hideSelectionOnBlur;
  }
  /**
   * 是否开启虚拟化
   */
  ;

  /**
   * 虚拟化时，是否节点可见
   * @param node
   * @returns
   */
  _proto.isNodeVisible = function isNodeVisible(node) {
    var _this14 = this;

    if (!Element$1.isElement(node)) {
      return false;
    }

    var visibles = this.virtualize.visibles;
    return visibles.some(function (visible) {
      if (node.key === visible) {
        return true;
      } // 如果可见节点是视图模型上的节点，则判断节点是否在视图模型上


      if (!_this14.value.document.hasNode(visible)) {
        var _this14$$viewDoc;

        var viewElement = (_this14$$viewDoc = _this14.$viewDoc) == null ? void 0 : _this14$$viewDoc.getNode(visible);
        return (viewElement == null ? void 0 : viewElement.isElement()) && viewElement.hasNode(node.key);
      }

      return false;
    });
  }
  /**
   * 是否 visibles 中存在未计算过视图模型的节点
   * 当节点被认为不可见后，它的视图模型不会被计算，那么下一次可见时：
   * - 节点本身可见
   * - 节点所在分组可见
   * 此时，需要保证节点的视图模型能够被正确计算
   * @param visibles
   * @returns
   */
  ;

  _proto.hasViewNeverCalculatedInVisibles = function hasViewNeverCalculatedInVisibles(visibles) {
    var _this15 = this;

    return visibles.some(function (visible) {
      if (_this15.VIEW_CACHE.VIEW_NEVER_CALCULATED.has(visible)) {
        return true;
      }

      if (!_this15.value.document.hasNode(visible)) {
        var _this15$$viewDoc;

        var viewElement = (_this15$$viewDoc = _this15.$viewDoc) == null ? void 0 : _this15$$viewDoc.assertElement(visible);
        return !!(viewElement != null && viewElement.findDescendant(function (node) {
          return node.isElement() && _this15.VIEW_CACHE.VIEW_NEVER_CALCULATED.has(node.key);
        }));
      }

      return false;
    });
  }
  /**
   * 设置虚拟化的可见节点集合
   * @param visibles
   */
  ;

  _proto.setVirtualize = function setVirtualize(key, value) {
    var document = this.value.document;

    if (key === 'visibles' && !equal(this.virtualize[key], value)) {
      var visibles = value;
      this.virtualize.visibles = visibles; // 如果 visible 中存在未计算过视图模型的节点，则需要重算视图模型

      if (this.hasViewNeverCalculatedInVisibles(visibles)) {
        //清理视图缓存，避免节点可见后，取到旧的视图模型缓存
        this.clearHots();
        this.VIEW_CACHE.VALUE["delete"](this.value);
        this.VIEW_CACHE.ELEMENT["delete"](document);
        this.VIEW_CACHE.DECORATED_ELEMENT["delete"](document);
        this.VIEW_CACHE.INJECTED_ELEMENT["delete"](document);
        this.VIEW_CACHE.GROUPED_ELEMENT["delete"](document);
        this.view;
      }

      this.visibles$.next(visibles); // 每当可视节点发生变化，则重新开始调度不可见节点的计算

      this.debouncedStartInvisibleCalculationScheduler(visibles);
    } else {
      this.virtualize[key] = value;
    }

    return this;
  };

  _createClass(Controller, [{
    key: "view",
    get: function get() {
      if (this.hasHots() && this.$viewDoc) {
        return this.$viewDoc;
      }

      var _this$value7 = this.value,
          document = _this$value7.document,
          decorations = _this$value7.decorations,
          injections = _this$value7.injections;

      if (this.VIEW_CACHE.VALUE.has(this.value)) {
        var _ref19 = this.VIEW_CACHE.DECORATED_ELEMENT.get(document) || [],
            decoratedDocument = _ref19[0];

        if (decoratedDocument) {
          var groupedDocument = this.VIEW_CACHE.GROUPED_ELEMENT.get(decoratedDocument);

          if (groupedDocument) {
            var _ref20 = this.VIEW_CACHE.INJECTED_ELEMENT.get(groupedDocument) || [],
                viewDocument = _ref20[0];

            if (viewDocument) {
              return viewDocument;
            }
          }
        }
      }

      this.VIEW_CACHE.VALUE.add(this.value);
      var viewDoc = this.toView(document, decorations, injections);
      this.$viewDoc = viewDoc;
      return viewDoc;
    }
  }, {
    key: "opRelatedId",
    get: function get() {
      return this.flag.opRelatedId;
    }
  }, {
    key: "shouldResumePosition",
    get: function get() {
      return this.flag.scrollType === 'maintain';
    }
  }, {
    key: "shouldScrollToSelection",
    get: function get() {
      return this.flag.scrollType === 'toSelection';
    }
  }, {
    key: "isPending",
    get: function get() {
      // OP Pending 或热区过程中
      return !!this.pendingQueue.type || !!this.hots.pendingType;
    }
  }, {
    key: "enablePending",
    get: function get() {
      return this.pendingQueue.enablePending;
    }
  }, {
    key: "isPendingEnable",
    get: function get() {
      return Object.values(this.pendingQueue.enablePending).some(function (s) {
        return !!s;
      }) && this.flag.pending;
    }
  }, {
    key: "pendingType",
    get: function get() {
      // 热区 debounce 时，pending type
      if (this.hasHots()) {
        return this.hots.pendingType;
      }

      return this.pendingQueue.type || this.testType;
    }
  }, {
    key: "isTracking",
    get: function get() {
      return this.flag.tracking;
    }
  }, {
    key: "enableHots",
    get: function get() {
      var _this$virtualizeOptio = this.virtualizeOptions,
          enable = _this$virtualizeOptio.enable,
          pendingDebounceTime = _this$virtualizeOptio.pendingDebounceTime;
      return enable && typeof pendingDebounceTime === 'number' && pendingDebounceTime > 0;
    }
  }, {
    key: "enableVirtualize",
    get: function get() {
      return this.virtualizeOptions.enable;
    }
    /**
     * 是否开启模型虚拟化以及视图虚拟化
     */

  }, {
    key: "enableVirtualizeView",
    get: function get() {
      return this.virtualizeOptions.enable && !this.virtualizeOptions.disableViewVirtualize;
    }
    /** 是否开启按需计算 */

  }, {
    key: "enableOnDemandViewCalculation",
    get: function get() {
      return !!this.virtualizeOptions.enable && this.virtualizeOptions.enableOnDemandViewCalculation;
    }
  }, {
    key: "visibleBlocks",
    get: function get() {
      return this.virtualize.visibles;
    }
  }, {
    key: "scrollableContainer",
    set: function set(scrollableContainer) {
      this.$scrollableContainer = scrollableContainer;
    },
    get: function get() {
      return this.$scrollableContainer || window;
    }
  }, {
    key: "enableUUID",
    get: function get() {
      return this.uuidConfig.enable;
    }
  }]);

  return Controller;
}();
/**
 * @ignore
 */


Controller.useController = useController;
Controller.useControllerStatic = useControllerStatic;
Controller.connectController = connectController;
var ControllerContext = /*#__PURE__*/React.createContext(null);

/**
 * @packageDocumentation
 * @module Hooks
 */

/**
 * 样式 context
 */
var StyleContext = /*#__PURE__*/React__default.createContext(undefined);
function useStyle() {
  return React__default.useContext(StyleContext);
}
/**
 * 获取节点样式
 * @returns React.CSSProperties
 */

function useNodeStyle(controller, node, visible) {
  if (visible === void 0) {
    visible = true;
  }

  var docStyle = React__default.useContext(StyleContext); // 非 block 元素不消费 style，return 以提高性能

  if (!Block.isBlock(node)) return {};
  var style = controller.run('getNodeStyle', {
    node: node,
    docStyle: docStyle
  }) || {};

  if (visible === false) {
    style.display = 'none';
  }

  return style;
}
/**
 * 获取全局默认文本样式
 * @returns React.CSSProperties
 */

function useContentStyle(controller) {
  var docStyle = React__default.useContext(StyleContext);
  var style = controller.run('getContentStyle', {
    docStyle: docStyle
  }) || {};
  return style;
}

/**
 * @packageDocumentation
 * @module Controller
 */
var _createElement$f = React.createElement;
function Provider(props) {
  var _options$showCaret, _options$showCaret2, _controller$virtualiz;

  var biz = props.biz,
      dataUid = props.dataUid,
      plugins = props.plugins,
      value = props.value,
      _props$onChange = props.onChange,
      onChange = _props$onChange === void 0 ? noop : _props$onChange,
      _props$controllerRef = props.controllerRef,
      controllerRef = _props$controllerRef === void 0 ? noop : _props$controllerRef,
      children = props.children,
      _props$readOnly = props.readOnly,
      readOnly = _props$readOnly === void 0 ? false : _props$readOnly,
      _props$autoFocus = props.autoFocus,
      autoFocus = _props$autoFocus === void 0 ? false : _props$autoFocus,
      canCopy = props.canCopy,
      options = props.options,
      flushType = props.flushType,
      configs = props.configs,
      onBusyStateChange = props.onBusyStateChange,
      onFirstRender = props.onFirstRender,
      docStyle = props.docStyle,
      _props$onPending = props.onPending,
      onPending = _props$onPending === void 0 ? noop : _props$onPending;
  var pluginsRef = React.useRef();
  var onChangeRef = React.useRef();
  var prevValueRef = React.useRef(value);
  var controller = React.useMemo(function () {
    var controllerIns = Controller.create({
      biz: biz,
      dataUid: dataUid,
      plugins: plugins,
      value: value,
      onChange: onChange,
      readOnly: readOnly,
      autoFocus: autoFocus,
      canCopy: canCopy,
      flushType: flushType,
      configs: configs,
      onBusyStateChange: onBusyStateChange,
      onPending: onPending
    }, options);
    pluginsRef.current = plugins;
    onChangeRef.current = onChange;
    controllerIns.groupManager.generateAllGroups();
    return controllerIns; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  React.useLayoutEffect(function () {
    if (onFirstRender) {
      onFirstRender(controller);
    }
  }, []);
  React.useEffect(function () {
    controller.showCaret = options == null ? void 0 : options.showCaret;
  }, [options == null ? void 0 : (_options$showCaret = options.showCaret) == null ? void 0 : _options$showCaret.onBlur, options == null ? void 0 : (_options$showCaret2 = options.showCaret) == null ? void 0 : _options$showCaret2.onReadOnly]); // 因 canCopy 而重新生成 controller 会导致后续的交互出 BUG

  React.useEffect(function () {
    if (typeof canCopy === 'boolean') {
      controller.canCopy = canCopy;
    }
  }, [controller, canCopy]);
  React.useEffect(function () {
    if (process.env.NODE_ENV === 'development') {
      warning$1(plugins === pluginsRef.current, "Cangjie.Provider will ignore `plugins`'s change.");
      warning$1(onChange === onChangeRef.current, "Cangjie.Provider will ignore `onChange`'s change.");
    }
  }, [plugins, onChange]);
  React.useEffect(function () {
    // uid 变化，刷新用户数据
    controller.switchUid(dataUid);
  }, [dataUid]);
  controllerRef(controller);

  if (readOnly !== controller.readOnly) {
    controller.setReadOnly(readOnly);
  }

  if (controller.enableVirtualize && (_controller$virtualiz = controller.virtualizeManager) != null && _controller$virtualiz.viewInitialized) {
    controller.virtualizeManager.workflowOnValueChange();
  } // Note: This action will trigger normalize


  if (value !== prevValueRef.current && value !== controller.value) {
    controller.resetValue(value, options);
  }

  prevValueRef.current = value;
  var context = React.useMemo(function () {
    var subject = new Subject();
    return {
      controller: controller,
      subject: subject
    };
  }, [controller]); // Note: Force re-render except first mount.

  var didMountRef = React.useRef(false);
  React.useEffect(function () {
    if (didMountRef.current) {
      context.subject.next(value);
    } else {
      didMountRef.current = true;
    }
  }, [value]);
  React.useEffect(function () {
    if (autoFocus) {
      controller.command(focus).flush();
    }
  }, [controller, autoFocus]);
  React.useEffect(function () {
    // 首次渲染完成，刷新分组信息
    controller.groupManager.notifyNewGroups(true);
    return function () {
      controller.destroy();
    };
  }, [controller]);
  React.useEffect(function () {
    if (IS_DEV) {
      var _React$version$split = React.version.split('.'),
          main = _React$version$split[0];

      warning$1(Number(main) < 18, 'React > 17 is not fully supported, editor will have some weird problems.');
    }
  }, []);
  return /*#__PURE__*/_createElement$f(ControllerContext.Provider, {
    value: context
  }, /*#__PURE__*/_createElement$f(StyleContext.Provider, {
    value: docStyle
  }, children));
}

var Decoration = /*#__PURE__*/function (_ImmutableRecord) {
  _inheritsLoose(Decoration, _ImmutableRecord);

  Decoration.create = function create(props) {
    if (Decoration.isDecoration(props)) {
      return props;
    }

    if (isPlainObject(props)) {
      var start = props.start,
          end = props.end,
          mark = props.mark;
      return new Decoration({
        start: TextPoint.create(start),
        end: TextPoint.create(end),
        mark: Mark.create(mark)
      });
    }

    throw new Error("`Decoration.create` only accepts objects or decorations, but you passed it: " + props);
  };

  Decoration.fromJSON = function fromJSON(json) {
    var start = json.start,
        end = json.end,
        mark = json.mark;
    return Decoration.create({
      start: TextPoint.fromJSON(start),
      end: TextPoint.fromJSON(end),
      mark: Mark.fromJSON(mark)
    });
  };

  Decoration.isDecoration = function isDecoration(maybeDecoration) {
    return maybeDecoration instanceof Decoration;
  }
  /**
   * Decoration的start point
   */
  ;

  function Decoration(props) {
    var _this;

    _this = _ImmutableRecord.call(this) || this;
    _this.start = void 0;
    _this.end = void 0;
    _this.mark = void 0;
    var start = props.start,
        end = props.end,
        mark = props.mark;
    _this.start = start;
    _this.end = end;
    _this.mark = mark;

    _this.freeze();

    return _this;
  }

  var _proto = Decoration.prototype;

  _proto.merge = function merge(props) {
    return new Decoration(_extends({
      start: this.start,
      end: this.end,
      mark: this.mark
    }, props));
  };

  _proto.set = function set(key, value) {
    var _this$merge;

    return this.merge((_this$merge = {}, _this$merge[key] = value, _this$merge));
  };

  _proto.toJSON = function toJSON(options) {
    return {
      start: this.start.toJSON(options),
      end: this.end.toJSON(options),
      mark: this.mark.toJSON()
    };
  };

  return Decoration;
}(ImmutableRecord);

function mergeUserProperties(value, operation) {
  var _properties$data;

  var path = operation.path,
      properties = operation.properties,
      context = operation.context; // 将当前 OP 中用户数据与 value 上的合并
  // 避免协同编辑下，不同用户/不同段落 OP 数据相互覆盖

  var matched = context == null ? void 0 : context.match(/userdata\/(.*)\/(.*)/);
  var targetData = (properties == null ? void 0 : (_properties$data = properties.data) == null ? void 0 : _properties$data.userData) || {};

  if (matched && (path == null ? void 0 : path.length) === 0 && targetData) {
    var _value$document$data;

    var mergedData = ((_value$document$data = value.document.data) == null ? void 0 : _value$document$data.userData) || {}; // context 上携带此次修改用户数据的 uid 和块 uuid

    var mUid = matched[1];
    var uids = [];

    if (mUid === '*') {
      uids = union$1(Object.keys(mergedData), Object.keys(targetData));
    } else if (mUid) {
      uids = [mUid];
    }

    var uuids = matched[2].split(',');
    uids.forEach(function (uid) {
      uuids.forEach(function (uuid) {
        var _targetData$uid;

        var target = targetData == null ? void 0 : (_targetData$uid = targetData[uid]) == null ? void 0 : _targetData$uid[uuid];

        if (uuid) {
          if (target === undefined) {
            var _mergedData, _extends2;

            // 删除数据
            mergedData = _extends({}, mergedData, (_extends2 = {}, _extends2[uid] = omit((_mergedData = mergedData) == null ? void 0 : _mergedData[uid], uuid), _extends2));
          } else {
            var _mergedData2, _extends3, _extends4;

            // 用 op 中 uuid 对应数据覆盖 document 上对应的
            mergedData = _extends({}, mergedData, (_extends4 = {}, _extends4[uid] = _extends({}, (_mergedData2 = mergedData) == null ? void 0 : _mergedData2[uid], (_extends3 = {}, _extends3[uuid] = target, _extends3)), _extends4));
          }
        }
      });
    });
    return _extends({}, properties, {
      data: omitDeepBy(_extends({}, properties.data, {
        userData: mergedData
      }), isEmptyObj)
    });
  }

  return properties;
}

var warning = typeof console !== 'undefined' ? once(console.warn.bind(console) || function () {}) : noop;

function getDefaultSelection(document) {
  var firstNode = document.getFirstNode();

  if (Text$1.isText(firstNode)) {
    var _point = TextPoint.create({
      key: firstNode.key,
      offset: 0
    });

    return Selection.create({
      anchor: _point,
      focus: _point
    });
  }

  var point = EdgePoint.create({
    key: document.key,
    edge: EdgePoint.BEFORE
  });
  return Selection.create({
    anchor: point,
    focus: point
  });
}

var Value = /*#__PURE__*/function (_ImmutableRecord) {
  _inheritsLoose(Value, _ImmutableRecord);

  Value.create = function create(props) {
    if (props === void 0) {
      props = {};
    }

    if (Value.isValue(props)) {
      return props;
    }

    if (isPlainObject(props)) {
      var _props = props,
          _props$data = _props.data,
          data = _props$data === void 0 ? {} : _props$data,
          _props$document = _props.document,
          doc = _props$document === void 0 ? {} : _props$document,
          selection = _props.selection,
          _props$remoteSelectio = _props.remoteSelections,
          remoteSelections = _props$remoteSelectio === void 0 ? [] : _props$remoteSelectio,
          _props$injections = _props.injections,
          injections = _props$injections === void 0 ? [] : _props$injections,
          _props$decorations = _props.decorations,
          decorations = _props$decorations === void 0 ? [] : _props$decorations,
          _props$composing = _props.composing,
          composing = _props$composing === void 0 ? '' : _props$composing,
          _props$isFocused = _props.isFocused,
          isFocused = _props$isFocused === void 0 ? false : _props$isFocused;
      var document = Document.create(doc);
      return new Value({
        data: data,
        document: document,
        selection: selection || getDefaultSelection(document),
        remoteSelections: remoteSelections,
        injections: injections,
        decorations: decorations,
        composing: composing,
        isFocused: isFocused
      });
    }

    throw new Error("`Value.create` only accepts objects or values, but you passed it: " + props);
  };

  Value.fromJSON = function fromJSON(json) {
    var _json$document = json.document,
        document = _json$document === void 0 ? {} : _json$document,
        injections = json.injections,
        selection = json.selection,
        remoteSelections = json.remoteSelections,
        decorations = json.decorations;
    var documentValue = Document.fromJSON(document);
    return Value.create(_extends({}, json, {
      injections: injections ? injections.map(Injection.fromJSON) : undefined,
      document: documentValue,
      selection: selection ? Selection.fromJSON(selection) : getDefaultSelection(documentValue),
      remoteSelections: remoteSelections ? remoteSelections.map(Selection.fromJSON) : undefined,
      decorations: decorations ? decorations.map(Decoration.fromJSON) : undefined
    }));
  };

  Value.isValue = function isValue(maybeValue) {
    return maybeValue instanceof Value;
  }
  /**
   * value 的 injections 数组
   */
  ;

  _createClass(Value, [{
    key: "rangeSelection",

    /**
     * 当前的选区
     */
    get: function get() {
      if ('development' === process.env.NODE_ENV) {
        warning('`Value.rangeSelection` is deprecated, please use `Value.selection`');
      }

      return this.selection;
    }
    /**
     * 远程选区
     */

  }]);

  function Value(props) {
    var _this;

    _this = _ImmutableRecord.call(this) || this;
    _this.injections = void 0;
    _this.decorations = void 0;
    _this.isFocused = void 0;
    _this.data = void 0;
    _this.document = void 0;
    _this.selection = void 0;
    _this.remoteSelections = [];
    _this.composing = '';
    var data = props.data,
        document = props.document,
        selection = props.selection,
        remoteSelections = props.remoteSelections,
        injections = props.injections,
        decorations = props.decorations,
        composing = props.composing,
        isFocused = props.isFocused;
    _this.data = _extends({}, data);
    _this.document = document;
    _this.selection = selection;
    _this.remoteSelections = remoteSelections;
    _this.injections = injections;
    _this.decorations = decorations;
    _this.composing = composing;
    _this.isFocused = isFocused;

    _this.freeze();

    return _this;
  }
  /**
   * 获取当前选中的blocks
   */


  var _proto = Value.prototype;

  _proto.getElement = function getElement(pointName, type) {
    var document = this.document,
        selection = this.selection;

    if (!selection) {
      return null;
    }

    var point = selection.getPoint(pointName, document);

    if (type === 'block') {
      return document.getClosestBlockFromPoint(point.key);
    } else if (type === 'inline') {
      return document.getClosestInline(point.key);
    } else {
      return document.getNode(point.key);
    }
  }
  /**
   * 获取当前选中的anchor位置对应的block
   */
  ;

  _proto.merge = function merge(props) {
    return new Value(_extends({
      data: this.data,
      document: this.document,
      selection: this.selection,
      remoteSelections: this.remoteSelections,
      injections: this.injections,
      decorations: this.decorations,
      composing: this.composing,
      isFocused: this.isFocused
    }, props));
  };

  _proto.set = function set(key, value) {
    var _this$merge;

    return this.merge((_this$merge = {}, _this$merge[key] = value, _this$merge));
  };

  _proto.updatePoints = function updatePoints(document, map, removed) {
    var updateSelections = function updateSelections(selections, selection) {
      if (!Selection.isSelection(selection)) {
        return [].concat(selections, [selection]);
      }

      var anchor = selection.anchor,
          focus = selection.focus;

      if (anchor.isEdgePoint() || focus.isEdgePoint()) {
        var _selection$convertToT = selection.convertToTextPoints(document);

        anchor = _selection$convertToT.anchor;
        focus = _selection$convertToT.focus;
      }

      var newAnchor = map(anchor);
      var newFocus = map(focus);

      if (!newAnchor || !newFocus) {
        return selections;
      }

      if (equal(newAnchor, anchor) && equal(newFocus, focus) && Selection.isValidSelection(document, selection)) {
        // 如果选区没有任何变化，返回原选区即可
        return [].concat(selections, [selection]);
      }

      return [].concat(selections, [selection.merge({
        anchor: newAnchor,
        focus: newFocus
      })]);
    }; // FIXME: 当 Document 内没有 Text 节点时，无法被 focus，等价于废档


    var selections = [this.selection].reduce(updateSelections, []);
    var remoteSelections = this.remoteSelections.reduce(updateSelections, []);
    var decorations = this.decorations.reduce(function (decs, dec) {
      var start = dec.start,
          end = dec.end;
      var newStart = map(start);
      var newEnd = map(end);

      if (!newStart || !newEnd) {
        return decs;
      }

      var startText = document.getNode(newStart.key);
      var endText = document.getNode(newEnd.key);

      if (!startText || !endText) {
        return decs;
      }

      if (removed && Block.isBlock(removed) && [start, end].every(function (n) {
        return removed.getNode(n.key);
      })) {
        // 删除 Block 节点时, 内部包含的 decoration 清空掉
        return decs;
      }

      if (equal(newStart, newEnd) && startText.text) {
        return decs;
      }

      return [].concat(decs, [dec.merge({
        start: newStart,
        end: newEnd
      })]);
    }, []);
    return this.merge({
      selection: selections[0] || getDefaultSelection(document),
      remoteSelections: remoteSelections,
      decorations: decorations
    });
  };

  _proto.addMark = function addMark(path, offset, length, mark) {
    var document = this.document;
    document = document.addMark(path, offset, length, mark);
    return this.set('document', document);
  };

  _proto.insertNode = function insertNode(path, node) {
    var document = this.document;
    document = document.insertNode(path, node);
    return this.set('document', document);
  };

  _proto.insertText = function insertText(path, offset, text, marks) {
    var prevDoc = this.document;
    var document = prevDoc.insertText(path, offset, text, marks); // node must be Text if .insertText works.

    var node = prevDoc.assertTextByPath(path);
    return this.updatePoints(document, function (point) {
      // 若在当前选区之前插入文本，则需要后移选区
      // insert 'e'
      //   │    cursor
      //   ▼     │
      //  HlloWor│ld
      //         │
      //
      //     │
      //     │ inserted
      //     ▼
      //
      //          │
      //  HelloWor│d
      //          │
      //        cursor
      if (node.key === point.key && offset <= point.offset) {
        return point.moveForward(text.length);
      }

      return point;
    }).set('document', document);
  };

  _proto.mergeNode = function mergeNode(path) {
    var prevDoc = this.document,
        prevInject = this.injections;
    var document = prevDoc.mergeNode(path);
    var injections = prevInject.filter(function (_ref) {
      var key = _ref.key;
      var injectTargetPath = prevDoc.getPath(key);
      return injectTargetPath && !Path.isEqual(injectTargetPath, path);
    }); // prev & node could not be null if .mergeNode works.

    var prev = prevDoc.getPreviousSiblingByPath(path);
    var node = prevDoc.getNodeByPath(path);
    return this.updatePoints(document, function (point) {
      // 如果选区所在的文本被 merge，则需要将光标移动到合并后的文本，并且修正光标起点
      //     ┌─────────┐  cursor
      //     │         │ │
      // ┌───▼───┐ ┌───┴─┼────┐
      // │ Hello │ │ Worl│d   │
      // └───────┘ └─────┼────┘
      //                 │
      //        │
      //        │ merged
      //        │
      //        ▼  
      //
      //           │
      // ┌─────────┼──┐
      // │HelloWorl│d │
      // └─────────┼──┘
      //           │
      //          cursor
      if (Text$1.isText(node) && point.key === node.key) {
        return point.merge({
          key: prev.key,
          offset: prev.text.length + point.offset
        });
      }

      return point;
    }).merge({
      document: document,
      injections: injections
    });
  };

  _proto.moveNode = function moveNode(path, newPath) {
    if (equal(path, newPath)) {
      return this;
    }

    var document = this.document;
    document = document.moveNode(path, newPath);
    return this.set('document', document);
  };

  _proto.removeMark = function removeMark(path, offset, length, mark) {
    var document = this.document;
    document = document.removeMark(path, offset, length, mark);
    return this.set('document', document);
  };

  _proto.removeNode = function removeNode(path) {
    var prevDoc = this.document,
        prevInject = this.injections;
    var node = prevDoc.assertNodeByPath(path);
    var prev = prevDoc.getPreviousNodeByPath(path);
    var next = prevDoc.getNextNodeByPath(path);
    var document = prevDoc.removeNode(path);
    var injections = prevInject.filter(function (_ref2) {
      var key = _ref2.key;
      var injectTargetPath = prevDoc.getPath(key);
      return injectTargetPath && !Path.isEqual(injectTargetPath, path);
    }); // `document.nodes` is empty.

    if (!prev && !next) {
      return this.merge({
        document: document,
        selection: getDefaultSelection(document),
        remoteSelections: [],
        injections: [],
        decorations: [],
        composing: ''
      });
    }

    return this.updatePoints(document, function (point) {
      if (node.key === point.key || node.isElement() && node.hasNode(point.key)) {
        // 若删除选区所在的节点或者其父节点，则要么移动选区到上一节点末，要么移动选区到下一节点开头
        //              cursor
        // ┌───────┐ ┌────┼───┐
        // │ Hello │ │ Wor│ld │
        // └───────┘ └────┼───┘
        //
        //          │
        //          │ removed
        //          ▼
        //
        // ┌──────┼┐
        // │ Hello││
        // └──────┼┘
        //      cursor
        if (prev) {
          var lastText = prev.getLastText();

          if (lastText) {
            return point.moveToEndOfNode(lastText);
          }
        } //       cursor
        //       │
        //  ┌────┼───┐ ┌───────┐
        //  │ Wor│ld │ │ Hello │
        //  └────┼───┘ └───────┘
        //       │
        //         │
        //         │ removed
        //         ▼
        //   │
        //  ┌┼──────┐
        //  ││Hello │
        //  └┼──────┘
        //   │
        // cursor


        if (next) {
          var firstText = next.getFirstText();

          if (firstText) {
            return point.moveToStartOfNode(firstText);
          }
        }

        return null;
      }

      return point;
    }, node).merge({
      document: document,
      injections: injections
    });
  };

  _proto.removeText = function removeText(path, offset, text) {
    var prevDoc = this.document;
    var document = prevDoc.removeText(path, offset, text); // node must be Text if .insertText works.

    var node = prevDoc.assertTextByPath(path);
    var start = offset;
    var end = start + text.length;
    return this.updatePoints(document, function (point) {
      if (node.key === point.key) {
        // 若当前选区在删除文本之后，则需要前移选区
        //          cursor
        //   ┌────┐   │
        //  H│ello│Wor│d
        //   └────┘   │
        //
        //       │
        //       │      removed
        //       ▼
        //
        //      │
        //  HWor│d
        //      │
        //    cursor
        if (point.offset >= end) {
          return point.moveBackward(text.length);
        } // 若当前选区在删除文本起点之后，则前移选区到删除起点
        //   ┌────┐
        //  H│ello│World
        //   └────┘
        //      ──────  selection
        //
        //      │
        //      │      removed
        //      ▼
        //
        //   HWorld
        //    ──── selection


        if (point.offset > start) {
          return point.set('offset', start);
        }
      }

      return point;
    }).set('document', document);
  };

  _proto.setMark = function setMark(path, offset, length, mark, properties) {
    var document = this.document;
    document = document.setMark(path, offset, length, mark, properties);
    return this.set('document', document);
  };

  _proto.setNode = function setNode(path, properties) {
    var document = this.document;
    document = document.setNode(path, properties);
    return this.set('document', document);
  }
  /**
   * 拷贝出一个新value，并设置选区字段
   */
  ;

  _proto.setSelection = function setSelection(selection) {
    return this.set('selection', selection);
  };

  _proto.splitNode = function splitNode(path, position, properties) {
    var prevDoc = this.document;
    var document = prevDoc.splitNode(path, position, properties); // node could not be null if .splitNode works.

    var node = prevDoc.getNodeByPath(path);
    return this.updatePoints(document, function (point) {
      // 如果在当前文本进行分裂，则需要调整选区到分裂后的文本
      //   position
      //       │    cursor
      //       │   │
      //  Hello│Wor│ld
      //       │   │
      //       │
      //
      //        │  split node
      //        ▼
      //
      //  Hello
      //  Wor│ld
      //    cursor
      if (Text$1.isText(node) && point.key === node.key && position <= point.offset) {
        // next is just create by .splitNode
        var next = document.getNextSiblingByPath(path);
        return point.merge({
          key: next.key,
          offset: point.offset - position
        });
      }

      return point;
    }).set('document', document);
  }
  /**
   * 应用operation，并返回一个新value
   */
  ;

  _proto.applyOperation = function applyOperation(operation) {
    var value = null;
    var type = operation.type;

    if (type === OperationType.AddMark) {
      var _ref3 = operation,
          path = _ref3.path,
          offset = _ref3.offset,
          length = _ref3.length,
          mark = _ref3.mark;
      value = this.addMark(path, offset, length, mark);
    } else if (type === OperationType.InsertNode) {
      var _ref4 = operation,
          _path = _ref4.path,
          node = _ref4.node;
      value = this.insertNode(_path, node);
    } else if (type === OperationType.InsertText) {
      var _ref5 = operation,
          _path2 = _ref5.path,
          _offset = _ref5.offset,
          text = _ref5.text,
          _ref5$marks = _ref5.marks,
          marks = _ref5$marks === void 0 ? [] : _ref5$marks;
      value = this.insertText(_path2, _offset, text, marks);
    } else if (type === OperationType.MergeNode) {
      var _ref6 = operation,
          _path3 = _ref6.path;
      value = this.mergeNode(_path3);
    } else if (type === OperationType.MoveNode) {
      var _ref7 = operation,
          _path4 = _ref7.path,
          newPath = _ref7.newPath;
      value = this.moveNode(_path4, newPath);
    } else if (type === OperationType.RemoveMark) {
      var _ref8 = operation,
          _path5 = _ref8.path,
          _offset2 = _ref8.offset,
          _length = _ref8.length,
          _mark = _ref8.mark;
      value = this.removeMark(_path5, _offset2, _length, _mark);
    } else if (type === OperationType.RemoveNode) {
      var _ref9 = operation,
          _path6 = _ref9.path;
      value = this.removeNode(_path6);
    } else if (type === OperationType.RemoveText) {
      var _ref10 = operation,
          _path7 = _ref10.path,
          _offset3 = _ref10.offset,
          _text = _ref10.text;
      value = this.removeText(_path7, _offset3, _text);
    } else if (type === OperationType.SetMark) {
      var _ref11 = operation,
          _path8 = _ref11.path,
          _offset4 = _ref11.offset,
          _length2 = _ref11.length,
          _mark2 = _ref11.mark,
          properties = _ref11.properties;
      value = this.setMark(_path8, _offset4, _length2, _mark2, properties);
    } else if (type === OperationType.SetNode) {
      var _ref12 = operation,
          _path9 = _ref12.path;

      var _properties = mergeUserProperties(this, operation);

      value = this.setNode(_path9, _properties);
    } else if (type === OperationType.SetSelection) {
      var _ref13 = operation,
          selection = _ref13.selection;
      value = this.setSelection(selection);
    } else if (type === OperationType.SplitNode) {
      var _ref14 = operation,
          _path10 = _ref14.path,
          position = _ref14.position,
          _properties2 = _ref14.properties;
      value = this.splitNode(_path10, position, _properties2);
    } else {
      throw new Error("Unknown operation type: \"" + type + "\".");
    }

    if (value.selection.anchor.key === value.document.key) {
      var _selection = getDefaultSelection(value.document);

      return value.setSelection(_selection);
    }

    return value;
  };

  _proto.toJSON = function toJSON(options) {
    var _this2 = this;

    var object = {
      klass: 'value',
      document: this.document.toJSON(options)
    };

    if (options != null && options.preserveDecorations) {
      object.decorations = this.decorations.map(function (decotation) {
        var _decotation$toJSON = decotation.toJSON(options),
            start = _decotation$toJSON.start,
            end = _decotation$toJSON.end,
            mark = _decotation$toJSON.mark;

        return {
          mark: mark,
          start: _extends({}, start, {
            path: _this2.document.getPath(decotation.start.key)
          }),
          end: _extends({}, end, {
            path: _this2.document.getPath(decotation.end.key)
          })
        };
      });
    }

    if (options != null && options.preserveSelections) {
      var selection = this.selection;

      var _selection$toJSON = selection.toJSON(options),
          anchor = _selection$toJSON.anchor,
          focus = _selection$toJSON.focus;

      object.selection = {
        anchor: _extends({}, anchor, {
          // @ts-ignore
          path: this.document.getPath(selection.anchor.key)
        }),
        focus: _extends({}, focus, {
          // @ts-ignore
          path: this.document.getPath(selection.focus.key)
        })
      };
    }

    if (options != null && options.preserveInjections) {
      object.injections = this.injections.map(function (injection) {
        return injection.toJSON();
      });
    }

    return object;
  };

  _createClass(Value, [{
    key: "blocks",
    get: function get() {
      return !this.selection ? [] : this.document.getLeafBlocksAtRange(this.selection);
    }
    /**
     * 获取当前选中的inlines
     */

  }, {
    key: "inlines",
    get: function get() {
      return !this.selection ? [] : this.document.getLeafInlinesAtRange(this.selection);
    }
  }, {
    key: "anchorBlock",
    get: function get() {
      return this.getElement('anchor', 'block');
    }
    /**
     * 获取当前选中的focus位置对应的block
     */

  }, {
    key: "focusBlock",
    get: function get() {
      return this.getElement('focus', 'block');
    }
    /**
     * 获取当前选中的start位置对应的block
     */

  }, {
    key: "startBlock",
    get: function get() {
      return this.getElement('start', 'block');
    }
    /**
     * 获取当前选中的end位置对应的block
     */

  }, {
    key: "endBlock",
    get: function get() {
      return this.getElement('end', 'block');
    }
    /**
     * 获取当前选中的anchor位置对应的inline
     */

  }, {
    key: "anchorInline",
    get: function get() {
      return this.getElement('anchor', 'inline');
    }
    /**
     * 获取当前选中的focus位置对应的inline
     */

  }, {
    key: "focusInline",
    get: function get() {
      return this.getElement('focus', 'inline');
    }
    /**
     * 获取当前选中的start位置对应的inline
     */

  }, {
    key: "startInline",
    get: function get() {
      return this.getElement('start', 'inline');
    }
    /**
     * 获取当前选中的end位置对应的inline
     */

  }, {
    key: "endInline",
    get: function get() {
      return this.getElement('end', 'inline');
    }
    /**
     * 获取当前选中的anchor位置对应的text
     */

  }, {
    key: "anchorText",
    get: function get() {
      return this.getElement('anchor', 'text');
    }
    /**
     * 获取当前选中的focus位置对应的text
     */

  }, {
    key: "focusText",
    get: function get() {
      return this.getElement('focus', 'text');
    }
    /**
     * 获取当前选中的start位置对应的text
     */

  }, {
    key: "startText",
    get: function get() {
      return this.getElement('start', 'text');
    }
    /**
     * 获取当前选中的end位置对应的text
     */

  }, {
    key: "endText",
    get: function get() {
      return this.getElement('end', 'text');
    }
    /**
     * 获取当前选中位置对应的marks。
     * 如果用户设置了正在编辑的样式，返回用户的设置Marks；否则返回当前文字的Marks。
     */

  }, {
    key: "activeMarks",
    get: function get() {
      if (!this.selection) {
        return [];
      }

      return this.selection.marks || this.document.getActiveMarksAtRange(this.selection);
    }
    /**
     * 是否是blur状态
     */

  }, {
    key: "isBlurred",
    get: function get() {
      return !this.isFocused;
    }
    /**
     * 获取当前选区对应的fragment
     */

  }, {
    key: "fragment",
    get: function get() {
      var selection = this.selection,
          document = this.document;
      return selection ? document.getFragmentAtRange(selection) : Document.create();
    }
  }]);

  return Value;
}(ImmutableRecord);

/* eslint-disable no-continue */

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  correctPointInsideInlineOrBlock: correctPointInsideInlineOrBlock,
  pointAtDistance: pointAtDistance,
  pointAtStartOfNode: pointAtStartOfNode,
  pointAtEndOfNode: pointAtEndOfNode,
  getUpsidePoint: getUpsidePoint,
  getUpsideRange: getUpsideRange,
  getDownsidePoint: getDownsidePoint,
  getDownsideRange: getDownsideRange
});

function usePendingTerminal(terminal$, onTerminate) {
  React__default.useEffect(function () {
    var subs = terminal$.subscribe(onTerminate);
    return subs.unsubscribe;
  }, [onTerminate, terminal$]);
}

var _createElement$e = React.createElement;
var placeholderMarkType = 'cangjiePlaceholder';
var defaultPlaceholerSymbol = Symbol();
var placeholderStyle = {
  pointerEvents: 'none',
  userSelect: 'none',
  WebkitUserSelect: 'none',
  position: 'relative'
}; // 用于外部宽度没有撑开的情况

var innerStyleWithWidth = {
  width: 'fit-content',
  whiteSpace: 'nowrap',
  color: 'rgba(23,26,29, 0.4)'
};

var innerStyle = _extends({
  position: 'absolute'
}, innerStyleWithWidth);

var ContentPlaceholderContext = /*#__PURE__*/React.createContext(null);

function useContentPlaceholder() {
  return React.useContext(ContentPlaceholderContext);
}

function blockEvent(event) {
  event.preventDefault();
  event.stopPropagation();
}

var defaultPx = '14.667';
var FONTSIZE_BIGGER = IS_MOBILE ? 1.06 : 1; // 并不需要精确计算placeholder的fontsize，目前只在非排版下使用

function formatFontSize(mark) {
  var _mark$data;

  if (mark != null && (_mark$data = mark.data) != null && _mark$data.value) {
    var _mark$data2 = mark.data,
        value = _mark$data2.value,
        szUnit = _mark$data2.szUnit;
    var unit = szUnit || 'px';

    if (unit === 'pt') {
      // word等转换的pt数据依然需要格式化
      return value * FONTSIZE_BIGGER + "pt";
    } else if (unit === 'px' && mark.data.value === 14) {
      // 特殊处理默认字号：稍微放大至11pt(14.667px)
      return defaultPx + "px";
    }
  }

  return '';
}

function PlaceholderProvider(_ref) {
  var _ref$placeholder = _ref.placeholder,
      placeholder = _ref$placeholder === void 0 ? '' : _ref$placeholder,
      children = _ref.children;
  var placeholderRef = React.useRef(placeholder);
  placeholderRef.current = placeholder;
  return /*#__PURE__*/_createElement$e(ContentPlaceholderContext.Provider, {
    value: placeholderRef
  }, children);
}

function Placeholder(props) {
  var _selection$focus;

  var _React$useReducer = React.useReducer(function (c) {
    return !c;
  }, false),
      forceUpdate = _React$useReducer[1];

  var contentPlaceholderRef = useContentPlaceholder(); // 逻辑收敛到Placeholder组件

  var controller = props.controller,
      node = props.node,
      mark = props.mark,
      children = props.children;
  var _controller$value = controller.value,
      selection = _controller$value.selection,
      isFocused = _controller$value.isFocused,
      composing = _controller$value.composing;
  var focusKey = selection == null ? void 0 : (_selection$focus = selection.focus) == null ? void 0 : _selection$focus.key;
  var _mark$data3 = mark.data,
      config = _mark$data3.config,
      block = _mark$data3.block;
  var disable = !config || config.disable || composing;
  var _ref2 = config,
      text = _ref2.text,
      needWidth = _ref2.needWidth,
      focusMode = _ref2.focusMode,
      when = _ref2.when;
  var isDefaultPlaceholder = defaultPlaceholerSymbol === text;
  var showDefaultPlaceholder = React.useMemo(function () {
    // 这里需要对默认placeholder做一个特殊的处理，默认placeholder是需要关心全文的，而不是上下文就可以了
    if (!isDefaultPlaceholder) return false;
    return when(controller, block);
  }, [controller.value, block, isDefaultPlaceholder, when]);
  var noRender = disable || focusMode && (!isFocused || !focusKey || node.key !== focusKey || controller.value.selection.isExpanded);
  var innerPlaceholderStyle = React.useMemo(function () {
    var _leaves, _leave$marks;

    var style = needWidth ? innerStyleWithWidth : innerStyle;
    var leave = ((_leaves = node.leaves) == null ? void 0 : _leaves.length) === 1 ? node.leaves[0] : null;
    var size = leave == null ? void 0 : (_leave$marks = leave.marks) == null ? void 0 : _leave$marks.find(function (m) {
      return m.type === 'sz';
    });

    if (size) {
      var fontSize = formatFontSize(size);

      if (fontSize) {
        return _extends({}, style, {
          fontSize: fontSize
        });
      }
    }

    return style;
  }, [node, needWidth]);
  var handlePendingSelectionChange = React.useCallback(function () {
    var _controller$value$sel, _controller$value$sel2, _controller$value$sel3, _controller$value$sel4;

    if (!disable && focusKey !== ((_controller$value$sel = controller.value.selection) == null ? void 0 : (_controller$value$sel2 = _controller$value$sel.focus) == null ? void 0 : _controller$value$sel2.key) && (node.key === focusKey || node.key === ((_controller$value$sel3 = controller.value.selection) == null ? void 0 : (_controller$value$sel4 = _controller$value$sel3.focus) == null ? void 0 : _controller$value$sel4.key))) {
      forceUpdate();
    }
  }, [controller, focusKey, node, disable]);
  var handlePendingTerminate = React.useCallback(function () {
    var _controller$value$sel5, _controller$value$sel6;

    if (node.key !== ((_controller$value$sel5 = controller.value.selection) == null ? void 0 : (_controller$value$sel6 = _controller$value$sel5.focus) == null ? void 0 : _controller$value$sel6.key) && !noRender) {
      forceUpdate();
    }
  }, [noRender, node, controller]);
  usePendingTerminal(controller.terminal$, handlePendingTerminate);
  useSelectionData(controller.selectionData$, null, handlePendingSelectionChange, []); // 当监听到热区时，也要重渲 placeholder，避免 placeholder 不消失

  useSelectingHots(controller, handlePendingSelectionChange);
  if (noRender || isDefaultPlaceholder && !showDefaultPlaceholder) return /*#__PURE__*/_createElement$e(React.Fragment, null, children);
  var textContent = typeof text === 'function' ? text(controller, node) : text;
  return /*#__PURE__*/_createElement$e(React.Fragment, null, children, /*#__PURE__*/_createElement$e("span", {
    onTouchStart: blockEvent,
    onMouseDown: blockEvent,
    style: placeholderStyle,
    "data-testid": "cangjie-placeholder",
    "data-cangjie-placeholder": true
  }, /*#__PURE__*/_createElement$e("span", {
    style: innerPlaceholderStyle
  }, isDefaultPlaceholder ? contentPlaceholderRef == null ? void 0 : contentPlaceholderRef.current : textContent)));
}

function createPlaceholderPlugin(config) {
  if (config === void 0) {
    config = {};
  }

  var _config = config,
      isPlaceholderVisible = _config.isPlaceholderVisible; // HACK: use `Symbol` as placeholder before getting placholder from `Cangjie.Content`.

  var contentPlaceholderConfig = isPlaceholderVisible ? {
    when: isPlaceholderVisible,
    text: defaultPlaceholerSymbol
  } : null;
  var placeholdersConfig = null;

  function decorateNode(node, controller, next) {
    if (!node.isEmpty()) {
      return next();
    } // 读取placeholder配置


    if (!placeholdersConfig) {
      placeholdersConfig = [];

      if (contentPlaceholderConfig) {
        // 内置空白行placeholder逻辑
        placeholdersConfig.push(contentPlaceholderConfig);
      } // @ts-ignore


      var placeholder = controller.handlers.placeholder;
      placeholder == null ? void 0 : placeholder.forEach(function (item) {
        if (Array.isArray(item)) {
          var _ref3;

          (_ref3 = placeholdersConfig).push.apply(_ref3, item);
        } else {
          // @ts-ignore
          placeholdersConfig.push(item);
        }
      });
      placeholdersConfig = placeholdersConfig.filter(function (_ref4) {
        var text = _ref4.text,
            disable = _ref4.disable;
        return !!(text || disable);
      });
    }

    var match = placeholdersConfig.find(function (_ref5) {
      var when = _ref5.when;
      return when(controller, node);
    });

    if (!match) {
      return next();
    }

    var first = node.getFirstText();
    var last = node.getLastText();

    if (!first || !last) {
      return next();
    }

    var start = TextPoint.create({
      key: first.key,
      offset: 0
    });
    var end = TextPoint.create({
      key: last.key,
      offset: last.text.length
    });
    return [Decoration.create({
      start: start,
      end: end,
      mark: Mark.create({
        type: placeholderMarkType,
        data: {
          config: match,
          block: node
        }
      })
    })].concat(next());
  }

  function renderEditable(props, _, next) {
    return /*#__PURE__*/_createElement$e(PlaceholderProvider, props, next());
  }

  function renderMark(props, controller, next) {
    var parent = props.parent,
        node = props.node,
        mark = props.mark,
        children = props.children;

    if (mark.type !== placeholderMarkType) {
      return next();
    }

    return /*#__PURE__*/_createElement$e(Placeholder, {
      key: parent.key + "_placeholder",
      controller: controller,
      node: node,
      mark: mark
    }, children());
  }

  return {
    decorateNode: decorateNode,
    renderEditable: renderEditable,
    renderMark: renderMark
  };
}

var hasIntersectionObserver = process.env.NODE_ENV === 'test' || typeof window !== 'undefined' && 'IntersectionObserver' in window;

var IntersectionObserver = /*#__PURE__*/function () {
  IntersectionObserver.getInstance = function getInstance() {
    if (!IntersectionObserver.instance) {
      IntersectionObserver.instance = new IntersectionObserver();
    }

    return IntersectionObserver.instance;
  };

  function IntersectionObserver() {
    var _this = this;

    this.elementToHandler = void 0;
    this.nativeIO = void 0;

    this.handleIntersectionChange = function (entries) {
      entries.forEach(function (entry) {
        var handler = _this.elementToHandler.get(entry.target);

        if (handler) {
          handler(entry);
        }
      });
    };

    this.elementToHandler = new WeakMap();
    this.nativeIO = hasIntersectionObserver ? new window.IntersectionObserver(this.handleIntersectionChange) : null;
  }

  var _proto = IntersectionObserver.prototype;

  _proto.observe = function observe(element, handler) {
    var _this$nativeIO;

    this.elementToHandler.set(element, handler);
    (_this$nativeIO = this.nativeIO) == null ? void 0 : _this$nativeIO.observe(element);
  };

  _proto.unobserve = function unobserve(element) {
    var _this$nativeIO2;

    this.elementToHandler["delete"](element);
    (_this$nativeIO2 = this.nativeIO) == null ? void 0 : _this$nativeIO2.unobserve(element);
  };

  return IntersectionObserver;
}();

IntersectionObserver.instance = null;
function useElementVisibility(elementRef, defaultVisible) {
  if (defaultVisible === void 0) {
    defaultVisible = false;
  }

  var _React$useState = React.useState(defaultVisible),
      visible = _React$useState[0],
      setVisible = _React$useState[1];

  var unobserve = function unobserve() {
    if (elementRef.current) {
      IntersectionObserver.getInstance().unobserve(elementRef.current);
    }
  };

  React.useLayoutEffect(function () {
    if (elementRef.current) {
      IntersectionObserver.getInstance().observe(elementRef.current, function (entry) {
        return setVisible(entry.isIntersecting);
      });
      return unobserve;
    }

    return undefined;
  }, []);
  return [visible, unobserve];
}

var _createElement$d = React.createElement;
var LazyRenderStrategyType;

(function (LazyRenderStrategyType) {
  LazyRenderStrategyType["LazyLoad"] = "lazyload";
  LazyRenderStrategyType["Pruning"] = "pruning";
})(LazyRenderStrategyType || (LazyRenderStrategyType = {}));

function LazyLoadWrapper(_ref) {
  var node = _ref.node,
      _ref$placeholder = _ref.placeholder,
      placeholder = _ref$placeholder === void 0 ? null : _ref$placeholder,
      size = _ref.size,
      children = _ref.children;
  var placeholderRef = React.useRef(null);

  var _useElementVisibility = useElementVisibility(placeholderRef),
      visible = _useElementVisibility[0],
      unobserve = _useElementVisibility[1];

  if (visible) {
    unobserve();
  }

  if (!visible) {
    return /*#__PURE__*/_createElement$d("div", {
      ref: placeholderRef,
      "data-cangjie-key": node.key,
      "data-cangjie-lazy-load": true,
      style: size
    }, placeholder);
  }

  return children;
}

function PruningManager(_ref2) {
  var controller = _ref2.controller,
      children = _ref2.children;
  var selectionUpdator = React.useCallback(function (_ref3) {
    var range = _ref3.range;

    if (range.isExpanded) {
      return;
    }

    var point = range.focus;
    var key = point.isTextPoint() ? point.key + ":0" : point.key;
    var dom = findDOMNodeSafely(key);

    if (dom) {
      showPrunedElements(dom);
    }
  }, [controller]);
  var onHots = React.useCallback(function () {
    selectionUpdator({
      range: controller.value.selection
    });
  }, [controller, selectionUpdator]);
  useSelectionData(controller.selectionData$, null, selectionUpdator, []);
  useSelectingHots(controller, onHots);
  return children;
}

function PruningWrapper(props) {
  var zoom = useZoom();
  var controller = props.controller,
      node = props.node,
      forceVisible = props.forceVisible,
      children = props.children;

  var _React$useState = React.useState(props.isSelected),
      isSelected = _React$useState[0],
      setIsSelected = _React$useState[1];

  var placeholderRef = React.useRef(null);

  var _React$useState2 = React.useState(),
      placeholderStyle = _React$useState2[0],
      setPlaceholderStyle = _React$useState2[1];

  var _useElementVisibility2 = useElementVisibility(placeholderRef, true),
      isElementVisible = _useElementVisibility2[0];

  var visible = isElementVisible || isSelected || forceVisible;
  var prevVisible = React.useRef(visible);
  var onHots = React.useCallback(function () {
    var selection = controller.value.selection;
    setIsSelected(controller.view.isNodeInRange(node.key, selection));
  }, [controller, node.key]);
  useSelectionData(controller.selectionData$, null, onHots, []);
  useSelectingHots(controller, onHots);
  React.useLayoutEffect(function () {
    if (prevVisible.current === visible) {
      return;
    }

    if (prevVisible.current && !visible) {
      var placeholder = placeholderRef.current;

      if (!placeholder) {
        return;
      }

      var placeholderClientRect = placeholder.getBoundingClientRect(); // HACK: `IntersectionObserver` cannot detect zero height element in Safari iframe.

      var height = placeholderClientRect.height || 1; // FIX: thrashing
      //   1. When placeholder is visible
      //   2. Remove `display: none` of placeholder
      //   3. Descendant's margin will push placeholder out of view
      // So placeholder will thrash if `margin-top` & `margin-bottom` is incorrect.

      var marginTop = placeholder.previousElementSibling ? placeholderClientRect.top - placeholder.previousElementSibling.getBoundingClientRect().bottom : 0;
      var marginBottom = placeholder.nextElementSibling ? placeholder.nextElementSibling.getBoundingClientRect().top - placeholderClientRect.bottom : 0;
      setPlaceholderStyle({
        height: height / zoom,
        marginTop: marginTop / zoom,
        marginBottom: marginBottom / zoom
      });
    } else {
      // !prevVisible.current && visible
      setPlaceholderStyle(undefined);
    }

    prevVisible.current = visible;
  }, [visible, zoom]);
  return /*#__PURE__*/_createElement$d("div", {
    ref: placeholderRef,
    "data-cangjie-perf-pruning": !visible,
    style: placeholderStyle
  }, /*#__PURE__*/_createElement$d("div", {
    style: placeholderStyle && {
      display: 'none'
    }
  }, children));
}

var DATA_CANGJIE_PERF_PRUNING = 'data-cangjie-perf-pruning';

function showPrunedElements(target) {
  var ancestorsWithPruning = [];
  var ancestor = target;

  while (ancestor) {
    if (ancestor.getAttribute(DATA_CANGJIE_PERF_PRUNING) === 'true') {
      ancestorsWithPruning.push(ancestor);
    }

    ancestor = ancestor.parentElement;
  }

  ancestorsWithPruning.forEach(function (node) {
    if (node instanceof HTMLElement) {
      node.style.height = '';
      node.style.marginTop = '';
      node.style.marginBottom = '';
      node.setAttribute(DATA_CANGJIE_PERF_PRUNING, 'false');
    }

    var firstElementChild = node.firstElementChild;

    if (firstElementChild instanceof HTMLElement) {
      firstElementChild.style.display = '';
    }
  });
}

function createPerfLazyRenderPlugin(config) {
  if (config === void 0) {
    config = {};
  }

  if (!hasIntersectionObserver) {
    return {};
  }

  function renderEditable(_, controller, next) {
    return /*#__PURE__*/_createElement$d(PruningManager, {
      controller: controller
    }, next());
  }

  function renderNode(_ref4, controller, next) {
    var node = _ref4.node,
        isSelected = _ref4.isSelected;
    var strategy = controller.query('lazyRenderStrategy', node) || {};
    var _strategy$type = strategy.type,
        type = _strategy$type === void 0 ? LazyRenderStrategyType.LazyLoad : _strategy$type;

    if (controller.enableVirtualize) {
      return next();
    }

    if (type === LazyRenderStrategyType.LazyLoad && (strategy.placeholder || strategy.size)) {
      var size = !strategy.size ? undefined : {
        width: strategy.size.width,
        // HACK: `IntersectionObserver` cannot detect zero height element in Safari iframe.
        height: strategy.size.height || 1
      };
      return /*#__PURE__*/_createElement$d(LazyLoadWrapper, {
        node: node,
        placeholder: strategy.placeholder,
        size: size
      }, next());
    }

    if (type === LazyRenderStrategyType.Pruning) {
      return /*#__PURE__*/_createElement$d(PruningWrapper, {
        controller: controller,
        node: node,
        isSelected: isSelected,
        forceVisible: strategy.forceVisible || false
      }, next());
    }

    return next();
  }

  if (config.lazyRenderStrategy) {
    return {
      queries: {
        lazyRenderStrategy: config.lazyRenderStrategy
      },
      renderEditable: renderEditable,
      renderNode: renderNode
    };
  }

  return {
    renderEditable: renderEditable,
    renderNode: renderNode
  };
}

createPerfLazyRenderPlugin.factory = function (defaultConfig) {
  if (defaultConfig === void 0) {
    defaultConfig = {};
  }

  return function (config) {
    if (config === void 0) {
      config = {};
    }

    return createPerfLazyRenderPlugin(_extends({}, defaultConfig, config));
  };
};

createPerfLazyRenderPlugin.LazyRenderStrategyType = LazyRenderStrategyType;
createPerfLazyRenderPlugin.showPrunedElements = showPrunedElements;
createPerfLazyRenderPlugin.useElementVisibility = useElementVisibility;

var _createElement$c = React.createElement;
var FirstRenderContext = /*#__PURE__*/React.createContext(null);

function FirstRenderManager(_ref) {
  var controller = _ref.controller,
      isFirstRenderSlice = _ref.isFirstRenderSlice,
      firstFrameSize = _ref.firstFrameSize,
      children = _ref.children;
  var animationFrameSubject = React.useMemo(function () {
    return new Subject();
  }, []);
  var delayRenderSlices = React.useMemo(function () {
    var delays = new Set();
    var remained = firstFrameSize;
    var document = controller.view;
    document.forEachDescendant(function (node) {
      if (remained <= 0 && isFirstRenderSlice(node)) {
        delays.add(node.key);
      }

      remained -= 1;
    });
    return delays;
  }, []);
  var context = React.useMemo(function () {
    return {
      animationFrameSubject: animationFrameSubject,
      delayRenderSlices: delayRenderSlices
    };
  }, [animationFrameSubject, delayRenderSlices]);
  React.useEffect(function () {
    var raf = null;

    function loop() {
      if (!delayRenderSlices.size) {
        return;
      }

      raf = window.requestAnimationFrame(function () {
        context.animationFrameSubject.next(undefined);
        loop();
      });
    }

    loop();
    return function () {
      if (raf) {
        window.cancelAnimationFrame(raf);
      }
    };
  }, []);
  return /*#__PURE__*/_createElement$c(FirstRenderContext.Provider, {
    value: context
  }, children);
}

function useShouldMount(node) {
  var context = React.useContext(FirstRenderContext);

  if (!context) {
    throw new Error("The `useShouldMount` hook must be used inside the <FirstRenderManager> component's context.");
  }

  var _React$useState = React.useState(!context.delayRenderSlices.has(node.key)),
      shouldMount = _React$useState[0],
      setShouldMount = _React$useState[1];

  React.useEffect(function () {
    if (shouldMount) {
      return undefined;
    }

    var subscription = context.animationFrameSubject.subscribe(function () {
      subscription.unsubscribe();
      context.delayRenderSlices["delete"](node.key);
      setShouldMount(true);
    });
    return subscription.unsubscribe;
  }, []);
  return shouldMount;
}

function FirstRenderSlice(_ref2) {
  var node = _ref2.node,
      children = _ref2.children;
  var shouldMount = useShouldMount(node);
  return shouldMount ? children : null;
}

function createPerfFirstRenderPlugin(config) {
  var isFirstRenderSlice = config.isFirstRenderSlice,
      _config$firstFrameSiz = config.firstFrameSize,
      firstFrameSize = _config$firstFrameSiz === void 0 ? 1000 : _config$firstFrameSiz;

  function renderEditable(_, controller, next) {
    return /*#__PURE__*/_createElement$c(FirstRenderManager, {
      controller: controller,
      isFirstRenderSlice: isFirstRenderSlice,
      firstFrameSize: firstFrameSize
    }, next());
  }

  function renderNode(props, _, next) {
    var node = props.node;

    if (!isFirstRenderSlice(node)) {
      return next();
    }

    return /*#__PURE__*/_createElement$c(FirstRenderSlice, {
      node: node
    }, next());
  }

  return {
    renderEditable: renderEditable,
    renderNode: renderNode
  };
}

createPerfFirstRenderPlugin.factory = function (defaultConfig) {
  return function (config) {
    return createPerfFirstRenderPlugin(_extends({}, defaultConfig, config));
  };
};

var Context = /*#__PURE__*/React__default.createContext(null);
/**
 * @deprecated
 */

function useSelectionContext() {
  var context = React__default.useContext(Context);

  if (!context) {
    throw new Error('SelectionContext not found.');
  }

  return context;
}

/**
 * @packageDocumentation
 * @module Hooks
 */

function updatePosition(caret, point, selectionContext, zoom, isHanging) {
  var _caret$parentElement;

  if (zoom === void 0) {
    zoom = 1;
  }

  if (isHanging === void 0) {
    isHanging = false;
  }

  var root = caret.closest("[" + Selector.content + "]") || undefined;
  var nodeRect = selectionContext.relativeRect;
  var relativeRect = nodeRect || ((_caret$parentElement = caret.parentElement) == null ? void 0 : _caret$parentElement.getBoundingClientRect());
  var position = null;

  if (point.isEdgePoint()) {
    position = findEdgePointPosition(point, root);
  } else {
    var preferredEdge = isHanging ? 'start' : 'end';
    position = findTextPointPosition(point, preferredEdge, root);
  }

  if (!position || !relativeRect) {
    return;
  }

  var _position = position,
      clientTop = _position.clientTop,
      clientLeft = _position.clientLeft,
      height = _position.height; // 有相对定位的容器就以提供的相对定位为准，否则以光标的父节点为准

  var relativeLeft = nodeRect ? nodeRect.left - nodeRect.scrollLeft : relativeRect.left;
  var left = clientLeft - relativeLeft;
  var top = clientTop - relativeRect.top;
  caret.style.top = top / zoom + "px";
  caret.style.left = point.isTextPoint() ? left / zoom - CURSOR_WIDTH / 2 + "px" : left / zoom + CURSOR_WIDTH / 2 + "px";
  caret.style.height = height / zoom + "px";
}
/**
 * @deprecated
 * 已废弃
 */


function useOffsetPosition(caretRef, pointStr, where, zoom, isHanging, deps) // 其他会引起光标位置变化的依赖
{
  if (zoom === void 0) {
    zoom = 1;
  }

  if (isHanging === void 0) {
    isHanging = false;
  }

  if (deps === void 0) {
    deps = [];
  }

  var selectionContext = useSelectionContext();
  React.useLayoutEffect(function () {
    var caret = caretRef.current;

    if (!caret || !pointStr) {
      return;
    }

    var offsetSeperatorIndex = pointStr == null ? void 0 : pointStr.lastIndexOf('-');
    var key = pointStr == null ? void 0 : pointStr.substring(0, offsetSeperatorIndex);

    if (!key) {
      return;
    }

    var point;

    if (typeof where === 'number') {
      point = TextPoint.create({
        key: key,
        offset: where
      });
    } else {
      point = EdgePoint.create({
        key: key,
        edge: where
      });
    }

    updatePosition(caret, point, selectionContext, zoom, isHanging);
  }, [pointStr, where, zoom, isHanging, caretRef, selectionContext].concat(deps));
}

var THROTTLE_TIME_RESIZE$1 = 300;
/**
 * 在 ref 上层对应的 leaf block 尺寸变动时，调用 updator。内置了 throttle。
 */

function useLeafBlockResizer(ref, updator, deps) {
  React.useEffect(function () {
    var _ref$current;

    var node = (_ref$current = ref.current) == null ? void 0 : _ref$current.closest("[" + Selector.leafBlock + "]");

    if (!node) {
      return undefined;
    }

    var callback = throttle(function () {
      updator();
    }, THROTTLE_TIME_RESIZE$1); // @ts-ignore

    if (typeof ResizeObserver !== 'undefined') {
      // @ts-ignore
      var observer = new ResizeObserver(callback);
      observer.observe(node);
      return function () {
        callback.cancel();
        observer.unobserve(node);
      };
    }

    window.addEventListener('resize', callback);
    return function () {
      callback.cancel();
      window.removeEventListener('resize', callback);
    };
  }, deps || []);
}

/**
 * 获取用户数据
 * @param node 
 * @param key 
 * @returns 
 */

function useUserData(node, key) {
  var controller = useControllerStatic();
  var uid = controller.uid;
  var initValue = controller.userData.get(node, key);
  var uuid = node.data.uuid;

  var _useState = useState(initValue),
      data = _useState[0],
      setData = _useState[1];

  useEffect(function () {
    if (uid && uuid) {
      // 订阅用户数据 update$ 更新（uid 和 uuid 存在的情况，存储在 document.data）
      var sub = controller.userData.update$.subscribe(function (event) {
        var euuid = event.uuid;

        if (euuid === uuid || euuid === '*') {
          // 同一个节点，用户数据发生改变
          var cNode = controller.value.document.getNode(node.key.split('-')[0]);

          if (cNode && Element$1.isElement(cNode)) {
            var nextData = controller.userData.get(cNode, key);
            setData(nextData);
          }
        }
      });
      return function () {
        return sub.unsubscribe();
      };
    } else {
      var _node$data;

      // 观察节点 node 变化（uid 或 uuid 不存在的情况，存储在 node.data）
      var nextData = (_node$data = node.data) == null ? void 0 : _node$data[key];

      if (nextData !== data) {
        setData(nextData);
      }

      return noop;
    }
  }, [controller, node, uuid, uid, key, data]);
  return data;
}

/**
 * 获得所在分组的数据 
 * @param node 
 * @param selector 
 * @param defaultValue 
 * @returns 
 * 
 * @example
 * ```tsx
 * const Element = props => {
 *   const hidden = useGroupData(groups => groups.some(group => group.hidden));
 * 
 *   // ...
 * }
 * ```
 */
function useGroupData(node, selector, defaultValue) {
  var finalNode = node;
  var controller = useControllerStatic(); // 兼容老 Group 的代码

  var legacyGroupIndex = node.key.indexOf('-group');

  if (legacyGroupIndex > -1) {
    var nodeKey = node.key.split('-group')[0];
    var originalNode = controller.view.getNode(nodeKey);

    if (originalNode) {
      finalNode = originalNode;
    }
  }

  var groups = controller.groupManager.getNodeGroups(finalNode);
  var selectorRef = useRef(selector);
  selectorRef.current = selector; // default state 就要取实际值，否则数据有延迟，有延迟就对虚拟化不友好

  var defaultData = selectorRef.current(groups) || defaultValue;

  var _useState = useState(defaultData),
      data = _useState[0],
      setData = _useState[1]; // 响应上游的分组信息变更


  useEffect(function () {
    var sub = null;

    if (finalNode && Element$1.isElement(finalNode)) {
      sub = controller.groupManager.groups$.subscribe(function (groupsMap) {
        var groups = controller.groupManager.getNodeGroups(finalNode);
        setData(selectorRef.current(groups));
      });
    }

    return function () {
      if (sub) {
        sub.unsubscribe();
      }
    };
  }, [controller, finalNode]);
  return data;
}

/**
 *
 * If the HTML node is hide behind a horizontal scroll container, make it
 * visible
 */
function makeElementVisible(
/**
 * dom node
 */
domNode,
/**
 * which edge should be visible.
 * options: start edge | end edge | all edges
 */
edge,
/**
 * extra space added to the domNode's edge
 */
extra) {
  var _domNode$getBoundingC = domNode.getBoundingClientRect(),
      left = _domNode$getBoundingC.left,
      right = _domNode$getBoundingC.right;

  var leftEdge = edge === 'end' ? right : left;
  var rightEdge = edge === 'start' ? left : right;
  leftEdge -= extra;
  rightEdge += extra;
  var node = domNode;

  while (node && !node.getAttribute(Selector.content)) {
    if (node.scrollWidth > node.offsetWidth) {
      var rect = node.getBoundingClientRect();
      var offsetLeft = leftEdge - rect.left;
      var offsetRight = rightEdge - rect.right;

      if (offsetLeft < 0 || offsetRight > 0) {
        var horizonOffset = offsetLeft < 0 ? offsetLeft : offsetRight;
        node.scrollLeft += horizonOffset;
        break;
      }
    }

    node = node.parentElement;
  }
}

/**
 * @packageDocumentation
 * @ignore
 */
// PC: no prefix/surfix by default
var EMPTY_PREFIX = '';
var EMPTY_SURFIX = '';

if (IS_IOS) {
  // iOS / Mac - Safari: will ignore the only space in textarea.
  EMPTY_PREFIX = '\n.';
  EMPTY_SURFIX = ' \n';
} else if (IS_MOBILE) {
  // Android: will toggle between uppercase and lowercase
  // while deleting with dot as the only character in textarea.
  EMPTY_PREFIX = ' '; // Android: Arrow buttons will not trigger any keyboard event when caret is at the edge of textarea value
  // eg1. textarea value is: ' <cursor />', keydown event will not triggered by ArrowRight/ArrowDown
  // eg2. textarea value is: '<cursor />', keydown event will not triggered by ArrowRight/ArrowDown/ArrowUp/ArrowLeft

  EMPTY_SURFIX = ' ';
}

var IS_TOUCH_MOBILE = IS_MOBILE || IS_TOUCH_DEVICE;
var getEmptyValue = function getEmptyValue(t) {
  return "" + EMPTY_PREFIX + t + EMPTY_SURFIX;
};
var EMPTY_TEXT_AREA_VALUE = getEmptyValue('');
var CHARACTERS_LENGTH_AFTER_USER_INPUT = EMPTY_SURFIX.length;

function resetTextAreaValue(textAreaRef, textAreaCacheRef) {
  textAreaCacheRef.current = EMPTY_TEXT_AREA_VALUE;
  var defaultCaretPosition = EMPTY_TEXT_AREA_VALUE.length - CHARACTERS_LENGTH_AFTER_USER_INPUT; // BACKGROUND:
  //   Android 中，点击非工具栏区域 blur 后，再 focus 回编辑器
  //   会出现 textarea.value === ' ' && textarea.selectionStart === 0 的情况
  //   导致无法删除文字，输入文字后会吞掉光标前一个字

  if (textAreaRef.current && (textAreaRef.current.value !== EMPTY_TEXT_AREA_VALUE || textAreaRef.current.selectionStart !== defaultCaretPosition || textAreaRef.current.selectionEnd !== defaultCaretPosition)) {
    textAreaRef.current.value = EMPTY_TEXT_AREA_VALUE;
    textAreaRef.current.selectionStart = defaultCaretPosition;
    textAreaRef.current.selectionEnd = defaultCaretPosition;
  }
}

function diffTextAreaValue(prevTextAreaValue, textAreaValue) {
  var prevValueCaretPosition = prevTextAreaValue.length - CHARACTERS_LENGTH_AFTER_USER_INPUT;
  var currentValueCaretPosition = textAreaValue.length - CHARACTERS_LENGTH_AFTER_USER_INPUT;
  var minValueCaretPosition = Math.min(prevValueCaretPosition, currentValueCaretPosition);
  var leftDiffOffset = 0;

  while (leftDiffOffset < minValueCaretPosition) {
    if (prevTextAreaValue[leftDiffOffset] !== textAreaValue[leftDiffOffset]) {
      break;
    }

    leftDiffOffset += 1;
  }

  return {
    range: [leftDiffOffset, prevValueCaretPosition],
    text: textAreaValue.slice(leftDiffOffset, currentValueCaretPosition)
  };
}

function insertText(controller, rawData) {
  // Safari 空格会发出 CharCode 为 160 的空格，这里抹平浏览器差异
  // convert <CharCode 160: &nbsp;> to <CharCode 32: space>
  var data = rawData.replace(/\xA0/g, ' ');
  var cangjieInput = CangjieInputEvent({
    type: 'insertText',
    data: data
  });
  controller.run('onCangjieInput', cangjieInput);
}

function removeText(controller, data) {
  controller.run('onCangjieInput', CangjieInputEvent({
    type: 'deleteContentBackward',
    data: data
  }));
}

function updateComposing(controller, composing) {
  controller.run('onCangjieComposingChange', composing);
}

function useInputDetector(controller, textAreaRef) {
  var _controller$value = controller.value,
      selection = _controller$value.selection,
      isBlurred = _controller$value.isBlurred;
  var isComposing = React.useRef(false);
  var prevSelectionAfterInput = React.useRef(null);
  var resetTimer = React.useRef(null);
  var composingData = React.useRef('');
  var prevTextAreaValue = React.useRef(EMPTY_TEXT_AREA_VALUE);
  var reset = React.useCallback(function () {
    resetTextAreaValue(textAreaRef, prevTextAreaValue);
  }, [textAreaRef]);
  React.useEffect(function () {
    var _prevSelectionAfterIn, _prevSelectionAfterIn2;

    // 仅当选区的位置变化才需要 reset textarea 结束 composing 状态，不应受其它因素影响
    // eg. 分页模式下用输入法输入，首字母输入后仅 selection.data.isHanging 会变为 true（https://code.aone.alibaba-inc.com/alidocs/we-word/codereview/7664706）
    //     这种情况下只影响选区渲染的位置，不应该打断输入
    if (((_prevSelectionAfterIn = prevSelectionAfterInput.current) == null ? void 0 : _prevSelectionAfterIn.plainViewKey) === selection.plainViewKey) {
      return;
    } // 分页模式下，会将 dataSelection 转为 viewSelection，并将原始 selection 放到 data 中
    // 因此可以通过 dataSelection 来判断是否为同一个位置，避免因排版将 composing 部分放到下一行导致选区变化，从而中断输入法
    // eg.
    //    Line 1: xxxxxxxxxxx<cursor/>[n]    <-- before：输入法输入时，光标和 composing 部分在行尾
    //    Line 2: <cursor/>[ni]xxxxxxxxxxx   <-- after：输入法输入时，光标和 composing 部分被放到下一行首
    //    此时，不应执行 reset


    var dataSelection = selection.data.dataSelection;
    var prevDataSelection = (_prevSelectionAfterIn2 = prevSelectionAfterInput.current) == null ? void 0 : _prevSelectionAfterIn2.data.dataSelection;

    if (isComposing && dataSelection && prevDataSelection && prevDataSelection.plainViewKey === dataSelection.plainViewKey) {
      return;
    } // BACKGROUND:
    // iOS 下，reset() 中设置 selectionStart/selectionEnd 的行为会造成 textarea 自动 focus
    // 导致编辑器的 autoFocus 配置失效
    // 因此需要人为控制 blur 状态下不执行 reset


    if (isBlurred) {
      return;
    }

    reset();
  }, [reset, selection, isBlurred]);
  React.useEffect(function () {
    return function () {
      resetTimer.current && clearTimeout(resetTimer.current);
    };
  }, []);
  return React.useMemo(function () {
    return {
      reset: reset,
      onChange: function onChange(event) {
        var value = event.target.value; // Safari 空格会发出 CharCode 为 160 的空格，这里抹平浏览器差异
        // 避免 diffTextAreaValue 时 offset 算错

        value = value.replace(/\xA0/g, ' ');

        var _diffTextAreaValue = diffTextAreaValue(prevTextAreaValue.current, value),
            range = _diffTextAreaValue.range,
            text = _diffTextAreaValue.text;

        var rangeStartIndex = range[0],
            rangeEndIndex = range[1];
        var mismatchLength = rangeEndIndex - rangeStartIndex;
        var composing = composingData.current; // console.info(`onchange, value=[${value}], range=${range}, text=[${text}], composing=[${composing}]`);

        if (mismatchLength > 0 && composing.length > 0) {
          var delLength = Math.min(mismatchLength, composing.length);
          composingData.current = composing.slice(0, composing.length - delLength);
          mismatchLength -= delLength;
          updateComposing(controller, composingData.current);
        }

        if (mismatchLength > 0) {
          var data = prevTextAreaValue.current.slice(rangeStartIndex, rangeStartIndex + mismatchLength);
          removeText(controller, data);
        }

        var newText = text;

        if (isComposing.current && newText) {
          composingData.current += newText;
          updateComposing(controller, composingData.current);
          newText = '';
        }

        if (newText) {
          insertText(controller, newText);
        }

        if (value.length < EMPTY_TEXT_AREA_VALUE.length) {
          mismatchLength <= 0 && removeText(controller, ' ');
          composingData.current = '';
          resetTimer.current = setTimeout(reset, 0);
        }

        prevTextAreaValue.current = value;
        prevSelectionAfterInput.current = controller.value.selection;
      },
      onCompositionStart: function onCompositionStart() {
        isComposing.current = true;
        prevSelectionAfterInput.current = controller.value.selection;
      },
      onCompositionEnd: function onCompositionEnd() {
        isComposing.current = false;

        if (composingData.current) {
          insertText(controller, composingData.current);
          updateComposing(controller, '');
          composingData.current = '';
        }

        prevSelectionAfterInput.current = controller.value.selection;
      },
      // 返回值意义: shouldContinue other keydown handlers
      onKeyDown: function onKeyDown(event) {
        if (IS_TOUCH_MOBILE && (hotkeys.isCopy(event) || hotkeys.isCut(event))) {
          // Background: iOS + Safari + 外接键盘的情况下，用中文输入法输入 cmd + C 等快捷键，会出现
          //             keydown 后触发 compositionStart -> onChange 的情况
          // Hack: https://stackoverflow.com/questions/63204395/how-can-i-reliably-cancel-a-compositionstart-event
          // Ref: https://alidocs.dingtalk.com/i/nodes/2m0X9MnDA3QJwww90al4JqklwBK7RezY
          if (IS_IPAD) {
            controller.run('onCangjieBlur');
            setTimeout(function () {
              return controller.run('onCangjieFocus');
            }, 100);
          }

          return true;
        }

        if (IS_SAFARI) {
          // BACKGROUND: Safari 下输入法输入 abc，然后逐个删除，到最后会把 abc 之前的文字删掉
          // 正常情况下，事件触发顺序为 onKeydown -> onChange -> onCompositionEnd；
          // 而 Safari 下是 onChange -> onCompositionEnd -> onKeydown，标志位就失去了参考价值
          // http://gwiki.cn/2019/02/js%E7%9A%84%E7%BC%96%E8%BE%91%E4%BA%8B%E4%BB%B6
          // https://developer.mozilla.org/en-US/docs/Web/Events/keydown
          // 利用 event 事件信息，使输入法处理过程中，忽略 onKeydown
          // @ts-ignore
          if (event.isComposing || event.keyCode === 229) {
            return false;
          }
        }

        return !isComposing.current || !hotkeys.isCompose(event) && !hotkeys.isUndo(event) && !hotkeys.isRedo(event);
      }
    };
  }, [controller, textAreaRef]);
}

/* eslint-disable react/no-find-dom-node */
var MULTIPLE_CLICK_DELAY = 500;
var TAP_HOLD_DELAY = 600; // 方向键需要快速响应，目前暂未发现明显问题

var CARET_MOVE_GAP_TIME = 0;
var MULTIPLE_CLICK_RANGE = 10;

function getWordSelection(controller, target, x, y) {
  var r = caretRangeFromTargetAndCoord(target, x, y, controller);

  if (!r) {
    return null;
  }

  var document = controller.value.document;
  return Selection.selectWordAtPoint(document, r.anchor);
} // get a new selection at Line Start or Line End of the current selection.


function getSelectionAtLine(where, controller, selection) {
  var value = controller.value;
  var document = value.document;

  if (!selection) {
    return null;
  }

  var isStart = where === 'start';
  var focus = selection.focus,
      isHanging = selection.isHanging;

  if (focus.isEdgePoint()) {
    var edge = isStart ? EdgePoint.BEFORE : EdgePoint.AFTER;
    var anchor = EdgePoint.create({
      key: focus.key,
      edge: edge
    });
    return Selection.create({
      anchor: anchor,
      focus: anchor
    });
  }

  var range = null; // selection's range

  var blockDomNode = null; // selection's closest block node

  try {
    var block = document.getClosestBlock(focus.key);
    range = findDOMRange(selection, controller);

    if (block) {
      blockDomNode = findDOMNode(block.key);
    }
  } catch (_) {
    return null;
  }

  if (!range || !blockDomNode) {
    return null;
  } // selection's rect


  var rects = range.getClientRects();

  if (!rects.length) {
    return null;
  }

  var rect = rects[isHanging ? rects.length - 1 : 0];
  var edgeRects = isPointAtEdge(focus) ? findRectsInEdgePoint(focus) : [];

  if (edgeRects && edgeRects.length) {
    rect = edgeRects[isHanging ? edgeRects.length - 1 : 0];
  } // selection's closest block's rect


  makeElementVisible(blockDomNode, where, CURSOR_WIDTH);
  var blockRect = blockDomNode.getBoundingClientRect(); // target selection's position

  var position = {
    x: where === 'start' ? blockRect.left + 1 : blockRect.right - 1,
    y: rect.top + rect.height / 2
  };
  var newRange = caretRangeFromTargetAndCoord(blockDomNode, position.x, position.y, controller);

  if (!newRange) {
    return null;
  }

  var point = newRange.anchor; // if the target point is inside a void element, take the next point

  var parent = document.getParent(point.key);

  if (parent && controller.query('isVoid', parent)) {
    point = controller.query(pointAtDistance, point, isStart ? -1 : 1);
  }

  var newSelection = Selection.create({
    anchor: point,
    focus: point
  });
  return newSelection;
}

function shouldSelectOnRightClick(targetPoint, controller) {
  var _controller$value = controller.value,
      selection = _controller$value.selection,
      document = _controller$value.document;

  if (!selection || selection.isCollapsed) {
    return true;
  }

  var _selection$sort = selection.sort(document),
      start = _selection$sort.start,
      end = _selection$sort.end;

  var rangeStart = Selection.create({
    anchor: targetPoint,
    focus: start
  });
  var rangeEnd = Selection.create({
    anchor: end,
    focus: targetPoint
  });
  var isBeforeStart = rangeStart.isExpanded && rangeStart.isForward(document);
  var isAfterEnd = rangeEnd.isExpanded && rangeEnd.isForward(document);
  return isBeforeStart || isAfterEnd;
}

function useSelectionCalculator(controller, textAreaRef, scrollableContainerRef) {
  var isJustTapHold = React.useRef(false);
  var tapHoldTimer = React.useRef(null);
  var outsideScoller = React.useRef(null);
  var lastSingleClick = React.useRef({
    time: 0,
    x: 0,
    y: 0
  });
  var lastDoubleClick = React.useRef({
    time: 0,
    x: 0,
    y: 0
  });
  var lastCaretMoveTime = React.useRef(0);
  var prevSelectionRef = React.useRef(null);
  var onCangjieSelect = React.useCallback(function (selection, trigger) {
    var _controller$value2 = controller.value,
        composing = _controller$value2.composing,
        isFocused = _controller$value2.isFocused;

    if (composing && selection.isExpanded) {
      return;
    }

    if (!isFocused) {
      controller.run('onCangjieFocus');
    }

    var newSelection = selection.marks === null ? selection : selection.set('marks', null);
    var subtypeTriggerMap = {
      selectStart: 'focusText',
      selecting: 'selectText',
      selectAll: 'selectAll'
    };

    if (!trigger || !subtypeTriggerMap[trigger] || equal(prevSelectionRef.current, newSelection)) {
      // 需要 delay 丢弃的 perf 事件
      controller.perfDrop(PerfType.selection);
    }

    prevSelectionRef.current = newSelection;
    return controller.run('onCangjieSelect', CangjieSelectEvent({
      selection: newSelection,
      trigger: trigger || 'userSelect'
    }));
  }, [controller]);

  var moveUpward = function moveUpward() {
    var now = Date.now();
    var isGapTimeTooShort = now - lastCaretMoveTime.current < CARET_MOVE_GAP_TIME;

    if (isGapTimeTooShort) {
      return;
    }

    lastCaretMoveTime.current = now;
    var newRange = controller.query(getUpsideRange);

    if (!newRange) {
      return;
    }

    onCangjieSelect(newRange, SelectionTrigger.MoveUpward);
  };

  var moveDownward = function moveDownward() {
    var now = Date.now();
    var isGapTimeTooShort = now - lastCaretMoveTime.current < CARET_MOVE_GAP_TIME;

    if (isGapTimeTooShort) {
      return;
    }

    lastCaretMoveTime.current = now;
    var newRange = controller.query(getDownsideRange);

    if (!newRange) {
      return;
    }

    onCangjieSelect(newRange, SelectionTrigger.MoveDownward);
  };

  var moveBackward = function moveBackward() {
    var _controller$value3 = controller.value,
        document = _controller$value3.document,
        selection = _controller$value3.selection;

    if (selection.isExpanded) {
      var _isAtEdge = isPointAtEdge(selection.getStart(document));

      onCangjieSelect(selection.moveToStart(document).setHanging(_isAtEdge));
      return;
    }

    var isProceeded = shoudStopInsideVoid(controller, 'moveBackward');

    if (isProceeded) {
      return;
    }

    var isAtEdge = isPointAtEdge(selection.anchor);

    if (isAtEdge && selection.isHanging) {
      onCangjieSelect(selection.setHanging(false));
      return;
    }

    var now = Date.now();
    var isGapTimeTooShort = now - lastCaretMoveTime.current < CARET_MOVE_GAP_TIME;

    if (isGapTimeTooShort) {
      return;
    }

    var newSelection = selection.moveAnchorBackward(1, movePointBackward(controller, curry.placeholder, curry.placeholder, 'offset')).moveToAnchor();
    var isNextPointAtEdge = isPointAtEdge(newSelection.anchor);
    lastCaretMoveTime.current = now;
    onCangjieSelect(newSelection.setHanging(isNextPointAtEdge), SelectionTrigger.MoveBackward);
  };

  var moveForward = function moveForward() {
    var _controller$value4 = controller.value,
        document = _controller$value4.document,
        selection = _controller$value4.selection;

    if (selection.isExpanded) {
      onCangjieSelect(selection.moveToEnd(document));
      return;
    }

    var isProceeded = shoudStopInsideVoid(controller, SelectionTrigger.MoveForward);

    if (isProceeded) {
      return;
    }

    var isAtEdge = isPointAtEdge(selection.anchor);

    if (isAtEdge && !selection.isHanging) {
      onCangjieSelect(selection.setHanging(true));
      return;
    }

    var now = Date.now();
    var isGapTimeTooShort = now - lastCaretMoveTime.current < CARET_MOVE_GAP_TIME;

    if (isGapTimeTooShort) {
      return;
    }

    lastCaretMoveTime.current = now;
    onCangjieSelect(selection.moveAnchorForward(1, movePointForward(controller, curry.placeholder, curry.placeholder, 'offset')).moveToAnchor(), SelectionTrigger.MoveForward);
  };

  var handleNativeSelectionChange = function handleNativeSelectionChange() {
    if (!textAreaRef.current || document.activeElement !== textAreaRef.current) {
      return;
    } // iOS - Voice Input will try to select all words when finished
    // ref: https://aone.alibaba-inc.com/v2/project/585561/bug/32431619


    if (textAreaRef.current.selectionStart !== textAreaRef.current.selectionEnd) {
      return;
    } // Detect users move selection by external keyboard arrow keys under iOS@<13
    // Ref: https://bugs.webkit.org/show_bug.cgi?id=149054


    var defaultCaretPosition = textAreaRef.current.value.length - CHARACTERS_LENGTH_AFTER_USER_INPUT;
    var newCaretPosition = textAreaRef.current.selectionStart;

    if (IS_IOS) {
      // Mobile 3rd IME will delete to beginning when choosing english suggestion
      // In this case both `newCaretPosition` and `defaultCaretPosition` is 0
      // We handle this case by adding `defaultCaretPosition !== 0`
      if (newCaretPosition === 0 && defaultCaretPosition !== 0) {
        moveUpward();
      } else if (newCaretPosition === textAreaRef.current.value.length) {
        moveDownward();
      } else if (newCaretPosition - defaultCaretPosition < 0) {
        moveBackward();
      } else if (newCaretPosition - defaultCaretPosition > 0) {
        moveForward();
      }
    } // Reset selection to end of textarea while users change it.
    // e.g. Users move selection by 3D touch.
    // Note: selectionStart is offset of characters and works fine with emoji.


    if (textAreaRef.current.selectionStart !== defaultCaretPosition) {
      textAreaRef.current.selectionStart = defaultCaretPosition;
    }

    if (textAreaRef.current.selectionEnd !== defaultCaretPosition) {
      textAreaRef.current.selectionEnd = defaultCaretPosition;
    }
  };

  React.useEffect(function () {
    if (IS_MOBILE) {
      document.addEventListener('selectionchange', handleNativeSelectionChange);
      return function () {
        document.removeEventListener('selectionchange', handleNativeSelectionChange);
      };
    }

    return undefined;
  }, [controller]);
  React.useEffect(function () {
    return function () {
      if (outsideScoller.current) {
        outsideScoller.current.cancel();
        outsideScoller.current = null;
      }
    };
  }, [controller]);
  return React.useMemo(function () {
    return {
      onKeyDown: function onKeyDown(event) {
        var value = controller.value,
            readOnly = controller.readOnly;
        var document = value.document,
            selection = value.selection;

        if (!selection) {
          return;
        }

        var now = Date.now();
        var isGapTimeTooShort = now - lastCaretMoveTime.current < CARET_MOVE_GAP_TIME;

        if (hotkeys.isSelectAll(event)) {
          controller.perfStart({
            type: PerfType.selection,
            subtype: 'selectAll'
          });
          event.preventDefault();
          onCangjieSelect(selection.moveToRangeOfNode(document, controller), SelectionTrigger.SelectAll);
          return;
        }

        if (hotkeys.isMoveBackward(event)) {
          event.preventDefault();
          moveBackward();
          return;
        }

        if (hotkeys.isMoveForward(event)) {
          event.preventDefault();
          moveForward();
          return;
        }

        if (hotkeys.isMoveUpward(event)) {
          if (readOnly && selection.isCollapsed) {
            return;
          }

          event.preventDefault();
          moveUpward();
          return;
        }

        if (hotkeys.isMoveDownward(event)) {
          if (readOnly && selection.isCollapsed) {
            return;
          }

          event.preventDefault();
          moveDownward();
          return;
        }

        if (hotkeys.isMoveWordBackward(event)) {
          event.preventDefault();

          if (isGapTimeTooShort) {
            return;
          }

          lastCaretMoveTime.current = now;
          onCangjieSelect(selection.move(movePointWordBackward(controller, 'focus')).moveToFocus());
          return;
        }

        if (hotkeys.isMoveWordForward(event)) {
          event.preventDefault();

          if (isGapTimeTooShort) {
            return;
          }

          lastCaretMoveTime.current = now;
          onCangjieSelect(selection.move(movePointWordForward(controller, 'focus')).moveToFocus());
          return;
        }

        if (hotkeys.isMoveLineBackward(event)) {
          event.preventDefault();
          var range = getSelectionAtLine('start', controller, selection);

          if (range) {
            var isAtEdge = isPointAtEdge(range.anchor);
            onCangjieSelect(range.setHanging(isAtEdge));
          }

          return;
        }

        if (hotkeys.isMoveLineForward(event)) {
          event.preventDefault();

          var _range = getSelectionAtLine('end', controller, selection);

          if (_range) {
            onCangjieSelect(_range);
          }

          return;
        }

        if (hotkeys.isMoveToDocumentStart(event)) {
          event.preventDefault();
          onCangjieSelect(selection.moveToStartOfDocument(controller));
          return;
        }

        if (hotkeys.isMoveToDocumentEnd(event)) {
          event.preventDefault();
          onCangjieSelect(selection.moveToEndOfDocument(controller));
          return;
        }

        if (hotkeys.isExtendBackward(event)) {
          event.preventDefault();

          if (isGapTimeTooShort) {
            return;
          }

          lastCaretMoveTime.current = now;
          onCangjieSelect(selection.moveFocusBackward(1, movePointBackward(controller, curry.placeholder, curry.placeholder, 'offset')));
          return;
        }

        if (hotkeys.isExtendForward(event)) {
          event.preventDefault();

          if (isGapTimeTooShort) {
            return;
          }

          lastCaretMoveTime.current = now;
          onCangjieSelect(selection.moveFocusForward(1, movePointForward(controller, curry.placeholder, curry.placeholder, 'offset')));
          return;
        }

        if (hotkeys.isExtendUpward(event)) {
          event.preventDefault();

          if (isGapTimeTooShort || !selection) {
            return;
          }

          lastCaretMoveTime.current = now;
          var point = getUpsidePoint(controller, selection.focus, selection.isHanging);
          var focus = selection.focus,
              anchor = selection.anchor;
          onCangjieSelect(Selection.create({
            anchor: anchor,
            focus: point || focus.moveToStartOfNode(document)
          }));
          return;
        }

        if (hotkeys.isExtendDownward(event)) {
          event.preventDefault();

          if (isGapTimeTooShort || !selection) {
            return;
          }

          lastCaretMoveTime.current = now;
          var _focus = selection.focus,
              _anchor = selection.anchor,
              isHanging = selection.isHanging;

          var _point = getDownsidePoint(controller, _focus, isHanging);

          onCangjieSelect(Selection.create({
            anchor: _anchor,
            focus: _point || _focus.moveToEndOfNode(document)
          }));
          return;
        }

        if (hotkeys.isExtendWordBackward(event)) {
          event.preventDefault();

          if (isGapTimeTooShort) {
            return;
          }

          lastCaretMoveTime.current = now;
          onCangjieSelect(selection.move(movePointWordBackward(controller, 'focus')));
          return;
        }

        if (hotkeys.isExtendWordForward(event)) {
          event.preventDefault();

          if (isGapTimeTooShort) {
            return;
          }

          lastCaretMoveTime.current = now;
          onCangjieSelect(selection.move(movePointWordForward(controller, 'focus')));
          return;
        }

        if (hotkeys.isExtendLineBackward(event)) {
          event.preventDefault();

          var _range2 = getSelectionAtLine('start', controller, selection);

          if (_range2) {
            onCangjieSelect(Selection.create({
              anchor: selection.anchor,
              focus: _range2.focus
            }));
          }

          return;
        }

        if (hotkeys.isExtendToDocumentStart(event)) {
          event.preventDefault();
          onCangjieSelect(selection.moveFocusToStartOfNode(document, controller));
          return;
        }

        if (hotkeys.isExtendToDocumentEnd(event)) {
          event.preventDefault();
          onCangjieSelect(selection.moveFocusToEndOfNode(document, controller));
          return;
        }

        if (hotkeys.isExtendLineForward(event)) {
          event.preventDefault();

          var _range3 = getSelectionAtLine('end', controller, selection);

          if (_range3) {
            onCangjieSelect(Selection.create({
              anchor: selection.anchor,
              focus: _range3.focus
            }));
          }
        }
      },
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onKeyUp: function onKeyUp(event) {
        lastCaretMoveTime.current = 0;
      },
      onMultipleClick: function onMultipleClick(event) {
        var now = Date.now();

        if (event.button === 2) {
          return;
        }

        if (now - lastDoubleClick.current.time < MULTIPLE_CLICK_DELAY && Math.abs(event.clientY - lastDoubleClick.current.y) < MULTIPLE_CLICK_RANGE && Math.abs(event.clientX - lastDoubleClick.current.x) < MULTIPLE_CLICK_RANGE) {
          lastDoubleClick.current = {
            time: 0,
            x: 0,
            y: 0
          };
          lastSingleClick.current = {
            time: 0,
            x: 0,
            y: 0
          };

          var _range4 = caretRangeFromTargetAndCoord(event.target, event.clientX, event.clientY, controller);

          if (!_range4) {
            return;
          }

          var value = controller.value;
          var _document = value.document,
              selection = value.selection;

          var anchorBlock = _document.getClosestBlock(_range4.anchor.key);

          if (selection && anchorBlock) {
            onCangjieSelect(selection.moveToRangeOfNode(anchorBlock, controller), SelectionTrigger.MultipleClick);
          }

          return;
        }

        if (controller.query('isQuickPreview')) {
          return;
        }

        if (now - lastSingleClick.current.time > MULTIPLE_CLICK_DELAY || Math.abs(event.clientY - lastSingleClick.current.y) > MULTIPLE_CLICK_RANGE || Math.abs(event.clientX - lastSingleClick.current.x) > MULTIPLE_CLICK_RANGE) {
          lastSingleClick.current = {
            time: now,
            x: event.clientX,
            y: event.clientY
          };
          lastDoubleClick.current = {
            time: 0,
            x: event.clientX,
            y: event.clientY
          };
          return;
        }

        lastSingleClick.current = {
          time: 0,
          x: 0,
          y: 0
        };
        lastDoubleClick.current = {
          time: now,
          x: event.clientX,
          y: event.clientY
        };
        var range = getWordSelection(controller, event.target, event.clientX, event.clientY);

        if (range) {
          onCangjieSelect(range, SelectionTrigger.MultipleClick);
        }
      },
      onSelectStart: function onSelectStart(event) {
        var isSelecting = false;

        function onSelectUpdate(e) {
          controller.perfStart({
            type: PerfType.selection,
            subtype: 'selectText'
          });

          if (!scrollableContainerRef.current) {
            controller.perfDrop(PerfType.selection);
            return;
          }

          outsideScoller.current && outsideScoller.current(e);
          var target = e.target;
          var x = e.clientX;
          var y = e.clientY;

          if (!target) {
            controller.perfDrop(PerfType.selection);
            return;
          }

          var range = caretRangeFromTargetAndCoord(target, x, y, controller);

          if (!range) {
            controller.perfDrop(PerfType.selection);
            return;
          }

          var selection = controller.value.selection;

          if (!selection || equal(range, selection)) {
            controller.perfDrop(PerfType.selection);
            return;
          }

          isSelecting = true;
          onCangjieSelect(selection.set('focus', range.focus), SelectionTrigger.Selecting);
        }

        function onSelectEnd() {
          if (outsideScoller.current) {
            outsideScoller.current.cancel();
            outsideScoller.current = null;
          }

          stopScroll(controller);

          if (isSelecting) {
            var _selection = controller.value.selection;
            onCangjieSelect(_selection.set('data', omit(_selection.data, 'trigger')));
          }

          window.document.removeEventListener('mousemove', onSelectUpdate);
          window.document.removeEventListener('mouseup', onSelectEnd);
          window.document.removeEventListener('mouseleave', onSelectEnd);
        }

        controller.perfStart({
          type: PerfType.selection,
          subtype: 'focusText'
        });

        if (isJustTapHold.current) {
          controller.perfDrop(PerfType.selection);
          isJustTapHold.current = false;
          return;
        }

        var rawRange = caretRangeFromTargetAndCoord(event.target, event.clientX, event.clientY, controller);
        var isClickAtLeftSide = isCoordAtLeftSide(event.clientX, controller);

        if (!rawRange) {
          controller.perfDrop(PerfType.selection);
          return;
        }

        var range = rawRange.setHanging(isClickAtLeftSide && isPointAtEdge(rawRange.anchor)); // HACK: Safari + third-party IME + MacOS checked TapToHold option
        // sometimes mouseup event triggers before mousedown in a click progress
        // Ref: https://github.com/facebook/react/issues/20787

        if (IS_MAC && IS_SAFARI && event.buttons === 0) {
          // in this backgound, event.buttons is 0
          var _selection2 = controller.value.selection;

          if (event.shiftKey) {
            onCangjieSelect(_selection2.set('focus', range.focus), SelectionTrigger.SelectStart);
          } else {
            onCangjieSelect(range, SelectionTrigger.SelectStart);
          }

          return;
        } // Right button clicked.
        // Ref: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button


        if (event.button === 2) {
          var shouldSelect = shouldSelectOnRightClick(range.focus, controller);

          if (shouldSelect) {
            onCangjieSelect(range);
            return;
          }

          controller.perfDrop(PerfType.selection);

          if (!controller.value.isFocused) {
            controller.run('onCangjieFocus');
          }

          return;
        }

        if (scrollableContainerRef.current) {
          outsideScoller.current = startScroll({
            scroller: scrollableContainerRef.current,
            controller: controller
          });
        }

        window.document.addEventListener('mousemove', onSelectUpdate);
        window.document.addEventListener('mouseup', onSelectEnd);
        window.document.addEventListener('mouseleave', onSelectEnd);
        var selection = controller.value.selection;

        if (event.shiftKey) {
          onCangjieSelect(selection.set('focus', range.focus), SelectionTrigger.SelectStart);
        } else {
          onCangjieSelect(range, SelectionTrigger.SelectStart);
        }
      },
      onTapHoldStart: function onTapHoldStart(event) {
        if (tapHoldTimer.current) {
          clearTimeout(tapHoldTimer.current);
        }

        var _event$touches$ = event.touches[0],
            target = _event$touches$.target,
            clientX = _event$touches$.clientX,
            clientY = _event$touches$.clientY;
        tapHoldTimer.current = window.setTimeout(function () {
          isJustTapHold.current = true;
          var range = getWordSelection(controller, target, clientX, clientY);

          if (range) {
            onCangjieSelect(range);
          }
        }, TAP_HOLD_DELAY);
      },
      onTapHoldEnd: function onTapHoldEnd() {
        if (tapHoldTimer.current) {
          clearTimeout(tapHoldTimer.current);
          tapHoldTimer.current = null;
        }
      }
    };
  }, [controller, scrollableContainerRef, onCangjieSelect]);
}

/**
 * @packageDocumentation
 * @module Events
 * @description Prevent clipboard data from being destroyed when asynchronous retrieval of data
 */
function PasteInputEvent(detail) {
  return new CustomEvent('pasteInput', {
    detail: detail
  });
}

var _createElement$b = React.createElement;
var SHOULD_FOLLOW_CARET = !IS_IOS || IS_IPAD;
var textAreaProps = IS_MOBILE ? {} : {
  spellCheck: false
};
var commonStyle = {
  position: 'fixed',
  overflow: 'hidden',
  width: 1,
  height: 1,
  lineHeight: 1,
  whiteSpace: 'pre-wrap',
  zIndex: -1,
  opacity: 0,
  background: 'transparent',
  color: 'transparent',
  outline: 'none',
  caretColor: 'transparent',
  willChange: 'left,top'
}; //@ts-ignore

if (process.env.NODE_ENV !== 'uitest') {
  // https://developer.mozilla.org/en-US/docs/Web/CSS/contain
  commonStyle.contain = 'strict';
}

var wrapperStyle = SHOULD_FOLLOW_CARET ? commonStyle : _extends({}, commonStyle, {
  top: 0,
  left: -99 // 修复iOS we-web下输入文字时滚动问题
  // height: 'auto',

});
var textAreaStyle = {
  fontSize: 'inherit',
  lineHeight: 1,
  padding: 0,
  border: 'none',
  // [IMPORTANT]
  // 1. iOS@<13 need to preserve `\n` to detect `moveUpward` & `moveDownward`,
  //    see: cangjie/src/hooks/useSelectionCalculator.ts
  // 2. Desktop need `nowrap` to prevent that IME positioning incorrectly
  whiteSpace: IS_IOS ? 'pre-wrap' : 'nowrap',
  // [IMPORTANT]
  // 1. Textarea will enlarge ancestors' rectangle when width is `auto`.
  // 2. `useInputDetector` will treat inputting as deleting if width is smaller than `1em`.
  width: '1em'
};

function usePointPosition(textareaWrapperRef, point, zoom) {
  var controller = useController();
  var container = useZoomContainer();
  React.useEffect(function () {
    if (!SHOULD_FOLLOW_CARET || !point) {
      return;
    }

    var textareaWrapper = textareaWrapperRef.current;

    if (!textareaWrapper) {
      return;
    }

    if (!container) {
      return;
    }

    var isHanging = controller.value.selection.isHanging;
    var preferredEdge = isHanging ? 'start' : 'end';
    var rect = findCaretPosition(point, preferredEdge, container);

    if (!rect) {
      return;
    }

    var clientLeft = rect.clientLeft,
        clientTop = rect.clientTop;
    textareaWrapper.style.top = clientTop + "px";
    textareaWrapper.style.left = clientLeft + "px";
    textareaWrapper.style.fontSize = rect.height / zoom + "px";
  });
}

var HiddenTextArea = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var selection = props.selection,
      rest = _objectWithoutPropertiesLoose(props, ["selection"]);

  var wrapperRef = /*#__PURE__*/React.createRef();
  var zoom = useZoom();
  var controller = useController();
  var point = selection.anchor; // if the target point is inside a void element, take the previous point

  var document = controller.value.document;
  var parentNode = document.getParent(point.key);

  if (parentNode && controller.query('isVoid', parentNode)) {
    point = controller.query(pointAtDistance, point, -1);
  }

  usePointPosition(wrapperRef, point, zoom);

  var children = /*#__PURE__*/_createElement$b("div", {
    ref: wrapperRef,
    style: wrapperStyle,
    "data-cangjie-hidden": true
  }, /*#__PURE__*/_createElement$b("textarea", _extends({}, rest, textAreaProps, {
    ref: ref,
    rows: 1,
    style: textAreaStyle,
    "data-cangjie-input": true // https://aone.alibaba-inc.com/v2/project/585561/bug/45423783#
    // iOS 15+ 有时会出现输入英文时页面 crash 然后 reload
    // 从现象上看，若关闭了系统输入法的「自动改正」开关，就不会出现
    // 因此这里加个 Non-standard Attribute 做个防御
    ,
    autoCorrect: "off"
  })));

  return /*#__PURE__*/ReactDOM__default.createPortal(children, window.document.body);
});

/* eslint-disable prefer-arrow-callback */
function useResumePosition(scrollableContainerRef, containerRef, controller) {
  // 缓存用户最近一次的光标位置，以实现多人协同时，内容变动，固定用户视角
  var snapshotCursorY = React.useRef(null);
  var snapshotScrollTop = React.useRef(0);
  var prevSelectionRef = React.useRef(null);
  var _controller$value = controller.value,
      document = _controller$value.document,
      selection = _controller$value.selection,
      injections = _controller$value.injections;
  React.useMemo(function snapshotCursorPos() {
    if (!controller.shouldResumePosition || controller.enableVirtualizeView) {
      return;
    } // 记录选区数据发生变化，DOM 尚未变更时，DOM 光标的位置
    // BACKGROUND：DOM 更新后，若选区数据（key）未发生变化，而选区对应的空间（Path）变化，则光标差异源于协同编辑，需要做滚动调整
    // HACK：`getSnapshotBeforeUpdate` 没有等价实现，使用 React.memo 实现 DOM 变更前的 Snapshot


    var val = controller.value;

    if (val.isFocused && scrollableContainerRef.current && prevSelectionRef.current) {
      snapshotScrollTop.current = scrollableContainerRef.current.scrollTop;
      var cursorRect = getDOMRectFromSelection(prevSelectionRef.current || val.selection, containerRef.current, controller);

      if (cursorRect) {
        var cursorY = scrollableContainerRef.current.scrollTop + cursorRect.top;
        snapshotCursorY.current = cursorY;
      }
    } else {
      snapshotCursorY.current = null;
    }
  }, [document, selection, injections]);
  React.useEffect(function scrollback() {
    if (!controller.shouldResumePosition || controller.enableVirtualizeView) {
      return;
    }

    var val = controller.value;

    if (val.isFocused && snapshotCursorY.current !== null && scrollableContainerRef.current) {
      // 当 DOM 更新后:
      // 如果选区所在的空间发生了变化，即当前选区的空间，不等于最近一次单人编辑时缓存的空间
      // 则认为选区因协同数据而发生了变化，此时需要做滚回操作
      var cursorRect = getDOMRectFromSelection(val.selection, containerRef.current, controller);

      if (!cursorRect) {
        snapshotCursorY.current = null;
      } else {
        var cursorY = scrollableContainerRef.current.scrollTop + cursorRect.top;
        var offset = cursorY - snapshotCursorY.current;

        if (offset !== 0) {
          scrollableContainerRef.current.scrollTop = snapshotScrollTop.current + offset;
        } // 刷新 DOM 光标位置


        snapshotCursorY.current = cursorY;
      }
    } // 消费后重置回默认值


    controller.setScrollType(defaultScrollType);
  }, [document, selection, injections]);
  React.useEffect(function () {
    prevSelectionRef.current = selection;
  }, [selection]);
}

var DEBOUNCE_TIME_SCROLL_BY_SELECTION = 60;
function useScrollBySelection(scrollableContainerRef, contentRef, controller) {
  var _controller$value = controller.value,
      selection = _controller$value.selection,
      composing = _controller$value.composing;
  var scrollDepsRef = React__default.useRef({
    selection: null,
    composing: ''
  });
  var scrollBySelection = React__default.useMemo(function () {
    return debounce(function (targetSelection, targetComposing) {
      if ((targetSelection.isExpanded || !controller.readOnly) && // 拖选时 or 编辑态下的光标 可触发滚动
      controller.value.isFocused && contentRef.current && scrollableContainerRef.current && (!equal(targetSelection, scrollDepsRef.current.selection) || targetComposing !== scrollDepsRef.current.composing)) {
        scrollDepsRef.current = {
          selection: targetSelection,
          composing: composing
        }; // 移动端：选区 Expand 时候，没必要每次渲染都进行 scroll，不然会导致无法跨段落选择

        if (IS_MOBILE && targetSelection.isExpanded) {
          return;
        } // 表格设置的选区，禁止 scroll


        if (targetSelection.data.isByTable) {
          return;
        }

        if (isScrolling(controller)) {
          return;
        } // 全选状态下，就不要scroll了。


        var _controller$value2 = controller.value,
            latestDocument = _controller$value2.document,
            latestSelection = _controller$value2.selection;

        var _latestSelection$sort = latestSelection.sort(latestDocument),
            start = _latestSelection$sort.start,
            end = _latestSelection$sort.end;

        var startPoint = controller.query(pointAtStartOfNode, latestDocument);
        var endPoint = controller.query(pointAtEndOfNode, latestDocument);
        var skipScroll = equal(start, startPoint) && equal(end, endPoint);

        if (skipScroll) {
          return;
        }

        var target = composing ? Selection.create(_extends({}, targetSelection, {
          focus: TextPoint.create(_extends({}, targetSelection.focus, {
            offset: targetSelection.focus.offset + targetComposing.length
          }))
        })) : targetSelection;
        scrollToSelection(target, contentRef.current, scrollableContainerRef.current, controller);
      }
    }, DEBOUNCE_TIME_SCROLL_BY_SELECTION);
  }, [contentRef, scrollableContainerRef, controller]); // 根据选区变化滚动页面

  React__default.useEffect(function () {
    // 排除渲染后需要滚回至原位置而非选区所在位置的情况
    // BACKGROUND: 协同编辑时，若协同者在同一段落的本地选区之前编辑，会导致本地选区变化
    if (controller.shouldScrollToSelection) {
      scrollBySelection(selection, composing);
    }

    return function () {
      scrollBySelection.cancel();
    }; // 这里不能加 document 依赖，因为可能会导致多人协同的时候，异常滚动。
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [controller, selection, composing]);
}

var _attrbiute;
var _createElement$a = React.createElement;
var attrbiute = (_attrbiute = {}, _attrbiute[Selector.nonSelect] = true, _attrbiute);
var style = {
  pointerEvents: 'none'
};

var isComponentPropsEqual = function isComponentPropsEqual(prevProps, nextProps) {
  return prevProps.isFocused === nextProps.isFocused && prevProps.isRemote === nextProps.isRemote && equal(prevProps.rects, nextProps.rects) && equal(prevProps.selection, nextProps.selection);
};
/**
 * 负责渲染 expanded selection
 */


var Range = /*#__PURE__*/React.memo(function (props) {
  var rects = props.rects,
      controller = props.controller,
      isFocused = props.isFocused,
      isRemote = props.isRemote,
      selection = props.selection;
  var color = React.useMemo(function () {
    return controller.query('selectionColor', selection, !isRemote // isFocused 在 query 内部会消费掉
    // eslint-disable-next-line react-hooks/exhaustive-deps
    );
  }, [controller, selection, isRemote, isFocused]);
  return /*#__PURE__*/_createElement$a("div", {
    "data-cangjie-selection": selection.viewKey,
    style: style,
    "data-testid": "cangjie-range",
    className: "cangjie-range"
  }, rects.map(function (rect) {
    var position = 'absolute';
    var left = rect.left,
        top = rect.top,
        width = rect.width,
        height = rect.height;
    var key = left + "-" + top + "-" + width + "-" + height;
    var style = {
      position: position,
      left: left,
      top: top,
      width: width,
      height: height,
      backgroundColor: color || CANGJIE_SELECTION_INACTIVE_COLOR
    };
    return /*#__PURE__*/_createElement$a("div", _extends({
      key: key
    }, attrbiute, {
      style: style
    }));
  }));
}, isComponentPropsEqual);

/* eslint-disable prefer-arrow-callback */

function isDelayed(selection, controller) {
  return selection !== controller.value.selection;
}

function usePerf(controller, noTrack) {
  /********************************************************************************************\
  * 正常绘制流程                                                                                 *
  *                 +---------+    +---------+   +---------+   +---------+   +----------+      *
  *  ---------------+ keydown +----+ render  +---+   rAF   +---+  paint  +---+setTimeout+----> *
  * Timeline        +---------+    +---------+   +---------+   +---------+   +----------+      *
  *                                                                                            *
  \********************************************************************************************/

  /*************************************************************************************************************\
  * 丢帧场景                                                                                                     *
  *                                +--------------+                                                             *
  *                          +---->| 未被绘制，丢帧 |                                                             *
  *                          |     +--------------+                                                             *
  *                          |                                                                                  *
  *            +--------------------------+                                                                     *
  *            | +---------+  +---------+ | +----------+  +---------+  +---------+ +---------+  +---------+     *
  *  ----------+-+ keydown +--+ render  +-+-+setTimeout+--+ keydown +--+ render  +-+   rAF   +--+  paint  +---> *
  * Timeline   | +---------+  +---------+ | +----------+  +---------+  +---------+ +---------+  +---------+     *
  *            +--------------------------+                                                                     *
  *                                                                                                             *
  \*************************************************************************************************************/
  useEffect(function () {
    if (noTrack) {
      return;
    } // 如果是 pending 期间的选区更新，进行输入统计


    var pendingType = controller.pendingType;

    if (pendingType === PendingType.input || pendingType === PendingType.selection) {
      var selection = controller.value.selection;
      var dropped = true;
      window.requestAnimationFrame(function preparePaint() {
        // 在下一次 repaint 发生前，若光标不再等于组件 update 时的光标，则认为丢帧
        dropped = isDelayed(selection, controller);
        var perfType = pendingType === PendingType.input ? controller.value.composing ? PerfType.composing : PerfType.input : PerfType.selection;
        controller.perfEnd(perfType, dropped);
      });
    }
  });
}

var _createElement$9 = React__default.createElement;
var SelectionRenderer = /*#__PURE__*/React__default.memo(function (props) {
  var appearances = props.appearances,
      isFocused = props.isFocused,
      controller = props.controller;
  var prevSelectionRef = React__default.useRef(null);

  var _React$useState = React__default.useState(null),
      globalStyle = _React$useState[0],
      setGlobalStyle = _React$useState[1];

  usePerf(controller, prevSelectionRef.current === controller.value.selection);
  React__default.useEffect(function () {
    var style = controller.query('selectionGlobalStyle');
    setGlobalStyle(style);
  }, []);
  var wrappers = Array.from(appearances.keys());

  var _ref2 = /*#__PURE__*/_createElement$9("style", null, globalStyle);

  return /*#__PURE__*/_createElement$9(React__default.Fragment, null, wrappers.map(function (wrapper) {
    if (!wrapper) {
      return null;
    }

    var info = appearances.get(wrapper);
    var hasRemote = false;

    var content = /*#__PURE__*/_createElement$9(React__default.Fragment, null, info.map(function (_ref, index) {
      var appearance = _ref.appearance,
          isRemote = _ref.isRemote,
          selection = _ref.selection,
          color = _ref.color;
      hasRemote = hasRemote || isRemote;
      return Array.isArray(appearance) ? /*#__PURE__*/_createElement$9(Range, {
        key: "range-" + index,
        rects: appearance,
        isRemote: isRemote,
        isFocused: isFocused,
        controller: controller,
        selection: selection
      }) : /*#__PURE__*/_createElement$9(Caret, {
        key: "caret-" + index,
        color: color,
        isRemote: isRemote,
        isFocused: isFocused,
        controller: controller,
        selection: selection,
        position: appearance
      });
    }), hasRemote && _ref2);

    return /*#__PURE__*/ReactDOM__default.createPortal(content, wrapper);
  }));
});

/**
 * @packageDocumentation
 * @ignore
 */
var RE_RGB = /^rgba?\((.+)\)/i;
var ALPHA_THRESHOLD = 0.5;
var LUMINANCE_THRESHOLD = 0.5;

function isCoordInsideDOMRect(x, y, rect) {
  var left = rect.left,
      right = rect.right,
      top = rect.top,
      bottom = rect.bottom;
  return x >= left && x <= right && y >= top && y <= bottom;
}
function getBgColor(targetBlock, at, point) {
  var element = targetBlock;

  if (point.isTextPoint()) {
    var leaves = targetBlock.querySelectorAll("[" + Selector.key + "^=\"" + point.key + ":\"]");
    var target = Array.from(leaves).find(function (b) {
      return isCoordInsideDOMRect(at.left, at.top + at.height / 2, b.getBoundingClientRect());
    });

    if (target) {
      element = target;
    }
  }

  while (element) {
    var color = window.getComputedStyle(element).backgroundColor;
    var rgba = rgbaFromString(color);

    if (rgba && rgba[3] > ALPHA_THRESHOLD && element.getBoundingClientRect().width > 0) {
      return rgba;
    }

    element = element.parentElement;
  }

  return [255, 255, 255, 1];
}
/**
 * rgba 字符串转为 rgba 数组。
 * 'rgba(0,0,0,0.88)' => [0,0,0,0.88]
 * 'RGB(0,0,0)' => [0,0,0,1]
 */

function rgbaFromString(str) {
  var rgb = RE_RGB.exec(str) || [];
  var rgbs = (rgb[1] || '').split(',');

  if (rgbs.length < 3) {
    return null;
  } else if (rgbs.length === 3) {
    rgbs.push('1');
  }

  var rgba = [0, 0, 0, 0];
  rgba[0] = parseInt(rgbs[0], 10);
  rgba[1] = parseInt(rgbs[1], 10);
  rgba[2] = parseInt(rgbs[2], 10);
  rgba[3] = parseFloat(rgbs[3]);
  return rgba;
}
/**
 * 获取相对的 luminance。
 * https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
 */


function getLuminance(rgba) {
  var a = [];

  for (var i = 0; i < 3; i++) {
    var x = rgba[i] / 255;
    a[i] = x <= 0.03928 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
  }

  return 0.2126 * a[0] + 0.7152 * a[1] + 0.0722 * a[2];
}
/**
 * 根据背景色，获取光标的颜色。
 */


function getCaretColor(backgroundColor) {
  var luminance = getLuminance(backgroundColor);
  return luminance > LUMINANCE_THRESHOLD ? 'black' : 'white';
}

/**
 * 从 cangjie-leaf 中获取 rects
 */

function getRectsFromLeaf(element, selection, document) {
  var _element$getAttribute, _textNode$textContent;

  var _selection$convertToT = selection.convertToTextPoints(document),
      start = _selection$convertToT.start,
      end = _selection$convertToT.end;

  var _ref = ((_element$getAttribute = element.getAttribute(Selector.key)) == null ? void 0 : _element$getAttribute.split(':')) || [],
      keyStr = _ref[0],
      leafOffsetStr = _ref[1];

  var textNode = element.firstChild;

  if (!keyStr || !leafOffsetStr || !textNode) {
    return [];
  } // 检测 leaf 所在的 text 是否在选区内


  if (!document.isNodeInRange(keyStr, selection)) {
    return [];
  }

  var textLength = ((_textNode$textContent = textNode.textContent) == null ? void 0 : _textNode$textContent.length) || 0;
  var leafOffset = parseInt(leafOffsetStr, 10); // 检测 leaf 是否在选区内

  if (keyStr === start.key && start.offset > leafOffset + textLength) {
    return [];
  }

  if (keyStr === end.key && end.offset < leafOffset) {
    return [];
  } // 是否是一半的 leaf


  var startOffset = -1;
  var endOffset = -1;

  if (keyStr === start.key && start.offset >= leafOffset && start.offset <= leafOffset + textLength) {
    startOffset = start.offset - leafOffset;
  }

  if (keyStr === end.key && end.offset >= leafOffset && end.offset <= leafOffset + textLength) {
    endOffset = end.offset - leafOffset;
  }

  if (startOffset >= 0 || endOffset >= 0) {
    try {
      var range = window.document.createRange();
      range.setStart(textNode, Math.max(startOffset, 0));
      range.setEnd(textNode, endOffset < 0 ? textLength : endOffset);
      return Array.from(range.getClientRects());
    } catch (error) {
      return [];
    }
  } // 到这里，肯定是完整的 leaf


  return Array.from(element.getClientRects());
}

function getDOMPath(dom, root) {
  if (root === void 0) {
    root = window.document.body;
  }

  var path = [];
  var current = dom;

  while (current && current !== root) {
    path.push(current);
    current = current.parentElement;
  }

  return path.reverse();
}
function getTraverseRootsByDOMPath(path1, path2) {
  var length = Math.min(path1.length, path2.length);
  var current = 0;

  for (; current < length; current++) {
    if (path1[current] !== path2[current]) {
      break;
    }
  }

  if (current === length) {
    return [path1[length - 1], path1[length - 1], path1.slice(0, length)];
  }

  return [path1[current], path2[current], current > 0 ? path1.slice(0, current) : []];
}

function _createForOfIteratorHelperLoose$2(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }

function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function traverseDOMTree(root, callback, parentContext, options) {
  if (parentContext === void 0) {
    parentContext = {};
  }

  var isStarted = options.isStarted,
      isEnded = options.isEnded;

  var _callback = callback(root, parentContext),
      stopTraverse = _callback.stopTraverse,
      context = _callback.context;

  if (stopTraverse) {
    return {
      isStarted: isStarted,
      isEnded: isEnded
    };
  }

  var childContext = merge(_extends({}, parentContext), context);
  var startPath = options.startPath,
      endPath = options.endPath,
      rootPath = options.rootPath;

  for (var _iterator = _createForOfIteratorHelperLoose$2(root.children), _step; !(_step = _iterator()).done;) {
    var ele = _step.value;
    var path = rootPath.concat(ele);

    var _getTraverseRootsByDO = getTraverseRootsByDOMPath(startPath, path),
        commonStartPath = _getTraverseRootsByDO[2];

    var _getTraverseRootsByDO2 = getTraverseRootsByDOMPath(endPath, path),
        commonEndPath = _getTraverseRootsByDO2[2]; // 未遍历到 start dom 且在遍历 start dom 的祖先节点


    if (!isStarted && commonStartPath.length === path.length) {
      var started = commonStartPath.length === startPath.length;
      var newOpt = traverseDOMTree(ele, callback, childContext, {
        startPath: startPath,
        endPath: endPath,
        rootPath: path,
        isStarted: started,
        isEnded: isEnded
      });
      isStarted = newOpt.isStarted;
      isEnded = newOpt.isEnded;
    } else if (isStarted && (!isEnded || commonEndPath.length === endPath.length)) {
      // 已到过 start dom 且未遍历完 end dom tree
      var ended = commonEndPath.length === endPath.length;

      var _newOpt = traverseDOMTree(ele, callback, childContext, {
        startPath: startPath,
        endPath: endPath,
        rootPath: path,
        isStarted: isStarted,
        isEnded: ended
      });

      isStarted = _newOpt.isStarted;
      isEnded = _newOpt.isEnded;
    } else if (isEnded && commonEndPath.length < endPath.length) {
      // 已遍历完 end dom tree
      break;
    }
  }

  return {
    isStarted: isStarted,
    isEnded: isEnded
  };
}
/**
 * 情况一：startAncestor, endAncestor 为相同节点
 * startAncestor/endAncestor/commonPath
 *                / \
 *               /   \
 *             void  block
 *                     /\
 *                    /  \
 *                 leaf  leaf
 *
 * 情况二：startAncestor, endAncestor 为兄弟节点
 *             commonPath
 *             /    |    \
 *            /     |     \
 *  startAncestor  ...  endAncestor
 *     / \               /    \
 *    /   \             /      \
 * void    block      block     block
 *          /\         /\        /\
 *         /  \       /  \      /  \
 *      leaf  leaf leaf  leaf leaf leaf
 * (startPath)              (endPath)
 *
 * 情况三：startAncestor, endAncestor 为兄弟节点，且 startPath = startAncestor or endPath = endAncestor
 *             commonPath
 *             /    |    \
 *            /     |     \
 *  startAncestor  ...  endAncestor
 * (startPath/void)       /    \
 *                       /      \
 *                     block     block
 *                      / \       / \
 *                     /   \     /   \
 *                   leaf  leaf leaf leaf
 *                                 (endPath)
 */

function traverseDOMForest(startPath, endPath, callback) {
  var _getTraverseRootsByDO3 = getTraverseRootsByDOMPath(startPath, endPath),
      startAncestor = _getTraverseRootsByDO3[0],
      endAncestor = _getTraverseRootsByDO3[1],
      commonPath = _getTraverseRootsByDO3[2];

  var root = commonPath.length === startPath.length ? startPath[startPath.length - 1] : startAncestor;
  var _isStarted$isEnded = {
    isStarted: commonPath.length === startPath.length,
    isEnded: commonPath.length === endPath.length
  },
      isStarted = _isStarted$isEnded.isStarted,
      isEnded = _isStarted$isEnded.isEnded;

  while (root) {
    var opt = traverseDOMTree(root, callback, {}, {
      startPath: startPath,
      endPath: endPath,
      rootPath: [].concat(commonPath, [root]),
      isStarted: isStarted || commonPath.length + 1 === startPath.length && root === startPath[startPath.length - 1],
      isEnded: isEnded || commonPath.length + 1 === endPath.length && root === endPath[endPath.length - 1]
    });
    isStarted = opt.isStarted;
    isEnded = opt.isEnded;

    if (root === endAncestor) {
      break;
    }

    root = root.nextElementSibling;
  }
}

function _createForOfIteratorHelperLoose$1(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// 复用选区定位逻辑中对同一行的判断来进行分行
var isOverlapped = function isOverlapped(a, b) {
  return isRectOnSameLineOfRect(_extends({}, a, {
    height: a.bottom - a.top
  }), _extends({}, b, {
    height: b.bottom - b.top
  }));
};

var getMaxLineSize = function getMaxLineSize(a, b) {
  return {
    top: Math.min(a.top, b.top),
    bottom: Math.max(a.bottom, b.bottom)
  };
}; // 扩展行高，填充行之间的空隙


function extendToFillBetweenLines(lines, startRects, endRects) {
  if (startRects === void 0) {
    startRects = [];
  }

  if (endRects === void 0) {
    endRects = [];
  }

  var length = lines.length;

  if (length === 0) {
    return [];
  }

  var first = lines[0];
  var last = lines[length - 1]; // 用选区 start 所在 block 的 rects 扩展第一行的高度

  for (var _iterator = _createForOfIteratorHelperLoose$1(startRects), _step; !(_step = _iterator()).done;) {
    var rect = _step.value;

    if (rect && isOverlapped(rect, first)) {
      first = getMaxLineSize(rect, first);
    }
  } // 用选区 end 所在 block 的 rects 扩展最后一行的高度


  for (var _iterator2 = _createForOfIteratorHelperLoose$1(endRects), _step2; !(_step2 = _iterator2()).done;) {
    var _rect = _step2.value;

    if (_rect && isOverlapped(_rect, last)) {
      last = getMaxLineSize(_rect, last);
    }
  }

  var filled = [first].concat(lines.slice(1, length - 1), [last]);

  for (var i = 1; i < length; i++) {
    var prev = filled[i - 1];
    var now = filled[i];
    var margin = now.top - prev.bottom;
    prev.bottom += margin / 2;
    now.top -= margin / 2;
  }

  return filled;
}

function splitRectsIntoLines(rects) {
  // 将 rects 以从上到下、从左到右排序 - O(NlogN)
  var sortedRects = rects.filter(function (v) {
    return v.width;
  }).sort(function (a, b) {
    return a.top - b.top || a.left - b.left;
  });
  var lines = [];
  var lineSizes = []; // 将 sortedRects 按顺序归纳到每一行中，并记录每行的尺寸 - O(N)

  var currentIndex = 0;
  sortedRects.forEach(function (rect) {
    if (lines.length === 0) {
      lines.push([rect]);
      lineSizes.push({
        top: rect.top,
        bottom: rect.bottom
      });
      return;
    } // 新的一行


    if (!isOverlapped(rect, lineSizes[currentIndex]) || rect.lineId !== lines[currentIndex][0].lineId) {
      lines.push([rect]);
      lineSizes.push({
        top: rect.top,
        bottom: rect.bottom
      });
      currentIndex += 1;
      return;
    } // 属于当前行


    lines[currentIndex].push(rect);
    lineSizes[currentIndex] = getMaxLineSize(rect, lineSizes[currentIndex]);
  });
  return [lines, lineSizes];
}

function antiAliasingRects(rects, startRects, endRects) {
  if (startRects === void 0) {
    startRects = [];
  }

  if (endRects === void 0) {
    endRects = [];
  }

  // 将 rects 以从上到下、从左到右排序，并记录每行的尺寸 - O(NlogN)（N 为 rect 个数）
  var _splitRectsIntoLines = splitRectsIntoLines(rects),
      lines = _splitRectsIntoLines[0],
      lineSizes = _splitRectsIntoLines[1];

  var startSizes = extendToFillBetweenLines(splitRectsIntoLines(startRects)[1]);
  var endSizes = extendToFillBetweenLines(splitRectsIntoLines(endRects)[1]); // 填充行之间的空隙：获得每行填充后的尺寸 - O(M)（M 为行数）

  var filledSizes = extendToFillBetweenLines(lineSizes, startSizes, endSizes); // 填充行之间的空隙：将 rects 更新为填充后的尺寸并合并相邻的 - ~O(N)

  var result = [];
  lines.forEach(function (lineRects, index) {
    var top = filledSizes[index].top;
    var height = filledSizes[index].bottom - top;
    var fitted = lineRects.map(function (rect) {
      return {
        top: top,
        height: height,
        left: rect.left,
        width: rect.width
      };
    });
    var merged = mergeRects(fitted);
    result.push.apply(result, merged);
  });
  return result;
}

var isEdgeSelectable = function isEdgeSelectable(dom) {
  return dom.getAttribute(Selector.edgeSelectable) === 'true';
};

var isLeaf = function isLeaf(dom) {
  return dom.getAttribute(Selector.leaf) === 'true';
};

var isVoid = function isVoid(dom) {
  return dom.getAttribute(Selector["void"]) === 'true';
};

var isFloatInlineBox = function isFloatInlineBox(dom) {
  return dom.getAttribute('data-type') === 'float-inline-box';
};

var isFloatBlockBox = function isFloatBlockBox(dom) {
  return dom.getAttribute('data-type') === 'float-block-box';
};

var isLine = function isLine(dom) {
  return dom.getAttribute('data-type') === 'line';
}; // const isGroupBlock = (dom: HTMLElement) => dom.getAttribute(Selector.groupBlock) === 'true';


var isPage = function isPage(dom) {
  return dom.getAttribute('data-type') === 'page';
};

var isTableCell = function isTableCell(dom) {
  return dom.getAttribute('data-type') === 'table-cell';
};

var isFullyContained = function isFullyContained(key, voidElement, selection, document) {
  var _selection$sort = selection.sort(document),
      start = _selection$sort.start,
      end = _selection$sort.end;

  var startPath = document.getPath(start.key);
  var endPath = document.getPath(end.key);
  var targetPath = document.getPath(key);

  if (!startPath || !endPath || !targetPath) {
    return false;
  }

  if (Path.isAncestor(targetPath, startPath) || Path.isAncestor(targetPath, endPath)) {
    // eg. 目标节点为 [0, 1]，start/end 为 [0, 1, 0]
    // => 目标节点若为 void 元素，则选区包含了目标
    // => 目标节点若非 void，则选区未完全包含目标
    return voidElement;
  }

  return document.isNodeInRange(key, selection);
};

var GlobalGroupKey = 'global-group';
var DefaultGapLabel = 'default-gap-label';

var getGapLabel = function getGapLabel(decesdant) {
  var conditions = [// isGroupBlock, // TODO FIXME: groupNodes 隔开的上下的全局段落，会被分组到一起做空隙填充，需要再对每个连续的全局区块单独命名
  isPage, isTableCell, isFloatInlineBox, // 浮动元素单独为一组，不参与普通 Rect 的间隙填充逻辑
  isFloatBlockBox // eg. 首字下沉
  ];
  var shouldGap = conditions.find(function (cond) {
    return cond(decesdant);
  });
  return shouldGap ? decesdant.getAttribute(Selector.key) || DefaultGapLabel : undefined;
};
/**
 * 判断当前节点的子节点中是否仅有一个 leaf/void 节点
 * @param decesdant
 * @returns
 */


var hasOnlyLeafChild = function hasOnlyLeafChild(decesdant) {
  var count = 0;
  var len = decesdant.children.length;

  for (var i = 0; i < len; i++) {
    if (isLeaf(decesdant.children[i]) || isVoid(decesdant.children[i])) {
      count++;
    } // perf: 找到超过 1 个符合要求的，就提前 return


    if (count > 1) {
      return false;
    }
  }

  return count === 1;
};

var addLineIdToRect = function addLineIdToRect(rect, lineId) {
  return _extends({}, rect.toJSON ? rect.toJSON() : rect, {
    lineId: lineId
  });
};

var addToRectGroupWithGap = function addToRectGroupWithGap(rects, target, context) {
  var _target$key$label;

  if (context === void 0) {
    context = {};
  }

  var key = context.scrollableKey || GlobalGroupKey;
  var label = context.gapLabel || DefaultGapLabel;

  if (!target[key]) {
    target[key] = {};
  }

  if (!target[key][label]) {
    target[key][label] = [];
  }

  (_target$key$label = target[key][label]).push.apply(_target$key$label, rects);
};

function getRectsFromSelection(selection, contentDOM, controller) {
  var document = controller.value.document;

  var _selection$sort2 = selection.sort(document),
      start = _selection$sort2.start,
      end = _selection$sort2.end;

  var startBlock = start.isEdgePoint() ? document.getNode(start.key) : document.getClosestBlock(start.key);
  var endBlock = end.isEdgePoint() ? document.getNode(end.key) : document.getClosestBlock(end.key);
  var startPath = document.getPath(start.key);
  var endPath = document.getPath(end.key);
  var startBlockPath = startBlock && document.getPath(startBlock.key);
  var endBlockPath = endBlock && document.getPath(endBlock.key);

  if (!startBlock || !endBlock || !startPath || !endPath || !startBlockPath || !endBlockPath) {
    throw new Error('start/end block or path is empty');
  }

  var selectionRects = {};
  var startRects = {};
  var endRects = {}; // 遍历过程中的 DOM 节点处理逻辑

  var traverseHandler = function traverseHandler(decesdant, context) {
    if (context === void 0) {
      context = {};
    }

    var domKey = decesdant.getAttribute(Selector.key);

    if (!domKey) {
      return {
        stopTraverse: false
      };
    }

    var voidDOM = isVoid(decesdant);
    var leafDOM = isLeaf(decesdant);
    var lineDOM = isLine(decesdant);
    var edgeSelectableDOM = isEdgeSelectable(decesdant); // 记录 start/end 所在 block 的所有 rects，用于后续修正选区边界的 rect

    if (voidDOM || leafDOM) {
      var path = document.getPath(domKey.split(':')[0]) || [];

      if (Path.isAncestor(startBlockPath, path)) {
        addToRectGroupWithGap(Array.from(decesdant.getClientRects()).map(function (v) {
          return addLineIdToRect(v, context.lineId);
        }), startRects, context);
      }

      if (Path.isAncestor(endBlockPath, path)) {
        addToRectGroupWithGap(Array.from(decesdant.getClientRects()).map(function (v) {
          return addLineIdToRect(v, context.lineId);
        }), endRects, context);
      }
    }

    if (edgeSelectableDOM || voidDOM) {
      if (isFullyContained(domKey, voidDOM, selection, document)) {
        var rect = decesdant.getBoundingClientRect();
        addToRectGroupWithGap([addLineIdToRect(rect, context.lineId)], selectionRects, context);
        return {
          stopTraverse: true
        }; // 不再继续递归
      }

      if (voidDOM) {
        return {
          stopTraverse: true
        };
      }
    }

    if (leafDOM) {
      var newRects = getRectsFromLeaf(decesdant, selection, document);

      if (context.onlyLeafChild && newRects.length === 1 && newRects[0].width < 1) {
        var _newRects$ = newRects[0],
            left = _newRects$.left,
            top = _newRects$.top,
            height = _newRects$.height;
        var width = CANGJIE_SELECTION_EMPTY_WIDTH;
        newRects = [_extends({}, newRects[0].toJSON(), {
          left: left,
          top: top,
          width: width,
          height: height
        })];
      }

      addToRectGroupWithGap(newRects.map(function (v) {
        return addLineIdToRect(v, context.lineId);
      }), selectionRects, context);
      return {
        stopTraverse: true
      };
    }

    var gapLabel = getGapLabel(decesdant) || context.gapLabel;
    return {
      stopTraverse: false,
      context: {
        gapLabel: gapLabel,
        lineId: lineDOM ? domKey : undefined,
        onlyLeafChild: hasOnlyLeafChild(decesdant)
      }
    };
  };

  var commonAncestorNode = document.getNodeByPath(Path.common(startPath, endPath));

  if (!commonAncestorNode) {
    throw new Error('commonAncestorNode is empty');
  }

  var commonAncestor = (commonAncestorNode.isElement() ? commonAncestorNode : document.getClosestBlock(commonAncestorNode.key)) || document; // 由于 view 或 实际 DOM 树与 document 结构并非一致，所以通过查找 DOM 树上需遍历的子树根结点来做

  var startBlockDOM = findDOMNodeSafely(startBlock.key, contentDOM);
  var endBlockDOM = findDOMNodeSafely(endBlock.key, contentDOM); // 分页模式下存在虚拟化，若找不到 DOM 则全量遍历已有 DOM

  if (!startBlockDOM || !endBlockDOM) {
    var commonAncestorDOM = findDOMNodeSafely(commonAncestor.key, contentDOM);
    startBlockDOM = startBlockDOM || (commonAncestorDOM == null ? void 0 : commonAncestorDOM.firstElementChild);
    endBlockDOM = endBlockDOM || (commonAncestorDOM == null ? void 0 : commonAncestorDOM.lastElementChild);
  } // 仍找不到则报错


  if (!startBlockDOM || !endBlockDOM) {
    throw new Error('start/end block DOM is empty');
  }

  var startDOMPath = getDOMPath(startBlockDOM, contentDOM);
  var endDOMPath = getDOMPath(endBlockDOM, contentDOM); // 以遍历森林的方式遍历 [startDOMPath, endDOMPath] 之间的节点

  traverseDOMForest(startDOMPath, endDOMPath, traverseHandler);
  var res = [];
  Object.keys(selectionRects).forEach(function (groupKey) {
    // res[groupKey] = [];
    Object.keys(selectionRects[groupKey]).forEach(function (gapLabel) {
      var _startRects$groupKey, _endRects$groupKey;

      // TO BE SOLVED: 1. 存在上下 margin 的 block 元素在跨 block 选区时高度会不稳定
      var lines = antiAliasingRects(selectionRects[groupKey][gapLabel], (_startRects$groupKey = startRects[groupKey]) == null ? void 0 : _startRects$groupKey[gapLabel], (_endRects$groupKey = endRects[groupKey]) == null ? void 0 : _endRects$groupKey[gapLabel]);
      res.push.apply(res, lines);
    });
  });
  return res;
}

function addToResult(result, wrapper, data) {
  if (!result.get(wrapper)) {
    result.set(wrapper, []);
  }

  var targetGroup = result.get(wrapper);
  targetGroup.push(data);
}

var getComposingLeaf = function getComposingLeaf(node) {
  return node != null && node.isText() ? node.leaves.find(function (leaf) {
    return leaf.marks.some(function (mark) {
      return mark.type === 'cangjieComposing';
    });
  }) : undefined;
};
/**
 * 输入法输入时，找到光标实际所在的 point
 *
 * @param anchor
 * @param composingLen
 * @param document 包含 composing mark 的 document
 * @returns
 * - composing leaf 未跨 Text 时，修正 offset 到 anchor.offset + composingLen
 * - composing leaf 跨 Text 时，修正到 composing 末尾所在的 Text 内，offset 为最后一个 Text 内的 composing 部分长度
 */


var findComposingPoint = function findComposingPoint(anchor, composingLen, document) {
  var len = 0;
  var composingEndLeaf;
  var startText = document.getNode(anchor.key);
  var textNode = startText; // 分页模式下，document 上存在 composing mark，则继续向后找到 composing 末尾；否则使用 startText 即可

  if (getComposingLeaf(startText)) {
    var pointAncestor = document.getFurthestOnlyChildAncestor(anchor.key);

    while (len < composingLen && (_textNode = textNode) != null && _textNode.isText()) {
      var _textNode, _composingEndLeaf;

      composingEndLeaf = getComposingLeaf(textNode);
      len += ((_composingEndLeaf = composingEndLeaf) == null ? void 0 : _composingEndLeaf.text.length) || 0;

      if (len < composingLen) {
        textNode = pointAncestor ? pointAncestor.getNextText(textNode.key) : null;
      }
    }
  }

  if (textNode) {
    return TextPoint.create({
      key: textNode.key,
      offset: startText !== textNode && composingEndLeaf ? composingEndLeaf.text.length : anchor.offset + composingLen
    });
  } // 兜底使用原值


  return anchor;
};
function getSelectionAppearance(selectionWrapperMap, zoom, isRemote, contentRef, controller) {
  var result = new Map();

  if (!contentRef.current) {
    return result;
  }

  if (controller.shouldHideSelectionOnBlur() && controller.value.isBlurred) {
    return result;
  }

  var wrapperRectCache = new WeakMap();
  var composingLen = controller.value.composing.length;
  selectionWrapperMap.forEach(function (_ref, selection) {
    var wrapper = _ref.wrapper,
        originSelection = _ref.originSelection;

    if (!wrapper) {
      return;
    }

    var offsetRect = wrapperRectCache.get(wrapper) || wrapper.getBoundingClientRect();
    wrapperRectCache.set(wrapper, offsetRect);

    if (originSelection.isCollapsed) {
      var preferredEdge = originSelection.isHanging ? 'start' : 'end';
      var point = selection.anchor;

      if (!isRemote && point.isTextPoint() && composingLen) {
        point = findComposingPoint(point, composingLen, controller.value.document);
      }

      var targetBlockDOM = null;

      try {
        // 存在 selection 先更新而 document 后更新，导致找不到 block 的情况，需要 catch 住，下次更新即可正常渲染
        var block = controller.value.document.getClosestBlockFromPoint(point.key);
        targetBlockDOM = block ? findDOMNodeSafely(block.key, contentRef.current || undefined) : null;
      } catch (e) {// ignore
      }

      if (!targetBlockDOM) {
        return;
      } // 计算位置


      var _ref2 = findCaretPosition(point, preferredEdge, targetBlockDOM, undefined, zoom) || {},
          clientLeft = _ref2.clientLeft,
          clientTop = _ref2.clientTop,
          height = _ref2.height;

      if (typeof clientLeft === 'undefined' || typeof clientTop === 'undefined' || typeof height === 'undefined') {
        return;
      }

      var correctedPosition = {
        top: clientTop - offsetRect.top / zoom,
        left: clientLeft - offsetRect.left / zoom,
        height: height
      };

      if (!isRemote) {
        cacheLocalCaret(controller, correctedPosition, wrapper);
      }

      var color; // 为本地光标计算颜色

      if (!isRemote) {
        var backgroundColor = getBgColor(targetBlockDOM, {
          top: clientTop,
          left: clientLeft,
          height: height
        }, point);
        color = getCaretColor(backgroundColor);
      }

      var data = {
        isRemote: isRemote,
        color: color,
        selection: originSelection,
        appearance: correctedPosition
      };
      addToResult(result, wrapper, data);
      return;
    }

    try {
      var rects = getRectsFromSelection(selection, contentRef.current, controller);
      var _data = {
        isRemote: isRemote,
        selection: originSelection,
        appearance: rects.map(function (rc) {
          return {
            top: (rc.top - offsetRect.top) / zoom,
            left: (rc.left - offsetRect.left) / zoom,
            height: rc.height / zoom,
            width: rc.width / zoom
          };
        })
      };
      addToResult(result, wrapper, _data);
    } catch (err) {
      console.warn('[Selection] Failed to get rects from expanded selection', err);
    }
  });
  return result;
}

var _createElement$8 = React__default.createElement;
var nativeSupport = false; // 仓颉代码会执行在 node 里，这里做一下防护

if (typeof Element !== 'undefined' && typeof Element.prototype !== 'undefined') {
  nativeSupport = 'attachShadow' in Element.prototype && typeof Element.prototype.attachShadow === 'function';
}

function ShadowRoot(props) {
  if (!nativeSupport) {
    return /*#__PURE__*/_createElement$8("div", props.attributes, props.children);
  }

  return /*#__PURE__*/_createElement$8(root.div, props.attributes, props.children);
}

var _createElement$7 = React__default.createElement;
var slotStyle = {
  position: 'absolute',
  zIndex: 10,
  // 相对于顶部定位，避免折叠/展开等操作引起的选区定位不稳定
  top: 0
};
var SelectionSlot = /*#__PURE__*/React__default.forwardRef(function (props, slotRef) {
  var _ref;

  return /*#__PURE__*/_createElement$7(ShadowRoot, {
    attributes: (_ref = {}, _ref[Selector.selectionLayer] = props.layerFor, _ref['data-testid'] = 'cangjie-selection-layer', _ref.style = {
      position: 'absolute',
      left: 0,
      top: 0
    }, _ref)
  }, /*#__PURE__*/_createElement$7("div", {
    ref: slotRef,
    style: slotStyle
  }), props.children);
});

function splitSelectionAndGetWrapper(controller, selection, globalRef) {
  var wrappers = controller.query('getSelectionContainers', {
    selection: selection,
    defaultWrapper: globalRef.current
  }) || new Map();

  if (wrappers.size < 1) {
    wrappers.set(selection, {
      wrapper: globalRef.current,
      originSelection: selection
    });
    return wrappers;
  }

  var res = new Map();
  wrappers.forEach(function (v, k) {
    res.set(k, _extends({}, v, {
      wrapper: v.wrapper || globalRef.current
    }));
  });
  return res;
}

/**
 * 计算选区应该分布的根节点
 *
 * A. 对于单个原始 selection
 * 1. 若为 collapsed，则返回值的 key 为该 selection，value 为它应渲染目标宿主节点 + originSelection
 * 2. 若为 expanded，则返回值 key 为该 selection 按需切割的子 selection，value 为其对应渲染的目标宿主节点 + originSelection
 *
 * B. remoteSelections 会分别将每一项按上面的规则分割并聚合到一个 Map 中
 *
 * @param controller Controller
 * @param globalWrapperRef 渲染在全局的根节点
 * @returns [local, remotes]: [SelectionWrapperMap, SelectionWrapperMap]
 */

function useSelectionWrappers(controller, globalWrapperRef) {
  var _controller$value = controller.value,
      remoteSelections = _controller$value.remoteSelections,
      selection = _controller$value.selection,
      document = _controller$value.document;
  var prevSelection = React__default.useRef(null);

  var _React$useState = React__default.useState([]),
      visibles = _React$useState[0],
      setVisibles = _React$useState[1];

  var getWrappersBySelection = React__default.useCallback(function (sel) {
    var wrappers = splitSelectionAndGetWrapper(controller, sel, globalWrapperRef);
    return wrappers;
  }, [document, controller]);
  var local = React__default.useMemo(function () {
    var isHideSelection = controller.query('isHideSelection', {
      selection: selection
    });
    var croppedSelection = getCroppedSelection(controller, selection, controller.visibleBlocks); // 不显示本地选区时 or 首次渲染 globalWrapperRef 仍为空时

    if (isHideSelection || !globalWrapperRef.current || !croppedSelection) {
      return new Map();
    }

    return getWrappersBySelection(croppedSelection); // 首次渲染出 globalWrapperRef 后，使其重新计算一下以得到选区 appearance
  }, [selection, document, controller, globalWrapperRef.current, visibles]);
  var remotes = React__default.useMemo(function () {
    var map = new Map();
    remoteSelections.forEach(function (sel) {
      var croppedSelection = getCroppedSelection(controller, sel, controller.visibleBlocks);

      if (croppedSelection) {
        var wrappers = getWrappersBySelection(croppedSelection);
        wrappers.forEach(function (v, key) {
          return map.set(key, v);
        });
      }
    });
    return map;
  }, [remoteSelections, document, controller, visibles]);
  React__default.useEffect(function () {
    prevSelection.current = selection;
  }, [selection, document]);
  React__default.useEffect(function () {
    var sub = controller.visibles$.subscribe(function (visibles) {
      setVisibles(visibles);
    });
    return function () {
      sub.unsubscribe();
    };
  }, [controller]);
  return [local, remotes];
}

var _createElement$6 = React__default.createElement;
var THROTTLE_TIME_RESIZE = 300;

var SelectionLayer = function SelectionLayer(props) {
  var controller = props.controller,
      contentRef = props.contentRef,
      scrollableContainerRef = props.scrollableContainerRef;
  var _controller$value = controller.value,
      composing = _controller$value.composing,
      isFocused = _controller$value.isFocused,
      selection = _controller$value.selection,
      document = _controller$value.document,
      injections = _controller$value.injections,
      decorations = _controller$value.decorations;
  var zoom = useZoom() || 1;

  var _React$useReducer = React__default.useReducer(function (c) {
    return c + 1;
  }, 0);
      _React$useReducer[0];
      var forceUpdate = _React$useReducer[1];

  var _React$useState = React__default.useState(0),
      resizeFlag = _React$useState[0],
      setResizeFlag = _React$useState[1];

  var globalWrapperRef = React__default.useRef(null);
  var isUnmountedRef = React__default.useRef(false); // 本地选区外观

  var _React$useState2 = React__default.useState(new Map()),
      local = _React$useState2[0],
      setLocal = _React$useState2[1]; // 远程选区外观


  var _React$useState3 = React__default.useState(new Map()),
      remotes = _React$useState3[0],
      setRemotes = _React$useState3[1];

  var localDepsRef = React__default.useRef({
    composing: composing,
    selection: selection,
    node: null
  });
  React__default.useEffect(function () {
    isUnmountedRef.current = false;
    return function () {
      isUnmountedRef.current = true;
    };
  }, []);
  React__default.useEffect(function () {
    if (!contentRef.current) {
      return undefined;
    }

    var resizeUpdator = throttle(function () {
      if (controller.shouldHideSelectionOnBlur() && controller.value.isBlurred) {
        return;
      }

      setResizeFlag(function (val) {
        return (val + 1) % 2;
      }); // 这里无需读取真实的 size 造成 reflow，只需要可以感知到变化即可
    }, THROTTLE_TIME_RESIZE);

    if (typeof ResizeObserver !== 'undefined') {
      var observer = new ResizeObserver(resizeUpdator);
      observer.observe(contentRef.current);
      return function () {
        resizeUpdator.cancel();

        if (contentRef.current) {
          observer.unobserve(contentRef.current);
        }
      };
    }

    window.addEventListener('resize', resizeUpdator);
    return function () {
      resizeUpdator.cancel();
      window.removeEventListener('resize', resizeUpdator);
    };
  }, []);
  React__default.useEffect(function () {
    localDepsRef.current.node = selection.isCollapsed ? document.getPreviousNode(selection.anchor.key) : null;
  }, [selection, document]);
  var shouldForceUpdate = React__default.useCallback(function (range) {
    if (equal(range, selection) && controller.value.composing === localDepsRef.current.composing) {
      // 仅 focus 发生变化时，需要及时 rerender 选区
      if (isFocused !== controller.value.isFocused) {
        return true;
      } // BACKGROUND: 在文本型链接的最后 delete 时，链接文字变少了，但选区不会发生变化
      // 所以需要在这种情况下 force re-render


      if (range.isCollapsed) {
        var prevNode = controller.value.document.getPreviousNode(range.anchor.key);

        if (!equal(prevNode, localDepsRef.current.node)) {
          return true;
        }
      }

      return false;
    }

    return true;
  }, [controller, isFocused, selection]);
  var selectionUpdator = React__default.useCallback(function (_ref) {
    var range = _ref.range;

    if (shouldForceUpdate(range)) {
      localDepsRef.current.composing = controller.value.composing;
      localDepsRef.current.selection = range;
      forceUpdate();
    }
  }, [controller, shouldForceUpdate]);
  var onHots = React__default.useCallback(function () {
    selectionUpdator({
      range: controller.value.selection
    });
  }, [controller, selectionUpdator]);
  var onInputingHots = React__default.useCallback(function () {
    // 保证节点完成渲染之后才计算和绘制选区
    Promise.resolve().then(onHots);
  }, [onHots]);
  useSelectionDataAtTheStartOfNextFrame(controller.selectionData$, null, selectionUpdator, []);
  useSelectingHotsAtTheStartOfNextFrame(controller, onHots);
  useInputingHots(controller, onInputingHots); // 根据本地选区变化滚动页面

  useScrollBySelection(scrollableContainerRef, contentRef, controller);
  useResumePosition(scrollableContainerRef, contentRef, controller); // 计算选区渲染所分布的根节点

  var _useSelectionWrappers = useSelectionWrappers(controller, globalWrapperRef),
      localWrappersMap = _useSelectionWrappers[0],
      remoteWrappersMap = _useSelectionWrappers[1]; // 选区需保证 node 渲染完成后再更新


  React__default.useLayoutEffect(function () {
    var appearance = getSelectionAppearance(localWrappersMap, zoom, false, contentRef, controller);
    setLocal(appearance);
  }, [localWrappersMap, composing, zoom, // BACKGROUND: https://aone.alibaba-inc.com/v2/project/897543/bug/41787750#
  isFocused, controller, resizeFlag, injections, decorations]);
  React__default.useLayoutEffect(function () {
    var appearance = getSelectionAppearance(remoteWrappersMap, zoom, true, contentRef, controller);
    setRemotes(appearance);
  }, [remoteWrappersMap, controller, zoom, isFocused, resizeFlag, document, injections, decorations]);
  return /*#__PURE__*/_createElement$6(SelectionSlot, {
    ref: globalWrapperRef,
    layerFor: "global"
  }, /*#__PURE__*/_createElement$6(SelectionRenderer, {
    appearances: local,
    isFocused: isFocused,
    controller: controller
  }), /*#__PURE__*/_createElement$6(SelectionRenderer, {
    appearances: remotes,
    isFocused: isFocused,
    controller: controller
  }));
};

function useCangjieKeyBindingRef(key) {
  var ref = React.useRef(null);

  var _ref = React.useContext(ControllerContext),
      controller = _ref.controller;

  React.useLayoutEffect(function () {
    if (!CONTROLLER_TO_KEY_DOM.has(controller)) {
      CONTROLLER_TO_KEY_DOM.set(controller, new Map());
    }

    var KEY_DOM = CONTROLLER_TO_KEY_DOM.get(controller);

    if (ref.current) {
      var dom = ReactDOM.findDOMNode(ref.current);
      KEY_DOM.set(key, dom);
    } else {
      KEY_DOM["delete"](key);
    }
  });
  return ref;
}

/**
 * 是否分组被折叠 
 * @param group 
 * @returns 
 */
function isGroupCollapsed(group) {
  return group.data[GROUP_COLLAPSED_KEY];
}
/**
 * 是否分组为空 
 * @param controller 
 * @param group 
 * @returns 
 */

function isGroupEmpty(controller, group) {
  var document = controller.value.document;
  var next = document.getNextSibling(group.key);

  if (next != null && next.isElement() && controller.query('isElementInGroup', next, group) !== false) {
    return false;
  }

  return true;
}

var groupUtils = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isGroupCollapsed: isGroupCollapsed,
  isGroupEmpty: isGroupEmpty
});

var _createElement$5 = React__default.createElement;
var blockStyle = {
  position: 'relative'
};

var inlineStyle = _extends({}, blockStyle, {
  display: 'inline-block',
  textIndent: 'initial',
  // 设置行高后，使void 节点的高度不变
  lineHeight: 'initial',
  maxWidth: '100%'
});

var voidStyle = _extends({}, inlineStyle);

var VoidInlineWrapper = function VoidInlineWrapper(_ref) {
  var attributes = _ref.attributes,
      children = _ref.children;
  return /*#__PURE__*/_createElement$5("span", _extends({
    "data-cangjie-void": true,
    style: voidStyle
  }, attributes), /*#__PURE__*/_createElement$5("span", {
    style: inlineStyle
  }, children));
};

var VoidBlockWrapper = function VoidBlockWrapper(_ref2) {
  var _seletableAttrs;

  var attributes = _ref2.attributes,
      node = _ref2.node,
      children = _ref2.children,
      controller = _ref2.controller,
      visible = _ref2.visible;
  var seletableAttrs = (_seletableAttrs = {}, _seletableAttrs[Selector.edgeSelectable] = true, _seletableAttrs); // @ts-ignore

  var fold = Block.isBlock(node) ? useUserData(node, 'fold') || false : false;
  var hidden = useGroupData(node, function (groups) {
    return groups.some(function (group) {
      return isGroupCollapsed(group) && group.key !== node.key;
    });
  }, fold); // 合并虚拟化的 visible 与 flattenGroup 的 visible

  var finalVisible = visible !== false && !hidden;
  var nodeStyle = useNodeStyle(controller, node, finalVisible);
  return /*#__PURE__*/_createElement$5("div", _extends({
    "data-cangjie-void": true,
    "data-block-uuid": node.data.uuid,
    style: nodeStyle
  }, attributes, seletableAttrs), children);
};

var VoidWrapper = function VoidWrapper(props) {
  var isBlock = Block.isBlock(props.node);
  return isBlock ? /*#__PURE__*/_createElement$5(VoidBlockWrapper, props) : /*#__PURE__*/_createElement$5(VoidInlineWrapper, props);
};

var _createElement$4 = React.createElement;

var LeafComponent = function LeafComponent(props) {
  var leafKey = props.leafKey,
      style = props.style,
      children = props.children;
  var ref = useCangjieKeyBindingRef(leafKey);
  return /*#__PURE__*/_createElement$4("span", {
    ref: ref,
    "data-cangjie-key": leafKey,
    "data-cangjie-leaf": true,
    "data-cangjie-mark": props['data-cangjie-mark'],
    style: style,
    "data-testid": leafKey
  }, children);
};

function replaceNodeIntoElement(origin, path, node) {
  // invalid path
  if (!path) {
    return origin;
  } // path 指向自身


  if (!path.length) {
    return node;
  }

  var nodes = origin.nodes;
  var offset = path[0];
  var target = node; // 递归找到目标位置

  if (path.length > 1) {
    var parent = nodes[offset];

    if (parent && parent.isElement()) {
      target = replaceNodeIntoElement(parent, path.slice(1), node);
    } else {
      target = parent;
    }
  } // 替换目标节点


  if (nodes[offset] && nodes[offset] !== target) {
    var next = nodes.slice(0);
    next[offset] = target;
    return origin.set('nodes', next);
  }

  return origin;
}

function useInputPending(elements, nodePath, controller, enablePending, pending$, updateElements) {
  var node = elements.node,
      document = elements.document; // 根据最新 node，使用 toView 局部重算 view node

  var pendingHandler = useCallback(function (data) {
    var textPath = data.startPath,
        startOffset = data.startOffset,
        textKey = data.key; // 判断当前编辑的 text 节点是否在 node 中

    var oldViewText = Block.isBlock(node) ? node.getNode(textKey) : null;

    if (Block.isBlock(node) && oldViewText) {
      // 获取最新 text 和缓存的 view data
      var text = controller.value.document.getNodeByPath(textPath);

      if (text && oldViewText) {
        var _node$getNodeByPath, _document$getNodeByPa;

        var viewData = controller.getViewData(oldViewText);
        var injections = viewData.injections; // 推算出新的 decorations

        var decorations = viewData.decorations.slice(0);
        decorations.forEach(function (d, i) {
          if (Decoration.isDecoration(d)) {
            var key = text.key;
            var start = d.start,
                end = d.end;

            if (start.key === key && end.key === key) {
              var delta = text.text.length - oldViewText.text.length;

              if (delta && startOffset <= start.offset) {
                // 在 decoration 前面增删文字
                var tmp = d.set('start', TextPoint.create({
                  key: key,
                  offset: start.offset + delta
                }));
                decorations[i] = tmp.set('end', TextPoint.create({
                  key: key,
                  offset: end.offset + delta
                }));
              } else if (delta && startOffset <= end.offset) {
                // 在 decoration 里面增删文字
                decorations[i] = d.set('end', TextPoint.create({
                  key: key,
                  offset: end.offset + delta
                }));
              }
            }
          }
        });
        var viewText = controller.toView(text, decorations, injections); // 替换 view node 中的 text 节点

        var rPath = textPath.slice(nodePath.length);

        if (((_node$getNodeByPath = node.getNodeByPath(rPath)) == null ? void 0 : _node$getNodeByPath.key) !== viewText.key) {
          rPath = node.getPath(viewText.key);
        }

        var viewNode = replaceNodeIntoElement(node, rPath, viewText); // 替换 view document 中的 node 节点

        var dPath = nodePath;

        if (((_document$getNodeByPa = document.getNodeByPath(dPath)) == null ? void 0 : _document$getNodeByPa.key) !== viewNode.key) {
          dPath = document.getPath(viewNode.key);
        }

        var documentView = replaceNodeIntoElement(document, dPath, viewNode);
        updateElements({
          node: viewNode,
          document: documentView
        });
      }
    }
  }, [controller, document, node, nodePath, updateElements]);
  useEffect(function () {
    // 只在 leaf block 监听 pending 流
    if (Block.isLeafBlock(node) && enablePending) {
      var sub = pending$.subscribe(pendingHandler);
      return function () {
        return sub.unsubscribe();
      };
    }

    return noop;
  }, [pending$, pendingHandler, node, enablePending]);
}

/**
 * 开启热区时，使用热区视图模型
 * @param controller
 * @param viewNode
 * @param viewDocument
 * @returns
 */

function useView(controller, viewNode, viewDocument, isSelected) {
  /**************************************************************************************\
  *                                                                                      *
  *                                                                                      *
  *         Render with hots$                                  Render with props         *
  *                                                                                      *
  *           +------------+                                     +------------+          *
  *           |    hot$    |                                     |   props    |          *
  *           |  +-------+ |                                     |            |          *
  *           |  |  hot  | |                                     | +--------+ |          *
  *           |  +-------+ |                                     | |document| |          *
  *           |  +-------+ |             .-------.               | +--------+ |          *
  *           |  |  hot  | |<--observe--( <Node/> )<---inject----|            |          *
  *           |  +-------+ |             `-------'               | +--------+ |          *
  *           |  +-------+ |                                     | |  node  | |          *
  *           |  |  hot  | |                                     | +--------+ |          *
  *           |  +-------+ |                                     |            |          *
  *           +------------+                                     +------------+          *
  *                  |                                                  |                *
  *                  |                                                  |                *
  *                  v                                                  v                *
  *            .-----------.                                      .-----------.          *
  *      +----( isViewHot?  )-----+                      +---Y---(  hasHots?   )--+      *
  *      N     `-----------'      Y                      |        `-----------'   |      *
  *      |                        |                      |                        |      *
  *      v                        v                      v                        |      *
  * +--------+            +--------------+         .-----------.                  |      *
  * |        |            |              |   +----(isInsideHot? )                 |      *
  * | silent |            |recalculateView|   |     `-----------'                  |      *
  * |        |            |              |   |           |                        |      *
  * +--------+            +--------------+   |           N                        N      *
  *                               |          Y           v                        |      *
  *                               v          |      +--------+                    |      *
  *                      +------------------+|      |        |                    |      *
  *                      | {node, document} ||      | silent |                    |      *
  *                      +------------------+|      |        |                    |      *
  *                                |         |      +--------+                    |      *
  *                                v         v                                    |      *
  *                             +------------------------+                        |      *
  *                             |                        |                        |      *
  *                             | render(node, document) |<-----------------------+      *
  *                             |                        |                               *
  *                             +------------------------+                               *
  *                                                                                      *
  \**************************************************************************************/
  var _useReducer = useReducer(function (c) {
    return !c;
  }, false),
      forceUpdate = _useReducer[1];

  var selectedRef = useRef(isSelected);
  var onHots = useCallback(function () {
    if (controller.isViewHot(viewNode)) {
      // 若正在框选节点，其选中态未发生变化，则不重渲
      if (controller.pendingType === PendingType.selection && controller.value.selection.isExpanded) {
        var prevSelected = selectedRef.current;

        var _controller$getView = controller.getView(viewNode, viewDocument, false),
            _node = _controller$getView.node,
            _document = _controller$getView.document;

        selectedRef.current = isSelectionInNode(_node, _document, controller.value.selection);

        if (prevSelected === selectedRef.current) {
          return;
        }
      }

      forceUpdate();
    }
  }, [controller, viewNode, viewDocument, isSelected, forceUpdate]);
  useHots(controller, onHots, undefined, !Block.isBlock(viewNode));

  if (!controller.hasHots()) {
    return {
      node: viewNode,
      document: viewDocument,
      isSelected: isSelected
    };
  }

  controller.removeIsSelected(viewNode.key); // 重渲时，若节点为热区节点，需要重算其视图模型

  if (controller.isViewHot(viewNode)) {
    var _controller$getView2 = controller.getView(viewNode, viewDocument, true),
        _node2 = _controller$getView2.node,
        _document2 = _controller$getView2.document;

    var selected = false;

    if (controller.pendingType === PendingType.input) {
      selected = true;
    } else if (controller.pendingType === PendingType.selection && controller.value.selection.isExpanded) {
      // 这种情况已经计算完成，直接使用缓存
      selected = selectedRef.current;
    } else {
      selected = isSelectionInNode(_node2, _document2, controller.value.selection);
    }

    selectedRef.current = selected;

    if (selected) {
      controller.addIsSelected(viewNode.key);
    }

    return {
      node: _node2,
      document: _document2,
      isSelected: selected
    };
  } // 重渲时，若节点非热区，则返回缓存的视图模型


  var _controller$getView3 = controller.getView(viewNode, viewDocument, false),
      node = _controller$getView3.node,
      document = _controller$getView3.document;

  selectedRef.current = isSelected;
  return {
    node: node,
    document: document,
    isSelected: isSelected
  };
}

var GroupWrapper = function GroupWrapper(props) {
  var children = props.children,
      node = props.node;
  var isCollapsed = useGroupData(node, function (groups) {
    var group = groups.find(function (g) {
      return g.key === node.key;
    });
    return group == null ? void 0 : group.data[GROUP_COLLAPSED_KEY];
  }, false);
  return /*#__PURE__*/React.cloneElement(children, {
    isCollapsed: isCollapsed
  });
};

var _createElement$3 = React.createElement;

function isComposingMark(_ref) {
  var type = _ref.type;
  return type === 'cangjieComposing';
}

function isNotComposingMark(mark) {
  return !isComposingMark(mark);
}

var checkRerenderNodesBySelectionChange = memoizeOne(function (prevSelection, selection, prevDocument, document) {
  var shouldRenderNodeKeys = new Set();

  var _selection$convertToT = selection.convertToTextPoints(document),
      start = _selection$convertToT.start,
      end = _selection$convertToT.end;

  var _prevSelection$conver = prevSelection.convertToTextPoints(document),
      prevStart = _prevSelection$conver.start,
      prevEnd = _prevSelection$conver.end;

  if (selection === prevSelection) {
    return shouldRenderNodeKeys;
  }

  if (start !== prevStart) {
    shouldRenderNodeKeys.add(start.key);
    var startAnchestors = document.getAncestors(start.key);
    startAnchestors.forEach(function (anchestor) {
      shouldRenderNodeKeys.add(anchestor.key);
    });
    shouldRenderNodeKeys.add(prevStart.key);
    var prevStartAnchestors = document.getAncestors(prevStart.key);
    prevStartAnchestors.forEach(function (anchestor) {
      shouldRenderNodeKeys.add(anchestor.key);
    });
  }

  if (end !== prevEnd) {
    shouldRenderNodeKeys.add(end.key);
    var endAnchestors = document.getAncestors(end.key);
    endAnchestors.forEach(function (anchestor) {
      shouldRenderNodeKeys.add(anchestor.key);
    });
    shouldRenderNodeKeys.add(prevEnd.key);
    var prevEndAnchestors = document.getAncestors(prevEnd.key);
    prevEndAnchestors.forEach(function (anchestor) {
      shouldRenderNodeKeys.add(anchestor.key);
    });
  }

  return shouldRenderNodeKeys;
}); // TODO: 等 selectionLayer 提到 content，修改这里的判断逻辑

function shouldComponentUpdate(prevProps, nextProps) {
  var _n$prevValue, _n$prevValue2;

  var controller = prevProps.controller;
  var shouldUpdate = controller.run('shouldNodeComponentUpdate', prevProps, nextProps);
  var n = nextProps;
  var p = prevProps;

  if (shouldUpdate !== null) {
    if (shouldUpdate) {
      return true;
    }

    if (process.env.NODE_ENV === 'development') {
      warning$1(shouldUpdate !== false, "Returning false in `shouldNodeComponentUpdate` does not disable Cangjie's internal `shouldComponentUpdate` logic. If you want to prevent updates, use React's `shouldComponentUpdate` instead.");
    }
  }

  if (n.node !== p.node) {
    return true;
  }

  if (n.visible !== p.visible) {
    return true;
  }

  var isSelectionPending = controller.pendingType === PendingType.selection; // 当存在 Hots & Pending 时，节点的重渲会存在两个诱因：
  // 1. 外部 Props 重渲
  // 2. 内部受 Hots & Pending 的控制重渲
  //
  // 假定节点树为：
  // ```tsx
  //   <value>
  //   <document>
  //     <block type="paragrah" key="p0">
  //       <block type="paragraph" key="hello">
  //         <text key="hello-text">Hello</text>
  //       </block>
  //       <block type="paragraph" key="world">
  //         <text key="world-text">World</text>
  //         <cursor />
  //       </block>
  //     </block>
  //     <block type="paragraph" key="p1">
  //       <block type="paragraph" key="cangjie">
  //         <text key="cangjie-text">Cangjie</text>
  //       </block>
  //     </block>
  //   </document>
  // </value>
  //```
  //
  // 1. 当光标从 `world-text` 移动到 `hello-text`：计算热区为 ['world', 'hello']，且开始选区 Pending
  //   1.1 Hots 驱动 `world` 组件树重渲：`world` 未选中
  //     * `world-text` 因为 props 变更而重渲 `prevProps.isSelected !== nextProps.isSelected`
  //   1.2 Hots 驱动 `hello` 组件树重渲：`hello` 选中
  //     * `hello-text` 因为 props 变更而重渲 `prevProps.isSelected !== nextProps.isSelected`
  //
  // 2. 当光标从 `hello-text` 移动到 `cangjie-text`：计算热区为 ['p0', 'p1']
  //    2.1 Hots 驱动 `p0` 组件树重渲：`p0` 节点树取消选中
  //      * `hello` 重渲，且 `prevProps.isSelected === nextProps.isSelectd === false`，但由于 `hello` 在 pending 期间被选中，因此 `hello` 应重渲以取消选中态
  //      * `hello` 组件树重渲...
  //    2.2 Hots 驱动 `p1` 组件树重渲：`p1` 节点树选中
  //      * `cangjie` 重渲，且 `prevProps.isSelectd !== nextProps.isSelected`，因此 `cangjie 重渲`
  //      * `cangjie` 组件树重渲..
  //

  if (isSelectionPending) {
    var pendingSelected = controller.getIsSelected(n.node.key);

    if (p.isSelected === n.isSelected) {
      return p.isSelected !== pendingSelected;
    }
  } // 1. 考虑节点树及其选中态为：
  // ```tsx
  // <value>
  //   <document>
  //     <block key="container" type="container" isSelected={true}>
  //       <block key="hello" type="paragraph" isSelected={true}>Hello</block>
  //       <block key="world" type="paragraph" isSelected={false}>World</block>
  //       <block key="cangjie" type="paragprah">Cangjie</block>
  //     </block>
  //   </document>
  // </value>
  // ```
  // 当选区从 `hello` 移动到 `world` 时，节点重渲的顺序为
  //   * `container` 因为选中态而重渲：为了保证其内部发生的选区变化也能响应，因此重渲 `container`
  //   * `hello` 选中态变化，重渲 `hello`
  //   * `world` 选中态变化，重渲 `world`
  //   * `cangjie` 选中态未变化，不重渲
  // ```tsx
  // <value>
  //   <document>
  //     <block key="container" type="container" isSelected={true}>
  //       <block key="hello" type="paragraph" isSelected={true}>Hello</block>
  //       <block key="world" type="paragraph">World</block>
  //       <block key="cangjie" type="paragraph">Cangjie</block>
  //     </block>
  //   </document>
  // </value>
  // ```
  // 
  // 2. 考虑节点树及其选中态为：
  // ```tsx
  // <value>
  //   <document>
  //     <block key="container1" type="container" isSelected={true}>
  //       <block key="hello" type="paragraph" isSelected={true}>Hello</block>
  //       <block key="world" type="paragraph"}>World</block>
  //     </block>
  //     <block key="container2" type="container">
  //       <block key="cangjie" type="paragraph">Cangjie</block>
  //     </block>
  //   </document>
  // </value>
  // ```
  // 当选区从 `container1` 移动到 `cangjie` 时，节点重渲的顺序为
  //   * `container1` 因为要取消选中而重渲：为了保证取消选中后，其内部节点的选中态也能取消，因此重渲 `container1`
  //     * `hello` 选中态变化，重渲 `hello`
  //     * `world` 选中态未变化，不重渲 `world`
  //   * `container2` 因为选中态变化重渲：为了保证其内部发生的选区变化也能响应，因此重渲 `container`
  //     * `cangjie` 因为选中态变化而重渲
  // ```tsx
  // <value>
  //   <document>
  //     <block key="container" type="container" isSelected={true}>
  //       <block key="hello" type="paragraph" isSelected={true}>Hello</block>
  //       <block key="world" type="paragraph" isSelected={false}>World</block>
  //       <block key="cangjie" type="paragprah">Cangjie</block>
  //     </block>
  //   </document>
  // </value>
  // ```


  if ((_n$prevValue = n.prevValue) != null && _n$prevValue.selection) {
    var shouldRenderSets = checkRerenderNodesBySelectionChange(n.prevValue.selection, n.value.selection, p.document, n.document);

    if (shouldRenderSets.has(n.node.key)) {
      return true;
    }
  }

  if (((_n$prevValue2 = n.prevValue) == null ? void 0 : _n$prevValue2.isFocused) !== n.value.isFocused) {
    return n.isSelected !== p.isSelected || n.isSelected || p.isSelected;
  }

  return n.isSelected !== p.isSelected;
}

function renderLeaves(parent, node, controller) {
  var value = controller.value;
  var composing = value.composing;
  var leaves = node.leaves;
  var ls = [];
  var nextStartOffset = 0;

  for (var i = 0; i < leaves.length; i += 1) {
    var leaf = leaves[i];
    var startOffset = nextStartOffset;
    nextStartOffset += leaf.text.length;
    var hasComposingMark = leaf.marks.some(isComposingMark);
    var text = leaf.text || CANGJIE_EMPTY;
    var children = [hasComposingMark ? /*#__PURE__*/_createElement$3("u", {
      "data-cangjie-composing": true
    }, text) : text];

    if (composing) {
      var marks = leaf.marks.filter(isNotComposingMark);

      while (i + 1 < leaves.length) {
        var nextLeaf = leaves[i + 1];
        var nextHasComposingMark = nextLeaf.marks.some(isComposingMark);
        var marksWithoutComposing = nextHasComposingMark ? nextLeaf.marks.filter(isNotComposingMark) : nextLeaf.marks;

        if (!equal(marks, marksWithoutComposing)) {
          break;
        }

        i += 1;
        nextStartOffset += nextLeaf.text.length;
        children.push(nextHasComposingMark ? /*#__PURE__*/_createElement$3("u", {
          "data-cangjie-composing": true
        }, nextLeaf.text) : nextLeaf.text);
      }
    }

    ls.push(renderLeaf(controller, parent, node, leaf, /*#__PURE__*/_createElement$3(React.Fragment, null, children), startOffset));
  }

  return ls;
}

var NodeComponent = /*#__PURE__*/React.memo(function (props) {
  var _binding;

  var controller = props.controller,
      parent = props.parent,
      path = props.path,
      composing = props.composing,
      prevValue = props.prevValue,
      _props$visible = props.visible,
      visible = _props$visible === void 0 ? true : _props$visible;
  var value = controller.value,
      enablePending = controller.enablePending,
      virtualizeManager = controller.virtualizeManager;
  var selection = value.selection;
  var node = props.node,
      document = props.document;
  var ref = useCangjieKeyBindingRef(node.key);

  var _React$useState = React.useState({
    document: document,
    node: node
  }),
      pendingElements = _React$useState[0],
      updatePendingElements = _React$useState[1]; // @ts-ignore


  var fold = Block.isBlock(node) ? useUserData(node, 'fold') || false : false;
  var hidden = useGroupData(node, function (groups) {
    return groups.some(function (group) {
      return isGroupCollapsed(group) && group.key !== node.key;
    });
  }, fold);
  var finalVisible = visible !== false && !hidden;

  var _useView = useView(controller, node, document, props.isSelected),
      view = _useView.node,
      viewDocument = _useView.document,
      isSelected = _useView.isSelected;

  var inputData$ = controller.inputData$; // 监听输入缓冲数据流

  useInputPending({
    node: node,
    document: document
  }, path, controller, enablePending.input, inputData$, updatePendingElements);

  if (controller.enableVirtualize && virtualizeManager) {
    var virtualizeNodeManager = virtualizeManager.nodeManager;

    var _path = document.getPath(node.key);

    if (_path) {
      var topPath = _path.slice(0, 1);

      var topBlock = document.getNodeByPath(topPath); // 是顶层节点

      if (node === topBlock) {
        var virtualizePersistState = virtualizeNodeManager.getVirtualizePersistState(topBlock.key);
        virtualizePersistState.forEach(function (childNodeKey) {
          var childNode = document.getNode(childNodeKey);

          if (topBlock.hasNode(childNodeKey) && childNode && controller.query('shouldPersistState', {
            node: childNode
          })) {
            virtualizeNodeManager.updateVirtualizePersistState(childNodeKey, topBlock.key, true);
          } else {
            virtualizeNodeManager.updateVirtualizePersistState(childNodeKey, topBlock.key, false);
          }
        });
      }

      var shouldPersistState = controller.query('shouldPersistState', {
        node: node
      });

      if (shouldPersistState) {
        virtualizeNodeManager.updateVirtualizePersistState(node.key, topBlock.key, true);
      }
    }
  } // 输入缓冲开始，使用 pending node


  if (Block.isLeafBlock(props.node) && controller.isPending && controller.pendingType === PendingType.input) {
    node = pendingElements.node;
    document = pendingElements.document;
  } // 如果使用热区技术，使用热区重算的模型


  if (controller.enableHots) {
    node = view;
    document = viewDocument;
  }

  var blockStyle = useNodeStyle(controller, node, finalVisible);

  var children = function children() {
    var n = node.toSubType();

    if (n.isElement()) {
      var childrenIsSelected = getChildrenIsSelected(document, n, selection);
      var renderedChildren = n.nodes.map(function (n, i) {
        return renderNode(controller, value, document, node, n, path.concat(i), childrenIsSelected[i], finalVisible, prevValue);
      });
      return renderedChildren;
    }

    return renderLeaves(parent, n, controller);
  };

  if (Text$1.isText(node)) {
    if (process.env.NODE_ENV === 'test') {
      // 服务于 Test 环境下对 text 渲染的监听
      controller.run('renderText', {
        node: node
      });
    }

    return /*#__PURE__*/_createElement$3(React.Fragment, null, children());
  }

  var isVoid = controller.query('isVoid', node);
  var isNonEmptyBlock = Block.isBlock(node) && !!node.nodes.length;
  var isLeafBlock = isNonEmptyBlock && Block.isLeafBlock(node);
  var isSelectable = isNonEmptyBlock && controller.query('isEdgeSelectable', node);
  var binding = (_binding = {
    ref: ref
  }, _binding[Selector.key] = node.key, _binding);
  var attributes = {
    key: node.key
  };

  var attributesWithBinding = _extends({}, attributes, binding);

  var nonVoidAttributes = attributesWithBinding;

  if (isLeafBlock) {
    var _extends2;

    nonVoidAttributes = _extends({}, nonVoidAttributes, (_extends2 = {
      style: blockStyle
    }, _extends2[Selector.leafBlock] = true, _extends2[Selector.uuid] = controller.query('anchor', node), _extends2));
  }

  if (isSelectable) {
    var _extends3;

    nonVoidAttributes = _extends({}, nonVoidAttributes, (_extends3 = {
      style: blockStyle
    }, _extends3[Selector.uuid] = controller.query('anchor', node), _extends3[Selector.edgeSelectable] = true, _extends3));
  }

  var element = controller.run('renderNode', {
    controller: controller,
    attributes: isVoid ? attributes : nonVoidAttributes,
    composing: composing,
    isSelected: isSelected,
    parent: parent,
    node: node,
    path: path,
    children: children,
    visible: finalVisible
  });

  if (element === null) {
    return null;
  }

  if (isVoid) {
    return /*#__PURE__*/_createElement$3(VoidWrapper, _extends({}, props, {
      attributes: attributesWithBinding
    }), element);
  }

  if (node.isElement()) {
    var group = controller.groupManager.getGroup(node.key);

    if (group) {
      var _attributes;

      var _props = {
        controller: controller,
        node: node,
        path: path,
        group: group,
        isCollapsed: false,
        isEmpty: isGroupEmpty(controller, _extends({}, group, {
          key: node.key
        })),
        attributes: (_attributes = {}, _attributes[Selector.groupKey] = node.key, _attributes),
        children: function children() {
          return element;
        },
        visible: finalVisible
      };
      var groupElement = controller.run('renderGroup', _props);

      if (groupElement) {
        return /*#__PURE__*/_createElement$3(GroupWrapper, {
          node: node
        }, groupElement);
      }
    }
  }

  return element;
}, function (prevProps, nextProps) {
  return !shouldComponentUpdate(prevProps, nextProps);
});

function renderLeaf(controller, parent, text, leaf, child, offset) {
  var composing = controller.value.composing;
  var leafKey = text.key + ":" + offset;

  var initialChild = /*#__PURE__*/_createElement$3(LeafComponent, {
    key: leafKey,
    leafKey: leafKey
  }, child);

  var children = leaf.marks.reduce(function (child, mark) {
    return controller.run('renderMark', {
      parent: parent,
      node: text,
      offset: offset,
      composing: composing,
      mark: mark,
      marks: leaf.marks,
      text: leaf.text,
      children: function children() {
        return child;
      }
    });
  }, initialChild);
  return children;
}

function renderNode(controller, value, document, parent, node, path, isSelected, visible, prevValue) {
  if (visible === void 0) {
    visible = true;
  }

  var composing = value.composing;

  var comp = /*#__PURE__*/_createElement$3(NodeComponent, {
    key: node.key,
    controller: controller,
    value: value,
    document: document,
    parent: parent,
    node: node,
    path: path,
    composing: composing,
    isSelected: isSelected,
    visible: visible,
    prevValue: prevValue
  });

  return comp;
}

var _createElement$2 = React__default.createElement;
var VirtualizePlaceholder = function VirtualizePlaceholder(props) {
  var _props$height = props.height,
      height = _props$height === void 0 ? 0 : _props$height;
  return /*#__PURE__*/_createElement$2("div", {
    "data-cangjie-virualize-placeholder": true,
    style: {
      height: height
    }
  });
};

function useVirtualize(controller, containerRef, getScrollableContainer) {
  var virtualizeManager = controller.virtualizeManager,
      enableVirtualizeView = controller.enableVirtualizeView;

  var _useState = useState(0),
      virtualizeId = _useState[0],
      setVirtualizeId = _useState[1];

  useEffect(function () {
    if (!virtualizeManager) {
      return;
    }

    if (enableVirtualizeView) {
      virtualizeManager.initView({
        scrollContainer: getScrollableContainer(),
        editorContainer: containerRef.current,
        triggerViewUpdate: setVirtualizeId
      });
      virtualizeManager.start();
    } else {
      virtualizeManager.stop();
    }

    return;
  }, [enableVirtualizeView, virtualizeManager]);

  if (!enableVirtualizeView || !virtualizeManager) {
    return null;
  }

  var outputManager = virtualizeManager.outputManager;
  var beforePlaceholderHeight = outputManager.beforePlaceholderHeight,
      afterPlaceholderHeight = outputManager.afterPlaceholderHeight,
      visibles = outputManager.visibles;
  var virtualizeResult = {
    virtualizeId: typeof virtualizeManager.virtualizeId === 'number' ? virtualizeManager.virtualizeId : virtualizeId,
    beforePlaceholderHeight: beforePlaceholderHeight,
    afterPlaceholderHeight: afterPlaceholderHeight,
    visibles: visibles
  };
  return [virtualizeResult, setVirtualizeId];
}

var _createElement$1 = React.createElement;

var arePropsEqual = function arePropsEqual(prevProps, nextProps) {
  var prevSelection = prevProps.selection,
      prevView = prevProps.document,
      prevIsFocused = prevProps.isFocused;
  var nextSelection = nextProps.selection,
      nextView = nextProps.document,
      nextIsFocused = nextProps.isFocused,
      controller = nextProps.controller; // 有热区时，不更新，内容交给节点子树自行更新

  if (controller.hasHots()) {
    return true;
  }

  return equal(prevSelection, nextSelection) && prevView === nextView && prevIsFocused === nextIsFocused;
};

var EditableContent = /*#__PURE__*/React.memo(function (props) {
  var controller = props.controller,
      ref = props.contentRef,
      getScrollableContainer = props.getScrollableContainer,
      selection = props.selection,
      document = props.document;
  var value = controller.value;
  var prevValue = React.useRef();
  React.useEffect(function () {
    prevValue.current = value;
  }, [value]);
  var childrenIsSelected = getChildrenIsSelected(document, document, selection);
  var editableRef = useCangjieKeyBindingRef(props[Selector.key]); // HACK: use `useCombinedRefs` will break `useCangjieKeyBindingRef`.

  React.useLayoutEffect(function () {
    if (!ref) {
      return;
    }

    if (typeof ref === 'function') {
      ref(editableRef.current);
    } else {
      ref.current = editableRef.current;
    }
  });
  var useVirtualizeResult = useVirtualize(controller, editableRef, getScrollableContainer);

  var _ref = useVirtualizeResult ? useVirtualizeResult[0] : {},
      _ref$virtualizeId = _ref.virtualizeId,
      virtualizeId = _ref$virtualizeId === void 0 ? -1 : _ref$virtualizeId,
      _ref$beforePlaceholde = _ref.beforePlaceholderHeight,
      beforePlaceholderHeight = _ref$beforePlaceholde === void 0 ? 0 : _ref$beforePlaceholde,
      _ref$afterPlaceholder = _ref.afterPlaceholderHeight,
      afterPlaceholderHeight = _ref$afterPlaceholder === void 0 ? 0 : _ref$afterPlaceholder,
      _ref$visibles = _ref.visibles,
      visibles = _ref$visibles === void 0 ? null : _ref$visibles;

  var virtualizeAttr = React.useMemo(function () {
    return controller.enableVirtualize ? {
      "data-virtualize-id": virtualizeId
    } : {};
  }, [controller.enableVirtualize, virtualizeId]); // 因为任何原因拿不到虚拟化结果，走非虚拟化分支

  if (useVirtualizeResult === null || virtualizeId === -1) {
    var _children = document.nodes.map(function (child, index) {
      return renderNode(controller, value, document, document, child, [index], childrenIsSelected[index], true, prevValue.current);
    });

    return /*#__PURE__*/_createElement$1(React.Fragment, null, /*#__PURE__*/_createElement$1("div", {
      ref: editableRef,
      "data-cangjie-key": document.key,
      "data-cangjie-editable": true
    }, _children));
  }

  var _ref2 = visibles,
      blockFinalVisibleStates = _ref2.blockFinalVisibleStates;
  var children = document.nodes.map(function (child, index) {
    var blockFinalVisibleState = blockFinalVisibleStates[index];
    var visible = blockFinalVisibleState === 'show';

    if (blockFinalVisibleState === 'destroy') {
      return null;
    }

    return renderNode(controller, value, document, document, child, [index], childrenIsSelected[index], visible, prevValue.current);
  });
  return /*#__PURE__*/_createElement$1(React.Fragment, null, /*#__PURE__*/_createElement$1("div", _extends({
    ref: editableRef,
    "data-cangjie-key": document.key,
    "data-cangjie-editable": true
  }, virtualizeAttr), controller.enableVirtualize ? /*#__PURE__*/_createElement$1(VirtualizePlaceholder, {
    height: beforePlaceholderHeight
  }) : null, children, controller.enableVirtualize ? /*#__PURE__*/_createElement$1(VirtualizePlaceholder, {
    height: afterPlaceholderHeight
  }) : null));
}, arePropsEqual);

/* eslint-disable @typescript-eslint/consistent-type-definitions */

var FOCUS_SCROLL_DELAY = 300; // 移动端弹键盘时，等待 visual viewport change 的最大时间

var MAX_VIEWPORT_WAIT_TIME = 3000;

/**
 * 移动端处理「点击后，滚动视口到光标」的逻辑
 * 这里需要等待键盘弹出后，才能计算跳转，因此依赖了 visual viewbox
 * 如果不支持 visual viewbox，就用 setTimeout
 */
function useClickToScroll() {
  var scrollerRef = React__default.useRef(null); // resize 事件发生。这里看如果有 scrollerRef，就开始滚动

  var handleResize = React__default.useCallback(function () {
    if (scrollerRef.current) {
      var _scrollerRef$current = scrollerRef.current,
          callback = _scrollerRef$current.callback,
          waitTimer = _scrollerRef$current.waitTimer;
      callback();
      clearTimeout(waitTimer);
      scrollerRef.current = null;
    }
  }, []); // 注册 visual box 事件

  React__default.useEffect(function () {
    if (!window.visualViewport) {
      return undefined;
    }

    window.visualViewport.addEventListener('resize', handleResize);
    return function () {
      window.visualViewport.removeEventListener('resize', handleResize);
    };
  }, [handleResize]);
  var scheduler = React__default.useCallback(function (callback) {
    if (scrollerRef.current) {
      clearTimeout(scrollerRef.current.waitTimer);
    }

    if (window.visualViewport) {
      // 如果支持 visualViewport 就开始检测 size 变化
      var fallbackCall = function fallbackCall() {
        scrollerRef.current = null;
      };

      var waitTimer = setTimeout(fallbackCall, MAX_VIEWPORT_WAIT_TIME);
      scrollerRef.current = {
        callback: callback,
        waitTimer: waitTimer
      };
    } else {
      // 不支持的话，就用 setTimeout
      setTimeout(callback, FOCUS_SCROLL_DELAY);
    }
  }, []);
  return scheduler;
}

var ScrollableContentContext = /*#__PURE__*/createContext(null);
/**
 * 滚动内容，默认是body
 */

function useScrollableContent() {
  return useContext(ScrollableContentContext);
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var _createElement = React__default.createElement;
var EVENT_HANDLERS = ['onDrop', 'onMouseMove'];
var editorStyle = {
  position: 'relative',
  whiteSpace: 'pre-wrap',
  wordWrap: 'break-word',
  cursor: 'text',
  userSelect: 'none',
  WebkitUserSelect: 'none',
  WebkitTapHighlightColor: 'transparent'
};
var CLIPBOARD_IDENTIFIER = '<article class="4ever-article" data-clipboard-cangjie';

function useWindowEvent(type, handler) {
  React__default.useEffect(function () {
    window.addEventListener(type, handler);
    return function () {
      return window.removeEventListener(type, handler);
    };
  }, [handler, type]);
}

// 多编辑器实例需要共享
var touchStartFlag = false;
/**
 * 是否 Event 不需要被拦截
 * @param target
 */

function isNotEditable(target) {
  var el;

  try {
    // COMPAT: 兼容在某些 Firefox 下，target 无法获取 `.closet()` 方法导致 crash
    if (target.nodeType === 8) {
      return true;
    } // COMPAT: 如果 event target 是 Text Node，则判断其父节点


    el = target.nodeType === 3 ? target.parentNode : target;
  } catch (err) {
    return true;
  }

  return !el || findClosestInContent(el, "[" + Selector.notEditable + "]");
}
/**
 * target 是否一个 Input 或者 TextArea
 */


function isInputTarget(target) {
  return target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement;
}

function useCombinedRefs() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }

  var targetRef = React__default.useRef();
  React__default.useLayoutEffect(function () {
    refs.forEach(function (ref) {
      if (!ref) return;

      if (typeof ref === 'function') {
        ref(targetRef.current);
      } else {
        ref.current = targetRef.current;
      }
    });
  }, [refs]);
  return targetRef;
} // 避免没有意义的复制、剪切


var isValidCopyOrCut = function isValidCopyOrCut(controller) {
  var _controller$value = controller.value,
      selection = _controller$value.selection,
      document = _controller$value.document;

  if (selection.isExpanded) {
    return true;
  }

  var node = document.getParent(selection.focus.key);

  if (!node) {
    return false;
  }

  var isVoid = controller.query('isVoid', node);
  return Boolean(isVoid);
};

var _ref = /*#__PURE__*/_createElement("div", {
  "data-cangjie-hidden": true,
  "data-cangjie-zoomer": true
});

var Content = /*#__PURE__*/React__default.forwardRef(function (props, ref) {
  var _textareaKeys, _extends3;

  var containerRef = React__default.useRef(null);
  var combinedContainerRef = useCombinedRefs(containerRef, ref);
  var contentRef = React__default.useRef(null);
  var scrollableContainerRef = React__default.useRef(null);
  var textareaRef = React__default.useRef(null);
  var prevWindowHeight = React__default.useRef(window.innerHeight);
  var prevWindowWidth = React__default.useRef(window.innerWidth);

  var _React$useState = React__default.useState(false),
      isTextareaDisabled = _React$useState[0],
      setIsTextareaDisabled = _React$useState[1];

  var controller = useController();
  var readOnly = controller.readOnly,
      value = controller.value,
      autoFocus = controller.autoFocus;
  var docStyle = useContentStyle(controller);
  var selection = value.selection,
      isFocused = value.isFocused;
  var document = controller.view;
  var className = props.className,
      _props$tagName = props.tagName,
      Container = _props$tagName === void 0 ? 'div' : _props$tagName,
      _props$tabIndex = props.tabIndex,
      tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex,
      _props$zoom = props.zoom,
      zoom = _props$zoom === void 0 ? 1 : _props$zoom,
      _props$style = props.style,
      customStyle = _props$style === void 0 ? {} : _props$style,
      defaultStyle = props.defaultStyle,
      _props$getScrollableC = props.getScrollableContainer,
      getScrollableContainer = _props$getScrollableC === void 0 ? function () {
    return window;
  } : _props$getScrollableC;
  var handlers = EVENT_HANDLERS.reduce(function (hdls, type) {
    var _extends2;

    return _extends({}, hdls, (_extends2 = {}, _extends2[type] = function (event) {
      return controller.run(type, event);
    }, _extends2));
  }, {}); // CSS transform只允许内部设置，禁止外部设置

  var zoomStyle = {};

  if (typeof zoom === 'number' && zoom !== 1) {
    zoomStyle = {
      transform: "scale(" + zoom + ")",
      transformOrigin: '0 0'
    };
  } // 移动端的 textarea focus 会触发视图的滚动，且 preventScroll not working，在 readonly 模式下禁止 focus
  // TODO: 关于 textarea 的滚动控制可以参考 Google Docs 的 iframe 方案


  var disableNativeFocus = readOnly && IS_MOBILE;
  var selectionCalculator = useSelectionCalculator(controller, textareaRef, scrollableContainerRef);
  var inputDetector = useInputDetector(controller, textareaRef);

  var handleClickToFocus = function handleClickToFocus(event) {
    if (isNotEditable(event.target) && event.target === window.document.activeElement) {
      // 不干扰节点自己的 focus 逻辑
      return;
    }

    if (!readOnly) {
      controller.run('onCangjieFocus');
    }

    var textarea = textareaRef.current;

    if (controller.value.isFocused && !disableNativeFocus) {
      // HACK: `.focus` only works in mouse event handler on mobile.
      textarea == null ? void 0 : textarea.focus({
        preventScroll: true
      });
    }

    controller.run('onClick', event);
  };

  var handleMouseDown = function handleMouseDown(event) {
    if (isNotEditable(event.target)) return;
    controller.run('onMouseDown', event);

    if (!event.defaultPrevented) {
      event.preventDefault();
      inputDetector.onCompositionEnd();
      selectionCalculator.onSelectStart(event);
      selectionCalculator.onMultipleClick(event);
    }
  };

  var handleMouseUp = function handleMouseUp(event) {
    if (isNotEditable(event.target)) return;
    controller.run('onMouseUp', event);
  };

  var handleKeyDown = function handleKeyDown(event) {
    if (isNotEditable(event.target)) return;

    if (!readOnly) {
      if (controller.value.composing) {
        controller.perfStart({
          type: PerfType.composing
        });
      } else if (controller.pendingType === PendingType.input) {
        var payload = hotkeys.isDeleteBackward(event) || hotkeys.isDeleteForward(event) ? {
          type: PerfType.input,
          subtype: 'delete'
        } : {
          type: PerfType.input
        };
        controller.perfStart(payload);
      }

      var shouldContinue = inputDetector.onKeyDown(event);

      if (shouldContinue === false) {
        return;
      } // 目前许多的编辑行为在 onKeyDown 事件中，所以暂时禁止掉
      // TODO: 将编辑行为的 onKeyDown 事件和选区交互行为分离 @展炤


      controller.run('onKeyDown', event);
    }

    if (!event.defaultPrevented) {
      selectionCalculator.onKeyDown(event);
    }
  };

  var handleKeyUp = function handleKeyUp(event) {
    if (isNotEditable(event.target)) return;
    selectionCalculator.onKeyUp(event);
    controller.run('onKeyUp', event);
  };

  var handleTouchStart = function handleTouchStart(event) {
    if (isNotEditable(event.target)) return;
    selectionCalculator.onTapHoldStart(event);
    controller.run('onTouchStart', event);
  };

  var handleTouchMove = function handleTouchMove(event) {
    if (isNotEditable(event.target)) return;
    selectionCalculator.onTapHoldEnd();
    controller.run('onTouchMove', event);
  };

  var handleTouchEnd = function handleTouchEnd(event) {
    if (isNotEditable(event.target)) return;
    selectionCalculator.onTapHoldEnd();
    controller.run('onTouchEnd', event);
  };

  var handleTouchStartCapture = function handleTouchStartCapture() {
    touchStartFlag = true;
  };

  var handleTouchEndCapture = function handleTouchEndCapture() {
    touchStartFlag = false;
  };

  var handleContextMenu = function handleContextMenu(event) {
    if (isNotEditable(event.target) || isInputTarget(event.target)) {
      return;
    }

    var isCollapsed = controller.value.selection.isCollapsed;

    if (!readOnly) {
      controller.run('onCangjieFocus');
    }

    if (isCollapsed) {
      controller.run('onClick', event);
    }

    controller.run('onContextMenu', event);
  };

  var handleDragStart = function handleDragStart(event) {
    if (isNotEditable(event.target)) return;
    controller.run('onDragStart', event);
  };

  var handleDragOver = function handleDragOver(event) {
    // PERF: just allow drop
    if (!event.defaultPrevented) {
      event.preventDefault();
    }
  };

  var handleDrop = function handleDrop(event) {
    if (isNotEditable(event.target)) return;
    controller.run('onDrop', event);
  };

  var handleDragEnter = function handleDragEnter(event) {
    if (isNotEditable(event.target)) return;
    controller.run('onDragEnter', event);
  };

  var handleCopy = React__default.useCallback(function (event) {
    if (!isValidCopyOrCut(controller)) {
      event.preventDefault();
      return;
    }

    controller.run('onCopy', event);
  }, [controller]);
  var handleCut = React__default.useCallback(function (event) {
    if (!isValidCopyOrCut(controller)) {
      event.preventDefault();
      return;
    }

    controller.run('onCut', event);
  }, [controller]);
  var scheduleScroll = useClickToScroll();
  var handleFocus = React__default.useCallback(function () {
    controller.run('onCangjieFocus'); // BACKGROUND:
    //   Android 中，点击非工具栏区域 blur 后，再 focus 回编辑器
    //   会出现 textarea.value === ' ' && textarea.selectionStart === 0 的情况
    //   导致无法删除文字，输入文字后会吞掉光标前一个字
    // 所以必须要在 focus 时 reset，而不是 blur 时

    inputDetector.reset(); // Should reset `textarea` to **EMPTY**.

    if (!IS_MOBILE) {
      return;
    }

    var scrollToCaret = function scrollToCaret() {
      var currentSelection = controller.value.selection;

      if (!currentSelection || !containerRef.current || !scrollableContainerRef.current || readOnly) {
        return;
      }

      scrollToSelection(currentSelection, containerRef.current, scrollableContainerRef.current, controller);
    };

    scheduleScroll(scrollToCaret);
  }, [controller, inputDetector, readOnly, scheduleScroll]);

  var handleBlur = function handleBlur() {
    var textarea = textareaRef.current;

    if (touchStartFlag && textarea) {
      textarea.focus({
        preventScroll: true
      });
      touchStartFlag = false;
      return;
    } // 此处是浏览器 bug，blur 时没有触发 compositionend，要手动触发
    // https://w3c.github.io/uievents/#compositionend
    // 由于 disabled 会导致切换应用后无法自动 focus
    // 所以只在 composing 期间才执行 compositionEnd


    if (value.composing) {
      triggerCompositionEnd();
    } // 只读模式下，如果用户在同页面点了其它内容，则先取消选区


    if (readOnly && window.document.activeElement !== textarea) {
      var newSelection = controller.value.selection.moveToFocus();
      controller.run('onCangjieSelect', CangjieSelectEvent({
        selection: newSelection
      }));
    }

    controller.run('onCangjieBlur');
  }; // 安卓下通过返回键/收起键 收起的键盘，不会触发失焦，再点击也不会触发focus
  // 不过失焦触发的键盘收起仍然能通过 iOS 逻辑 handle
  // 其余只能通过 resize 事件监听键盘的弹起
  // 安卓下分屏模式、折叠屏机很常见，也经常横竖屏切换，很大程度不能保证 resize 是键盘引发
  // 符合以下两个条件再触发滚动最大程度保证行为符合用户预期：
  // 1、resize 只是高度发生减小宽度未变 2、之前光标在视野内，resize 后不在视野内了


  var handleWindowResize = function handleWindowResize() {
    var _controller$value2 = controller.value,
        rs = _controller$value2.selection,
        isBlurred = _controller$value2.isBlurred;

    if (isBlurred || !rs || !containerRef.current || !scrollableContainerRef.current) {
      return;
    }

    var height = window.innerHeight;
    var width = window.innerWidth;
    var previousHeight = prevWindowHeight.current;
    var previousWidth = prevWindowWidth.current;
    prevWindowHeight.current = height;
    prevWindowWidth.current = width;

    if (!IS_ANDROID || height >= previousHeight || previousWidth !== width) {
      return;
    }

    var rect = getDOMRectFromSelection(rs, containerRef.current, controller);

    if (!rect) {
      return;
    }

    if (rect.top < previousHeight && rect.bottom >= height) {
      scrollToSelection(rs, containerRef.current, scrollableContainerRef.current, controller);
    }
  }; // 设置 disabled 并异步取消 disabled 以取消 composing
  // 不能用 Promose.resolve() micro task 方式，会导致多编辑器互相切换时异常


  var triggerCompositionEnd = React__default.useCallback(function () {
    setIsTextareaDisabled(true);
    setTimeout(function () {
      setIsTextareaDisabled(false);
    });
    inputDetector.onCompositionEnd();
  }, [inputDetector]);
  useWindowEvent('resize', handleWindowResize);
  React__default.useLayoutEffect(function () {
    var textarea = textareaRef.current;

    if (!textarea) {
      return;
    }

    var isNativeFocused = window.document.activeElement === textarea;
    var isFocusedNow = controller.value.isFocused;

    if (isFocusedNow && !isNativeFocused && !disableNativeFocus) {
      textarea.focus({
        preventScroll: true
      });
    }

    if (!isFocused && isNativeFocused && window.document.hasFocus()) {
      textarea.blur();
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [isFocused]);
  React__default.useLayoutEffect(function () {
    if (containerRef.current) {
      ROOT_TO_CONTROLLER.set(containerRef.current, controller);
    }
  }, [controller]);
  React__default.useLayoutEffect(function () {
    if (!scrollableContainerRef.current) {
      scrollableContainerRef.current = getScrollableContainer();
      controller.scrollableContainer = scrollableContainerRef.current;
    }
  });
  React__default.useEffect(function () {
    return function () {
      if (containerRef.current && ROOT_TO_CONTROLLER.has(containerRef.current)) {
        ROOT_TO_CONTROLLER["delete"](containerRef.current);
      }
    };
  }, []); // 移动端只读场景下，无法监听到键盘事件，因此这里将事件绑定在 document 上
  // Ref: https://aone.alibaba-inc.com/v2/project/897543/bug/45864425#

  var isReadMode = Boolean(readOnly || controller.query('isQuickPreview'));
  React__default.useEffect(function () {
    var handleReadOnlyKeyDown = function handleReadOnlyKeyDown(event) {
      if (isNotEditable(event.target)) return;
      selectionCalculator.onKeyDown(event);
    };

    var handleReadOnlyKeyUp = function handleReadOnlyKeyUp(event) {
      if (isNotEditable(event.target)) return;
      selectionCalculator.onKeyUp(event);
    };

    if (isReadMode && IS_MOBILE) {
      window.document.addEventListener('keydown', handleReadOnlyKeyDown);
      window.document.addEventListener('keyup', handleReadOnlyKeyUp);
    }

    return function () {
      if (isReadMode && IS_MOBILE) {
        window.document.removeEventListener('keydown', handleReadOnlyKeyDown);
        window.document.removeEventListener('keyup', handleReadOnlyKeyUp);
      }
    };
  }, [readOnly, selectionCalculator, isReadMode]); // 编辑模式下 textarea 监听输入行为

  var editableListeners = readOnly ? {} : {
    onChange: inputDetector.onChange,
    onCompositionStart: inputDetector.onCompositionStart,
    onCompositionEnd: inputDetector.onCompositionEnd,
    onCut: handleCut,
    onPaste: function onPaste(event) {
      event.preventDefault();
      var clipboardData = event.clipboardData; // perf: clipboardData.files 读取耗费性能，减少读取次数
      // TODO 优化 win 上

      var isCangjie = clipboardData.types.includes(MIME_TYPES.FRAGMENT) || (clipboardData.getData(MIME_TYPES.HTML) || '').includes(CLIPBOARD_IDENTIFIER);
      var isFile = clipboardData.types.includes('Files') && !isCangjie;
      /**
       * 支持异步读取 native event 对象上的数据
       * React 16 及更早版本需要调用 event.persist 方法， 参考：https://reactjs.org/docs/legacy-event-pooling.html
       * React 17 以上版本 event pool 被移除，默认支持异步读取， 参考：https://reactjs.org/blog/2020/08/10/react-v17-rc.html#no-event-pooling
       */

      if (event.persist) {
        event.persist();
      } // 粘贴的是文件，走同步事件，其他类型走异步事件


      if (window.DataTransfer && !isFile) {
        var cloneData;

        try {
          cloneData = new DataTransfer();
        } catch (e) {
          // 兼容chrome 60以下不支持的DataTransfer构造函数的版本
          cloneData = new CustomDataTransfer();
        }

        var pasteInputEvent = PasteInputEvent({});

        for (var _iterator = _createForOfIteratorHelperLoose(clipboardData.items), _step; !(_step = _iterator()).done;) {
          var _step$value = _step.value,
              type = _step$value.type,
              kind = _step$value.kind;

          if (kind === 'file') {
            continue;
          }

          var data = clipboardData.getData(type);
          cloneData.setData(type, data);
        } // @ts-ignore


        pasteInputEvent.clipboardData = cloneData; // @ts-ignore

        controller.run('onPaste', pasteInputEvent);
      } else {
        controller.run('onPaste', event);
      }
    }
  };
  var textareaKeys = (_textareaKeys = {}, _textareaKeys[Selector.dockey] = document.key, _textareaKeys); // TODO: 在 Safari 下阅读模式会丢失内容焦点，导致键盘事件和CCP事件全部失效
  // Use jsx will lose type check

  var _ref2 = /*#__PURE__*/_createElement(EditableContent, {
    document: document,
    selection: selection,
    isFocused: isFocused,
    controller: controller,
    contentRef: contentRef,
    containerRef: containerRef,
    getScrollableContainer: getScrollableContainer
  });

  var content = _createElement(Container, _extends({}, handlers, (_extends3 = {
    ref: combinedContainerRef
  }, _extends3[Selector.content] = true, _extends3['data-zoom'] = zoom, _extends3.className = className, _extends3.style = _extends({}, editorStyle, defaultStyle, docStyle, customStyle, zoomStyle), _extends3.onClick = handleClickToFocus, _extends3.onMouseDown = handleMouseDown, _extends3.onMouseUp = handleMouseUp, _extends3.onKeyDown = handleKeyDown, _extends3.onKeyUp = handleKeyUp, _extends3.onTouchStart = handleTouchStart, _extends3.onTouchMove = handleTouchMove, _extends3.onTouchEnd = handleTouchEnd, _extends3.onTouchStartCapture = handleTouchStartCapture, _extends3.onTouchEndCapture = handleTouchEndCapture, _extends3.onContextMenu = handleContextMenu, _extends3.onDragOver = handleDragOver, _extends3.onDrop = handleDrop, _extends3.onDragEnter = handleDragEnter, _extends3.onDragStart = handleDragStart, _extends3)), IS_MOBILE ? _ref : null,
  /*#__PURE__*/

  /**
   * 阅读模式为什么要挂载 textarea 节点？
   * user-select: none 时浏览器由于丢失了原生选区，无法触发 onCopy 事件，所以这里挂载一个 readOnly 的 textarea 节点用于获取
   * 浏览器的焦点。
   */
  _createElement(HiddenTextArea
  /**
   * readonly mode disable composition and input
   * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea
   */
  , _extends({
    readOnly: readOnly,
    autoFocus: autoFocus && !readOnly,
    ref: textareaRef,
    tabIndex: tabIndex,
    selection: selection,
    onCopy: handleCopy,
    onFocus: handleFocus,
    onBlur: handleBlur,
    disabled: isTextareaDisabled
  }, textareaKeys, editableListeners)), controller.run('renderEditable', _extends({}, props, {
    contentRef: contentRef,
    children: function children() {
      return _ref2;
    }
  })), /*#__PURE__*/_createElement(SelectionLayer, {
    controller: controller,
    contentRef: combinedContainerRef,
    scrollableContainerRef: scrollableContainerRef
  }));

  var externalZoom = useExternalZoom();
  return /*#__PURE__*/_createElement(ZoomContainerContext.Provider, {
    value: containerRef.current
  }, /*#__PURE__*/_createElement(ZoomContext.Provider, {
    value: zoom * externalZoom
  }, controller.run('renderContent', _extends({}, props, {
    contentRef: contentRef,
    children: function children() {
      return content;
    }
  }))));
});
/**
 * Cangjie Content 组件
 * (new plugin 修改)scollbaleContainer 和 scrollableContent 属于 cangjie 本身的职责，从 bi/zhi 移动到 cangjie 中
 * @returns
 */

function ContentWithContext(props) {
  var contentRef = useRef(null);

  var _props$getScrollableC2 = props.getScrollableContainer,
      getScrollableContainer = _props$getScrollableC2 === void 0 ? function () {
    return window;
  } : _props$getScrollableC2,
      _props$getScrollableC3 = props.getScrollableContent,
      getScrollableContent = _props$getScrollableC3 === void 0 ? function () {
    return contentRef.current || window.document.body;
  } : _props$getScrollableC3,
      rest = _objectWithoutPropertiesLoose(props, ["getScrollableContainer", "getScrollableContent"]);

  return /*#__PURE__*/_createElement(ScrollableContainerContext.Provider, {
    value: getScrollableContainer()
  }, /*#__PURE__*/_createElement(ScrollableContentContext.Provider, {
    value: getScrollableContent()
  }, /*#__PURE__*/_createElement(Content, _extends({}, rest, {
    ref: contentRef,
    getScrollableContent: getScrollableContent,
    getScrollableContainer: getScrollableContainer
  }))));
}

Content.displayName = 'CangjieContent';

var normalizePendingConfig = (function (config) {
  var input = false;
  var selection = false;

  if (typeof config === 'boolean' || !config) {
    // @ts-ignore typing narrow error ????
    input = config || false; // @ts-ignore typing narrow error

    selection = config || false;
  } else {
    input = config.input || false;
    selection = config.selection || false;
  }

  return {
    input: input,
    selection: selection
  };
});

/** 
 * 插件 action 创建快捷方法，解决 action 的 typing 问题
 */
// utils handler for createAction and judgeAction
var createActionHandlers = function createActionHandlers(type) {
  var createAction = function createAction(payload) {
    if (payload === void 0) {
      payload = {};
    }

    return {
      type: type,
      payload: payload
    };
  };

  var isAction = function isAction(action) {
    return (action == null ? void 0 : action.type) === type;
  };

  return [createAction, isAction];
};

function getUserData(document, node, uid, key) {
  var _node$data;

  if (!Element$1.isElement(node)) {
    return undefined;
  }

  var uuid = (_node$data = node.data) == null ? void 0 : _node$data.uuid;
  var nData = node.data[key];

  if (uid && uuid) {
    var _document$data$userDa, _document$data$userDa2, _document$data$userDa3;

    var uData = (_document$data$userDa = document.data.userData) == null ? void 0 : (_document$data$userDa2 = _document$data$userDa[uid]) == null ? void 0 : (_document$data$userDa3 = _document$data$userDa2[uuid]) == null ? void 0 : _document$data$userDa3[key];
    return uData || nData;
  }

  return nData;
}

var GroupPlugin = {
  actions: groupActions,
  utils: groupUtils
};

var RangeSelection = /*#__PURE__*/function (_Selection) {
  _inheritsLoose(RangeSelection, _Selection);

  function RangeSelection() {
    return _Selection.apply(this, arguments) || this;
  }

  return RangeSelection;
}(Selection);

export { ACTION_CLEAR_MOBILE_MENU, Block, CangjieClipboardEvent, CangjieDataTransfer, CangjieInputEvent, CangjieSelectEvent, Commands, ContentWithContext as Content, contextMenu$1 as ContextMenu, Controller, DATA_CLIPBORAD_CANGJIE, Decoration, Document, EdgePoint, Element$1 as Element, ExternalZoomContext, FlushTask, GroupPlugin, History, Parser as HtmlParser, ImmutableRecord, Injection, Inline, JsonMLHasAttributes, Leaf, MS_OFFICE, MS_OFFICES, MS_WORD, Mark, index$2 as MoCommon, index$1 as MoInterfaces, State as MoState, Node$1 as Node, Operation, OperationType, Path, PendingType, Point, Provider, index as Queries, REMAIN_STYLE_SOURCES, RangeSelection, SLASH_PLACEHOLDER, ScrollableContentContext, Selection, SelectionSlot, ShadowRoot, StyleContext, Text$1 as Text, TextPoint, Value, YUQUE, constants, createActionHandlers, createBaseSerializer, createEmptyParagraph, createEmptyText, createPerfFirstRenderPlugin, createPerfLazyRenderPlugin, createPlaceholderPlugin, createSchema, createSerializer, createSerializerOld, createStrictSchema, createTextWithString, index$3 as domUtils, environment, jsonMLGetAttributes as getAttributes, jsonMLGetChildren as getChildren, getDirtyKeysFromElementDiffStrictly, jsonMLGetTagName as getTagName, getUserData, hotkeys, jsonMLAppend, jsonMLAppendAt, jsonMLGetAttributes, jsonMLGetChildren, jsonMLGetDescription, jsonMLGetLastChild, jsonMLGetTagName, jsonMLGetText, jsonMLIsEmptyContent, jsonMLIsText, keyUtils, normalizePendingConfig, omitEmptyObj, opContext as opContextUtils, setUtils, textUtils, toStyleObject, transfer as transferUtils, useContentStyle, useExternalZoom, useGroupData, useHots, useHotsAtTheStartOfNextFrame, useInputingHots, useInputingHotsAtTheStartOfNextFrame, useLeafBlockResizer, useNodeStyle, useOffsetPosition, useScroll, useScrollableContainer, useScrollableContent, useSelectingHots, useSelectingHotsAtTheStartOfNextFrame, useSelectionData, useStyle, useUserData, useZoom, useZoomContainer };
//# sourceMappingURL=index.js.map
