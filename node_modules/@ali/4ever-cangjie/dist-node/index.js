'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var isPlainObject = require('is-plain-object');
var equal = require('fast-deep-equal');
var React = require('react');
var warning$1 = require('tiny-warning');
var lodash = require('lodash');
var _extends = require('@babel/runtime/helpers/extends');
var UnicodeTrie = require('unicode-trie');
var ClipboardManager = require('@ali/clipboard-manager');
var ReactDOM = require('react-dom');
var isHotkey = require('is-hotkey');
var Debug = require('debug');
var tsPattern = require('ts-pattern');
var root = require('react-shadow');
var memoizeOne = require('memoize-one');
var uuid = require('uuid');
var ReactDOMServer = require('react-dom/server');
var cangjieLibForTreeShaking = require('@ali/cangjie-lib-for-tree-shaking');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var isPlainObject__default = /*#__PURE__*/_interopDefaultLegacy(isPlainObject);
var equal__default = /*#__PURE__*/_interopDefaultLegacy(equal);
var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var React__namespace = /*#__PURE__*/_interopNamespace(React);
var warning__default = /*#__PURE__*/_interopDefaultLegacy(warning$1);
var _extends__default = /*#__PURE__*/_interopDefaultLegacy(_extends);
var UnicodeTrie__default = /*#__PURE__*/_interopDefaultLegacy(UnicodeTrie);
var ClipboardManager__default = /*#__PURE__*/_interopDefaultLegacy(ClipboardManager);
var ReactDOM__default = /*#__PURE__*/_interopDefaultLegacy(ReactDOM);
var ReactDOM__namespace = /*#__PURE__*/_interopNamespace(ReactDOM);
var Debug__default = /*#__PURE__*/_interopDefaultLegacy(Debug);
var root__default = /*#__PURE__*/_interopDefaultLegacy(root);
var memoizeOne__default = /*#__PURE__*/_interopDefaultLegacy(memoizeOne);
var ReactDOMServer__namespace = /*#__PURE__*/_interopNamespace(ReactDOMServer);

/**
 * @packageDocumentation
 * @module environment
 */
const IS_IOS = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
const IS_ANDROID = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);
const IS_MOBILE = IS_IOS || IS_ANDROID;
const IS_TOUCH_DEVICE = typeof navigator !== 'undefined' && navigator.maxTouchPoints > 0;
const IS_IPAD = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad/.test(navigator.userAgent) && !window.MSStream;
const IS_MAC = typeof navigator !== 'undefined' && /Mac OS X/i.test(navigator.userAgent);
const IS_WINDOWS = typeof navigator !== 'undefined' && /Windows/i.test(navigator.userAgent);
const IS_FIREFOX = typeof navigator !== 'undefined' && /mozilla\/[a-z._\d]+ \((?:mobile)|(?:tablet)/i.test(navigator.userAgent); // Mac 容器内置的 Safari 内核浏览器在 userAgent 上没有 Safari 标识...
// 这里为了兼容钉钉容器内置 Safari 的情况

const IS_SAFARI = typeof navigator !== 'undefined' && navigator.vendor === 'Apple Computer, Inc.';
const IS_DEV = process.env.NODE_ENV === 'development';
const IS_NODE = !!(typeof process !== 'undefined' && process.versions && process.versions.node);
/**
 * 返回 Chrome 版本
 */

const getChromeVersion = () => {
  const raw = navigator?.userAgent?.match(/Chrom(e|ium)\/([0-9]+)\./);
  return raw ? parseInt(raw[2], 10) : -1;
};

var environment = /*#__PURE__*/Object.freeze({
  __proto__: null,
  IS_IOS: IS_IOS,
  IS_ANDROID: IS_ANDROID,
  IS_MOBILE: IS_MOBILE,
  IS_TOUCH_DEVICE: IS_TOUCH_DEVICE,
  IS_IPAD: IS_IPAD,
  IS_MAC: IS_MAC,
  IS_WINDOWS: IS_WINDOWS,
  IS_FIREFOX: IS_FIREFOX,
  IS_SAFARI: IS_SAFARI,
  IS_DEV: IS_DEV,
  IS_NODE: IS_NODE,
  getChromeVersion: getChromeVersion
});

/**
 * @packageDocumentation
 * @ignore
 */

/**
 * Freeze an object or array in Cangjie data to prevent modification
 *
 * Since Cangjie abandoned the immutableJS library, now it's developer's
 * responsibility to create new data object for any updated properties.
 * This function is used in Cangjie debug mode to prevent mistakes of altering
 * existing object.
 *
 * Note:
 * 1. use it in development mode, since it may cause bad performance
 *   https://immerjs.github.io/immer/docs/performance
 *
 * 2. use it in 'strict mode' to trigger a TypeError; otherwise the caller
 *   will just fails silently, which doesn't make any use it.
 */
function isFrozen(obj) {
  if (obj === null || typeof obj !== 'object') {
    return true;
  }

  return Object.isFrozen(obj);
}

function deepFreeze(obj) {
  if (isFrozen(obj)) {
    return;
  } // we don't use Object.keys here, as we want to incude Arrays


  const propNames = Object.getOwnPropertyNames(obj);

  for (const key of propNames) {
    const value = obj[key];

    if (!isFrozen(value)) {
      deepFreeze(value);
    }
  }

  return Object.freeze(obj);
}

/**
 * @packageDocumentation
 * @ignore
 */
class ImmutableRecord {
  freeze() {
    if (IS_DEV) {
      deepFreeze(this);
    }
  }

}

/**
 * @packageDocumentation
 * @module Models
 */
class Node$1 extends ImmutableRecord {
  static createProperties(attrs = {}) {
    if (typeof attrs === 'string') {
      return {
        type: attrs
      };
    }

    if (isPlainObject__default["default"](attrs)) {
      return attrs;
    }

    throw new Error(`\`Node.createProperties\` only accepts objects, strings, but you passed it: ${attrs}`);
  }

  constructor(props) {
    super();
    this.key = void 0;
    const {
      key
    } = props;
    this.key = key;
  }

  /**
   * 把当前的 Node 转化成子类型（Text 或者 Element）
   */
  toSubType() {
    const node = this;

    if (node instanceof Text$1) {
      return node;
    } else if (node instanceof Element$1) {
      return node;
    }

    throw new Error(`${node} is not a Node`);
  }
  /**
   * 此节点是否是一个Text节点。see Text.isText
   */


  isText() {
    return this instanceof Text$1;
  }
  /**
   * 此节点是否是一个Element节点。see Element.isElement
   */


  isElement() {
    return this instanceof Element$1;
  }
  /**
   * 获取第一个叶子Node；如果自身就是一个叶子Node，则返回自身
   * 根据目前Schema规范，返回的都都是一个text；但是后续Cangjie扩展，可能返回其它类型Node
   */


  getFirstNode() {
    if (!this.isElement() || !this.nodes.length) {
      return this;
    }

    return this.nodes[0].getFirstNode();
  }
  /**
   * 获取最后一个叶子Node；如果自身就是一个叶子Node，则返回自身
   * 根据目前Schema规范，返回的都都是一个text；但是后续Cangjie扩展，可能返回其它类型Node
   */


  getLastNode() {
    if (!this.isElement() || !this.nodes.length) {
      return this;
    }

    return this.nodes[this.nodes.length - 1].getLastNode();
  }
  /**
   * 获取第一个Text
   * 根据目前Schema规范，都会返回一个text；但是后续Cangjie扩展，可能返回null
   */


  getFirstText() {
    if (this.isText()) {
      return this;
    }

    if (!this.isElement() || !this.nodes.length) {
      return null;
    }

    return this.nodes[0].getFirstText();
  }
  /**
   * 获取最后一个Text
   * 根据目前Schema规范，都会返回一个text；但是后续Cangjie扩展，可能返回null
   */


  getLastText() {
    if (this.isText()) {
      return this;
    }

    if (!this.isElement() || !this.nodes.length) {
      return null;
    }

    return this.nodes[this.nodes.length - 1].getLastText();
  }

}

/**
 * @packageDocumentation
 * @module Models
 */
class Mark extends ImmutableRecord {
  static create(properties) {
    if (Mark.isMark(properties)) {
      return properties;
    }

    let props = properties;

    if (typeof props === 'string') {
      props = {
        type: props
      };
    }

    if (isPlainObject__default["default"](props)) {
      const {
        type,
        data = {}
      } = props;

      if (typeof type !== 'string') {
        throw new Error('`Mark.fromJS` requires a `type` string.');
      }

      return new Mark({
        type,
        data
      });
    }

    throw new Error(`\`Mark.create\` only accepts objects, strings or marks, but you passed it: ${properties}`);
  }

  static fromJSON(json) {
    return Mark.create(json);
  }

  static isMark(maybeMark) {
    return maybeMark instanceof Mark;
  }

  constructor(props) {
    super();
    this.type = void 0;
    this.data = void 0;
    const {
      type,
      data
    } = props;
    this.type = type;
    this.data = { ...data
    };
    this.freeze();
  }

  merge(props) {
    return new Mark({
      type: this.type,
      data: this.data,
      ...props
    });
  }

  set(key, value) {
    return this.merge({
      [key]: value
    });
  }

  isEqual(mark) {
    return equal__default["default"](this, mark);
  }

  toJSON() {
    return {
      klass: 'mark',
      type: this.type,
      data: { ...this.data
      }
    };
  }

}

/**
 * @packageDocumentation
 * @ignore
 */
var listUtils = {
  skipUntil(as, func) {
    const index = as.findIndex(a => func(a));

    if (index === -1) {
      return [];
    }

    return as.slice(index);
  },

  takeUntil(as, func) {
    const index = as.findIndex(a => func(a));

    if (index === -1) {
      return as.slice();
    }

    return as.slice(0, index);
  },

  hasSameMembers(a, b) {
    if (a.length !== b.length) {
      return false;
    }

    return a.length === 0 || a.every(aElem => !!b.find(bElem => equal__default["default"](aElem, bElem)));
  }

};

/**
 * @packageDocumentation
 * @module Models
 */

function has(as, b) {
  return as.some(a => equal__default["default"](a, b));
}

function union(as, bs) {
  return bs.reduce((merged, b) => {
    if (has(merged, b)) {
      return merged;
    }

    return [...merged, b];
  }, as);
}

function except(as, bs) {
  return as.filter(a => !has(bs, a));
}

class Leaf extends ImmutableRecord {
  static create(properties = '') {
    if (Leaf.isLeaf(properties)) {
      return properties;
    }

    let props = properties;

    if (typeof props === 'string') {
      props = {
        text: props
      };
    }

    if (isPlainObject__default["default"](props)) {
      const {
        text = '',
        marks = []
      } = props;
      return new Leaf({
        text,
        marks: marks.map(Mark.create)
      });
    }

    throw new Error(`\`Leaf.create\` only accepts objects, strings or leaves, but you passed it: ${properties}`);
  }

  static fromJSON(json) {
    const {
      marks
    } = json;
    return Leaf.create({ ...json,
      marks: marks ? marks.map(Mark.fromJSON) : undefined
    });
  }

  static isLeaf(maybeLeaf) {
    return maybeLeaf instanceof Leaf;
  }
  /**
   * 对leaves进行normalize，并返回新Leafs
   */


  static normalizeLeaves(leaves) {
    if (leaves.length === 0) {
      return [Leaf.create()];
    }

    if (leaves.length === 1) {
      return leaves;
    }

    let invalid = false;
    const normalized = leaves.reduceRight((ls, leaf) => {
      const next = ls[0];

      if (!next) {
        return [leaf];
      }

      if (listUtils.hasSameMembers(leaf.marks, next.marks)) {
        invalid = true;
        ls[0] = next.set('text', `${leaf.text}${next.text}`);
        return ls;
      }

      if (next.text === '') {
        invalid = true;
        ls[0] = leaf;
        return ls;
      }

      if (leaf.text === '') {
        invalid = true;
        return ls;
      }

      ls.unshift(leaf);
      return ls;
    }, []);

    if (!invalid) {
      return leaves;
    }

    return normalized;
  }
  /**
   * 对leaves执行split操作。
   * @offset text的偏移量，如果位于某一个leaf内部，则分割该leaf
   */


  static splitLeaves(leaves, offset) {
    if (offset < 0) {
      return [[], leaves];
    }

    if (leaves.length === 0) {
      return [[], []];
    }

    let endOffset = 0;
    let left;
    let right;
    const index = leaves.findIndex(leaf => {
      const startOffset = endOffset;
      const {
        text
      } = leaf;
      endOffset += text.length;

      if (endOffset < offset) {
        return false;
      }

      if (startOffset > offset) {
        return false;
      }

      const length = offset - startOffset;

      if (typeof text.slice !== 'function') {
        throw new Error(`Unable to split leaf with text: ${text}`);
      }

      left = leaf.set('text', text.slice(0, length));
      right = leaf.set('text', text.slice(length));
      return true;
    });

    if (!left || !right) {
      // Same as `!left && !right`
      return [leaves, []];
    }

    if (left.text === '') {
      if (index === 0) {
        return [[left], leaves];
      }

      return [leaves.slice(0, index), leaves.slice(index)];
    }

    if (right.text === '') {
      if (index === leaves.length - 1) {
        return [leaves, [right]];
      }

      const splittedIndex = index + 1;
      return [leaves.slice(0, splittedIndex), leaves.slice(splittedIndex)];
    }

    return [[...leaves.slice(0, index), left], [right, ...leaves.slice(index + 1)]];
  }
  /**
   * 在leaves中搜索第offset个字符对应的位置
   */


  static searchLeafAtOffset(leaves, offset) {
    let startOffset = 0;
    let endOffset = 0;
    const index = leaves.findIndex(leaf => {
      startOffset = endOffset;
      endOffset = startOffset + leaf.text.length;
      return endOffset >= offset;
    });
    const found = index !== -1;

    if (!found) {
      return null;
    }

    return {
      index,
      leaf: leaves[index],
      startOffset,
      endOffset
    };
  }

  constructor(props) {
    super();
    this.text = void 0;
    this.marks = void 0;
    const {
      text,
      marks
    } = props;
    this.text = text;
    this.marks = marks;
    this.freeze();
  }

  merge(props) {
    return new Leaf({
      text: this.text,
      marks: this.marks,
      ...props
    });
  }

  set(key, value) {
    return this.merge({
      [key]: value
    });
  }
  /**
   * 拷贝一个新Leaf，并把Mark加上去
   */


  addMark(mark) {
    return this.set('marks', union(this.marks, [mark]));
  }
  /**
   * 拷贝一个新Leaf，并把Marks加上去
   */


  addMarks(marks) {
    return this.set('marks', union(this.marks, marks));
  }
  /**
   * 拷贝一个新Leaf，并把Mark过滤掉
   */


  removeMark(mark) {
    return this.set('marks', except(this.marks, [mark]));
  }
  /**
   * 拷贝一个新Leaf，并把Mark替换掉
   * 如果mark不存在、mark和新mark相等，则返回当前的Leaf
   */


  setMark(mark, newMark) {
    if (equal__default["default"](mark, newMark)) {
      return this;
    }

    const {
      marks
    } = this;

    if (!has(marks, mark)) {
      return this;
    }

    const newMarks = marks.map(m => equal__default["default"](m, mark) ? newMark : mark);
    return this.set('marks', newMarks);
  }

  toJSON() {
    return {
      klass: 'leaf',
      text: this.text,
      marks: this.marks.map(mark => mark.toJSON())
    };
  }

}

/**
 * @packageDocumentation
 * @module keyUtils
 */

/**
 * cangjie key 生成逻辑，默认从 0 开始递增。
 *
 * key 在多版本、多实例 cangjie 嵌套时，保持全局唯一
 */
let localCount = 0;
const cangjieKeyGen = '__cangjieKeyGen';
const hasWindow = typeof window === 'object';

if (hasWindow && !window[cangjieKeyGen]) {
  window[cangjieKeyGen] = 0;
}

const keyUtils = {
  create() {
    if (hasWindow) {
      const keyStr = `${window[cangjieKeyGen]}`;
      window[cangjieKeyGen] = window[cangjieKeyGen] + 1;
      return keyStr;
    }

    const keyStr = `${localCount}`;
    localCount = localCount + 1;
    return keyStr;
  },

  parse(key) {
    const [k, o] = key.split(':');
    return [k, parseInt(o, 10)];
  },

  resetGenerator() {
    if (hasWindow) {
      window[cangjieKeyGen] = 0;
    }

    localCount = 0;
  }

};

/**
 * @packageDocumentation
 * @ignore
 */
var setUtils = {
  add(as, b) {
    const index = as.findIndex(a => equal__default["default"](a, b));
    const newAs = [...as];

    if (index !== -1) {
      newAs.splice(index, 1);
    }

    newAs.push(b);
    return newAs;
  },

  remove(as, b) {
    return as.filter(a => !equal__default["default"](a, b));
  },

  has(as, b, isEqual = equal__default["default"]) {
    return as.some(a => isEqual(a, b));
  },

  intersect(as, bs) {
    return as.filter(a => bs.some(b => equal__default["default"](a, b)));
  },

  union(as, bs, isEqual = equal__default["default"]) {
    return bs.reduce((merged, b) => {
      if (this.has(merged, b, isEqual)) {
        return merged;
      }

      merged.push(b);
      return merged;
    }, [...as]);
  },

  removeDuplicate(as) {
    return as.filter((a, index) => index === as.findIndex(b => equal__default["default"](b, a)));
  },

  isSuperSet(as, bs) {
    return bs.every(b => as.findIndex(a => equal__default["default"](a, b)) !== -1);
  }

};

/**
 * @packageDocumentation
 * @module Models
 */
const SUPRESS_NORMALIZE = {
  normalize: false
};
const TEXTS = new WeakMap();
class Text$1 extends Node$1 {
  static create(properties = '') {
    if (Text$1.isText(properties)) {
      return properties;
    }

    let props = properties;

    if (typeof props === 'string') {
      props = {
        leaves: [Leaf.create(props)]
      };
    }

    if (isPlainObject__default["default"](props)) {
      const {
        key = keyUtils.create(),
        leaves = []
      } = props;
      return new Text$1({
        key,
        leaves: leaves.map(Leaf.create)
      });
    }

    throw new Error(`\`Text.create\` only accepts objects, strings or texts, but you passed it: ${properties}`);
  }

  static fromJSON(json) {
    return Text$1.create({ ...json,
      leaves: json.leaves.map(Leaf.fromJSON)
    });
  }

  static isText(maybeText) {
    return maybeText instanceof Text$1;
  }

  static isEmptyText(maybeText) {
    return maybeText instanceof Text$1 && !maybeText.text;
  }

  static isTextList(maybeTextList) {
    return Array.isArray(maybeTextList) && maybeTextList.every(Text$1.isText);
  }

  constructor(props, options = {
    normalize: true
  }) {
    super(props);
    this.leaves = void 0;
    const {
      leaves
    } = props;
    this.leaves = options.normalize ? Leaf.normalizeLeaves(leaves) : leaves;
    this.freeze();
  }

  /**
   * 获取对应的文本string
   */
  get text() {
    if (process.env.NODE_ENV !== 'test' && TEXTS.has(this)) {
      return TEXTS.get(this);
    }

    const t = this.leaves.map(({
      text
    }) => text).join('');
    TEXTS.set(this, t);
    return t;
  }
  /**
   * 获取所有的marks
   */


  get marks() {
    return this.getMarks();
  }
  /**
   * 获取自身树下的所有 Text 节点
   * 如果自身是 Text，则返回只含有自身的数组
   */


  getTexts() {
    return [this];
  }

  merge(props) {
    return new Text$1({
      key: this.key,
      leaves: this.leaves,
      ...props
    });
  }

  set(key, value) {
    return this.merge({
      [key]: value
    });
  }

  regenerateKey() {
    return this.set('key', keyUtils.create());
  }

  getLeaves(decorations) {
    if (!decorations || decorations.length === 0) {
      return this.leaves;
    }

    if (this.leaves.length === 0) {
      const marks = decorations.map(({
        mark
      }) => mark);
      const leaf = Leaf.create({
        text: '',
        marks
      });
      return [leaf];
    }

    if (this.text.length === 0) {
      const firstLeaf = this.leaves[0];
      const marks = decorations.map(d => d.mark);
      return [firstLeaf.addMarks(marks)];
    }

    const {
      key,
      text
    } = this;
    let {
      leaves
    } = this;
    decorations.forEach(dec => {
      const {
        start,
        end,
        mark
      } = dec;
      const hasStart = start.key === key;
      const hasEnd = end.key === key;

      if (hasStart || hasEnd) {
        const index = hasStart ? start.offset : 0;
        const length = hasEnd ? end.offset - index : text.length - index;

        if (length < 1) {
          return;
        }

        if (index >= text.length) {
          return;
        }

        if (index !== 0 || length < text.length) {
          const [before, bundle] = Leaf.splitLeaves(leaves, index);
          const [middle, after] = Leaf.splitLeaves(bundle, length);
          leaves = before.concat(middle.map(l => l.addMark(mark)), after);
          return;
        }
      }

      leaves = leaves.map(l => l.addMark(mark));
    });

    if (leaves === this.leaves) {
      return leaves;
    }

    return Leaf.normalizeLeaves(leaves);
  }
  /**
   * 获取所有的marks
   */


  getMarks() {
    if (this.leaves.length === 0) {
      return [];
    }

    return this.leaves.reduce((marks, leaf) => setUtils.union(marks, leaf.marks), []);
  }
  /**
   * 获取text内所有文字都有的，公共marks
   */


  getActiveMarks() {
    if (this.leaves.length === 0) {
      return [];
    }

    const firstMarks = this.leaves[0].marks;

    if (firstMarks.length === 0) {
      return firstMarks;
    }

    return this.leaves.slice(1).reduce((marks, leaf) => setUtils.intersect(marks, leaf.marks), firstMarks);
  }
  /**
   * 根据offset区间，获取marks
   */


  getMarksBetweenOffsets(startOffset, endOffset) {
    if (startOffset <= 0 && endOffset >= this.text.length) {
      return this.getMarks();
    }

    if (startOffset >= endOffset) return []; // For empty text in a paragraph, use getActiveMarks;

    if (this.text === '') return this.getActiveMarks();
    let result = null;
    let leafEnd = 0;
    this.leaves.forEach(leaf => {
      const leafStart = leafEnd;
      leafEnd = leafStart + leaf.text.length;
      if (leafEnd <= startOffset) return;
      if (leafStart >= endOffset) return;

      if (!result) {
        result = leaf.marks;
        return;
      }

      result = setUtils.union(result, leaf.marks);
    });
    return result || [];
  }
  /**
   * 根据offset区间，获取区间内所有文字都含有的，公共marks
   */


  getActiveMarksBetweenOffsets(startOffset, endOffset) {
    if (startOffset <= 0 && endOffset >= this.text.length) {
      return this.getActiveMarks();
    }

    if (startOffset >= endOffset) return []; // For empty text in a paragraph, use getActiveMarks;

    if (this.text === '') return this.getActiveMarks();
    let result = [];
    let leafEnd = 0;
    let foundNoMarks = false;
    this.leaves.forEach(leaf => {
      const leafStart = leafEnd;
      leafEnd = leafStart + leaf.text.length;
      if (leafEnd <= startOffset) return;
      if (leafStart >= endOffset) return;
      foundNoMarks = foundNoMarks || !leaf.marks.length;

      if (!result.length) {
        result = leaf.marks;
        return;
      }

      result = setUtils.intersect(result, leaf.marks);
    });

    if (foundNoMarks && result.length) {
      // aaaBBB: a has no marks, B has marks, so they have no intersected marks
      result = [];
    }

    return result || [];
  }
  /**
   * 获取第index个文字，对应的marks
   */


  getMarksAtIndex(index) {
    const leafObj = Leaf.searchLeafAtOffset(this.leaves, index);
    return !leafObj ? [] : leafObj.leaf.marks;
  }
  /**
   * 拷贝出一个新的text节点，并在指定的位置添加mark
   * 如果offset不合法，则返回自身
   */


  addMark(offset, length, mark) {
    return this.addMarks(offset, length, [mark]);
  }
  /**
   * 拷贝出一个新的text节点，并在指定的位置添加marks。
   * 如果marks是0，或者offset不合法，则返回自身
   */


  addMarks(offset, length, marks) {
    if (this.text === '' && offset === 0) {
      const {
        leaves
      } = this;
      const first = leaves[0];

      if (!first) {
        return this.set('leaves', [Leaf.create({
          text: '',
          marks
        })]);
      }

      const newFirst = first.addMarks(marks);

      if (newFirst === first) {
        return this;
      }

      return this.set('leaves', [newFirst]);
    }

    if (length === 0 || offset >= this.text.length) {
      return this;
    }

    const [before, bundle] = Leaf.splitLeaves(this.leaves, offset);
    const [middle, after] = Leaf.splitLeaves(bundle, length);
    return this.set('leaves', [...before, ...middle.map(leaf => leaf.addMarks(marks)), ...after]);
  }
  /**
   * 拷贝出一个新的text节点，并在指定的位置过滤掉对应的mark
   * 如果当前没有这个mark，或者offset不合法，则返回自身
   */


  removeMark(offset, length, mark) {
    if (this.text === '' && offset === 0) {
      const {
        leaves
      } = this;
      const first = leaves[0];

      if (!first) {
        return this;
      }

      const newFirst = first.removeMark(mark);

      if (newFirst === first) {
        return this;
      }

      return this.set('leaves', [newFirst]);
    }

    if (length === 0 || offset >= this.text.length) {
      return this;
    }

    const [before, bundle] = Leaf.splitLeaves(this.leaves, offset);
    const [middle, after] = Leaf.splitLeaves(bundle, length);
    return this.set('leaves', [...before, ...middle.map(leaf => leaf.removeMark(mark)), ...after]);
  }
  /**
   * 在指定的区间，设置一个新的Mark
   * 如果指定区间不合法，或者区间内已经存在同样的mark，则返回自身
   */


  setMark(offset, length, mark, properties) {
    const newMark = mark.merge(properties);

    if (this.text === '' && offset === 0 && length === 0) {
      const {
        leaves
      } = this;
      const first = leaves[0];

      if (!first) {
        return this;
      }

      const newFirst = first.setMark(mark, newMark);

      if (newFirst === first) {
        return this;
      }

      return this.set('leaves', [newFirst]);
    }

    if (length === 0 || offset >= this.text.length) {
      return this;
    }

    const [before, bundle] = Leaf.splitLeaves(this.leaves, offset);
    const [middle, after] = Leaf.splitLeaves(bundle, length);
    return this.set('leaves', [...before, ...middle.map(leaf => leaf.setMark(mark, newMark)), ...after]);
  }
  /**
   * 复制出一个新的text，并在指定的位置，插入对应的文字和marks
   */


  insertText(offset, text, marks = []) {
    if (this.text === '') {
      return this.set('leaves', [Leaf.create({
        text,
        marks
      })]);
    }

    if (text.length === 0) {
      return this;
    }

    const {
      leaves
    } = this;
    const leafObj = Leaf.searchLeafAtOffset(leaves, offset);

    if (!leafObj) {
      throw new Error(`Text.insertText, could not find leaf with offset: ${offset}`);
    }

    const {
      index,
      leaf,
      startOffset
    } = leafObj;
    const delta = offset - startOffset;
    const beforeText = leaf.text.slice(0, delta);
    const afterText = leaf.text.slice(delta);
    const newLeaves = [...leaves];

    if (listUtils.hasSameMembers(leaf.marks, marks)) {
      const newLeaf = leaf.set('text', beforeText + text + afterText);
      newLeaves[index] = newLeaf;
      return this.set('leaves', newLeaves);
    }

    newLeaves.splice(index, 1, leaf.set('text', beforeText), Leaf.create({
      text,
      marks
    }), leaf.set('text', afterText));
    return this.set('leaves', newLeaves);
  }
  /**
   * 在指定的位置，删掉指定的text长度的文字
   * 本杰：TODO: check whether deleted text is same as text?
   */


  removeText(offset, text) {
    if (text.length === 0 || offset >= this.text.length) {
      return this;
    } // PERF: For simple backspace, we can operate directly on the leaf


    if (text.length === 1) {
      const leafObj = Leaf.searchLeafAtOffset(this.leaves, offset + 1);

      if (!leafObj) {
        throw new Error(`Text.removeText, could not find leaf with offset: ${offset}`);
      }

      const {
        index,
        leaf,
        startOffset
      } = leafObj;
      const newLeaves = [...this.leaves];

      if (leaf.text.length === 1) {
        if (newLeaves.length === 1) {
          // keep marks when delete the last leaf
          newLeaves[0] = Leaf.create({
            text: '',
            marks: leaf.marks
          });
        } else {
          newLeaves.splice(index, 1);
        } // PERF: Avoid normalizing twice for normalized `leaves`.


        return new Text$1({
          key: this.key,
          leaves: newLeaves
        }, SUPRESS_NORMALIZE);
      }

      const delta = offset - startOffset;
      const beforeText = leaf.text.slice(0, delta);
      const afterText = leaf.text.slice(delta + text.length);
      const newText = beforeText + afterText;
      newLeaves[index] = leaf.set('text', newText);
      return new Text$1({
        key: this.key,
        leaves: newLeaves
      }, SUPRESS_NORMALIZE);
    }

    const [before, bundle] = Leaf.splitLeaves(this.leaves, offset);
    const after = Leaf.splitLeaves(bundle, text.length)[1]; // PERF: reduce `leaves` to be normalized.

    const middle = Leaf.normalizeLeaves([...before.slice(-1), ...after.slice(0, 1)]);
    const leaves = [...before.slice(0, -1), ...middle, ...after.slice(1)];

    if (leaves.length === 1) {
      const first = leaves[0];

      if (first.text === '') {
        return new Text$1({
          key: this.key,
          leaves: [first.set('marks', this.getActiveMarks())]
        }, SUPRESS_NORMALIZE);
      }
    }

    return new Text$1({
      key: this.key,
      leaves
    }, SUPRESS_NORMALIZE);
  }
  /**
   * 拷贝出一个新的text，并把传入的text的leaves添加上去
   */


  mergeText(other) {
    const leaves = this.leaves.concat(other.leaves);
    return this.set('leaves', leaves);
  }
  /**
   * 在指定的位置做一个split，返回split后的两个text
   */


  splitText(position) {
    const [befores, afters] = Leaf.splitLeaves(this.leaves, position);
    const a = this.set('leaves', befores);
    const b = this.set('leaves', afters).regenerateKey();
    return [a, b];
  }

  toJSON(options) {
    const object = {
      klass: 'text',
      leaves: this.leaves.map(leaf => leaf.toJSON())
    };

    if (options?.preserveKeys) {
      object.key = this.key;
    }

    return object;
  }

}

/**
 * @packageDocumentation
 * @module Models
 */
class Path extends Array {
  /**
   * Compare priority between `path` and `target`:
   *
   * - if `path` is before `target`, return -1
   * - if `path` is after `target`, return 1
   * - if `path` is equal to `target`, return 0
   * - else if something went wrong, return null
   *
   * @param path - path
   * @param target - target path
   *
   * # Example
   *
   * ```ts
   * Path.compare([1,0], [1,0])     // 0
   * Path.compare([1,1,1], [1,0])   // 1
   * Path.compare([1,0,0,1], [1,1]) // -1
   * ```
   */
  static compare(path, target) {
    const m = Math.min(path.length, target.length);

    for (let i = 0; i < m; i += 1) {
      const pv = path[i];
      const tv = target[i]; // If the path's value is ever less than the target's, it's before.

      if (pv < tv) {
        return -1;
      } // If the target's value is ever less than the path's, it's after.


      if (pv > tv) {
        return 1;
      }
    } // Paths should now be equal, otherwise something is wrong


    return path.length === target.length ? 0 : null;
  }
  /**
   * Crop `a` and `b` into the same size.
   *
   * @param a
   * @param b
   * @param size - crop size, default is the shortest between a and b
   *
   * # Example
   *
   * ```ts
   * Path.crop([1,1,0], [1,1])    // [1,1]
   * Path.crop([1,1,0], [1,1], 1) // [1]
   * ```
   */


  static crop(a, b, size = Math.min(a.length, b.length)) {
    const ca = a.slice(0, size);
    const cb = b.slice(0, size);
    return [ca, cb];
  }
  /**
   * Decrement a `path` by `n` at `index`.
   *
   * @param path
   * @param n - default is 1
   * @param index - default is the last index
   *
   * # Example
   *
   * ```ts
   * Path.decrement([1,1,1])       // [1,1,0]
   * Path.decrement([1,1,3], 2)    // [1,1,1]
   * Path.decrement([1,1,3], 1, 1) // [1,0,3]
   * ```
   */


  static decrement(path, n = 1, index = path.length - 1) {
    return Path.increment(path, 0 - n, index);
  }
  /**
   * Increment a `path` by `n` at `index`.
   *
   * @param path
   * @param n - default is 1
   * @param index - default is the last index
   *
   * # Example
   *
   * ```ts
   * Path.increment([1,1,1])       // [1,1,2]
   * Path.increment([1,1,1], 2)    // [1,1,3]
   * Path.increment([1,1,1], 2, 1) // [1,3,1]
   * ```
   */


  static increment(path, n = 1, index = path.length - 1) {
    const newPath = [...path];
    newPath[index] += n;
    return newPath;
  }
  /**
   * Link the `subPath` to the `ancestor`.
   *
   * @param ancestor
   * @param subPath
   *
   * # Example
   *
   * ```ts
   * Path.link([1,0], [1]) // [1,0,1]
   * ```
   */


  static link(ancestor, subPath) {
    return ancestor.concat(subPath);
  }
  /**
   * If the `path` is the ancestor of the `target`.
   *
   * @param path
   * @param target
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *         []
   *        /  \
   *     [0]   [1]
   *    /  \
   * [0,0]  [0,1]
   * ```
   *
   * ```ts
   * Path.isAncestor([], [0,0])  // true
   * Path.isAncestor([0], [0,0]) // true
   * ```
   */


  static isAncestor(path, target) {
    const [p, t] = Path.crop(path, target);
    return path.length < target.length && Path.isEqual(p, t);
  }
  /**
   * If the `path` is descendant of the `target`.
   *
   * @param path
   * @param target
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *         []
   *        /  \
   *      [0]   [1]
   *         __/ | \__
   *    [1,0]  [1,1]  [1,2]
   *      /
   *   [1,0,0]
   * ```
   *
   * ```ts
   * Path.isDescendant([1,0], [1]) // true
   * Path.isDescendant([1], [])   // true
   * ```
   */


  static isDescendant(path, target) {
    return path.length > target.length && Path.isEqual(path.slice(0, target.length), target);
  }
  /**
   * If the `path` is before the `target`.
   *
   * @param path
   * @param target
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *         []
   *        / \
   *      [0] [1]
   *         /  \
   *    [1,0]   [1,1]
   * ```
   *
   * ```ts
   * Path.isBefore([0], [1,1])   // true
   * Path.isBefore([1,0], [1,1]) // true
   * ```
   */


  static isBefore(path, target) {
    const [p, t] = Path.crop(path, target);
    return Path.compare(p, t) === -1;
  }
  /**
   * If the `path` is after the `target`.
   *
   * @param path
   * @param target
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *         []
   *        /  \
   *     [0]   [1]
   *          /  \
   *     [1,0]   [1,1]
   * ```
   *
   * ```ts
   * Path.isAfter([1], [0])   // true
   * Path.isAfter([1,0], [0]) // true
   * ```
   */


  static isAfter(path, target) {
    const [p, t] = Path.crop(path, target);
    return Path.compare(p, t) === 1;
  }
  /**
   * If the `path` is equal to `target`.
   *
   * @param path
   * @param target
   *
   * # Example
   *
   * ```ts
   * Path.isEqual([], [])       // true
   * Path.isEqual([1,0], [1,0]) // true
   * Path.isEqual([0], [1])     // false
   * ```
   */


  static isEqual(path, target) {
    return equal__default["default"](path, target);
  }
  /**
   * If the `path` is the sibling of the `target`.
   *
   * @param path
   * @param target
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *         []
   *        /  \
   *      [0]   [1]
   *         __/ | \__
   *    [1,0]  [1,1]  [1,2]
   * ```
   *
   * ```ts
   * Path.isSibling([1,0], [1,1]) // true
   * Path.isSibling([1,2], [1,1]) // true
   * ```
   */


  static isSibling(path, target) {
    if (path.length !== target.length) {
      return false;
    }

    const p = Path.parent(path);
    const t = Path.parent(target);
    return Path.isEqual(p, t) && path[path.length - 1] !== target[path.length - 1];
  }
  /**
   * If the `path` is the previous sibling of the `target`.
   *
   * @param path
   * @param target
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *         []
   *        /  \
   *      [0]   [1]
   *         __/ | \__
   *    [1,0]  [1,1]  [1,2]
   * ```
   *
   * ```ts
   * Path.isPrevSibling([0], [1]) // true
   * Path.isPrevsSibling([1,1], [1,2]) // true
   * Path.isPrevsSibling([0], [1,2]) // false
   * ```
   */


  static isPrevSibling(path, target) {
    return Path.isSibling(path, target) && Path.isBefore(path, target);
  }
  /**
   * If the `path` is younger than the `target`.It means at the level which `path` lives, the `path` is ends before `target`.
   *
   * @param path
   * @param target
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *         []
   *        / \
   *     [0]   [1]
   *        __/ | \__
   *   [1,0]  [1,1]  [1,2]
   *          /   \
   *   [1,1,0]   [1,1,1]
   * ```
   *
   * ```ts
   * Path.isYounger([1,1,0], [1,1,1]) // true
   * Path.isYounger([1,0], [1,1,1])   // true
   * Path.isYounger([0], [1,1,1])     // true
   * ```
   */


  static isYounger(path, target) {
    const index = path.length - 1;
    const [p, t] = Path.crop(path, target, index);
    const pl = path[index];
    const tl = target[index];
    return Path.isEqual(p, t) && pl < tl;
  }
  /**
   * If the `path` is deeper than the `target`.
   *
   * @param path
   * @param target
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *         []
   *        /  \
   *      [0]  [1]
   *           /  \
   *      [1,0]   [1,1]
   * ```
   *
   * ```ts
   * Path.isDeeper([1,0], [1]) // true
   * Path.isDeeper([1,0], [])  // true
   * ```
   */


  static isDeeper(path, target) {
    return path.length > target.length;
  }
  /**
   * If the `path` is parent of the `target`.
   *
   * @param path
   * @param target
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *        []
   *       / \
   *    [0]  [1]
   *         /  \
   *    [1,0]   [1,1]
   * ```
   *
   * ```ts
   * Path.isParent([1], [1,0]) // true
   * Path.isParent([], [1])    // true
   * ```
   */


  static isParent(path, target) {
    return path.length + 1 === target.length && Path.isEqual(path, Path.parent(target));
  }
  /**
   * If the `path` is child of the `target`
   *
   *
   * @param path
   * @param target
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *         []
   *        /  \
   *      [0]  [1]
   *          /  \
   *     [1,0]   [1,1]
   * ```
   *
   * ```ts
   * Path.isChild([1,0], [1]) // true
   * ```
   */


  static isChild(path, target) {
    return path.length === target.length + 1 && Path.isEqual(path.slice(0, -1), target);
  }
  /**
   * Get the next sibiling of the `path`.
   *
   * @param path
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *         []
   *        /  \
   *      [0]  [1]
   *          /  \
   *     [1,0]   [1,1]
   * ```
   *
   * ```ts
   * Path.next([1,0]) // [1,1]
   * Path.next([])    // null
   * ```
   */


  static next(path) {
    if (path.length === 0) {
      return null;
    }

    const last = path[path.length - 1];
    return path.slice(0, -1).concat(last + 1);
  }
  /**
   * Get the previous sibiling of the `path`.
   *
   * @param path
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *         []
   *        /  \
   *      [0]  [1]
   *          /  \
   *     [1,0]   [1,1]
   * ```
   *
   * ```ts
   * Path.previous([1,1]) // [1,0]
   * Path.previous([])    // null
   * Path.previous([1,0]) // null
   * ```
   */


  static previous(path) {
    if (path.length === 0) {
      return null;
    }

    const last = path[path.length - 1];

    if (last <= 0) {
      return null;
    }

    return path.slice(0, -1).concat(last - 1);
  }
  /**
   * Get the parent path of the `path`,
   * Note: the parent of root is still root.
   *
   * @param path
   *
   * # Example
   *
   * Given the document tree:
   *
   * ```txt
   *         []
   *        /  \
   *      [0]  [1]
   *          /  \
   *     [1,0]   [1,1]
   * ```
   *
   * ```ts
   * Path.parent([1,0]) // [1]
   * Path.parent([0])   // []
   * Path.parent([])    // []
   * ```
   */


  static parent(path) {
    return path.slice(0, -1);
  }
  /**
   * Get all ancestors of the `path`.
   *
   * @param path
   *
   * # Example
   *
   * Given the document tree:
   *
   *```txt
   *        []
   *       /  \
   *    [0]   [1]
   *       __/ | \__
   *  [1,0]  [1,1]  [1,2]
   *          /
   *      [1,1,0]
   * ```
   *
   * ```ts
   * Path.ancestors([1,1,0]) // [[], [1], [1,1]]
   * ```
   */


  static ancestors(path) {
    const ancestors = [];

    for (let i = 0; i < path.length; i += 1) {
      ancestors.push(path.slice(0, i));
    }

    return ancestors;
  }
  /**
   * Get the common ancestor between `a` and `b`.
   *
   * @param a
   * @param b
   *
   * # Example
   *
   * Given the document tree:
   *
   *```txt
   *        []
   *       /  \
   *    [0]   [1]
   *       __/ | \__
   *  [1,0]  [1,1]  [1,2]
   *          /       /
   *      [1,1,0]  [1,2,0]
   * ```
   *
   * ```ts
   * Path.common([1,1,0], [1,2,0]) // [1]
   * ```
   */


  static common(a, b) {
    const path = []; // eslint-disable-next-line no-plusplus

    for (let i = 0; i < a.length && i < b.length; i++) {
      const av = a[i];
      const bv = b[i];
      if (av !== bv) break;
      path.push(av);
    }

    return path;
  }
  /**
   * Get the path of `path` relative to `ancestor`.
   *
   * @param a
   * @param b
   *
   * # Example
   *
   * Given the document tree:
   *
   *```txt
   *        []
   *       /  \
   *    [0]   [1]
   *       __/ | \__
   *  [1,0]  [1,1]  [1,2]
   *          /       /
   *      [1,1,0]  [1,2,0]
   * ```
   *
   * ```ts
   * Path.relative([1,1,0], [1]) // [1,0]
   * Path.relative([1,0,0], [0]) // null
   * ```
   */


  static relative(path, ancestor) {
    if (!Path.isAncestor(ancestor, path) || Path.isEqual(path, ancestor)) {
      return null;
    }

    return path.slice(ancestor.length);
  }
  /**
   * Transform the `path` based on `operation`.
   * @param path
   * @param operation
   */


  static transform(path, operation) {
    if (operation.type === 'set_selection') {
      return [path];
    }

    const {
      type,
      path: p
    } = operation;

    if (type === 'add_mark' || type === 'insert_text' || type === 'remove_mark' || type === 'remove_text' || type === 'set_mark' || type === 'set_node' || path.length === 0) {
      return [path];
    }

    const pIndex = p.length - 1;
    const pEqual = Path.isEqual(p, path);
    const pYounger = Path.isYounger(p, path);
    const pAbove = Path.isAncestor(p, path);

    if (type === 'insert_node') {
      if (pEqual || pYounger || pAbove) {
        /**
         * ## Insert at the path
         *
         * ```js
         * path    = [1,0]
         * op.path = [1,0]
         * ```
         *
         * move path forward at op.path's level           [1,0] --> [1,1]
         *
         * ```txt
         *         []                                               []
         *      __/ \__                                          __/ \__
         *   [0]       [1]             --- transform -->      [0]       [1]
         *             /                                                / |
         *          *[1,0]*                                        [1,0]  *[1,1]*
         * ```
         *
         * ## Insert above the path
         *
         * ```js
         * path    = [1,0]
         * op.path = [1]
         * ```
         *
         * move path forward at op.path's level           [1,0] --> [2,0]
         *
         * ```txt
         *         []                                               [ ]
         *      __/ \__                                          __/ | \__
         *   [0]       [1]           --- transform -->        [0]   [1]   [2]
         *             /                                                  /
         *         *[1,0]*                                            *[2,0]*
         * ```
         *
         * ## Insert at younger
         *
         * ```js
         * path    = [1]
         * op.path = [0]
         * ```
         *
         * move path forward at op.path's level           [1] --> [2]
         *
         * ```txt
         *          [ ]                                             [ ]
         *         /  |                                          __/ | \__
         *       [0] *[1]*           --- transform -->        [0]   [1]   *[2]*
         * ```
         */
        return [Path.increment(path, 1, pIndex)];
      }
    } else if (type === 'remove_node') {
      if (pYounger) {
        /**
         * ## Remove at younger
         *
         * ```js
         * path    = [1,0]
         * op.path = [0]
         * ```
         *
         * move path forward at op.path's level           [1,0] --> [0,0]
         *
         * ```txt
         *         []                                               [ ]
         *      __/ \__                                          __/ | \__
         *   [0]       [1]           --- transform -->        [0]   [1]   [2]
         *             /                                      /
         *         *[1,0]*                                 *[0,0]*
         * ```
         */
        return [Path.decrement(path, 1, pIndex)];
      }

      if (pEqual || pAbove) {
        /**
         * ## Remove at the path
         *
         * ```js
         * path    = [1,0]
         * op.path = [1,0]
         * ```
         *
         * path is removed           [1,0] --> removed
         *
         * ```txt
         *         []                                               []
         *      __/ \__                                          __/ \__
         *   [0]       [1]             --- transform -->      [0]       [1]
         *             /
         *          *[1,0]*
         * ```
         *
         * ## Remove above the path
         *
         * ```js
         * path    = [1,0]
         * op.path = [1]
         * ```
         *
         * path is removed           [1,0] --> removed
         *
         * ```txt
         *         []                                               [ ]
         *      __/ \__                                          __/  \__
         *   [0]       [1]           --- transform -->        [0]        [1]
         *             /
         *         *[1,0]*
         * ```
         *
         */
        return [];
      }
    } else if (type === 'merge_node') {
      if (!Path.previous(p)) {
        return [path];
      }

      if (pEqual || pYounger) {
        /**
         * ## Merge at the path
         *
         * ```js
         * path         = [1]
         * op.path      = [1]
         * op.position  = 2
         * ```
         *
         * move path forward at op.path's level                 [0,1] -> [0]
         *
         * ```txt
         *            []                                                []
         *         __/ \__                                           __/ \__
         *      [0]      *[1]*                                    *[0]*
         *     /  \       /             ---- transform -->      __/  |  \__
         * [0,0] [0,1]  [1,0]                              [0,0]   [0,1]  [0,2]
         * ```
         *
         * ## Merge at younger
         *
         * ```js
         * path         = [1,0,2,0]
         * op.path      = [1,0,1]
         * op.position  = 1
         * ```
         *
         * move path forward at op.path's level         [1,0,2,0] -> [1,0,1,0]
         *
         *```txt
         *            []                                                []
         *         __/ \__                                           __/ \__
         *      [0]       [1]                                     [0]       [1]
         *     /  \       /             ---- transform -->        / \        /
         * [0,0] [0,1]  [1,0]                                 [0,0] [0,1]  [1,0]
         *          ___/  |  \___                                          /  \
         * [1,0,0] <-- [1,0,1]   [1,0,2]                            [1,0,0]   [1,0,1]
         *                         /                                             /
         *                   *[1,0,2,0]*                                    *[1,0,1,0]*
         *```
         */
        return [Path.decrement(path, 1, pIndex)];
      }

      if (pAbove) {
        /**
         *
         * ## Merge above the path
         *
         * ```js
         * path        = [1,0]
         * op.path     = [1]
         * op.position = 2
         * ```
         *
         * 1. move path forward at op.path's level    [1,0] -> [0,0]
         * 2. move sub path to the position               [0,0] -> [0,2]
         *
         * ```
         *            []                                                []
         *         __/ \__                                           __/
         *      [0]  <-- [1]                                      [0]
         *     /  \       /             ---- transform -->     __/ | \__
         * [0,0] [0,1] *[1,0]*                            [0,0] [0, 1]  *[0,2]*
         *          ___/  |  \___                                    ___/  |  \___
         *   [1,0,0]   [1,0,1]   [1,0,2]                      [0,2,0]   [0,2,1]   [0,2,2]
         * ```
         */
        const {
          position
        } = operation;
        return [Path.increment(Path.decrement(path, 1, pIndex), position, pIndex + 1)];
      }
    } else if (type === 'split_node') {
      if (pEqual) {
        /**
         * ## Split at the path
         *
         * ```js
         * path        = [1]
         * op.path     = [1]
         * op.position = 1
         * ```
         *
         * split path into 2 paths:  [1] -> [1], [2]
         *
         * ```
         *         []                                          [ ]
         *      __/ \__                                     __/ | \__
         *   [0]      *[1]*      --- transform -->       [0]  *[1]*  *[2]*
         *            /  \                                     /      /
         *       [1,0] s [1,1]                              [1,0]   [2,0]
         * ```
         */
        return [path, Path.increment(path)];
      }

      if (pYounger) {
        /**
         * ## Split at younger
         *
         * ```js
         * path        = [1,0,0]
         * op.path     = [0]
         * op.position = 1
         * ```
         *
         * move path foward at op.path's level: [1,0,0] -> [2,0,0]
         *
         * ```txt
         *              []                                          [ ]
         *           __/ \__                                     __/ | \__
         *        [0]       [1]      --- transform -->       [0]   [1]    [2]
         *       /  \       /                                /      /     /
         *  [0,0] s [0,1] [1,0]                           [0,0]  [1,0] [2,0]
         *                 /                                            /
         *             *[1,0,0]*                                   *[2,0,0]*
         * ```
         */
        return [Path.increment(path, 1, pIndex)];
      }

      if (pAbove) {
        /*
         * ## Split above
         *
         * If split happened before the path at op.path's level
         *
         * ```js
         * path        = [1,0,2]
         * op.path     = [1,0]
         * op.position = 1
         * ```
         *
         * 1. move path foward at op.path's level: [1,0,2] -> [1,1,2]
         * 2. move path backward to the split position:    [1,1,2] -> [1,1,1]
         *
         * ```txt
         *              []                                          []
         *           __/ \__                                     __/  \__
         *        [0]       [1]      --- transform -->        [0]        [1]
         *                   /                                        __/   \__
         *                [1,0]                                  [1,0]         [1,1]
         *            ____/ | \____                                /           /   \
         *     [1,0,0] s [1,0,1]   *[1,0,2]*                  [1,0,0]   [1,1,0]    *[1,1,1]*
         * ```
         */
        const {
          position
        } = operation;

        if (path[pIndex + 1] >= position) {
          return [Path.decrement(Path.increment(path, 1, pIndex), position, pIndex + 1)];
        }
      }
    }

    if (type === 'move_node') {
      const {
        newPath: np
      } = operation;
      const npIndex = np.length - 1;
      const npEqual = Path.isEqual(np, path); // Stay

      if (Path.isEqual(p, np)) {
        return [path];
      }

      const npYounger = Path.isYounger(np, path);
      const npAbove = Path.isAncestor(np, path);

      if (pAbove) {
        /*
         * ## Move above the path
         *
         * If move node forward to the deeper
         *
         * ```js
         * path       = [1,0]
         * op.path    = [1]
         * op.newPath = [2,0]
         * ```
         *
         * 1. move new path to the left at op.path's level:    [2,0] -> [1,0]
         * 2. link sub path to the path:                       [1,0] + [0] -> [1,0,0]
         *
         * ```txt
         *         [  ]                                     [ ]
         *      __/ | \__                                __/  |__
         *   [0]   [1]  [2]    --- transform -->      [0]        [1]
         *         /     /                                       / \
         *    *[1,0]*  [2,0]                                [1,0]  [1,1]
         *              /                                    /      /
         *           [2,0,0]                          *[1,0,0]*   [1,1,0]
         * ```
         *
         * Else
         *
         * ```js
         * path       = [1,0]
         * op.path    = [1]
         * op.newPath = [0]
         * ```
         *
         * link sub path to new path:                                [0] + [0] -> [0,0]
         *
         * ```
         *         []                                         []
         *      __/ \__                                    __/ |__
         *   [0]       [1]       --- transform -->      [0]       [1]
         *              /                                /
         *          *[1,0]*                           *[0,0]*
         * ```
         */
        const subPath = Path.relative(path, p);

        if (Path.isAfter(np, p) && Path.isDeeper(np, p)) {
          return [Path.link(Path.decrement(np, 1, p.length - 1), subPath)];
        }

        return [Path.link(np, subPath)];
      } else if (pEqual) {
        /*
         * ## Move at the path
         *
         * If move forward to the deeper
         *
         * ```js
         * path       = [1]
         * op.path    = [1]
         * op.newPath = [2,0]
         * ```
         *
         * 1. move new path backward at op.path's level:      [2,0] -> [1,0]
         * 2. move path to the new path:                         [1]   -> [1,0]
         *
         * ```txt
         *         [  ]                                         []
         *      __/ | \__                                      / \
         *   [0]  *[1]*  [2]    --- transform -->           [0]  [1]
         *               /                                       /  \
         *            [2,0]                                 *[1,0]*  [1,1]
         * ```
         *
         * Else
         *
         * ```js
         * path       = [1,0]
         * op.path    = [1,0]
         * op.newPath = [2,0]
         * ```
         *
         * move path to new path:                               [1,0] -> [2,0]
         *
         * ```txt
         *         [  ]                                         [ ]
         *      __/ | \__                                    __/ | \__
         *   [0]   [1]   [2]    --- transform -->         [0]   [1]   [2]
         *          /     /                                          /  \
         *      *[1,0]* [2,0]                                  *[2,0]* [2,1]
         * ```
         */
        if (Path.isYounger(p, np) && Path.isDeeper(np, p)) {
          return [Path.decrement(np, 1, p.length - 1)];
        }

        return [np];
      } else if (Path.isSibling(p, np) && (npAbove || npEqual)) {
        if (pYounger) {
          /*
           * ## Move younger to sibling, the sibling is the ancestor of the path.
           *
           * ```js
           * path       = [1,0]
           * op.path    = [0]
           * op.newPath = [1]
           * ```
           *
           * move path forward at op.path's level:        [1,0] -> [0,0]
           *
           * ```txt
           *         []                                       []
           *        / \                                      / \
           *     [0]  [1]       --- transform -->          [0] [1]
           *           /                                    /
           *        *[1,0]*                              *[0,0]*
           * ```
           *
           * ## Move younger to sibling, the sibling is the path.
           *
           * ```js
           * path       = [2]
           * op.path    = [0]
           * op.newPath = [2]
           * ```
           *
           * move path forward at op.path's level:        [2] -> [1]
           *
           * ```txt
           *         [ ]                                        [ ]
           *        / | \         --- transform -->          __/ | \__
           *    [0] [1] *[2]*                             [0]  *[1]*  [2]
           * ```
           */
          return [Path.decrement(path, 1, pIndex)];
        } else {
          /*
           * ## Move older to sibling, the sibling is ancestor of the path.
           *
           * ```js
           * path       = [1, 0]
           * op.path    = [2]
           * op.newPath = [0]
           * ```
           *
           * move path foward at op.path's level:        [1,0] -> [2,0]
           *
           * ```txt
           *         [ ]                                       [ ]
           *        / | \                                     / | \
           *     [0] [1] [2]      --- transform -->        [0] [1] [2]
           *          /                                            /
           *       *[1,0]*                                      *[2,0]*
           *
           * ```
           *
           * ## Move older to sibling, the sibling is the path.
           *
           * ```js
           * path       = [1]
           * op.path    = [2]
           * op.newPath = [1]
           * ```
           *
           * move path forward at op.path's level:        [1] -> [2]
           *
           * ```txt
           *         [ ]                                        [ ]
           *        / | \         --- transform -->          __/ | \__
           *    [0] *[1]* [2]                             [0]   [1]  *[2]*
           * ```
           */
          return [Path.increment(path, 1, pIndex)];
        }
      } else if (npEqual || npYounger || npAbove) {
        if (pYounger) {
          /*
           * ## Move younger to path.
           *
           * ```js
           * path       = [1,1]
           * op.path    = [0]
           * op.newPath = [1,0]
           * ```
           *
           * 1. move path backward at op.path's level:        [1,1] -> [0,1]
           * 2. move path forward at op.newPath's level:      [0,1] -> [0,2]
           *
           * ```txt
           *        [ ]                                    [ ]
           *     __/ | \__                              __/ | \__
           *  [0]   [1]  [2]   --- transform -->    [0]  [1]   [2]
           *        / \                          __/ | \__
           *   [1,0]  *[1,1]*               [0,0]  [0,1]  *[0,2]*
           * ```
           *
           * ## Move younger to path's younger.
           *
           * ```js
           * path       = [1,1]
           * op.path    = [0]
           * op.newPath = [1,0]
           * ```
           *
           * 1. move path backward at op.path's level:        [1,1] -> [0,1]
           * 2. move path forward at op.newPath's level:      [0,1] -> [0,2]
           *
           * ```txt
           *        [ ]                                  [ ]
           *     __/  \__                                /
           *  [0]      [1]    --- transform -->        [0]
           *           /  \                         __/ | \__
           *      [1,0]  *[1,1]*               [0,0]  [0,1]  *[0,2]*
           * ```
           *
           * ## Move younger to path's ancestor.
           *
           * ```js
           * path       = [1,0,0]
           * op.path    = [0]
           * op.newPath = [1,0]
           * ```
           *
           * 1. move path backward at op.path's level:        [1,0,0] -> [0,0,0]
           * 2. move path forward at op.newPath's level:      [0,0,0] -> [0,1,0]
           *
           * ```txt
           *        [ ]                                    [ ]
           *     __/  \__                                 /
           *  [0]        [1]    --- transform -->      [0]
           *             /                             / \
           *          [1,0]                       [0,0]  [0,1]
           *           /                                   /
           *       *[1,0,0]*                            *[0,1,0]*
           * ```
           *
           */
          return [Path.increment(Path.decrement(path, 1, pIndex), 1, npIndex)];
        }
        /*
         * ## Move to path.
         *
         * ```js
         * path       = [1]
         * op.path    = [2]
         * op.newPath = [1]
         * ```
         *
         * move path to the right at op.newPath's level:      [1] -> [2]
         *
         * ```txt
         *        [ ]                                    [ ]
         *     __/ | \__                              __/ | \__
         *  [0]  *[1]*  [2]   --- transform -->     [0]  [1]   *[2]*
         * ```
         *
         * ## Move to path's younger.
         *
         * ```js
         * path       = [1,0]
         * op.path    = [1,1]
         * op.newPath = [0]
         * ```
         *
         * move path to the right at op.newPath's level:      [1,0] -> [2,0]
         *
         * ```txt
         *        [ ]                                  [ ]
         *     __/  \__                             __/ | \__
         *  [0]      [1]    --- transform -->    [0]   [1]   [2]
         *           /  \                                     /
         *      *[1,0]* [1,1]                             *[2,0]*
         * ```
         *
         * ## Move to path's ancestor.
         *
         * ```js
         * path       = [1,0]
         * op.path    = [0,0]
         * op.newPath = [1]
         * ```
         *
         * move path to the right at op.newPath's level:      [1,0] -> [2,0]
         *
         * ```txt
         *        [ ]                                    [ ]
         *     __/  \__                               __/ | \__
         *  [0]        [1]    --- transform -->    [0]   [1]   [2]
         *   /          /                                       /
         * [0,0]    *[1,0]*                                 *[2,0]*
         * ```
         *
         */


        return [Path.increment(path, 1, npIndex)];
      } else if (pYounger) {
        /**
         * ## Move younger to the right of the path.
         *
         * ```js
         * path       = [1,0]
         * op.path    = [0]
         * op.newPath = [1,1]
         * ```
         *
         * move path backward at op.path's level:          [1,0] -> [0,0]
         *
         * ```txt
         *         []                                       []
         *        / \                                      /
         *     [0]  [1]       --- transform -->          [0]
         *         /   \                                 / \
         *    *[1,0]*  [1,1]                       *[0,0]* [0,1]
         * ```
         *
         * ```js
         * path       = [1]
         * op.path    = [0]
         * op.newPath = [2,0]
         * ```
         *
         * move path backward at op.path's level:          [1] -> [0]
         *
         * ```txt
         *         [ ]                                       []
         *      __/ | \__                                   / \
         *   [0]  *[1]*  [2]     --- transform -->      *[0]*  [1]
         *               /                                     / \
         *            [2,0]                                [1,0] [1,1]
         * ```
         *
         * ## Move younger below the path.
         *
         * ```js
         * path       = [1,0]
         * op.path    = [0]
         * op.newPath = [1,1]
         * ```
         *
         * move path backward at op.path's level:          [1,0] -> [0,0]
         *
         * ```txt
         *         []                                       []
         *        / \                                      /
         *     [0]  [1]       --- transform -->          [0]
         *         /   \                                 / \
         *    *[1,0]*  [1,1]                       *[0,0]* [0,1]
         * ```
         */
        return [Path.decrement(path, 1, pIndex)];
      }
    }

    return [path];
  }
  /**
  * If the `path` is root path
  *
  *
  * @param path
  * @param target
  *
  * # Example
  *
  *
  * ```ts
  * Path.isRoot([]) // true
  * ```
  */


  static isRoot(path) {
    return path.length === 0;
  }

}

function whereToStr(where) {
  if (typeof where === 'string') {
    return `with key: ${where}.`;
  } else if (Array.isArray(where)) {
    return `with path: ${where}.`;
  }

  return `with unknown: ${typeof where}, ${where}.`;
}

/** 节点不存在 Error */
class NodeNotFoundError extends Error {
  static createAssertNotFoundError(type, ofType) {
    return function assertNotFound(maybeNode, method, where) {
      if (!maybeNode || !ofType(maybeNode)) {
        throw new NodeNotFoundError(method, type, where);
      }

      return maybeNode;
    };
  }

  constructor(method, type, where) {
    super(`[${method}] could not find ${type} ${whereToStr(where)}`);
    Object.setPrototypeOf(this, NodeNotFoundError.prototype);
  }

}
/** 路径不存在的 Error */

class PathNotFoundError extends Error {
  constructor(key) {
    super(`\`Element.assertPath\` could not find path with key: ${key}`);
    Object.setPrototypeOf(this, PathNotFoundError.prototype);
  }

}

/**
 * @packageDocumentation
 * @module Models
 */
const KEYS_TO_EDGES_TABLE_CACHE = new WeakMap();
function linkKeysToEdgesTable(src, target) {
  const table = KEYS_TO_EDGES_TABLE_CACHE.get(src);

  if (table) {
    KEYS_TO_EDGES_TABLE_CACHE.set(target, table);
  }
}
const assertNode = NodeNotFoundError.createAssertNotFoundError('node', node => node instanceof Node$1);
const assertElement = NodeNotFoundError.createAssertNotFoundError('element', node => node instanceof Element$1);
const assertText = NodeNotFoundError.createAssertNotFoundError('text', node => node instanceof Text$1);
const assertBlock = NodeNotFoundError.createAssertNotFoundError('block', node => node instanceof Block);
class Element$1 extends Node$1 {
  /**
   * 判断 `maybeElement` 是否为 Element
   * @param maybeElement
   * @returns
   *
   * @example
   * ```tsx
   * const block = (<block type="paragraph">Hello</block>);
   * const inline = (<inline type="link">www.dingtalk.com</inline>);
   * const text = (<text>Hello</text>);
   *
   * assertTrue(Element.isElement(block));
   * assertTrue(Element.isElement(inline));
   * assertFlase(Element.isElement(text));
   * ```
   */
  static isElement(maybeElement) {
    return maybeElement instanceof Element$1;
  }

  constructor(props) {
    super(props);
    this.data = void 0;
    this.nodes = void 0;
    this.type = void 0;
    const {
      data,
      nodes
    } = props;
    this.data = { ...data
    };
    this.nodes = nodes;
  }

  /**
   * 判断节点是否是 Inline 类型
   *
   * @example
   * ```tsx
   * const document = (<document><block type="paragraph">Hello</block></document>);
   * const block = (<block type="paragraph">Hello</block>);
   * const inline = (<inline type="link">www.dingtalk.com</inline>);
   *
   * assertTrue(inline.isInline());
   * assertFalse(block.isInline());
   * assertFalse(document.isInline());
   * ```
   */
  isInline() {
    return this instanceof Inline;
  }
  /**
   * 判断节点是否是 Block 类型
   *
   * @example
   * ```tsx
   * const document = (<document><block type="paragraph">Hello</block></document>);
   * const block = (<block type="paragraph">Hello</block>);
   * const inline = (<inline type="link">www.dingtalk.com</inline>);
   *
   * assertTrue(block.isBlock());
   * assertFalse(inline.isBlock());
   * assertFalse(document.isBlock());
   * ```
   */


  isBlock() {
    return this instanceof Block;
  }
  /**
   * 重新生成节点 key，避免出现 key 重复的节点
   * @example
   * ```tsx
   * const block = (<block type="paragraph">Hello</block>);
   *
   * const newBlock = block.regenerateKey();
   * assertFalse(block.key === newBlock.key);
   * ```
   * @returns
   */


  regenerateKey() {
    return this.set('key', keyUtils.create());
  }
  /**
   * 获取子节点
   * @param key
   * @throws NodeNotFoundError 无法找到节点时，抛出异常
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(element.assertNode('own'), <block key="own" />);
   * assertEqual(element.assertNode('hello'), <text key="hello" />);
   * assertEqual(element.assertNode('world-block'), <block type="paragraph" key="world-block"/>);
   * assert(() => element.assertNode('not-exists')).toThrow();
   * ```
   */


  assertNode(key) {
    const node = this.getNode(key);
    return assertNode(node, 'Element.assertNode', this.assertPath(key));
  }
  /**
   * 获取子节点
   * @param path
   * @throws NodeNotFoundError 无法找到节点时，抛出异常
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(element.assertNodeByPath([]), <block key="own" />);
   * assertEqual(element.assertNodeByPath([0,0]), <text key="hello" />);
   * assertEqual(element.assertNodeByPath([1]), <block type="paragraph" key="world-block"/>);
   * assert(() => element.assertNodeByPath([2])).toThrow();
   * ```
   *
   *
   */


  assertNodeByPath(path) {
    const node = this.getNodeByPath(path);
    return assertNode(node, 'Element.assertNodeByPath', path);
  }
  /**
   * 获取子 text 节点
   * @param key
   * @throws NodeNotFoundError 无法找到节点时，抛出异常
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.assertText('hello'),
   *   <text key="hello">Hello</text>
   * );
   * assert(() => element.assertText('hello-block')).toThrow();
   * assert(() => element.assertText('not-exists')).toThrow();
   * ```
   */


  assertText(key) {
    const node = this.getNode(key);
    return assertText(node, 'Element.assertText', this.assertPath(key));
  }
  /**
   * 获取子 text 节点
   * @param path
   * @throws NodeNotFoundError 无法找到节点时，抛出异常
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.assertTextByPath([0,0]),
   *   <text key="hello">Hello</text>
   * );
   * assert(() => element.assertTextByPath([0])).toThrow();
   * assert(() => element.assertTextByPath([0,1])).toThrow();
   * ```
   */


  assertTextByPath(path) {
    const node = this.getNodeByPath(path);
    return assertText(node, 'Element.assertTextByPath', path);
  }
  /**
   * 根据 `key`，获取子 element 节点
   * @param key
   * @throws NodeNotFoundError 无法找到节点时，抛出异常
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.assertElement('hello-block'),
   *   <block type="paragraph" key="hello-block" />
   * );
   * assert(() => element.assertElement('hello')).toThrow();
   * assert(() => element.assertElement('not-exists')).toThrow();
   * ```
   */


  assertElement(key) {
    const node = this.getNode(key);
    return assertElement(node, 'Element.assertElement', this.assertPath(key));
  }
  /**
   * 获取子 element 节点
   * @param path
   * @throws NodeNotFoundError 无法找到节点时，抛出异常
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.assertElementByPath([0]),
   *   <block type="paragraph" key="hello-block" />
   * );
   * assert(() => element.assertElementByPath([0,0])).toThrow();
   * assert(() => element.assertElementByPath([2])).toThrow();
   * ```
   */


  assertElementByPath(path) {
    const node = this.getNodeByPath(path);
    return assertElement(node, 'Element.assertElementByPath', path);
  }
  /**
   * 获取节点 path
   * @param key
   * @throws NodeNotFoundError 无法找到节点时，抛出异常
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(element.assertPath('own'), []);
   * assertEqual(element.assertPath('hello-block'), [0]);
   * assertEqual(element.assertPath('hello'), [0, 0]);
   * assert(() => element.assertPath('not-exists')).toThrow();
   * ```
   */


  assertPath(key) {
    const path = this.getPath(key);

    if (path === null) {
      throw new PathNotFoundError(key);
    }

    return path;
  }
  /**
   * 判断节点是否存在于当前的节点子树中
   * @param key
   * @returns
   *
   * @example
   *
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *   </block>
   * );
   *
   * assertTrue(element.hasNode('hello'));
   * assertFalse(element.hasNode('own));
   * assertFalse(element.hasNode('not-exists'));
   * ```
   */


  hasNode(key) {
    return Boolean(this.getKeysToEdgesTable()[key]);
  }
  /**
   * 判断节点是否为空：仅含有一个空的 text 节点
   *
   * @example
   *
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <text />
   *   </block>
   * );
   *
   * assertTrue(element.isEmpty());
   * ```
   */


  isEmpty() {
    const {
      nodes
    } = this;
    return nodes.length === 1 && Text$1.isText(nodes[0]) && !nodes[0].text;
  }
  /**
   * 获取子节点
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(element.getNode('own'), <block key="own" />);
   * assertEqual(element.getNode('hello'), <text key="hello" />);
   * assertEqual(element.getNode('world-block'), <block type="paragraph" key="world-block"/>);
   * assertEqual(element.getNode(), null);
   * ```
   */


  getNode(key) {
    const path = this.getPath(key);
    return this.getNodeByPath(path);
  }
  /**
   * 获取子节点，如果没有找到，将返回 null
   * @param path
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(element.getNodeByPath([]), <block key="own" />);
   * assertEqual(element.getNodeByPath([0,0]), <text key="hello" />);
   * assertEqual(element.getNodeByPath([1]), <block type="paragraph" key="world-block"/>);
   * assertEqual(element.getNodeByPath([2]), null);
   * ```
   */


  getNodeByPath(path) {
    if (!path) {
      return null;
    }

    return path.reduce((n, index, idx) => {
      if (!n) {
        return null;
      }

      const node = n.toSubType();

      if (node.isText()) {
        return idx === path.length - 1 ? node : null;
      }

      return node.nodes[index] || null;
    }, this);
  }
  /**
   * 获取相对于当前节点的 path，如果没有找到，就返回 `null`
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(element.getPath('own'), []);
   * assertEqual(element.getPath('hello'), [0,0]);
   * assertEqual(element.getPath('world-block'), [1]);
   * assertEqual(element.getPath('not-exists'), null);
   * ```
   */


  getPath(key) {
    if (key === this.key) {
      return [];
    }

    const keysToEdgesTable = this.getKeysToEdgesTable();

    if (!keysToEdgesTable[key]) {
      return null;
    }

    const path = [];
    let k = key;

    while (keysToEdgesTable[k]) {
      const [parentKey, index] = keysToEdgesTable[k];
      path.push(index);
      k = parentKey;
    }

    path.reverse();
    return path;
  }
  /**
   * 获取上一个兄弟节点，若不存在，将返回 null
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">Hello</block>
   *     <block type="paragraph" key="world-block">World</block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getPreviousSibling('world-block'),
   *   <block type="paragraph" key="hello-block">Hello</block>
   * );
   * assertEqual(
   *   element.getPreviousSibling('hello-block'),
   *   null
   * );
   * ```
   */


  getPreviousSibling(key) {
    const path = this.getPath(key);

    if (!path || path.length === 0) {
      return null;
    }

    return this.getPreviousSiblingByPath(path);
  }
  /**
   * 获取上一个兄弟节点，若不存在，将返回 null
   * @param path
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">Hello</block>
   *     <block type="paragraph" key="world-block">World</block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getPreviousSiblingByPath([1]),
   *   <block type="paragraph" key="hello-block">Hello</block>
   * );
   * assertEqual(
   *   element.getPreviousSiblingByPath([0]),
   *   null
   * );
   * ```
   */


  getPreviousSiblingByPath(path) {
    const lastIndex = path[path.length - 1];

    if (lastIndex <= 0) {
      return null;
    }

    return this.getNodeByPath(Path.decrement(path));
  }
  /**
   * 获取下一个兄弟节点，若不存在，返回 null
   * @param key
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">Hello</block>
   *     <block type="paragraph" key="world-block">World</block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getNextSibling('hello-block'),
   *   <block type="paragraph" key="world-block">World</block>
   * );
   * assertEqual(
   *   element.getNextSibling('world-block'),
   *   null
   * );
   * ```
   */


  getNextSibling(key) {
    const path = this.getPath(key);

    if (!path || path.length === 0) {
      return null;
    }

    return this.getNextSiblingByPath(path);
  }
  /**
   * 获取下一个兄弟节点，若不存在，返回 null
   * @param path
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">Hello</block>
   *     <block type="paragraph" key="world-block">World</block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getNextSiblingByPath([0]),
   *   <block type="paragraph" key="world-block">World</block>
   * );
   * assertEqual(
   *   element.getNextSiblingByPath([1]),
   *   null
   * );
   * ```
   */


  getNextSiblingByPath(path) {
    return this.getNodeByPath(Path.increment(path));
  }
  /**
   * 获取上一个叶子节点，若不存在，将返回 null
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *       <block type="paragraph" key="world-block">World</block>
   *     </block>
   *     <block type="container">
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getPreviousNode('cangjie-block'),
   *   <text>World</text>
   * );
   * assertEqual(
   *   element.getPreviousNode('hello-block'),
   *   null
   * );
   * ```
   */


  getPreviousNode(key) {
    const path = this.getPath(key);

    if (!path) {
      return null;
    }

    return this.getPreviousNodeByPath(path);
  }
  /**
   * 获取上一个叶子节点，若不存在，将返回 null
   * @param path
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *       <block type="paragraph" key="world-block">World</block>
   *     </block>
   *     <block type="container">
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getPreviousNodeByPath([1,0]),
   *   <text>World</text>
   * );
   * assertEqual(
   *   element.getPreviousNodeByPath([0,0]),
   *   null
   * );
   * ```
   */


  getPreviousNodeByPath(path) {
    let previousNode = this.getPreviousSiblingByPath(path);
    let parentPath = Path.parent(path);

    while (!previousNode && parentPath.length) {
      const parentPrevSibling = this.getPreviousSiblingByPath(parentPath);
      previousNode = parentPrevSibling && parentPrevSibling.getLastNode();
      parentPath = Path.parent(parentPath);
    }

    return previousNode;
  }
  /**
   * 获取下一个叶子节点，若不存在，将返回 null
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *     </block>
   *     <block type="container">
   *       <block type="paragraph" key="world-block">World</block>
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getNextNode('hello-block'),
   *   <text>World</text>
   * );
   * assertEqual(
   *   element.getNextNode('cangjie-block'),
   *   null
   * );
   * ```
   */


  getNextNode(key) {
    const path = this.getPath(key);

    if (!path) {
      return null;
    }

    return this.getNextNodeByPath(path);
  }
  /**
   * 获取下一个叶子节点，若不存在，将返回 null
   * @param path
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *     </block>
   *     <block type="container">
   *       <block type="paragraph" key="world-block">World</block>
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getNextNodeByPath([0, 0]),
   *   <text>World</text>
   * );
   * assertEqual(
   *   element.getNextNodeByPath([1,1]),
   *   null
   * );
   * ```
   */


  getNextNodeByPath(path) {
    let nextNode = this.getNextSiblingByPath(path);
    let parentPath = Path.parent(path);

    while (!nextNode && parentPath.length) {
      const parentNextSibling = this.getNextSiblingByPath(parentPath);
      nextNode = parentNextSibling && parentNextSibling.getFirstNode();
      parentPath = Path.parent(parentPath);
    }

    return nextNode;
  }
  /**
   * 获取上一个文本节点
   * @param key
   * @throws NodeNotFoundError 若节点不存在，则抛错
   * @returns
   *
   * * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *       <block type="paragraph" key="world-block">World</block>
   *     </block>
   *     <block type="container">
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.assertPreviousText('cangjie-block'),
   *   <text>World</text>
   * );
   * assert(() => element.assertPreviousText('hello-block')).toThrow();
   * ```
   */


  assertPreviousText(key) {
    const text = this.getPreviousText(key);
    return assertText(text, 'assertPreviousText', key);
  }
  /**
   * 获取上一个文本节点，若不存在，将返回 null
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *       <block type="paragraph" key="world-block">World</block>
   *     </block>
   *     <block type="container">
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getPreviousText('cangjie-block'),
   *   <text>World</text>
   * );
   * assertEqual(
   *   element.getPreviousText('hello-block'),
   *   null
   * );
   * ```
   */


  getPreviousText(key) {
    const path = this.getPath(key);

    if (!path || !path.length) {
      return null;
    }

    return this.getPreviousTextByPath(path);
  }
  /**
   * 获取上一个文本节点，若不存在，将返回 null
   * @param path
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *       <block type="paragraph" key="world-block">World</block>
   *     </block>
   *     <block type="container">
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getPreviousTextByPath([1,0]),
   *   <text>World</text>
   * );
   * assertEqual(
   *   element.getPreviousTextByPath([0]),
   *   null
   * );
   * ```
   */


  getPreviousTextByPath(path) {
    let previous = this.getPreviousNodeByPath(path);

    while (previous?.isElement() && !previous.nodes.length) {
      const previousPath = this.getPath(previous.key);

      if (!previousPath) {
        return null;
      }

      previous = this.getPreviousNodeByPath(previousPath);
    }

    if (!previous) {
      return null;
    }

    return previous.getLastText();
  }
  /**
   * 获取下一个文本节点，若不存在，将返回 null
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *     </block>
   *     <block type="container">
   *       <block type="paragraph" key="world-block">World</block>
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getNextText('hello-block'),
   *   <text>World</text>
   * );
   * assertEqual(
   *   element.getNextText('cangjie-block'),
   *   null
   * );
   * ```
   */


  getNextText(key) {
    const path = this.getPath(key);

    if (!path || !path.length) {
      return null;
    }

    return this.getNextTextByPath(path);
  }
  /**
   * 获取下一个文本节点，若不存在，将返回 null
   * @param path
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *     </block>
   *     <block type="container">
   *       <block type="paragraph" key="world-block">World</block>
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getNextTextByPath([0,0]),
   *   <text>World</text>
   * );
   * assertEqual(
   *   element.getNextTextByPath([1,1]),
   *   null
   * );
   * ```
   */


  getNextTextByPath(path) {
    let next = this.getNextNodeByPath(path);

    while (next?.isElement() && !next.nodes.length) {
      const nextPath = this.getPath(next.key);

      if (!nextPath) {
        return null;
      }

      next = this.getNextNodeByPath(nextPath);
    }

    if (!next) {
      return null;
    }

    return next.getFirstText();
  }
  /**
   * 获取上一个 block，若不存在，将返回 null
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *       <block type="paragraph" key="world-block">World</block>
   *     </block>
   *     <block type="container">
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getPreviousBlock('cangjie-block'),
   *   <block type="paragraph" key="world-block">World</block>
   * );
   * assertEqual(
   *   element.getPreviousBlock('hello-block'),
   *   null
   * );
   * ```
   */


  getPreviousBlock(key) {
    const child = this.getNode(key);

    if (!child) {
      return null;
    }

    let first;

    if (Block.isBlock(child)) {
      first = child.getFirstText();
    } else {
      const block = this.getClosestBlock(key);
      first = block.getFirstText();
    }

    const previous = first && this.getPreviousText(first.key);

    if (!previous) {
      return null;
    }

    return this.getClosestBlock(previous.key);
  }
  /**
   * 获取下一个 block，若不存在，将返回 null
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *     </block>
   *     <block type="container">
   *       <block type="paragraph" key="world-block">World</block>
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getNextBlock('hello-block'),
   *   <block type="paragraph" key="world-block">World</block>
   * );
   * assertEqual(
   *   element.getNextBlock('cangjie-block'),
   *   null
   * );
   * ```
   */


  getNextBlock(key) {
    const child = this.getNode(key);

    if (!child) {
      return null;
    }

    let last;

    if (Block.isBlock(child)) {
      last = child.getLastText();
    } else {
      const block = this.getClosestBlock(key);
      last = block.getLastText();
    }

    if (!last) return null;
    const next = this.getNextText(last.key);
    if (!next) return null;
    const closest = this.getClosestBlock(next.key);
    return closest;
  }
  /**
   * 获取节点 Key-to-Path 的映射表
   *
   * @example
   * ```ts
   * const element = (
   *   <block type="container" key="container">
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *   </block>
   * );
   *
   * const table = element.getKeysToEdgesTable();
   * assertEqual(
   *   table,
   *   {
   *     'world-block': ['container', 0],
   *     'world':       ['world-block', 0],
   *     'hello-block': ['container', 1],
   *     'hello':       ['hello-block', 0]
   *   }
   * );
   * ```
   */


  getKeysToEdgesTable() {
    if (!KEYS_TO_EDGES_TABLE_CACHE.has(this)) {
      const {
        key,
        nodes
      } = this;
      const {
        length
      } = nodes;
      const table = Object.create(null);

      for (let i = 0; i < length; i += 1) {
        const node = nodes[i];
        table[node.key] = [key, i];

        if (!Element$1.isElement(node)) {
          continue;
        }

        const nested = node.getKeysToEdgesTable(); // PERF

        node.forEachDescendant(n => {
          table[n.key] = nested[n.key];
        });
      }

      KEYS_TO_EDGES_TABLE_CACHE.set(this, table);
    }

    return KEYS_TO_EDGES_TABLE_CACHE.get(this);
  }
  /**
   * 获取节点下的文本
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *     </block>
   *     <block type="container">
   *       <block type="paragraph" key="world-block">World</block>
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(element.text, 'HelloWorldCangjie');
   * ```
   */


  get text() {
    return this.getTexts().reduce((str, {
      text
    }) => `${str}${text}`, '');
  }
  /**
   * 获得最远的满足 `predicate` 断言的祖先节点
   * @param key
   * @param predicate
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container" key="container-1">
   *       <block type="container" key="container-2">
   *         <block type="paragraph">
   *           <text key="hello">Hello</text>
   *         </block>
   *       </block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getFurthsest('hello', (node) => node.type === 'container'),
   *   <block type="container" key="container-1" />
   * );
   * ```
   */


  getFurthsest(key, predicate) {
    const path = this.getPath(key);

    if (!path) {
      return null;
    }

    return this.getFurthsestByPath(path, predicate);
  }
  /**
   * 获得最远的满足 `predicate` 断言的祖先节点
   *
   * @param path
   * @param predicate
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container" key="container-1">
   *       <block type="container" key="container-2">
   *         <block type="paragraph">
   *           <text key="hello">Hello</text>
   *         </block>
   *       </block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getFurthsestByPath([0,0,0,0], (node) => node.type === 'container'),
   *   <block type="container" key="container-1" />
   * );
   * ```
   */


  getFurthsestByPath(path, predicate) {
    const ancestors = this.getAncestorsByPath(path);

    if (!ancestors || !ancestors.length) {
      return null;
    }

    const fursest = ancestors.find((node, index) => {
      if (node === this) {
        return false;
      }

      return predicate(node, index);
    }, []);
    return fursest || null;
  }
  /**
   * 获得最远的 Inline 祖先
   * @param key
   * @param returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <inline type="inline-block">
   *       <inline type="link">
   *         <text key="hello">Hello</text>
   *       </inline>
   *     </inline>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getFurthsestInline('hello'),
   *   <inline type="inline-block" />
   * );
   * ```
   */


  getFurthsestInline(key) {
    const node = this.getFurthsest(key, n => Inline.isInline(n));

    if (node?.isElement() && node.isInline()) {
      return node;
    }

    return null;
  }
  /**
   * 获得最远的 Block 祖先
   * @param key
   * @param returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container" key="container-1">
   *       <block type="container" data={{highlight: true}} key="container-2">
   *         <block type="paragraph">
   *           <text key="hello">Hello</text>
   *         </block>
   *       </block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getFurthsestBlock('hello'),
   *   <block type="container" key="container-1" />
   * );
   * ```
   */


  getFurthsestBlock(key) {
    const node = this.getFurthsest(key, n => Block.isBlock(n));

    if (node?.isElement() && node.isBlock()) {
      return node;
    }

    return null;
  }
  /**
   * 获得最远的、仅含有一个子孙的祖先
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container" key="multiple-child">
   *       <block type="container" key="only-child">
   *         <block type="paragraph">
   *           <text key="hello">Hello</text>
   *         </block>
   *       </block>
   *       <block type="paragraph">World</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getFurthestOnlyChildAncestor('hello'),
   *   <block type="container" key="only-child" />
   * );
   * ```
   */


  getFurthestOnlyChildAncestor(key) {
    const path = this.getPath(key);

    if (!path) {
      return null;
    }

    return this.getFurthestOnlyChildAncestorByPath(path);
  }
  /**
   * 获得最远的、仅含有一个子孙的祖先
   * @param path
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="container" key="multiple-child">
   *       <block type="container" key="only-child">
   *         <block type="paragraph">
   *           <text key="hello">Hello</text>
   *         </block>
   *       </block>
   *       <block type="paragraph">World</block>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getFurthestOnlyChildAncestorByPath([0,0,0,0]),
   *   (<block type="container" key="only-child" />)
   * );
   * ```
   */


  getFurthestOnlyChildAncestorByPath(path) {
    const ancestors = this.getAncestorsByPath(path);

    if (!ancestors) {
      return null;
    }

    const furthest = ancestors.slice(1) // ignore self
    .find(node => node instanceof Element$1 && node.nodes.length === 1);
    return furthest || null;
  }
  /**
   * 获得节点所有的祖先
   * @param key
   * @returns 祖先序列
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container">
   *     <block type="paragraph">
   *       <text key="hello">Hello</text>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getAncestors('hello'),
   *   [
   *     <block type="container" />,
   *     <block type="paragraph" />
   *   ]
   * )
   * ```
   */


  getAncestors(key) {
    const path = this.getPath(key);
    return this.getAncestorsByPath(path);
  }
  /**
   * 获得节点所有的祖先
   * @param path
   * @returns 祖先序列
   *
   * @example
   *
   * ```tsx
   * const element = (
   *   <block type="container">
   *     <block type="paragraph">
   *       <text key="hello">Hello</text>
   *     </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getAncestorsByPath([0,0]),
   *   [
   *     <block type="container" />,
   *     <block type="paragraph" />
   *   ]
   * )
   * ```
   */


  getAncestorsByPath(path) {
    if (!path || !this.getNodeByPath(path)) {
      return [];
    }

    const ancestors = [];
    path.forEach((_, index) => {
      const subPath = path.slice(0, index);
      const ancestor = this.getNodeByPath(subPath);

      if (ancestor?.isElement()) {
        ancestors.push(ancestor);
      }
    });
    return ancestors;
  }
  /**
   * 获得最近的满足 `predicate` 断言的祖先，祖先不包含当前节点
   * @param key
   * @param predicate
   * @returns
   *
   * @example
   *
   * ```tsx
   * const element = (
   *   <block type="container" key="container-1">
   *    <block type="container" key="container-2">
   *      <block type="paragraph">
   *        <text key="hello">Hello</text>
   *       </block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getClosest('hello', (node) => node.type === 'container'),
   *   <block type="container" key="container-2" />,
   * );
   *
   * assertEqual(
   *   element.getClosest('hello', (node) => node.key === 'container-1'),
   *   null,
   * );
   * ```
   */


  getClosest(key, predicate) {
    const path = this.getPath(key);
    return this.getClosestByPath(path, predicate);
  }
  /**
   * 获得最近的满足 `predicate` 断言的祖先，祖先不包含当前节点
   * @param key
   * @param predicate
   * @returns
   *
   * @example
   *
   * ```tsx
   * const element = (
   *   <block type="container" key="container-1">
   *    <block type="container" key="container-2">
   *      <block type="paragraph">
   *        <text key="hello">Hello</text>
   *       </block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getClosestByPath([0,0,0], (node) => node.type === 'container'),
   *   <block type="container" key="container-2" />,
   * );
   * assertEqual(
   *   element.getClosestByPath([0,0,0], (node) => node.key === 'container-1'),
   *   null,
   * );
   * ```
   */


  getClosestByPath(path, predicate) {
    if (!path) {
      return null;
    }

    const ancestors = this.getAncestorsByPath(path);
    const closest = ancestors.reverse().find((node, index, self) => {
      if (node === this) return false;
      return predicate(node, index, self);
    });
    return closest || null;
  }
  /**
   * 获得最近的 Inline
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container">
   *    <inline type="highlight">
   *      <inline type="link">
   *        <text key="hello">Hello</text>
   *       </inline>
   *    </inline>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getClosestInline('hello'),
   *   <inline type="link" />,
   * );
   * ```
   */


  getClosestInline(key) {
    const path = this.getPath(key);

    if (!path) {
      return null;
    }

    return this.getClosestInlineByPath(path);
  }
  /**
   * 获得最近的 Inline
   * @param path
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container">
   *    <inline type="highlight">
   *      <inline type="link">
   *        <text key="hello">Hello</text>
   *       </inline>
   *    </inline>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getClosestInlineByPath([0,0,0]),
   *   <inline type="link" />,
   * );
   * ```
   */


  getClosestInlineByPath(path) {
    const closest = this.getClosestByPath(path, n => Inline.isInline(n));

    if (closest?.isElement() && closest.isInline()) {
      return closest;
    }

    return null;
  }
  /**
   * 获取最近的 block 祖先
   * @param key
   * @returns
   * @throws NodeNotFoundError 若节点不存在，抛错
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container-1">
   *    <block type="container" key="container-2">
   *      <block type="paragraph">
   *        <text key="hello">Hello</text>
   *       </block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.assertClosestBlock('hello'),
   *   <block type="paragraph" />
   * );
   * assert(() =>element.assertClosestBlock('hello')).toThrow();
   * ```
   */


  assertClosestBlock(key) {
    const block = this.getClosestBlock(key);
    return assertBlock(block, 'assertClosestBlock', key);
  }
  /**
   * 获取最近的 block 祖先
   * @param key
   * @param returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container-1">
   *    <block type="container" key="container-2">
   *      <block type="paragraph">
   *        <text key="hello">Hello</text>
   *       </block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getClosestBlock('hello'),
   *   <block type="paragraph" />
   * );
   * assertEqual(
   *   element.getClosestBlock('hello'),
   *   null
   * );
   * ```
   */


  getClosestBlock(key) {
    const path = this.getPath(key);
    return path ? this.getClosestBlockByPath(path) : null;
  }
  /**
   * 获取最近的 block 祖先
   * @param path
   * @param returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container-1">
   *    <block type="container" key="container-2">
   *      <block type="paragraph">
   *        <text key="hello">Hello</text>
   *       </block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getClosestBlockByPath([0,0,0]),
   *   <block type="paragraph" />
   * );
   * assertEqual(
   *   element.getClosestBlockByPath([]),
   *   null
   * );
   * ```
   */


  getClosestBlockByPath(path) {
    const closest = this.getClosestByPath(path, n => Block.isBlock(n));

    if (closest?.isElement() && closest.isBlock()) {
      return closest;
    }

    return null;
  }
  /**
   * 获取最近的 block 祖先，如果节点本身就是 block，则返回节点
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container-1">
   *    <block type="container" key="container-2">
   *      <block type="paragraph" key="hello-block">
   *        <text key="hello">Hello</text>
   *       </block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getClosestBlockFromPoint('hello-block'),
   *   <block type="paragraph" />
   * );
   * assertEqual(
   *   element.getClosestBlockFromPoint('hello'),
   *   <block type="paragraph" />
   * );
   * ```
   */


  getClosestBlockFromPoint(key) {
    const node = this.getNode(key);

    if (node && node.isElement() && node.isBlock()) {
      return node;
    }

    return this.getClosestBlock(key);
  }
  /**
   * 获得最远的祖先
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container-1">
   *    <block type="container" key="container-2">
   *      <block type="paragraph" key="paragraph">
   *        <text key="hello">Hello</text>
   *       </block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getFurthestAncestor('hello'),
   *   <block type="container" key="container-2" />
   * );
   * assertEqual(
   *   element.getFurthestAncestor('container-1'),
   *   null,
   * );
   * ```
   */


  getFurthestAncestor(key) {
    const childPath = this.getPath(key);

    if (!childPath || !childPath.length) {
      return null;
    }

    const node = this.nodes[childPath[0]];
    return node;
  }
  /**
   * 获得最远的祖先
   * @param key
   * @throws NodeNotFoundError 节点不存在时，抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container-1">
   *    <block type="container" key="container-2">
   *      <block type="paragraph" key="paragraph">
   *        <text key="hello">Hello</text>
   *       </block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.assertFurthestAncestor('hello'),
   *   <block type="container" key="container-2" />
   * );
   * assert(
   *   () =>element.assertFurthestAncestor('container-1'),
   * ).toThrow();
   * ```
   */


  assertFurthestAncestor(key) {
    const node = this.getFurthestAncestor(key);
    return assertNode(node, 'assertFurthestAncestor', key);
  }
  /**
   * 获得节点的偏移位置，以文本为单位测算
   * @param key
   * @returns
   * @throws NodeNotFoundError 节点不存在时，抛错
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container-1">
   *    <block type="paragraph" key="world-block">World</block>
   *    <block type="container" key="container-2">
   *      <block type="paragraph" key="hello-block">
   *        <text key="hello">Hello</text>
   *       </block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(element.getOffset('hello'), 5);
   * assertEqual(element.getOffset('hello-block'), 5);
   * assertEqual(element.getOffset('world-block'), 0);
   * ```
   */


  getOffset(key) {
    this.assertNode(key); // Calculate the offset of the nodes before the highest child.

    const child = this.getFurthestAncestor(key);

    if (!child) {
      return 0;
    }

    const childIndex = this.nodes.findIndex(n => n === child);
    const offset = this.nodes.slice(0, childIndex).reduce((memo, n) => memo + n.text.length, 0);
    return key === child.key ? offset : offset + (child.isElement() ? child.getOffset(key) : 0);
  }
  /**
   * 获取父节点
   * @param key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container-1">
   *    <block type="container" key="container-2">
   *      <block type="paragraph" key="paragraph">
   *        <text key="hello">Hello</text>
   *       </block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getParent('hello'),
   *   <block type="paragraph" />
   * );
   *
   * assertEqual(
   *   element.getParent('container-1'),
   *   null,
   * );
   * ```
   */


  getParent(key) {
    const path = this.getPath(key);
    return this.getParentByPath(path);
  }
  /**
   * 获取父节点
   * @param key
   * @returns
   * @throws NodeNotFoundError 节点不存在时，抛错
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container-1">
   *    <block type="container" key="container-2">
   *      <block type="paragraph" key="paragraph">
   *        <text key="hello">Hello</text>
   *       </block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.assertParent('hello'),
   *   <block type="paragraph" />
   * );
   * assert(() => element.assertParent('container-1')).toThrow();
   * ```
   */


  assertParent(key) {
    const element = this.getParent(key);
    return assertElement(element, 'assertParent', key);
  }
  /**
   * 获取父节点
   * @param path
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container-1">
   *    <block type="container" key="container-2">
   *      <block type="paragraph" key="paragraph">
   *        <text key="hello">Hello</text>
   *       </block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getParentByPath([0,0,0]),
   *   <block type="paragraph" />
   * );
   *
   * assertEqual(
   *   element.getParentByPath([]),
   *   null,
   * );
   * ```
   */


  getParentByPath(path) {
    if (!path || !path.length || !this.getNodeByPath(path)) {
      return null;
    }

    const node = this.getNodeByPath(path.slice(0, -1));

    if (node?.isElement()) {
      return node;
    }

    return null;
  }
  /**
   * 获取公共祖先
   * @param a
   * @param b
   * @throws NodeNotFoundError 节点不存在，抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container">
   *    <block type="paragraph" key="hello">Hello</block>
   *    <block type="container">
   *      <block type="paragraph" key="world">World</block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.assertCommonAncestor('hello', 'world'),
   *   <block type="container" key="container" />
   * );
   * assertEqual(
   *   element.assertCommonAncestor('container', 'world'),
   *   <block type="container" key="container" />
   * );
   * assertEqual(
   *   () => element.assertCommonAncestor('not-exists', 'hello'),
   * ).toThrow();
   * ```
   */


  assertCommonAncestor(a, b) {
    const element = this.getCommonAncestor(a, b);
    return assertElement(element, 'assertCommonAncestor', `[${a}, ${b}]`);
  }
  /**
   * 获取公共祖先
   * @param a
   * @param b
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container">
   *    <block type="paragraph" key="hello">Hello</block>
   *    <block type="container">
   *      <block type="paragraph" key="world">World</block>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getCommonAncestor('hello', 'world'),
   *   <block type="container" key="container" />
   * );
   * assertEqual(
   *   element.getCommonAncestor('container', 'world'),
   *   <block type="container" key="container" />
   * );
   * assertEqual(
   *   element.getCommonAncestor('not-exists', 'hello'),
   *   null,
   * );
   * ```
   */


  getCommonAncestor(a, b) {
    const aPath = this.getPath(a);
    const bPath = this.getPath(b);

    if (!aPath || !bPath) {
      return null;
    }

    const node = this.getNodeByPath(Path.common(aPath, bPath));
    return node?.isElement() ? node : null;
  }
  /**
   * 获取 [`startKey`, `endKey`] 之间的所有 text
   * @param startKey 起始 text key
   * @param endKey   结束 text key
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container">
   *    <block type="paragraph">
   *      <text key="hello">Hello</text>
   *    </block>
   *    <block type="paragraph">
   *      <text key="world">World</text>
   *    </block>
   *    <block type="container">
   *      <block type="paragraph">
   *        <text key="cangjie">Cangjie</text>
   *      </block>
   *    </block>
   *    <block type="paragraph">
   *      <text key="footer">Footer</text>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getTextsBetweenPositions('hello', 'cangjie'),
   *   [
   *     <text key="hello">Hello</text>,
   *     <text key="world">World</text>,
   *     <text key="cangjie">Cangjie</text>,
   *   ]
   * );
   * ```
   */


  getTextsBetweenPositions(startKey, endKey) {
    const startText = this.getNode(startKey);

    if (!startText?.isText()) {
      return [];
    }

    if (startKey === endKey) return [startText];
    const endText = this.getNode(endKey);

    if (!endText?.isText()) {
      return [];
    }

    const texts = this.getTexts();
    const start = texts.indexOf(startText);
    const end = texts.indexOf(endText, start);
    const result = texts.slice(start, end + 1);
    return result;
  }
  /**
   * 获取节点树下所有 text
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container">
   *    <block type="paragraph">
   *      <text key="hello">Hello</text>
   *    </block>
   *    <block type="paragraph">
   *      <text key="world">World</text>
   *    </block>
   *    <block type="container">
   *      <block type="paragraph">
   *        <text key="cangjie">Cangjie</text>
   *      </block>
   *    </block>
   *    <block type="paragraph">
   *      <text key="footer">Footer</text>
   *    </block>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getTexts(),
   *   [
   *     <text key="hello">Hello</text>,
   *     <text key="world">World</text>,
   *     <text key="cangjie">Cangjie</text>,
   *     <text key="footer">Footer</text>
   *   ]
   * );
   * ```
   */


  getTexts() {
    const texts = [];
    this.forEachDescendant(node => {
      if (Text$1.isText(node)) {
        texts.push(node);
      }
    });
    return texts;
  }
  /**
   * 获取节点树下所有 inline
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container">
   *    <inline type="link">www.dingtalk.com</inline>
   *    <block type="paragraph">
   *      <inline type="link">www.dingding.com</inline>
   *    </block>
   *    <inline type="mention" data={{name: 'john'}}/>
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getInlines(),
   *   [
   *     <inline type="link">www.dingtalk.com</inline>,
   *     <inline type="link">www.dingding.com</type="link">,
   *     <inline type="mention" data={{name: 'john'}}/>,
   *   ]
   * );
   * ```
   */


  getInlines() {
    const inlines = [];
    this.forEachDescendant(node => {
      if (Inline.isLeafInline(node)) {
        inlines.push(node);
      }
    });
    return inlines;
  }
  /**
   * 获得节点树下所有类型为 `type` 的 inline
   * @param type
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container" key="container">
   *    <inline type="link">www.dingtalk.com</inline>
   *    <block type="paragraph">
   *      <inline type="link">www.dingding.com</inline>
   *    </block>
   *    <inline type="mention" data={{name: 'john'}} />
   *   </block>
   * );
   *
   * assertEqual(
   *   element.getInlinesByType('link'),
   *   [
   *     <inline type="link">www.dingtalk.com</inline>,
   *     <inline type="link">www.dingding.com</type="link">,
   *   ]
   * );
   * ```
   */


  getInlinesByType(type) {
    const inlines = [];
    this.forEachDescendant(node => {
      if (Inline.isLeafInline(node) && node.type === type) {
        inlines.push(node);
      }
    });
    return inlines;
  }
  /**
   * Map 节点树的所有子孙
   * @param map 节点映射函数
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container">
   *     <block type="paragraph">Hello</block>
   *     <block type="code">const foo = 'bar';</block>
   *     <block type="paragraph">World</block>
   *   </block>
   * );
   *
   * const newElement = element.mapDescendants(node => {
   *   if (node.isElement() && node.type === "paragraph") {
   *     return node.set('data', { highlight: true });
   *   }
   *   return node;
   * })
   *
   * assertEqual(
   *   newElement,
   *   <block type="container">
   *     <block type="paragraph" data={{ highlight: true }}>Hello</block>
   *     <block type="code">const foo = 'bar';</block>
   *     <block type="paragraph" data={{ highlight: true }}>World</block>
   *   </block>
   * )
   * ```
   */


  mapDescendants(map) {
    const newNodes = this.nodes.map(node => {
      let ret = node;

      if (Element$1.isElement(ret)) {
        ret = ret.mapDescendants(map);
      }

      return map(ret);
    });
    return this.set('nodes', newNodes);
  }
  /**
   * 遍历自身树下所有子节点：遍历顺序为前序遍历
   * @param iterator 遍历函数；如果返回 `false`，则停止遍历当前节点的子孙，防止冗余遍历引起的性能开销
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container">
   *     <block type="paragraph">Hello</block>
   *     <block type="code">const foo = 'bar';</block>
   *     <block type="paragraph">World</block>
   *   </block>
   * );
   *
   * const paragraphs: Block[] = [];
   * element.forEachDescendant(node => {
   *   if (node.isElement()) {
   *     if (node.type === "paragraph") {
   *       paragraphs.push(node);
   *     } else if (node.type === "code"){
   *       // code 下不再有 paragraph，可以提前终止对 code 的遍历
   *       return false;
   *     }
   *   }
   * });
   *
   * assertEqual(
   *   paragraphs,
   *   <block type="paragraph">Hello</block>
   *   <block type="paragraph">World</block>
   * )
   * ```
   */


  forEachDescendant(iterator) {
    let ret = null;
    this.nodes.forEach(child => {
      if (iterator(child) === false) {
        ret = false;
        return;
      }

      if (Element$1.isElement(child)) {
        ret = child.forEachDescendant(iterator);
      }
    });
    return ret;
  }
  /**
   * 判断子孙节点中，是否有符合条件的节点
   * @param predicate 遍历函数, 相比 forEachDescendant 会降低节点遍历开销
   * @returns {boolean}
   * @example
   * ```tsx
   * const element = (
   *   <block type="container">
   *     <block type="paragraph">Hello</block>
   *     <block type="code">const foo = 'bar';</block>
   *     <block type="paragraph">World</block>
   *   </block>
   * );
   *
   * const hasCode = element.someDescendants(node => {
   *   return node.isElement() && node.type === 'code';
   * });
   *
   * const hasCard = element.someDescendants(node => {
   *  return node.isElement() && node.type === 'card';
   * })
   *
   * assertEqual(hasCode, true);
   * assertEqual(hasCard, false);
   * );
   * ```
   */


  someDescendant(predicate) {
    return this.nodes.some(child => {
      if (predicate(child)) {
        return true;
      }

      if (Element$1.isElement(child)) {
        return child.someDescendant(predicate);
      }

      return false;
    });
  }
  /**
   * 过滤子孙，仅保留符合 `predicate` 断言的节点
   * @param predicate
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container">
   *     <block type="paragraph">Hello</block>
   *     <block type="code">const foo = 'bar';</block>
   *     <block type="paragraph">World</block>
   *   </block>
   * );
   *
   * const filtered = element.filterDescendants(node => {
   *   return node.isElement() && node.type !== 'code';
   * });
   *
   * assertEqual(
   *   filtered,
   *   [
   *     <block type="paragraph">Hello</block>,
   *     <block type="paragraph">World</block>
   *   ]
   * );
   * ```
   */


  filterDescendants(predicate) {
    const descendants = [];
    this.nodes.forEach(node => {
      if (predicate(node)) {
        descendants.push(node);
      }

      if (node instanceof Element$1) {
        descendants.push(...node.filterDescendants(predicate));
      }
    });
    return descendants;
  }
  /**
   * 查找节点树满足 `predicate` 断言的子孙
   * @param predicate
   * @returns
    * @example
   * ```tsx
   * const element = (
   *   <block type="container">
   *     <block type="paragraph">Hello</block>
   *     <block type="code">const foo = 'bar';</block>
   *     <block type="paragraph">World</block>
   *   </block>
   * );
   *
   * const code = element.findDescendant(node => {
   *   return node.isElement() && node.type === 'code'
   * });
   *
   * assertEqual(
   *   code,
   *   <block type="code">const foo = 'bar';</block>
   * );
   * ```
   */


  findDescendant(predicate) {
    let found = null;
    this.forEachDescendant(node => {
      // if the node has been found, then don't assign value to it.
      if (predicate(node) && !found) {
        found = node;
        return false;
      }

      return true;
    });
    return found;
  }
  /**
   * 是否 `node` 位于节点子孙中
   * @param node
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block type="container">
   *     <block type="paragraph" key="hello">Hello</block>
   *   </block>
   * );
   *
   * const hello = element.assertNode('hello');
   * const root = element.assertNodeByPath([]);
   * const cangjie = <block type="paragraph">World</block>;
   *
   * assertTrue(element.contains(hello));
   * assertFalse(element.contains(root));
   * assertFlase(element.contains(cangjie));
   * ```
   */


  contains(node) {
    if (node) {
      const found = this.findDescendant(child => child === node);

      if (found) {
        return true;
      }
    }

    return false;
  }
  /**
   * 替换节点子树中 `path` 位置的节点为 `node`
   * @param path
   * @param node
   * @param noSpacialEffect 是否操作将影响空间，若不影响空间，将不进行 Key-to-Path Table 的重构
   * @throws NodeNotFoundError 如果节点路径错误，将抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world-block">
   *       <text key="world">World</text>
   *     </block>
   *   </block>
   * );
   *
   * const newElement = element.replaceNode(
   *   [1],
   *   <block type="paragraph" key="cangjie-block">Cangjie</block>
   * );
   *
   * assertEqual(newElement, (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="cangjie-block">Cangjie</block>
   *   </block>
   * ));
   * ```
   */


  replaceNode(path, node, noSpacialEffect = false) {
    let p = path;
    let n = node;

    if (noSpacialEffect && Element$1.isElement(node)) {
      linkKeysToEdgesTable(this.getNodeByPath(path), node);
    }

    while (p.length) {
      const index = p[p.length - 1];
      p = p.slice(0, -1);
      const maybeParent = this.getNodeByPath(p);
      const parent = assertElement(maybeParent, 'Element.replaceNode', p);
      const nodes = [...parent.nodes];
      nodes[index] = n;
      n = parent.set('nodes', nodes);

      if (noSpacialEffect) {
        linkKeysToEdgesTable(parent, n);
      }
    }

    return n;
  }
  /**
   * 在对应 `path` 的 text 节点的 `offset` 位置，为长度为 `length` 的区间添加 `mark`
   *
   * @param path
   * @param offset 偏移位置
   * @param length 文本区间长度
   * @param mark
   * @throws NodeNotFoundError 如果节点路径错误，将抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">HelloWorld</text>
   *     </block>
   *   </block>
   * );
   *
   * const newElement = element.addMark(
   *   [0, 0],
   *   5,
   *   5,
   *   Mark.craete('bold')
   * );
   *
   * assertEqual(newElement, (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello<m type="world">World</m></text>
   *     </block>
   *   </block>
   * ));
   * ```
   */


  addMark(path, offset, length, mark) {
    const maybeNode = this.getNodeByPath(path);
    const node = assertText(maybeNode, 'Element.addMark', path);
    return this.replaceNode(path, node.addMark(offset, length, mark), true);
  }
  /**
   * 在对应 `path` 的 text 节点的 `offset` 位置，为长度为 `length` 的区间删除 `mark`
   * @param path
   * @param offset
   * @param length
   * @param mark
   * @throws NodeNotFoundError 如果节点路径错误，将抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *        <text key="hello">Hello<m type="world">World</m></text>
   *     </block>
   *   </block>
   * );
   *
   * const newElement = element.removeMark(
   *   [0, 0],
   *   5,
   *   5,
   *   Mark.craete('bold')
   * );
   *
   * assertEqual(newElement, (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">HelloWorld</text>
   *     </block>
   *   </block>
   * ));
   * ```
   */


  removeMark(path, offset, length, mark) {
    const maybeTextNode = this.getNodeByPath(path);
    const textNode = assertText(maybeTextNode, 'Element.addMark', path);
    return this.replaceNode(path, textNode.removeMark(offset, length, mark), true);
  }
  /**
   * 在对应 `path` 的 text 节点的 `offset` 位置，为长度为 `length` 的区间设置 mark data
   * @param path
   * @param offset
   * @param length
   * @param mark
   * @param properties
   * @throws NodeNotFoundError 如果节点路径错误，将抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *        <text key="hello">Hello
   *          <m type="world" data={{ weight: 500 }}>World</m>
   *        </text>
   *     </block>
   *   </block>
   * );
   *
   * const newElement = element.setMark(
   *   [0, 0],
   *   5,
   *   5,
   *   Mark.craete('bold'),
   *   { data: { weight: 700 } }
   * );
   *
   * assertEqual(newElement, (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *        <text key="hello">Hello
   *          <m type="world" data={{ weight: 700 }}>World</m>
   *        </text>
   *     </block>
   *   </block>
   * ));
   * ```
   */


  setMark(path, offset, length, mark, properties) {
    const maybeText = this.getNodeByPath(path);
    const text = assertText(maybeText, 'Element.setMark', path);
    return this.replaceNode(path, text.setMark(offset, length, mark, properties), true);
  }
  /**
   * 在对应 `path` 的 text 节点的 `offset` 位置，插入文本 `text`，并指定这段文本的 `marks`
   * @param path
   * @param offset
   * @param text
   * @param marks
   * @throws NodeNotFoundError 如果节点路径错误，将抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">Hello</block>
   *   </block>
   * );
   *
   * const newElement = element.insertText(
   *   [0, 0],
   *   5,
   *   'World',
   *   [Mark.craete('bold'), Mark.create('italic)],
   * );
   *
   * assertEqual(newElement, (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       Hello
   *       <m type="bold"><m type="italic">World</m></m>
   *     </block>
   *   </block>
   * ));
   * ```
   */


  insertText(path, offset, text, marks) {
    const maybeNode = this.getNodeByPath(path);
    const node = assertText(maybeNode, 'Element.insertText', path);
    return this.replaceNode(path, node.insertText(offset, text, marks), true);
  }
  /**
   * 在对应 `path` 的 text 节点的 `offset` 位置，删除指定的文本 `text`
   * @param path
   * @param offset
   * @param text
   * @throws NodeNotFoundError 如果节点路径错误，将抛错
   * @returns
   *
   * @exmple
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">HelloWorld</block>
   *   </block>
   * );
   *
   * const newElement = element.removeText(
   *   [0, 0],
   *   5,
   *   'World'
   * );
   *
   * assertEqual(newElement, (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">Hello</block>
   *   </block>
   * ));
   * ```
   */


  removeText(path, offset, text) {
    const maybeTextNode = this.getNodeByPath(path);
    const textNode = assertText(maybeTextNode, 'Element.removeText', path);
    return this.replaceNode(path, textNode.removeText(offset, text), true);
  }
  /**
   * 在 `path` 位置插入节点 `node`
   * @param path
   * @param node
   * @throws NodeNotFoundError 如果节点路径错误，将抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *   </block>
   * );
   *
   * const newElement = element.insertNode(
   *   [1],
   *   <block type="paragraph" key="world">World</block>
   * );
   *
   * assertEqual(newElement, (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       <text key="hello">Hello</text>
   *     </block>
   *     <block type="paragraph" key="world">World</block>
   *   </block>
   * ));
   * ```
   */


  insertNode(path, node) {
    const index = path[path.length - 1];
    const parentPath = path.slice(0, -1);
    const maybeParent = this.getNodeByPath(parentPath);
    const parent = assertElement(maybeParent, 'Element.insertNode', path);
    const nodes = [...parent.nodes];
    nodes.splice(index, 0, node);
    return this.replaceNode(parentPath, parent.set('nodes', nodes));
  }
  /**
   * 删除节点子树中 `path` 位置的节点
   * @param path
   * @throws NodeNotFoundError 如果节点路径错误，将抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">Hello</block>
   *     <block type="container" key="container">
   *        <block type="paragraph" key="world-block">World</block>
   *        <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * const newElement = element.removeNode([1,0]);
   *
   * assertEqual(newElement, (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">Hello</block>
   *     <block type="container" key="container">
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * ));
   * ```
   */


  removeNode(path) {
    const node = this.getNodeByPath(path);
    assertNode(node, 'Element.removeNode', path);
    const index = path[path.length - 1];
    const parentPath = path.slice(0, -1);
    const maybeParent = this.getNodeByPath(parentPath);
    const parent = assertElement(maybeParent, 'Element.insertNode', path);
    const nodes = [...parent.nodes];
    nodes.splice(index, 1);
    return this.replaceNode(parentPath, parent.set('nodes', nodes));
  }
  /**
   * 将 `path` 位置的节点，合并到其前一个兄弟节点
   * @param path
   * @throws NodeNotFoundError 如果节点路径错误，将抛错
   * @throws Error 如果节点与兄弟节点类型不一致，将抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">Hello</block>
   *     <block type="paragraph" key="world-block">World</block>
   *   </block>
   * );
   *
   * const newElement = element.mergeNode([1]);
   *
   * assertEqual(newElement, (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">
   *       HelloWorld
   *     </block>
   *   </block>
   * ));
   * ```
   */


  mergeNode(path) {
    const maybeB = this.getNodeByPath(path);
    const b = assertNode(maybeB, 'Element.mergeNode', path);
    const lastIndex = path[path.length - 1];

    if (lastIndex === 0) {
      throw new Error(`Unable to merge node because it has no previous sibling: ${b}`);
    }

    const withPath = Path.decrement(path);
    const maybeA = this.getNodeByPath(withPath);
    const aNode = assertNode(maybeA, 'Element.mergeNode', withPath);
    const a = aNode.toSubType();

    if (a.constructor !== b.constructor) {
      throw new Error(`Unable to merge two different kinds of nodes: ${a} and ${b}`);
    }

    const newNode = a.isText() ? a.mergeText(b) : a.set('nodes', [...a.nodes, ...b.nodes]);
    return this.removeNode(path).replaceNode(withPath, newNode);
  }
  /**
   * 对指定 `path` 位置的节点在 `position` 处进行拆分
   * @param path
   * @param position 拆分位置。如果是 text 节点，代表文字的偏移量；如果是 element 节点，代表子节点 index
   * @param properties 拆分 element 后，为拆分的节点设置 properties
   * @throws NodeNotFoundError 如果节点路径错误，将抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block>
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *       <block type="paragraph" key="world-block">World</block>
   *     </block>
   *   </block>
   * );
   *
   * // Split Element
   * const elementSplitted = element.splitNode([0], 1, { data: { highlight: true } });
   *
   * assertEqual(newElement, (
   *   <block>
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">Hello</block>
   *     </block>
   *     <block type="container" data={{ highlight: true }}>
   *       <block type="paragraph" key="world-block">World</block>
   *     </block>
   *   </block>
   * ));
   *
   * // Split Text
   * const textSplitted = element.splitNode([0,0], 3);
   *
   * assertEqual(newElement, (
   *   <block>
   *     <block type="container">
   *       <block type="paragraph" key="hello-block">
   *         <text>Hel</text><text>lo</text></block>
   *       </block>
   *     <block type="paragraph" key="world-block">World</block>
   *   </block>
   * ));
   * ```
   */


  splitNode(path, position, properties) {
    const maybeNode = this.getNodeByPath(path);
    const n = assertNode(maybeNode, 'Element.splitNode', path);
    const node = n.toSubType();
    let a;
    let b;

    if (node.isText()) {
      [a, b] = node.splitText(position);
    } else {
      const element = node;
      const befores = element.nodes.slice(0, position);
      const afters = element.nodes.slice(position);
      a = element.set('nodes', befores);
      b = element.set('nodes', afters).regenerateKey();
    }

    if (properties && !Text$1.isText(node)) {
      b = b.merge(properties);
    }

    return this.removeNode(path).insertNode(path, b).insertNode(path, a);
  }
  /**
   * 将 `path` 位置的节点移动到新的位置 `newPath`
   * @param path
   * @param newPath
   * @throws NodeNotFoundError 如果节点路径错误，将抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">Hello</block>
   *     <block type="container" key="container">
   *        <block type="paragraph" key="world-block">World</block>
   *        <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * );
   *
   * const newElement = element.moveNode([1,0], [1]);
   *
   * assertEqual(newElement, (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block">Hello</block>
   *     <block type="paragraph" key="world-block">World</block>
   *     <block type="container" key="container">
   *       <block type="paragraph" key="cangjie-block">Cangjie</block>
   *     </block>
   *   </block>
   * ));
   * ```
   */


  moveNode(path, newPath) {
    const maybeNode = this.getNodeByPath(path);
    const node = assertNode(maybeNode, 'Element.moveNode', path);
    const newParentPath = newPath.slice(0, -1);
    const newParent = this.getNodeByPath(newParentPath);
    assertElement(newParent, 'Element.moveNode', path);
    const isYounger = Path.isYounger(path, newPath);
    const isSibling = Path.isSibling(path, newPath); // If the old path ends above and before a node in the new path, then
    // removing it will alter the target, so we need to adjust the new path.

    if (isYounger && !isSibling) {
      // eslint-disable-next-line no-param-reassign
      newPath = Path.decrement(newPath, 1, path.length - 1);
    }

    return this.removeNode(path).insertNode(newPath, node);
  }
  /**
   * 对指定 `path` 位置的节点设置属性
   * @param path
   * @param properties
   * @throws NodeNotFoundError 如果节点路径错误，将抛错
   * @returns
   *
   * @example
   * ```tsx
   * const element = (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block" data={{ highlight: true }}>Hello</block>
   *     <block type="paragraph" key="world-block">World</block>
   *   </block>
   * );
   *
   * const newElement = element.setNode([0], { data: { highlight: false } });
   *
   * assertEqual(newElement, (
   *   <block key="own">
   *     <block type="paragraph" key="hello-block" data={{ highlight: false }}>Hello</block>
   *     <block type="paragraph" key="world-block">World</block>
   *   </block>
   * ));
   * ```
   */


  setNode(path, properties) {
    const maybeElement = this.getNodeByPath(path);
    let element = assertElement(maybeElement, 'Element.setNode', path);
    element = element.merge(properties);
    return this.replaceNode(path, element, true);
  }

}

/**
 * @packageDocumentation
 * @module Models
 */
/**
 * @ignore
 */

class Inline extends Element$1 {
  static create(properties) {
    if (Inline.isInline(properties)) {
      return properties;
    }

    let props = properties;

    if (typeof props === 'string') {
      props = {
        type: props
      };
    }

    if (isPlainObject__default["default"](props)) {
      const {
        type,
        key = keyUtils.create(),
        data = {},
        nodes = [Text$1.create()]
      } = props;

      if (typeof type !== 'string') {
        throw new Error('`Inline.create` requires a `type` string.');
      }

      return new Inline({
        type,
        key,
        data,
        nodes
      });
    }

    throw new Error(`\`Inline.create\` only accepts objects, string or blocks, but you passed it: ${props}`);
  }

  static childFromJSON(node) {
    const {
      klass
    } = node;

    if (klass === 'inline') {
      return Inline.fromJSON(node);
    }

    if (klass === 'text') {
      return Text$1.fromJSON(node);
    }

    throw new Error('`Inline.childFromJSON` requires a valid `klass`(inline|text) string.');
  }

  static fromJSON(json) {
    const {
      nodes
    } = json;
    return Inline.create({ ...json,
      nodes: nodes ? nodes.map(Inline.childFromJSON) : undefined
    });
  }

  static isInline(maybeInline) {
    return maybeInline instanceof Inline;
  }
  /**
   * 是否是叶子inline
   */


  static isLeafInline(maybeLeafInline) {
    if (!this.isInline(maybeLeafInline)) {
      return false;
    }

    for (const child of maybeLeafInline.nodes) {
      if (child.isElement()) {
        return false;
      }
    }

    return true;
  }

  constructor(props) {
    super(props);
    this.type = void 0;
    this.nodes = void 0;
    const {
      type,
      nodes
    } = props;
    this.type = type;
    this.nodes = nodes;
    this.freeze();
  }

  merge(props) {
    return new Inline({
      type: this.type,
      key: this.key,
      data: this.data,
      nodes: this.nodes,
      ...props
    });
  }

  set(key, value) {
    return this.merge({
      [key]: value
    });
  }

  toJSON(options) {
    const object = {
      klass: 'inline',
      type: this.type,
      data: { ...this.data
      },
      nodes: this.nodes.map(node => node.toJSON(options))
    };

    if (options?.preserveKeys) {
      object.key = this.key;
    }

    return object;
  }

}

/**
 * @packageDocumentation
 * @module Models
 */
class Block extends Element$1 {
  static create(properties) {
    if (Block.isBlock(properties)) {
      return properties;
    }

    const props = typeof properties === 'string' ? {
      type: properties
    } : properties;

    if (isPlainObject__default["default"](props)) {
      const {
        type,
        key = keyUtils.create(),
        data,
        nodes = [Text$1.create()]
      } = props;

      if (typeof type !== 'string') {
        throw new Error('`Block.create` requires a `type` string.');
      }

      return new Block({
        type,
        key,
        data: data,
        nodes
      });
    }

    throw new Error(`\`Block.create\` only accepts objects, string or blocks, but you passed it: ${props}`);
  }

  static childFromJSON(node) {
    const {
      klass
    } = node;

    if (klass === 'block') {
      return Block.fromJSON(node);
    }

    return Inline.childFromJSON(node);
  }

  static fromJSON(json) {
    const {
      nodes
    } = json;
    return Block.create({ ...json,
      // @ts-ignore
      nodes: nodes ? nodes.map(Block.childFromJSON) : nodes
    });
  }

  static isBlock(maybeBlock) {
    return maybeBlock instanceof Block;
  }

  static isBlocks(maybeBlocks) {
    return maybeBlocks.every(Block.isBlock);
  }
  /**
   * 是否是叶子 block
   */


  static isLeafBlock(maybeLeafBlock) {
    const {
      nodes
    } = maybeLeafBlock;

    if (!this.isBlock(maybeLeafBlock)) {
      return false;
    }

    if (!nodes.length) {
      return true;
    }

    const first = nodes[0];
    return !this.isBlock(first);
  }
  /**
   * 循环获取所有的叶子 block 节点
   */


  static getBlocks(nodes) {
    return nodes.reduce((array, child) => {
      if (!Block.isBlock(child)) {
        return array;
      }

      if (!Block.isLeafBlock(child)) {
        return array.concat(child.getBlocks());
      }

      array.push(child);
      return array;
    }, []);
  }
  /**
   * 循环获取所有的满足指定 type 的叶子 block 节点
   */


  static getBlocksByType(nodes, type) {
    return nodes.reduce((array, node) => {
      if (!Block.isBlock(node)) {
        return array;
      } else if (Block.isLeafBlock(node) && node.type === type) {
        array.push(node);
        return array;
      } else {
        return array.concat(node.getBlocksByType(type));
      }
    }, []);
  }

  constructor(props) {
    super(props);
    this.type = void 0;
    const {
      type
    } = props;
    this.type = type;
    this.freeze();
  }

  merge(props) {
    return new Block({
      type: this.type,
      key: this.key,
      data: this.data,
      nodes: this.nodes,
      ...props
    });
  }

  set(key, value) {
    return this.merge({
      [key]: value
    });
  }
  /**
   * 自身的 nodes 中，是否有 block 类型的节点
   */


  hasBlockChildren() {
    return this.nodes.some(b => Block.isBlock(b));
  }
  /**
   * 获取自身树下所有的叶子 block 节点
   */


  getBlocks() {
    return Block.getBlocks(this.nodes);
  }
  /**
   * 循环获取所有的满足指定 type 的叶子 block 节点
   */


  getBlocksByType(type) {
    return Block.getBlocksByType(this.nodes, type);
  }

  toJSON(options) {
    const object = {
      klass: 'block',
      type: this.type,
      data: { ...this.data
      },
      nodes: this.nodes.map(node => node.toJSON(options))
    };

    if (options?.preserveKeys) {
      object.key = this.key;
    }

    return object;
  }

}
Block.DEFAULT_TYPE = 'paragraph';

/**
 * @packageDocumentation
 * @module Controller
 */

/**
 * @ignore
 */

/**
 * @ignore
 */
exports.PendingType = void 0;

(function (PendingType) {
  PendingType["input"] = "input";
  PendingType["selection"] = "selection";
})(exports.PendingType || (exports.PendingType = {}));

let PendingConfigType;

(function (PendingConfigType) {
  PendingConfigType["input"] = "input";
  PendingConfigType["selection"] = "selection";
})(PendingConfigType || (PendingConfigType = {}));

/**
 * 消费变更产生的热区
 * @param controller
 * @param onHots
 * @param pendingType
 * @param disabled 是否禁用监听 
 */

function useHots(controller, onHots, pendingType, disabled) {
  React.useEffect(() => {
    if (!controller.enableHots || disabled) {
      return () => {};
    }

    const handleOnHots = hots => {
      if (pendingType && controller.pendingType !== pendingType) {
        return;
      }

      onHots(hots);
    };

    const sub = controller.hots$.subscribe(handleOnHots);
    return () => {
      sub.unsubscribe();
    };
  }, [controller, onHots, pendingType, disabled]);
}
/**
 * 在下一帧时，消费变更产生的热区。当我们期望在热区重渲完成时，再消费热区信息时，可以使用这个 Hook.
 *
 * ## Example
 *
 * ```tsx
 * const Toolbar = props => {
 *   // 假设我们期望热区重渲完成后，获得热区对布局的影响
 *   const onHotsNextFrame = React.useCallback((hots) => {
 *     if (hots.find(hot => hot.node?.type === 'table-cell')) {
 *        const rects = getBoundingClientRect(domRef.current);
 *        // ...
 *     }
 *   }, []);
 *
 *   useHotsAtTheStartOfNextFrame(controller, onHotsNextFrame);
 * }
 * ```
 * @param controller
 * @param onHotsNextFrame
 * @param pendingType
 * @param disabled
 */

function useHotsAtTheStartOfNextFrame(controller, onHotsNextFrame, pendingType, disabled) {
  const animId = React__default["default"].useRef(null);
  const onHots = React.useCallback(hots => {
    animId.current = window.requestAnimationFrame(() => {
      onHotsNextFrame(hots);
    });
  }, [onHotsNextFrame]);
  React__default["default"].useEffect(() => {
    return () => {
      if (animId.current) {
        window.cancelAnimationFrame(animId.current);
      }
    };
  }, []);
  useHots(controller, onHots, pendingType, disabled);
}
/**
 * 消费选区 Pending 的热区 
 * @param controller 
 * @param onHots 
 */

function useSelectingHots(controller, onHots) {
  useHots(controller, onHots, exports.PendingType.selection);
}
/**
 * 在下一帧消费选区 Pending 的热区  
 * @param controller 
 * @param onHotsNextFrame 
 */

function useSelectingHotsAtTheStartOfNextFrame(controller, onHotsNextFrame) {
  useHotsAtTheStartOfNextFrame(controller, onHotsNextFrame, exports.PendingType.selection);
}
/**
 * 消费输入 Pending 的热区 
 * @param controller 
 * @param onHots 
 */

function useInputingHots(controller, onHots) {
  useHots(controller, onHots, exports.PendingType.input);
}
/**
 * 在下一帧消费输入 Pending 的热区 
 * @param controller 
 * @param onHotsNextFrame 
 */

function useInputingHotsAtTheStartOfNextFrame(controller, onHotsNextFrame) {
  useHotsAtTheStartOfNextFrame(controller, onHotsNextFrame, exports.PendingType.input);
}

/**
 * @packageDocumentation
 * @ignore
 */
const isSupportProxy = typeof Proxy !== 'undefined';

/**
 * 获得 Controller 实例，如果组件严格期望在编辑器内容变更后，不进行重渲，仅消费 Controller 实例，请使用 `useControllerStatic`
 * @param options 
 * @returns 
 */
function useController(options) {
  const {
    maxPending = 0
  } = options || {};
  const context = React__namespace.useContext(ControllerContext);

  if (!context) {
    throw new Error("The `useController` hook must be used inside the <Cangjie.Provider> component's context.");
  }

  const isRendering = React__namespace.useRef(true);
  isRendering.current = true;
  React__namespace.useLayoutEffect(() => {
    isRendering.current = false;
  });
  const [, forceRender] = React__namespace.useReducer(s => s + 1, 0);
  const hasConsumedValue = React__namespace.useRef(false);
  const lastConsumedValue = React__namespace.useRef(null);
  const controller = React__namespace.useMemo(() => !isSupportProxy ? context.controller : new Proxy(context.controller, {
    get(ctrl, prop) {
      if (prop === 'value' && isRendering.current) {
        hasConsumedValue.current = true;
        lastConsumedValue.current = ctrl[prop];
      }

      return ctrl[prop];
    }

  }), [context.controller]);
  const debouncedRerender = React__namespace.useMemo(() => {
    if (Number.isFinite(maxPending)) {
      return lodash.debounce(forceRender, maxPending);
    }

    return lodash.noop;
  }, [maxPending]);
  React__namespace.useEffect(() => {
    const sub = context.subject.subscribe(() => {
      if ((!isSupportProxy || hasConsumedValue.current) && context.controller.value !== lastConsumedValue.current) {
        forceRender();
      }
    });
    return sub.unsubscribe;
  }, [context]);
  useHots(controller, debouncedRerender);
  return controller;
}

const _createElement$r = React__namespace.createElement;
function connectController(Component) {
  return props => {
    const controller = useController(); // @ts-ignore

    return /*#__PURE__*/_createElement$r(Component, _extends__default["default"]({}, props, {
      controller: controller
    }));
  };
}

/**
 * @packageDocumentation
 * @module Models
 */
exports.OperationType = void 0;

(function (OperationType) {
  OperationType["AddMark"] = "add_mark";
  OperationType["InsertNode"] = "insert_node";
  OperationType["InsertText"] = "insert_text";
  OperationType["MergeNode"] = "merge_node";
  OperationType["MoveNode"] = "move_node";
  OperationType["RemoveMark"] = "remove_mark";
  OperationType["RemoveNode"] = "remove_node";
  OperationType["RemoveText"] = "remove_text";
  OperationType["SetMark"] = "set_mark";
  OperationType["SetNode"] = "set_node";
  OperationType["SetSelection"] = "set_selection";
  OperationType["SplitNode"] = "split_node";
})(exports.OperationType || (exports.OperationType = {}));

/**
 * op取反
 *
 * move_node 路径矫正说明：
 *
 * Given the document tree:
 * ```txt
 *         []
 *        / \
 *     [0]   [1]
 *            |
 *          [1,0]
 *            |
 *         [1,0,0]
 *         __/ \__
 * [1,0,0,0]      [1,0,0,1]
 * ```
 * case one:
 * ```ts
 * op.path = [0]
 * op.newPath = [1,0,0,1]
 * Path.isYounger([0], [1,0,0,1])   // true
 * // when path is been moved, the new path should decrement
 * Path.decrement([1,0,0,1], 1, 0) // [0,0,0,1]
 * // final inverted op: [0,0,0,1] -> [0]
 * ```
 * case two:
 * ```ts
 * op.path = [1,0,0,1]
 * op.newPath = [1]
 * Path.isAncestor([1], [1,0,0,1])   // true
 * // when move node to it's ancestor, the new path should increment
 * Path.increment([1,0,0,1], 1, 0) // [2,0,0,1]
 * // final inverted op: [2,0,0,1] -> [1]
 * ```
 */
function invert(operation) {
  const {
    type
  } = operation;

  if (type === 'add_mark') {
    return { ...operation,
      type: 'remove_mark'
    };
  }

  if (type === 'insert_node') {
    return { ...operation,
      type: 'remove_node'
    };
  }

  if (type === 'insert_text') {
    return { ...operation,
      type: 'remove_text'
    };
  }

  if (type === 'merge_node') {
    const {
      path
    } = operation;
    const invertedPath = Path.decrement(path);
    return { ...operation,
      type: 'split_node',
      path: invertedPath
    };
  }

  if (type === 'move_node') {
    const {
      path,
      newPath
    } = operation;

    if (Path.isEqual(path, newPath)) {
      return operation;
    }

    let invertedPath = newPath;
    let invertedNewPath = path;
    const isSibling = Path.isSibling(path, newPath); // If the node's old position was a left sibling of an ancestor of
    // its new position, we need to adjust part of the path by -1.
    // If the node's new position is an ancestor of the old position,
    // or a left sibling of an ancestor of its old position, we need
    // to adjust part of the path by 1.

    if (!isSibling) {
      const isYounger = Path.isYounger(path, newPath);
      const isInvertedYounger = Path.isYounger(invertedPath, invertedNewPath);
      const isInvertedAncestor = Path.isAncestor(invertedPath, invertedNewPath);

      if (isYounger) {
        invertedPath = Path.decrement(newPath, 1, path.length - 1);
      } else if (isInvertedYounger || isInvertedAncestor) {
        invertedNewPath = Path.increment(path, 1, newPath.length - 1);
      }
    }

    return { ...operation,
      path: invertedPath,
      newPath: invertedNewPath
    };
  }

  if (type === 'remove_mark') {
    return { ...operation,
      type: 'add_mark'
    };
  }

  if (type === 'remove_node') {
    return { ...operation,
      type: 'insert_node'
    };
  }

  if (type === 'remove_text') {
    return { ...operation,
      type: 'insert_text'
    };
  }

  if (type === 'set_mark') {
    const {
      mark,
      properties
    } = operation;
    const invertedMark = mark.merge(properties);
    const invertedProperties = Object.keys(properties).reduce((p, key) => ({ ...p,
      [key]: mark[key]
    }), {});
    return { ...operation,
      mark: invertedMark,
      properties: invertedProperties
    };
  }

  if (type === 'set_node') {
    const {
      properties,
      prevProperties
    } = operation;
    return { ...operation,
      properties: prevProperties || {},
      prevProperties: properties
    };
  }

  if (type === 'set_selection') {
    const {
      selection,
      prevSelection
    } = operation;
    return { ...operation,
      selection: prevSelection,
      prevSelection: selection
    };
  }

  if (type === 'split_node') {
    const {
      path
    } = operation;
    const invertedPath = Path.increment(path);
    return { ...operation,
      type: 'merge_node',
      path: invertedPath
    };
  }

  throw new Error(`Unknown operation type: "${type}".`);
}

const Operation = {
  invert
}; // eslint-disable-next-line no-undef

/**
 * @packageDocumentation
 * @module Models
 */
const PATH_CACHE = new WeakMap();
class Point extends ImmutableRecord {
  static createFromParams(key, where) {
    if (typeof where === 'number') {
      return TextPoint.create({
        key,
        offset: where
      });
    } else {
      return EdgePoint.create({
        key,
        edge: where
      });
    }
  }

  static create(props) {
    if (props instanceof Point) {
      return props.toSubType();
    }

    if ('edge' in props) {
      return EdgePoint.create(props);
    } else {
      return TextPoint.create(props);
    }
  }

  static fromJSON(json) {
    if ('offset' in json) {
      return TextPoint.fromJSON(json);
    }

    return EdgePoint.fromJSON(json);
  }

  constructor(props) {
    super();
    this.key = void 0;
    const {
      key
    } = props;
    this.key = key;
  }
  /**
   * 创建一个新的 Point，并移到 node 的第一个子节点的起始位置
   */


  moveToStartOfNode(node) {
    const firstNode = node.getFirstNode();
    return TextPoint.create({
      key: firstNode.key,
      offset: 0
    });
  }
  /**
   * 创建一个新的 Point，并移到 node 的最后一个子节点的终点位置
   */


  moveToEndOfNode(node) {
    const lastNode = node.getLastNode();
    return TextPoint.create({
      key: lastNode.key,
      offset: lastNode.text.length
    });
  }
  /**
   * 是否在 node 的第一个节点的起始位置
   */


  isTextPoint() {
    return this instanceof TextPoint;
  }

  isEdgePoint() {
    return this instanceof EdgePoint;
  }

  moveBackward() {
    return this.toSubType();
  }

  moveForward() {
    return this.toSubType();
  }

  toSubType() {
    if (this.isTextPoint()) {
      return this;
    } else if (this.isEdgePoint()) {
      return this;
    }

    throw new Error(`Target is not a valid point: ${this}`);
  }

  convertToTextPoint(document) {
    const point = this.toSubType();

    if (point.isTextPoint()) {
      return point;
    }

    const node = document.getNode(this.key);
    let textNode = point.edge === EdgePoint.BEFORE ? node?.getFirstText() : node?.getLastText();

    if (!textNode) {
      textNode = point.edge === EdgePoint.BEFORE ? document.getFirstNode() : document.getLastNode();
    }

    const {
      key
    } = textNode;
    const offset = point.edge === EdgePoint.BEFORE ? 0 : textNode?.text.length;
    return TextPoint.create({
      key,
      offset
    });
  }
  /**
   * 是否在 node 内部
   */


  isInNode(node) {
    if (node.isText() && node.key === this.key) return true;
    if (node.isElement() && node.getNode(this.key)) return true;
    return false;
  } // NOTE: point.getPathIn(document) === document.getPath(point.key)
  // PERF: ~5ms in Huge Document story
  //       Why do not memoize `document.getPath`? Node's path will not be re-get frequently, but Point's path does.


  getPathIn(document) {
    if (!PATH_CACHE.has(this)) {
      PATH_CACHE.set(this, new WeakMap());
    }

    const DOCUMENT_TO_PATH_CACHE = PATH_CACHE.get(this);

    if (!DOCUMENT_TO_PATH_CACHE.has(document)) {
      DOCUMENT_TO_PATH_CACHE.set(document, document.getPath(this.key));
    }

    return DOCUMENT_TO_PATH_CACHE.get(document);
  }

}
class TextPoint extends Point {
  static create(props) {
    if (props instanceof TextPoint) {
      return props;
    }

    if (isPlainObject__default["default"](props)) {
      const {
        key,
        offset
      } = props;
      return new TextPoint({
        key,
        offset
      });
    }

    throw new Error(`\`Point.create\` only accepts objects or points, but you passed it: ${props}`);
  }

  static fromJSON(json) {
    return TextPoint.create({ ...json,
      key: json.key || 'NONE'
    });
  }

  get viewKey() {
    return `${this.key}-${this.offset}`;
  }

  constructor(props) {
    super(props);
    this.offset = void 0;
    const {
      offset
    } = props;
    this.offset = offset;
    this.freeze();
  }
  /**
   * 把 offset 加 n，并返回一个新的 Point。
   * @n 移动的个数，可以为正/负值，默认为 1；如果 n=0，则返回自身。
   */


  moveForward(n = 1) {
    if (n === 0) {
      return this;
    }

    if (n < 0) {
      return this.moveBackward(-n);
    }

    return this.set('offset', this.offset + n);
  }
  /**
   * 把 offset 减 n，并返回一个新的 Point。
   * @n 移动的个数，可以为正/负值，默认为 1；如果 n=0，则返回自身。
   */


  moveBackward(n = 1) {
    if (n === 0) {
      return this;
    }

    if (n < 0) {
      return this.moveForward(-n);
    }

    return this.set('offset', this.offset - n);
  }
  /**
   * 创建一个新的 Point
   * @offset 默认是 0
   */


  moveTo(key, offset = 0) {
    return this.merge({
      key,
      offset
    });
  }
  /**
   * 是否在 node 的第一个节点的起始位置
   */


  isAtStartOfNode(node) {
    if (this.offset !== 0) return false;
    const first = node.getFirstNode();
    return this.key === first.key;
  }
  /**
   * 是否在 node 的最后一个节点的终点位置
   */


  isAtEndOfNode(node) {
    const last = node.getLastNode();
    return this.key === last.key && this.offset === last.text.length;
  }

  merge(props) {
    return new TextPoint({
      key: this.key,
      offset: this.offset,
      ...props
    });
  }

  set(key, value) {
    return this.merge({
      [key]: value
    });
  }

  toJSON(options) {
    const object = {
      klass: 'point',
      offset: this.offset
    };

    if (options?.preserveKeys) {
      object.key = this.key;
    }

    return object;
  }

}
class EdgePoint extends Point {
  static create(props) {
    if (props instanceof EdgePoint) {
      return props;
    }

    if (isPlainObject__default["default"](props)) {
      const {
        key,
        edge
      } = props;
      return new EdgePoint({
        key,
        edge
      });
    }

    throw new Error(`\`Point.create\` only accepts objects or points, but you passed it: ${props}`);
  }

  static fromJSON(json) {
    return EdgePoint.create({ ...json,
      key: json.key || 'NONE'
    });
  }

  get viewKey() {
    return `${this.key}-${this.edge}`;
  }

  constructor(props) {
    super(props);
    this.edge = void 0;
    const {
      edge
    } = props;
    this.edge = edge;
    this.freeze();
  }
  /**
   * 是否在 node 的第一个节点的起始位置
   */


  isAtStartOfNode(node) {
    return this.key === node.key && this.edge === EdgePoint.BEFORE;
  }
  /**
   * 是否在 node 的最后一个节点的终点位置
   */


  isAtEndOfNode(node) {
    return this.key === node.key && this.edge === EdgePoint.AFTER;
  }

  merge(props) {
    return new EdgePoint({
      key: this.key,
      edge: this.edge,
      ...props
    });
  }

  set(key, value) {
    return this.merge({
      [key]: value
    });
  }

  toJSON(options) {
    const object = {
      klass: 'point',
      edge: this.edge
    };

    if (options?.preserveKeys) {
      object.key = this.key;
    }

    return object;
  }

}
EdgePoint.BEFORE = 'before';
EdgePoint.AFTER = 'after';

/**
 * @packageDocumentation
 * @ignore
 */
var classesmjs = {
  "trie": "ABAOAAAAAAAQmQAAAYAIf/ftmwuoFUUYx+d4z7nnHO+rUiF8gFHRBQ00CyQpJEtMUiwSSjLkViBlIqUhXnuoEXXpaWVkJFFWpj3EQCN6UdiVIKw0C4QSxbDkhkSKlUL/ZXe709yZ2XnvUfeDHzM7M/t937xn9+yZ3kTIDWAO6ALLwEoqzTbsAavBk2CNQvl14A1J/kawBXwIPgdfge/Aj2AfVe4g6AN/gL8BKRNSA1XQAYaCkeBF8ApYX47vTdkDLkDa2+BdsBV8Ar4EvWAn+AH8DPaBQ6CPuj4KTiblKxVC2irx/cMQvoNwVCW2cyHCOq4vrvTrn4D4pOR6CsJrwFjKfnTfDKSNq8Xx2YjfUun3fR7i85PrBQjvTeLdCFeBHjCUKr8a8bXgVbCx8v92uLHWz9yE28CSBLqsjDcVy7lmSyXmr3JMlPYBrj9L6jmf6ffxSN/OtMHXFbH+3UneXoQHkvgjYEii9zDSfgfHwAlQbiaktTnOG5KEw5sH6h2NtE5Oeko0r8ZJ8lVZCD8XR+MMumZS6VEdnkjq8zjVz88ivlaj319G2fVU+TT+FsL3JHq2SfI+Rt520At2gt0Ue5nr/eBXcAQcB/+AprpeG7Volqc5J7l3uIGOiUz/7uKMAdv+j7iSsjPVckyNtmirgoKCgoKCgoKCgoKCggIVZjTH79LS64WS9zYps3HPXOqZt7dKyGU1Qu5A2t1J+hKEy8HsWvw+cAXiVyD+WJL/FMIXwEvJ9WsIjyHclPEs/T7yH4CeB8FDYAVYCVaBh2tFXpFX5BV5RZ7rvLvAPeC+Wv57VkFBwenLNge/0clY09T/uzpLFyeNPh8vL/vxSYcNbTGHwDQFOtsJmdg+MH0pk7YB14dAZwch8zritOcQ7gDkLEJGgllgcgshi8D+OiHnDSbk+VLMzVScZVOLOI+mm9KxGfHDuG9MK54twOvgYKuanoKCgoKC048j2BcI9oUDOCccx35YKsffeUTfCV2C+OXJHj0I4W9IuxrPLEea4/yj4CpqDz/JOWtEuirV/u/I2hAfVuXvxSOQfj6VNwbxCYKyERORN5nKn1bt/+4pYhaVF33/dZNE11xJXsRU6J3JnFduxz0LwOLoXuR1JzrmGJxrVlL2exB/mvFnDa67Er3rMnylWa9R1ierGuCsx7IDbXN9QHs9aINvYHMPp09+apB+0iX6XreHYhlDj4RnygPLn2nYtP2nGc92Q5g51+v5WdCEnfBpl8Cv8Qq/n6jwrWa993LKd3hevzYm839zA6wDW+HDddjnP6J8+cKBX9Gc/6Uah30I/wQnGqC+qpTRJq0Z72xN++/sU+BdMFu3c08Bn02gv9/mcVE9/n48KjsW8UvBpHqc1wmmID49+g65nq2LZbRiue/BnAz9t9b59aHrOoK67kr03ZnctygJlyK8n7I1Kvo9A9ePGtSPtW/S/j6J2vXaptJ/lOO/7mTSRMUHKd6jQiH5SdH+7saxz/HfzvGZTTOVyhmOSwllp9Ek7z407Xc6FMVPdykJUBXdNm/kPacR15dQY1BWh1JGGVYHr6wPof3KSxpprDSynAnt4KpuvDlVUtTvmqqgDlUK9ppeM1TraSqsXdZ3Oj0Vnf2NJ7b305K2n2zfFbW/q/2lyoEwcdoPuo+rVJj33JWNYd784YnoPGQ7d3R9LmXc50No+z7OaeVEdxtx9/7H9bslV8/VqYR+H+bCBm/dp4W31qZjRoaL/ahR3zfy1hbR/q9aLpTI7LLrWV5Cj0lC5Pu+6BxAl6f3Ntm9Ov7ltf+x9Qltm/VB1Iasj3R5HVuqZUP2R4WJ5zVfZPODV5bnN1vWZTva6hfNd1o3e371MQ58jy/b9cilH7Q/Pua36Xqbh4jW2qznYVXdOvbzeObi7adpuuxMk6Uzz/6MhD0X8M4IvP51XT/2zJKnsP2p449ov+GdEejyvHcRrsc62+ema23WudOVqPprYjfvfSaEPXaM8ey5nG8qfcRD5Wxja8/GP1fYimq7sfXVWbNtRfXs7aM9THVEovrO0kZ8tH2otUtlzNFjTbaXqb6/0K2bzzaQ1ZGXzgqv/iI9IfvS51marq/K2kyHJOMe1XZUGVMi3SElq56i+tLpeYmPvS+vfqCFN5Z4c97nvGVt8Pqe55+uqKzbKnPRx97OXqui+5wj85vOUz0rhEBky0ZcjmeR3ya/N7r+jTJLfLUBL810jOqOYxfCWwN9+yBaj0KJy/lqYtvULx+iuwa73sNpvSJ7KvZDjp/UnqyNRNcmdlTK5H1m9KGPN/Zl7WjSxqrjy/TZSvSszL6HDz1+eZKnDyFs66ypoj1eRa9v0TlTqOpyKfQYz1tEa3Qee23qj0vRfVdi+zwp2ut03rnq+OxDaN/ZNV90rdpuOj6zelXbIeR4TcXm/QE9PnyKK/2yMylbH9EcyOO5hieyuqQieh7Lqw6ubZqOXZMxKxobsjGk6r/qPuZaTPaYkH2YCtuHdHlWV2hRabcQ80zVhs7abiMq73Vt54+qqPYRz8esevheV1XGE9uehFNGJrzfElh9tutnlrDj0KVOX/PQ53xn290EHd9tfFQVH+8ZdUW0/rD5Iddw33ZC7kMiu65xZUulDjr19SUi3122oQufXPmmOy+z7PqQ0O3pWtoDwquTqGxzIFyJr33N9Z4fQkL6YXM2ckGtAaClnjODPdPKoCsu68qK77qrwEoLGdhmPgltLxWf3xz51s3DREdIUbUZ0i9XtnTONLJ7Q/hqKrpjRrVs3vWihddXsn7UPc+a3OML0zaxtWfSXoTIfTbN45U1WUtltmT+i+qqY9u0X21E156NX3ndK9Np0095+6KiUyXNh5jOA54eV21ju36yemz8yPLJ1Vrgep8JtU/Zim4b88qp2vFFHjZ9rW8mvtvq9u2rrZ5Q9m3t+BpbJnk+x/e/",
  "classes": {
    "Other": 0,
    "Prepend": 1,
    "CR": 2,
    "LF": 3,
    "Control": 4,
    "Extend": 5,
    "Regional_Indicator": 6,
    "SpacingMark": 7,
    "L": 8,
    "V": 9,
    "T": 10,
    "LV": 11,
    "LVT": 12,
    "ZWJ": 13,
    "ExtPict": 14
  }
};

/**
 * @packageDocumentation
 * @ignore
 */
const {
  trie
} = classesmjs;
const {
  Other,
  Prepend,
  CR,
  LF,
  Control,
  Extend,
  Regional_Indicator,
  SpacingMark,
  L,
  V,
  T,
  LV,
  LVT,
  ZWJ,
  ExtPict
} = classesmjs.classes;
let data = null;

if (typeof window !== 'undefined') {
  const bin = window.atob(trie);
  data = new Uint8Array(bin.length);

  for (let i = 0; i < bin.length; i++) data[i] = bin.charCodeAt(i);
} else {
  data = Buffer.from(trie, 'base64');
} // console.log(data, data.length)


const classTrie = new UnicodeTrie__default["default"](data);

const codePointAt = function (str, idx) {
  // different from String#codePointAt with low surrogate
  const code = str.charCodeAt(idx); // High surrogate

  if (code >= 0xD800 && code <= 0xDBFF) {
    const hi = code;
    const low = str.charCodeAt(idx + 1);

    if (low >= 0xDC00 && low <= 0xDFFF) {
      return (hi - 0xD800) * 0x400 + (low - 0xDC00) + 0x10000;
    }

    return hi;
  } // Low surrogate


  if (code >= 0xDC00 && code <= 0xDFFF) {
    const hi = str.charCodeAt(idx - 1);
    const low = code;

    if (hi >= 0xD800 && hi <= 0xDBFF) {
      return (hi - 0xD800) * 0x400 + (low - 0xDC00) + 0x10000;
    }

    return low;
  }

  return code;
};

const isSurrogate$1 = function (str, pos) {
  let ref;
  let ref1; // eslint-disable-next-line no-return-assign

  return (ref = str.charCodeAt(pos)) >= 0xd800 && ref <= 0xdbff && (ref1 = str.charCodeAt(pos + 1)) >= 0xdc00 && ref1 <= 0xdfff;
};

const BreakType = {
  NotBreak: 0,
  BreakStart: 1,
  Break: 2,
  BreakLastRegional: 3,
  BreakPenultimateRegional: 4
}; // Returns whether a break is allowed within a sequence of grapheme breaking classes

const shouldBreak = function (reverse, start, mid, end) {
  const all = [start].concat(mid).concat([end]);
  const previous = reverse ? start : all[all.length - 2];
  const next = reverse ? all[1] : end; // Lookahead terminator for:
  // GB12. ^ (RI RI)* RI × RI
  // GB13. [^RI] (RI RI)* RI × RI

  const rIIndex = all.lastIndexOf(Regional_Indicator);

  if (rIIndex > 0 && all.slice(1, rIIndex).every(c => c === Regional_Indicator) && previous !== Prepend && previous !== Regional_Indicator) {
    if (all.filter(c => c === Regional_Indicator).length % 2 === 1) {
      return BreakType.BreakLastRegional;
    }

    return BreakType.BreakPenultimateRegional;
  } // GB3. CR X LF


  if (previous === CR && next === LF) {
    return BreakType.NotBreak;
  } // GB4. (Control|CR|LF) ÷


  if (previous === Control || previous === CR || previous === LF) {
    // return BreakType.BreakStart
    if (next !== Extend && mid.every(c => c === Extend)) {
      return BreakType.Break;
    }

    return BreakType.BreakStart;
  } // GB5. ÷ (Control|CR|LF)


  if (next === Control || next === CR || next === LF) {
    return BreakType.BreakStart;
  } // GB6. L X (L|V|LV|LVT)


  if (previous === L && (next === L || next === V || next === LV || next === LVT)) {
    return BreakType.NotBreak;
  } // GB7. (LV|V) X (V|T)


  if ((previous === LV || previous === V) && (next === V || next === T)) {
    return BreakType.NotBreak;
  } // GB8. (LVT|T) X (T)


  if ((previous === LVT || previous === T) && next === T) {
    return BreakType.NotBreak;
  } // GB9.0 X (Extend|ZWJ)


  if (reverse) {
    if (next === Extend) {
      return BreakType.NotBreak;
    }

    if (next === ZWJ) {
      if (previous == Other && mid.length > 0 && mid[0] == ZWJ) {
        return end != ExtPict ? BreakType.BreakStart : BreakType.Break;
      }

      return BreakType.NotBreak;
    }
  } else if (next === Extend || next === ZWJ) {
    return BreakType.NotBreak;
  } // GB9.1 X SpacingMark


  if (next === SpacingMark) {
    return BreakType.NotBreak;
  } // GB9.2 Prepend X


  if (previous === Prepend) {
    return BreakType.NotBreak;
  } // GB11.0 ExtPict Extend * ZWJ × ExtPict


  if (reverse) {
    if (previous == ZWJ && next == ExtPict && (start == ZWJ || start == Other)) {
      return BreakType.NotBreak;
    }
  } else if (start == ExtPict && previous == ZWJ && next == ExtPict) {
    return BreakType.NotBreak;
  } // GB12. ^ (RI RI)* RI × RI
  // GB13. [^RI] (RI RI)* RI × RI


  if (!reverse && mid.indexOf(Regional_Indicator) >= 0) {
    return BreakType.Break;
  }

  if (previous === Regional_Indicator && next === Regional_Indicator) {
    return BreakType.NotBreak;
  } // GB999. Any ÷ Any


  return BreakType.BreakStart;
};

const getUnicodeByteOffset = function (str, start, unicodeOffset) {
  while (unicodeOffset--) {
    start += isSurrogate$1(str, start) ? 2 : 1;
  }

  return start;
}; // Returns the next grapheme break in the string after the given index


function nextBreak(string, index = 0) {
  if (index < 0) {
    return 0;
  }

  if (index >= string.length - 1) {
    return string.length;
  }

  const prev = classTrie.get(string.codePointAt(index));
  const mid = [];
  let i;
  let j;
  let ref; // eslint-disable-next-line no-multi-assign

  for (i = j = index + 1, ref = string.length; j < ref; i = j += 1) {
    if (isSurrogate$1(string, i - 1)) {
      // check for already processed low surrogates
      continue;
    }

    const next = classTrie.get(string.codePointAt(i));

    if (shouldBreak(false, prev, mid, next)) {
      return i;
    }

    mid.push(next);
  }

  return string.length;
} // Returns the next grapheme break in the string before the given index


function previousBreak(string, index = string.length) {
  if (index > string.length) {
    return string.length;
  }

  if (index <= 1) {
    return 0;
  }

  index--;
  const mid = [];
  const next = classTrie.get(codePointAt(string, index));
  let i;
  let j; // eslint-disable-next-line no-multi-assign

  for (i = j = index - 1; j >= -1; i = j += -1) {
    if (isSurrogate$1(string, i)) {
      // check for already processed high surrogates
      continue;
    }

    const prev = classTrie.get(codePointAt(string, i));

    switch (shouldBreak(true, prev, mid, next)) {
      case BreakType.Break:
        return i + mid.length + 1;

      case BreakType.BreakStart:
        return i + 1;

      case BreakType.BreakLastRegional:
        // eslint-disable-next-line no-case-declarations
        const offset = getUnicodeByteOffset(string, i, mid.concat(next).lastIndexOf(Regional_Indicator) + 1);
        return offset;

      case BreakType.BreakPenultimateRegional:
        return getUnicodeByteOffset(string, i, mid.concat(next).lastIndexOf(Regional_Indicator));
    }

    mid.unshift(prev);
  }
} // Breaks the given string into an array of grapheme cluster strings


function breaks(str) {
  const res = [];
  let index = 0;
  let brk; // eslint-disable-next-line no-cond-assign

  while ((brk = nextBreak(str, index)) < str.length) {
    res.push(str.slice(index, brk));
    index = brk;
  }

  if (index < str.length) {
    res.push(str.slice(index));
  }

  return res;
} // Returns the number of grapheme clusters there are in the given string


function countBreaks$1(str) {
  let count = 0;
  let index = 0;
  let brk; // eslint-disable-next-line no-cond-assign

  while ((brk = nextBreak(str, index)) < str.length) {
    index = brk;
    count++;
  }

  if (index < str.length) {
    count++;
  }

  return count;
}

var GraphemesBreaker = {
  nextBreak,
  previousBreak,
  break: breaks,
  countBreaks: countBreaks$1
};

/**
 * @packageDocumentation
 * @ignore
 */
const SURROGATE_START = 0xd800;
const SURROGATE_END = 0xdfff;
const SPACE = /\s/;
/**
 * 标点的定义各家不统一
 * 部分常用标点可以在 https://www.ascii-code.com/ 上查看
 * 目前至少确保标准键盘能输入的标点
 */

const PUNCTUATION = /[\u0021-\u002F\u003A-\u0040\u005B-\u0060\u007B-\u007E\u00A1-\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65\uFFE5]/;

function isChineseChar(char) {
  return /[\u3400-\u9FBF]/.test(char);
}

function isValidString(str) {
  return typeof str === 'string' && str !== '';
}

function isPunc(char) {
  return PUNCTUATION.test(char);
} // 当满足以下条件时，认为是同一类型：
// 1. 都是「标点/SPACE」或都不是「标点/SPACE」
// 2. 都是中文或都不是中文


function isSameCharType(charA, charB) {
  return isValidString(charA) && isValidString(charB) && isWord(charA) === isWord(charB) && isChineseChar(charA) === isChineseChar(charB);
}

function getNextLetter(str, i, reverse) {
  let nextBreak;
  if (!str || i < 0 || i > str.length) return '';

  if (reverse) {
    nextBreak = GraphemesBreaker.previousBreak(str, i);
    return str.substring(nextBreak, i);
  }

  nextBreak = GraphemesBreaker.nextBreak(str, i);
  return str.substring(i, nextBreak);
}

function countBreaks(str, i, reverse) {
  if (!str || i < 0 || i > str.length) return 0;
  const start = reverse ? i : 0;
  const end = reverse ? str.length : i;
  const text = str.substring(start, end);
  return GraphemesBreaker.countBreaks(text);
}

function isSurrogate(code) {
  return SURROGATE_START <= code && code <= SURROGATE_END;
}

function isWord(char) {
  if (SPACE.test(char)) {
    return false;
  }

  if (PUNCTUATION.test(char)) {
    return false;
  }

  return true;
}

function getCharOffset(text, offset, reverse) {
  return getNextLetter(text, offset, reverse).length;
}

function getCharOffsetBackward(text, offset) {
  return getNextLetter(text, offset, true).length || 1;
}

function getCharOffsetForward(text, offset) {
  return getNextLetter(text, offset).length || 1;
} // 在搜索结果处处理Unicode，避免光标focus到Unicode中间


function getCharRange(text, offset) {
  let start = 0;

  while (start <= offset) {
    const end = start + getCharOffsetForward(text, start);

    if (end > offset) {
      return [start, end];
    }

    start = end;
  }

  return [start, start + Math.min(text.length, 1)];
}

function getWordRange(text, offset) {
  if (!text) {
    return [0, 0];
  } // eslint-disable-next-line no-param-reassign


  offset = Math.min(offset, text.length);
  const charAtOffset = text[offset];
  const lastChar = text[offset - 1];
  const nextChar = text[offset + 1];
  let end = 0;
  let start = 0; // 当前字符不为空时，至少选中该字符

  if (isValidString(charAtOffset)) {
    end = 1;
  } // 当前字符为空时，说明在文本末尾需要 backward 遍历
  // backward 遍历，找到词的后半部分的长度


  if (!isValidString(charAtOffset) || isSameCharType(lastChar, charAtOffset)) {
    start = getWordOffsetBackward(text, offset);
  } // 当前字符为空或当前字符和前一字符同类型时
  // forward 遍历，找到词的前半部分的长度


  if (isSameCharType(nextChar, charAtOffset)) {
    end = getWordOffsetForward(text, offset);
  }

  return [offset - start, offset + end];
}

function getWordOffset(text, offset, reverse) {
  let length = 0;
  let i = offset;
  let char = getNextLetter(text, i, reverse);
  const curChar = char;

  while (isSameCharType(char, curChar)) {
    length += char.length;

    if (reverse) {
      i -= char.length;
    } else {
      i += char.length;
    }

    char = getNextLetter(text, i, reverse);
  } // 如果没有迭代到字符，至少保证选中前一个字符


  return length || char.length;
} // 计算光标以 word 为单位时移动的偏移量


function getMoveWordOffset(text, offset, reverse) {
  let char = getNextLetter(text, offset, reverse);

  if (!isValidString(char)) {
    return 0;
  }

  let delta = 0;
  let i = offset; // 参考原生实现: 直接跳过光标附近的 SPACE

  while (SPACE.test(char)) {
    if (reverse) {
      i -= char.length;
      delta -= 1;
    } else {
      i += char.length;
      delta += 1;
    }

    char = getNextLetter(text, i, reverse);
  }

  return Math.abs(delta) + getWordOffset(text, offset + delta, reverse);
}

function getWordOffsetBackward(text, offset) {
  const o = getWordOffset(text, offset, true);
  return o;
}

function getWordOffsetForward(text, offset) {
  const o = getWordOffset(text, offset);
  return o;
}

function graphemesBreak(text) {
  return GraphemesBreaker.break(text);
}

const NEWLINE$1 = '\n';
const SECLINE = '\r';
const SIMPLE_SPACE = String.fromCharCode(32);
const spaceUniCode = {
  nbsp: '\u00a0',
  zwnj: '\u200c',
  zwj: '\u200d'
};
/**
 *  处理字符串中的特殊字符
 * 
 *  1. 单独 \r 或 \r\n 效果类似 \n ，有折行效果
 *     \r\r 或 \n\n， 有隔行效果
 *  2. &nbsp; 替换成普通空格，移除 &zwnj;、&zwj 零宽字符
 * */

function normalizeText$2(text) {
  let result = '';

  for (let i = text.length - 1; i >= 0; i--) {
    if (text[i] === NEWLINE$1) {
      if (text[i - 1] === SECLINE) {
        i--;
      }

      result = NEWLINE$1 + result;
      continue;
    }

    if (text[i] === SECLINE) {
      result = NEWLINE$1 + result;
      continue;
    }

    if (text[i] === spaceUniCode.nbsp) {
      result = SIMPLE_SPACE + result;
      continue;
    }

    if (text[i] === spaceUniCode.zwnj || text[i] === spaceUniCode.zwj) {
      continue;
    }

    result = text[i] + result;
  }

  return result;
}
var textUtils = {
  countBreaks,
  getNextLetter,
  getCharOffset,
  getCharOffsetBackward,
  getCharOffsetForward,
  getCharRange,
  getWordRange,
  getWordOffset,
  getMoveWordOffset,
  getWordOffsetBackward,
  getWordOffsetForward,
  isSurrogate,
  isWord,
  isPunc,
  isChineseChar,
  graphemesBreak,
  normalizeText: normalizeText$2
};

function isValidElement(el) {
  return el !== null && el.nodeType === Node.ELEMENT_NODE && !el.getAttribute('data-cangjie-content');
}
/**
 * Find closest ancestor
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/closest
 * @returns
 */


function findClosestInContent(el, selector) {
  do {
    if (Element.prototype.matches.call(el, selector)) return el;
    el = el.parentElement || el.parentNode;
  } while (isValidElement(el));

  return null;
}

/**
 * @packageDocumentation
 * @module constants
 */
const CUSTOM_MIME_TYPES = {
  FRAGMENT: 'application/x-cangjie-fragment',
  PACKAGE: 'application/x-cangjie-fragment-pack',
  SYNC: 'application/x-hetu-sync',
  DOCKEY: 'application/x-doc-key',
  REFBLOCK: 'application/x-refblock',
  ENCRYPTION: 'application/x-cangjie-encryption',
  APPLICATION_VSCODE: 'vscode-editor-data'
};
const MIME_TYPES = {
  HTML: 'text/html',
  TEXT: 'text/plain',
  ...CUSTOM_MIME_TYPES
};
const EVENTS = ['onAction', 'onChange', 'onCangjieFocus', 'onCangjieBlur', 'onCangjieInput', 'onCangjieSelect', 'onCangjieCopy', 'onCangjieCut', 'onCangjiePaste', 'onCangjieComposingChange', 'onClick', 'onCopy', 'onCut', 'onPaste', 'onKeyDown', 'onKeyUp', 'onMouseDown', 'onMouseMove', 'onMouseUp', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onContextMenu', 'onDragStart', 'onDragOver', 'onDrop', 'onDragEnter'];
/**
 * 光标宽度
 */

const CURSOR_WIDTH = 2;
/**
 * Edge 光标的最大高度
 */

const CURSOR_EDGE_MAX_HEIGHT = 21;
/**
 * Edge 光标和元素之间的偏移量
 */

const CURSOR_EDGE_OFFSET = 1;
const CANGJIE_EMPTY = '\uFEFF';
/**
 * 选区颜色
 */

const CANGJIE_SELECTION_COLOR = 'rgba(1, 134, 251, 0.3)';
/**
 * 空行时最小宽度
 */

const CANGJIE_SELECTION_EMPTY_WIDTH = 4;
/**
 * Blur的选区颜色
 */

const CANGJIE_SELECTION_INACTIVE_COLOR = 'rgba(136, 136, 136, 0.3)';
const Z_INDEX_CONTEXTMENU = 10000;
const Selector = {
  key: 'data-cangjie-key',
  content: 'data-cangjie-content',
  edgeSelectable: 'data-cangjie-edge-selectable',
  editable: 'data-cangjie-editable',
  void: 'data-cangjie-void',
  leaf: 'data-cangjie-leaf',
  leafBlock: 'data-cangjie-leaf-block',
  nonSelect: 'data-cangjie-non-select',
  notEditable: 'data-cangjie-not-editable',
  dockey: 'data-cangjie-dockey',
  selectionLayer: 'data-cangjie-selection-layer',
  selectionWrapper: 'data-cangjie-selection-wrapper',
  groupBlock: 'data-cangjie-group-block',
  groupKey: 'data-cangjie-group-key',
  hoverWrapper: 'data-hover-box',
  uuid: 'data-block-uuid'
};
/**
 * 默认 undo 队列最大长度限制
 */

const MAX_HISTORY_SIZE = 100;
/** 仓颉 Group 折叠 key */

const GROUP_COLLAPSED_KEY = 'cangjieGroupCollpased';

var constants = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CUSTOM_MIME_TYPES: CUSTOM_MIME_TYPES,
  MIME_TYPES: MIME_TYPES,
  EVENTS: EVENTS,
  CURSOR_WIDTH: CURSOR_WIDTH,
  CURSOR_EDGE_MAX_HEIGHT: CURSOR_EDGE_MAX_HEIGHT,
  CURSOR_EDGE_OFFSET: CURSOR_EDGE_OFFSET,
  CANGJIE_EMPTY: CANGJIE_EMPTY,
  CANGJIE_SELECTION_COLOR: CANGJIE_SELECTION_COLOR,
  CANGJIE_SELECTION_EMPTY_WIDTH: CANGJIE_SELECTION_EMPTY_WIDTH,
  CANGJIE_SELECTION_INACTIVE_COLOR: CANGJIE_SELECTION_INACTIVE_COLOR,
  Z_INDEX_CONTEXTMENU: Z_INDEX_CONTEXTMENU,
  Selector: Selector,
  MAX_HISTORY_SIZE: MAX_HISTORY_SIZE,
  GROUP_COLLAPSED_KEY: GROUP_COLLAPSED_KEY
});

/**
 * @packageDocumentation
 * @module domUtils
 */
/**
 * 根据浏览器的节点和位置获取仓颉对应的 Point。
 */

function findPoint(nativeNode, nativeOffset, controller) {
  if (!nativeNode) {
    return null;
  }

  const node = nativeNode instanceof Text ? nativeNode.parentElement : nativeNode;

  if (!(node instanceof Element)) {
    return null;
  }

  const {
    document
  } = controller.value;
  let leaf;

  if (node.getAttribute(Selector.void)) {
    // 原本这里有一层「判断 node 内部是否存在 leaf 节点，不存在才继续」的逻辑
    // 由于 hetu 等插件内部可能嵌套了编辑器，且 key 不可控，可能与宿主重复，造成问题（选区异常 or 页面奔溃）
    // 因此这里去掉 `!isLeaf` 判断
    const key = node.getAttribute(Selector.key);

    if (!key) {
      return null;
    }

    const voidNode = document.getNode(key);

    if (!voidNode) {
      return null;
    }

    const text = voidNode.getFirstText();

    if (!text) {
      return null;
    }

    return TextPoint.create({
      key: text.key,
      offset: 0
    });
  } else {
    leaf = node.getAttribute(`[${Selector.leaf}]`) ? node : findClosestInContent(node, `[${Selector.leaf}]`);
  }

  if (!leaf) {
    return null;
  }

  const [key, offset] = keyUtils.parse(leaf.getAttribute(Selector.key) || '');
  const text = document.getNode(key);

  if (!text) {
    return null;
  } // NOTE: what if user data has just one `CANGJIE_EMPTY` character?


  const nativeText = leaf.textContent && leaf.textContent !== CANGJIE_EMPTY ? leaf.textContent.slice(0, nativeOffset) : '';
  return TextPoint.create({
    key,
    offset: offset + nativeText.length
  });
}

/**
 * @packageDocumentation
 * @module domUtils
 */
/**
 * 根据浏览器的 Range 获取仓颉的 Selection
 */

function findRange(native, controller) {
  const {
    startContainer,
    startOffset,
    endContainer,
    endOffset,
    collapsed
  } = native;
  const start = findPoint(startContainer, startOffset, controller);
  const end = collapsed ? start : findPoint(endContainer, endOffset, controller);

  if (!start || !end) {
    return null;
  }

  return Selection.create({
    anchor: start,
    focus: end
  });
}

/**
 * @packageDocumentation
 * @ignore
 */

const isPointOnLeftOfRect = (x, _, rect) => x < rect.left;

const isPointOnRightOfRect = (x, _, rect) => x > rect.right;

const isPointOnTopOfRect = (_, y, rect) => y < rect.top;

const isPointOnBottomOfRect = (_, y, rect) => y > rect.bottom;

const isPointHorzInsideRect = (x, _, rect) => x >= rect.left && x <= rect.right;

const isPointVertInsideRect = (_, y, rect) => y >= rect.top && y <= rect.bottom;

const isPointInsideRect = (x, y, rect) => {
  return isPointHorzInsideRect(x, y, rect) && isPointVertInsideRect(x, y, rect);
};

const isPointOnRightOfRectNonStrict = (x, _, rect) => x > rect.left;

const isPointOnLeftOfRectNonStrict = (x, _, rect) => x < rect.right; // 认为是同一行的阈值：重叠部分占矮的高度的百分比（magic number: 上下标的重叠比例）


const SAME_LINE_THRESHOLD = 0.4;
const isRectOnSameLineOfRect = (newRect, rect) => {
  // 底边对齐
  if (newRect.bottom === rect.bottom) {
    return true;
  } // 无交集


  if (newRect.top > rect.bottom || rect.top > newRect.bottom) {
    return false;
  } // 重叠部分
  // eg. 表情 + 文字：可能是包含 or 部分重叠关系


  const smallerHeight = Math.min(rect.height, newRect.height);
  const overlap = Math.min(newRect.bottom, rect.bottom) - Math.max(newRect.top, rect.top);
  return smallerHeight === 0 || overlap / smallerHeight > SAME_LINE_THRESHOLD;
};
const APPROXIMATE_THEREHOLD = 1e-5; // 近似相等的阈值，误差小于此则认为相等

const approximateEqual = (a, b) => Math.abs(a - b) < APPROXIMATE_THEREHOLD; // 此类都是非严格判断，只检测同一个方位的边界


const isRectOnLeftOfRect = (newRect, newContentNode, prevClosestRect) => {
  return newRect.left < prevClosestRect.contentRect.left || newRect.left === prevClosestRect.contentRect.left && newContentNode.compareDocumentPosition(prevClosestRect.contentNode) === Node.DOCUMENT_POSITION_FOLLOWING;
};

const isRectOnRightOfRect = (newRect, newContentNode, prevClosestRect) => {
  // 某些 win 触屏机下，inline 元素与右侧的空 Text 渲染的位置有重叠，存在细微的误差
  // https://aone.alibaba-inc.com/v2/project/897543/bug/41731721#
  return newRect.right > prevClosestRect.contentRect.right + APPROXIMATE_THEREHOLD || approximateEqual(newRect.right, prevClosestRect.contentRect.right) && newContentNode.compareDocumentPosition(prevClosestRect.contentNode) === Node.DOCUMENT_POSITION_PRECEDING;
};

const isRectOnTopOfRect = (newRect, newContentNode, prevClosestRect) => {
  return newRect.top < prevClosestRect.contentRect.top || newRect.top === prevClosestRect.contentRect.top && newContentNode.compareDocumentPosition(prevClosestRect.contentNode) === Node.DOCUMENT_POSITION_FOLLOWING;
};

const isRectOnBottomOfRect = (newRect, newContentNode, prevClosestRect) => {
  return newRect.bottom > prevClosestRect.contentRect.bottom || newRect.top === prevClosestRect.contentRect.bottom && newContentNode.compareDocumentPosition(prevClosestRect.contentNode) === Node.DOCUMENT_POSITION_PRECEDING;
};

const getHorzDistance = (x, _, rect) => {
  return Math.min(Math.abs(x - rect.left), Math.abs(x - rect.right));
};

function getClosestAncestorWithBiggerHorizontalRect(element) {
  const rect = element.getBoundingClientRect();
  let parent = element.parentElement;

  while (parent) {
    const parentRect = parent.getBoundingClientRect();

    if (parentRect.left < rect.left && parentRect.right > rect.right) {
      return parent;
    }

    parent = parent.getAttribute(Selector.content) ? null : parent.parentElement;
  }

  return null;
}

function* getSeletableBlocksFromElement(element) {
  const edgeSelectableAncestor = element.closest(`[${Selector.edgeSelectable}]`);

  if (edgeSelectableAncestor) {
    yield edgeSelectableAncestor;
  }

  const edgeSelectableDescendants = element.querySelectorAll(`[${Selector.edgeSelectable}]`);

  if (!edgeSelectableDescendants) {
    return;
  }

  for (const descendant of Array.from(edgeSelectableDescendants)) {
    yield descendant;
  }
}

function* getRectsFromElement(element) {
  // TODO: 处理点击 content 外元素时的定位逻辑，后续有更好的方案可移除
  const isNonSelect = element.getAttribute(Selector.nonSelect);
  const elementParent = findClosestInContent(element, `[${Selector.leafBlock}]`) || element.parentElement || element;
  const targetElement = isNonSelect ? elementParent : element;
  const cangjieLeafs = targetElement.querySelectorAll(`span[${Selector.leaf}]`);

  for (let i = 0; i < cangjieLeafs.length; i += 1) {
    const cangjieLeaf = cangjieLeafs[i];
    yield {
      contentNode: cangjieLeaf,
      contentRects: Array.from(cangjieLeaf.getClientRects())
    };
  }

  const cangjieVoids = targetElement.querySelectorAll(`[${Selector.void}]`);

  for (let i = 0; i < cangjieVoids.length; i += 1) {
    const cangjieVoid = cangjieVoids[i];
    yield {
      contentNode: cangjieVoid,
      contentRects: [cangjieVoid.getBoundingClientRect()]
    };
  }
}

function findClosestRectsInElement(element, x, y) {
  let closestBelow = null;
  let closestLeft = null;
  let closestRight = null;
  let closestTop = null;

  for (const rect of getRectsFromElement(element)) {
    const {
      contentNode
    } = rect;

    for (let index = 0; index < rect.contentRects.length; index++) {
      const contentRect = rect.contentRects[index];

      if (!contentRect) {
        continue;
      }

      if (isPointInsideRect(x, y, contentRect)) {
        return {
          exactTarget: contentNode
        };
      }

      if (isPointOnTopOfRect(x, y, contentRect)) {
        let found = false; // 现在左下、正下、右下都算 closestBelow
        // 多个 rect 都符合 closestBelow 条件的时候，需要取我们最需要的那个

        if (!closestBelow) {
          // 之前没有 closestBelow 的时候，没有对比，设置它为 closestBelow
          found = true;
        } else if (isRectOnSameLineOfRect(contentRect, closestBelow.contentRect)) {
          // 之前的 closestBelow 和现在的 rect 处于同一条直线上时
          // 通过检查左右距离确定最终取哪个
          const prevExactBelow = isPointHorzInsideRect(x, y, closestBelow.contentRect);
          const newExactBelow = isPointHorzInsideRect(x, y, contentRect);
          const prevDistance = getHorzDistance(x, y, closestBelow.contentRect);
          const newDistance = getHorzDistance(x, y, contentRect); // 原先处于正下方，就是同行最优先的结果，不用再更新
          // 原先不处于正下方，现在处于正下方，需要更新
          // 两次都不处于正下方，使用距离更短的那个作为最终结果

          if (!prevExactBelow && (newExactBelow || newDistance < prevDistance)) {
            found = true;
          }
        } else if (isRectOnTopOfRect(contentRect, contentNode, closestBelow)) {
          // 之前的 closestBelow 和现在的 rect 不处于同一条直线上时
          // 取位置更高的，即纵向上更靠近的作为 closestBelow
          found = true;
        }

        if (found) {
          closestBelow = {
            contentRect,
            contentNode
          };
        }
      } else if (isPointOnBottomOfRect(x, y, contentRect)) {
        let found = false;

        if (!closestTop) {
          found = true;
        } else if (isRectOnSameLineOfRect(contentRect, closestTop.contentRect)) {
          const prevExactTop = isPointHorzInsideRect(x, y, closestTop.contentRect);
          const newExactTop = isPointHorzInsideRect(x, y, contentRect);
          const prevDistance = getHorzDistance(x, y, closestTop.contentRect);
          const newDistance = getHorzDistance(x, y, contentRect);

          if (!prevExactTop && (newExactTop || newDistance < prevDistance)) {
            found = true;
          }
        } else if (isRectOnBottomOfRect(contentRect, contentNode, closestTop)) {
          found = true;
        }

        if (found) {
          closestTop = {
            contentRect,
            contentNode
          };
        }
      } else if (isPointVertInsideRect(x, y, contentRect) && isPointOnRightOfRectNonStrict(x, y, contentRect) && (!closestLeft || isRectOnRightOfRect(contentRect, contentNode, closestLeft))) {
        closestLeft = {
          contentRect,
          contentNode
        };
      } else if (isPointVertInsideRect(x, y, contentRect) && isPointOnLeftOfRectNonStrict(x, y, contentRect) && (!closestRight || isRectOnLeftOfRect(contentRect, contentNode, closestRight))) {
        closestRight = {
          contentRect,
          contentNode
        };
      }
    }
  }

  return {
    closestBelow,
    closestLeft,
    closestRight,
    closestTop
  };
}

function binarySearchOffset(textNode, mouseX, mouseY, rangeStart, rangeEnd, textLength) {
  const range = document.createRange();

  if (rangeEnd - rangeStart > 1) {
    const offset = Math.floor((rangeStart + rangeEnd) / 2);

    try {
      range.setStart(textNode, offset);
      range.setEnd(textNode, Math.max(Math.min(offset, textLength), 0));
    } catch (error) {
      return rangeStart;
    } // getClientBoundingRect不保险，在iOS10下结果不对


    const rect = range.getClientRects()[0];

    if (!rect) {
      return rangeStart;
    }

    if (mouseY < rect.top) {
      return binarySearchOffset(textNode, mouseX, mouseY, rangeStart, offset, textLength);
    }

    if (mouseY > rect.bottom) {
      return binarySearchOffset(textNode, mouseX, mouseY, offset, rangeEnd, textLength);
    }

    if (mouseX <= rect.left + rect.width) {
      return binarySearchOffset(textNode, mouseX, mouseY, rangeStart, offset, textLength);
    }

    return binarySearchOffset(textNode, mouseX, mouseY, offset, rangeEnd, textLength);
  }

  const [offsetStart, offsetEnd] = textUtils.getCharRange(textNode.textContent, rangeStart);

  try {
    range.setStart(textNode, offsetStart);
    range.setEnd(textNode, Math.max(Math.min(offsetEnd, textLength), 0));
  } catch (error) {
    return offsetStart;
  }

  const rangeRects = Array.from(range.getClientRects());
  const rect = rangeRects.find(r => r.width > 0) || rangeRects[0];

  if (!rect) {
    return offsetStart;
  }

  if (mouseY < rect.top) {
    return offsetStart;
  }

  if (mouseY > rect.bottom) {
    return offsetEnd;
  }

  if (mouseX <= rect.left + rect.width / 2) {
    return offsetStart;
  }

  return offsetEnd;
}

function caretPointFromTargetAndCoord({
  eventTarget,
  mouseX,
  mouseY,
  adjustedX,
  adjustedY
}) {
  let target = eventTarget;
  let [x, y] = [adjustedX, adjustedY];

  for (const node of getSeletableBlocksFromElement(target)) {
    const rect = node.getBoundingClientRect();
    const parent = getClosestAncestorWithBiggerHorizontalRect(node); // 检查 eventTarget 是否在 node 的左侧和右侧

    if (!parent || isPointHorzInsideRect(mouseX, mouseY, rect) || !isPointVertInsideRect(mouseX, mouseY, rect)) {
      continue;
    } // 如果 eventTarget 在父元素内部，才算命中（处理表格等情况）


    const parentRect = parent.getBoundingClientRect();
    const parentStyle = window.getComputedStyle(parent); // 父元素的 margin 也需要计算在内（排版等情况，用的是 margin）

    const parentLeft = parentRect.left - parseInt(parentStyle.marginLeft, 10);
    const parentRight = parentRect.right + parseInt(parentStyle.marginRight, 10);

    if (x >= parentLeft && x <= parentRight) {
      const edge = x > rect.left ? EdgePoint.AFTER : EdgePoint.BEFORE;
      return {
        node,
        edge
      };
    }
  }

  let closestLeftEdge;
  let closestRightEdge;

  if (!findClosestInContent(target, `span[${Selector.leaf}]`) && !findClosestInContent(target, `[${Selector.void}]`)) {
    const {
      exactTarget,
      closestBelow,
      closestLeft,
      closestRight,
      closestTop
    } = findClosestRectsInElement(target, x, y);
    closestLeftEdge = closestLeft?.contentRect.right;
    closestRightEdge = closestRight?.contentRect.left;

    if (exactTarget) {
      target = exactTarget;
    } else if (closestBelow && closestLeft) {
      if (isRectOnSameLineOfRect(closestBelow.contentRect, closestLeft.contentRect)) {
        y = closestBelow.contentRect.top;
        target = closestBelow.contentNode;
      } else {
        x = closestLeft.contentRect.right;
        target = closestLeft.contentNode;
      }
    } else if (closestBelow && closestRight) {
      if (isRectOnSameLineOfRect(closestBelow.contentRect, closestRight.contentRect)) {
        y = closestBelow.contentRect.top;
        target = closestBelow.contentNode;
      } else {
        x = closestRight.contentRect.left;
        target = closestRight.contentNode;
      }
    } else if (closestLeft) {
      x = closestLeft.contentRect.right;
      target = closestLeft.contentNode;
    } else if (closestRight) {
      x = closestRight.contentRect.left;
      target = closestRight.contentNode;
    } else if (closestBelow) {
      // 如果不是正下方，是左下方或者右下方
      // 则x坐标需要进行左移或者右移
      if (isPointOnLeftOfRect(x, y, closestBelow.contentRect)) {
        x = closestBelow.contentRect.left;
      } else if (isPointOnRightOfRect(x, y, closestBelow.contentRect)) {
        x = closestBelow.contentRect.right;
      }

      y = closestBelow.contentRect.top;
      target = closestBelow.contentNode;
    } else if (closestTop) {
      if (isPointOnLeftOfRect(x, y, closestTop.contentRect)) {
        x = closestTop.contentRect.left;
      } else if (isPointOnRightOfRect(x, y, closestTop.contentRect)) {
        x = closestTop.contentRect.right;
      }

      y = closestTop.contentRect.bottom;
      target = closestTop.contentNode;
    }
  }

  if (!(target instanceof Element)) {
    return null;
  }

  if (findClosestInContent(target, `[${Selector.void}]`)) {
    const node = findClosestInContent(target, `[${Selector.void}]`);
    let textNode = null;
    let offset = 0;

    if (closestLeftEdge && Math.round(x) === Math.round(closestLeftEdge)) {
      const nextTextNode = node?.nextElementSibling?.querySelector(`span[${Selector.leaf}]`)?.firstChild;
      textNode = nextTextNode instanceof Text ? nextTextNode : null;
    } else if (closestRightEdge && Math.round(x) === Math.round(closestRightEdge)) {
      const nextTextNode = node?.previousElementSibling?.querySelector(`span[${Selector.leaf}]`)?.firstChild;
      textNode = nextTextNode instanceof Text ? nextTextNode : null;
      offset = textNode?.textContent?.length || 0;
    }

    return {
      node: textNode || node,
      offset
    };
  }

  if (findClosestInContent(target, `span[${Selector.leaf}]`)) {
    const leafContent = target.getAttribute(Selector.leaf) ? target : target.querySelector(`span[${Selector.leaf}]`);
    const textNode = leafContent && leafContent.firstChild;

    if (textNode instanceof Text && textNode.textContent === CANGJIE_EMPTY) {
      return {
        node: textNode,
        offset: 0
      };
    }

    if (textNode instanceof Text && textNode.textContent) {
      const offset = binarySearchOffset(textNode, x, y, 0, textNode.textContent.length, textNode.textContent.length);
      return {
        node: textNode,
        offset
      };
    }

    return null;
  }

  return null;
}

function caretRangeFromTargetAndCoord(eventTarget, mouseX, mouseY, controller) {
  let target = eventTarget;

  if (target instanceof Text) {
    target = target.parentNode;
  } else if (target.shadowRoot) {
    target = target.shadowRoot.querySelector(`[${Selector.content}]`);
  }

  if (!target || !(target instanceof Element)) {
    return null;
  }

  let [x, y] = [mouseX, mouseY];

  if (target.getAttribute(Selector.content)) {
    const editable = target.querySelector(`[${Selector.editable}]`);

    if (editable) {
      const editableRect = editable.getBoundingClientRect();

      if (x < editableRect.left) {
        x = editableRect.left;
      } else if (x > editableRect.right) {
        x = editableRect.right - 1;
      }

      if (y < editableRect.top) {
        y = editableRect.top;
      } else if (y > editableRect.bottom) {
        y = editableRect.bottom - 1;
      } // ref: https://developer.mozilla.org/en-US/docs/Web/API/Node/getRootNode


      const root = target.getRootNode();
      const adjustedTarget = typeof root.elementFromPoint === 'function' ? root.elementFromPoint(x, y) : null;

      if (adjustedTarget) {
        target = adjustedTarget;
      }
    }
  }

  const point = caretPointFromTargetAndCoord({
    eventTarget: target,
    adjustedX: x,
    adjustedY: y,
    mouseX,
    mouseY
  });

  if (!point || !point.node) {
    return null;
  }

  const nodeKey = point.node instanceof Element ? point.node.getAttribute(Selector.key) : null;

  if (point.edge && nodeKey) {
    const pointProperties = {
      key: nodeKey,
      edge: point.edge
    };
    const anchor = Point.create(pointProperties);
    return Selection.create({
      anchor,
      focus: anchor
    });
  }

  const native = document.createRange();

  try {
    native.setStart(point.node, point.offset);
    native.setEnd(point.node, Math.max(point.offset, 0));
  } catch (error) {
    return null;
  }

  return native && findRange(native, controller);
}

const ROOT_TO_CONTROLLER = new WeakMap();
const CONTROLLER_TO_KEY_DOM = new WeakMap();

function getElementByCangjieKey(key, root) {
  let KEY_DOM;
  const controller = ROOT_TO_CONTROLLER.get(root);

  if (controller) {
    if (!CONTROLLER_TO_KEY_DOM.has(controller)) {
      CONTROLLER_TO_KEY_DOM.set(controller, new Map());
    }

    KEY_DOM = CONTROLLER_TO_KEY_DOM.get(controller);
  }

  if (KEY_DOM && KEY_DOM.has(key)) {
    return KEY_DOM.get(key);
  }

  if (root instanceof Element && key === root.getAttribute(Selector.key)) {
    return root;
  }

  return root.querySelector(`[${Selector.key}="${key}"]`);
}

/**
 * @packageDocumentation
 * @module domUtils
 */
/**
 * 根据节点的 key 查找对应的 DOM 节点。如果找不到，就返回 null
 */

function findDOMNodeSafely(key, root = window) {
  const node = root !== window ? getElementByCangjieKey(key, root) : getElementByCangjieKey(key, root.document);
  return node || undefined;
}
/**
 * 根据节点的 key 查找对应的 DOM 节点。如果找不到，就 throw error。
 * 类似的 API：domUtils.findDOMNodeSafely
 */

function findDOMNode(key, root = window) {
  const node = findDOMNodeSafely(key, root);

  if (!node) {
    throw new Error(`Unable to find a DOM node for "${key}". This is often because of forgetting to add \`props.attributes\` to a custom component.`);
  }

  return node;
}

function findDOMLeaves(key, root = window) {
  const element = root instanceof Element ? root : root.document;
  const firstLeaf = getElementByCangjieKey(`${key}:0`, element);
  const leafBlock = firstLeaf?.closest(`[${Selector.leafBlock}]`);
  return leafBlock ? Array.from(leafBlock.querySelectorAll(`[${Selector.key}^="${key}:"]`)) : [];
}

/**
 * @packageDocumentation
 * @module domUtils
 */
/**
 * 根据 Point 来获取浏览器的 HTML 节点、offset。
 */

function findDOMPoint(point, root = window) {
  const leaves = findDOMLeaves(point.key, root);
  let start = 0; // eslint-disable-next-line no-restricted-syntax

  for (const leaf of leaves) {
    const node = leaf.firstChild;
    const length = node && node.textContent ? node.textContent.length : 0;
    const end = start + length;

    if (point.offset <= end) {
      const offset = point.offset - start;
      return {
        node,
        offset
      };
    }

    start = end;
  }

  return null;
}

/* eslint-disable react/no-find-dom-node */
/**
 * 根据仓颉的 RangeSelection 获取浏览器的 Range。
 */

function findDOMRange(range, controller, root = window) {
  const {
    document
  } = controller.value;
  const {
    isCollapsed
  } = range;
  const {
    start,
    end
  } = range.convertToTextPoints(document); // @ts-ignore

  const r = ('document' in root ? root.document : root.ownerDocument).createRange();
  const domStart = findDOMPoint(start, root);
  const domEnd = isCollapsed ? domStart : findDOMPoint(end, root); // 查找 Range 时，首先查找文字选区，若文字选区不存在，则判断是否存在 void 选区

  try {
    if (domStart && domStart.node) {
      r.setStart(domStart.node, domStart.offset);
    } else {
      const startVoidNode = document.getClosestVoid(start.key, controller);

      if (startVoidNode) {
        const domNode = findDOMNode(startVoidNode.key, root);
        r.setStartBefore(domNode);
      } else {
        return null;
      }
    }

    if (domEnd && domEnd.node) {
      r.setEnd(domEnd.node, domEnd.offset);
    } else {
      const endVoidNode = document.getClosestVoid(end.key, controller);

      if (endVoidNode) {
        const domNode = findDOMNode(endVoidNode.key, root);
        r.setEndAfter(domNode);
      } else {
        return null;
      }
    }
  } catch (error) {
    console.error(error);
    return null;
  }

  return r;
}

/**
 * @packageDocumentation
 * @ignore
 */
function getAroundRects(point) {
  if (!point.isTextPoint()) {
    return [];
  }

  const prevPoint = point.moveBackward();
  const nextPoint = point.moveForward();

  if (prevPoint.offset < 0) {
    return [];
  }

  let domPoint = null;
  let prevDomPoint = null;
  let nextDomPoint = null;

  try {
    domPoint = findDOMPoint(point);
    prevDomPoint = findDOMPoint(prevPoint);
    nextDomPoint = findDOMPoint(nextPoint);
  } catch (error) {// ignore
  }

  if (!domPoint || !domPoint.node || !prevDomPoint || !prevDomPoint.node || !nextDomPoint || !nextDomPoint.node) {
    return [];
  }

  const firstRange = window.document.createRange();
  const secondRange = window.document.createRange();

  try {
    firstRange.setStart(prevDomPoint.node, prevDomPoint.offset);
    firstRange.setEnd(domPoint.node, domPoint.offset);
    secondRange.setStart(domPoint.node, domPoint.offset);
    secondRange.setEnd(nextDomPoint.node, nextDomPoint.offset);
  } catch (error) {
    return [];
  }

  const firstRects = Array.from(firstRange.getClientRects()).filter(r => r.width > 0);
  const secondRects = Array.from(secondRange.getClientRects()).filter(r => r.width > 0);
  const firstRect = firstRects[firstRects.length - 1];
  const secondRect = secondRects[0];
  return [firstRect, secondRect];
}
function findRectsInEdgePoint(point) {
  const [firstRect, secondRect] = getAroundRects(point);

  if (!firstRect || !secondRect || typeof DOMRect === 'undefined') {
    return [];
  }

  return [new DOMRect(firstRect.right, firstRect.top, 0, firstRect.height), new DOMRect(secondRect.left, secondRect.top, 0, secondRect.height)];
}
function isPointAtEdge(point) {
  const [firstRect, secondRect] = getAroundRects(point);

  if (!firstRect || !secondRect) {
    return false;
  }
  /**
   * The comparsion was secondRect.left < firstRect.right, but it's 0.xx px
   * incorrect for adjusting bold mark.
   */


  return secondRect.left < firstRect.left;
}

/**
 * @packageDocumentation
 * @ignore
 */
function findRectFromPoint(point, isHanging, controller) {
  if (!point.isTextPoint()) {
    // eslint-disable-next-line react/no-find-dom-node
    const node = findDOMNode(point.key);
    return node.getBoundingClientRect();
  }

  const {
    document
  } = controller.value;
  const text = document.getNode(point.key)?.text;
  const isAfterNewLine = text && text[point.offset - 1] === '\n';
  const isAtEdge = isPointAtEdge(point);

  if (isAtEdge) {
    const edgeRects = findRectsInEdgePoint(point);
    return isHanging ? edgeRects[edgeRects.length - 1] : edgeRects[0];
  }

  const domRange = findDOMRange(Selection.create({
    anchor: point,
    focus: point
  }), controller);

  if (!domRange) {
    return null;
  }

  const rangeRects = domRange.getClientRects(); // choose last rect when the point is hanging or after \n

  return isHanging || isAfterNewLine ? rangeRects[rangeRects.length - 1] : rangeRects[0];
}

const cache = new WeakMap();
const cacheLocalCaret = (controller, position, wrapper) => {
  cache.set(controller, {
    caret: position,
    wrapper
  });
};
const getLocalCaretPos = controller => {
  return cache.get(controller)?.caret;
};
const getLocalCaretPosDetail = controller => {
  return cache.get(controller);
};

/**
 * @packageDocumentation
 * @ignore
 */
/**
 * 从 from 垂直变到 to 点时，新的点是否为 isHanging
 * @param from 起始 Point
 * @param to 目标 Point
 * @returns isHanging
 */

function shouldBeHangingByVertically(from, to, controller) {
  if (to.isEdgePoint()) {
    return false;
  }

  const [firstRect, secondRect] = getAroundRects(to);

  if (!firstRect || !secondRect) {
    return false;
  }

  if (from.isEdgePoint()) {
    return secondRect.left < firstRect.left && from.edge === EdgePoint.BEFORE;
  }

  const fromPos = getLocalCaretPos(controller);

  if (!fromPos || secondRect.left >= firstRect.left) {
    return false;
  } // to 在边界点上，且起点更靠近 secondRect.left 时，应为 isHanging


  return fromPos.left - secondRect.left < firstRect.right - fromPos.left;
}
function isCoordAtLeftSide(clientX, controller) {
  const {
    document
  } = controller.value; // eslint-disable-next-line react/no-find-dom-node

  const articleDom = findDOMNode(document.key);

  if (!articleDom) {
    return false;
  }

  const rect = articleDom.getBoundingClientRect();
  return clientX < rect.left + rect.width / 2;
}

/* eslint-disable react/no-find-dom-node */

/**
 *
 * move point out of inline IF it's located at inline edges
 *
 * Optimizition for non-void inlines (e.g. <Link> elements) for better experience
 *
 * Before: <link>[anchor]www.dingtalk.com[focus]</link>
 * After: [anchor]<link>www.dingtalk.com</link>[focus]
 */
const correctPointInsideInlineOrBlock = (controller, point) => {
  const {
    document
  } = controller.value;
  const parent = document.getClosestInline(point.key);

  if (!parent || controller.query('isVoid', parent) || controller.query('isInlineBlock', parent)) {
    return point;
  }

  if (point.offset === 0) {
    const textNode = document.getPreviousText(point.key);

    if (textNode) {
      const {
        key
      } = textNode;
      const offset = textNode.text.length;
      return TextPoint.create({
        key,
        offset
      });
    }
  } else if (point.offset === parent.text.length) {
    const textNode = document.getNextText(point.key);

    if (textNode) {
      const {
        key
      } = textNode;
      const offset = 0;
      return TextPoint.create({
        key,
        offset
      });
    }
  }

  return point;
};

function* iterateTextNodesFromPoint(document, at, reverse) {
  const atNode = document.getNode(at.key);

  if (!atNode) {
    return;
  }

  if (atNode.isText()) {
    yield atNode;
  }

  const next = key => {
    return reverse ? document.getPreviousText(key) : document.getNextText(key);
  };

  const startText = element => {
    return reverse ? element.getLastText() : element.getFirstText();
  };

  const goDeep = at.isEdgePoint() && (at.edge === EdgePoint.BEFORE && !reverse || at.edge === EdgePoint.AFTER && reverse);
  let node = goDeep && atNode.isElement() ? startText(atNode) : next(atNode.key);

  while (node) {
    yield node;
    node = next(node.key);
  }
}

function* iteratePositionsFromPoint(controller, at, unit, reverse) {
  const {
    document
  } = controller.value;

  const step = (t, o) => {
    if (unit === 'offset') {
      const nextCharStep = textUtils.getCharOffset(t, o, reverse);
      return nextCharStep || 1;
    }

    const count = textUtils.getMoveWordOffset(t, o, reverse);
    return Math.max(count, 1);
  }; // We ignore the start point by default, since the start point is the same
  // point as the end point of the previous text


  let shouldCountStartPoint = false;
  let lastBlock = document.getClosestBlock(at.key);
  let offset = 0;

  function getEdgePoint(nodeKey, isAtEntrance) {
    const closestBlock = document.getClosestSelectableBlock(nodeKey, controller);

    if (!closestBlock) {
      return null;
    }

    const firstText = closestBlock.getFirstText();
    const lastText = closestBlock.getLastText();
    let edgeText = firstText;

    if (isAtEntrance) {
      // alway skip the entrance WHEN started at a selectable inside node
      if (closestBlock.getNode(at.key)) {
        return null;
      }

      edgeText = reverse ? lastText : firstText;
    } else {
      edgeText = reverse ? firstText : lastText;
    }

    const isTextAtEdge = edgeText?.key === nodeKey;

    if (!isTextAtEdge) {
      return null;
    }

    const {
      key
    } = closestBlock;
    const edge = reverse && isAtEntrance || !reverse && !isAtEntrance ? EdgePoint.AFTER : EdgePoint.BEFORE;
    return {
      key,
      edge
    };
  }

  for (const node of iterateTextNodesFromPoint(document, at, reverse)) {
    const {
      text,
      key
    } = node;
    const closestBlock = document.getClosestBlock(key);
    let nodePoint = getEdgePoint(key, true);

    if (nodePoint) {
      yield nodePoint;
    } // skip the void elements and count the next start point


    if (document.getClosestVoid(node.key, controller)) {
      nodePoint = getEdgePoint(key, false);

      if (nodePoint) {
        yield nodePoint;
      }

      shouldCountStartPoint = true;
      continue;
    } // it's another block, count the next start point


    if (lastBlock !== closestBlock) {
      lastBlock = closestBlock;
      shouldCountStartPoint = true;
    } // calculate the start point (offset)


    if (at.isTextPoint() && node.key === at.key) {
      // special case: first text
      offset = reverse ? at.offset - step(text, at.offset) : at.offset + step(text, at.offset);
    } else if (shouldCountStartPoint) {
      // special case: count the start point
      offset = reverse ? text.length : 0;
      shouldCountStartPoint = false;
    } else {
      offset = reverse ? text.length - step(text, text.length) : step(text, 0);
    } // now iterate the text node


    while (offset <= text.length && offset >= 0) {
      yield {
        key,
        offset
      };
      reverse ? offset -= step(text, offset) : offset += step(text, offset);
    }

    nodePoint = getEdgePoint(key, false);

    if (nodePoint) {
      yield nodePoint;
    }
  }
}

function pointAtDistance(controller, at, distance = 1, unit = 'offset') {
  const {
    document
  } = controller.value;
  const reverse = distance < 0;
  let remaining = Math.abs(distance);

  if (unit === 'word' && at.isEdgePoint()) {
    const {
      key
    } = at;

    if (reverse && at.edge === EdgePoint.AFTER) {
      return EdgePoint.create({
        key,
        edge: EdgePoint.BEFORE
      });
    }

    if (!reverse && at.edge === EdgePoint.BEFORE) {
      return EdgePoint.create({
        key,
        edge: EdgePoint.AFTER
      });
    }
  }

  for (const pt of iteratePositionsFromPoint(controller, at, unit, reverse)) {
    remaining -= 1;

    if (remaining <= 0) {
      return Point.create(pt);
    }
  }

  return controller.query(pointAtNodeEdge, document, reverse ? 'start' : 'end');
}
function pointAtStartOfNode(controller, node) {
  return controller.query(pointAtNodeEdge, node, 'start');
}
function pointAtEndOfNode(controller, node) {
  return controller.query(pointAtNodeEdge, node, 'end');
}

function pointAtNodeEdge(controller, node, where) {
  const {
    document
  } = controller.value;
  const targetNode = where === 'start' ? node.getFirstNode() : node.getLastNode(); // 获取 node 下距离 targetNode 最远的可 edgeSelectable 的 block 节点

  const furthestBlock = document.getFurthestSelectableBlock(targetNode.key, node.key, controller); // 若存在 furthestBlock 则返回该 block 的 edge point

  if (furthestBlock) {
    const {
      key
    } = furthestBlock;
    const edge = where === 'start' ? EdgePoint.BEFORE : EdgePoint.AFTER;
    return EdgePoint.create({
      key,
      edge
    });
  } // 否则返回 targetNode 内 的 text point


  const {
    key
  } = targetNode;
  const offset = where === 'start' ? 0 : targetNode.text.length;
  return TextPoint.create({
    key,
    offset
  });
}

function getTrueRectFromPoint(controller, point, isHanging) {
  const {
    document
  } = controller.value;
  const node = document.assertNode(point.key);
  const closestVoid = controller.query('isVoid', node) ? node : document.getClosestVoid(point.key, controller);
  let rangeRect = null;

  if (closestVoid) {
    rangeRect = findDOMNode(closestVoid.key).getBoundingClientRect();
  } else {
    rangeRect = findRectFromPoint(point, isHanging, controller);
  }

  if (!rangeRect) {
    return null;
  }

  return rangeRect;
}

function getUpsidePoint(controller, point, isHanging, lockedX) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const rangeRect = getTrueRectFromPoint(controller, point, isHanging);

  if (!rangeRect) {
    return null;
  }

  const rectX = point.isEdgePoint() && point.edge === EdgePoint.AFTER ? rangeRect.right : rangeRect.left;
  const x = typeof lockedX === 'number' ? lockedX : rectX;
  let y = rangeRect.top;
  let currentBlock = document.getClosestBlockFromPoint(point.key);
  let currentBlockDOM = null;
  let currentLeafDOMs;
  let found = false;

  while (!found) {
    if (!currentBlock) {
      return null;
    }

    const closestBlock = document.getClosestSelectableBlock(currentBlock.key, controller);

    if (closestBlock && closestBlock.key !== point.key && !closestBlock.getNode(point.key)) {
      const {
        key
      } = closestBlock;
      const edge = isCoordAtLeftSide(x, controller) ? EdgePoint.BEFORE : EdgePoint.AFTER;
      return EdgePoint.create({
        key,
        edge
      });
    }

    try {
      currentBlockDOM = findDOMNode(currentBlock.key, window);
    } catch (e) {
      currentBlock = document.getPreviousBlock(currentBlock.key);
      continue;
    }

    currentLeafDOMs = Array.from(currentBlockDOM.querySelectorAll(`span[${Selector.leaf}]`)).reverse(); // eslint-disable-next-line no-restricted-syntax

    for (const leafDOM of currentLeafDOMs) {
      if (found) {
        break;
      }

      const blockRects = Array.from(leafDOM.getClientRects()).filter(rect => rect.height > 0);
      const blockRectsLength = blockRects.length; // eslint-disable-next-line no-plusplus

      for (let i = blockRectsLength - 1; i >= 0; i--) {
        const blockRect = blockRects[i];

        if (blockRect.bottom <= y) {
          found = true;
          y = blockRect.bottom - blockRect.height / 2;
          break;
        }
      }
    }

    currentBlock = document.getPreviousBlock(currentBlock.key);
  }

  const range = currentBlockDOM && caretRangeFromTargetAndCoord(currentBlockDOM, x, y, controller);

  if (!range) {
    return null;
  }

  return range.anchor;
}
function getUpsideRange(controller) {
  const {
    value
  } = controller;
  const {
    document,
    selection
  } = value;

  if (!selection) {
    return null;
  }

  const start = selection.getStart(document);
  const {
    isHanging
  } = selection;
  const point = getUpsidePoint(controller, start, isHanging);

  if (!point) {
    return selection.moveToStartOfDocument(controller);
  }

  const nextIsHanging = shouldBeHangingByVertically(start, point, controller);
  const newRange = selection.moveAnchorTo(point.key, point.isEdgePoint() ? point.edge : point.offset).moveToAnchor().setHanging(nextIsHanging);
  return newRange;
}
function getDownsidePoint(controller, point, isHanging, lockedX) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const rangeRect = getTrueRectFromPoint(controller, point, isHanging);

  if (!rangeRect) {
    return null;
  }

  const rectX = point.isEdgePoint() && point.edge === EdgePoint.AFTER ? rangeRect.right : rangeRect.left;
  const x = typeof lockedX === 'number' ? lockedX : rectX;
  let y = rangeRect.bottom;
  let currentBlock = document.getClosestBlockFromPoint(point.key);
  let currentBlockDOM = null;
  let currentLeafDOMs;
  let found = false;

  while (!found) {
    if (!currentBlock) {
      return null;
    }

    const closestBlock = document.getClosestSelectableBlock(currentBlock.key, controller);

    if (closestBlock && closestBlock.key !== point.key && !closestBlock.getNode(point.key)) {
      const {
        key
      } = closestBlock;
      const edge = isCoordAtLeftSide(x, controller) ? EdgePoint.BEFORE : EdgePoint.AFTER;
      return EdgePoint.create({
        key,
        edge
      });
    }

    try {
      currentBlockDOM = findDOMNode(currentBlock.key, window);
    } catch (e) {
      currentBlock = document.getNextBlock(currentBlock.key);
      continue;
    }

    currentLeafDOMs = Array.from(currentBlockDOM.querySelectorAll(`span[${Selector.leaf}]`)); // eslint-disable-next-line no-restricted-syntax

    for (const leafDOM of currentLeafDOMs) {
      if (found) {
        break;
      }

      const blockRects = Array.from(leafDOM.getClientRects()).filter(rect => rect.height > 0);
      const blockRectsLength = blockRects.length; // eslint-disable-next-line no-plusplus

      for (let i = 0; i <= blockRectsLength - 1; i++) {
        const blockRect = blockRects[i];

        if (blockRect.top >= y) {
          found = true;
          y = blockRect.top + blockRect.height / 2;
          break;
        }
      }
    }

    currentBlock = document.getNextBlock(currentBlock.key);
  }

  const range = currentBlockDOM && caretRangeFromTargetAndCoord(currentBlockDOM, x, y, controller);

  if (!range) {
    return null;
  }

  return range.anchor;
}
function getDownsideRange(controller) {
  const {
    value
  } = controller;
  const {
    document,
    selection
  } = value;

  if (!selection) {
    return null;
  }

  const start = selection.getStart(document);
  const {
    isHanging
  } = selection;
  const point = getDownsidePoint(controller, start, isHanging);

  if (!point) {
    return selection.moveToEndOfDocument(controller);
  }

  const nextIsHanging = shouldBeHangingByVertically(start, point, controller);
  const newRange = selection.moveAnchorTo(point.key, point.isEdgePoint() ? point.edge : point.offset).moveToAnchor().setHanging(nextIsHanging);
  return newRange;
}

/**
 * @packageDocumentation
 * @module Models
 */
let SelectionTrigger;

(function (SelectionTrigger) {
  SelectionTrigger["Selecting"] = "selecting";
  SelectionTrigger["SelectStart"] = "selectStart";
  SelectionTrigger["SelectAll"] = "selectAll";
  SelectionTrigger["MoveUpward"] = "moveUpward";
  SelectionTrigger["MoveDownward"] = "moveDownward";
  SelectionTrigger["MoveBackward"] = "moveBackward";
  SelectionTrigger["MoveForward"] = "moveForward";
  SelectionTrigger["MultipleClick"] = "multipleClick";
})(SelectionTrigger || (SelectionTrigger = {}));

const IS_COLLAPSED_CACHE = new WeakMap();
const IS_FORWARD_CACHE = new WeakMap();
class Selection extends ImmutableRecord {
  static create(props) {
    if (Selection.isSelection(props)) {
      return props;
    }

    if (isPlainObject__default["default"](props)) {
      const {
        data = {},
        anchor,
        focus,
        marks
      } = props;
      return new Selection({
        data,
        anchor: Point.create(anchor),
        focus: Point.create(focus),
        marks: marks ? marks.map(mark => Mark.create(mark)) : null
      });
    }

    throw new Error(`\`Selection.create\` only accepts objects or range selections, but you passed it: ${props}`);
  }
  /**
   * 调整range的开始位置和结束位置，使其"收缩"到最小的位置， 如果ignoreEnd的值为true，则忽略对结束位置的调整
   * @param document
   * @param ignoreEnd 如果ignoreEnd的值为true，则忽略对结束位置的调整
   * @example
   * before:1234<anchor/><link>56<focus/>78</link>90
   * after:1234<link><anchor/>56<focus/>78</link>90
   */


  shrinkBoundary(document, ignoreEnd) {
    const start = this.getStart(document);
    const end = this.getEnd(document);

    if (!start.isTextPoint() || !end.isTextPoint()) {
      return this;
    }

    const isForward = this.isForward(document);
    let targetRange = this;

    if (!ignoreEnd && end.offset === 0) {
      const targetEndText = document.getPreviousText(end.key);

      if (targetEndText) {
        targetRange = targetRange.set(isForward ? 'focus' : 'anchor', TextPoint.fromJSON({
          key: targetEndText.key,
          offset: targetEndText.text.length
        }));
      }
    }

    const beforeStartText = document.getNode(start.key);

    if (beforeStartText && start.offset === beforeStartText.text.length) {
      const targetStartText = document.getNextText(start.key);

      if (targetStartText) {
        targetRange = targetRange.set(isForward ? 'anchor' : 'focus', Point.fromJSON({
          key: targetStartText.key,
          offset: 0
        }));
      }
    }

    return targetRange;
  }

  static fromJSON(json) {
    const {
      data,
      anchor,
      focus,
      marks
    } = json;
    return Selection.create({
      data,
      anchor: Point.fromJSON(anchor),
      focus: Point.fromJSON(focus),
      marks: marks ? marks.map(mark => Mark.fromJSON(mark)) : null
    });
  }

  static isSelection(maybeSelection) {
    return maybeSelection instanceof Selection;
  }

  static isRangeSelection(maybeSelection) {
    return Selection.isSelection(maybeSelection);
  }

  static isValidSelection(document, selection) {
    if (!Selection.isSelection(selection)) {
      return false;
    }

    const {
      anchor,
      focus
    } = selection;
    const anchorNode = document.getNode(anchor.key);
    const focusNode = document.getNode(focus.key);

    if (!anchorNode || !focusNode) {
      return false;
    }

    const isAnchorValid = anchor.isTextPoint() && anchor.offset >= 0 && anchor.offset <= anchorNode.text.length || anchor.isEdgePoint();
    const isFocusValid = focus.isTextPoint() && focus.offset >= 0 && focus.offset <= focusNode.text.length || focus.isEdgePoint();
    return isAnchorValid && isFocusValid;
  }

  static isValidRangeSelection(document, selection) {
    return Selection.isValidSelection(document, selection);
  }

  static selectWordAtPoint(document, point) {
    if (point.isEdgePoint()) {
      return Selection.create({
        anchor: point.set('edge', EdgePoint.BEFORE),
        focus: point.set('edge', EdgePoint.AFTER)
      });
    }

    const text = document.getNode(point.key);

    if (!text) {
      return null;
    }

    const [start, end] = textUtils.getWordRange(text.text, point.offset);
    return Selection.create({
      anchor: point.set('offset', start),
      focus: point.set('offset', end)
    });
  }

  static isEqual(rangSelection, target) {
    return equal__default["default"](rangSelection.anchor, target.anchor) && equal__default["default"](rangSelection.focus, target.focus);
  }

  constructor(props) {
    super();
    this.data = void 0;
    this.anchor = void 0;
    this.focus = void 0;
    this.marks = void 0;
    const {
      data,
      anchor,
      focus,
      marks = null
    } = props;
    this.data = data;
    this.anchor = anchor;
    this.focus = focus;
    this.marks = marks;
    this.freeze();
  }
  /**
   * 选区是否指向同一个位置（caret）
   */


  get isCollapsed() {
    if (!IS_COLLAPSED_CACHE.has(this)) {
      const {
        anchor,
        focus
      } = this;
      IS_COLLAPSED_CACHE.set(this, equal__default["default"](anchor, focus));
    }

    return IS_COLLAPSED_CACHE.get(this);
  }
  /**
   * 选区是否是扩展
   */


  get isExpanded() {
    return !this.isCollapsed;
  }

  get viewKey() {
    const keyStr = `${this.anchor.viewKey}_${this.focus.viewKey}`;

    try {
      return `${keyStr}_${JSON.stringify(this.data)}`;
    } catch (error) {
      return keyStr;
    }
  }

  get plainViewKey() {
    return `${this.anchor.viewKey}_${this.focus.viewKey}`;
  }

  merge(props) {
    return new Selection({
      data: this.data,
      anchor: this.anchor,
      focus: this.focus,
      marks: this.marks,
      ...props
    });
  }

  set(key, value) {
    return this.merge({
      [key]: value
    });
  }

  isForwardInDocument(document) {
    const {
      anchor,
      focus
    } = this; // same node

    if (anchor.key === focus.key) {
      if (anchor.isEdgePoint()) {
        return anchor.edge === EdgePoint.BEFORE;
      }

      if (focus.isEdgePoint()) {
        return focus.edge === EdgePoint.AFTER;
      }

      return anchor.offset <= focus.offset;
    } // parent-child


    if (anchor.isEdgePoint()) {
      const anchorNode = document.getNode(anchor.key);

      if (anchorNode?.isElement() && anchorNode.getNode(focus.key)) {
        return anchor.edge === EdgePoint.BEFORE;
      }
    }

    if (focus.isEdgePoint()) {
      const focusNode = document.getNode(focus.key);

      if (focusNode?.isElement() && focusNode.getNode(anchor.key)) {
        return focus.edge === EdgePoint.AFTER;
      }
    } // other relationship


    const anchorPath = anchor.getPathIn(document);
    const focusPath = focus.getPathIn(document);
    return Boolean(anchorPath && focusPath && Path.isBefore(anchorPath, focusPath));
  }
  /**
   * 选区是不是正序的（anchor在前，focus在后）
   */


  isForward(document) {
    if (!IS_FORWARD_CACHE.has(this)) {
      IS_FORWARD_CACHE.set(this, new WeakMap());
    }

    const DOCUMENT_TO_IS_FORWARD_CACHE = IS_FORWARD_CACHE.get(this);

    if (!DOCUMENT_TO_IS_FORWARD_CACHE.has(document)) {
      DOCUMENT_TO_IS_FORWARD_CACHE.set(document, this.isForwardInDocument(document));
    }

    return DOCUMENT_TO_IS_FORWARD_CACHE.get(document);
  }
  /**
   * 选区是不是倒序的（anchor在后，focus在前）
   */


  isBackward(document) {
    return !this.isForward(document);
  }
  /**
   * 获取start point
   */


  getStart(document) {
    return this.isForward(document) ? this.anchor : this.focus;
  }
  /**
   * 获取end point
   */


  getEnd(document) {
    return this.isBackward(document) ? this.anchor : this.focus;
  }
  /**
   * 根据PointName，获取point
   */


  getPoint(pointName, document) {
    if (pointName === 'start') {
      return this.getStart(document);
    } else if (pointName === 'end') {
      return this.getEnd(document);
    } else {
      return this[pointName];
    }
  }
  /**
   * 同时获取start point、end point
   */


  sort(document) {
    return {
      start: this.getStart(document),
      end: this.getEnd(document)
    };
  }
  /**
   * 把当前的数据选区的 Points 转换成 TextPoints。
   */


  convertToTextPoints(document) {
    let {
      start,
      end
    } = this.sort(document);

    if (this.isCollapsed) {
      const point = start.convertToTextPoint(document);
      return {
        anchor: point,
        focus: point,
        start: point,
        end: point
      };
    }

    if (start.isEdgePoint()) {
      if (start.edge === EdgePoint.BEFORE) {
        start = start.convertToTextPoint(document);
      } else {
        const startNode = document.getNextText(start.key) || document.getFirstNode();
        start = TextPoint.create({
          key: startNode.key,
          offset: 0
        });
      }
    }

    if (end.isEdgePoint()) {
      if (end.edge === EdgePoint.AFTER) {
        end = end.convertToTextPoint(document);
      } else {
        const endNode = document.getPreviousText(end.key) || document.getLastNode();
        end = TextPoint.create({
          key: endNode.key,
          offset: endNode.text.length
        });
      }
    }

    const isForward = this.isForward(document);
    const anchor = isForward ? start : end;
    const focus = isForward ? end : start;
    return {
      anchor,
      focus,
      start,
      end
    };
  }
  /**
   * 获得当前选区所处的 Node
   * @param document
   */


  getClosestNode(document) {
    const {
      start,
      end
    } = this.convertToTextPoints(document);
    const aPath = document.getPath(start.key);
    const bPath = document.getPath(end.key);

    if (!aPath || !bPath) {
      return null;
    }

    const node = document.getNodeByPath(Path.common(aPath, bPath));

    if (node?.isText()) {
      return document.getClosestBlock(node.key);
    }

    return node;
  }
  /**
   * 选区是否在Hanging状态
   */


  get isHanging() {
    return Boolean(this.data.isHanging);
  }

  get isCollapsedAtEdge() {
    return this.isCollapsed && this.anchor.isEdgePoint();
  }
  /**
   * 拷贝出一个新的选区，并设置选区的Haning状态
   */


  setHanging(isHanging) {
    if (this.data.isHanging !== isHanging) {
      return this.merge({
        data: { ...this.data,
          isHanging
        }
      });
    }

    return this;
  }
  /**
   * 拷贝出一个新的选区，并把start point移到end point的位置
   */


  moveToEnd(document) {
    if (this.isBackward(document)) {
      return this.merge({
        focus: this.getEnd(document)
      });
    }

    return this.merge({
      anchor: this.getEnd(document)
    });
  }

  moveStartToStartOfNode(node, controller) {
    const {
      document
    } = controller.value;

    if (this.isForward(document)) {
      return this.moveAnchorToStartOfNode(node, controller);
    } else {
      return this.moveFocusToStartOfNode(node, controller);
    }
  }

  moveStartToEndOfNode(node, controller) {
    const {
      document
    } = controller.value;

    if (this.isForward(document)) {
      return this.moveAnchorToEndOfNode(node, controller);
    } else {
      return this.moveFocusToEndOfNode(node, controller);
    }
  }

  moveEndToStartOfNode(node, controller) {
    const {
      document
    } = controller.value;

    if (this.isForward(document)) {
      return this.moveFocusToStartOfNode(node, controller);
    } else {
      return this.moveAnchorToStartOfNode(node, controller);
    }
  }

  moveEndToEndOfNode(node, controller) {
    const {
      document
    } = controller.value;

    if (this.isForward(document)) {
      return this.moveFocusToEndOfNode(node, controller);
    } else {
      return this.moveAnchorToEndOfNode(node, controller);
    }
  }

  moveAnchorToStartOfNode(node, controller) {
    return this.set('anchor', controller.query(pointAtStartOfNode, node));
  }

  moveAnchorToEndOfNode(node, controller) {
    return this.set('anchor', controller.query(pointAtEndOfNode, node));
  }

  moveFocusToStartOfNode(node, controller) {
    return this.set('focus', controller.query(pointAtStartOfNode, node));
  }

  moveFocusToEndOfNode(node, controller) {
    return this.set('focus', controller.query(pointAtEndOfNode, node));
  }

  moveAnchorTo(key, where) {
    return this.set('anchor', Point.createFromParams(key, where));
  }

  moveFocusTo(key, where) {
    return this.set('focus', Point.createFromParams(key, where));
  }

  moveToStartOfNode(node, controller) {
    const anchor = controller.query(pointAtStartOfNode, node);
    const focus = anchor;
    return this.merge({
      anchor,
      focus
    });
  }

  moveToEndOfNode(node, controller) {
    const anchor = controller.query(pointAtEndOfNode, node);
    const focus = anchor;
    return this.merge({
      anchor,
      focus
    });
  }
  /**
   * 拷贝出一个新的选区，并把anchor和focus调换位置
   */


  flip() {
    return this.merge({
      anchor: this.focus,
      focus: this.anchor
    });
  }

  moveAnchorBackward(n = 1, mover) {
    return mover ? mover('anchor', n)(this) : this.set('anchor', this.anchor.moveBackward(n));
  }

  moveAnchorForward(n = 1, mover) {
    return mover ? mover('anchor', n)(this) : this.set('anchor', this.anchor.moveForward(n));
  }

  moveFocusBackward(n = 1, mover) {
    return mover ? mover('focus', n)(this) : this.set('focus', this.focus.moveBackward(n));
  }

  moveFocusForward(n = 1, mover) {
    return mover ? mover('focus', n)(this) : this.set('focus', this.focus.moveForward(n));
  }

  moveToFocus() {
    return this.set('anchor', this.focus);
  }

  moveToAnchor() {
    return this.set('focus', this.anchor);
  }

  moveToStart(document) {
    const start = this.getStart(document);
    return this.merge({
      anchor: start,
      focus: start
    });
  }

  moveToRangeOfNode(node, controller) {
    return this.moveAnchorToStartOfNode(node, controller).moveFocusToEndOfNode(node, controller);
  }

  moveForward(n = 1, mover) {
    if (!mover) {
      return this.updatePoints(point => {
        return point.isTextPoint() ? point.moveForward(n) : point;
      });
    }

    return this.moveAnchorForward(n, mover).moveFocusForward(n, mover);
  }

  moveStartBackward(document, n) {
    if (this.isForward(document)) {
      return this.moveAnchorBackward(n);
    }

    return this.moveFocusBackward(n);
  }

  moveStartForward(document, n) {
    return this.moveStartBackward(document, -n);
  }

  moveEndBackward(document, n) {
    if (this.isForward(document)) {
      return this.moveFocusBackward(n);
    }

    return this.moveAnchorBackward(n);
  }

  moveEndForward(document, n) {
    return this.moveEndBackward(document, -n);
  }

  moveBackward(n = 1, mover) {
    if (!mover) {
      return this.updatePoints(point => {
        return point.isTextPoint() ? point.moveBackward(n) : point;
      });
    }

    return this.moveAnchorBackward(n, mover).moveFocusBackward(n, mover);
  }

  move(mover) {
    return mover(this);
  }

  moveToStartOfDocument(controller) {
    return this.moveToStartOfNode(controller.value.document, controller);
  }

  moveToEndOfDocument(controller) {
    return this.moveToEndOfNode(controller.value.document, controller);
  }

  movePointEdgeKlass(controller, pointName, edge, klass) {
    const {
      document
    } = controller.value;
    const PName = pointName.slice(0, 1).toUpperCase() + pointName.slice(1);
    const Edge = edge.slice(0, 1).toUpperCase() + edge.slice(1);
    const Object = klass.slice(0, 1).toUpperCase() + klass.slice(1);
    const method = `move${PName}To${Edge}OfNode`;
    const getNode = klass === 'text' ? 'getNode' : `getClosest${Object}`;
    const p = this.getPoint(pointName, document);
    const node = p.isTextPoint() ? document[getNode](p.key) : document.getNode(p.key);

    if (!node) {
      return this;
    }

    const newSelection = this[method](node, controller);
    return newSelection;
  }

  movePointEdgeSideKlass(controller, pointName, edge, side, klass) {
    const {
      document
    } = controller.value;
    const PName = pointName.slice(0, 1).toUpperCase() + pointName.slice(1);
    const Edge = edge.slice(0, 1).toUpperCase() + edge.slice(1);
    const Side = side.slice(0, 1).toUpperCase() + side.slice(1);
    const Klass = klass.slice(0, 1).toUpperCase() + klass.slice(1);
    const method = `move${PName}To${Edge}OfNode`;
    const getNode = klass === 'text' ? 'getNode' : `getClosest${Klass}`;
    const getDirectionNode = `get${Side}${Klass}`;
    const p = this.getPoint(pointName, document);
    const node = document[getNode](p.key);

    if (!node) {
      return this;
    }

    const target = document[getDirectionNode](node.key);

    if (!target) {
      return this;
    }

    const newSelection = this[method](target, controller);
    return newSelection;
  }

  updatePoints(updater) {
    let {
      anchor,
      focus
    } = this;
    anchor = updater(anchor);
    focus = updater(focus);
    return this.merge({
      anchor,
      focus
    });
  }

  toJSON(options) {
    return {
      klass: 'selection',
      anchor: this.anchor.toJSON(options),
      focus: this.focus.toJSON(options),
      marks: this.marks ? this.marks.map(m => m.toJSON()) : null
    };
  }

}

/**
 * @packageDocumentation
 * @module Models
 */
class Document extends Element$1 {
  static create(props = {}) {
    if (Document.isDocument(props)) {
      return props;
    }

    if (isPlainObject__default["default"](props)) {
      const {
        key = keyUtils.create(),
        data = {},
        nodes = []
      } = props;
      return new Document({
        key,
        data,
        nodes
      });
    }

    throw new Error(`\`Document.create\` only accepts objects or documents, but you passed it: ${props}`);
  }

  static fromJSON(json) {
    return Document.create({ ...json,
      nodes: json.nodes ? json.nodes.map(Block.fromJSON) : []
    });
  }

  static isDocument(maybeDocument) {
    return maybeDocument instanceof Document;
  }

  constructor(props) {
    super(props);
    this.type = 'document';
    this.nodes = void 0;
    const {
      nodes
    } = props;
    this.nodes = nodes;
  }

  merge(props) {
    return new Document({
      key: this.key,
      data: this.data,
      nodes: this.nodes,
      ...props
    });
  }

  set(key, value) {
    return this.merge({
      [key]: value
    });
  }
  /**
   * 获取selection内对应的所有marks
   */


  getMarksAtRange(range) {
    if (range.isCollapsed && range.anchor.isEdgePoint()) {
      return [];
    }

    const {
      start,
      end
    } = range.convertToTextPoints(this);

    if (range.isCollapsed) {
      return this.getMarksAtPosition(start.key, start.offset);
    }

    if (start.key === end.key) {
      const startText = this.getNode(start.key);
      return Text$1.isText(startText) ? startText.getMarksBetweenOffsets(start.offset, end.offset) : [];
    }

    const texts = this.getTextsBetweenPositions(start.key, end.key);
    return texts.reduce((marks, text) => {
      if (text.key === start.key) {
        return setUtils.union(marks, text.getMarksBetweenOffsets(start.offset, text.text.length));
      }

      if (text.key === end.key) {
        return setUtils.union(marks, text.getMarksBetweenOffsets(0, end.offset));
      }

      return setUtils.union(marks, text.getMarks());
    }, []);
  }
  /**
   * 获取selection内对应的所有公共marks
   */


  getActiveMarksAtRange(range) {
    if (range.isCollapsed && range.anchor.isEdgePoint()) {
      return [];
    }

    if (!Selection.isValidSelection(this, range)) {
      return [];
    }

    const {
      start,
      end
    } = range.convertToTextPoints(this);

    if (range.isCollapsed) {
      return this.getMarksAtPosition(start.key, start.offset);
    }

    const startNode = this.getNode(start.key);
    let startText = startNode?.isText() ? startNode : null;

    if (!startText) {
      return [];
    }

    let startKey = start.key;
    let startOffset = start.offset;
    let endKey = end.key;
    let endOffset = end.offset;

    if (startKey === endKey) {
      return startText.getActiveMarksBetweenOffsets(startOffset, endOffset);
    }

    while (startKey !== endKey && endOffset === 0) {
      const endText = this.getPreviousText(endKey);

      if (!endText) {
        return [];
      }

      endKey = endText.key;
      endOffset = endText.text.length;
    }

    while (startKey !== endKey && startOffset === startText.text.length) {
      startText = this.getNextText(startKey);

      if (!startText) {
        return [];
      }

      startKey = startText.key;
      startOffset = 0;
    }

    const startMarks = startText.getActiveMarksBetweenOffsets(startOffset, startText.text.length);
    if (startMarks.length === 0) return [];
    const endText = this.getNode(endKey);
    const endMarks = endText?.isText() ? endText.getActiveMarksBetweenOffsets(0, endOffset) : [];
    let marks = setUtils.intersect(startMarks, endMarks); // If marks is already empty, the active marks is empty

    if (marks.length === 0) return marks;
    if (startKey === endKey) return marks;
    let text = this.getNextText(startKey);

    while (text && text.key !== endKey) {
      if (text.text.length !== 0) {
        marks = setUtils.intersect(marks, text.getActiveMarks());
        if (marks.length === 0) return [];
      }

      text = this.getNextText(text.key);
    }

    return marks;
  }

  getMarksAtPosition(key, offset) {
    const text = this.getNode(key);
    const currentMarks = !text?.isText() ? [] : text.getMarksAtIndex(offset);

    if (offset !== 0) {
      return currentMarks;
    }

    const closestBlock = this.getClosestBlock(key);

    if (!closestBlock || closestBlock.text === '') {
      // Insert mark for empty block; the empty block are often created by split node or add marks in a range including empty blocks
      return currentMarks;
    }

    const previous = this.getPreviousText(key);

    if (previous && closestBlock.getNode(previous.key)) {
      return previous.getMarksAtIndex(previous.text.length);
    }

    return currentMarks;
  }
  /**
   * 获取插入点对应的marks
   * 如果选区是collapse的，返回插入位置的marks;
   * 如果插入位置在新的text节点，则尝试获取同一block的前一个text对应的mark；
   * 如果选区是expand，则返回start位置对应的marks
   */


  getInsertMarksAtRange(range) {
    if (range.isCollapsed && range.anchor.isEdgePoint()) {
      return [];
    }

    const {
      start
    } = range.convertToTextPoints(this);

    if (range.isCollapsed) {
      return this.getMarksAtPosition(start.key, start.offset);
    }

    const text = this.getNode(start.key);
    return !text?.isText() ? [] : text.getMarksAtIndex(start.offset + 1);
  }

  getNodesAtRange(range) {
    if (!range) {
      return [];
    }

    const doc = this;
    const start = range.getStart(doc);
    const end = range.getEnd(doc);
    const startPath = this.getPath(start.key);
    const endPath = this.getPath(end.key);
    const startIndex = startPath[0];
    const endIndex = endPath[0];
    const startBlock = this.nodes[startIndex];
    const endBlock = this.nodes[endIndex];
    const result = [];

    function push(node) {
      result.push(node);

      if (Block.isBlock(node) || Inline.isInline(node)) {
        node.nodes.forEach(push);
      }
    }

    function pushEdgeNode(node) {
      const path = doc.getPath(node.key);

      if (Path.isEqual(path, startPath) || Path.isAncestor(path, startPath) || Path.isAncestor(startPath, path) || Path.isEqual(path, endPath) || Path.isAncestor(path, endPath) || Path.isAncestor(endPath, path) || !range.isCollapsed && Path.isAfter(path, startPath) && Path.isBefore(path, endPath)) {
        result.push(node);

        if (Block.isBlock(node) || Inline.isInline(node)) {
          node.nodes.forEach(pushEdgeNode);
        }
      }
    } // Push the nodes in start path


    result.push(startBlock);
    startBlock.nodes.forEach(pushEdgeNode);

    if (startIndex === endIndex) {
      return result;
    } // Push the nodes between start and end


    this.nodes.slice(startIndex + 1, endIndex).forEach(node => {
      push(node);
    }); // Push the nodes in end path

    result.push(endBlock);
    endBlock.nodes.forEach(pushEdgeNode);
    return result;
  }
  /**
   * 获取最近的支持 edge 选择的 block 节点。
   * 如果 key 对应的节点满足条件，会直接返回此节点。
   */


  getClosestSelectableBlock(key, controller) {
    let ans = this.getAncestors(key);
    const n = this.getNode(key);

    if (n?.isElement()) {
      ans.push(n);
    }

    ans = ans.reverse();

    for (const node of ans) {
      if (controller.query('isEdgeSelectable', node)) {
        return node;
      } else if (node.isBlock() && controller.query('isVoid', node)) {
        return node;
      }
    }

    return null;
  }
  /**
   * 获取 rootKey 节点下距离 key 最远的支持 edge 选择的 block 节点。
   * 如果 key 对应的节点满足条件，也会返回此节点。
   */


  getFurthestSelectableBlock(key, rootKey, controller) {
    const ans = this.getAncestors(key);
    const n = this.getNode(key);

    if (n?.isElement()) {
      ans.push(n);
    }

    const rootIndex = ans.findIndex(node => node.key === rootKey);

    if (rootIndex === -1) {
      return null;
    }

    for (let i = rootIndex; i < ans.length; i++) {
      const node = ans[i];

      if (controller.query('isEdgeSelectable', node)) {
        return node;
      } else if (node.isBlock() && controller.query('isVoid', node)) {
        return node;
      }
    }

    return null;
  }
  /**
   * 获取最近的Void父节点
   */


  getClosestVoid(key, controller) {
    const path = this.getPath(key);

    if (!path) {
      return null;
    }

    return this.getClosestVoidByPath(path, controller);
  }
  /**
   * 获取最近的Void父节点
   */


  getClosestVoidByPath(path, controller) {
    return this.getClosestByPath(path, node => {
      return controller.query('isVoid', node);
    });
  }
  /**
   * 是否有一个Void父节点
   */


  hasVoidParent(key, controller) {
    const path = this.getPath(key);

    if (!path) {
      return false;
    }

    return this.hasVoidParentByPath(path, controller);
  }

  hasVoidParentByPath(path, controller) {
    const closest = this.getClosestVoidByPath(path, controller);
    return !!closest;
  }
  /**
   * 获取最顶层的一个Void节点
   */


  getFurthsestVoid(key, controller) {
    return this.getFurthsest(key, node => controller.query('isVoid', node));
  }
  /**
   * 根据选区，获取一个fragment
   */


  getFragmentAtRange(range, controller) {
    const {
      start,
      end
    } = range.convertToTextPoints(this);
    const startTextPath = this.getPath(start.key);
    const endTextPath = this.getPath(end.key);

    if (!startTextPath || !endTextPath) {
      return Document.create();
    }

    const startVoid = controller && this.getClosestVoidByPath(startTextPath, controller);
    const endVoid = controller && this.getClosestVoidByPath(endTextPath, controller);
    const startPath = startVoid ? this.assertPath(startVoid.key) : startTextPath;
    const endPath = endVoid ? this.assertPath(endVoid.key) : endTextPath;
    let node = this;
    let targetPath = endPath;
    let targetPosition = endVoid ? endVoid.nodes.length : end.offset;
    let mode = 'end';

    while (targetPath.length) {
      const index = targetPath[targetPath.length - 1];
      node = node.splitNode(targetPath, targetPosition);
      targetPath = Path.parent(targetPath);
      targetPosition = index + 1;

      if (!targetPath.length && mode === 'end') {
        targetPath = startPath;
        targetPosition = startVoid ? 0 : start.offset;
        mode = 'start';
      }
    }

    const startIndex = startPath[0] + 1;
    const endIndex = endPath[0] + 2;
    const nodes = node.nodes.slice(startIndex, endIndex); // @ts-ignore

    return Document.create({
      nodes
    });
  }
  /**
   * 获取特定区间的所有叶子block
   */


  getLeafBlocksAtRange(range) {
    const {
      start,
      end
    } = range.convertToTextPoints(this);
    const startBlock = this.getClosestBlockFromPoint(start.key); // PERF: the most common case is when the range is in a single block node,
    // where we can avoid a lot of iterating of the tree.

    if (start.key === end.key) {
      return [startBlock];
    }

    const endBlock = this.getClosestBlockFromPoint(end.key);
    const blocks = this.getBlocks();
    const startIndex = blocks.indexOf(startBlock);
    const endIndex = blocks.indexOf(endBlock);
    return blocks.slice(startIndex, endIndex + 1);
  }
  /**
   * 循环获取document下的所有叶子blocks节点
   */


  getBlocks() {
    return Block.getBlocks(this.nodes);
  }
  /**
   * 循环获取document下的所有叶子blocks节点
   */


  getBlocksByType(type) {
    return Block.getBlocksByType(this.nodes, type);
  }
  /**
   * 循环获取document下的特定区间内的全部blocks节点
   */


  getRootBlocksAtRange(range) {
    if (!range) {
      return [];
    }

    const {
      start,
      end
    } = range.convertToTextPoints(this);
    const startBlock = this.getFurthsestBlock(start.key);

    if (!startBlock) {
      return [];
    }

    if (start.key === end.key) {
      return [startBlock];
    }

    const endBlock = this.getFurthsestBlock(end.key);

    if (!endBlock) {
      return [];
    }

    return this.nodes.slice(this.nodes.indexOf(startBlock), this.nodes.indexOf(endBlock) + 1);
  }
  /**
   * 判断节点是否在Selection之内
   */


  isNodeInRange(key, range) {
    const path = this.getPath(key);

    if (!path) {
      return false;
    }

    return this.isNodeInRangeByPath(path, range);
  }
  /**
   * 判断节点是否在Selection之内
   */


  isNodeInRangeByPath(path, range) {
    if (!range || range.isCollapsedAtEdge) {
      return false;
    }

    const {
      start,
      end
    } = range.sort(this);
    const startPath = start.getPathIn(this);
    const endPath = end.getPathIn(this); // we cannot trust the selection

    if (!startPath || !endPath) {
      return false;
    } // edge cases


    if (start.isEdgePoint() && start.edge === EdgePoint.AFTER && (Path.isEqual(startPath, path) || Path.isAncestor(startPath, path))) {
      return false;
    }

    if (end.isEdgePoint() && end.edge === EdgePoint.BEFORE && (Path.isEqual(endPath, path) || Path.isAncestor(endPath, path))) {
      return false;
    }

    const isBeforeStart = Path.compare(path, startPath) === -1;
    const isAfterEnd = Path.compare(path, endPath) === 1;
    return !isBeforeStart && !isAfterEnd;
  }
  /**
   * 获取Selection内所有的Text节点
   */


  getTextsAtRange(range) {
    const {
      start,
      end
    } = range.convertToTextPoints(this);
    return this.getTextsBetweenPositions(start.key, end.key);
  }
  /**
   * 获取Selection内所有的叶子Inline节点
   */


  getLeafInlinesAtRange(range) {
    const array = this.getTextsAtRange(range).map(text => this.getClosestInline(text.key)).filter(exists => Boolean(exists));
    return array;
  }
  /**
   * 获取Selection内的所有最远Inline节点
   */


  getRootInlinesAtRange(range) {
    if (!range) {
      return [];
    }

    const array = this.getTextsAtRange(range).map(text => this.getFurthsestInline(text.key))
    /* eslint-disable @typescript-eslint/indent */
    .reduce((inlines, inline) => {
      if (inline && !inlines.includes(inline)) {
        inlines.push(inline);
      }

      return inlines;
    }, []);
    /* eslint-enable @typescript-eslint/indent */

    return array;
  }

  toJSON(options) {
    const object = {
      klass: 'document',
      data: { ...this.data
      },
      nodes: this.nodes.map(node => node.toJSON(options))
    };

    if (options?.preserveKeys) {
      object.key = this.key;
    }

    return object;
  }

}

/**
 * @packageDocumentation
 * @module Models
 */

function defaultMergeData(a, b) {
  return { ...a,
    ...b
  };
}

class Injection extends ImmutableRecord {
  static create(props) {
    if (Injection.isInjection(props)) {
      return props;
    }

    if (isPlainObject__default["default"](props)) {
      const {
        key,
        data,
        mergeData
      } = props;
      return new Injection({
        key,
        data,
        mergeData
      });
    }

    throw new Error(`\`Injection.create\` only accepts objects or injections, but you passed it: ${props}`);
  }

  static isInjection(maybeInjection) {
    return maybeInjection instanceof Injection;
  }

  static injectIntoNode(injections, node) {
    if (!injections.length || !Element$1.isElement(node)) {
      return node;
    }

    return injections.reduce((n, injection) => {
      if (injection.key !== n.key) {
        return n;
      }

      const {
        mergeData
      } = injection;
      return n.set('data', mergeData(n.data, injection.data));
    }, node);
  }

  static fromJSON(json) {
    const {
      key,
      data
    } = json;
    return Injection.create({
      key,
      data
    });
  }

  constructor(props) {
    super();
    this.key = void 0;
    this.data = void 0;
    this.mergeData = void 0;
    const {
      key,
      data,
      mergeData = defaultMergeData
    } = props;
    this.key = key;
    this.data = data;
    this.mergeData = mergeData;
    this.freeze();
  }

  merge(props) {
    return new Injection({
      key: this.key,
      data: this.data,
      mergeData: this.mergeData,
      ...props
    });
  }

  set(key, value) {
    return this.merge({
      [key]: value
    });
  }

  toJSON() {
    return {
      key: this.key,
      data: this.data
    };
  }

}

/**
 * @packageDocumentation
 * @ignore
 */
const movePointForward = lodash.curry((controller, pn, distance, unit) => {
  return selection => {
    if (distance === 0) {
      return selection;
    }

    const {
      document
    } = controller.value;
    let pointName = pn;

    if (pointName === 'start') {
      pointName = selection.isForward(document) ? 'anchor' : 'focus';
    } else if (pointName === 'end') {
      pointName = selection.isForward(document) ? 'focus' : 'anchor';
    }

    const at = pointName === 'anchor' ? selection.anchor : selection.focus;
    const point = controller.query(pointAtDistance, at, distance, unit);
    return selection.set(pointName, point);
  };
});
const movePointBackward = lodash.curry((controller, pn, distance, unit) => {
  return selection => {
    const mover = movePointForward(controller, pn, -distance, unit);
    return mover(selection);
  };
});
const movePointWordBackward = movePointBackward(lodash.curry.placeholder, lodash.curry.placeholder, 1, 'word');
const movePointWordForward = movePointForward(lodash.curry.placeholder, lodash.curry.placeholder, 1, 'word');
/**
 * 判断 `selection` 是否完全在 `node` 内部
 * @param node
 * @param document
 * @param selection
 * @returns
 */

const isSelectionInNode = (node, document, selection) => {
  const {
    start,
    end
  } = selection.sort(document);

  if (Element$1.isElement(node)) {
    if (start.isEdgePoint() && start.key === node.key || end.isEdgePoint() && end.key === node.key) {
      return false;
    } else {
      const {
        start: startText,
        end: endText
      } = selection.convertToTextPoints(document);
      return node.hasNode(startText.key) && node.hasNode(endText.key);
    }
  } else {
    // Node is Text
    return start.isTextPoint() && end.isTextPoint() && start.key === node.key && end.key === node.key;
  }
};

function getFirstDataElementPath(document, view, viewElement) {
  let start = viewElement.nodes[0];

  while (!document.hasNode(start.key)) {
    start = view.assertElement(start.key).nodes[0];
  }

  return document.assertPath(start.key);
}

function getLastDataElementPath(document, view, viewElement) {
  let end = viewElement.nodes[viewElement.nodes.length - 1];

  while (!document.hasNode(end.key)) {
    const endElement = view.assertElement(end.key);
    end = endElement.nodes[endElement.nodes.length - 1];
  }

  return document.assertPath(end.key);
}
/**
 * 获得裁剪后的选区
 * @param controller
 * @param selection
 * @param visibles
 */


function getCroppedSelection(controller, selection, visibles) {
  if (!controller.enableVirtualize) {
    return selection;
  }

  const {
    document
  } = controller.value;
  const view = controller.view;
  const validVisibles = visibles.filter(visible => document.hasNode(visible) || view.hasNode(visible));

  if (!validVisibles.length) {
    return null;
  } else {
    const {
      start,
      end
    } = selection.convertToTextPoints(document);
    const selectionStartPath = document.getPath(start.key);
    const selectionEndPath = document.getPath(end.key);

    if (!selectionStartPath || !selectionEndPath) {
      return null;
    }

    const visibleStartKey = validVisibles[0];
    const visibleEndKey = validVisibles[validVisibles.length - 1];
    let visibleStart;
    let visibleEnd;

    if (document.hasNode(visibleStartKey)) {
      visibleStart = document.assertPath(visibleStartKey)[0];
    } else {
      const viewElement = view.assertElement(visibleStartKey);
      visibleStart = getFirstDataElementPath(document, view, viewElement)[0];
    }

    if (document.hasNode(visibleEndKey)) {
      visibleEnd = document.assertPath(visibleEndKey)[0];
    } else {
      const viewElement = view.assertElement(visibleEndKey);
      visibleEnd = getLastDataElementPath(document, view, viewElement)[0];
    }

    const selectionStart = selectionStartPath[0];
    const selectionEnd = selectionEndPath[0];

    if (selectionStart > visibleEnd || selectionEnd < visibleStart) {
      return null;
    }

    let sel = selection;

    if (selectionStart < visibleStart) {
      sel = sel.moveStartToStartOfNode(document.assertNodeByPath([visibleStart]), controller);
    }

    if (selectionEnd > visibleEnd) {
      sel = sel.moveEndToEndOfNode(document.assertNodeByPath([visibleEnd]), controller);
    }

    return sel;
  }
}

/* eslint-disable no-restricted-syntax */

function getSiblingTextPoint(controller, key, isPrev) {
  const {
    document
  } = controller.value;
  const textNode = isPrev ? document.getPreviousText(key) : document.getNextText(key);

  if (textNode) {
    const {
      key
    } = textNode;
    const offset = isPrev ? textNode.text.length : 0;
    return TextPoint.create({
      key,
      offset
    });
  }

  return undefined;
}
/**
 *
 * move point out of inline IF it's located at inline edges
 *
 * ### Normal Inline
 * Before: `<link><anchor/>www.dingtalk.com<focus/></link>`
 *
 * After: `<anchor/><link>www.dingtalk.com</link><focus/>`
 *
 * ### Side selectable Inline
 * Before: `<anchor/><ins>www.dingtalk.com</ins><focus/>`
 *
 * After: `<ins><anchor/>www.dingtalk.com<focus/></ins>`
 */


const correctPointAtInlineEdge = (controller, point) => {
  if (point.isEdgePoint()) {
    return point;
  }

  if (controller.query('disableCorrectPointAtInnerEdge', point)) {
    return point;
  }

  const {
    document
  } = controller.value;
  const {
    key,
    offset
  } = point;
  const text = document.getNode(key);
  const parent = document.getParent(key); // 若当前选中点为 text 起始，则试探前一个节点是否为可选 inline

  if (offset === 0) {
    const node = document.getPreviousSibling(key);

    if (node && Inline.isInline(node) && controller.query('isSideSelectable', node)) {
      return getSiblingTextPoint(controller, key, true) || point;
    }
  } // 若当前选中点为 text 末尾，则试探后一个节点是否为可选 inline


  if (text && offset === text.text.length) {
    const node = document.getNextSibling(key);

    if (node && Inline.isInline(node) && controller.query('isSideSelectable', node)) {
      return getSiblingTextPoint(controller, key, false) || point;
    }
  }

  if (!parent || !parent.isInline() || controller.query('isVoid', parent) || controller.query('isSideSelectable', parent)) {
    return point;
  }

  if (offset !== 0 && offset !== parent.text.length) {
    return point;
  }

  return getSiblingTextPoint(controller, key, offset === 0) || point;
};
/**
 *
 * move point out of void
 *
 * Before: <img>[anchor]</img>cangjie[focus]
 * After: [anchor]<img></img>cangjie[focus]
 */


const correctPointInVoid = (controller, point, isStart) => {
  if (point.isEdgePoint()) {
    return point;
  }

  const {
    document
  } = controller.value;
  const {
    key
  } = point;
  const parent = document.getClosestInline(key);

  if (!parent || !controller.query('isVoid', parent)) {
    return point;
  }

  return getSiblingTextPoint(controller, key, isStart) || point;
};

function focus(controller) {
  if (!controller.value.isFocused) {
    return controller.setIsFocused(true);
  }

  return controller;
}
function blur(controller) {
  if (controller.value.isFocused) {
    return controller.setIsFocused(false);
  }

  return controller;
}
function select(controller, selection) {
  const {
    selection: prevSelection
  } = controller.value;

  if (equal__default["default"](selection, prevSelection)) {
    return controller;
  }

  return controller.applyOperation({
    type: exports.OperationType.SetSelection,
    selection: Selection.create(selection),
    prevSelection
  });
}
/**
 *
 * differences between `select` and `userSelect`:
 *
 * `select` will set exactly what you passed;
 * `userSelect` may adjust the selection to make the user feel expected.
 */

function userSelect(controller, selection) {
  const {
    selection: prevSelection,
    document
  } = controller.value;

  if (equal__default["default"](selection, prevSelection)) {
    return controller;
  }

  const {
    anchor: paramAnchor,
    focus: paramFocus
  } = selection;
  let anchor = correctPointAtInlineEdge(controller, paramAnchor);
  let focus = correctPointAtInlineEdge(controller, paramFocus);

  if (selection.isExpanded) {
    const isForward = selection.isForward(document);
    anchor = correctPointInVoid(controller, anchor, isForward);
    focus = correctPointInVoid(controller, focus, !isForward);
  }

  const correctedSelection = selection.set('anchor', anchor).set('focus', focus);
  return controller.applyOperation({
    type: exports.OperationType.SetSelection,
    selection: correctedSelection,
    prevSelection
  });
}
function selectWordAtPoint(controller, point) {
  const {
    document
  } = controller.value;
  const selection = Selection.selectWordAtPoint(document, point);
  return selection ? controller.command(select, selection) : controller;
}
function moveAnchorBackward(controller, n = 1, unit) {
  const {
    selection
  } = controller.value;
  const mover = movePointBackward(controller, 'anchor', n, unit || 'offset');
  return controller.command(userSelect, mover(selection));
}
function moveAnchorForward(controller, n = 1, unit) {
  const {
    selection
  } = controller.value;
  const mover = movePointForward(controller, 'anchor', n, unit || 'offset');
  const newSelection = mover(selection);
  return controller.command(userSelect, newSelection);
}
function moveAnchorTo(controller, path, offset) {
  const {
    selection,
    document
  } = controller.value;
  const {
    key
  } = document.assertNodeByPath(path);
  const newSelection = selection.moveAnchorTo(key, offset);
  return controller.command(select, newSelection);
}
function moveAnchorToKey(controller, key, offset) {
  const path = controller.value.document.assertPath(key);
  return controller.command(moveAnchorTo, path, offset);
}
function moveAnchorToStartOfBlock(controller) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.movePointEdgeKlass(controller, 'anchor', 'start', 'block'));
}
function moveAnchorToStartOfPreviousBlock(controller) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.movePointEdgeSideKlass(controller, 'anchor', 'start', 'previous', 'block'));
}
function moveAnchorToEndOfNextBlock(controller) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.movePointEdgeSideKlass(controller, 'anchor', 'end', 'next', 'block'));
}
function moveFocusTo(controller, path, offset) {
  const {
    selection,
    document
  } = controller.value;
  const {
    key
  } = document.assertNodeByPath(path);
  const newSelection = selection.moveFocusTo(key, offset);
  return controller.command(select, newSelection);
}
function moveFocusToKey(controller, key, offset) {
  const path = controller.value.document.assertPath(key);
  return controller.command(moveFocusTo, path, offset);
}
function moveTo(controller, path, offset) {
  return controller.command(moveAnchorTo, path, offset).command(moveFocusTo, path, offset);
}
function moveToKey(controller, key, offset) {
  const path = controller.value.document.assertPath(key);
  return controller.command(moveTo, path, offset);
}
function moveFocusBackward(controller, n = 1) {
  const {
    selection
  } = controller.value;
  const mover = movePointBackward(controller, 'focus', n, 'offset');
  return controller.command(select, mover(selection));
}
function moveFocusForward(controller, n = 1) {
  const {
    selection
  } = controller.value;
  const mover = movePointForward(controller, 'focus', n, 'offset');
  return controller.command(select, mover(selection));
}
function moveFocusWordBackward(controller) {
  const {
    selection
  } = controller.value;
  const mover = movePointBackward(controller, 'focus', 1, 'word');
  return controller.command(select, mover(selection));
}
function moveFocusWordForward(controller) {
  const {
    selection
  } = controller.value;
  const mover = movePointForward(controller, 'focus', 1, 'word');
  return controller.command(select, mover(selection));
}
function moveFocusToEndOfText(controller) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.movePointEdgeKlass(controller, 'focus', 'end', 'text'));
}
function moveFocusToStartOfBlock(controller) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.movePointEdgeKlass(controller, 'focus', 'start', 'block'));
}
function moveFocusToEndOfBlock(controller) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.movePointEdgeKlass(controller, 'focus', 'end', 'block'));
}
function moveFocusToStartOfDocument(controller) {
  const {
    document
  } = controller.value;
  return controller.command(moveFocusToStartOfNode, document);
}
function moveFocusToEndOfDocument(controller) {
  const {
    document
  } = controller.value;
  return controller.command(moveFocusToEndOfNode, document);
}
function moveStartBackward(controller, n = 1) {
  const {
    selection
  } = controller.value;
  const mover = movePointBackward(controller, 'start', n, 'offset');
  return controller.command(select, mover(selection));
}
function moveStartForward(controller, n = 1) {
  const {
    selection
  } = controller.value;
  const mover = movePointForward(controller, 'start', n, 'offset');
  return controller.command(select, mover(selection));
}
function moveEndBackward(controller, n = 1) {
  const {
    selection
  } = controller.value;
  const mover = movePointBackward(controller, 'end', n, 'offset');
  return controller.command(select, mover(selection));
}
function moveEndForward(controller, n = 1) {
  const {
    selection
  } = controller.value;
  const mover = movePointForward(controller, 'end', n, 'offset');
  return controller.command(select, mover(selection));
}
function moveBackward(controller, n = 1) {
  return controller.command(moveAnchorBackward, n).command(moveFocusBackward, n);
}
function moveForward(controller, n = 1) {
  return controller.command(moveAnchorForward, n).command(moveFocusForward, n);
}
function moveToEndOfPreviousBlock(controller) {
  return controller.command(moveStartToEndOfPreviousBlock).command(moveToStart);
}
function moveToEndOfNextBlock(controller) {
  return controller.command(moveEndToEndOfNextBlock).command(moveToEnd);
}
function moveToEndOfInline(controller) {
  return controller.command(moveEndToEndOfInline).command(moveToEnd);
}
function moveToAnchor(controller) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.moveToAnchor());
}
function moveToFocus(controller) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.moveToFocus());
}
function moveToRangeOfDocument(controller) {
  return controller.command(moveToRangeOfNode, controller.value.document);
}
function moveToRangeOfNode(controller, node) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.moveToRangeOfNode(node, controller));
}
function moveToStart(controller) {
  const {
    document,
    selection
  } = controller.value;
  return controller.command(select, selection.moveToStart(document));
}
function moveToEnd(controller) {
  const {
    document,
    selection
  } = controller.value;
  return controller.command(select, selection.moveToEnd(document));
}
function moveToEndOfDocument(controller) {
  return controller.command(moveEndToEndOfNode, controller.value.document).command(moveToEnd);
}
function moveToStartOfInline(controller) {
  return controller.command(moveStartToStartOfInline).command(moveToStart);
}
function moveToStartOfBlock(controller) {
  return controller.command(moveStartToStartOfBlock).command(moveToStart);
}
function moveToEndOfBlock(controller) {
  return controller.command(moveEndToEndOfBlock).command(moveToEnd);
}
function moveToEndOfNode(controller, node) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.moveToEndOfNode(node, controller));
}
function moveStartToStartOfInline(controller) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.movePointEdgeKlass(controller, 'start', 'start', 'inline'));
}
function moveStartToStartOfBlock(controller) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.movePointEdgeKlass(controller, 'start', 'start', 'block'));
}
function moveStartToStartOfPreviousBlock(controller) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.movePointEdgeSideKlass(controller, 'start', 'start', 'previous', 'block'));
}
function moveEndToEndOfBlock(controller) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.movePointEdgeKlass(controller, 'end', 'end', 'block'));
}
function moveToStartOfDocument(controller) {
  const {
    document,
    selection
  } = controller.value;
  return controller.command(select, selection.moveFocusToStartOfNode(document, controller).moveToFocus());
}
function moveStartToEndOfNode(controller, node) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.moveStartToEndOfNode(node, controller));
}
function moveAnchorToStartOfNode(controller, node) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.moveAnchorToStartOfNode(node, controller));
}
function moveAnchorToEndOfNode(controller, node) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.moveAnchorToEndOfNode(node, controller));
}
function moveFocusToStartOfNode(controller, node) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.moveFocusToStartOfNode(node, controller));
}
function moveFocusToEndOfNode(controller, node) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.moveFocusToEndOfNode(node, controller));
}
function moveToEndOfPreviousText(controller) {
  return controller.command(moveStartToEndOfPreviousText).command(moveToStart);
}
function moveToStartOfNextText(controller) {
  return controller.command(moveEndToStartOfNextText).command(moveToEnd);
}
function moveToStartOfPreviousBlock(controller) {
  return controller.command(moveStartToStartOfPreviousBlock).command(moveToStart);
}
function moveToStartOfNextBlock(controller) {
  return controller.command(moveEndToStartOfNextBlock).command(moveToEnd);
}
function moveToStartOfNode(controller, node) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.moveToStartOfNode(node, controller));
}
function moveStartToStartOfNode(controller, node) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.moveStartToStartOfNode(node, controller));
}
function moveEndToStartOfNode(controller, node) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.moveEndToStartOfNode(node, controller));
}
function moveEndToEndOfNode(controller, node) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.moveEndToEndOfNode(node, controller));
}
function moveStartToEndOfPreviousText(controller) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.movePointEdgeSideKlass(controller, 'start', 'end', 'previous', 'text'));
}
function moveStartToEndOfPreviousBlock(controller) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.movePointEdgeSideKlass(controller, 'start', 'end', 'previous', 'block'));
}
function moveEndToEndOfInline(controller) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.movePointEdgeKlass(controller, 'end', 'end', 'inline'));
}
function moveEndToStartOfNextText(controller) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.movePointEdgeSideKlass(controller, 'end', 'start', 'next', 'text'));
}
function moveEndToStartOfNextBlock(controller) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.movePointEdgeSideKlass(controller, 'end', 'start', 'next', 'block'));
}
function moveEndToEndOfNextBlock(controller) {
  const {
    selection
  } = controller.value;
  return controller.command(select, selection.movePointEdgeSideKlass(controller, 'end', 'end', 'next', 'block'));
}
function moveWordBackward(controller) {
  const {
    selection
  } = controller.value;
  const mover = movePointWordBackward(controller, 'focus');
  return controller.command(select, mover(selection)).command(moveToFocus);
}
function moveWordForward(controller) {
  const {
    selection
  } = controller.value;
  const mover = movePointWordForward(controller, 'focus');
  return controller.command(select, mover(selection)).command(moveToFocus);
}

/**
 * @packageDocumentation
 * @module Commands
 */
/**
 * 删除指定位置的节点。
 * 1. 如果传入无效的节点，会抛异常。
 */

function removeNodeByKey(controller, key) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const path = document.assertPath(key);
  return controller.command(removeNodeByPath, path);
}
/**
 * 删除指定位置的节点。
 * 1. 如果传入无效的节点，会抛异常。
 */

function removeNodeByPath(controller, path) {
  const {
    document: oldDoc
  } = controller.value;
  const node = oldDoc.assertNodeByPath(path);
  const {
    selection,
    document
  } = controller.value;
  const prev = document.getPreviousNodeByPath(path);
  const next = document.getNextNodeByPath(path);

  const mapPoint = point => {
    if (node.key === point.key || node.isElement() && node.hasNode(point.key)) {
      if (prev) {
        return controller.query(pointAtEndOfNode, prev);
      }

      if (next) {
        return controller.query(pointAtStartOfNode, next);
      }
    }

    return point;
  };

  let newSelection = selection;

  if (prev || next) {
    // 为什么在这里调整选区？
    // 需要根据 controller 来获取 pointAtStartOfNode / pointAtEndOfNode。如果放到 Value 的
    // applyOperation 中调整，value 没有感知到 controller 的存在，就无法获取 edge point。
    const anchor = mapPoint(selection.anchor);
    const focus = mapPoint(selection.focus);
    newSelection = Selection.create({
      anchor,
      focus
    });
  } // 调用select是方便后续撤销时恢复选区，表格选区不恢复可能会跑到隐藏单元格触发bug


  controller.command(select, newSelection);
  controller.applyOperation({
    type: exports.OperationType.RemoveNode,
    path,
    node: node
  });

  if (newSelection !== selection) {
    return controller.command(select, newSelection);
  }

  return controller;
}
/**
 * 删除指定位置的文字。
 * 1. 如果传入无效的节点，会抛异常。
 */

function removeTextByKey(controller, key, offset, text) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const path = document.assertPath(key);
  return controller.command(removeTextByPath, path, offset, text);
}
/**
 * 删除指定位置的文字。
 * 1. 如果传入无效的节点，会抛异常。
 * @text 删除的文字；如果长度大于可用长度，按照可用长度计算
 */

function removeTextByPath(controller, path, offset, text) {
  const {
    value
  } = controller;
  const {
    decorations,
    document
  } = value;
  const node = document.assertTextByPath(path);
  let updated = false;
  const {
    key,
    leaves
  } = node;
  const from = offset;
  const to = offset + text.length; // filter atomic decorations

  const decs = decorations.filter(dec => {
    const {
      start,
      end,
      mark
    } = dec;
    const isAtomic = controller.query('isAtomic', mark);
    if (!isAtomic) return true;
    if (start.key !== key) return true;

    if (start.offset < from && (end.key !== key || end.offset > from)) {
      updated = true;
      return false;
    }

    if (start.offset < to && (end.key !== key || end.offset > to)) {
      updated = true;
      return null;
    }

    return true;
  });

  if (updated) {
    controller.setDecorations(decs);
  }

  const removals = [];
  let cursor = 0;
  leaves.forEach(leaf => {
    const startCursor = cursor;
    const endCursor = cursor + leaf.text.length;
    cursor += leaf.text.length; // Skip the leaf which is not overlapped

    if (endCursor < from || to < startCursor) return; // Remove the leaf text

    const start = Math.max(startCursor, from);
    const end = Math.min(endCursor, to);
    const string = node.text.slice(start, end);
    removals.push({
      type: exports.OperationType.RemoveText,
      path,
      offset: start,
      text: string,
      marks: leaf.marks
    });
  });
  controller.command(select, value.selection);
  removals.reverse().forEach(op => controller.applyOperation(op));
  return controller;
}

/**
 * @packageDocumentation
 * @module Commands
 */
/**
 * 删除指定位置的Node，并添加到parentPath的第index处
 * 1. 如果传入无效的节点，会抛异常。
 */

function moveNodeByKey(controller, key, parentKey, index) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const path = document.assertPath(key);
  const parentPath = document.assertPath(parentKey);
  return controller.command(moveNodeByPath, path, parentPath, index);
}
/**
 * 删除指定位置的Node，并添加到parentPath的第index处
 * 1. 如果传入无效的节点，会抛异常。
 */

function moveNodeByPath(controller, path, parentPath, index) {
  if (Path.isEqual(path, parentPath)) {
    return controller;
  }

  const newPath = parentPath.concat(index);

  if (Path.isEqual(path, newPath)) {
    return controller;
  }

  return controller.applyOperation({
    type: exports.OperationType.MoveNode,
    path,
    newPath
  });
}

/* eslint-disable no-param-reassign */
function deleteExpanded(controller) {
  const {
    value
  } = controller;
  const {
    selection
  } = value;

  if (selection.isExpanded) {
    controller.command(del);
  }
}
/**
 * 删除选区的内容；返回一个拷贝选区，并定位到原选区的start位置
 */

function deleteExpandedAtRange(controller, range) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const {
    start,
    end
  } = range.sort(document);

  if (range.isExpanded) {
    controller.command('deleteAtRange', range);
  }

  const {
    document: newDocument
  } = controller.value;

  if (newDocument.getNode(start.key)) {
    range = range.merge({
      anchor: start,
      focus: start
    });
  } else {
    const point = end.isTextPoint() ? end.set('offset', 0) : end;
    range = range.merge({
      anchor: point,
      focus: point
    });
  }

  return range;
}

const PREFIX = 'cj/cmd/split_';
const splitTpl = (node, path, position) => `${PREFIX}${node.isText() ? 'text' : 'node'}(${JSON.stringify([path, position])}`;

/* eslint-disable no-param-reassign */
/**
 * 从指定文本位置开始拆分节点子树
 * @param controller
 * @param key 节点子树的 root key
 * @param textKey 待拆分的文本 key
 * @param textOffset 待拆分的文本 offset
 * @returns
 * @example
 * ```ts
 * // 
 * //   ┌───────┐                      ┌───────┐   
 * //   │ root  │                      │ root  │   
 * //   └───────┘                      └───────┘   
 * //       │                         ┌─────────┐  
 * //       ▼                         ▼         ▼  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ A │                     │ A │     │A1 │
 * //     └───┘                     └───┘     └───┘
 * //       │         ──split─▶       │         │  
 * //       ▼                         ▼         ▼  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ B │                     │ B │     │B1 │
 * //     └───┘                     └───┘     └───┘
 * //       │                         │         │  
 * //      │▼                         ▼         ▼  
 * //   ┌──┼────┐                   ┌───┐     ┌───┐
 * //   │'a│bc' │                   │'a'│     │'bc│
 * //   └──┼────┘                   └───┘     └───┘
 * //      │                                       
 * //   offset=1                                    
 * //
 * 
 * const newDocument = controller.commands('splitDescendantsByKey', document.key, text.key, 1);
*                                                       
 * ```
 */

function splitDescendantsByKey(controller, key, textKey, textOffset) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const path = document.assertPath(key);
  const textPath = document.assertPath(textKey);
  return controller.command('splitDescendantsByPath', path, textPath, textOffset);
}
/**
 * 从指定文本位置开始拆分节点子树
 * @param controller
 * @param path 节点子树的 path
 * @param textPath 待拆分的文本 path
 * @param textOffset 待拆分的文本 offset
 * @returns
 * @example
 * ```ts
 * // 
 * //   ┌───────┐                      ┌───────┐   
 * //   │ root  │                      │ root  │   
 * //   └───────┘                      └───────┘   
 * //       │                         ┌─────────┐  
 * //       ▼                         ▼         ▼  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ A │                     │ A │     │A1 │
 * //     └───┘                     └───┘     └───┘
 * //       │         ──split─▶       │         │  
 * //       ▼                         ▼         ▼  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ B │                     │ B │     │B1 │
 * //     └───┘                     └───┘     └───┘
 * //       │                         │         │  
 * //      │▼                         ▼         ▼  
 * //   ┌──┼────┐                   ┌───┐     ┌───┐
 * //   │'a│bc' │                   │'a'│     │'bc│
 * //   └──┼────┘                   └───┘     └───┘
 * //      │                                       
 * //   offset=1                                    
 * //
 * 
 * const newDocument = controller.commands('splitDescendantsByPath', [], [0,0,0], 1);
 *                                                     
 * ```
 */

function splitDescendantsByPath(controller, path, textPath, textOffset) {
  if (equal__default["default"](path, textPath)) {
    controller.command(splitNodeByPath, textPath, textOffset);
    return controller;
  }

  const {
    value
  } = controller;
  const {
    document
  } = value; // 从待拆分文本 `text` 开始，自底向上逐个拆分节点，直到到达拆分节点 `node`

  const node = document.assertNodeByPath(path);
  const text = document.assertNodeByPath(textPath);
  const ancestors = document.getAncestorsByPath(textPath);
  let elements = ancestors.slice();
  elements = lodash.dropWhile(elements, a => a.key !== node.key).reverse();
  return controller.withoutNormalizing(() => {
    controller.command(splitNodeByKey, text.key, textOffset);
    let previous = text;
    elements.forEach(element => {
      controller.command(splitNodeByKey, element.key, element.nodes.indexOf(previous) + 1);
      previous = element;
    });
  });
}
/**
 * 对目标节点进行拆分
 *
 * ```txt
 * Split Text:
 *
 *       position=5                    Text      Text
 *          │                        ┌───────┐ ┌───────┐
 *     Hello│World     ─split─────▶  │ Hello │ │ World │
 *          │                        └───────┘ └───────┘
 *
 * Split Element:
 *
 *          position=1
 *             │
 * ┌───────────┼───────────┐                ┌─────────────┐   ┌─────────────┐
 * │ Element   │           │                │ Element     │   │ Element     │
 * │  ┌───────┐│┌───────┐  │                │  ┌───────┐  │   │  ┌───────┐  │
 * │  │ Hello │││ World │  │────split─────▶ │  │ Hello │  │   │  │ World │  │
 * │  └───────┘│└───────┘  │                │  └───────┘  │   │  └───────┘  │
 * └───────────┼───────────┘                └─────────────┘   └─────────────┘
 *             │
 *             │
 *
 * ```
 * @key 待拆分节点 key
 * @position 拆分位置。如果是 Text 节点，代表文字的偏移量；如果 Element节点，代表子节点 index。
 */

function splitNodeByKey(controller, key, position) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const path = document.assertPath(key);
  return controller.command(splitNodeByPath, path, position);
}
/**
 * 对目标节点进行拆分
 * ```txt
 * Split Text:
 *
 *       position=5                    Text      Text
 *          │                        ┌───────┐ ┌───────┐
 *     Hello│World     ─split─────▶  │ Hello │ │ World │
 *          │                        └───────┘ └───────┘
 *
 * Split Element:
 *
 *          position=1
 *             │
 * ┌───────────┼───────────┐                ┌─────────────┐   ┌─────────────┐
 * │ Element   │           │                │ Element     │   │ Element     │
 * │  ┌───────┐│┌───────┐  │                │  ┌───────┐  │   │  ┌───────┐  │
 * │  │ Hello │││ World │  │────split─────▶ │  │ Hello │  │   │  │ World │  │
 * │  └───────┘│└───────┘  │                │  └───────┘  │   │  └───────┘  │
 * └───────────┼───────────┘                └─────────────┘   └─────────────┘
 *             │
 *             │
 *                                                      
 * ```
 * @path 待拆分节点 path
 * @position 拆分位置。如果是 Text 节点，代表文字的偏移量；如果 Element节点，代表子节点 index。
 */

function splitNodeByPath(controller, path, position) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const node = document.assertNodeByPath(path);
  const parentPath = path.slice(0, -1);
  const parent = document.getNodeByPath(parentPath);
  const index = parent.nodes.indexOf(node);

  if (Element$1.isElement(node)) {
    node.type;
    node.data;
  }

  controller.withOpContext(splitTpl(node, path, position), () => {
    controller.withoutTracking(() => {
      controller.withoutNormalizing(() => {
        if (node.isText()) {
          /**
           * Split Text为：
           *
           * 1. 删除分裂位置后的文本
           * 2. 在分裂节点之后，插入新的文本节点（其内容为分裂位置后的文本）
           * ```txt
           *
           *        position=4
           *            │
           * ┌──────────┼────────┐                ┌──────┐                     ┌──────┐┌──────┐
           * │      ABCD│EF      │─remove 'EF'──▶ │ ABCD │─insert Text('EF')─▶ │ ABCD ││  EF  │
           * └──────────┼────────┘                └──────┘                     └──────┘└──────┘
           *            │
           * ```
           */
          const [, after] = node.splitText(position);
          const {
            selection,
            decorations
          } = controller.value;
          controller.command(removeTextByPath, path, position, after.text).command(insertNodeByPath, parentPath, index + 1, after);
          /**
           * 上面从 split op 换成 remove + insert 之后，updatePoints 无法处理，导致 selection
           * 和 decorations 都会失效。
           *
           * 这里取之前的 selection 和 decorations，主动调用 updatePoints 来矫正位置，模拟之前的
           * split op 处理方式。
           */

          const valueToUpdate = controller.value.set('decorations', decorations).set('selection', selection);
          const updatedValue = valueToUpdate.updatePoints(valueToUpdate.document, point => {
            if (point.key === node.key && position <= point.offset) {
              return point.merge({
                key: after.key,
                offset: point.offset - position
              });
            }

            return point;
          });
          controller.setValue(updatedValue, {
            clearOperations: false
          });
        } else {
          /**
           * Split Element：
           *
           * 1. 在分裂位置后，插入空节点
           * 2. 将分裂位置后的节点移入这个空间点
           * 2. 在分裂节点之后，插入新的文本节点（其内容为分裂位置后的文本）
           * ```txt
           *     position=1
           *         │
           * ┌───────┼────────────────┐                      ┌────────────────────────┐ ┌─────────┐                ┌─────────┐ ┌────────────────┐
           * │ Elemen│                │                      │ Element                │ │ Element │                │ Element │ │ Element        │
           * │  ┌───┐│┌───┐┌───┐┌───┐ │                      │  ┌───┐ ┌───┐┌───┐┌───┐ │ │         │                │  ┌───┐  │ │┌───┐┌───┐┌───┐ │
           * │  │ A │││ B ││ C ││ D │ │───insert container──▶│  │ A │ │ B ││ C ││ D │ │ │         │──move afters──▶│  │ A │  │ ││ B ││ C ││ D │ │
           * │  └───┘│└───┘└───┘└───┘ │                      │  └───┘ └───┘└───┘└───┘ │ │         │                │  └───┘  │ │└───┘└───┘└───┘ │
           * └───────┼────────────────┘                      └────────────────────────┘ └─────────┘                └─────────┘ └────────────────┘
           *         │
           *
           * ```
           */
          const element = node;
          const insertNode = element.set('nodes', []).regenerateKey();
          const afters = element.nodes.slice(position);
          const at = index + 1;
          controller.command(insertNodeByPath, parentPath, at, insertNode);
          const insertNodePath = parentPath.concat(at);
          const moveNodePath = path.concat(position);
          afters.forEach((_, idx) => {
            controller.command(moveNodeByPath, moveNodePath, insertNodePath, idx);
          });
        }
      });
    });
  });
  return controller;
}
/**
 * 在当前选区拆分 Block
 * 
 * @param controller
 * @param depth 对于嵌套结构，可以指定拆分深度，默认拆分深度为 1 ，即只拆分距选区最近的 Block
 * @returns
 * @example
 * 
 * ```ts
 * // 
 * //   ┌───────┐                      ┌───────┐   
 * //   │ root  │                      │ root  │   
 * //   └───────┘                      └───────┘   
 * //       │                              │       
 * //       ▼                              ▼       
 * //     ┌───┐                          ┌───┐     
 * //     │ A │                          │ A │     
 * //     └───┘                          └───┘     
 * //       │       ──depth=3─▶            │       
 * //       ▼                         ┌─────────┐  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ B │                     │ B │     │B1 │
 * //     └───┘                     └───┘     └───┘
 * //       │                         │         │  
 * //      │▼                         ▼         ▼  
 * //   ┌──┼────┐                   ┌───┐     ┌───┐
 * //   │'a│bc' │                   │'a'│     │'bc│
 * //   └──┼────┘                   └───┘     └───┘
 * //      │                                       
 * //   cursor                                    
 * //
 * 
 * const newDocument = controller.commands('splitBlock');
 * 
 *  * // 
 * //   ┌───────┐                      ┌───────┐   
 * //   │ root  │                      │ root  │   
 * //   └───────┘                      └───────┘   
 * //       │                         ┌─────────┐  
 * //       ▼                         ▼         ▼  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ A │                     │ A │     │A1 │
 * //     └───┘                     └───┘     └───┘
 * //       │       ──depth=3─▶       │         │  
 * //       ▼                         ▼         ▼  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ B │                     │ B │     │B1 │
 * //     └───┘                     └───┘     └───┘
 * //       │                         │         │  
 * //      │▼                         ▼         ▼  
 * //   ┌──┼────┐                   ┌───┐     ┌───┐
 * //   │'a│bc' │                   │'a'│     │'bc│
 * //   └──┼────┘                   └───┘     └───┘
 * //      │                                       
 * //   cursor                                    
 * //
 * 
 * const newDocument = controller.commands('splitBlock', 3);
 *                                                      
 * ```
 */

function splitBlock(controller, depth = 1) {
  deleteExpanded(controller);
  const {
    value
  } = controller;
  const {
    selection,
    document
  } = value;
  const marks = selection.marks || document.getInsertMarksAtRange(selection);
  controller.command('splitBlockAtRange', selection, depth);
  const range = controller.value.selection;
  let newRange = range.moveToEnd(document);

  if (marks.length || selection.marks) {
    // 允许清除样式后 selection.marks = [] 继承到下一行
    newRange = range.merge({
      marks: marks.length ? marks : selection.marks
    });
  }

  return controller.command(select, newRange);
}
/**
 * 在指定选区区间拆分 Block
 * @param controller
 * @param selection
 * @param depth 对于嵌套结构，可以指定拆分深度，默认拆分深度为 1 ，即只拆分距选区最近的 Block
 * @returns
 * @example
 * 
 * ```ts
 * // 
 * //   ┌───────┐                      ┌───────┐   
 * //   │ root  │                      │ root  │   
 * //   └───────┘                      └───────┘   
 * //       │                              │       
 * //       ▼                              ▼       
 * //     ┌───┐                          ┌───┐     
 * //     │ A │                          │ A │     
 * //     └───┘                          └───┘     
 * //       │       ──depth=3─▶            │       
 * //       ▼                         ┌─────────┐  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ B │                     │ B │     │B1 │
 * //     └───┘                     └───┘     └───┘
 * //       │                         │         │  
 * //      │▼                         ▼         ▼  
 * //   ┌──┼────┐                   ┌───┐     ┌───┐
 * //   │'a│bc' │                   │'a'│     │'bc│
 * //   └──┼────┘                   └───┘     └───┘
 * //      │                                       
 * //   cursor                                    
 * //
 * 
 * const newDocument = controller.commands('splitBlockAtRange', cursor);
 * 
 * //   ┌───────┐                      ┌───────┐   
 * //   │ root  │                      │ root  │   
 * //   └───────┘                      └───────┘   
 * //       │                         ┌─────────┐  
 * //       ▼                         ▼         ▼  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ A │                     │ A │     │A1 │
 * //     └───┘                     └───┘     └───┘
 * //       │       ──depth=3─▶       │         │  
 * //       ▼                         ▼         ▼  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ B │                     │ B │     │B1 │
 * //     └───┘                     └───┘     └───┘
 * //       │                         │         │  
 * //      │▼                         ▼         ▼  
 * //   ┌──┼────┐                   ┌───┐     ┌───┐
 * //   │'a│bc' │                   │'a'│     │'bc│
 * //   └──┼────┘                   └───┘     └───┘
 * //      │                                       
 * //   cursor                                    
 * //
 * 
 * const newDocument = controller.commands('splitBlockAtRange', cursor, 3);
 *                                                      
 * ```
 */

function splitBlockAtRange(controller, selection, depth = 1) {
  let range = selection;
  let {
    value
  } = controller;
  let {
    document
  } = value;

  if (range.isCollapsed && range.anchor.isEdgePoint()) {
    // 对于 edge selection，做特殊处理。
    const point = range.anchor;
    const isAtBefore = point.edge === EdgePoint.BEFORE;
    controller.command(insertEmptyBlock, point);

    if (isAtBefore) {
      controller.command(select, range);
    }

    return controller;
  }

  range = deleteExpandedAtRange(controller, range);
  const {
    start,
    end
  } = range.convertToTextPoints(document);
  let node = document.assertNode(start.key);
  let parent = document.getClosestBlock(node.key);
  let d = 0;

  while (parent && d < depth) {
    node = parent;
    parent = document.getClosestBlock(parent.key);
    d++;
  }

  return controller.withoutNormalizing(() => {
    controller.command(splitDescendantsByKey, node.key, start.key, start.offset);
    value = controller.value;
    document = value.document;

    if (range.isExpanded) {
      if (range.isBackward(document)) range = range.flip();
      const nextBlock = document.getNextBlock(node.key);
      range = range.moveAnchorToStartOfNode(nextBlock, controller);

      if (start.key === end.key) {
        range = range.moveFocusTo(range.anchor.key, end.offset - start.offset);
      }

      controller.command('deleteAtRange', range);
    }
  });
}
/**
 * 在当前选区拆分 Inline
 * 
 * @param controller
 * @param depth 对于嵌套结构，可以指定拆分深度，默认拆分深度为 1 ，即只拆分距选区最近的 Inline
 * @returns
 * @example
 * 
 * ```ts
 * // 
 * //   ┌───────┐                      ┌───────┐   
 * //   │ root  │                      │ root  │   
 * //   └───────┘                      └───────┘   
 * //       │                              │       
 * //       ▼                              ▼       
 * //     ┌───┐                          ┌───┐     
 * //     │ A │                          │ A │     
 * //     └───┘                          └───┘     
 * //       │       ──depth=3─▶            │       
 * //       ▼                         ┌─────────┐  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ B │                     │ B │     │B1 │
 * //     └───┘                     └───┘     └───┘
 * //       │                         │         │  
 * //      │▼                         ▼         ▼  
 * //   ┌──┼────┐                   ┌───┐     ┌───┐
 * //   │'a│bc' │                   │'a'│     │'bc│
 * //   └──┼────┘                   └───┘     └───┘
 * //      │                                       
 * //   cursor                                    
 * //
 * 
 * const newDocument = controller.commands('splitInline');
 * 
 *  * // 
 * //   ┌───────┐                      ┌───────┐   
 * //   │ root  │                      │ root  │   
 * //   └───────┘                      └───────┘   
 * //       │                         ┌─────────┐  
 * //       ▼                         ▼         ▼  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ A │                     │ A │     │A1 │
 * //     └───┘                     └───┘     └───┘
 * //       │       ──depth=3─▶       │         │  
 * //       ▼                         ▼         ▼  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ B │                     │ B │     │B1 │
 * //     └───┘                     └───┘     └───┘
 * //       │                         │         │  
 * //      │▼                         ▼         ▼  
 * //   ┌──┼────┐                   ┌───┐     ┌───┐
 * //   │'a│bc' │                   │'a'│     │'bc│
 * //   └──┼────┘                   └───┘     └───┘
 * //      │                                       
 * //   cursor                                    
 * //
 * 
 * const newDocument = controller.commands('splitInline', 3);
 *                                                      
 * ```
 */

function splitInline(controller, depth = 1) {
  deleteExpanded(controller);
  const {
    selection
  } = controller.value;
  return controller.command(splitInlineAtRange, selection, depth);
}
/**
 * 在指定选区区间拆分 Inline
 * @param controller
 * @param selection
 * @param depth 对于嵌套结构，可以指定拆分深度，默认拆分深度为 Infinity ，即从根节点开始拆分 Inline
 * @returns
 * @example
 * 
 * ```ts
 * //
 * //   ┌───────┐                      ┌───────┐   
 * //   │ root  │                      │ root  │   
 * //   └───────┘                      └───────┘   
 * //       │                         ┌─────────┐  
 * //       ▼                         ▼         ▼  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ A │                     │ A │     │A1 │
 * //     └───┘                     └───┘     └───┘
 * //       │   ──depth=Infinity─▶    │         │  
 * //       ▼                         ▼         ▼  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ B │                     │ B │     │B1 │
 * //     └───┘                     └───┘     └───┘
 * //       │                         │         │  
 * //      │▼                         ▼         ▼  
 * //   ┌──┼────┐                   ┌───┐     ┌───┐
 * //   │'a│bc' │                   │'a'│     │'bc│
 * //   └──┼────┘                   └───┘     └───┘
 * //      │                                       
 * //   cursor                                    
 * // 
 * 
 * const newDocument = controller.commands('splitInlineAtRange', cursor);
 * 
 * // 
 * //   ┌───────┐                      ┌───────┐   
 * //   │ root  │                      │ root  │   
 * //   └───────┘                      └───────┘   
 * //       │                              │       
 * //       ▼                              ▼       
 * //     ┌───┐                          ┌───┐     
 * //     │ A │                          │ A │     
 * //     └───┘                          └───┘     
 * //       │       ──depth=1─▶            │       
 * //       ▼                         ┌─────────┐  
 * //     ┌───┐                     ┌───┐     ┌───┐
 * //     │ B │                     │ B │     │B1 │
 * //     └───┘                     └───┘     └───┘
 * //       │                         │         │  
 * //      │▼                         ▼         ▼  
 * //   ┌──┼────┐                   ┌───┐     ┌───┐
 * //   │'a│bc' │                   │'a'│     │'bc│
 * //   └──┼────┘                   └───┘     └───┘
 * //      │                                       
 * //   cursor                                    
 * 
 * const newDocument = controller.commands('splitInlineAtRange', cursor, 1);
 *                                                      
 * ```
 */

function splitInlineAtRange(controller, range, depth = Infinity) {
  range = deleteExpandedAtRange(controller, range);
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const start = range.getStart(document);
  let node = document.assertNode(start.key);
  let parent = document.getClosestInline(node.key);
  let d = 0;

  while (parent && Inline.isInline(parent) && d < depth) {
    node = parent;
    parent = document.getClosestInline(parent.key);
    d++;
  }

  return controller.command(splitDescendantsByKey, node.key, start.key, start.offset);
}

const insertBlockTpl = () => 'cj/cmd/insblock';
const insertInlineTpl = () => 'cj/cmd/insinline';
const insertTpl = path => `cj/cmd/ins(${JSON.stringify(path)})`;

/* eslint-disable no-param-reassign */
/**
 * 在指定位置，插入一个node
 * @key 插入目标节点
 * @index 插入后在目标节点的顺序
 */

function insertNodeByKey(controller, key, index, node) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const path = document.assertPath(key);
  return controller.command(insertNodeByPath, path, index, node);
}
/**
 * 在指定位置，插入一个node
 * @path 插入目标节点
 * @index 插入后在目标节点的顺序
 */

function insertNodeByPath(controller, path, index, node) {
  const insertPath = [...path, index];
  return controller.withOpContext(insertTpl(insertPath), () => {
    return controller.applyOperation({
      type: exports.OperationType.InsertNode,
      path: insertPath,
      node
    });
  });
}

function isBlockEmpty(controller, block) {
  return !controller.query('isVoid', block) && controller.query('isEmpty', block) && block.text === '' && !block.findDescendant(n => controller.query('isVoid', n));
}
/**
 * 在当前选区插入一段文字，并附带marks。
 * 1. marks：会从参数里获取；如果参数没有提供，会尝试从当前selection获取；如果依然没有，就从当前的插入位置获取
 */


function insertText$1(controller, text, ms) {
  const {
    value
  } = controller;
  const {
    document,
    selection
  } = value;

  if (!selection) {
    return controller;
  }

  const marks = ms || selection.marks || document.getInsertMarksAtRange(selection);
  return controller.command(insertTextAtRange, selection, text, marks);
}
/**
 * 在 EdgePoint 的 before 或者 after 位置，插入一个空白的段落。
 */

function insertEmptyBlock(controller, at) {
  let {
    document
  } = controller.value;
  const block = document.getNode(at.key);
  const parent = document.getParent(at.key);
  const isAtBefore = at.edge === EdgePoint.BEFORE;

  if (!block || !parent || !block.isElement() || !block.isBlock()) {
    return controller;
  }

  const index = parent.nodes.indexOf(block);
  const newBlock = Block.create(Block.DEFAULT_TYPE);
  const insertIndex = isAtBefore ? index : index + 1;
  controller.command(insertNodeByKey, parent.key, insertIndex, newBlock);
  document = controller.value.document;
  const node = newBlock.getFirstNode();
  const anchor = TextPoint.create({
    key: node.key,
    offset: 0
  });
  const focus = anchor;
  return controller.command(select, Selection.create({
    anchor,
    focus
  }));
}
/**
 * 在目标位置插入一段文字，并附带marks。
 * 1. 目标位置需要对应一个Text节点，否则会抛出异常
 * 2. marks：会从参数里获取；如果参数没有提供，会尝试从当前的插入位置获取
 */

function insertTextAtRange(controller, r, text, marks) {
  if (r.isCollapsed && r.anchor.isEdgePoint()) {
    controller.command(insertEmptyBlock, r.anchor);
    const textNode = controller.value.focusText;

    if (!textNode) {
      return controller;
    }

    return controller.command(insertTextByKey, textNode.key, 0, text, marks);
  }

  const range = r.isExpanded ? deleteExpandedAtRange(controller, r) : r;
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const {
    start
  } = range.convertToTextPoints(document);
  const parent = document.getParent(start.key);

  if (controller.query('isVoid', parent)) {
    return controller;
  }

  return controller.command(insertTextByKey, start.key, start.offset, text, marks);
}
/**
 * 在目标位置插入一段文字，并附带marks。
 * 1. 目标位置需要对应一个Text节点，否则会抛出异常
 * 2. marks：会从参数里获取；如果参数没有提供，会尝试从当前的插入位置获取
 */

function insertTextByKey(controller, key, offset, text, marks) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const path = document.assertPath(key);
  return controller.command(insertTextByPath, path, offset, text, marks);
}
/**
 * 在目标位置插入一段文字，并附带marks。
 * 1. 目标位置需要对应一个Text节点，否则会抛出异常
 * 2. marks：会从参数里获取；如果参数没有提供，会尝试从当前的插入位置获取
 */

function insertTextByPath(controller, path, offset, text, ms) {
  const {
    value
  } = controller;
  const {
    document,
    decorations
  } = value;
  const node = document.assertNodeByPath(path);

  if (!node.isText()) {
    throw new Error(`Commands.insertText, target([${path.join(',')}] type: ${node.type}) is not a Text node`);
  }

  const marks = ms || node.getMarksAtIndex(offset);
  let updated = false;
  const decs = decorations.filter(dec => {
    const {
      start,
      end,
      mark
    } = dec;
    const isAtomic = controller.query('isAtomic', mark);

    if (!isAtomic) {
      return true;
    }

    const startPath = document.getPath(start.key);

    if (!startPath) {
      updated = true;
      return false;
    }

    if (!Path.isEqual(startPath, path)) {
      return true;
    }

    const endPath = document.getPath(end.key);

    if (!endPath) {
      updated = true;
      return false;
    }

    if (start.offset < offset && (!Path.isEqual(endPath, path) || end.offset > offset)) {
      updated = true;
      return false;
    }

    return true;
  });

  if (updated) {
    controller.setValue(value.set('decorations', decs), {
      normalize: false
    });
  }

  return controller.applyOperation({
    type: exports.OperationType.InsertText,
    path,
    offset,
    text: text || '',
    marks: marks.map(Mark.create)
  });
}
/**
 * 在指定的选区的start位置，插入一个block。
 * 1. 如果start节点在开始/结束位置，或者start节点是个空block，则直接插入；否则先split，后插入
 */

function insertBlockAtRange(controller, range, block) {
  const newRange = deleteExpandedAtRange(controller, range);
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const {
    start
  } = newRange.convertToTextPoints(document);
  let {
    key: startKey,
    offset: startOffset
  } = start;
  const startBlock = document.getClosestBlock(startKey);
  const startInline = document.getClosestInline(startKey);
  const parent = document.getParent(startBlock.key);
  const index = parent.nodes.indexOf(startBlock);
  controller.withOpContext(insertBlockTpl(), () => {
    if (newRange.anchor.isEdgePoint()) {
      // If we insert block at edge point.
      controller.command(insertNodeByKey, parent.key, index + (newRange.anchor.edge === 'before' ? 0 : 1), block);
    } else if (!startInline && startBlock.text === '') {
      // if we insert block at an empty block
      controller.command(insertNodeByKey, parent.key, index + 1, block);
    } else if (start.isAtStartOfNode(startBlock)) {
      controller.command(insertNodeByKey, parent.key, index, block);
    } else if (start.isAtEndOfNode(startBlock)) {
      controller.command(insertNodeByKey, parent.key, index + 1, block);
    } else {
      // If we're in the middle of a block, we should consider split it first
      // If we're in a void inline, we should move cursor to the sibliting text of the inline before spliting
      if (startInline && controller.query('isVoid', startInline)) {
        const atEnd = start.isAtEndOfNode(startInline);
        const siblingText = atEnd ? document.getNextText(startKey) : document.getPreviousText(startKey);
        const splitRange = atEnd ? newRange.moveToStartOfNode(siblingText, controller) : newRange.moveToEndOfNode(siblingText, controller);
        const {
          anchor
        } = splitRange.convertToTextPoints(controller.value.document);
        startKey = anchor.key;
        startOffset = anchor.offset;
      }

      controller.withoutNormalizing(() => {
        controller.command(splitDescendantsByKey, startBlock.key, startKey, startOffset);
        controller.command(insertNodeByKey, parent.key, index + 1, block);
      });
    }
  });
  return controller;
}
/**
 * 在当前选区位置，插入一个block。
 * 1. 如果当前选区是expand，会先执行删除选区操作。
 * 2. 如果start节点在开始/结束位置，或者start节点是个空block，则直接插入；否则先split，后插入
 * @blockProps block或者block参数，会传递给Block.create来创建一个block
 */

function insertBlock(controller, blockProps) {
  const {
    selection
  } = controller.value;
  const block = Block.create(blockProps);
  controller.command(insertBlockAtRange, deleteExpandedAtRange(controller, selection), block); // move to end of inserted block

  const node = controller.value.document.getNode(block.key);

  if (node) {
    controller.command(moveToEndOfNode, node);
  }

  return controller;
}
/**
 * 在当前选区位置，插入一个inline。
 * 1. 如果当前选区是expand，会先执行删除选区操作。
 */

function insertInlineAtRange(controller, range, inline) {
  controller.withOpContext(insertInlineTpl(), () => {
    controller.withoutNormalizing(() => {
      const point = deleteExpandedAtRange(controller, range).anchor;

      if (range.isCollapsed && point.isEdgePoint()) {
        controller.command(insertEmptyBlock, point);
      }

      const {
        document,
        selection
      } = controller.value;
      const {
        start
      } = selection.convertToTextPoints(document);
      const parent = document.getParent(start.key);
      const startText = document.assertNode(start.key);
      const index = parent.nodes.indexOf(startText);
      if (controller.query('isVoid', parent)) return;
      controller.command(splitNodeByKey, start.key, start.offset);
      controller.command(insertNodeByKey, parent.key, index + 1, inline);
    });
  });
  return controller;
}
/**
 * 在当前选区位置，插入一个inline。
 * 1. 如果当前选区是expand，会先执行删除选区操作。
 */

function insertInline(controller, inlineProps) {
  const {
    selection
  } = controller.value;
  const inline = Inline.create(inlineProps);
  controller.command(insertInlineAtRange, selection, inline); // move to end of inserted block

  const node = controller.value.document.getNode(inline.key);

  if (node) {
    controller.command(moveToEndOfNode, node);
  }

  return controller;
} // If the fragment is wrapped by/nested in blocks, and the nesting pattern
// already exists at the range, we meld the fragment contents into the
// document’s existing nesting pattern as much as possible
// Given a `fragment`, `document`, and `startKey`, it returns a Node from the
// `fragment` to be inserted into the document. By default, the node returned
// will be the `fragment`, but if a common nesting pattern is detected, a
// sub-node of the fragment will be returned.
// The detection algorithm is as follows:
// 1. Ensure the fragment has a single child node, call it `fragmentInner`
// 2. Find the furthest document ancestor of the `startKey` matching
//    `fragmentInner.type`. Call this `documentInner`
// 3. Drill into both `documentInner` and `fragmentInner` as long as each has
//    a single child node and their types match. The stopping point for the
//    fragment is the sub-node to insert into the document.

const findInsertionNode = (fragment, document, startKey) => {
  const hasSingleNode = object => {
    if (!object || Text$1.isText(object)) {
      return false;
    }

    return object.nodes.length === 1;
  };

  const firstNode = object => object && object.nodes[0];

  let node = fragment;

  if (hasSingleNode(fragment)) {
    let fragmentInner = firstNode(fragment);
    let documentInner = document.getFurthsest(startKey, documentNode => {
      if (document instanceof Element$1) {
        return documentNode.type === fragmentInner.type;
      }

      return false;
    });

    if (documentInner === document.getParent(startKey)) {
      node = fragmentInner;
    }

    while (hasSingleNode(fragmentInner) && hasSingleNode(documentInner)) {
      fragmentInner = firstNode(fragmentInner);
      documentInner = firstNode(documentInner);

      if (fragmentInner.type === documentInner.type) {
        node = fragmentInner;
      } else {
        break;
      }
    }
  }

  return node;
};
/**
 * 在目标位置插入一个fragment
 * 1. 内部遍历fragment的每一个node，然后调用Commands.insertNode
 * 2. 如果针对复制粘贴等上层场景，需要考虑key重新生成等逻辑，请使用Commands.insertFragment
 */


function insertFragmentByKey(controller, key, index, fragment) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const path = document.assertPath(key);
  return controller.command(insertFragmentByPath, path, index, fragment);
}
/**
 * 在目标位置插入一个fragment
 * 1. 内部遍历fragment的每一个node，然后调用Commands.insertNode
 * 2. 如果针对复制粘贴等上层场景，需要考虑key重新生成等逻辑，请使用Commands.insertFragment
 */

function insertFragmentByPath(controller, path, index, fragment) {
  fragment.nodes.forEach((node, i) => {
    controller.command(insertNodeByPath, path, index + i, node);
  });
  return controller;
}
/**
 * 在当前插入一个fragment
 * 1. 内部会处理插入点、插入后的光标行为，以符合用户直觉
 */

function insertFragment(controller, fragment) {
  if (!fragment.nodes.length) {
    return controller;
  } // pre-step, delete the selection is it's expanded


  deleteExpanded(controller); // save the values before insert

  let {
    value
  } = controller;
  let {
    document
  } = value;
  let {
    selection
  } = value;

  if (!selection) {
    return controller;
  } // 获取插入位置祖先 Block 元素, 非容器节点插入祖先为 Document、Block, 容器节点插入祖先为 Document、Block、Block...


  const startAncestors = document.getAncestors(selection.anchor.key);
  const lastText = fragment.getLastText();

  if (!lastText) {
    return controller;
  }

  const {
    start,
    end
  } = selection.sort(document);
  const {
    startText,
    endText
  } = value;
  const keys = document.getTexts().map(text => text.key); // perform insert

  controller.command(insertFragmentAtRange, selection, fragment); // get the new values after insert

  ({
    value
  } = controller);
  ({
    document
  } = value);
  selection = value.selection;
  const updatedTexts = document.getTexts();
  const newTexts = updatedTexts.filter(n => !keys.includes(n.key));
  const lastNewText = newTexts[newTexts.length - 1]; // selection - take the selection back if it's removed (e.g. the last one block is deleted)

  if (!selection && updatedTexts.length) {
    const firstText = updatedTexts[0];
    const point = TextPoint.create({
      key: firstText.key,
      offset: 0
    });
    controller.command(select, Selection.create({
      anchor: point,
      focus: point
    }));
  }
  /**
   * 插入 fragment 后移动光标的位置：
   * 1. 首先判断本次插入操作是否有产生新的 text，如果没有产生新 text 节点，则为纯文字的插入，光标会自动校正，不需要处理
   * 2. 若产生了新的 text 节点，则先移动至 lastText 的 end 点
   * 3. 如果插入的过程中产生了对一段文字的后半段做 split 操作，则需要做偏移校正，校正的距离为插入前光标距离末尾的偏移量
   */


  if (lastNewText) {
    controller.command(moveToEndOfNode, lastNewText);
    const blockParent = document.getClosestBlock(lastNewText.key);
    const nextText = blockParent?.getNextText(lastNewText.key); // lastText 节点的 nextText 节点与插入 fragment 前的 endText 相等
    // 这种状况是由于在段落的行首插入一个 inline 元素不会触发 split 操作，这种情况不需要校正偏移量，直接移动至 next 的首位

    if (nextText && nextText.key === end.key) {
      controller.command(moveToStartOfNode, nextText);
    } else if (endText && end.isTextPoint()) {
      // 如果 nextText 节点不相等，则说明出现了文字截断，此时要做偏移位校正，校正时需要先从光标点位和字符串中取分割的文字串，然后再计算字数
      // 注意这里有个小问题：Point 的 offset 表示的是字符的偏移量，但是 moveBackward 方法是做的字偏移，所以要计算 Unicode 字
      // 关于 Unicode 的一个小问题：存在一种组合 Unicode 会导致字数计算有偏差，例如【👩‍ 🦱】，如果将空格删除，则两个 emoji 会合并，这种组合性的 emoji 在
      // 字数计算的时候会被拆分出来成 2 个字
      const subText = endText.text.substring(end.offset);
      const offsetToEnd = GraphemesBreaker.countBreaks(subText);
      const firstChildHasBlockChildren = fragment.nodes[0].hasBlockChildren();
      const startBlock = startText && document.getClosestBlock(startText.key);
      const isAtStartOfUnEmptyNode = startBlock && start.isAtStartOfNode(startBlock);

      if (firstChildHasBlockChildren && isAtStartOfUnEmptyNode) ; else {
        controller.command(moveBackward, offsetToEnd);
      }

      const subRoot = document.getAncestors(lastNewText.key)[1]; // 插入 Void Block 节点时，光标移到 Block 节点外部

      if ( // 根据祖先元素长度判断是否在容器节点内插入内容, 如果根节点下插入容器节点，插入后光标最后移出容器
      // 如果在容器内插入普通节点，光标保持在容器内部
      startAncestors.length <= 2 && controller.query('isEdgeSelectable', subRoot) && subRoot.getLastText() === lastNewText) {
        controller.command(moveToStartOfNextBlock);
      }
    }

    if (controller.value.selection.isExpanded) {
      controller.command(moveToStart);
    }
  }

  return controller;
}
/**
 * 在指定的选区插入一个fragment
 * 1. 如果选区是expand，会先删除选区
 */

function insertFragmentAtRange(controller, range, fragment) {
  if (!fragment.nodes.length) {
    return controller;
  }

  return controller.withoutNormalizing(() => {
    range = deleteExpandedAtRange(controller, range);

    if (range.isCollapsed && range.anchor.isEdgePoint()) {
      controller.command(insertEmptyBlock, range.anchor);
      range = controller.value.selection;
    }

    fragment = fragment.mapDescendants(child => child.regenerateKey()); // NOTE: 这里调用 command key 试插件 onCommand 时间触发，主要用于图片的复制转存逻辑
    // TODO: 在 model 增加一个可以不计入 asl 的 attributes，用于存储 key

    controller.command('insertFragmentWithRealKeyAtRange', range, fragment);
  });
}
/**
 * 在指定的选区插入一个fragment
 * 1. fragment必须包含有效的无冲突的key
 */

function insertFragmentWithRealKeyAtRange(controller, range, fragment) {
  const {
    value
  } = controller;
  let {
    document
  } = value; // checking the start point

  const {
    start,
    end
  } = range.convertToTextPoints(document);
  let startText = document.getNode(start.key);
  let startBlock = document.getClosestBlock(startText.key);
  let startChild = startBlock.getFurthestAncestor(startText.key);
  const isAtStart = start.isAtStartOfNode(startBlock);
  const isAtEnd = end.isAtEndOfNode(startBlock);
  let parent = document.getParent(startBlock.key);
  const index = parent.nodes.indexOf(startBlock);
  const blocks = fragment.getBlocks();

  if (blocks.length === 0) {
    return controller;
  }

  const firstChild = fragment.nodes[0];
  const lastChild = fragment.nodes[fragment.nodes.length - 1];
  const firstBlock = blocks[0];
  const lastBlock = blocks[blocks.length - 1];
  const insertionNode = findInsertionNode(fragment, document, startBlock.key); // 设置用户数据

  controller.userData.mergeUserData(fragment); // If the new fragment only contains a void block, use `insertBlockAtRange`

  if (firstBlock === lastBlock && controller.query('isVoid', firstBlock) && !controller.query('isContainer', insertionNode)) {
    controller.command(insertBlockAtRange, range, firstBlock);
    return controller;
  } // If the new fragment starts or ends with a single nested block,
  // e.g. a table, use `insertBlockAtRange`


  const firstChildHasBlockChildren = firstChild.hasBlockChildren();
  const lastChildHasBlockChildren = lastChild.hasBlockChildren();

  if (insertionNode === fragment && (firstChildHasBlockChildren || lastChildHasBlockChildren)) {
    // 如果插入的第一个节点是一个容器节点：
    //
    // Fragment:
    // ```tsx
    // <document>
    //   <block>
    //     <block>Hello</block>
    //     <block>World</block>
    //   </block>
    //   <block>Cangjie</block>
    // </document>
    // ```
    //
    // 插入到光标位置
    // ```tsx
    // <document>
    //   <block>Intro<cursor />123</block>
    //   <block>Command</block>
    // </document>
    // ```
    //
    // 期望是
    // ```tsx
    // <document>
    //   <block>Intro</block>
    //   <block>
    //     <block>Hello</block>
    //     <block>World</block>
    //   </block>
    //   <block>Cangjie</block>
    //   <block>123</block>
    //   <block>Command</block>
    // </document>
    // ```
    //
    if (firstChildHasBlockChildren) {
      // 非空节点插入内容，不需要进行 reverse
      const isAtStartOfUnEmptyNode = start.isAtStartOfNode(startBlock);
      const nodes = isAtStartOfUnEmptyNode ? fragment.nodes : [...fragment.nodes].reverse();
      nodes.forEach(node => {
        controller.command(insertBlockAtRange, range, node);
      });
      return controller;
    } // 如果插入的最后一个节点是一个容器节点：
    //
    // Fragment:
    // ```tsx
    // <document>
    //   <block>Cangjie</block>
    //   <block>
    //     <block>Hello</block>
    //     <block>World</block>
    //   </block>
    // </document>
    // ```
    //
    // 插入到光标位置
    // ```tsx
    // <document>
    //   <block>Intro<cursor />123</block>
    // </document>
    // ```
    //
    // 期望是
    // ```tsx
    // <document>
    //   <block>IntroCangjie</block>
    //   <block>
    //     <block>Hello</block>
    //     <block>World</block>
    //   </block>
    //   <block>123</block>
    // </document>
    // ```
    //


    if (lastChildHasBlockChildren) {
      // 插入最后一个节点，再在原位置插入剩余节点
      controller.command(insertBlockAtRange, range, lastChild);
      const rest = fragment.removeNode([fragment.nodes.length - 1]);

      if (rest.nodes.length) {
        controller.command(insertFragmentWithRealKeyAtRange, range, rest);
      }
    }

    return controller;
  } // If the first and last block aren't the same, we need to insert all of the
  // nodes after the insertion node's first block at the index.


  if (firstBlock !== lastBlock) {
    const lonelyParent = insertionNode.getFurthsest(firstBlock.key, p => p.nodes.length === 1);
    const lonelyChild = lonelyParent || firstBlock;
    const startIndex = parent.nodes.indexOf(startBlock);
    const excludingLonelyChild = insertionNode.removeNode(insertionNode.assertPath(lonelyChild.key));
    excludingLonelyChild.nodes.forEach((node, i) => {
      const newIndex = startIndex + i + 1;
      controller.command(insertNodeByKey, parent.key, newIndex, node);
    });
  } // Check if we need to split the node.


  if (start.offset !== 0) {
    controller.command(splitDescendantsByKey, startChild.key, start.key, start.offset);
  }

  ({
    document
  } = controller.value);
  startText = document.getNode(start.key);
  startBlock = document.getClosestBlock(start.key);
  parent = document.getParent(startBlock.key);
  startChild = startBlock.getFurthestAncestor(startText.key);

  if (firstBlock !== lastBlock) {
    const nextChild = isAtStart ? startChild : startBlock.getNextSibling(startChild.key);
    const nextNodes = nextChild ? listUtils.skipUntil(startBlock.nodes, n => n.key === nextChild.key) : [];
    const block = document.assertElement(lastBlock.key);

    if (!controller.query('isVoid', block)) {
      // 如果插入的最后一个节点是非 void block，则 split 后的 nodes 可以追加到 block 末尾
      // Fragment:
      // ```ts
      // <document>
      //   <block>Hello</block>
      //   <block>World</block>
      // </document>
      // ```
      //
      // 在如下光标位置插入:
      // ```ts
      // <document>
      //   <block>123<cursor />45</block>
      // </document>
      // ```
      //
      // 期望的插入结果是:
      // ```ts
      // <document>
      //   <block>123Hello</block>
      //   <block>World45</block>
      // </document>
      // ```
      const moveTo = block.nodes.length;
      nextNodes.forEach((node, i) => {
        const newIndex = moveTo + i;
        controller.command(moveNodeByKey, node.key, block.key, newIndex);
      });
    } else {
      // 如果插入的最后一个节点是 void block，则 split 后的 nodes 可以插入到 block 之后
      // Fragment:
      // ```ts
      // <document>
      //   <block>Hello</block>
      //   <void-block />
      // </document>
      // ```
      //
      // 在如下光标位置插入:
      // ```ts
      //   <document>
      //     <block>123<cursor />45</block>
      //   </document>
      // ```
      //
      // 期望的插入结果为:
      // ```ts
      //   <document>
      //     <block>123Hello</block>
      //     <void-block />
      //     <block>45</block>
      //   </document>
      // ```
      const insertAt = document.assertElement(parent.key).nodes.indexOf(block) + 1;
      nextNodes.forEach(node => {
        controller.command(removeNodeByKey, node.key);
      }); // 新插入的节点继承原 block 的属性

      const restBlock = startBlock.set('nodes', nextNodes).regenerateKey();

      if (!isAtEnd) {
        controller.command(insertNodeByKey, parent.key, insertAt, restBlock);
      }
    }
  }

  if (isBlockEmpty(controller, startBlock)) {
    // 如果 start block 为空，则直接替换 start block 为待插入的 first block
    // 是否为空的断言需要插件实现 `isEmpty`，即由插件决定某个元素是否可以被判定为空，且被替换
    // Fragment:
    // ```ts
    //   <document>
    //     <block>Hello</block>
    //     <block>World</block>
    //   </document>
    // ```
    //
    // 在如下光标位置插入:
    // ```ts
    //   <document>
    //     <block><cursor /></block>
    //   </document>
    // ```
    //
    // 期望的插入结果是:
    // ```ts
    // <document>
    //   <block>Hello</block>
    //   <block>World</block>
    // </document>
    // ```
    controller.command(insertNodeByKey, parent.key, index, firstBlock).command(removeNodeByKey, startBlock.key);
  } else {
    // 否则，保留 start block，并在 start block 的分裂位置插入 first block 的子孙
    // 1. first block is non-void
    // Fragment:
    // ```ts
    // <document>
    //   <block>Hello</block>
    //   <block>World</block>
    // </document>
    // ```
    //
    // 在如下光标位置插入:
    // ```ts
    // <document>
    //   <block>Cangjie<cursor /></block>
    // </document>
    // ```
    //
    // 期望的插入结果是:
    // ```ts
    // <document>
    //   <block>CangjieHello</block>
    //   <block>World</block>
    // </document>
    // ```
    //
    // 2. first block is void
    // Fragment:
    // ```ts
    // <document>
    //   <void-block />
    //   <block>World</block>
    // </document>
    // ```
    //
    // 在如下光标位置插入:
    // ```ts
    // <document>
    //   <block>Cangjie<cursor /></block>
    // </document>
    // ```
    //
    // 期望的插入结果是:
    // ```ts
    // <document>
    //   <block>Cangjie</block>
    //   <void-block />
    //   <block>World</block>
    // </document>
    // ```
    // 否则，保留 start block，并在 start block 的分裂位置插入 first block 的子孙
    const inlineChild = startBlock.getFurthestAncestor(startText.key);
    const inlineIndex = startBlock.nodes.indexOf(inlineChild);

    if (controller.query('isVoid', firstBlock)) {
      const insertAt = parent.nodes.indexOf(startBlock) + 1;
      controller.command(insertNodeByKey, parent.key, insertAt, firstBlock);
    } else {
      firstBlock.nodes.forEach((inline, i) => {
        const o = start.offset === 0 ? 0 : 1;
        const newIndex = inlineIndex + i + o;
        controller.command(insertNodeByKey, startBlock.key, newIndex, inline);
      });
    }
  }

  return controller;
}

const mergeTpl = (node, path) => `cj/cmd/merge_${node.isElement() ? 'node' : 'text'}(${JSON.stringify(path)})`;

/**
 * @packageDocumentation
 * @module Commands
 */
/**
 * 把目标 path 的 Node，合并到其上一个 Sibling 上。
 * 1. 必须满足 Node 和上一个 Sibling 是同一种类型。
 * 2. 如果没有上一个 Sibling，直接抛异常。
 */

function mergeNodeByKey(controller, key) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const path = document.assertPath(key);
  return controller.command(mergeNodeByPath, path);
}
/**
 * 把目标 path 的 Node，合并到其上一个 Sibling 上。
 * 1. 必须满足 Node 和上一个 Sibling 是同一种类型。
 * 2. 如果没有上一个 Sibling，直接抛异常。
 */

function mergeNodeByPath(controller, path) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const original = document.getNodeByPath(path);
  const previous = original ? document.getPreviousSibling(original.key) : null;

  if (!previous) {
    throw new Error(`Unable to merge node with path "${path}", because it has no previous sibling.`);
  }

  if (previous.constructor !== original.constructor) {
    throw new Error(`Unable to merge two different kinds of nodes: ${previous} and ${original}`);
  }

  const previousPath = document.getPath(previous.key);
  const previousNode = previous.toSubType();
  const position = previousNode.isText() ? previousNode.text.length : previousNode.nodes.length;
  controller.withOpContext(mergeTpl(original, path), () => {
    controller.withoutNormalizing(() => {
      if (original.isElement()) {
        const moveNodePath = [...path, 0];
        original.nodes.forEach((node, index) => {
          controller.command(moveNodeByPath, moveNodePath, previousPath, position + index);
        });
        controller.command(removeNodeByPath, path);
      } else {
        const {
          leaves
        } = original;
        let offset = previousNode.text.length;
        const {
          selection,
          decorations
        } = controller.value;
        leaves.forEach(leaf => {
          controller.command(insertTextByPath, previousPath, offset, leaf.text, leaf.marks);
          offset += leaf.text.length;
        });
        controller.command(removeNodeByPath, path); // 处理 updatePoints 的问题；具体请参考 split 中同样的处理

        const valueToUpdate = controller.value.set('decorations', decorations).set('selection', selection);
        const updatedValue = valueToUpdate.updatePoints(valueToUpdate.document, point => {
          if (point.key === original.key) {
            return point.merge({
              key: previousNode.key,
              offset: point.offset + position
            });
          }

          return point;
        });
        controller.setValue(updatedValue, {
          clearOperations: false
        });
      }
    });
  });
  return controller;
}

/**
 * @packageDocumentation
 * @module Commands
 */
/**
 * 在当前选区，添加mark
 * 1. 如果选区是expand，会设置当前选中内容的mark
 * 2. 如果选区是collapse，会把m和当前的选区的marks，一起合并到当前selection内
 */

function addMark(controller, m) {
  const mark = Mark.create(m);
  const {
    value
  } = controller;
  const {
    document,
    selection
  } = value;

  if (selection.isExpanded) {
    controller.command(addMarkAtRange, selection, mark);
  } else {
    const activeMarks = selection.marks || document.getActiveMarksAtRange(selection);
    const sel = selection.set('marks', setUtils.add(activeMarks, mark));
    controller.command('select', sel);
  }

  return controller;
}
/**
 * 对指定的选区内，增加mark
 * 1. 如果选区是collapse，则什么都不做
 */

function addMarkAtRange(controller, range, mark) {
  if (range.isCollapsed) return controller;
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const {
    start,
    end
  } = range.convertToTextPoints(document);
  const texts = document.getTextsAtRange(range);
  controller.withoutNormalizing(() => {
    texts.forEach(node => {
      const {
        key
      } = node;
      let offset = 0;
      let {
        length
      } = node.text;
      if (key === start.key) ({
        offset
      } = start);
      if (key === end.key) length = end.offset;

      if (key === start.key && key === end.key) {
        length = end.offset - start.offset;
      }

      controller.command(addMarkByKey, key, offset, length, mark);
    });
  });
  return controller;
}
/**
 * 对指定的选区内，增加mark
 * 1. 如果选区是collapse，则什么都不做
 */

function addMarkByKey(controller, key, offset, length, mark) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const path = document.assertPath(key);
  return controller.command(addMarkByPath, path, offset, length, mark);
}
/**
 * 对一个text节点的一部分文字，增加mark
 * 1. 如果目标无效，或者不是一个text，则什么都不做
 */

function addMarkByPath(controller, path, offset, length, mark) {
  const node = controller.value.document.getNodeByPath(path);
  if (!node || !Text$1.isText(node)) return controller; // Text start offset

  const bx = offset; // Text end offset

  const by = offset + length; // Current Leaf start offset

  let o = 0;
  node.leaves.forEach(leaf => {
    // Leaf start offset
    const ax = o; // Leaf end offset

    const ay = ax + leaf.text.length; // 叠加偏移量

    o += leaf.text.length; // If the leaf doesn't overlap with the operation, continue on.

    if (ay < bx || by < ax) return; // If the leaf already has the mark, continue on.

    if (leaf.marks.find(m => m.isEqual(mark))) return; // Otherwise, determine which offset and characters overlap.

    const start = Math.max(ax, bx);
    const end = Math.min(ay, by);
    controller.applyOperation({
      type: exports.OperationType.AddMark,
      path,
      offset: start,
      length: end - start,
      mark
    });
  });
  return controller;
}
/**
 * 在当前选区，添加marks
 * 1. 如果选区是expand，会设置当前选中内容的marks
 * 2. 如果选区是collapse，会把marks和当前的选区的marks，一起合并到当前selection内
 */

function addMarks(controller, marks) {
  marks.forEach(mark => controller.command(addMark, mark));
  return controller;
}
/**
 * 对指定的选区内，增加marks
 * 1. 如果选区是collapse，则什么都不做
 */

function addMarksAtRange(controller, range, marks) {
  marks.forEach(mark => controller.command(addMarkAtRange, range, mark));
  return controller;
}
/**
 * 在当前的选区内，toggleMark
 * 1. 如果选区是expand，会设置到当前选中内容
 * 2. 如果选区是collapse，会设置到当前的selection
 */

function toggleMark(controller, m) {
  const mark = Mark.create(m);
  const {
    value
  } = controller;
  const {
    selection,
    document
  } = value;

  if (selection.isExpanded) {
    return controller.command(toggleMarkAtRange, selection, mark);
  }

  const activeMarks = selection.marks || document.getActiveMarksAtRange(selection);
  const newMarks = setUtils.has(activeMarks, mark) ? setUtils.remove(activeMarks, mark) : setUtils.add(activeMarks, mark);
  const sel = selection.set('marks', newMarks);
  return controller.command('select', sel);
}
/**
 * 在指定的选区内，toggleMark
 * 1. 如果选区是collapse，什么都不做
 */

function toggleMarkAtRange(controller, range, m) {
  if (range.isCollapsed) {
    return controller;
  }

  const mark = Mark.create(m);
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const activeMarks = document.getActiveMarksAtRange(range);

  if (setUtils.has(activeMarks, mark)) {
    controller.command(removeMarkAtRange, range, mark);
  } else {
    controller.command(addMarkAtRange, range, mark);
  }

  return controller;
}
/**
 * 在当前的选区内，删除mark
 * 1. 如果选区是expand，会设删除当前选中内容的mark
 * 2. 如果选区是collapse，会删除当前的selection的mark
 */

function removeMark(controller, m) {
  const mark = Mark.create(m);
  const {
    value
  } = controller;
  const {
    document,
    selection
  } = value;

  if (selection.isExpanded) {
    return controller.command(removeMarkAtRange, selection, mark);
  }

  const activeMarks = selection.marks || document.getActiveMarksAtRange(selection);
  const sel = selection.set('marks', setUtils.remove(activeMarks, mark));
  return controller.command('select', sel);
}
/**
 * 在指定的选区内，删除mark
 * 1. 如果选区是collapse，什么都不做
 */

function removeMarkAtRange(controller, range, mark) {
  if (range.isCollapsed) return controller;
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const {
    start,
    end
  } = range.convertToTextPoints(document);
  const texts = document.getTextsAtRange(range);
  controller.withoutNormalizing(() => {
    texts.forEach(node => {
      const {
        key
      } = node;
      let offset = 0;
      let {
        length
      } = node.text;
      if (key === start.key) ({
        offset
      } = start);
      if (key === end.key) length = end.offset;

      if (key === start.key && key === end.key) {
        length = end.offset - start.offset;
      }

      controller.command(removeMarkByKey, key, offset, length, mark);
    });
  });
  return controller;
}
/**
 * 对指定的节点，删除mark
 * 1. 如果指定的节点无效，会抛异常
 */

function removeMarkByKey(controller, key, offset, length, mark) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const path = document.assertPath(key);
  return controller.command(removeMarkByPath, path, offset, length, mark);
}
/**
 * 对指定的节点，删除mark
 * 1. 如果指定的节点无效，会抛异常
 */

function removeMarkByPath(controller, path, offset, length, mark) {
  const text = controller.value.document.getNodeByPath(path);
  let totalOffset = 0;
  text.leaves.forEach(leaf => {
    // current start offset
    const o = totalOffset;
    const leafLength = leaf.text.length;
    totalOffset += leafLength;
    if (o + leafLength < offset || o > offset + length) return;
    if (!setUtils.has(leaf.marks, mark)) return;
    const start = Math.max(offset, o);
    const end = Math.min(offset + length, o + leafLength);
    controller.applyOperation({
      type: exports.OperationType.RemoveMark,
      path,
      offset: start,
      length: end - start,
      mark
    });
  });
  return controller;
}
/**
 * 对指定的节点，替换或者添加mark
 * 1. 如果指定的节点无效，会抛异常
 */

function replaceMark(controller, oldMark, newMark) {
  return controller.command(removeMark, oldMark).command(addMark, newMark);
}

/* eslint-disable prefer-destructuring */
/**
 * 删除 Selection 内的所有内容
 */

function deleteAtRange(controller, range) {
  const {
    value
  } = controller;
  let {
    document
  } = value;
  let {
    start,
    end
  } = range.sort(document); // edge point - shim them for hanging positions

  if (start.isEdgePoint() && start.edge === EdgePoint.AFTER) {
    start = controller.query(pointAtDistance, start, 1);
  }

  if (end.isEdgePoint() && end.edge === EdgePoint.BEFORE) {
    end = controller.query(pointAtDistance, end, -1);
  }

  const detectSelection = Selection.create({
    anchor: start,
    focus: end
  });

  if (detectSelection.isCollapsedAtEdge || detectSelection.isBackward(document)) {
    return controller;
  } // edge point - delete them


  if (start.isEdgePoint()) {
    const node = controller.value.document.getNode(start.key);
    controller.command(insertEmptyBlock, start).command(removeNodeByKey, start.key);

    if (start.key === end.key || node?.isElement() && node.hasNode(end.key)) {
      return controller;
    } // selection is focused to the new text point


    start = controller.value.selection.anchor;
  }

  if (end.isEdgePoint()) {
    const node = controller.value.document.getNode(end.key);
    controller.command(insertEmptyBlock, end).command(removeNodeByKey, end.key);

    if (node?.isElement() && node.hasNode(start.key)) {
      return controller;
    } // selection is focused to the new text point


    end = controller.value.selection.anchor;
  }

  document = controller.value.document; // now [start, end] are text points

  let startOffset = start.offset;
  let endOffset = end.offset;
  let startKey = start.key;
  let endKey = end.key;
  const startText = document.assertNode(start.key);
  const endText = document.assertNode(end.key);
  let startBlock = document.assertClosestBlock(startKey);
  let endBlock = document.assertClosestBlock(endKey);
  const isCrossBlock = startBlock.key !== endBlock.key;
  const isStartVoid = document.hasVoidParent(startKey, controller);
  const isEndVoid = document.hasVoidParent(endKey, controller); // BACKGROUND: Hanging Selection
  // If we select from one paragraph start point to another paragraph start point.
  // The selected content user sees is the first paragraph.
  // If we do a delete on hanging selection, we should delete selection that user sees.

  const isHanging = startOffset === 0 && endOffset === 0 && isStartVoid === false && isEndVoid === false && startKey === startBlock.getFirstNode().key && endKey === endBlock.getFirstNode().key && startKey !== endKey; // Remove all text nodes between start block & end block

  controller.withoutNormalizing(() => {
    const removeNode = node => {
      controller.command(removeNodeByKey, node.key);
    }; // In a single text node


    if (startKey === endKey && !isHanging && !isStartVoid) {
      controller.command(removeTextByKey, startKey, startOffset, startText.text.slice(startOffset, endOffset));
      return controller;
    } // Remove selected text in start text node


    if (startText && startText.text.length - startOffset > 0) {
      controller.command(removeTextByKey, startKey, startOffset, startText.text.slice(startOffset));
    } // Remove selected text in end text node


    if (endText && endOffset > 0) {
      controller.command(removeTextByKey, endKey, 0, endText.text.slice(0, endOffset));
    }

    if (startKey !== endKey) {
      // Remove nodes between start text and end text
      const ancestor = document.assertCommonAncestor(startKey, endKey);
      const ancestorNodes = ancestor.nodes;
      const startChild = ancestor.assertFurthestAncestor(startKey);
      const endChild = ancestor.assertFurthestAncestor(endKey); // Remove nodes from bottom to top in start child

      let child = startText;

      while (child.key !== startChild.key) {
        const parent = document.assertParent(child.key);
        const afters = parent.nodes.slice(parent.nodes.indexOf(child) + 1);
        afters.forEach(removeNode);
        child = parent;
      } // Remove nodes between start child & end child


      const middles = ancestorNodes.slice(ancestorNodes.indexOf(startChild) + 1, ancestorNodes.indexOf(endChild));
      middles.forEach(removeNode); // Remove nodes from top to bottom in end child

      child = endText;

      while (child.key !== endChild.key) {
        const parent = document.assertParent(child.key);
        const befores = parent.nodes.slice(0, parent.nodes.indexOf(child));
        befores.forEach(removeNode);
        child = parent;
      }
    }

    document = controller.value.document; // Find and remove furthest void ancestor

    if (isStartVoid) {
      const startVoidAncestor = document.getFurthsestVoid(startKey, controller);
      const nextText = document.getNextText(startVoidAncestor.key);
      removeNode(startVoidAncestor);

      if (startKey === endKey) {
        return controller;
      } // Move start to the start of next text


      if (!nextText) {
        // If we can't find the next text, we're done
        return controller;
      }

      startKey = nextText.key;
      startOffset = 0;
      document = controller.value.document;
    }

    if (isEndVoid) {
      const endVoidAncestor = document.getFurthsestVoid(endKey, controller);
      const prevText = document.getPreviousText(endVoidAncestor.key);
      removeNode(endVoidAncestor); // Move end to the end of previous text

      if (!prevText) {
        return controller;
      }

      if (startKey === endKey) {
        // endKey is removed!
        startKey = prevText.key;
        startOffset = prevText.text.length;
      }

      endKey = prevText.key;
      endOffset = prevText.text.length;
      document = controller.value.document;
    }

    startBlock = document.getClosestBlock(startKey);
    endBlock = document.getClosestBlock(endKey);

    if (endKey === startKey) {
      if (isHanging) {
        return removeNode(startBlock);
      }

      if (isCrossBlock && document.getPreviousSibling(endBlock.key)) {
        return controller.command(mergeNodeByKey, endBlock.key);
      }
    }

    if (!startBlock) {
      return controller;
    }

    const startParent = document.getParent(startBlock.key);
    const startParentIndex = startParent.nodes.indexOf(startBlock);
    const endParentIndex = startParent.nodes.indexOf(endBlock); // Move the end block into start block and merge them

    if (startBlock.key !== endBlock.key) {
      // If end block's ancestor is empty after merge, we should remove it
      const ancestors = document.getAncestors(endBlock.key);
      const lonely = ancestors ? lodash.takeRightWhile( // Ignore document
      ancestors.slice(1), node => node.nodes.length <= 1)[0] : null; // Put end block under the start block

      if (endParentIndex !== startParentIndex + 1) {
        controller.command(moveNodeByKey, endBlock.key, startParent.key, startParentIndex + 1);
      } // If selection is hanging, we should remove start block(what user sees)


      if (isHanging) {
        removeNode(startBlock);
      } else {
        controller.command(mergeNodeByKey, endBlock.key);
      }

      if (lonely) {
        removeNode(lonely);
      }
    }

    return controller;
  });
  document = controller.value.document;
  const {
    start: rangeStart
  } = controller.value.selection.convertToTextPoints(document);
  const closest = document.getClosestBlock(rangeStart.key);
  const isEmptyParagraph = Text$1.isTextList(closest?.nodes) && closest?.text === '';
  return controller.withoutNormalizing(() => {
    const nextStart = document.getNode(startKey);
    const nextEnd = document.getNode(endKey);
    if (!nextStart && !nextEnd) return;

    if (!nextStart || !nextEnd || nextStart.key === nextEnd.key) {
      // only one or same
      const nextNode = nextStart || nextEnd;

      if (!isEmptyParagraph && Text$1.isText(nextNode) && nextNode.text === '') {
        // don't keep empty text node with marks in non-empty paragraph
        nextNode.marks.forEach(mark => {
          controller.command(removeMarkByKey, nextNode.key, 0, 1, mark);
        });
      }

      return;
    }

    const isSibling = document.getNextSibling(nextStart.key)?.key === nextEnd.key; // start and end is not sibling when one of them in inline node

    if (!isSibling) return;

    if (Text$1.isText(nextEnd) && nextEnd.text === '') {
      // empty end text node is useless
      controller.command(removeNodeByKey, nextEnd.key);
    }

    if (!isEmptyParagraph && Text$1.isText(nextStart) && nextStart.text === '') {
      // don't keep empty text node with marks in non-empty paragraph
      nextStart.marks.forEach(mark => {
        controller.command(removeMarkByKey, nextStart.key, 0, 1, mark);
      });
    }
  });
}
/**
 * 删除当前Selection内的所有内容
 * 1. 将选区开头的样式设置到 selection.marks 中
 */

function del(controller) {
  const {
    selection,
    document
  } = controller.value;
  const {
    start
  } = selection.convertToTextPoints(document);
  const startNode = document.getNode(start.key);
  const startMarks = Text$1.isText(startNode) ? document.getMarksAtPosition(start.key, start.offset + 1) : [];
  controller.command('deleteAtRange', selection);
  let range = controller.value.selection; // set selection.marks to make sure inherit marks from deleted text

  range = range.set('marks', startMarks);
  return controller.command(select, range.moveToFocus());
}
/**
 * 在指定selection上，进行往后删除。
 * @range 如果是expand选区，会删除选区内的内容，并忽略掉后续参数；否则从anchor点往后计算n个unit进行删除
 */

function deleteBackwardAtRange(controller, range, n = 1, unit) {
  const {
    document
  } = controller.value;

  if (range.isExpanded) {
    return controller.command(del);
  }

  let {
    anchor
  } = range;

  if (anchor.isEdgePoint()) {
    const isBackward = n >= 0;
    const point = anchor;
    const deleteEdge = isBackward ? EdgePoint.AFTER : EdgePoint.BEFORE;
    const isToDelete = point.edge === deleteEdge;

    if (isToDelete) {
      // 在 edge block 的后面。直接删除掉，并插入新的段落
      return controller.command(insertEmptyBlock, point).command(removeNodeByKey, point.key);
    } else {
      // 在 edge block 的非删除边缘。需要看前/后一个 block。
      // 如果前/后一个 block 是空的，直接删掉；否则移动到末尾。
      const siblingBlock = isBackward ? document.getPreviousBlock(point.key) : document.getNextBlock(point.key);

      if (!siblingBlock) {
        return controller;
      }

      const closestBlock = document.getClosestSelectableBlock(siblingBlock.key, controller);
      anchor = point;

      if (closestBlock || siblingBlock.text || siblingBlock.nodes.length > 1) {
        anchor = controller.query(isBackward ? pointAtEndOfNode : pointAtStartOfNode, siblingBlock);
      } else {
        controller.command(removeNodeByKey, siblingBlock.key);
      }

      const focus = anchor;
      return controller.command(select, Selection.create({
        anchor,
        focus
      }));
    }
  } // if we're in a void block, remove it


  const voidParent = document.getClosestVoid(anchor.key, controller);

  if (voidParent) {
    if (document.nodes.length === 1 && document.nodes[0] === voidParent) {
      controller.command(insertEmptyBlock, EdgePoint.create({
        key: voidParent.key,
        edge: EdgePoint.BEFORE
      }));
    }

    return controller.command(removeNodeByKey, voidParent.key);
  } // if we're in a empty block, remove it


  const block = document.getClosestBlock(anchor.key);

  if (document.nodes.length !== 1 && block && block.text === '' && block.nodes.length === 1) {
    controller.command(removeNodeByKey, block.key); // 向后删除时，光标移动到删除段落的下一段

    if (n === -1) {
      controller.command(moveToStartOfNextBlock);
    }

    return controller;
  }

  controller.command(moveAnchorBackward, n, unit);
  const {
    selection: updatedSelection
  } = controller.value;
  const updatedAnchor = updatedSelection?.anchor;

  if (updatedAnchor?.isEdgePoint()) {
    return controller.command(moveToAnchor);
  }

  return controller.command(del);
}
/**
 * 在指定selection上，进行往前删除。
 * @range 如果是expand选区，会删除选区内的内容，并忽略掉后续参数；否则从anchor点往前计算n个unit进行删除
 */

function deleteForwardAtRange(controller, range, n = 1, unit) {
  return deleteBackwardAtRange(controller, range, -n, unit);
}
/**
 * 从所有当前选区的位置，往后删除n个offset
 */

function deleteBackward(controller, n = 1) {
  const {
    selection
  } = controller.value;
  return controller.command(deleteBackwardAtRange, selection, n);
}
/**
 * 从所有当前选区的位置，往前删除n个offset
 */

function deleteForward(controller, n = 1) {
  return controller.command(deleteBackward, -n);
}

function createDeleteBoundry(dir) {
  return function deleteBoundray(controller, getBoundaryOrIteratePositionsFromPoint, unit) {
    const isBackward = dir === 'backward';
    const {
      selection
    } = controller.value;
    const defaultBoundary = 1;
    let boundary = typeof getBoundaryOrIteratePositionsFromPoint === 'number' ? getBoundaryOrIteratePositionsFromPoint : defaultBoundary;

    if (selection.anchor.isTextPoint()) {
      const {
        document
      } = controller.value;
      const {
        anchor
      } = selection;
      const block = document.getClosestBlock(anchor.key);

      if (!block) {
        return controller;
      }

      const offset = block.getOffset(anchor.key);

      if (typeof getBoundaryOrIteratePositionsFromPoint === 'function') {
        boundary = getBoundaryOrIteratePositionsFromPoint(block, offset + anchor.offset);
      }
    }

    return controller.command(isBackward ? deleteBackwardAtRange : deleteForwardAtRange, selection, boundary, unit);
  };
}
/**
 * @ignore
 */


const deleteBoundrayBackward = createDeleteBoundry('backward');
/**
 * @ignore
 */

const deleteBoundrayForward = createDeleteBoundry('forward');
/**
 * 从所有当前选区的位置，往后删除1个文字（大多情况下，1个文字等于1个offset，但是1个emoji可能对应多个offset）
 */

function deleteCharBackward(controller) {
  return controller.command(deleteBoundrayBackward, 1);
}
/**
 * 从所有当前选区的位置，往前删除1个文字（大多情况下，1个文字等于1个offset，但是1个emoji可能对应多个offset）
 */

function deleteCharForward(controller) {
  return controller.command(deleteBoundrayForward, 1);
}
/**
 * 从所有当前选区的位置，往后删除1个词
 */

function deleteWordBackward(controller) {
  return controller.command(deleteBoundrayBackward, 1, 'word');
}
/**
 * 从所有当前选区的位置，往前删除1个词
 */

function deleteWordForward(controller) {
  return controller.command(deleteBoundrayForward, 1, 'word');
}
/**
 * 从所有当前选区的位置，往后删除1行文字
 */

function deleteLineBackward(controller) {
  return controller.command(deleteBoundrayBackward, (startBlock, offset) => {
    return textUtils.countBreaks(startBlock.text, offset);
  });
}
/**
 * 从所有当前选区的位置，往前删除1行文字
 */

function deleteLineForward(controller) {
  return controller.command(deleteBoundrayForward, (startBlock, offset) => {
    return textUtils.countBreaks(startBlock.text, offset, true);
  });
}

/**
 * @packageDocumentation
 * @module Commands
 */

/**
 * 在指定的位置上，替换node
 */
function replaceNodeByKey(controller, key, newNode) {
  const {
    document
  } = controller.value;
  const path = document.getPath(key);

  if (!path) {
    return controller;
  }

  return controller.command(replaceNodeByPath, path, newNode);
}
/**
 * 在指定的位置上，替换node
 */

function replaceNodeByPath(controller, path, newNode) {
  const index = path[path.length - 1];
  const parentPath = Path.parent(path);
  return controller.withoutNormalizing(() => {
    controller.command(removeNodeByPath, path).command(insertNodeByPath, parentPath, index, newNode);
  });
}
/**
 * 在指定的位置上，替换文本，并附加marks
 * 1. 提过oldText长度大于可用长度，按照可用长度计算
 */

function replaceTextByKey(controller, key, offset, oldText, text, marks) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const path = document.assertPath(key);
  return controller.command(replaceTextByPath, path, offset, oldText, text, marks);
}
/**
 * 在指定的位置上，替换文本，并附加marks
 * 1. 提过oldText长度大于可用长度，按照可用长度计算
 */

function replaceTextByPath(controller, path, offset, oldText, text, marks = []) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const node = document.assertNodeByPath(path);
  const activeMarks = document.getActiveMarksAtRange(Selection.create({
    anchor: TextPoint.create({
      key: node.key,
      offset
    }),
    focus: TextPoint.create({
      key: node.key,
      offset: offset + oldText.length
    })
  }));
  const mergedMarks = setUtils.union(marks, activeMarks, (a, b) => a.type === b.type);
  return controller.withoutNormalizing(() => {
    controller.command(removeTextByPath, path, offset, oldText).command(insertTextByPath, path, offset, text, mergedMarks.map(Mark.create));
  });
}

/**
 * @packageDocumentation
 * @module Commands
 */
function setNodeByKey(controller, key, properties) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const path = document.assertPath(key);
  return controller.command(setNodeByPath, path, properties);
}
function setNodeByPath(controller, path, properties) {
  const prevNode = controller.value.document.assertNodeByPath(path);
  const prevProperties = Element$1.isElement(prevNode) ? {
    type: prevNode.type,
    data: prevNode.data
  } : {};
  return controller.applyOperation({
    type: exports.OperationType.SetNode,
    path: [...path],
    properties: Node$1.createProperties(properties),
    prevProperties
  });
}
function setBlocks(controller, properties) {
  const {
    selection
  } = controller.value;
  return controller.command(setBlocksAtRange, selection, properties);
}
function setBlocksAtRange(controller, selection, properties) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const {
    start,
    end
  } = selection.convertToTextPoints(document);
  const hasVoidParent = document.hasVoidParent(start.key, controller);
  const startBlock = document.getClosestBlock(start.key);
  const endBlock = document.getClosestBlock(end.key);
  const startNodeKey = startBlock ? startBlock.getFirstNode().key : null;
  const endNodeKey = endBlock ? endBlock.getLastNode().key : null; // Check the "Hanging Selection" case for UX reasons.
  // For more detail, go read the comments in [deleteAtRange]

  const isHanging = selection.isCollapsed === false && hasVoidParent === false && start.offset === 0 && end.offset === 0 && start.key === startNodeKey && end.key === endNodeKey && start.key !== end.key;
  const allBlocks = document.getLeafBlocksAtRange(selection);
  const blocks = isHanging ? allBlocks.slice(0, -1) : allBlocks;
  return controller.withoutNormalizing(() => {
    blocks.forEach(block => {
      controller.command('setNodeByKey', block.key, properties);
    });
  });
}
function setInlines(controller, properties) {
  const {
    selection
  } = controller.value;
  return controller.command(setInlinesAtRange, selection, properties);
}
function setInlinesAtRange(controller, selection, properties) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  return controller.withoutNormalizing(() => {
    const inlines = document.getLeafInlinesAtRange(selection);
    inlines.forEach(inline => {
      controller.command('setNodeByKey', inline.key, properties);
    });
  });
}
function setMarkByKey(controller, key, offset, length, mark, properties) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const path = document.assertPath(key);
  return controller.command(setMarkByPath, path, offset, length, mark, properties);
}
function setMarkByPath(controller, path, offset, length, m, properties) {
  const mark = Mark.create(m);
  return controller.applyOperation({
    type: exports.OperationType.SetMark,
    path,
    offset,
    length,
    mark,
    properties
  });
}
function setTextByKey(controller, key, text, marks) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const path = document.assertPath(key);
  return controller.command(setTextByPath, path, text, marks);
}
function setTextByPath(controller, path, text, marks) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const node = document.assertNodeByPath(path);
  return controller.command(replaceTextByPath, path, 0, node.text, text, marks);
}

const wrapInlineTpl = () => 'cj/cmd/wrapinline';

/**
 * @packageDocumentation
 * @module Commands
 */
/**
 * 在当前选区的start和end位置，插入一些文字，并更新选区位置。
 * 1. 不区分range是否是collapse
 */

function wrapText(controller, prefix, suffix = prefix) {
  const {
    value
  } = controller;
  const {
    selection,
    document
  } = value;
  controller.command(wrapTextAtRange, selection, prefix, suffix);
  let sel = controller.value.selection;

  if (selection.isCollapsed) {
    sel = sel.moveStartBackward(document, prefix.length);
  } // Adding the suffix will have pushed the end of the selection further on, so
  // we need to move it back to account for this.


  sel = sel.moveEndBackward(document, suffix.length);
  return controller.command(select, sel);
}
/**
 * 在选区的start和end位置，插入一些文字
 * 1. 不区分range是否是collapse
 * 2. 此方法不会更新选区位置
 */

function wrapTextAtRange(controller, range, prefix, suffix = prefix) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const startRange = range.moveToStart(document);
  const endRange = range.moveToEnd(document);
  controller.withoutNormalizing(() => {
    controller.command(insertTextAtRange, endRange, suffix);
    controller.command(insertTextAtRange, startRange, prefix);
  });
  return controller;
}
/**
 * 在range的公共父节点上插入block，然后把range对应的nodes都转到block中
 */

function wrapBlock(controller, block) {
  const {
    selection
  } = controller.value;
  return controller.command(wrapBlockAtRange, selection, block);
}
/**
 * 在range的公共父节点上插入block，然后把range对应的nodes都转到block中
 */

function wrapBlockAtRange(controller, range, b) {
  let block = Block.create(b);
  block = block.set('nodes', []);
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const blocks = document.getLeafBlocksAtRange(range);
  const firstblock = blocks[0];
  const lastblock = blocks[blocks.length - 1];
  let parent;
  let siblings;
  let index;

  if (blocks.length === 1) {
    parent = document.getParent(firstblock.key);
    siblings = blocks;
  } else {
    parent = document.getCommonAncestor(firstblock.key, lastblock.key);
  } // If no shared parent could be found then the parent is the document.


  if (parent == null) {
    parent = document;
  } // Create a list of direct children siblings of parent that fall in the
  // selection.


  if (siblings == null) {
    const indexes = parent.nodes.reduce((ind, node, i) => {
      // eslint-disable-next-line no-param-reassign
      if (node === firstblock || node.getNode(firstblock.key)) ind[0] = i; // eslint-disable-next-line no-param-reassign

      if (node === lastblock || node.getNode(lastblock.key)) ind[1] = i;
      return ind;
    }, []);
    [index] = indexes;
    siblings = parent.nodes.slice(indexes[0], indexes[1] + 1);
  } // Get the index to place the new wrapped node at.


  if (index == null) {
    index = parent.nodes.indexOf(siblings[0]);
  }

  controller.withoutNormalizing(() => {
    // Inject the new block node into the parent.
    controller.command(insertNodeByKey, parent.key, index, block); // Move the sibling nodes into the new block node.

    siblings.forEach((node, i) => {
      controller.command(moveNodeByKey, node.key, block.key, i);
    });
  });
  return controller;
}
/**
 * 把目标节点插入到一个新的block节点中，并把block放到原来的节点的位置
 */

function wrapBlockByKey(controller, key, block) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const path = document.assertPath(key);
  return controller.command(wrapBlockByPath, path, Block.create(block));
}
/**
 * 把目标节点插入到一个新的block节点中，并把block放到原来的节点的位置
 */

function wrapBlockByPath(controller, path, b) {
  const block = Block.create(b).set('nodes', []);
  const parentPath = Path.parent(path);
  const index = path[path.length - 1];
  const newPath = Path.increment(path);
  controller.withoutNormalizing(() => {
    controller.command(insertNodeByPath, parentPath, index, block);
    controller.command(moveNodeByPath, newPath, path, 0);
  });
  return controller;
}
/**
 * 把当前选区wrap一个inline
 * 1. 如果range是collapse，则把对应节点的最近void inline节点进行wrap；
 * 如果没有最近的void inline，则什么都不做
 * 2. 如果选区里有block，会在每个block内部进行wrap inline操作
 */

function wrapInline(controller, inline) {
  const {
    selection
  } = controller.value;
  return controller.command(wrapInlineAtRange, selection, inline);
}
/**
 * 把当前选区wrap一个inline
 * 1. 如果range是collapse，则把对应节点的最近void inline节点进行wrap；
 * 如果没有最近的void inline，则什么都不做
 * 2. 如果选区里有block，会在每个block内部进行wrap inline操作
 */

function wrapInlineAtRange(controller, range, i) {
  const {
    value
  } = controller;
  let {
    document
  } = value;
  const {
    start,
    end
  } = range.convertToTextPoints(document);
  let inline = Inline.create(i);

  if (range.isCollapsed) {
    // Wrapping an inline void
    const inlineParent = document.getClosestInline(start.key);

    if (!inlineParent) {
      return controller;
    }

    if (!controller.query('isVoid', inlineParent)) {
      return controller;
    }

    return controller.command(wrapInlineByKey, inlineParent.key, inline);
  }

  inline = inline.set('nodes', []);
  const blocks = document.getLeafBlocksAtRange(range);
  let startBlock = document.getClosestBlock(start.key);
  let endBlock = document.getClosestBlock(end.key);
  const startInline = document.getClosestInline(start.key);
  const endInline = document.getClosestInline(end.key);
  let startChild = startBlock.getFurthestAncestor(start.key);
  let endChild = endBlock.getFurthestAncestor(end.key);
  controller.withOpContext(wrapInlineTpl(), () => {
    controller.withoutNormalizing(() => {
      if (!startInline || startInline !== endInline) {
        controller.command(splitDescendantsByKey, endChild.key, end.key, end.offset);
        controller.command(splitDescendantsByKey, startChild.key, start.key, start.offset);
      }

      ({
        document
      } = controller.value);
      startBlock = document.getNode(startBlock.key);
      endBlock = document.getNode(endBlock.key);
      startChild = startBlock.getFurthestAncestor(start.key);
      endChild = endBlock.getFurthestAncestor(end.key);
      const startIndex = startBlock.nodes.indexOf(startChild);
      const endIndex = endBlock.nodes.indexOf(endChild);

      if (startInline && startInline === endInline) {
        const text = document.getTextsAtRange(range)[0].splitText(start.offset)[1].splitText(end.offset - start.offset)[0];
        inline = inline.set('nodes', [text]);
        controller.command(insertInlineAtRange, range, inline);
        const inlinekey = text.key;
        const anchor = TextPoint.create({
          key: inlinekey,
          offset: 0
        });
        const focus = TextPoint.create({
          key: inlinekey,
          offset: end.offset - start.offset
        });
        const rng = Selection.create({
          anchor,
          focus
        });
        controller.command(select, rng);
      } else if (startBlock === endBlock) {
        ({
          document
        } = controller.value);
        startBlock = document.getClosestBlock(start.key);
        startChild = startBlock.getFurthestAncestor(start.key);
        const startInner = document.getNextSibling(startChild.key);
        const startInnerIndex = startBlock.nodes.indexOf(startInner);
        const endInner = start.key === end.key ? startInner : startBlock.getFurthestAncestor(end.key);
        let inlines = listUtils.skipUntil(startBlock.nodes, n => n === startInner);
        inlines = listUtils.takeUntil(inlines, n => n === endInner);
        inlines.push(endInner);
        const node = inline.regenerateKey();
        controller.command(insertNodeByKey, startBlock.key, startInnerIndex, node);
        inlines.forEach((child, idx) => {
          controller.command(moveNodeByKey, child.key, node.key, idx);
        });
      } else {
        const startInlines = startBlock.nodes.slice(startIndex + 1);
        const endInlines = endBlock.nodes.slice(0, endIndex + 1);
        const startNode = inline.regenerateKey();
        const endNode = inline.regenerateKey();
        controller.command(insertNodeByKey, startBlock.key, startIndex + 1, startNode);
        controller.command(insertNodeByKey, endBlock.key, endIndex, endNode);
        startInlines.forEach((child, idx) => {
          controller.command(moveNodeByKey, child.key, startNode.key, idx);
        });
        endInlines.forEach((child, idx) => {
          controller.command(moveNodeByKey, child.key, endNode.key, idx);
        });
        blocks.slice(1, -1).forEach(block => {
          const node = inline.regenerateKey();
          controller.command(insertNodeByKey, block.key, 0, node);
          block.nodes.forEach((child, idx) => {
            controller.command(moveNodeByKey, child.key, node.key, idx);
          });
        });
      }
    });
  });
  return controller;
}
/**
 * 把目标节点插入到一个新的inline节点中，并把inline放到原来的节点的位置
 */

function wrapInlineByKey(controller, key, inline) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const path = document.assertPath(key);
  return controller.command(wrapInlineByPath, path, inline);
}
/**
 * 把目标节点插入到一个新的inline节点中，并把inline放到原来的节点的位置
 */

function wrapInlineByPath(controller, path, i) {
  const inline = Inline.create(i).set('nodes', []);
  const parentPath = Path.parent(path);
  const index = path[path.length - 1];
  const newPath = Path.increment(path);
  controller.withoutNormalizing(() => {
    controller.command(insertNodeByPath, parentPath, index, inline);
    controller.command(moveNodeByPath, newPath, path, 0);
  });
  return controller;
}

const unwrapBlockTpl = () => 'cj/cmd/unwrapblock';
const unwrapTpl = () => 'cj/cmd/unwrapnode';

/**
 * @packageDocumentation
 * @module Commands
 */
function unwrapBlock(controller, p) {
  const {
    selection
  } = controller.value;
  const properties = typeof p === 'string' ? {
    type: p
  } : p;
  return controller.command(unwrapBlockAtRange, selection, properties);
}
function unwrapBlockAtRange(controller, range, properties) {
  const {
    value
  } = controller;
  let {
    document
  } = value;
  const blocks = document.getLeafBlocksAtRange(range);
  const wraps = blocks.map(block => {
    return document.getClosest(block.key, parent => {
      if (!Block.isBlock(parent)) {
        return false;
      }

      if (properties.type != null && parent.type !== properties.type) {
        return false;
      }

      if (properties.data != null && !setUtils.isSuperSet(Object.values(parent.data), Object.values(properties.data))) {
        return false;
      }

      return true;
    });
  });
  const wrappers = wraps.filter(exists => {
    return Boolean(exists?.isElement() && exists.isBlock());
  });
  controller.withOpContext(unwrapBlockTpl(), () => {
    controller.withoutNormalizing(() => {
      setUtils.removeDuplicate(wrappers).forEach(block => {
        const first = block.nodes[0];
        const last = block.nodes[block.nodes.length - 1];
        const parent = controller.value.document.getParent(block.key);
        const index = parent.nodes.indexOf(block);
        const children = block.nodes.filter(child => {
          return blocks.some(b => child === b || child.isElement() && child.getNode(b.key));
        });
        const firstMatch = children[0];
        const lastMatch = children[children.length - 1];

        if (first === firstMatch && last === lastMatch) {
          block.nodes.forEach((child, idx) => {
            controller.command(moveNodeByKey, child.key, parent.key, index + idx);
          });
          controller.command(removeNodeByKey, block.key);
        } else if (last === lastMatch) {
          listUtils.skipUntil(block.nodes, n => n === firstMatch).forEach((child, i) => {
            controller.command(moveNodeByKey, child.key, parent.key, index + 1 + i);
          });
        } else if (first === firstMatch) {
          const nodes = listUtils.takeUntil(block.nodes, n => n === lastMatch);
          nodes.push(lastMatch);
          nodes.forEach((child, i) => {
            controller.command(moveNodeByKey, child.key, parent.key, index + i);
          });
        } else {
          const firstText = firstMatch.getFirstText();
          controller.command(splitDescendantsByKey, block.key, firstText.key, 0);
          ({
            document
          } = controller.value);
          children.forEach((child, i) => {
            let newChild = child;

            if (i === 0) {
              const extra = newChild;
              newChild = document.getNextBlock(child.key);
              controller.command(removeNodeByKey, extra.key);
            }

            controller.command(moveNodeByKey, newChild.key, parent.key, index + 1 + i);
          });
        }
      });
    });
  });
  return controller;
}
function unwrapBlockByKey(controller, key, p) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const path = document.assertPath(key);
  const properties = typeof p === 'string' ? {
    type: p
  } : p;
  return controller.command(unwrapBlockByPath, path, properties);
}
function unwrapBlockByPath(controller, path, properties) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const node = document.assertNodeByPath(path);
  const first = node.getFirstText();
  const last = node.getLastText();
  const anchor = TextPoint.create({
    key: first.key,
    offset: 0
  });
  const focus = TextPoint.create({
    key: last.key,
    offset: last.text.length
  });
  const range = Selection.create({
    anchor,
    focus
  });
  return controller.command(unwrapBlockAtRange, range, properties);
}
function unwrapInline(controller, p) {
  const {
    selection
  } = controller.value;
  const properties = typeof p === 'string' ? {
    type: p
  } : p;
  return controller.command(unwrapInlineAtRange, selection, properties);
}
function unwrapInlineAtRange(controller, range, properties) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const texts = document.getTextsAtRange(range);
  const inlines = texts.map(text => document.getClosest(text.key, parent => {
    if (!Inline.isInline(parent)) return false;

    if (properties.type != null && parent.type !== properties.type) {
      return false;
    }

    if (properties.data != null && !setUtils.isSuperSet(Object.values(parent.data), Object.values(properties.data))) {
      return false;
    }

    return true;
  })).filter(exists => exists);
  controller.withoutNormalizing(() => {
    setUtils.removeDuplicate(inlines).forEach(inline => {
      const parent = controller.value.document.getParent(inline.key);
      const index = parent.nodes.indexOf(inline);
      inline.nodes.forEach((child, i) => {
        controller.command(moveNodeByKey, child.key, parent.key, index + i);
      });
      controller.command(removeNodeByKey, inline.key);
    });
  });
  return controller;
}
function unwrapInlineByKey(controller, key, p) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const path = document.assertPath(key);
  const properties = typeof p === 'string' ? {
    type: p
  } : p;
  return controller.command(unwrapInlineByPath, path, properties);
}
function unwrapInlineByPath(controller, path, properties) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const node = document.assertNodeByPath(path);
  const first = node.getFirstText();
  const last = node.getLastText();
  const anchor = TextPoint.create({
    key: first.key,
    offset: 0
  });
  const focus = TextPoint.create({
    key: last.key,
    offset: last.text.length
  });
  const range = Selection.create({
    anchor,
    focus
  });
  return controller.command(unwrapInlineAtRange, range, properties);
}
function unwrapNodeByKey(controller, key) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const path = document.assertPath(key);
  return controller.command(unwrapNodeByPath, path);
}
function unwrapNodeByPath(controller, path) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  document.assertNodeByPath(path);
  const parentPath = Path.parent(path);
  const parent = document.assertNodeByPath(parentPath);
  const index = path[path.length - 1];
  const parentIndex = parentPath[parentPath.length - 1];
  const grandPath = Path.parent(parentPath);
  const isFirst = index === 0;
  const isLast = index === parent.nodes.length - 1;
  controller.withOpContext(unwrapTpl(), () => {
    controller.withoutNormalizing(() => {
      if (parent.nodes.length === 1) {
        controller.command(moveNodeByPath, path, grandPath, parentIndex + 1);
        controller.command(removeNodeByPath, parentPath);
      } else if (isFirst) {
        controller.command(moveNodeByPath, path, grandPath, parentIndex);
      } else if (isLast) {
        controller.command(moveNodeByPath, path, grandPath, parentIndex + 1);
      } else {
        let updatedPath = Path.increment(path, 1, parentPath.length - 1);
        updatedPath = updatedPath.map((p, idx) => idx === updatedPath.length - 1 ? 0 : p);
        controller.command(splitNodeByPath, parentPath, index);
        controller.command(moveNodeByPath, updatedPath, grandPath, parentIndex + 1);
      }
    });
  });
  return controller;
}

/**
 * @packageDocumentation
 * @ignore
 */

var Commands = /*#__PURE__*/Object.freeze({
  __proto__: null,
  deleteAtRange: deleteAtRange,
  del: del,
  deleteBackwardAtRange: deleteBackwardAtRange,
  deleteForwardAtRange: deleteForwardAtRange,
  deleteBackward: deleteBackward,
  deleteForward: deleteForward,
  deleteBoundrayBackward: deleteBoundrayBackward,
  deleteBoundrayForward: deleteBoundrayForward,
  deleteCharBackward: deleteCharBackward,
  deleteCharForward: deleteCharForward,
  deleteWordBackward: deleteWordBackward,
  deleteWordForward: deleteWordForward,
  deleteLineBackward: deleteLineBackward,
  deleteLineForward: deleteLineForward,
  insertNodeByKey: insertNodeByKey,
  insertNodeByPath: insertNodeByPath,
  insertText: insertText$1,
  insertEmptyBlock: insertEmptyBlock,
  insertTextAtRange: insertTextAtRange,
  insertTextByKey: insertTextByKey,
  insertTextByPath: insertTextByPath,
  insertBlockAtRange: insertBlockAtRange,
  insertBlock: insertBlock,
  insertInlineAtRange: insertInlineAtRange,
  insertInline: insertInline,
  insertFragmentByKey: insertFragmentByKey,
  insertFragmentByPath: insertFragmentByPath,
  insertFragment: insertFragment,
  insertFragmentAtRange: insertFragmentAtRange,
  insertFragmentWithRealKeyAtRange: insertFragmentWithRealKeyAtRange,
  mergeNodeByKey: mergeNodeByKey,
  mergeNodeByPath: mergeNodeByPath,
  moveNodeByKey: moveNodeByKey,
  moveNodeByPath: moveNodeByPath,
  focus: focus,
  blur: blur,
  select: select,
  userSelect: userSelect,
  selectWordAtPoint: selectWordAtPoint,
  moveAnchorBackward: moveAnchorBackward,
  moveAnchorForward: moveAnchorForward,
  moveAnchorTo: moveAnchorTo,
  moveAnchorToKey: moveAnchorToKey,
  moveAnchorToStartOfBlock: moveAnchorToStartOfBlock,
  moveAnchorToStartOfPreviousBlock: moveAnchorToStartOfPreviousBlock,
  moveAnchorToEndOfNextBlock: moveAnchorToEndOfNextBlock,
  moveFocusTo: moveFocusTo,
  moveFocusToKey: moveFocusToKey,
  moveTo: moveTo,
  moveToKey: moveToKey,
  moveFocusBackward: moveFocusBackward,
  moveFocusForward: moveFocusForward,
  moveFocusWordBackward: moveFocusWordBackward,
  moveFocusWordForward: moveFocusWordForward,
  moveFocusToEndOfText: moveFocusToEndOfText,
  moveFocusToStartOfBlock: moveFocusToStartOfBlock,
  moveFocusToEndOfBlock: moveFocusToEndOfBlock,
  moveFocusToStartOfDocument: moveFocusToStartOfDocument,
  moveFocusToEndOfDocument: moveFocusToEndOfDocument,
  moveStartBackward: moveStartBackward,
  moveStartForward: moveStartForward,
  moveEndBackward: moveEndBackward,
  moveEndForward: moveEndForward,
  moveBackward: moveBackward,
  moveForward: moveForward,
  moveToEndOfPreviousBlock: moveToEndOfPreviousBlock,
  moveToEndOfNextBlock: moveToEndOfNextBlock,
  moveToEndOfInline: moveToEndOfInline,
  moveToAnchor: moveToAnchor,
  moveToFocus: moveToFocus,
  moveToRangeOfDocument: moveToRangeOfDocument,
  moveToRangeOfNode: moveToRangeOfNode,
  moveToStart: moveToStart,
  moveToEnd: moveToEnd,
  moveToEndOfDocument: moveToEndOfDocument,
  moveToStartOfInline: moveToStartOfInline,
  moveToStartOfBlock: moveToStartOfBlock,
  moveToEndOfBlock: moveToEndOfBlock,
  moveToEndOfNode: moveToEndOfNode,
  moveStartToStartOfInline: moveStartToStartOfInline,
  moveStartToStartOfBlock: moveStartToStartOfBlock,
  moveStartToStartOfPreviousBlock: moveStartToStartOfPreviousBlock,
  moveEndToEndOfBlock: moveEndToEndOfBlock,
  moveToStartOfDocument: moveToStartOfDocument,
  moveStartToEndOfNode: moveStartToEndOfNode,
  moveAnchorToStartOfNode: moveAnchorToStartOfNode,
  moveAnchorToEndOfNode: moveAnchorToEndOfNode,
  moveFocusToStartOfNode: moveFocusToStartOfNode,
  moveFocusToEndOfNode: moveFocusToEndOfNode,
  moveToEndOfPreviousText: moveToEndOfPreviousText,
  moveToStartOfNextText: moveToStartOfNextText,
  moveToStartOfPreviousBlock: moveToStartOfPreviousBlock,
  moveToStartOfNextBlock: moveToStartOfNextBlock,
  moveToStartOfNode: moveToStartOfNode,
  moveStartToStartOfNode: moveStartToStartOfNode,
  moveEndToStartOfNode: moveEndToStartOfNode,
  moveEndToEndOfNode: moveEndToEndOfNode,
  moveStartToEndOfPreviousText: moveStartToEndOfPreviousText,
  moveStartToEndOfPreviousBlock: moveStartToEndOfPreviousBlock,
  moveEndToEndOfInline: moveEndToEndOfInline,
  moveEndToStartOfNextText: moveEndToStartOfNextText,
  moveEndToStartOfNextBlock: moveEndToStartOfNextBlock,
  moveEndToEndOfNextBlock: moveEndToEndOfNextBlock,
  moveWordBackward: moveWordBackward,
  moveWordForward: moveWordForward,
  addMark: addMark,
  addMarkAtRange: addMarkAtRange,
  addMarkByKey: addMarkByKey,
  addMarkByPath: addMarkByPath,
  addMarks: addMarks,
  addMarksAtRange: addMarksAtRange,
  toggleMark: toggleMark,
  toggleMarkAtRange: toggleMarkAtRange,
  removeMark: removeMark,
  removeMarkAtRange: removeMarkAtRange,
  removeMarkByKey: removeMarkByKey,
  removeMarkByPath: removeMarkByPath,
  replaceMark: replaceMark,
  splitDescendantsByKey: splitDescendantsByKey,
  splitDescendantsByPath: splitDescendantsByPath,
  splitNodeByKey: splitNodeByKey,
  splitNodeByPath: splitNodeByPath,
  splitBlock: splitBlock,
  splitBlockAtRange: splitBlockAtRange,
  splitInline: splitInline,
  removeNodeByKey: removeNodeByKey,
  removeNodeByPath: removeNodeByPath,
  removeTextByKey: removeTextByKey,
  removeTextByPath: removeTextByPath,
  replaceNodeByKey: replaceNodeByKey,
  replaceNodeByPath: replaceNodeByPath,
  replaceTextByKey: replaceTextByKey,
  replaceTextByPath: replaceTextByPath,
  setNodeByKey: setNodeByKey,
  setNodeByPath: setNodeByPath,
  setBlocks: setBlocks,
  setBlocksAtRange: setBlocksAtRange,
  setInlines: setInlines,
  setInlinesAtRange: setInlinesAtRange,
  setMarkByKey: setMarkByKey,
  setMarkByPath: setMarkByPath,
  setTextByKey: setTextByKey,
  setTextByPath: setTextByPath,
  wrapText: wrapText,
  wrapTextAtRange: wrapTextAtRange,
  wrapBlock: wrapBlock,
  wrapBlockAtRange: wrapBlockAtRange,
  wrapBlockByKey: wrapBlockByKey,
  wrapBlockByPath: wrapBlockByPath,
  wrapInline: wrapInline,
  wrapInlineAtRange: wrapInlineAtRange,
  wrapInlineByKey: wrapInlineByKey,
  wrapInlineByPath: wrapInlineByPath,
  unwrapBlock: unwrapBlock,
  unwrapBlockAtRange: unwrapBlockAtRange,
  unwrapBlockByKey: unwrapBlockByKey,
  unwrapBlockByPath: unwrapBlockByPath,
  unwrapInline: unwrapInline,
  unwrapInlineAtRange: unwrapInlineAtRange,
  unwrapInlineByKey: unwrapInlineByKey,
  unwrapInlineByPath: unwrapInlineByPath,
  unwrapNodeByKey: unwrapNodeByKey,
  unwrapNodeByPath: unwrapNodeByPath
});

const DATA_CLIPBORAD_CANGJIE = 'data-clipboard-cangjie';
const SLASH_PLACEHOLDER = '__slash__';

function isFileMimeType(mime_type) {
  return /^(image)|(audio)|(video)\//.test(mime_type);
}
/**
 * @description 从 html 中读取自定义数据
 */

function readClipboardDataFromHtml(html) {
  const domparser = new DOMParser();
  const root = domparser.parseFromString(html, 'text/html');
  const clipboardDataNode = root.querySelector(`[${DATA_CLIPBORAD_CANGJIE}]`);
  const clipboardData = [];

  if (clipboardDataNode && root.body.firstElementChild === clipboardDataNode) {
    Object.values(clipboardDataNode.attributes).forEach(item => {
      if (item.nodeName.startsWith('data-identifier-') && item.textContent) {
        const mimeType = item.nodeName.slice('data-identifier-'.length).replace(new RegExp(SLASH_PLACEHOLDER, 'gm'), '/');
        clipboardData.push([mimeType, item.textContent]);
      }
    });
  }

  return clipboardData;
}
/**
 * @description 获取剪切板权限并读取内容
 */

async function getClipboardData() {
  try {
    const dataTransfer = CangjieDataTransfer.create(); // 作为 any 类型处理，防止构建报错: Property 'read' does not exist on type 'Clipboard'.

    const nav = window.navigator;

    if (!nav?.clipboard?.read) {
      return Promise.reject(new Error('Your browser does not support navigator.clipboard.read method.'));
    }

    const clipboardItems = await nav.clipboard.read();

    for (const clipboardItem of clipboardItems) {
      for (const type of clipboardItem.types) {
        const blob = await clipboardItem.getType(type);

        if (isFileMimeType(type)) {
          const file = new window.File([blob], '', {
            type
          });
          dataTransfer.setData(type, file);
        } else {
          const text = await blob.text();
          dataTransfer.setData(type, text);

          if (type === 'text/html') {
            const customData = readClipboardDataFromHtml(text);
            customData.forEach(([type, data]) => {
              dataTransfer.setData(type, data);
            });
          }
        }
      }
    }

    return Promise.resolve(dataTransfer);
  } catch (err) {
    return Promise.reject(err);
  }
}

class CustomDataTransfer {
  constructor() {
    this.data = void 0;
    this.dropEffect = void 0;
    this.effectAllowed = void 0;
    this.files = void 0;
    this.img = void 0;
    this.items = void 0;
    this.types = void 0;
    this.xOffset = void 0;
    this.yOffset = void 0;
    this.data = {
      dragX: '',
      dragY: ''
    };
    this.dropEffect = 'none';
    this.effectAllowed = 'all';
    this.files = [];
    this.img = '';
    this.items = [];
    this.types = [];
    this.xOffset = 0;
    this.yOffset = 0;
  }

  clearData() {
    this.data = {};
    this.items = [];
    this.types = [];
  }

  getData(format) {
    return this.data[format];
  }

  setData(format, data) {
    const toAdd = {
      kind: 'string',
      type: format
    };

    if (!this.items.some(i => {
      i.kind === toAdd.kind && i.type === toAdd.type;
    })) {
      this.items.push(toAdd);
    }

    if (isFileMimeType(format) && data instanceof Blob) {
      this.data[format] = '';

      if (!this.types.includes('Files')) {
        this.types.push('Files');
      }

      this.files.push(data);
    } else {
      this.data[format] = data;

      if (!this.types.includes(format)) {
        this.types.push(format);
      }
    }
  }

  setDragImage(img, xOffset, yOffset) {
    this.img = img;
    this.xOffset = xOffset;
    this.yOffset = yOffset;
  }

}

class CangjieDataTransfer extends CustomDataTransfer {
  static create(clipboardData) {
    return new CangjieDataTransfer(clipboardData);
  }

  constructor(clipboardData) {
    super();

    if (!clipboardData) {
      return this;
    } // 仅复制剪切板里基础类型数据，防止文件过大导致内存溢出，需要消费 File、Img 类型数据直接从 nativeEvent 上获取


    for (const type of Object.values(MIME_TYPES)) {
      if (!clipboardData.types.includes(type)) {
        continue;
      }

      const data = clipboardData.getData(type);
      super.setData(type, data);
    }

    return this;
  }

  setData(type, data) {
    super.setData(type, data);
    return Object.create(this, {
      clearData: {
        value() {
          Object.getPrototypeOf(this).clearData();
        }

      },
      getData: {
        value(t) {
          return Object.getPrototypeOf(this).getData(t);
        }

      }
    });
  }

}

/**
 * @packageDocumentation
 * @module Events
 */

/**
 * 剪切板事件
 */
function CangjieClipboardEvent(type, {
  nativeEvent,
  clipboardData
} = {}) {
  const event = new CustomEvent(type);
  /**
   * https://bugs.webkit.org/show_bug.cgi?id=49739
   * webkit bug, safari 10 及以下会报 ERROR: Attempted to assign to readonly property.
   */

  if (clipboardData) {
    // @ts-ignore
    event.clipboardData = CangjieDataTransfer.create(clipboardData);
  } // @ts-ignore


  return Object.assign(event, {
    nativeEvent,

    setClipboardData(clipboardData) {
      // @ts-ignore
      event.clipboardData = clipboardData;
      return Object.create(this, {
        clipboardData: {
          value: clipboardData
        }
      });
    }

  });
}

/**
 * @packageDocumentation
 * @module Events
 */
function CangjieSelectEvent(detail) {
  return new CustomEvent('cangjieSelect', {
    detail
  });
}

/**
 * @packageDocumentation
 * @ignore
 */
const defaultLocale = {
  copy: '复制',
  cut: '剪切',
  select: '选择',
  selectAll: '全选',
  paste: '粘贴',
  pasteTips: '请用快捷键'
};

/**
 * @packageDocumentation
 * @module transferUtils
 */

function getTransferType(data) {
  if (data.fragment) {
    return 'fragment';
  }

  if (data.files && data.files.length) {
    return 'files';
  }

  if (data.html) {
    return 'html';
  }

  if (data.text) {
    return 'text';
  }

  return 'unknown';
}

function getEventTransfer(event, controller) {
  const clipboardData = 'dataTransfer' in event ? event.dataTransfer : event.clipboardData;

  if (!clipboardData) {
    return {
      files: [],
      fragment: null,
      html: '',
      text: ''
    };
  }

  const html = clipboardData.getData(MIME_TYPES.HTML);
  const text = clipboardData.getData(MIME_TYPES.TEXT) || '';
  const encodedFragment = clipboardData.getData(MIME_TYPES.FRAGMENT);
  let fragment = null;

  if (encodedFragment) {
    try {
      fragment = decodeFragment(encodedFragment);
    } catch (e) {// do nothing
    }
  }

  if (!fragment && html && ~html.indexOf(` data-${controller.biz}-fragment="`)) {
    const FRAGMENT_MATCHER = new RegExp(` data-${controller.biz}-fragment="([^\\s"]+)"`);
    const matches = FRAGMENT_MATCHER.exec(html); // eslint-disable-next-line @typescript-eslint/no-unused-vars

    const [_, encoded] = matches || [];

    if (encoded) {
      fragment = decodeFragment(encoded);
    }
  }

  let files = [];

  try {
    if (clipboardData.items && clipboardData.items.length) {
      files = Array.from(clipboardData.items).reduce((fs, item) => {
        if (item.kind === 'file') {
          const file = item.getAsFile();

          if (file) {
            return [...fs, file];
          }
        }

        return fs;
      }, []);
    } else if (clipboardData.files && clipboardData.files.length) {
      files = Array.from(clipboardData.files);
    }
  } catch (err) {
    if (clipboardData.files && clipboardData.files.length) {
      files = Array.from(clipboardData.files);
    }
  }

  const data = {
    files,
    fragment,
    html,
    text
  };
  return { ...data,
    type: getTransferType(data)
  };
}
/**
 * 编码 fragment
 * @param fragment
 */

function encodeFragment(fragment) {
  const string = JSON.stringify(fragment.toJSON());
  const encoded = window.btoa(encodeURIComponent(string));
  return encoded;
}
/**
 * 解码 fragment
 * @param text
 */

function decodeFragment(text) {
  const decoded = decodeURIComponent(window.atob(text));
  const json = JSON.parse(decoded);
  const fragment = Document.fromJSON(json);
  return fragment;
}
let clip;

const createClip = () => {
  if (clip) return clip;
  const target = document.createElement('div');
  target.setAttribute('style', '-webkit-user-select: text !important');
  clip = new ClipboardManager__default["default"]({
    target
  });
  return clip;
};
/**
 * 数据写入系统剪切板
 * @param event
 * @param data
 * @param callback
 */


function setClipboardData(event, data, callback) {
  const isFileData = Object.keys(data).some(type => type.startsWith('image'));

  if (event.nativeEvent?.clipboardData) {
    const dataEntries = Object.entries(data);
    dataEntries.forEach(item => {
      const [mimeType, content] = item;

      if (!isFileMimeType(mimeType)) {
        event.nativeEvent?.clipboardData?.setData(mimeType, content);
      }
    });

    if (isFileData) {
      const clipManager = createClip();
      clipManager.writeFile(data, {
        succeeded: true,
        action: 'copy',
        text: ''
      }).finally(() => {
        if (callback) {
          callback();
        }
      });
    } else if (callback) {
      callback();
    }
  } else {
    const clipManager = createClip();
    clipManager.write(data, false);
    window.requestAnimationFrame(() => {
      if (callback) {
        callback();
      }
    });
  }
}

function copyFragment(event, callback) {
  const encodedFragment = event.clipboardData?.getData(MIME_TYPES.FRAGMENT);
  const text = event.clipboardData?.getData(MIME_TYPES.TEXT) || encodedFragment && decodeFragment(encodedFragment).text || '';
  const html = event.clipboardData?.getData(MIME_TYPES.HTML) || text;
  const data = {
    [MIME_TYPES.FRAGMENT]: encodedFragment,
    [MIME_TYPES.HTML]: html,
    [MIME_TYPES.TEXT]: text
  };
  const imageTypes = event.clipboardData?.types.filter(type => type.startsWith('image'));
  imageTypes?.forEach(type => {
    const imgData = event.clipboardData?.getData(type);

    if (imgData) {
      data[type] = imgData;
    }
  });
  setClipboardData(event, data, callback);
}

var transfer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getEventTransfer: getEventTransfer,
  encodeFragment: encodeFragment,
  decodeFragment: decodeFragment,
  copyFragment: copyFragment
});

function isEmptyObj(value) {
  if (lodash.isPlainObject(value) || lodash.isArray(value)) {
    return lodash.isEmpty(value);
  }

  return false;
}
function omitEmptyObj(obj) {
  return lodash.omitBy(obj, isEmptyObj);
}
function omitDeepBy(obj, predicate) {
  let nextObj = obj;
  lodash.forOwn(obj, (value, key) => {
    if (lodash.isObject(value)) {
      nextObj = { ...nextObj,
        [key]: omitDeepBy(value, predicate)
      };
    }
  });
  return lodash.omitBy(nextObj, predicate);
}

function createClipboardDataFromSelection(controller) {
  const {
    value,
    uid
  } = controller;
  const {
    document,
    selection
  } = value;
  let fragment = document.getFragmentAtRange(selection);
  fragment = withUserData(fragment, document.data?.userData, uid);
  const dataTransfer = CangjieDataTransfer.create();
  const text = fragment.nodes.reduce((acc, node) => {
    return `${acc}\n${node.text}`;
  }, '').slice(1);
  return dataTransfer.setData(MIME_TYPES.FRAGMENT, encodeFragment(fragment)).setData(MIME_TYPES.TEXT, text);
}
/**
 * 将节点的用户数据复制到 fragment 中
 * @param fragment 
 * @param userData 
 * @param uid 
 * @returns 
 */

function withUserData(fragment, userData, uid) {
  const originData = uid && userData?.[uid];

  if (originData) {
    const nextData = {}; // 遍历 fragment 子节点，取出所有子节点的用户数据

    fragment.forEachDescendant(node => {
      const uuid = Element$1.isElement(node) ? node.data?.uuid : null;

      if (uuid && originData?.[uuid]) {
        nextData[uuid] = originData?.[uuid];
      }
    }); // 用户数据复制到 fragment 中

    if (Object.keys(nextData).length > 0) {
      return fragment.set('data', omitDeepBy({ ...fragment.data,
        userData: {
          [uid]: nextData
        }
      }, isEmptyObj));
    }
  }

  return fragment;
}

const _createElement$q = React__default["default"].createElement;

var _ref$2 = /*#__PURE__*/_createElement$q("svg", {
  className: "icon",
  width: "24px",
  height: "24px",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg"
}, /*#__PURE__*/_createElement$q("path", {
  fill: "#ffffff",
  d: "M192 160a10.666667 10.666667 0 0 0-10.666667 10.666667v554.666666c0 5.888 4.778667 10.666667 10.666667 10.666667h42.666667v64h-42.666667A74.666667 74.666667 0 0 1 117.333333 725.333333V170.666667c0-41.216 33.450667-74.666667 74.666667-74.666667h469.333333c41.216 0 74.666667 33.450667 74.666667 74.666667v42.666666h-64V170.666667a10.666667 10.666667 0 0 0-10.666667-10.666667h-469.333333zM288 341.333333c0-41.216 33.450667-74.666667 74.666667-74.666666h469.333333c41.216 0 74.666667 33.450667 74.666667 74.666666v512a74.666667 74.666667 0 0 1-74.666667 74.666667h-469.333333A74.666667 74.666667 0 0 1 288 853.333333V341.333333z m74.666667-10.666666a10.666667 10.666667 0 0 0-10.666667 10.666666v512c0 5.888 4.778667 10.666667 10.666667 10.666667h469.333333a10.666667 10.666667 0 0 0 10.666667-10.666667V341.333333a10.666667 10.666667 0 0 0-10.666667-10.666666h-469.333333z"
}));

function Copy() {
  return _ref$2;
}

var _ref2 = /*#__PURE__*/_createElement$q("svg", {
  className: "icon",
  width: "24px",
  height: "24px",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg"
}, /*#__PURE__*/_createElement$q("path", {
  fill: "#ffffff",
  d: "M553.301333 484.48l259.712-318.378667-49.578666-40.448L384.426667 590.250667a160 160 0 1 0 46.208 44.586666L512 535.04l81.365333 99.754667a160 160 0 1 0 46.208-44.586667l-86.272-105.813333zM298.666667 629.333333c18.901333 0 36.565333 5.461333 51.413333 14.933334l17.621333 14.336A96 96 0 1 1 298.666667 629.333333zM210.986667 166.101333l182.058666 223.189334 41.216-50.773334-173.653333-212.906666-49.621333 40.490666zM673.92 644.266667a96 96 0 1 1-17.578667 14.336l17.578667-14.336z"
}));

function Cut() {
  return _ref2;
}

var _ref3 = /*#__PURE__*/_createElement$q("svg", {
  className: "icon",
  width: "24px",
  height: "24px",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg"
}, /*#__PURE__*/_createElement$q("path", {
  fill: "#ffffff",
  d: "M352 106.666667A32 32 0 0 1 384 74.666667h170.666667a32 32 0 0 1 32 32v32H640a32 32 0 0 1 32 32v10.666666H725.333333c41.216 0 74.666667 33.450667 74.666667 74.666667v85.333333h-64V256a10.666667 10.666667 0 0 0-10.666667-10.666667h-53.333333V298.666667a32 32 0 0 1-32 32H298.666667A32 32 0 0 1 266.666667 298.666667V245.333333H213.333333a10.666667 10.666667 0 0 0-10.666666 10.666667v554.666667c0 5.888 4.778667 10.666667 10.666666 10.666666h213.333334v64H213.333333A74.666667 74.666667 0 0 1 138.666667 810.666667V256c0-41.216 33.450667-74.666667 74.666666-74.666667h53.333334V170.666667A32 32 0 0 1 298.666667 138.666667h53.333333V106.666667z m64 32V170.666667a32 32 0 0 1-32 32H330.666667v64h277.333333v-64H554.666667a32 32 0 0 1-32-32v-32h-106.666667z m106.666667 352c0-41.216 33.450667-74.666667 74.666666-74.666667h256c41.216 0 74.666667 33.450667 74.666667 74.666667v341.333333A74.666667 74.666667 0 0 1 853.333333 906.666667h-256a74.666667 74.666667 0 0 1-74.666666-74.666667v-341.333333z m74.666666-10.666667a10.666667 10.666667 0 0 0-10.666666 10.666667v341.333333c0 5.888 4.778667 10.666667 10.666666 10.666667h256a10.666667 10.666667 0 0 0 10.666667-10.666667v-341.333333a10.666667 10.666667 0 0 0-10.666667-10.666667h-256z"
}));

function Paste() {
  return _ref3;
}

var _ref4 = /*#__PURE__*/_createElement$q("svg", {
  className: "icon",
  width: "24px",
  height: "24px",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg"
}, /*#__PURE__*/_createElement$q("path", {
  fill: "#ffffff",
  d: "M237.525333 187.178667a32 32 0 0 1 33.706667-1.962667l597.333333 324.266667a32 32 0 0 1-11.904 59.946666l-308.181333 32.426667-162.56 276.224a32 32 0 0 1-59.221333-11.221333L224.426667 218.325333a32 32 0 0 1 13.141333-31.146666z m60.16 85.205333l78.336 496.341333 125.44-213.205333a32 32 0 0 1 24.277334-15.616l221.781333-23.338667L297.728 272.384z"
}));

function Select() {
  return _ref4;
}

var _ref5 = /*#__PURE__*/_createElement$q("svg", {
  className: "icon",
  width: "24px",
  height: "24.00px",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg"
}, /*#__PURE__*/_createElement$q("path", {
  fill: "#ffffff",
  d: "M142.037333 154.965333l9.130667-3.797333 3.84-9.130667 9.130667 3.754667 7.424-3.072c6.357333-2.602667 13.226667-4.053333 20.437333-4.053333h85.333333v64H202.666667V277.333333h-64v-85.333333c0-7.168 1.450667-14.08 4.053333-20.437333l3.072-7.424-3.754667-9.173334zM352 138.666667H320v64h170.666667v-64H352z m213.333333 0h-32v64h170.666667v-64h-138.666667z m213.333334 0h-32v64h74.666666V277.333333h64v-85.333333c0-7.168-1.450667-14.08-4.053333-20.437333l-3.114667-7.424 3.84-9.173334-9.173333-3.797333-3.84-9.130667-9.130667 3.754667-7.424-3.072a53.248 53.248 0 0 0-20.437333-4.053333h-53.333333z m-576 213.333333V320h-64v170.666667h64V352z m682.666666 0V320h-64v170.666667h64V352z m-682.666666 213.333333v138.666667h-64v-170.666667h64v32z m682.666666 0v-32h-64v170.666667h64v-138.666667z m-682.666666 213.333334v-32h-64v85.333333c0 7.168 1.450667 14.08 4.053333 20.437333l3.072 7.424-3.754667 9.173334 9.130667 3.797333 3.84 9.173333 9.130667-3.84 7.424 3.114667c6.357333 2.602667 13.226667 4.053333 20.437333 4.053333h85.333333v-64H202.666667v-42.666666z m682.666666 0v-32h-64v74.666666H746.666667v64h85.333333c7.168 0 14.08-1.450667 20.437333-4.053333l7.424-3.114667 9.173334 3.84 3.797333-9.173333 9.173333-3.84-3.84-9.130667 3.114667-7.424a53.333333 53.333333 0 0 0 4.053333-20.437333v-53.333333z m-533.333333 42.666666H320v64h170.666667v-64H352z m213.333333 0h-32v64h170.666667v-64h-138.666667zM392.533333 580.181333L483.413333 298.666667h67.2l90.837334 281.514666 51.2 145.152h-67.84l-36.352-102.912h-142.933334L409.173333 725.333333H341.333333l51.2-145.152z m124.458667-177.28l-50.176 155.52h100.352l-50.176-155.52z"
}));

function SelectAll() {
  return _ref5;
}

/**
 * @packageDocumentation
 * @ignore
 */
const ACTION_COPY = Symbol('ACTION_COPY');
const ACTION_COPY_FAIL = Symbol('ACTION_COPY_FAIL');
const ACTION_CUT = Symbol('ACTION_CUT');
const ACTION_CUT_FAIL = Symbol('ACTION_CUT_FAIL');
const ACTION_PASTE = Symbol('ACTION_PASTE');
const ACTION_PASTE_FAIL = Symbol('ACTION_PASTE_FAIL');
const ACTION_SELECT = Symbol('ACTION_SELECT');
const ACTION_SELECT_ALL = Symbol('ACTION_SELECT_ALL');

function execCommandPolyfill(command) {
  const maybeHiddenTextArea = window.document.activeElement;
  let hiddenTextAreaOriginValue = '';
  let hiddenTextAreaOriginStart = 0;
  let hiddenTextAreaOriginEnd = 0;

  if (maybeHiddenTextArea instanceof HTMLTextAreaElement) {
    hiddenTextAreaOriginValue = maybeHiddenTextArea.value;
    hiddenTextAreaOriginStart = maybeHiddenTextArea.selectionStart;
    hiddenTextAreaOriginEnd = maybeHiddenTextArea.selectionEnd; // NOTE: `execCommand` will not trigger onCopy & onCut on Safari if selection is collapsed.

    maybeHiddenTextArea.value = ' ';
    maybeHiddenTextArea.selectionStart = 0;
    maybeHiddenTextArea.selectionEnd = maybeHiddenTextArea.value.length;
  }

  window.document.execCommand(command);

  if (maybeHiddenTextArea instanceof HTMLTextAreaElement) {
    maybeHiddenTextArea.value = hiddenTextAreaOriginValue;
    maybeHiddenTextArea.selectionStart = hiddenTextAreaOriginStart;
    maybeHiddenTextArea.selectionEnd = hiddenTextAreaOriginEnd;
  }
}

function execCommand(command, controller) {
  if (controller.value.isBlurred) {
    // 手动调用 flush, 触发 仓颉 HiddenTextarea 聚焦
    controller.command(focus).flush();
    requestAnimationFrame(() => {
      execCommandPolyfill(command);
    });
  } else {
    execCommandPolyfill(command);
  }
}

const pasteMenu = locale => {
  return {
    name: locale.paste,
    action: {
      type: ACTION_PASTE
    },
    key: 'paste',
    role: 'paste',
    icon: Paste,
    options: {
      hotKey: 'mod+v',
      mobile: true
    }
  };
}; // [defaultLocale] is the same as [configs.plugins.contextMenu]


function contextMenu(configs) {
  const locale = configs?.plugins?.contextMenu || defaultLocale;
  return function (controller, next) {
    const menus = [];
    const {
      readOnly,
      canCopy
    } = controller;
    const {
      selection,
      document
    } = controller.value;
    const isReadMode = Boolean(readOnly || controller.query('isQuickPreview'));
    const hasVoidParent = selection?.isCollapsed && document.hasVoidParent(selection.anchor.key, controller);

    if (hasVoidParent) ; else if (selection?.isExpanded) {
      const items = [{
        name: locale.cut,
        action: {
          type: ACTION_CUT
        },
        key: 'cut',
        role: 'cut',
        icon: Cut,
        options: {
          hotKey: 'mod+x',
          mobile: true,
          disable: isReadMode
        }
      }, {
        name: locale.copy,
        action: {
          type: ACTION_COPY
        },
        key: 'copy',
        role: 'copy',
        icon: Copy,
        options: {
          disable: isReadMode && !canCopy,
          hotKey: 'mod+c',
          mobile: true
        }
      }];

      if (!isReadMode) {
        items.push(pasteMenu(locale));
      }

      menus.push(...items);
    } else if (selection?.isCollapsed && !selection.data.isByTable) {
      menus.push({
        name: locale.select,
        action: {
          type: ACTION_SELECT
        },
        key: 'select',
        icon: Select,
        options: {
          mobile: true,
          group: 10
        }
      }, {
        name: locale.selectAll,
        action: {
          type: ACTION_SELECT_ALL
        },
        key: 'select-all',
        icon: SelectAll,
        options: {
          hotKey: 'mod+a',
          mobile: true,
          group: 10
        }
      });
      menus.push({
        name: locale.cut,
        action: {
          type: ACTION_CUT
        },
        key: 'cut',
        role: 'cut',
        options: {
          hotKey: 'mod+x',
          disable: true
        }
      }, {
        name: locale.copy,
        action: {
          type: ACTION_COPY
        },
        key: 'copy',
        role: 'copy',
        options: {
          hotKey: 'mod+c',
          disable: true
        }
      });

      if (!isReadMode) {
        menus.push(pasteMenu(locale));
      }
    }

    const others = next() || [];
    return [...menus, ...others];
  };
}

function handleAction(action, controller, next) {
  const {
    type
  } = action;

  if (type === ACTION_COPY) {
    if (IS_MOBILE) {
      // 移动端 document.activeElement 非 hiddenTextarea, 无法通过 execCommand 触发 copy 事件
      const event = CangjieClipboardEvent('cangjieCopy');

      try {
        controller.run('onCangjieCopy', event.setClipboardData(createClipboardDataFromSelection(controller)));
      } catch (error) {
        controller.run('onAction', {
          type: ACTION_COPY_FAIL,
          payload: {
            error
          }
        });
        throw error;
      }
    } else {
      execCommand('copy', controller);
    }
  } else if (type === ACTION_CUT) {
    if (IS_MOBILE) {
      const event = CangjieClipboardEvent('cangjieCut');

      try {
        controller.run('onCangjieCut', event.setClipboardData(createClipboardDataFromSelection(controller)));
      } catch (error) {
        controller.run('onAction', {
          type: ACTION_CUT_FAIL,
          payload: {
            error
          }
        });
        throw error;
      }
    } else {
      execCommand('cut', controller);
    }
  } else if (type === ACTION_PASTE) {
    const event = CangjieClipboardEvent('cangjiePaste');

    if (IS_MOBILE) {
      const customEvent = event.setClipboardData(CangjieDataTransfer.create());
      const html = event.clipboardData?.getData('text/html');

      if (html) {
        const customData = readClipboardDataFromHtml(html);
        customData.forEach(([dataType, data]) => {
          customEvent.clipboardData?.setData(dataType, data);
        });
      }

      try {
        controller.run('onCangjiePaste', customEvent);
      } catch (error) {
        controller.run('onAction', {
          type: ACTION_PASTE_FAIL,
          payload: {
            isShortcut: false,
            error
          }
        });
        throw error;
      }
    } else {
      const isPasteEnable = window.document.execCommand('paste');

      if (!isPasteEnable) {
        getClipboardData().then(clipboardData => {
          controller.run('onCangjiePaste', event.setClipboardData(clipboardData));
        }, error => {
          controller.run('onAction', {
            type: ACTION_PASTE_FAIL,
            payload: {
              isShortcut: false,
              error
            }
          });
          console.error(error);
        });
      }
    }
  } else if (type === ACTION_SELECT) {
    // Select
    const {
      selection
    } = controller.value;
    selection && controller.command(selectWordAtPoint, selection.anchor);
  } else if (type === ACTION_SELECT_ALL) {
    // Select All
    const {
      document,
      selection
    } = controller.value;
    selection && controller.run('onCangjieSelect', CangjieSelectEvent({
      selection: selection.moveToRangeOfNode(document, controller)
    }));
  }

  return next();
}

var createContextMenuPlugin = (configs => ({
  contextMenu: contextMenu(configs),
  onAction: handleAction,
  models: []
}));

var contextMenu$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ACTION_COPY: ACTION_COPY,
  ACTION_COPY_FAIL: ACTION_COPY_FAIL,
  ACTION_CUT: ACTION_CUT,
  ACTION_CUT_FAIL: ACTION_CUT_FAIL,
  ACTION_PASTE: ACTION_PASTE,
  ACTION_PASTE_FAIL: ACTION_PASTE_FAIL,
  ACTION_SELECT: ACTION_SELECT,
  ACTION_SELECT_ALL: ACTION_SELECT_ALL,
  'default': createContextMenuPlugin
});

/**
 * @packageDocumentation
 * @ignore
 */
function useScroll({
  onStart,
  onEnd
}) {
  React__namespace.useEffect(() => {
    let timeout = null;
    let isStarted = false;

    const handleScrollEvent = () => {
      timeout && clearTimeout(timeout);
      onStart();
      isStarted = true;
      timeout = window.setTimeout(() => {
        onEnd();
        isStarted = false;
      }, 300);
    };

    window.addEventListener('scroll', handleScrollEvent, true);
    return () => {
      if (isStarted) {
        onEnd();
        isStarted = false;
      }

      timeout && clearTimeout(timeout);
      window.removeEventListener('scroll', handleScrollEvent, true);
    };
  });
}

/**
 * @packageDocumentation
 * @module domUtils
 */

function isAfterNewLine(leaf, offset) {
  return leaf.firstChild?.textContent && leaf.firstChild.textContent[offset - 1] === '\n';
}
/**
 *
 * Caret Hanging Optimization
 *
 * By default, the [caret] is inserted **after the charactor**:
 *
 *   [charactor][caret][may-be-a-line-break][next charactor].
 *
 * For multi-lines paragraph, the start of the non-first line cannot be focused
 * by this behaviour. Then we optimize the caret insert position to **before
 * the last characotr** if the user is clicking/touching the very left side:
 *
 *   [charactor][may-be-a-line-break][caret][next charactor]
 *
 */
// If the caret can hanging, return the position; otheriwse return null


function findHangingPosition(node, offset, originLength) {
  /**
   * Detect is it can hanging.
   *
   * we get the rects of the newRange, whose offset is [originOffset + 1]
   * if the newRange have one more rect than the old one, then we know that
   * there is a line break between [offset, offset + 1]
   */
  const detectRange = window.document.createRange();

  try {
    detectRange.setStart(node, 0);
    detectRange.setEnd(node, Math.max(offset, 0));
  } catch (error) {
    return null;
  }

  const detectRects = detectRange.getClientRects();
  const {
    length
  } = detectRects;

  if (length > originLength && length > 1) {
    // the newRange has more rects than the old range
    const secondLastRect = detectRects[length - 2];
    const lastRect = detectRects[length - 1]; // skip is it's still in same line

    if (lastRect.left >= secondLastRect.right) {
      return null;
    } // it's a new line, binggo!


    const {
      top,
      left,
      height
    } = lastRect;
    return {
      top,
      left,
      height
    };
  }

  return null;
}

function getTextContentLength(childNode) {
  return childNode.textContent ? childNode.textContent.length : 0;
}

function findTextNodeAtOffset(element, offset) {
  let remainedOffset = offset;
  const {
    childNodes
  } = element;

  for (let i = 0; i < childNodes.length; i += 1) {
    const childNode = childNodes[i];
    const textContentLength = getTextContentLength(childNode);

    if (childNode.nodeType === Node.TEXT_NODE) {
      if (textContentLength >= remainedOffset) {
        return [childNode, remainedOffset];
      }
    } else if (childNode.nodeType === Node.ELEMENT_NODE) {
      if (textContentLength >= remainedOffset) {
        return findTextNodeAtOffset(childNode, remainedOffset);
      }
    } // Ignore other Node.TYPE


    remainedOffset -= textContentLength;
  }

  return findTextNodeAtOffset(element, getTextContentLength(element));
}

function findEdgePointPosition(point, root = window, maxEdgeHeight = CURSOR_EDGE_MAX_HEIGHT, zoom = 1) {
  const {
    key
  } = point; // eslint-disable-next-line react/no-find-dom-node

  const node = findDOMNodeSafely(key, root);

  if (!node) {
    return undefined;
  }

  const {
    edge
  } = point;
  const rect = node.getBoundingClientRect();
  const height = Math.min(Math.round(rect.height), maxEdgeHeight);
  const heightWithZoom = height > maxEdgeHeight ? height / zoom : height;
  const clientLeft = edge === EdgePoint.BEFORE ? rect.left - CURSOR_EDGE_OFFSET - CURSOR_WIDTH : rect.right + CURSOR_EDGE_OFFSET;
  return {
    node,
    clientTop: rect.bottom / zoom - heightWithZoom,
    clientLeft: clientLeft / zoom,
    height: heightWithZoom
  };
}
function findTextPointPosition(point, preferredEdge, root = window, zoom = 1) {
  const isHanging = preferredEdge === 'start';
  const leaves = findDOMLeaves(point.key, root);

  if (!leaves.length) {
    return undefined;
  }
  /**
   * Step 1, find the leaf DOM node
   */


  const {
    offset
  } = point;
  const leaf = leaves.find((_, index) => {
    const nextLeaf = leaves[index + 1];

    if (!nextLeaf) {
      return true;
    }

    const leafKey = nextLeaf.getAttribute(Selector.key);
    const startOffset = leafKey ? keyUtils.parse(leafKey)[1] : null;

    if (!startOffset) {
      return false;
    }

    return startOffset >= offset;
  });

  if (!leaf || !leaf.firstChild) {
    return undefined;
  }

  const leafKey = leaf.getAttribute(Selector.key);
  const startOffset = leafKey ? keyUtils.parse(leafKey)[1] : null;

  if (!startOffset && startOffset !== 0) {
    return undefined;
  }
  /**
   * Step 2, calculate the rects
   */


  const range = window.document.createRange();

  try {
    range.setStart.apply(range, findTextNodeAtOffset(leaf, 0));
    range.setEnd.apply(range, findTextNodeAtOffset(leaf, offset - startOffset));
  } catch (error) {
    return undefined;
  } // example: <span leaf-content key=`key:startOffset`>TEXT [offset] TEXT</span>


  const rangeRects = Array.from(range.getClientRects());
  const firstRangeRect = rangeRects[0];
  const lastRangeRect = rangeRects[rangeRects.length - 1];

  if (!firstRangeRect || !lastRangeRect) {
    return undefined;
  }
  /**
   * Step 3, detect hanging
   */


  const textContent = leaf.firstChild.textContent || '';
  let hangingPosition = null;
  const detectOffset = offset - startOffset + 1;

  if (isHanging && textContent.length >= detectOffset) {
    hangingPosition = findHangingPosition(leaf.firstChild, detectOffset, rangeRects.length);
  }

  let {
    top,
    height
  } = lastRangeRect;
  let left = lastRangeRect.right;
  /**
   * Step 4, detect soft line break
   */
  // if the point is after \n
  // calculate the following bounding rect (offset, offset + 1)
  // and choose left side of following bounding rect

  if (isAfterNewLine(leaf, offset)) {
    try {
      range.setStart(leaf.firstChild, offset - startOffset);
      range.setEnd(leaf.firstChild, Math.max(Math.min(detectOffset, textContent.length), 0));
    } catch (error) {
      return undefined;
    }

    const rects = range.getClientRects();
    const followingRect = rects[rects.length - 1];

    if (followingRect) {
      ({
        left,
        top,
        height
      } = followingRect);
    }
  } // then we have the final position


  if (hangingPosition) {
    ({
      left,
      top,
      height
    } = hangingPosition);
  }

  const [clientLeft, clientTop] = [left, top];
  return {
    node: leaf,
    clientTop: clientTop / zoom,
    clientLeft: clientLeft / zoom - CURSOR_WIDTH / 2,
    height: height / zoom
  };
}
function findCaretPosition(point, preferredEdge, root = window, maxEdgeHeight = CURSOR_EDGE_MAX_HEIGHT, // 缩放比例
zoom = 1) {
  return point.isEdgePoint() ? findEdgePointPosition(point, root, maxEdgeHeight, zoom) : findTextPointPosition(point, preferredEdge, root, zoom);
}

const ARROW_SIZE = 10;
const POPUP_MIN_SPACE = 6;
const TOP_SAFE_SPACE = 42;

function getSelectionRect(selection, controller) {
  let range = null;

  try {
    // get the dom rectangles from the selction
    range = findDOMRange(selection, controller);
  } catch (_) {
    return null;
  }

  if (!range) {
    return null;
  }

  const domRects = Array.from(range.getClientRects());

  if (!domRects.length) {
    return null;
  }

  const {
    left,
    right,
    top,
    bottom
  } = domRects[0]; // compute the rectangle area

  const rect = Array.from(domRects).reduce((obj, item) => {
    obj.left = Math.min(item.left, obj.left);
    obj.top = Math.min(item.top, obj.top);
    obj.right = Math.max(item.right, obj.right);
    obj.bottom = Math.max(item.bottom, obj.bottom);
    return obj;
  }, {
    left,
    right,
    top,
    bottom
  });
  return rect;
}

function getCaretRect(selection, root) {
  const preferredEdge = selection.isHanging ? 'start' : 'end';
  const position = findCaretPosition(selection.anchor, preferredEdge, root);

  if (!position) {
    return null;
  }

  const {
    clientLeft: left,
    clientTop: top,
    height
  } = position;
  const right = left;
  const bottom = top + height;
  return {
    left,
    right,
    top,
    bottom
  };
}

const getPopupPosition = (selection, controller, popupWidth, popupHeight, defaultTop = true) => {
  const {
    document
  } = controller.value;
  const root = findDOMNodeSafely(document.key);
  const rect = selection.isCollapsed ? getCaretRect(selection, root) : getSelectionRect(selection, controller);

  if (!rect) {
    return null;
  } // default position is on top of selection


  let isTop = defaultTop; // move to bottom if the top is reaching out of screen

  if (rect.top - (popupHeight + POPUP_MIN_SPACE) < TOP_SAFE_SPACE) {
    isTop = false;
  } // special case when the user select very long text that exceed screen bottom


  if (rect.bottom + (popupHeight + POPUP_MIN_SPACE) > window.innerHeight) {
    isTop = true;
  } // default arrow is at the middle


  let arrowOffset = popupWidth / 2 - ARROW_SIZE / 2;
  let x = (rect.left + rect.right) / 2 - popupWidth / 2;
  let y = isTop ? rect.top - popupHeight - ARROW_SIZE : rect.bottom + ARROW_SIZE; // if popup is exceed the left/right edge, move it by the [offsetX] value

  let offsetX = 0;

  if (x < POPUP_MIN_SPACE) {
    offsetX = POPUP_MIN_SPACE - x;
  }

  if (x + popupWidth > window.innerWidth - POPUP_MIN_SPACE) {
    offsetX = window.innerWidth - x - popupWidth - POPUP_MIN_SPACE;
  }

  if (offsetX !== 0) {
    x += offsetX;
    arrowOffset -= offsetX;
  }

  arrowOffset = Math.min(popupWidth - ARROW_SIZE * 2, Math.max(ARROW_SIZE, arrowOffset));
  y = Math.max(y, TOP_SAFE_SPACE);
  return {
    x,
    y,
    isTop,
    arrowOffset
  };
};

function useSelectionData(selectionData$, key, onSelectionData, deps) {
  React__default["default"].useEffect(() => {
    const subs = selectionData$.subscribe(({
      range,
      blocksKeys,
      isHideSelection
    }) => {
      const isSelected = key === null ? null : blocksKeys.has(key);
      onSelectionData({
        range,
        isSelected,
        isHideSelection
      });
    });
    return subs.unsubscribe;
  }, [key, onSelectionData, ...deps]);
}
function useSelectionDataAtTheStartOfNextFrame(selectionData$, key, onSelectionDataNextFrame, deps) {
  const animId = React__default["default"].useRef(null);
  const onSelectionData = React__default["default"].useCallback(pendingData => {
    animId.current = window.requestAnimationFrame(() => {
      onSelectionDataNextFrame(pendingData);
    });
  }, [onSelectionDataNextFrame]);
  React__default["default"].useEffect(() => {
    return () => {
      if (animId.current) {
        window.cancelAnimationFrame(animId.current);
      }
    };
  }, []);
  useSelectionData(selectionData$, key, onSelectionData, deps);
}

/**
 * @packageDocumentation
 * @ignore
 */
const _createElement$p = React__namespace.createElement;
const ITEM_HEIGHT = 54;
const POPUP_HEIGHT = ITEM_HEIGHT + 8 * 2;
const POPUP_BOTTOM_EXTRA_HEIGHT = 20;
const wrapperStyle$1 = {
  position: 'fixed',
  zIndex: Z_INDEX_CONTEXTMENU,
  backgroundColor: '#585A5C',
  padding: '8px 4px',
  borderRadius: '8px',
  display: 'flex',
  flexDirection: 'row',
  opacity: '0',
  transition: 'opacity 0.3s'
};
const itemStyle = {
  height: `${ITEM_HEIGHT}px`,
  lineHeight: '16px',
  color: 'white',
  minWidth: '56px',
  width: '56px',
  fontSize: '10px',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  flexDirection: 'column',
  whiteSpace: 'nowrap',
  overflow: 'hidden'
};
const iconStyle = {
  width: '24px',
  height: '24px',
  marginBottom: '2px'
};
const arrowStyle = {
  position: 'absolute',
  bottom: '-4px',
  width: '10px',
  height: '10px',
  backgroundColor: '#585A5C',
  transform: 'rotate(45deg)'
};
const arrowStyleTop = { ...arrowStyle,
  bottom: 'inherit',
  top: '-4px'
};

function ContextMenu(props) {
  const {
    selection,
    controller,
    hidePopup
  } = props;
  const [position, setPosition] = React__namespace.useState(null);
  const rootRef = React__namespace.useRef(null);

  const updatePosition = () => {
    if (rootRef.current) {
      const {
        width
      } = rootRef.current.getBoundingClientRect();
      const pos = getPopupPosition(selection, controller, width, POPUP_HEIGHT, IS_MOBILE);
      setPosition(pos);
    }
  };

  React__namespace.useEffect(updatePosition, [selection]);
  const setNodeVisible = React__namespace.useCallback(visible => {
    const node = rootRef.current;

    if (selection.isCollapsed) {
      hidePopup && hidePopup(controller);
    } else if (node) {
      node.style.opacity = visible ? '1' : '0';
    }
  }, [selection, hidePopup]);
  useSelectionData(controller.selectionData$, null, ({
    range
  }) => {
    if (range.isExpanded && selection.isCollapsed) {
      setNodeVisible(false);
    }
  }, []);
  useScroll({
    onStart: () => {
      setNodeVisible(false);
    },
    onEnd: () => {
      updatePosition();
      setNodeVisible(true);
    }
  });
  let buttons = controller.run('contextMenu').filter(b => Boolean(b.options?.mobile));
  buttons = buttons.sort((a, b) => {
    const groupA = a.options?.group || 0;
    const groupB = b.options?.group || 0;
    return groupA - groupB;
  });
  const styleForWrapper = position ? { ...wrapperStyle$1,
    left: position.x,
    top: position.isTop ? position.y : position.y + POPUP_BOTTOM_EXTRA_HEIGHT,
    opacity: 1
  } : wrapperStyle$1;

  const handleAction = button => {
    return event => {
      event.stopPropagation();
      event.preventDefault();
      controller.run('onAction', button.action);
    };
  };

  const availableButtons = buttons.filter(btn => {
    if (btn.options && btn.options.disable) {
      return false;
    }

    return true;
  }); // 如果可用的 buttons 数为 0，则不渲染

  if (availableButtons.length <= 0) {
    return null;
  }

  const styleForArrow = position ? { ...(position.isTop ? arrowStyle : arrowStyleTop),
    left: position.arrowOffset
  } : arrowStyle;
  return /*#__PURE__*/_createElement$p("div", {
    "data-role": "mobileContextMenu",
    ref: rootRef,
    className: "cangjieContextMenu",
    style: styleForWrapper
  }, availableButtons.map((button, index) => {
    const {
      name,
      role,
      icon: Icon
    } = button;
    return /*#__PURE__*/_createElement$p("div", {
      key: name,
      "data-role": role || '',
      onMouseDown: handleAction(button),
      onTouchEnd: handleAction(button),
      style: itemStyle
    }, typeof Icon !== 'function' && /*#__PURE__*/_createElement$p("img", {
      style: iconStyle,
      src: Icon || 'https://gw.alicdn.com/imgextra/i4/O1CN011xit6C1NdBJNUvlF9_!!6000000001592-55-tps-24-24.svg'
    }), typeof Icon === 'function' && /*#__PURE__*/_createElement$p(Icon, null), /*#__PURE__*/_createElement$p("div", null, name));
  }), /*#__PURE__*/_createElement$p("span", {
    style: styleForArrow
  }));
}

var ContextMenu$1 = (props => /*#__PURE__*/ReactDOM__default["default"].createPortal( /*#__PURE__*/_createElement$p(ContextMenu, props), document.body));

/**
 * @packageDocumentation
 * @module Hooks
 */
/**
 * @ignore
 */

const ZoomContext = /*#__PURE__*/React__namespace.createContext(1);
/**
 * @ignore
 */

const ExternalZoomContext = /*#__PURE__*/React__namespace.createContext(1);
/**
 * @ignore
 */

const ZoomContainerContext = /*#__PURE__*/React__namespace.createContext(null);
function useZoom() {
  return React__namespace.useContext(ZoomContext);
}
/**
 * @ignore
 *
 * TODO: external zoom 是为了感知上层业务自行实现的缩放，但是这个设计是不合理的，上层业务从使
 * 用上看，没必要自行实现缩放功能，应该使用 cangjie 自带的缩放设计。后续希望移除此部分的 API。
 *
 * 目前已知的业务自行实现的缩放场景：PC 演示模式、生成长图
 * 2021-0222 新加：缩放状态下的评论
 */

function useExternalZoom() {
  return React__namespace.useContext(ExternalZoomContext);
}
function useZoomContainer() {
  return React__namespace.useContext(ZoomContainerContext);
}

const _createElement$o = React__namespace.createElement;
const WIDTH = 160;
const HEIGHT = 128;
const ZOOM = 1.8;
const POPUP_EXTRA_TOP = -4;
const POPUP_EXTRA_BOTTOM = 52;
const rootStyle = {
  position: 'fixed',
  overflow: 'hidden',
  left: '50px',
  top: '50px',
  zIndex: 10000,
  background: 'white',
  width: WIDTH,
  height: HEIGHT,
  border: '1px solid rgba(17,31,44,0.12)',
  boxShadow: '0 4px 8px 0 rgba(0,0,0,0.08), inset 0 10px 20px 0 rgba(0,0,0,0.08)',
  borderRadius: '8px',
  opacity: 0
};
const blockContainerStyle = {
  backfaceVisibility: 'hidden',
  transformOrigin: 'top left'
};

// remove all the *cangjie* attributes
function cleanNode(node) {
  Array.from(node.attributes).forEach(attr => {
    if (attr.name.indexOf('cangjie') >= 0) {
      node.removeAttribute(attr.name);
    }
  });
  Array.from(node.children).forEach(child => {
    cleanNode(child);
  });
}

function clearNode(node) {
  while (node && node.lastChild) {
    node.removeChild(node.lastChild);
  }
}

function Zoomer(pros) {
  const controller = useController();
  const container = useZoomContainer();
  const {
    point,
    isHanging
  } = pros;
  const [cachedBlocks] = React__namespace.useState(new WeakMap());
  const blockRef = React__namespace.useRef(null);
  const rootRef = React__namespace.useRef(null);
  React__namespace.useEffect(() => {
    const blockNode = blockRef.current;
    const {
      document,
      selection
    } = controller.value;
    const {
      start
    } = selection.sort(document);
    const preferredEdge = point === start ? 'start' : 'end';
    const pointPosition = findCaretPosition(point, preferredEdge, container || window);

    if (!blockNode || !pointPosition) {
      return;
    } // Get the DOM elements
    // eslint-disable-next-line react/no-find-dom-node


    const ancestor = document.getAncestors(point.key)[0];
    const dom = findDOMNode(ancestor.key);
    const maybePrevDom = dom.previousElementSibling;
    const prevDom = maybePrevDom && !maybePrevDom.getAttribute('data-cangjie-hidden') ? maybePrevDom : null;
    const nextDom = dom.nextElementSibling; // Clone the DOM elements and cache them if necessary

    const prevArticleBlock = prevDom ? cachedBlocks.get(prevDom) || prevDom.cloneNode(true) : null;
    const nextArticleBlock = nextDom ? cachedBlocks.get(nextDom) || nextDom.cloneNode(true) : null;

    if (prevDom && prevArticleBlock && !cachedBlocks.get(prevDom)) {
      cleanNode(prevArticleBlock);
      cachedBlocks.set(prevDom, prevArticleBlock);
    }

    if (nextDom && nextArticleBlock && !cachedBlocks.get(nextDom)) {
      cleanNode(nextArticleBlock);
      cachedBlocks.set(nextDom, nextArticleBlock);
    } // We never cache the focused DOM element


    const articleBlock = dom.cloneNode(true);
    cleanNode(articleBlock); // Calculate the offset positions

    const domRect = dom.getBoundingClientRect();
    const marginTop = parseInt(window.getComputedStyle(dom).marginTop, 10) || 0;
    const offsetX = pointPosition.clientLeft - domRect.left - WIDTH / ZOOM / 2;
    let offsetY = pointPosition.clientTop + pointPosition.height / 2 - domRect.top + marginTop - HEIGHT / ZOOM / 2;

    if (prevDom && prevArticleBlock) {
      const prevStyle = window.getComputedStyle(prevDom);
      const prevMarginTop = parseInt(prevStyle.marginTop, 10) || 0;
      const prevMarginBottom = parseInt(prevStyle.marginBottom, 10) || 0;
      offsetY += prevDom.getBoundingClientRect().height + prevMarginTop + prevMarginBottom;
    }

    const focusedSelection = Selection.create({
      anchor: point,
      focus: point
    }).setHanging(isHanging);
    const popupPosition = getPopupPosition(focusedSelection, controller, WIDTH, HEIGHT); // Attach the DOM elements and apply all positions

    clearNode(blockNode);

    if (prevArticleBlock) {
      blockNode.appendChild(prevArticleBlock);
    }

    blockNode.appendChild(articleBlock);

    if (nextArticleBlock) {
      blockNode.appendChild(nextArticleBlock);
    }

    if (rootRef.current && popupPosition) {
      const {
        isTop,
        x,
        y
      } = popupPosition;
      const extraOffset = isTop ? POPUP_EXTRA_TOP : POPUP_EXTRA_BOTTOM;
      rootRef.current.style.left = `${x}px`;
      rootRef.current.style.top = `${y + extraOffset}px`;
      rootRef.current.style.opacity = '1';
    }

    blockNode.style.width = `${domRect.width}px`;
    blockNode.style.transform = `translate(${-offsetX * ZOOM}px, ${-offsetY * ZOOM}px) scale(${ZOOM})`;
  }, [cachedBlocks, container, controller, point]);
  return /*#__PURE__*/_createElement$o("div", {
    "data-cangjie-mobile-zoomer": true,
    style: rootStyle,
    ref: rootRef
  }, /*#__PURE__*/_createElement$o("div", {
    style: blockContainerStyle,
    ref: blockRef
  }));
}

var Zoomer$1 = (props => {
  const container = useZoomContainer();
  const attachNode = container?.querySelector('[data-cangjie-zoomer]');

  if (!attachNode) {
    return null;
  }

  return /*#__PURE__*/ReactDOM__default["default"].createPortal( /*#__PURE__*/_createElement$o(Zoomer, props), attachNode);
});

/**
 * @packageDocumentation
 * @ignore
 */
// 参考 mac 下最大字号 72pt * 1.7 行高 = 163px 设置的 magic number

const MAX_LINE_HEIGHT = 150; // 往上滚动时，底部预留额外距离。参考竞品 (G Docs)，移动端间距会大一些 (一行 + 4px)

const EXTRA_BOTTOM_OFFSET = IS_MOBILE ? 66 : 12;
function findScrollableContainer(el, window) {
  if (!el) {
    return null;
  }

  let scroller;
  let parent = el.parentNode;

  while (!scroller) {
    if (!parent.parentNode) break;
    const style = window.getComputedStyle(parent);
    const {
      overflowY
    } = style;

    if (['auto', 'overlay', 'scroll'].includes(overflowY)) {
      scroller = parent;
      break;
    }

    parent = parent.parentNode;
  } // COMPAT: Because Chrome does not allow doucment.body.scrollTop, we're
  // assuming that window.scrollTo() should be used if the scrollable element
  // turns out to be document.body or document.documentElement. This will work
  // unless body is intentionally set to scrollable by restricting its height
  // (e.g. height: 100vh).


  if (!scroller) {
    return window.document.body;
  }

  return scroller;
}
function getScrollableContainerInfo(scroller) {
  const isWindow = scroller === window || scroller === window.document.body || scroller === window.document.documentElement; // @ts-ignore

  const {
    innerHeight,
    visualViewport,
    _visualHeight
  } = window;
  let width;
  let height;
  let yOffset;
  let xOffset;
  let scrollerTop = 0;
  let scrollerLeft = 0;
  let scrollerBordersY = 0;
  let scrollerBordersX = 0;
  let scrollerPaddingTop = 0;
  let scrollerPaddingBottom = 0;
  let scrollerPaddingLeft = 0;
  let scrollerPaddingRight = 0; // iOS 13/14 Safari浏览器，去除键盘高度后的视口高度

  let viewportHeight = visualViewport ? visualViewport.height : innerHeight; // 底部工具条弹出时，下面区域视为 viewport 之外

  if (typeof _visualHeight === 'number' && _visualHeight > 0) {
    viewportHeight = _visualHeight;
  }

  if (isWindow) {
    // @ts-ignore
    const {
      innerWidth,
      pageYOffset,
      pageXOffset
    } = window;
    width = innerWidth;
    height = innerHeight;
    yOffset = pageYOffset;
    xOffset = pageXOffset;
  } else {
    const {
      offsetWidth,
      offsetHeight,
      scrollTop,
      scrollLeft
    } = scroller;
    const {
      borderTopWidth,
      borderBottomWidth,
      borderLeftWidth,
      borderRightWidth,
      paddingTop,
      paddingBottom,
      paddingLeft,
      paddingRight
    } = window.getComputedStyle(scroller);
    const scrollerRect = scroller.getBoundingClientRect();
    width = offsetWidth;
    height = offsetHeight;
    scrollerTop = scrollerRect.top + parseInt(borderTopWidth, 10);
    scrollerLeft = scrollerRect.left + parseInt(borderLeftWidth, 10);
    scrollerBordersY = parseInt(borderTopWidth, 10) + parseInt(borderBottomWidth, 10);
    scrollerBordersX = parseInt(borderLeftWidth, 10) + parseInt(borderRightWidth, 10);
    scrollerPaddingTop = parseInt(paddingTop, 10);
    scrollerPaddingBottom = parseInt(paddingBottom, 10);
    scrollerPaddingLeft = parseInt(paddingLeft, 10);
    scrollerPaddingRight = parseInt(paddingRight, 10);
    yOffset = scrollTop;
    xOffset = scrollLeft;
  }

  return {
    isWindow,
    width,
    height,
    viewportHeight,
    scrollerTop,
    scrollerLeft,
    xOffset,
    yOffset,
    scrollerPaddingLeft,
    scrollerPaddingRight,
    scrollerPaddingTop,
    scrollerPaddingBottom,
    scrollerBordersX,
    scrollerBordersY
  };
}
function getDOMRectFromSelection(selection, content, controller) {
  const collapsedSelection = selection.moveToFocus();

  if (!collapsedSelection) {
    return null;
  }

  const {
    anchor
  } = collapsedSelection;

  if (anchor.isEdgePoint()) {
    let node = null;

    try {
      // eslint-disable-next-line react/no-find-dom-node
      node = findDOMNode(anchor.key);
    } catch (error) {// ignore
    }

    if (!node) {
      return null;
    }

    const domRect = node.getBoundingClientRect();
    const {
      top,
      height
    } = domRect;
    const left = anchor.edge === EdgePoint.BEFORE ? domRect.left : domRect.right;
    return typeof DOMRect !== 'undefined' ? new DOMRect(left, top, 1, height) : null;
  }

  let range = null;

  try {
    range = findDOMRange(collapsedSelection, controller, content);
  } catch (e) {
    return null;
  }

  if (!range) {
    return null;
  }

  const cursorRect = range.getClientRects()[0];

  if (!cursorRect) {
    return null;
  }

  return cursorRect;
}
function scrollToSelection(selection, content, scroller, controller) {
  const inline = controller.value.document.getClosestInline(selection.focus.key);
  let rect; // 光标在 inline 元素内部

  if (inline) {
    const inlineDOM = findDOMNodeSafely(inline.key);

    if (!inlineDOM) {
      return;
    }

    const inlineRect = inlineDOM.getBoundingClientRect();
    rect = {
      node: inlineDOM,
      clientLeft: inlineRect.left + inlineRect.width / 2,
      clientTop: inlineRect.top,
      height: inlineRect.height // 以 inline 的尺寸为准

    };
  } else {
    rect = findCaretPosition(selection.focus, selection.isHanging ? 'start' : 'end', content, Infinity);
  }

  if (!rect) {
    return;
  }

  const {
    isWindow,
    width,
    height,
    viewportHeight,
    scrollerTop,
    scrollerLeft,
    xOffset,
    yOffset,
    scrollerPaddingLeft,
    scrollerPaddingRight,
    scrollerPaddingTop,
    scrollerPaddingBottom,
    scrollerBordersX,
    scrollerBordersY
  } = getScrollableContainerInfo(scroller);
  const cursorTop = rect.clientTop + yOffset - scrollerTop;
  const cursorLeft = rect.clientLeft + xOffset - scrollerLeft;
  let x = xOffset;
  let y = yOffset;
  let inView = true;

  if (cursorLeft < xOffset) {
    // selection to the left of viewport
    x = cursorLeft - scrollerPaddingLeft;
    inView = false;
  } else if (cursorLeft + CURSOR_WIDTH + scrollerBordersX > xOffset + width) {
    // selection to the right of viewport
    x = cursorLeft + scrollerBordersX + scrollerPaddingRight - width;
    inView = false;
  }

  if (cursorTop < yOffset) {
    // selection above viewport
    y = cursorTop - scrollerPaddingTop;
    inView = false;
  } else if (cursorTop + rect.height + scrollerBordersY > yOffset + height - EXTRA_BOTTOM_OFFSET // 此条件为被iOS键盘遮挡
  // iOS弹出键盘只会改变 visualViewport，不会影响其他任何地方
  || rect.clientTop + rect.height > viewportHeight - EXTRA_BOTTOM_OFFSET) {
    // selection below viewport
    y = Math.max(cursorTop + scrollerBordersY + scrollerPaddingBottom + rect.height - height, // 此数值为避免被iOS键盘遮挡
    scrollerTop + cursorTop + rect.height - viewportHeight);
    y += EXTRA_BOTTOM_OFFSET;
    inView = false;
  } // 对于大元素（超过 1/2 屏幕高度以上），特殊处理一下。


  const quaterHeight = height / 4;
  const isHugeElement = rect.height > quaterHeight * 2; // 如果大元素已经大部分在视图内（1/4 以上），就不要滚动了。

  const partInView = rect.clientTop < scrollerTop + quaterHeight * 3 && rect.clientTop + rect.height > scrollerTop + quaterHeight;

  if (isHugeElement && partInView) {
    inView = true;
  }

  if (inView) {
    return;
  }

  const deltaY = Math.abs(y - scroller.scrollTop);
  (isWindow ? window : scroller).scrollTo({
    left: x,
    top: y,
    // 纵向滚动距离小于 Min(视口高度/4, 特定高度) 时，采用顺滑滚动
    //    > 一般用于输入文字导致的换行到视口外，然后滚动进视口
    // 否则滚动距离过大就直接跳转到指定位置，避免滚动动画时间过长，体感不好
    behavior: deltaY < Math.min(quaterHeight, MAX_LINE_HEIGHT) ? 'smooth' : 'auto'
  });
}

const stateMap = new WeakMap(); // 检测 move 事件的 Throttle

const THROTTLE_MOVE = 300; // 用户每移动这么多 pixel，就加一个速度

const SPEED_PIXEL = 20; // 用户最大速度（最小是 1）

const MAX_SPEED = 6; // 底部热区大一些，提前就滚动

const BOTTOM_EXTRA_HOT_SIZE = IS_MOBILE ? 100 : 50; // 移动端顶部热区大一些，提前滚动

const TOP_EXTRA_HOT_SIZE = IS_MOBILE ? 100 : 0;

const scheduleScroll = params => {
  const {
    controller,
    isWindow,
    scroller,
    left,
    from,
    speed,
    isTop
  } = params;
  const state = stateMap.get(controller);

  if (!state || !state.isStarted) {
    return;
  }

  cancelSchedule(controller); // step 从用户体验角度，做了指数加速，一般是：2, 6, 12, 20, 30, ... 72

  const px = speed * (speed + 1);
  const step = isTop ? -px : px;
  const top = Math.round(from + step);

  if (isWindow) {
    window.scrollTo(left, top);
  } else {
    scroller.scrollTop = top;
  }

  const newSpeed = Math.min(MAX_SPEED, speed + 0.1);
  state.timer = requestAnimationFrame(() => {
    scheduleScroll({ ...params,
      from: top,
      speed: newSpeed
    });
  });
};

const cancelSchedule = controller => {
  const state = stateMap.get(controller);

  if (state?.timer) {
    cancelAnimationFrame(state.timer);
    state.timer = undefined;
  }
};

const startScroll = ({
  scroller,
  controller
}) => {
  stopScroll(controller);
  stateMap.set(controller, {
    isStarted: true
  });
  return lodash.throttle(event => {
    // PC Safari 下，不支持 TouchEvent
    const {
      clientY
    } = typeof TouchEvent === 'function' && event instanceof TouchEvent ? event.touches[0] : event;
    const {
      isWindow,
      scrollerTop: top,
      height,
      xOffset,
      yOffset
    } = getScrollableContainerInfo(scroller);
    const bottom = top + height;
    const topOffset = top - clientY + SPEED_PIXEL + TOP_EXTRA_HOT_SIZE;
    const bottomOffset = clientY - bottom + SPEED_PIXEL + BOTTOM_EXTRA_HOT_SIZE;

    if (topOffset <= 0 && bottomOffset <= 0) {
      cancelSchedule(controller);
      return;
    }

    const isTop = topOffset > 0; // speed 一般是：1 - 8

    const speed = Math.max(1, Math.min(MAX_SPEED, Math.round(isTop ? topOffset / SPEED_PIXEL : bottomOffset / SPEED_PIXEL)));
    scheduleScroll({
      controller,
      isWindow,
      scroller,
      left: xOffset,
      from: yOffset,
      isTop,
      speed
    });
  }, THROTTLE_MOVE);
};
const stopScroll = controller => {
  const state = stateMap.get(controller);

  if (!state || !state.isStarted) {
    return;
  }

  cancelSchedule(controller);
  state.isStarted = false;
};
const isScrolling = controller => {
  const state = stateMap.get(controller);
  return Boolean(state?.isStarted && state.timer);
};

const ScrollableContainerContext = /*#__PURE__*/React.createContext(typeof window !== 'undefined' ? window : null);
/**
 * 滚动container，默认是window
 */

function useScrollableContainer() {
  return React.useContext(ScrollableContainerContext);
}

const _createElement$n = React__namespace.createElement;
// handle needle width
const HANDLE_WIDTH = 2; // handle round dot size

const HANDLE_DOT_SIZE = 10; // handle touchable rect size

const HANDLE_TOUCH_SIZE = 30;
const TYPE_START = 'start';
const TYPE_END = 'end';
const cursorStyle = {
  position: 'fixed',
  background: '#0089ff',
  opacity: 1,
  width: `${HANDLE_WIDTH}px`
};
const handleRectStyle = {
  position: 'absolute',
  width: `${HANDLE_TOUCH_SIZE}px`,
  height: `${HANDLE_TOUCH_SIZE}px`,
  left: `-${HANDLE_TOUCH_SIZE / 2 - HANDLE_WIDTH / 2}px`,
  bottom: `-${HANDLE_TOUCH_SIZE / 2 + HANDLE_DOT_SIZE / 2}px`,
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center'
};
const handleRectTop = {
  left: `-${HANDLE_TOUCH_SIZE / 2}px`,
  top: `-${HANDLE_TOUCH_SIZE / 2}px`,
  bottom: 'auto'
};
const handleRoundDotStyle = {
  background: '#0089ff',
  width: `${HANDLE_DOT_SIZE}px`,
  height: `${HANDLE_DOT_SIZE}px`,
  borderRadius: `${HANDLE_DOT_SIZE}px`
};
const handleRectTopStyle = { ...handleRectStyle,
  ...handleRectTop
};

const isPointVisible = ({
  node,
  clientLeft
}) => {
  let visible = true;
  let pElement = node.parentElement;

  while (pElement && !pElement.getAttribute(`[${Selector.content}]`)) {
    if (pElement.scrollWidth > pElement.offsetWidth) {
      const pRect = pElement.getBoundingClientRect();

      if (clientLeft < pRect.left || clientLeft > pRect.right) {
        visible = false;
        break;
      }
    }

    pElement = pElement.parentElement;
  }

  return visible;
};

const updateHandlePosition = (node, loc) => {
  node.style.top = `${loc.clientTop}px`;
  node.style.left = `${loc.clientLeft}px`;
  node.style.height = `${loc.height}px`;
};

const blockEvent$1 = e => {
  e.preventDefault();
  e.stopPropagation();
}; // get a range from a client point (x, y)


const caretRangeFromPoint = (x, y, controller) => {
  const {
    key
  } = controller.value.document;
  const docNode = findDOMNodeSafely(key);
  const ele = docNode?.closest(`[${Selector.content}]`);

  if (!ele) {
    return null;
  }

  return caretRangeFromTargetAndCoord(ele, x, y, controller);
}; // Handle component


var _ref$1 = /*#__PURE__*/_createElement$n("span", {
  style: handleRoundDotStyle
});

const Handle = /*#__PURE__*/React__namespace.forwardRef(({
  style,
  onDrag,
  onDragStart,
  onDragEnd,
  type,
  isHidden = false
}, ref) => {
  // prevent page scroll when dragging
  const handleTouchStart = e => {
    blockEvent$1(e);
    e.nativeEvent.stopImmediatePropagation();
    onDragStart(type);
  };

  const handleTouchEnd = e => {
    blockEvent$1(e);
    e.nativeEvent.stopImmediatePropagation();
    onDragEnd(type);
  };

  const handleDrag = React__namespace.useCallback(event => {
    onDrag(type, event);
  }, [type, onDrag]);
  const touchMoveRef = React__namespace.useRef(null);
  React__namespace.useEffect(() => {
    const element = touchMoveRef ? touchMoveRef.current : null;

    if (element !== null) {
      element.addEventListener('touchmove', handleDrag, {
        passive: false,
        capture: true
      });
    }

    return () => {
      if (element !== null) {
        element.removeEventListener('touchmove', handleDrag, {
          capture: true
        });
      }
    };
  }, [handleDrag]);
  return /*#__PURE__*/_createElement$n("span", {
    ref: ref,
    "data-testid": "mobile-range-handle",
    style: isHidden ? { ...cursorStyle,
      opacity: 0
    } : cursorStyle
  }, /*#__PURE__*/_createElement$n("span", {
    ref: touchMoveRef,
    onTouchStart: handleTouchStart,
    onTouchEnd: handleTouchEnd,
    style: style
  }, _ref$1));
}); // Handles component, contains two handles at start and end of a selection

function Handles({
  selection,
  controller,
  enableZoomer
}) {
  const {
    document
  } = controller.value;
  const scrollableContainer = useScrollableContainer();
  const startRef = React__namespace.useRef(null);
  const endRef = React__namespace.useRef(null);
  const outsideScoller = React__namespace.useRef(null);
  const {
    start,
    end
  } = selection.sort(document);
  const setNodeVisible = React__namespace.useCallback((nodeRef, visible) => {
    const node = nodeRef.current;

    if (node) {
      node.style.visibility = visible ? 'unset' : 'hidden';
    }
  }, []);

  const updatePosition = () => {
    const root = findDOMNodeSafely(document.key);
    const posStart = findCaretPosition(start, 'start', root);
    const posEnd = findCaretPosition(end, 'end', root);
    const pairs = [[posStart, startRef], [posEnd, endRef]];
    pairs.forEach(([position, ref]) => {
      if (position && isPointVisible(position) && ref.current) {
        setNodeVisible(ref, true);
        updateHandlePosition(ref.current, position);
      } else {
        setNodeVisible(ref, false);
      }
    });
  };

  React__namespace.useEffect(updatePosition);
  useScroll({
    onStart: () => {
      setNodeVisible(startRef, false);
      setNodeVisible(endRef, false);
    },
    onEnd: () => {
      updatePosition();
    }
  });
  const optimizeVerticalPosition = React__namespace.useCallback((isStart, orginalY) => {
    const friendNode = isStart ? endRef.current : startRef.current;

    if (friendNode) {
      const friendRect = friendNode.getBoundingClientRect();
      const friendY = friendRect.top + friendRect.height / 2;
      return isStart ? Math.min(friendY, orginalY) : Math.max(friendY, orginalY);
    }

    return orginalY;
  }, []); // update the selection when the user drags the handle bar

  const handleDrag = React__namespace.useCallback((type, event) => {
    blockEvent$1(event);
    outsideScoller.current && outsideScoller.current(event);
    const isStart = type === TYPE_START;
    event.stopImmediatePropagation();
    const touchPoint = event.touches[0];
    const {
      clientX,
      clientY
    } = touchPoint;
    const x = clientX;
    const orginalY = isStart ? clientY + HANDLE_TOUCH_SIZE : clientY - HANDLE_TOUCH_SIZE;
    const y = optimizeVerticalPosition(isStart, orginalY);
    const range = caretRangeFromPoint(x, y, controller);
    const {
      document: doc,
      selection
    } = controller.value;

    if (!range) {
      return;
    }

    let {
      focus: targetPoint
    } = range;
    const voidParent = document.getClosestVoid(targetPoint.key, controller);

    if (voidParent) {
      // Handle Drag will skip the point inside void elements
      try {
        // eslint-disable-next-line react/no-find-dom-node
        const voidNode = findDOMNode(voidParent.key);
        const voidRect = voidNode.getBoundingClientRect();
        const voidCenterX = voidRect.x + voidRect.width / 2;
        const distance = clientX > voidCenterX ? 1 : -1;
        targetPoint = controller.query(pointAtDistance, targetPoint, distance);
      } catch (error) {// ignore
      }
    }

    const newSelection = selection.set('anchor', targetPoint);

    if (newSelection.isCollapsed || newSelection.isBackward(doc) !== selection.isBackward(doc) || equal__default["default"](newSelection, selection)) {
      return;
    }

    controller.run('onCangjieSelect', CangjieSelectEvent({
      selection: newSelection,
      trigger: 'dragging'
    }));
  }, [controller]);
  const [dragging, setDragging] = React__namespace.useState(null);
  const onDragStart = React__namespace.useCallback(type => {
    /**
     * Some android devices scroll to the HiddenTextArea after drag, it
     * use 'anchor' point for positioning. So we make sure the user always
     * drag the 'anchor' point here.
     */
    const isBackward = selection.isBackward(document); // if we're dragging the 'focus' point, flip the selection

    if (type === TYPE_START && isBackward || type === TYPE_END && !isBackward) {
      const newSelection = selection.merge({
        anchor: selection.focus,
        focus: selection.anchor
      });
      controller.run('onCangjieSelect', CangjieSelectEvent({
        selection: newSelection,
        trigger: 'dragging'
      }));
    }

    setDragging(type);

    if (scrollableContainer) {
      outsideScoller.current = startScroll({
        scroller: scrollableContainer,
        controller
      });
    }
  }, [controller, document, selection]);
  const onDragEnd = React__namespace.useCallback(() => {
    setDragging(null);

    if (outsideScoller.current) {
      outsideScoller.current.cancel();
      outsideScoller.current = null;
    }

    stopScroll(controller);
  }, []);
  React__namespace.useEffect(() => {
    return () => {
      if (outsideScoller.current) {
        outsideScoller.current.cancel();
        outsideScoller.current = null;
      }
    };
  }, [controller]);
  const dragProps = {
    onDragStart,
    onDragEnd
  };
  let draggingPoint = null;

  if (dragging === TYPE_START) {
    draggingPoint = start;
  } else if (dragging === TYPE_END) {
    draggingPoint = end;
  }

  return /*#__PURE__*/_createElement$n(React__namespace.Fragment, null, /*#__PURE__*/_createElement$n(Handle, _extends__default["default"]({}, dragProps, {
    type: TYPE_START,
    isHidden: enableZoomer && dragging === TYPE_END,
    onDrag: handleDrag,
    ref: startRef,
    style: handleRectTopStyle
  })), /*#__PURE__*/_createElement$n(Handle, _extends__default["default"]({}, dragProps, {
    type: TYPE_END,
    isHidden: enableZoomer && dragging === TYPE_START,
    onDrag: handleDrag,
    ref: endRef,
    style: handleRectStyle
  })), enableZoomer && draggingPoint && /*#__PURE__*/_createElement$n(Zoomer$1, {
    isHanging: dragging === TYPE_START,
    point: draggingPoint
  }), !dragging && /*#__PURE__*/_createElement$n(ContextMenu$1, {
    selection: selection,
    controller: controller
  }));
}

var Handles$1 = (props => {
  const {
    selection: propsSelection,
    controller
  } = props;
  const [selection, setSelection] = React__namespace.useState(propsSelection);
  React__namespace.useMemo(() => {
    setSelection(propsSelection);
  }, [propsSelection]);
  useSelectionData(controller.selectionData$, null, ({
    range
  }) => {
    setSelection(range);
  }, []);

  if (selection.isCollapsed) {
    return null;
  }

  return /*#__PURE__*/ReactDOM__default["default"].createPortal( /*#__PURE__*/_createElement$n(Handles, _extends__default["default"]({}, props, {
    selection: selection
  })), document.body);
});

/**
 * @packageDocumentation
 * @ignore
 */
const _createElement$m = React__namespace.createElement;
const ACTION_CLEAR_MOBILE_MENU = Symbol('ACTION_CLEAR_MOBILE_MENU');

function getDraggingSelection(controller) {
  // eslint-disable-next-line no-underscore-dangle
  return controller.value.data._mobileDraggingSelection;
}

function hidePopup(controller) {
  showPopup(controller, undefined);
}

function showPopup(controller, selection) {
  const {
    data
  } = controller.value;
  const prevRange = getPopupSelection(controller);
  const focusedSelection = prevRange && selection && Selection.isEqual(prevRange, selection) ? undefined : selection;
  controller.setData({ ...data,
    _mobileFocusedSelection: focusedSelection
  });
}

function getPopupSelection(controller) {
  // eslint-disable-next-line no-underscore-dangle
  return controller.value.data._mobileFocusedSelection;
}
/**
 * 兼容 鼠标 + 触屏 场景
 *
 * 背景：
 * touch 事件会触发 onTouchStart 和 onMouseDown
 * mouse 事件会触发 onMouseDown
 *
 * 方案：
 * touch 事件，touchCount 值重置为 2
 * mouse 事件，touchCount 值减 1
 *
 * 结果：
 * 用户使用了 mouse：touchCount <= 0
 * 用户使用了 touch：touchCount === 1
 */


let touchCount = 0;
function createMobilePlugin(configs) {
  const {
    enableZoomer = false
  } = configs?.plugins?.mobile || {};

  function onTouchStart(event, controller, next) {
    const {
      selection,
      isFocused
    } = controller.value;
    const {
      isCollapsed
    } = selection;

    if (isFocused && isCollapsed) {
      const {
        target,
        clientX,
        clientY
      } = event.touches[0];
      const range = caretRangeFromTargetAndCoord(target, clientX, clientY, controller);

      if (range && Selection.isEqual(selection, range)) {
        showPopup(controller, selection);
      } else if (range && getPopupSelection(controller)) {
        hidePopup(controller);
      }
    }

    touchCount = 2;
    return next();
  }

  function onMouseDown(event, controller, next) {
    touchCount = touchCount > 0 ? touchCount - 1 : 0;
    return next();
  }

  function renderContent(_, controller, next) {
    const {
      value,
      readOnly
    } = controller;
    const {
      selection,
      isFocused
    } = value;
    const {
      contextData
    } = value.data;
    const focusedSelection = getPopupSelection(controller);
    const shouldRenderH5Controls = Boolean(isFocused || controller.query('shouldRenderH5Controls')); // 鼠标 + 触屏 场景，如果是鼠标触发的，就不显示菜单

    const isDisabled = !IS_MOBILE && IS_TOUCH_DEVICE && touchCount === 0;
    const isInFocusedSelection = focusedSelection && Selection.isEqual(focusedSelection, selection); // 当处于 focusedSelection 或者 插件允许的区域，可以渲染 contextMenu

    const isInRenableSelection = isInFocusedSelection || controller.query('shouldRenderContextMenu');
    const shouldRenderContextMenu = Boolean(shouldRenderH5Controls && !contextData && !isDisabled && isInRenableSelection);
    const shouldRenderHandles = shouldRenderH5Controls && !contextData && !isDisabled && !controller.query('isHideSelection');
    return /*#__PURE__*/_createElement$m(React__namespace.Fragment, null, next(), selection.isCollapsed && shouldRenderContextMenu && /*#__PURE__*/_createElement$m(ContextMenu$1, {
      selection: selection,
      controller: controller,
      hidePopup: hidePopup
    }), shouldRenderHandles && /*#__PURE__*/_createElement$m(Handles$1, {
      enableZoomer: enableZoomer,
      selection: selection,
      controller: controller
    }));
  }

  function renderCaret(props, controller, next) {
    const caret = next();

    if (!caret) {
      return null;
    }

    const isDragging = getDraggingSelection(controller);
    const mode = isDragging ? 'placeholder' : 'caret';
    return /*#__PURE__*/React__namespace.cloneElement(caret, {
      mode
    });
  }

  function onAction(action, controller, next) {
    if (action.type === ACTION_CLEAR_MOBILE_MENU) {
      const {
        data
      } = controller.value; // eslint-disable-next-line no-underscore-dangle

      if (data._mobileFocusedSelection) {
        controller.setData({ ...data,
          _mobileFocusedSelection: undefined
        });
      }
    }

    return next();
  }

  return {
    onAction,
    onTouchStart,
    onMouseDown,
    renderContent,
    renderCaret,
    models: []
  };
}

/**
 * @packageDocumentation
 * @ignore
 */
function createQueriesPlugin(qrys = {}) {
  // PERF: drop prototype
  const queries = Object.assign(Object.create(null), qrys);

  function onQuery(qry, controller, next) {
    const {
      type,
      args
    } = qry;
    const query = queries[type];

    if (!query) {
      return next();
    }

    const ret = query(controller, ...args);
    return ret === undefined ? next() : ret;
  }

  return {
    models: [],
    onQuery
  };
}

/**
 * @packageDocumentation
 * @ignore
 */
function createRenderNodePlugin(renders = {}) {
  // PERF: drop prototype
  const renderNodes = Object.assign(Object.create(null), renders); // @ts-ignore

  const renderNode = (props, controller, n) => {
    // @ts-ignore
    const renders = renderNodes[props.node?.type];

    if (!renders) {
      return n();
    }

    let prevArgs = [props, controller, n];
    let i = 0;

    function next(...as) {
      const currentArgs = as.length === 0 ? prevArgs : [...as, ...prevArgs.slice(as.length)];
      prevArgs = currentArgs;
      const fn = renders[i];

      if (!fn) {
        return null;
      }

      i += 1;
      return fn(currentArgs[0], controller, next);
    }

    return next();
  };

  return {
    models: [],
    renderNode
  };
}

/**
 * @packageDocumentation
 * @ignore
 */
function createCommandsPlugin(cmds = {}) {
  // PERF: drop prototype
  const commands = Object.assign(Object.create(null), cmds);

  function onCommand(cmd, controller, next) {
    const {
      type,
      args
    } = cmd;
    const command = commands[type];

    if (!command) {
      return next();
    }

    return command(controller, ...args);
  }

  return {
    models: [],
    onCommand
  };
}

/* eslint-disable no-continue */
const klassToIsType = {
  document: Document.isDocument,
  block: Block.isBlock,
  inline: Inline.isInline,
  text: Text$1.isText,
  mark: Mark.isMark
};

function validateKlass(node, rule) {
  if (!rule.klass) {
    return null;
  } // FIXME: remove `.toJSON()`


  if (typeof rule.klass === 'function' && rule.klass(node.toJSON().klass)) {
    return null;
  }

  const isType = klassToIsType[rule.klass];

  if (isType && isType(node)) {
    return null;
  }

  return {
    code: 'node_klass_invalid',
    rule,
    node
  };
}

function validateType(node, rule) {
  if (!rule.type) {
    return null;
  }

  if (rule.type === node.type) {
    return null;
  }

  if (typeof rule.type === 'function' && rule.type(node.type)) {
    return null;
  }

  return {
    code: 'node_type_invalid',
    rule,
    node
  };
}

function validateFirst(node, rule) {
  if (!rule.first) {
    return null;
  }

  const first = node.nodes[0];

  if (!first) {
    return null;
  }

  const error = validateRules(first, rule.first);

  if (!error) {
    return null;
  }

  return Object.assign({}, error, {
    rule,
    node,
    child: first,
    code: error.code.replace('node_', 'first_child_')
  });
}

function validateLast(node, rule) {
  if (!rule.last) {
    return null;
  }

  const last = node.nodes[node.nodes.length - 1];

  if (!last) {
    return null;
  }

  const error = validateRules(last, rule.last);

  if (!error) {
    return null;
  } // PERF


  return Object.assign({}, error, {
    rule,
    node,
    child: last,
    code: error.code.replace('node_', 'last_child_')
  });
}

function validateParent(node, child, rules) {
  // PERF: For loop is faster than for of.
  const {
    length
  } = rules;

  for (let i = 0; i < length; i++) {
    const rule = rules[i];

    if (!rule.parent) {
      continue;
    }

    if (rule.match && !testRules(child, rule.match)) {
      continue;
    }

    const error = validateRules(node, rule.parent);

    if (!error) {
      continue;
    } // PERF


    return Object.assign({}, error, {
      rule,
      parent: node,
      node: child,
      code: error.code.replace('node_', 'parent_')
    });
  }

  return null;
}

function validatePrevious(node, child, previous, index, rules) {
  if (!previous) {
    return null;
  } // PERF: For loop is faster than for of.


  const {
    length
  } = rules;

  for (let i = 0; i < length; i++) {
    const rule = rules[i];

    if (!rule.previous) {
      continue;
    }

    if (rule.match && !testRules(child, rule.match)) {
      continue;
    }

    const error = validateRules(previous, rule.previous);

    if (!error) {
      continue;
    } // PERF


    return Object.assign({}, error, {
      rule,
      node,
      child,
      index,
      previous,
      code: error.code.replace('node_', 'previous_sibling_')
    });
  }

  return null;
}

function validateNext(node, child, next, index, rules) {
  if (!next) {
    return null;
  } // PERF: For loop is faster than for of.


  const {
    length
  } = rules;

  for (let i = 0; i < length; i++) {
    const rule = rules[i];

    if (!rule.next) {
      continue;
    }

    if (rule.match && !testRules(child, rule.match)) {
      continue;
    }

    const error = validateRules(next, rule.next);

    if (!error) {
      continue;
    } // PERF


    return Object.assign({}, error, {
      rule,
      node,
      child,
      index,
      next,
      code: error.code.replace('node_', 'next_sibling_')
    });
  }

  return null;
}

function validateNodes(node, rule, rules = []) {
  if (!node.nodes) {
    return null;
  }

  const children = node.nodes;
  const defs = rule.nodes ? [...rule.nodes] : [];
  let count = 0;
  let lastCount = 0;
  let min = null;
  let index = -1;
  let def = null;
  let max = null;
  let child = null;
  let previous = null;
  let next = null;

  function nextDef() {
    if (defs.length === 0) {
      return false;
    }

    def = defs.shift();
    lastCount = count;
    count = 0;
    min = def.min || null;
    max = def.max || null;
    return true;
  }

  function nextChild() {
    index += 1;
    previous = child;
    child = children[index] || null;
    next = children[index + 1] || null;

    if (!child) {
      return false;
    }

    lastCount = count;
    count += 1;
    return true;
  }

  function rewind() {
    if (index > 0) {
      index -= 1;
      count = lastCount;
    }
  }

  if (rule.nodes) {
    nextDef();
  }

  while (nextChild()) {
    const error = validateParent(node, child, rules) || validatePrevious(node, child, previous, index, rules) || validateNext(node, child, next, index, rules);

    if (error) {
      return error;
    }

    if (rule.nodes) {
      if (!def) {
        return {
          code: 'child_unknown',
          rule,
          node,
          child,
          index
        };
      }

      if (def.match) {
        // @ts-ignore
        const err = validateRules(child, def.match);

        if (err) {
          // Since we want to report overflow on last matching child we don't
          // immediately check for count > max, but instead do so once we find
          // a child that doesn't match.
          if (max !== null && count - 1 > max) {
            rewind();
            return {
              code: 'child_max_invalid',
              rule,
              node,
              index,
              child: children[index],
              count,
              limit: max
            };
          }

          const lastMin = min; // If there are more groups after this one then child might actually
          // be valid.

          if (nextDef()) {
            // If we've already satisfied the minimum for the current group,
            // then we can rewind and proceed to the next group.
            if (lastMin === null || lastCount - 1 >= lastMin) {
              index -= 1;
              continue;
            } // Otherwise we know that current value is underflowing. There are
            // three possible causes for this...
            // 1. There might just not be enough elements for current group, and
            // current child is in fact the first of the next group. If so, the
            // next def will not report errors, in which case we can rewind and
            // report an minimum error.
            // @ts-ignore


            if (validateRules(child, def.match) === null) {
              rewind();
              return {
                code: 'child_min_invalid',
                rule,
                node,
                index,
                count: lastCount - 1,
                limit: lastMin
              };
            } // 2. The current group is underflowing, but there is also an
            // invalid child before the next group.
            // 3. Or the current group is not underflowing but it appears so
            // because there's an invalid child between its members.
            // It's either the second or third case. If it's the second then
            // we could report an underflow, but presence of an invalid child
            // is arguably more important, so we report it first. It also lets
            // us avoid checking for which case exactly is it.
            // PERF


            return Object.assign({}, err, {
              rule,
              node,
              child,
              index,
              code: err.code.replace('node_', 'child_')
            });
          } // Otherwise either we exhausted the last group, in which case it's
          // an unknown child, ...


          if (max != null && count > max) {
            return {
              code: 'child_unknown',
              rule,
              node,
              child,
              index
            };
          }

          return Object.assign({}, err, {
            rule,
            node,
            child,
            index,
            code: err.code.replace('node_', 'child_')
          });
        }
      }
    }
  } // Since we want to report overflow on last matching child we don't
  // immediately check for count > max, but do so after processing all nodes.


  if (max !== null && count > max) {
    return {
      code: 'child_max_invalid',
      rule,
      node,
      index: index - 1,
      count,
      child: children[index - 1],
      limit: max
    };
  }

  if (rule.nodes) {
    do {
      if (min !== null && count < min) {
        return {
          code: 'child_min_invalid',
          rule,
          node,
          index,
          count,
          limit: min
        };
      }
    } while (nextDef());
  }

  return null;
}

function validateRules(object, rule, rules, options = {}) {
  const {
    every = false
  } = options;

  if (Array.isArray(rule)) {
    const array = rule.length ? rule : [{}];
    let first = null; // PERF: For loop is faster than for of.

    const {
      length
    } = array;

    for (let i = 0; i < length; i++) {
      const r = array[i];
      const error = validateRules(object, r, rules);
      first = first || error;

      if (every && error) {
        return error;
      }

      if (!every && !error) {
        return null;
      }
    }

    return first;
  }

  return validateKlass(object, rule) || // @ts-ignore
  validateType(object, rule) || // @ts-ignore
  validateFirst(object, rule) || // @ts-ignore
  validateLast(object, rule) || // @ts-ignore
  validateNodes(object, rule, rules);
}

function testRules(object, rules) {
  return !validateRules(object, rules);
}

function defaultNormalize(controller, error) {
  const {
    code,
    node,
    child,
    next,
    previous
  } = error;

  switch (code) {
    case 'child_max_invalid':
    case 'child_klass_invalid':
    case 'child_type_invalid':
    case 'child_unknown':
    case 'first_child_klass_invalid':
    case 'first_child_type_invalid':
    case 'last_child_klass_invalid':
    case 'last_child_type_invalid':
      {
        return Text$1.isText(child) && Block.isBlock(node) && node.nodes.length === 1 ? controller.command(removeNodeByKey, node.key) : controller.command(removeNodeByKey, child.key);
      }

    case 'previous_sibling_klass_invalid':
    case 'previous_sibling_type_invalid':
      {
        return Text$1.isText(previous) && Block.isBlock(node) && node.nodes.length === 1 ? controller.command(removeNodeByKey, node.key) : controller.command(removeNodeByKey, previous.key);
      }

    case 'next_sibling_klass_invalid':
    case 'next_sibling_type_invalid':
      {
        return Text$1.isText(next) && Block.isBlock(node) && node.nodes.length === 1 ? controller.command(removeNodeByKey, node.key) : controller.command(removeNodeByKey, next.key);
      }

    case 'child_min_invalid':
    case 'parent_klass_invalid':
    case 'parent_type_invalid':
      {
        return Document.isDocument(node) ? node.nodes.forEach(n => controller.command(removeNodeByKey, n.key)) : controller.command(removeNodeByKey, node.key);
      }

    default:
      {
        return controller.command(removeNodeByKey, node.key);
      }
  }
}

function isOnlyContainsVoidAndEdgeSelectable(rule) {
  return !Object.keys(rule).filter(key => key !== 'isVoid' && key !== 'isEdgeSelectable').length;
}

function isOnlyContainsAtomic(rule) {
  return !Object.keys(rule).filter(key => key !== 'isAtomic').length;
}

function createNormalizationPlugin(schema) {
  const {
    rules = [],
    document,
    blocks = {},
    inlines = {},
    marks = {}
  } = schema;
  const schemaRules = [...rules];

  if (document) {
    schemaRules.push({
      match: [{
        klass: 'document'
      }],
      ...document
    });
  }

  Object.keys(blocks).filter(type => !isOnlyContainsVoidAndEdgeSelectable(blocks[type])).forEach(type => {
    schemaRules.push({
      match: [{
        klass: 'block',
        type
      }],
      ...blocks[type]
    });
  });
  Object.keys(inlines).filter(type => !isOnlyContainsVoidAndEdgeSelectable(inlines[type])).forEach(type => {
    schemaRules.push({
      match: [{
        klass: 'inline',
        type
      }],
      ...inlines[type]
    });
  });
  Object.keys(marks).filter(type => isOnlyContainsAtomic(marks[type])).forEach(type => {
    schemaRules.push({
      match: [{
        klass: 'mark',
        type
      }],
      ...marks[type]
    });
  }); // Check if a `mark` is atomic

  const isAtomicDict = Object.create(null);
  Object.keys(marks).forEach(type => {
    if ('isAtomic' in marks[type]) {
      isAtomicDict[type] = marks[type].isAtomic;
    }
  });

  function isAtomic(_, mark) {
    return isAtomicDict[mark.type];
  }

  const isVoidDict = {
    block: Object.create(null),
    inline: Object.create(null)
  };
  const isEdgeSelectableDict = {
    block: Object.create(null),
    inline: Object.create(null)
  };
  const isSideSelectableDict = Object.create(null);
  Object.keys(blocks).forEach(type => {
    if ('isVoid' in blocks[type]) {
      isVoidDict.block[type] = blocks[type].isVoid;
    }

    if ('isEdgeSelectable' in blocks[type]) {
      isEdgeSelectableDict.block[type] = blocks[type].isEdgeSelectable;
    }
  });
  Object.keys(inlines).forEach(type => {
    if ('isVoid' in inlines[type]) {
      isVoidDict.inline[type] = inlines[type].isVoid;
    }

    if ('isEdgeSelectable' in inlines[type]) {
      isEdgeSelectableDict.inline[type] = inlines[type].isEdgeSelectable;
    }

    if ('isSideSelectable' in inlines[type]) {
      isSideSelectableDict[type] = inlines[type].isSideSelectable;
    }
  }); // Check if a `node` is void.

  function isVoid(controller, node) {
    let klass = '';

    if (Block.isBlock(node)) {
      klass = 'block';
    }

    if (Inline.isInline(node)) {
      klass = 'inline';
    }

    if (!klass) {
      return undefined;
    }

    const predict = isVoidDict[klass][node.type];
    return typeof predict === 'function' ? predict(controller, node) : predict;
  } // Check if the side of `node` is selectable


  function isSideSelectable(controller, node) {
    if (Inline.isInline(node)) {
      return isSideSelectableDict[node.type];
    }

    return undefined;
  } // Check if a `node` is selectable.


  function isEdgeSelectable(_, node) {
    let klass = '';

    if (Block.isBlock(node)) {
      klass = 'block';
    }

    if (Inline.isInline(node)) {
      klass = 'inline';
    }

    if (!klass) {
      return undefined;
    }

    return isEdgeSelectableDict[klass][node.type];
  }

  function validateNode(node, controller, next) {
    const matches = schemaRules.filter(r => r.match && testRules(node, r.match));
    const error = validateRules(node, matches, schemaRules, {
      every: true
    });

    if (!error) {
      return next();
    }

    return error;
  }

  function normalizeNode(node, controller, next) {
    const error = validateNode(node, controller, () => null);

    if (!error) {
      return next();
    }

    return () => {
      const {
        rule
      } = error;
      const {
        document: $document
      } = controller.value;

      if (rule.normalize) {
        rule.normalize(controller, error);
      }

      if (controller.value.document === $document) {
        defaultNormalize(controller, error);
      }
    };
  }

  return {
    models: [],
    queries: {
      isAtomic,
      isVoid,
      isEdgeSelectable,
      isSideSelectable
    },
    validateNode,
    normalizeNode
  };
}

/**
 * @packageDocumentation
 * @ignore
 */

function isInlineOrText(node) {
  return Inline.isInline(node) || Text$1.isText(node);
}

function normalizeNode(node, controller, next) {
  if (Document.isDocument(node)) {
    // Only allow block nodes in documents.
    const length = node.nodes.length;

    for (let i = 0; i < length; i += 1) {
      const child = node.nodes[i];

      if (!Block.isBlock(child)) {
        return () => controller.command(removeNodeByKey, child.key);
      }
    }
  } else if (Block.isBlock(node) || Inline.isInline(node)) {
    const length = node.nodes.length; // Ensure that block and inline nodes have at least one text child.

    if (length < 1) {
      return () => controller.command(insertNodeByKey, node.key, 0, Text$1.create());
    } // 1. Only allow block nodes or inline and text nodes in blocks.
    // 2. Only allow inline and text nodes in inlines.


    const predicate = Block.isBlock(node) && Block.isBlock(node.nodes[0]) ? Block.isBlock : isInlineOrText;

    for (let i = 0; i < length; i += 1) {
      const child = node.nodes[i];

      if (!predicate(child)) {
        return () => controller.command(removeNodeByKey, child.key);
      } // Ensure that inline nodes are surrounded by text nodes.


      if (i === 0 && Inline.isInline(child)) {
        return () => controller.command(insertNodeByKey, node.key, 0, Text$1.create());
      }

      const next = node.nodes[i + 1];

      if (Inline.isInline(child)) {
        if (!Text$1.isText(next)) {
          return () => controller.command(insertNodeByKey, node.key, i + 1, Text$1.create());
        }
      } else if (Text$1.isText(child)) {
        // Merge adjacent text nodes.
        if (Text$1.isText(next)) {
          return () => controller.command(mergeNodeByKey, next.key);
        }
      }
    }
  }

  return next();
}

function createCoreSchemaPlugin() {
  return {
    normalizeNode
  };
}

/**
 * @packageDocumentation
 * @module Models
 */
const BATCH_UNDO_MERGE_TIME = 1000;

function shouldClear(op) {
  return op.type !== exports.OperationType.SetSelection;
}

function shouldMerge(op, prevOp) {
  if (!prevOp) return false;
  return op.type === exports.OperationType.InsertText && prevOp.type === exports.OperationType.InsertText && op.offset === prevOp.offset + prevOp.text.length && Path.isEqual(op.path, prevOp.path) || op.type === exports.OperationType.RemoveText && prevOp.type === exports.OperationType.RemoveText && op.offset + op.text.length === prevOp.offset && Path.isEqual(op.path, prevOp.path);
}

function shouldOverwrite(op, prevOp) {
  return prevOp && op.type === exports.OperationType.SetSelection && prevOp.type === exports.OperationType.SetSelection;
}

class History extends ImmutableRecord {
  static create(params) {
    return new History(params);
  }

  constructor(props = {}) {
    super();
    this.redos = void 0;
    this.undos = void 0;
    this.lastUndoCreatedTime = 0;
    this.maxHistorySize = void 0;
    const {
      redos = [],
      undos = [],
      lastUndoCreatedTime = 0,
      maxHistorySize = MAX_HISTORY_SIZE
    } = props;
    this.redos = redos;
    this.undos = undos.slice(-maxHistorySize);
    this.lastUndoCreatedTime = lastUndoCreatedTime;
    this.maxHistorySize = maxHistorySize;
    this.freeze();
  }

  merge(props) {
    return new History({
      redos: this.redos,
      undos: this.undos,
      maxHistorySize: this.maxHistorySize,
      ...props,
      lastUndoCreatedTime: this.lastUndoCreatedTime
    });
  }

  set(key, value) {
    return this.merge({
      [key]: value
    });
  }

  moveLastRedoRecordToUndos() {
    const {
      redos
    } = this;

    if (!redos.length) {
      return this;
    }

    const newRedos = redos.slice(0, -1);
    const lastRedoRecord = redos[redos.length - 1];
    const newUndos = [...this.undos, lastRedoRecord];
    return this.merge({
      undos: newUndos,
      redos: newRedos
    });
  }

  moveLastUndoRecordToRedos(undoRecord) {
    const {
      undos
    } = this;

    if (!undos.length) {
      return this;
    }

    const newUndos = undos.slice(0, -1);
    const lastUndoRecord = undoRecord || undos[undos.length - 1];
    const newRedos = [...this.redos, lastUndoRecord];
    return this.merge({
      undos: newUndos,
      redos: newRedos
    });
  }

  mergeToLastUndoIfNeed(operation, forceMerge) {
    let undos = [...this.undos];
    let lastBatch = undos[undos.length - 1];
    const lastOp = lastBatch && lastBatch[lastBatch.length - 1];
    const overwrite = shouldOverwrite(operation, lastOp);
    const merge = !!lastBatch && (this.lastUndoCreatedTime === 0 || Date.now() - this.lastUndoCreatedTime <= BATCH_UNDO_MERGE_TIME) && (shouldMerge(operation, lastOp) || overwrite);

    if (lastBatch && (merge || forceMerge)) {
      if (overwrite) {
        lastBatch = lastBatch.slice(0, -1);
      }

      lastBatch = [...lastBatch, operation];
      undos = [...undos.slice(0, -1), lastBatch];
    } else {
      const batch = [operation];
      undos = [...undos, batch];
    }

    return this.merge({
      undos,
      redos: shouldClear(operation) ? [] : this.redos
    });
  }

}

/**
 * @packageDocumentation
 * @ignore
 */
const HOTKEYS = {
  bold: 'mod+b',
  compose: ['left', 'right', 'down', 'up', 'space', 'shift?+backspace', 'shift?+enter', 'shift?+delete', 'shift?+tab'],
  moveBackward: 'left',
  moveForward: 'right',
  moveUpward: 'up',
  moveDownward: 'down',
  deleteBackward: 'shift?+backspace',
  deleteForward: 'shift?+delete',
  extendBackward: 'shift+left',
  extendForward: 'shift+right',
  extendUpward: 'shift+up',
  extendDownward: 'shift+down',
  italic: 'mod+i',
  splitBlock: 'shift?+enter',
  undo: 'mod+z',
  space: 'space',
  enter: 'enter',
  tab: 'tab',
  copy: 'mod+c',
  cut: 'mod+x',
  paste: 'mod+v'
}; // https://support.apple.com/en-us/HT201236

const APPLE_HOTKEYS = {
  selectAll: 'cmd+a',
  moveBackward: 'ctrl+b',
  moveForward: 'ctrl+f',
  moveUpward: 'ctrl+p',
  moveDownward: 'ctrl+n',
  moveWordBackward: 'opt+left',
  moveWordForward: 'opt+right',
  moveLineBackward: ['cmd+left', 'home'],
  moveLineForward: ['cmd+right', 'end'],
  moveBlockBackward: ['opt+up', 'ctrl+a'],
  moveBlockForward: ['opt+down', 'ctrl+e'],
  moveToDocumentStart: 'cmd+up',
  moveToDocumentEnd: 'cmd+down',
  deleteBackward: ['ctrl+backspace'],
  deleteForward: ['ctrl+delete', 'ctrl+d', 'fn+delete'],
  deleteLineBackward: 'cmd+shift?+backspace',
  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],
  deleteWordBackward: 'opt+shift?+backspace',
  deleteWordForward: 'opt+shift?+delete',
  extendWordBackward: 'opt+shift+left',
  extendWordForward: 'opt+shift+right',
  extendLineBackward: 'cmd+shift+left',
  extendLineForward: 'cmd+shift+right',
  extendBlockBackward: ['opt+shift+up', 'ctrl+shift+a'],
  extendBlockForward: ['opt+shift+down', 'ctrl+shift+e'],
  extendToDocumentStart: ['cmd+shift+up', 'fn+left'],
  extendToDocumentEnd: ['cmd+shift+down', 'fn+right'],
  splitBlock: 'ctrl+o',
  redo: 'cmd+shift+z',
  transposeCharacter: 'ctrl+t'
}; // https://support.microsoft.com/en-us/help/12445/windows-keyboard-shortcuts

const WINDOWS_HOTKEYS = {
  moveWordBackward: 'ctrl+left',
  moveWordForward: 'ctrl+right',
  moveLineBackward: 'home',
  moveLineForward: 'end',
  moveBlockBackward: 'ctrl+up',
  moveBlockForward: 'ctrl+down',
  moveToDocumentStart: 'ctrl+home',
  moveToDocumentEnd: 'ctrl+end',
  extendWordBackward: 'ctrl+shift+left',
  extendWordForward: 'ctrl+shift+right',
  extendLineBackward: 'shift+home',
  extendLineForward: 'shift+end',
  extendBlockBackward: 'ctrl+shift+up',
  extendBlockForward: 'ctrl+shift+down',
  selectAll: 'ctrl+a',
  deleteWordBackward: 'ctrl+shift?+backspace',
  deleteWordForward: 'ctrl+shift?+delete',
  redo: ['ctrl+y', 'ctrl+shift+z']
};

const create$1 = key => {
  const generic = HOTKEYS[key];
  const apple = APPLE_HOTKEYS[key];
  const windows = WINDOWS_HOTKEYS[key];
  const isGeneric = generic && isHotkey.isKeyHotkey(generic);
  const isApple = apple && isHotkey.isKeyHotkey(apple);
  const isWindows = windows && isHotkey.isKeyHotkey(windows);
  return event => {
    if (isGeneric && isGeneric(event)) {
      return true;
    }

    if (IS_MAC && isApple && isApple(event)) {
      return true;
    }

    if (!IS_MAC && isWindows && isWindows(event)) {
      return true;
    }

    return false;
  };
};

var hotkeys = {
  isBold: create$1('bold'),
  isCompose: create$1('compose'),
  isSelectAll: create$1('selectAll'),
  isMoveBackward: create$1('moveBackward'),
  isMoveForward: create$1('moveForward'),
  isMoveUpward: create$1('moveUpward'),
  isMoveDownward: create$1('moveDownward'),
  isDeleteBackward: create$1('deleteBackward'),
  isDeleteForward: create$1('deleteForward'),
  isDeleteLineBackward: create$1('deleteLineBackward'),
  isDeleteLineForward: create$1('deleteLineForward'),
  isDeleteWordBackward: create$1('deleteWordBackward'),
  isDeleteWordForward: create$1('deleteWordForward'),
  isExtendBackward: create$1('extendBackward'),
  isExtendForward: create$1('extendForward'),
  isExtendUpward: create$1('extendUpward'),
  isExtendDownward: create$1('extendDownward'),
  isExtendWordBackward: create$1('extendWordBackward'),
  isExtendWordForward: create$1('extendWordForward'),
  isExtendLineBackward: create$1('extendLineBackward'),
  isExtendLineForward: create$1('extendLineForward'),
  isExtendBlockBackward: create$1('extendBlockBackward'),
  isExtendBlockForward: create$1('extendBlockForward'),
  isExtendToDocumentStart: create$1('extendToDocumentStart'),
  isExtendToDocumentEnd: create$1('extendToDocumentEnd'),
  isItalic: create$1('italic'),
  isMoveWordBackward: create$1('moveWordBackward'),
  isMoveWordForward: create$1('moveWordForward'),
  isMoveLineBackward: create$1('moveLineBackward'),
  isMoveLineForward: create$1('moveLineForward'),
  isMoveBlockBackward: create$1('moveBlockBackward'),
  isMoveBlockForward: create$1('moveBlockForward'),
  isMoveToDocumentStart: create$1('moveToDocumentStart'),
  isMoveToDocumentEnd: create$1('moveToDocumentEnd'),
  isRedo: create$1('redo'),
  isSplitBlock: create$1('splitBlock'),
  isTransposeCharacter: create$1('transposeCharacter'),
  isUndo: create$1('undo'),
  isSpace: create$1('space'),
  isEnter: create$1('enter'),
  isCopy: create$1('copy'),
  isCut: create$1('cut'),
  isPaste: create$1('paste')
};

/**
 * @packageDocumentation
 * @ignore
 */
const SUPRESS_WITHOUT_SAVING_ERROR = {
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: true
};

function deserializeSelection(document, selection) {
  const {
    anchor,
    focus
  } = selection;
  return Selection.fromJSON({
    anchor: { ...anchor,
      // @ts-ignore
      key: anchor.path ? document.assertNodeByPath(anchor.path).key : anchor.key
    },
    focus: { ...focus,
      // @ts-ignore
      key: focus.path ? document.assertNodeByPath(focus.path).key : focus.key
    }
  });
}

function deserializeOperation(document, operation) {
  if (operation.type !== exports.OperationType.SetSelection) {
    return operation;
  }

  const selection = deserializeSelection(document, operation.selection);
  const prevSelection = deserializeSelection(document, operation.prevSelection);
  return { ...operation,
    selection,
    prevSelection
  };
}

function serializeSelection(document, selection) {
  const {
    anchor,
    focus
  } = selection;
  return {
    anchor: { ...anchor.toJSON(),
      path: document.getPath(anchor.key)
    },
    focus: { ...focus.toJSON(),
      path: document.getPath(focus.key)
    }
  };
}

function createHistoryPlugin(configs) {
  const maxHistorySize = configs?.history?.maxHistorySize;

  function redo(controller) {
    const {
      value
    } = controller;
    const history = value.data.history || History.create({
      maxHistorySize
    });
    const {
      redos
    } = history;

    if (!redos.length) {
      return controller;
    }

    const batch = redos[redos.length - 1];
    controller.withoutNormalizing(() => {
      controller.withoutSaving(() => {
        batch.forEach(op => {
          controller.applyOperation(deserializeOperation(controller.value.document, op));
        });
      }, SUPRESS_WITHOUT_SAVING_ERROR);
    });
    const newHistory = history.moveLastRedoRecordToUndos();
    return controller.setData({ ...value.data,
      history: newHistory
    });
  }

  function undo(controller) {
    const {
      value
    } = controller;
    const history = value.data.history || History.create({
      maxHistorySize
    });
    const {
      undos
    } = history;

    if (!undos.length) {
      return controller;
    }

    const undoRecord = [];
    controller.withoutNormalizing(() => {
      controller.withoutSaving(() => {
        const reversed = [...undos[undos.length - 1]].reverse();
        reversed.forEach(op => {
          undoRecord.unshift(undoOperation(controller, op));
          controller.applyOperation(deserializeOperation(controller.value.document, Operation.invert(op)));
        });
      }, SUPRESS_WITHOUT_SAVING_ERROR);
    });
    const newHistory = history.moveLastUndoRecordToRedos(undoRecord);
    return controller.setData({ ...value.data,
      history: newHistory
    });
  }

  function undoOperation(controller, operation) {
    if (operation.type === exports.OperationType.InsertNode) {
      const {
        document
      } = controller.value;
      return { ...operation,
        node: document.assertNodeByPath(operation.path)
      };
    }

    return operation;
  }

  function onConstruct(controller, next) {
    // @ts-ignore
    const privateApplyOperation = controller.privateApplyOperation; // @ts-ignore

    controller.privateApplyOperation = op => {
      // @ts-ignore
      if (controller.flag.saving) {
        const {
          value,
          operations
        } = controller;
        const {
          document,
          data
        } = value; // @ts-ignore

        const operation = op.type === exports.OperationType.SetSelection ? { ...op,
          selection: serializeSelection(document, op.selection),
          prevSelection: serializeSelection(document, op.prevSelection)
        } : op;
        const history = data.history || History.create({
          maxHistorySize
        });
        const newHistory = history.mergeToLastUndoIfNeed(operation, operations.length !== 0);
        const newValue = value.set('data', { ...value.data,
          history: newHistory
        });
        controller.setValue(newValue, {
          clearOperations: false,
          normalize: false,
          clearHots: false
        });
      }

      return privateApplyOperation.call(controller, op);
    };

    return next();
  }

  function onKeyDown(event, controller, next) {
    if (hotkeys.isRedo(event)) {
      event.preventDefault();
      return controller.withoutPending(ctrl => {
        return ctrl.command('redo');
      });
    }

    if (hotkeys.isUndo(event)) {
      event.preventDefault();
      return controller.withoutPending(ctrl => {
        return ctrl.command('undo');
      });
    }

    return next();
  }

  return {
    commands: {
      redo,
      undo
    },
    onConstruct,
    onKeyDown,
    models: []
  };
}

// eslint-disable-next-line import/no-extraneous-dependencies
const _createElement$l = React__namespace.createElement;
const CURSOR_BLINK_ANIMATION_TIME = 530;
const CURSOR_STYLE = {
  position: 'absolute',
  top: 0,
  left: 0,
  width: CURSOR_WIDTH,
  opacity: 1,
  zIndex: 1,
  pointerEvents: 'none',
  willChange: 'transform,height,opacity'
};

function useBlinkAnimation(cursorRef, pointStr, controller, // Placeholder Mode: disable the blink animation and add an opacity style
mode) {
  const isVisible = React__namespace.useRef(true);
  const timeout = React__namespace.useRef(null);
  const prevPoint = React__namespace.useRef(null);
  React__namespace.useLayoutEffect(() => {
    const caretNode = cursorRef.current;

    if (!caretNode || !pointStr) {
      return undefined;
    }

    if (mode === 'placeholder') {
      caretNode.style.opacity = '0.5';
      return undefined;
    }

    function toggleBackgroundColor() {
      if (caretNode) {
        // 输入过程中不闪烁
        if (controller.isPending && controller.pendingType === exports.PendingType.input) {
          caretNode.style.opacity = '1';
        } else {
          const visible = prevPoint.current !== pointStr || isVisible.current;
          caretNode.style.opacity = visible ? '1' : '0';
          isVisible.current = !visible;
        }
      }

      timeout.current = window.setTimeout(toggleBackgroundColor, CURSOR_BLINK_ANIMATION_TIME);
    }

    toggleBackgroundColor();
    prevPoint.current = pointStr;
    return () => {
      if (timeout.current) {
        clearTimeout(timeout.current);
      }
    };
  }, [pointStr, mode, controller]);
}

function LocalCaret(props) {
  const ref = React__namespace.useRef(null);
  const {
    position,
    color,
    style,
    mode,
    controller,
    selection
  } = props;
  /* https://aone.alibaba-inc.com/v2/bug/35876239# 《【0730闪会BugBash】左侧 edge selection 定位到高亮条外面去了》 */
  // 外部无法通过样式直接影响选区，需要通过 query 指定自定义偏移量

  const {
    left = 0,
    top = 0
  } = React__namespace.useMemo(() => {
    if (selection.isExpanded) {
      return {};
    }

    return controller.query('getCaretOffset', selection) || {};
  }, [selection, controller]);
  const point = selection.anchor;
  const pointStr = selection.isCollapsed ? point.viewKey : '';
  const where = point.isTextPoint() ? point.offset + controller.value.composing.length : point.edge;
  const cursorStyle = { ...CURSOR_STYLE,
    backgroundColor: color,
    height: position.height,
    ...(style || {}),
    transform: `translateX(${position.left + left}px) translateY(${position.top + top}px)`
  };
  useBlinkAnimation(ref, pointStr, controller, mode);
  return /*#__PURE__*/_createElement$l("span", {
    ref: ref,
    "data-testid": "cangjie-caret",
    "data-cangjie-caret": "true",
    "data-cangjie-point": pointStr,
    key: pointStr,
    "data-where": where,
    style: cursorStyle
  });
}

const _createElement$k = React__namespace.createElement;

const isComponentPropsEqual$1 = (prevProps, nextProps) => {
  return prevProps.isFocused === nextProps.isFocused && prevProps.isRemote === nextProps.isRemote && prevProps.color === nextProps.color && prevProps.selection === nextProps.selection && equal__default["default"](prevProps.position, nextProps.position);
}; // eslint-disable-next-line prefer-arrow-callback


var Caret = /*#__PURE__*/React__namespace.memo(function Caret(props) {
  const {
    controller,
    isRemote,
    isFocused,
    selection,
    color,
    position
  } = props;
  const {
    onBlur: showCaretOnBlur,
    onReadOnly: showCaretOnReadOnly
  } = controller.showCaret || {};

  if (selection.isExpanded) {
    return null;
  }

  if ( // 大多数情况，focused && 编辑态
  isFocused && !controller.readOnly || // blur 时，配置 showCaretOnBlur 时可以显示远程光标
  !isFocused && isRemote && showCaretOnBlur || // 只读时，配置 showCaretOnReadOnly 时可以显示远程光标
  controller.readOnly && isRemote && showCaretOnReadOnly) {
    return /*#__PURE__*/_createElement$k(React__namespace.Fragment, null, isRemote ? controller.run('renderRemoteCaret', {
      selection,
      position
    }) : controller.run('renderCaret', {
      position,
      color: color
    }));
  }

  return null;
}, isComponentPropsEqual$1);

/**
 * @packageDocumentation
 * @module Events
 */

function CangjieInputEvent(detail) {
  return new CustomEvent('cangjieInput', {
    detail
  });
}

/**
 * @packageDocumentation
 * @module domUtils
 */
/**
 * 根据浏览器的 HTML Element 获取仓颉的 Node。
 */

function findNode(element, controller) {
  const closest = findClosestInContent(element, `[${Selector.key}]`);
  if (!closest) return null;
  const key = closest.getAttribute(Selector.key);
  if (!key) return null;
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const node = document.getNode(key);
  return node || null;
}

/**
 * Detect if the cursor should be moved inside when deleting/moving at void edges
 */

function shoudStopInsideVoid(controller, direciton) {
  const isBackward = direciton === 'moveBackward';
  const {
    selection,
    document
  } = controller.value;
  const {
    anchor
  } = selection;
  const node = document.getNode(anchor.key);

  if (selection.isExpanded || !node) {
    return false;
  }

  let voidNode = null;

  if (anchor.isEdgePoint()) {
    // edge point cases, current node maybe void block
    const isBackwardCase = isBackward && anchor.edge === EdgePoint.AFTER;
    const isForwardCase = !isBackward && anchor.edge === EdgePoint.BEFORE;
    const directionHit = isBackwardCase || isForwardCase;
    const isVoid = controller.query('isVoid', node);
    voidNode = isVoid && directionHit ? node : null;
  } else if (isBackward && node.isText() && anchor.offset === 0) {
    // text cases, previous node maybe void inline
    const prev = document.getPreviousText(anchor.key);
    const parent = prev && document.getParent(prev.key);
    const isVoid = parent && controller.query('isVoid', parent);
    voidNode = isVoid && parent?.isElement() && parent.isInline() ? parent : null;
  } else if (!isBackward && node.isText() && node.text.length === anchor.offset) {
    // text cases, next node maybe void inline
    const next = document.getNextText(anchor.key);
    const parent = next && document.getParent(next.key);
    const isVoid = parent && controller.query('isVoid', parent);
    voidNode = isVoid && parent?.isElement() && parent.isInline() ? parent : null;
  }

  const point = voidNode && voidNode.getFirstText();

  if (!point) {
    return false;
  } // now we found the void, move inside!


  const newPoint = TextPoint.create({
    key: point.key,
    offset: 0
  });
  const newSelection = selection.set('anchor', newPoint).moveToAnchor();
  controller.run('onCangjieSelect', CangjieSelectEvent({
    selection: newSelection,
    trigger: direciton
  }));
  return true;
}

function perfMark(key) {
  if (typeof performance.mark === 'function') {
    performance.mark(key);
  }
}
function perfMeasure(name, start, end) {
  if (typeof performance.measure === 'function') {
    performance.measure(name, start, end);
  }
}

/**
 * @packageDocumentation
 * @ignore
 */
const _createElement$j = React__namespace.createElement;
const warn = Debug__default["default"]('EDITOR:CANGJIE:PLUGIN');

if (typeof console !== 'undefined') {
  warn.log = console.warn.bind(console);
}

const IS_TOUCH_MOBILE$1 = IS_MOBILE || IS_TOUCH_DEVICE;
function createCorePlugin() {
  function decorateNode() {
    return [];
  }

  function injectToNode() {
    return [];
  }

  function onApplyOperation(op, controller) {
    return controller.applyOperation(op);
  }

  function groupNodes([start, end], {
    parent
  }) {
    const {
      nodes
    } = parent;
    return {
      node: nodes[start],
      remainedRange: [start + 1, end]
    };
  }

  function onCopy(event, controller) {
    event.preventDefault();

    if (controller.readOnly && !controller.canCopy) {
      warn('Copy command is prohibited.');
      return;
    }

    const cangjieCopyEvent = CangjieClipboardEvent('cangjieCopy', {
      nativeEvent: event.nativeEvent
    });

    try {
      controller.run('onCangjieCopy', cangjieCopyEvent.setClipboardData(createClipboardDataFromSelection(controller)));
    } catch (error) {
      controller.run('onAction', {
        type: ACTION_COPY_FAIL,
        payload: {
          error
        }
      });
      throw error;
    }
  }

  function onCut(event, controller) {
    event.preventDefault();

    if (controller.readOnly && !controller.canCopy) {
      warn('Cut command is prohibited.');
      return;
    }

    const cangjieCutEvent = CangjieClipboardEvent('cangjieCut', {
      nativeEvent: event.nativeEvent
    });

    try {
      controller.run('onCangjieCut', cangjieCutEvent.setClipboardData(createClipboardDataFromSelection(controller)));
    } catch (error) {
      controller.run('onAction', {
        type: ACTION_CUT_FAIL,
        payload: {
          error
        }
      });
      throw error;
    }
  }

  function onPaste(event, controller) {
    event.preventDefault();
    const cangjiePasteEvent = CangjieClipboardEvent('cangjiePaste', {
      nativeEvent: event.nativeEvent
    });

    try {
      controller.run('onCangjiePaste', cangjiePasteEvent.setClipboardData(CangjieDataTransfer.create(event.clipboardData)));
    } catch (error) {
      controller.run('onAction', {
        type: ACTION_PASTE_FAIL,
        payload: {
          isShortcut: true,
          error
        }
      });
      throw error;
    }
  }

  function onCangjieFocus(controller) {
    return controller.command(focus);
  }

  function onCangjieBlur(controller) {
    return controller.command(blur);
  }

  function onCangjieInput(e, controller, next) {
    const {
      document,
      selection
    } = controller.value;
    const {
      detail
    } = e;
    const {
      type,
      data
    } = detail;

    if (type === 'insertText' && data) {
      // 在这里 flush 会导致 Android 联想状态回车后续的 splitBlock 无效
      // 但不 flush 会导致桌面端中文输入选词失效
      return controller.command(insertText$1, data);
    }

    if (type === 'compositionStart') {
      perfMark('compositionStart');

      if (selection?.isExpanded) {
        return controller.command('del');
      }

      if (selection?.isCollapsed && document.hasVoidParent(selection.anchor.key, controller)) {
        return controller.command(moveToStartOfNextText);
      }
    }

    if (type === 'deleteContentBackward') {
      if (!selection) {
        return next();
      }

      const length = (data || '').length;
      return controller.command(deleteBackwardAtRange, selection, length);
    }

    if (type === 'insertParagraph') {
      if (selection?.isCollapsed && document.hasVoidParent(selection.anchor.key, controller)) {
        const parent = document.getClosestVoid(selection.anchor.key, controller);

        if (document.getLastNode().key === selection.anchor.key && parent) {
          return controller.command(insertEmptyBlock, EdgePoint.create({
            key: parent.key,
            edge: EdgePoint.AFTER
          }));
        }

        const nextText = document.getNextText(selection.focus.key);

        if (nextText) {
          const newRange = selection.moveAnchorTo(nextText.key, 0).moveToAnchor();
          return controller.run('onCangjieSelect', CangjieSelectEvent({
            selection: newRange
          }));
        }
      }

      return controller.command(splitBlock);
    }

    return next();
  }

  function onCangjieSelect(event, controller) {
    const {
      detail
    } = event;
    const {
      selection,
      trigger
    } = detail;
    const {
      document,
      selection: prevSelection
    } = controller.value;

    if (!Selection.isValidSelection(document, selection)) {
      const selectionJSONString = JSON.stringify(selection.toJSON({
        preserveKeys: true
      }), null, 2);
      throw new Error(`Core[onCangjieSelect] receive invalid selection: ${selectionJSONString}`);
    } // 发现selection除mark外没变化则不设置
    // 这里是行为层，不是command层，做这种处理是安全的


    if (equal__default["default"](prevSelection.data, selection.data) && equal__default["default"](prevSelection.anchor, selection.anchor) && equal__default["default"](prevSelection.focus, selection.focus)) {
      return controller;
    }

    if (trigger) {
      const selectionWithData = trigger === SelectionTrigger.Selecting ? selection.merge({
        data: { ...selection.data,
          trigger
        }
      }) : selection;
      return controller.command(userSelect, selectionWithData);
    }

    return controller.command(select, selection);
  }

  function onCangjieCopy(event, controller) {
    if (!controller.canCopy) {
      warn('Copy command is prohibited.');
      return;
    }

    copyFragment(event, () => {
      if (IS_MOBILE || IS_TOUCH_DEVICE) {
        controller.command(moveToEnd);
      }
    });
  }

  function onCangjieCut(event, controller) {
    const {
      selection
    } = controller.value;

    if (!controller.canCopy) {
      warn('Cut command is prohibited.');
      return;
    }

    copyFragment(event, () => {
      // 修复移动端点击触发 copy 后，仓颉选区 collapsed，造成无法删除（iOS 12 系列及 iOS 14.6 ）
      controller.command(select, selection).command(del);
    });
  }

  function onCangjieComposingChange(composing = '', controller) {
    if (!composing.length) {
      perfMark('compositionEnd');
    }

    controller.setComposing(composing);
  }

  function onCangjiePaste(event, controller) {
    if (!event.clipboardData) {
      throw new Error('`event` is invalid, please pass clipbaord data with event.');
    }

    const transfer = getEventTransfer(event, controller);

    if (transfer.fragment) {
      controller.command(insertFragment, transfer.fragment);
      return;
    }

    if (!transfer.text) {
      return;
    }

    const texts = transfer.text.split('\n');
    texts.forEach((line, index) => {
      if (index !== 0) {
        controller.command(splitBlock);
      }

      controller.command(insertText$1, line);
    });
  }

  function onClick(e, controller, next) {
    const {
      value
    } = controller;
    const {
      document
    } = value;
    const node = findNode(e.target, controller);
    if (!node) return next();
    const ancestors = document.getAncestors(node.key);
    const isVoid = node && (controller.query('isVoid', node) || ancestors.some(a => controller.query('isVoid', a)));
    const firstText = node.getFirstText();

    if (isVoid && firstText) {
      const selection = value.selection.moveAnchorTo(firstText.key, 0).moveToAnchor();
      controller.run('onCangjieSelect', CangjieSelectEvent({
        selection
      }));
    }

    return next();
  }

  function onKeyDown(event, controller, next) {
    const {
      selection,
      document
    } = controller.value;

    if (!selection) {
      return next();
    }

    if (hotkeys.isSplitBlock(event)) {
      event.preventDefault(); // 如果光标在一个 void 元素中，则不进行 split 操作，直接移动光标到下一个 Text 节点
      // 这个行为主要用于处理 image/mention 等 inline 元素的断行问题

      return controller.run('onCangjieInput', CangjieInputEvent({
        type: 'insertParagraph',
        data: null
      }));
    }

    if (hotkeys.isDeleteBackward(event)) {
      if (IS_MOBILE) {
        // 移动端由于删除事件不准确，这里不 preventDefault，走 onChange 路径
        return;
      }

      const isProceeded = shoudStopInsideVoid(controller, 'moveBackward');
      event.preventDefault();

      if (isProceeded) {
        return controller;
      }

      return controller.command(deleteCharBackward);
    }

    if (hotkeys.isDeleteForward(event)) {
      const isProceeded = shoudStopInsideVoid(controller, 'moveForward');
      event.preventDefault();

      if (isProceeded) {
        return controller;
      }

      return controller.command(deleteCharForward);
    }

    if (hotkeys.isDeleteLineBackward(event)) {
      event.preventDefault();
      return controller.command(deleteLineBackward);
    }

    if (hotkeys.isDeleteLineForward(event)) {
      event.preventDefault();
      return controller.command(deleteLineForward);
    }

    if (hotkeys.isDeleteWordBackward(event)) {
      event.preventDefault();
      return controller.command(deleteWordBackward);
    }

    if (hotkeys.isDeleteWordForward(event)) {
      event.preventDefault();
      return controller.command(deleteWordForward);
    }

    if (hotkeys.isMoveBlockBackward(event)) {
      event.preventDefault();
      const newSelection = selection.movePointEdgeKlass(controller, 'start', 'start', 'block').moveToStart(document);
      return controller.command(select, newSelection);
    }

    if (hotkeys.isMoveBlockForward(event)) {
      event.preventDefault();
      const newSelection = selection.movePointEdgeKlass(controller, 'end', 'end', 'block').moveToEnd(document);
      return controller.command(select, newSelection);
    }

    if (hotkeys.isExtendBlockBackward(event)) {
      event.preventDefault();
      const newSelection = selection.movePointEdgeKlass(controller, 'focus', 'start', 'block');
      return controller.command(select, newSelection);
    }

    if (hotkeys.isExtendBlockForward(event)) {
      event.preventDefault();
      const newSelection = selection.movePointEdgeKlass(controller, 'focus', 'end', 'block');
      return controller.command(select, newSelection);
    }

    if (hotkeys.isCopy(event) && IS_TOUCH_MOBILE$1) {
      controller.run('onAction', {
        type: ACTION_COPY
      });
      return controller;
    }

    if (hotkeys.isCut(event) && IS_TOUCH_MOBILE$1) {
      controller.run('onAction', {
        type: ACTION_CUT
      });
      return controller;
    }

    return next();
  }

  function renderEditable(props) {
    const {
      children
    } = props;
    return children();
  }

  function renderNode(props, _, next) {
    const {
      attributes,
      node,
      children
    } = props;
    const Tag = Block.isBlock(node) ? 'div' : 'span';
    const result = next();

    if (result === null) {
      return /*#__PURE__*/_createElement$j(Tag, attributes, children());
    }

    return result;
  }

  function renderMark(props) {
    const {
      children
    } = props;
    return children();
  }

  function renderCaret({
    position,
    color
  }, controller) {
    const {
      value
    } = controller;
    const {
      document,
      selection
    } = value;

    if (!selection) {
      return null;
    }

    if (document.getClosest(selection.focus.key, node => controller.query('isVoid', node))) {
      return null;
    }

    return /*#__PURE__*/_createElement$j(LocalCaret, {
      "data-cangjie-selection": selection.viewKey,
      controller: controller,
      selection: selection,
      position: position,
      color: color
    });
  }

  function selectionColor(controller) {
    const {
      isFocused
    } = controller.value;
    return isFocused ? CANGJIE_SELECTION_COLOR : CANGJIE_SELECTION_INACTIVE_COLOR;
  }

  function isEditorBusy(controller) {
    // OP Pending 或热区过程中
    if (controller.isPending) {
      return true;
    } // 输入法输入过程中


    if (controller.value.composing) {
      return true;
    }

    return false;
  }

  function onCleanup(controller, next) {
    if (CONTROLLER_TO_KEY_DOM.has(controller)) {
      // weakmap的value是map,引用到了dom
      const map = CONTROLLER_TO_KEY_DOM.get(controller);
      map && Object.keys(map).forEach(key => {
        map?.delete(key);
      });
      CONTROLLER_TO_KEY_DOM.delete(controller);
    }

    return next();
  }

  function mapOperation(op) {
    return op;
  }

  function isElementInGroup(controller, element, group) {
    return true;
  }

  return {
    queries: {
      selectionColor,
      isEditorBusy,
      isElementInGroup
    },
    decorateNode,
    injectToNode,
    groupNodes,
    onApplyOperation,
    onCangjieFocus,
    onCangjieBlur,
    onCangjieInput,
    onCangjieSelect,
    onCangjieCopy,
    onCangjieCut,
    onCangjiePaste,
    onCangjieComposingChange,
    onClick,
    onCopy,
    onCut,
    onKeyDown,
    onPaste,
    onCleanup,
    renderEditable,
    renderContent: renderEditable,
    renderNode,
    renderMark,
    renderCaret,
    mapOperation,
    models: []
  };
}

const createMapOperations = (gen, uuidKey, getUUIDs) => {
  function generateUUID(node, diff) {
    const uuids = getUUIDs();
    const uuid = node.data[uuidKey]; // 如果无 UUID，或者 UUID 重复，则需要重新创建 UUID

    if (!uuid || uuids[uuid]) {
      const newUUID = gen();
      uuids[newUUID] = node.key;
      diff.adds.push({
        uuid: newUUID,
        key: node.key
      });
      return node.merge({
        data: { ...node.data,
          [uuidKey]: newUUID
        }
      });
    }

    return node;
  }

  const genUUIDForTree = (root, diff) => {
    const newRoot = root.mapDescendants(n => {
      if (n.isElement()) {
        return generateUUID(n, diff);
      }

      return n;
    });
    return generateUUID(newRoot, diff);
  };

  const adjustSetNodeOperation = (op, document) => {
    const uuids = getUUIDs();
    const {
      properties,
      prevProperties,
      path
    } = op;
    const node = document.assertElementByPath(path);
    /* istanbul ignore next */

    const data = properties.data || {};
    /* istanbul ignore next */

    const prevData = prevProperties.data || {};
    const theUUID = data[uuidKey];
    const thePrevUUID = prevData[uuidKey];
    return tsPattern.match({
      uuid: theUUID,
      prevUUID: thePrevUUID,
      reset: theUUID !== thePrevUUID
    }).with( // 若设置节点时，丢失 UUID，则写回 UUID
    {
      uuid: tsPattern.P.nullish,
      prevUUID: tsPattern.P.not(tsPattern.P.nullish)
    }, ({
      prevUUID
    }) => ({
      op: { ...op,
        properties: { ...properties,
          data: { ...data,
            [uuidKey]: prevUUID
          }
        }
      },
      diff: {
        adds: [],
        removes: [],
        updates: []
      }
    })).with( // 若设置节点时，UUID 不重复，则允许生成
    {
      uuid: tsPattern.P.when(id => id && !uuids[id]),
      prevUUID: tsPattern.P.not(tsPattern.P.nullish),
      reset: true
    }, ({
      uuid,
      prevUUID
    }) => {
      return {
        op,
        diff: {
          adds: [],
          removes: [],
          updates: [{
            oldUUID: prevUUID,
            newUUID: uuid
          }]
        }
      };
    }).with( // 若设置节点时，UUID 重复，则重新生成 UUID
    {
      uuid: tsPattern.P.when(id => id && uuids[id] !== node.key),
      prevUUID: tsPattern.P.not(tsPattern.P.nullish),
      reset: true
    }, ({
      prevUUID
    }) => {
      const newUUID = gen();
      return {
        op: { ...op,
          properties: { ...properties,
            data: { ...data,
              [uuidKey]: newUUID
            }
          }
        },
        diff: {
          adds: [],
          removes: [],
          updates: [{
            oldUUID: prevUUID,
            newUUID
          }]
        }
      };
    }).with( // 设置不含有 UUID 的节点时，若新的属性缺失 UUID，则生成 UUID
    {
      uuid: tsPattern.P.nullish,
      prevUUID: tsPattern.P.nullish
    }, // 设置不含有 UUID 的节点时，若新的属性有 UUID，但重复，则生成 UUIID
    {
      uuid: tsPattern.P.when(id => uuids[id] && uuids[id] !== node.key),
      prevUUID: tsPattern.P.nullish
    }, () => {
      const newUUID = gen();
      return {
        op: { ...op,
          properties: { ...properties,
            data: { ...data,
              [uuidKey]: newUUID
            }
          }
        },
        diff: {
          adds: [{
            uuid: newUUID,
            key: node.key
          }],
          removes: [],
          updates: []
        }
      };
    }).with( // 设置不含有 UUID 的节点时，若新的属性中含有不重复的 UUID，允许生成
    {
      uuid: tsPattern.P.when(id => id && !uuids[id]),
      prevUUID: tsPattern.P.nullish
    }, ({
      uuid
    }) => {
      return {
        op,
        diff: {
          adds: [{
            uuid,
            key: node.key
          }],
          removes: [],
          updates: []
        }
      };
    })
    /* istanbul ignore next */
    .otherwise(() => ({
      op,
      diff: {
        adds: [],
        removes: [],
        updates: []
      }
    }));
  };

  const adjustRemoveNodeOperation = op => {
    const {
      node
    } = op;

    if (node.isElement() && node.data[uuidKey]) {
      const uuid = node.data[uuidKey];
      return {
        op,
        diff: {
          adds: [],
          removes: [uuid],
          updates: []
        }
      };
    }

    return {
      op,
      diff: {
        adds: [],
        removes: [],
        updates: []
      }
    };
  };

  const adjustInsertNodeOperation = op => {
    const {
      node
    } = op;
    const diff = {
      adds: [],
      removes: [],
      updates: []
    };

    if (node.isElement()) {
      return {
        op: { ...op,
          node: genUUIDForTree(node, diff)
        },
        diff
      };
    }

    return {
      op,
      diff
    };
  };

  return function mapOperation(operation, document) {
    return tsPattern.match(operation).with({
      type: exports.OperationType.RemoveNode
    }, op => adjustRemoveNodeOperation(op)).with({
      type: exports.OperationType.SetNode
    }, op => adjustSetNodeOperation(op, document)).with({
      type: exports.OperationType.InsertNode
    }, op => adjustInsertNodeOperation(op)).otherwise(op => ({
      op,
      diff: {
        adds: [],
        removes: [],
        updates: []
      }
    }));
  };
};

const createUUIDQuery = uuidKey => (_, node) => {
  return node.data[uuidKey];
};
function createGetNodeKeyByUUID(getUUIDS) {
  const getNodeKeyByUUID = (_, uuid) => {
    const uuids = getUUIDS();
    return uuids[uuid];
  };

  return getNodeKeyByUUID;
}

function getUUIDSFromDocument(document, uuidKey) {
  const uuids = {};
  const duplications = [];
  document.forEachDescendant(desendant => {
    if (desendant.isElement() && desendant.data[uuidKey]) {
      const uuid = desendant.data[uuidKey];

      if (uuids[uuid]) {
        duplications.push(desendant.key);
      } else {
        uuids[uuid] = desendant.key;
      }
    }
  });
  return {
    uuids,
    duplications
  };
}

function toKeyUUIDMap(map) {
  return Object.keys(map).reduce((ret, uuid) => {
    ret[map[uuid]] = uuid;
    return ret;
  }, {});
}

function diffUUIDS(a, b) {
  const aKeyToUUIDMap = toKeyUUIDMap(a);
  const bKeyToUUIDMap = toKeyUUIDMap(b);
  const diff = {
    adds: [],
    removes: [],
    updates: []
  };
  Object.keys(aKeyToUUIDMap).forEach(nodeKey => {
    const aUUID = aKeyToUUIDMap[nodeKey];
    const bUUID = bKeyToUUIDMap[nodeKey];

    if (aUUID !== bUUID) {
      diff.updates.push({
        oldUUID: aUUID,
        newUUID: bUUID
      });
    }

    if (!bKeyToUUIDMap[nodeKey]) {
      diff.removes.push(aUUID);
    }
  });
  Object.keys(bKeyToUUIDMap).forEach(nodeKey => {
    if (!aKeyToUUIDMap[nodeKey]) {
      diff.adds.push({
        uuid: bKeyToUUIDMap[nodeKey],
        key: nodeKey
      });
    }
  });
  return diff;
}
function isEmptyDiff(diff) {
  return !diff.adds.length && !diff.removes.length && !diff.updates.length;
}

const UPDATE_UUIDS = Symbol('update_uuids');
const GENERATE_UUID = Symbol('generate_uuid');
function updateUUIDs(payload) {
  return {
    type: UPDATE_UUIDS,
    payload
  };
}
function isUpdateUUIDs(action) {
  return action.type === UPDATE_UUIDS;
}
function generateUUID(payload) {
  return {
    type: GENERATE_UUID,
    payload
  };
}
function isGenerateUUID(action) {
  return action.type === GENERATE_UUID;
}
const actions = {
  updateUUIDs,
  generateUUID
};
const isActions = {
  isUpdateUUIDs,
  isGenerateUUID
};

function setNodeUUID(controller, node, uuid, uuidKey) {
  return controller.withoutSaving(() => {
    controller.command('setNodeByKey', node.key, {
      type: node.type,
      data: { ...node.data,
        [uuidKey]: uuid
      }
    });
  });
}
function createGenerateUUID(gen, uuidKey) {
  return function generateUUID(controller, node) {
    if (node.isElement() && !node.data[uuidKey]) {
      const uuid = gen();
      controller.command(setNodeUUID, node, uuid, uuidKey);
    }

    return controller;
  };
}

function onAction$1(action, controller, next) {
  const isGenerateUUID = controller.isActionFactory('isGenerateUUID');

  if (isGenerateUUID?.(action)) {
    return controller.command('generateUUID', action.payload.node);
  }

  return next();
}

const DEFAULT_UUID_KEY = '__uuid__';

function createUUIDPlugin(config) {
  // 初始化 UUID 映射
  let uuids = {};

  function getUUIDS() {
    return uuids;
  }

  const uuidKey = config.uuidKey || DEFAULT_UUID_KEY;

  function regenerateDuplicateUUIDS(controller, value) {
    const befores = { ...getUUIDS()
    };
    const ret = getUUIDSFromDocument(value.document, uuidKey); // 为重复的 id 重新生成 uuid

    const newUUIDS = ret.duplications.reduce((ids, key) => {
      const element = value.document.assertElement(key);
      const uuid = config.gen();
      controller.command(setNodeUUID, element, uuid, uuidKey);
      ids[uuid] = key;
      return ids;
    }, ret.uuids);
    const diff = diffUUIDS(befores, newUUIDS);

    if (!isEmptyDiff(diff)) {
      uuids = newUUIDS;
      controller.dispatch('updateUUIDs', {
        // Immutable，防止外部改动了 uuid
        uuids: { ...newUUIDS
        },
        diff
      });
    }
  }

  const mapOperation = createMapOperations(config.gen, uuidKey, getUUIDS);
  return {
    actions,
    isActions,
    commands: {
      generateUUID: createGenerateUUID(config.gen, uuidKey)
    },
    onConstruct: (controller, next) => {
      regenerateDuplicateUUIDS(controller, controller.value);
      return next();
    },
    onResetValue: (value, _, controller, next) => {
      regenerateDuplicateUUIDS(controller, value);
      return next();
    },
    onAction: onAction$1,
    mapOperation: (operation, controller, next) => {
      const {
        op,
        diff
      } = mapOperation(operation, controller.value.document);

      if (isEmptyDiff(diff)) {
        return op;
      }

      diff.removes.forEach(uuid => {
        delete uuids[uuid];
      });
      diff.adds.forEach(({
        uuid,
        key
      }) => {
        uuids[uuid] = key;
      });
      diff.updates.forEach(({
        oldUUID,
        newUUID
      }) => {
        const nodeKey = uuids[oldUUID];
        uuids[newUUID] = nodeKey;
        delete uuids[oldUUID];
      });
      controller.dispatch('updateUUIDs', {
        // Immutable，防止外部改动了 uuid
        uuids: { ...uuids
        },
        diff
      });
      return next(op);
    },
    queries: {
      uuid: createUUIDQuery(uuidKey),
      anchor: createUUIDQuery(uuidKey),
      getNodeKeyByUUID: createGetNodeKeyByUUID(getUUIDS)
    }
  };
}

const TOGGLE_GROUP_FOLD = Symbol('toggleGroupFold');
const FOLD_GROUP = Symbol('fold');
const EXPAND_GROUP = Symbol('expand');

/**
 * 折叠/展开分组
 * @param key
 * @returns
 */
function toggleGroupFold(key) {
  return {
    type: TOGGLE_GROUP_FOLD,
    payload: {
      key
    }
  };
}
/**
 * 折叠分组
 * @param key
 * @returns
 */

function fold(key) {
  return {
    type: FOLD_GROUP,
    payload: {
      key
    }
  };
}
/**
 * 展开分组
 * @param key
 * @returns
 */

function expand(key) {
  return {
    type: EXPAND_GROUP,
    payload: {
      key
    }
  };
}

var groupActions = /*#__PURE__*/Object.freeze({
  __proto__: null,
  TOGGLE_GROUP_FOLD: TOGGLE_GROUP_FOLD,
  FOLD_GROUP: FOLD_GROUP,
  EXPAND_GROUP: EXPAND_GROUP,
  toggleGroupFold: toggleGroupFold,
  fold: fold,
  expand: expand
});

const onAction = (action, controller, next) => {
  const {
    type,
    payload
  } = action;
  const {
    groupManager
  } = controller;

  if (type === TOGGLE_GROUP_FOLD || type === FOLD_GROUP || type === EXPAND_GROUP) {
    const {
      key
    } = payload;
    const group = groupManager.getGroup(key);

    if (group) {
      if (type === TOGGLE_GROUP_FOLD) {
        groupManager.mergeGroupData(key, {
          [GROUP_COLLAPSED_KEY]: !group.data[GROUP_COLLAPSED_KEY]
        });
        return controller;
      } else {
        groupManager.mergeGroupData(key, {
          [GROUP_COLLAPSED_KEY]: type === FOLD_GROUP
        });
        return controller;
      }
    }
  }

  return next();
};

const renderNode$1 = (props, controller, next) => {
  return next();
};

const renderGroup = (props, controller, next) => {
  const group = next();
  return group;
};

const onResetValue = (_value, _controllerValue, controller, next) => {
  controller.groupManager.generateAllGroups().notifyNewGroups();
  return next();
};

const createGroupPlugin = () => ({
  onAction,
  renderNode: renderNode$1,
  renderGroup,
  onResetValue
});

/**
 * @packageDocumentation
 * @ignore
 */
let Status;
/**
 * WARN: Sometimes request idle callback in Safari will never be called!
 */

(function (Status) {
  Status["Idle"] = "Idle";
  Status["Pending"] = "Pending";
  Status["Canceled"] = "Canceled";
  Status["Done"] = "Done";
})(Status || (Status = {}));

/**
 * 默认的 flush 类型
 */
const DEFAULT_FLUSH_TYPE = 'microtask';
/**
 * flush 最大等待时间（100ms 是为了保证常规情况下反馈不会过长，同时大文档在连续情况下每隔 100ms 做一次渲染也能保障流畅度）
 * @description 浏览器的调度有时候会将线程长时间闲置，导致 flush 延迟过高
 * @example 一个典型的例子是当滚动区域触发一个滑动后，光标的再次点击，使浏览器的线程调度闲置（具体原因还在研究中）
 */

const FLUSH_MAX_WAIT = 100;

/**
 * 是否支持 idleCallback
 */
const IS_SUPPORT_IDLE_TASK = typeof window === 'object' && 'requestIdleCallback' in window && 'cancelIdleCallback' in window;
/**
 * 是否支持 animationFrame
 */

const IS_SUPPORT_FRAME_TASK = typeof window === 'object' && 'requestAnimationFrame' in window && 'cancelAnimationFrame' in window;
/**
 * 决议能够使用的 flushType
 * @param flushType 需要的 flushType
 */

function resolveSupportedType(flushType) {
  if (flushType === 'microtask') {
    return 'microtask';
  }

  if (flushType === 'idletask') {
    if (IS_SUPPORT_IDLE_TASK) {
      return 'idletask';
    } else if (IS_SUPPORT_FRAME_TASK) {
      return 'frametask';
    }
  }

  if (flushType === 'frametask' && IS_SUPPORT_FRAME_TASK) {
    return 'frametask';
  }

  return 'microtask';
}

class FlushTask {
  static create(task, options) {
    return new FlushTask(task, options);
  }
  /**
   * 等待执行的微任务
   */


  constructor(task, options = {}) {
    this.task = void 0;
    this.status = Status.Idle;
    this.resolved = false;
    this.flushType = void 0;
    this.supportedFlushType = void 0;
    this.taskId = -1;
    this.task = task;
    const {
      flushType = DEFAULT_FLUSH_TYPE
    } = options;
    this.flushType = flushType;
    this.supportedFlushType = resolveSupportedType(flushType);
  }

  start() {
    this.status = Status.Pending;

    if (!this.resolved) {
      this.requestTask();
      this.resolved = true;
    }

    return this;
  }

  cancel() {
    this.status = Status.Canceled;
    this.cancelTask();
    return this;
  }

  getStatus() {
    return this.status;
  }

  requestTask() {
    if (this.supportedFlushType === 'idletask') {
      this.taskId = window.requestIdleCallback(() => this.run(), {
        timeout: FLUSH_MAX_WAIT
      });
    } else if (this.supportedFlushType === 'frametask') {
      this.taskId = window.requestAnimationFrame(() => this.run());
    } else {
      Promise.resolve().then(() => this.run());
    }
  }

  cancelTask() {
    if (this.supportedFlushType === 'idletask') {
      window.cancelIdleCallback(this.taskId);
    } else if (this.supportedFlushType === 'frametask') {
      window.cancelAnimationFrame(this.taskId);
    }
  }

  run() {
    if (this.status === Status.Pending && typeof this.task === 'function') {
      this.task.call(null);
      this.status = Status.Done;
    }
  }

}

/**
 * @packageDocumentation
 * @ignore
 */

function isChild(item) {
  return 'child' in item;
}

function isRangeStart(item) {
  return 'start' in item;
}

function isRangeEnd(item) {
  return 'end' in item;
}

function isEdgeAfter(edgePoint, edgePath, nodePath) {
  return edgePoint.isEdgePoint() && edgePoint.edge === EdgePoint.AFTER && (Path.isEqual(edgePath, nodePath) || Path.isAncestor(edgePath, nodePath));
}

function isEdgeBefore(edgePoint, edgePath, nodePath) {
  return edgePoint.isEdgePoint() && edgePoint.edge === EdgePoint.BEFORE && (Path.isEqual(edgePath, nodePath) || Path.isAncestor(edgePath, nodePath));
}

function sort(a, b) {
  if (a.order > b.order) {
    return 1;
  } else if (a.order === b.order) {
    return isRangeEnd(b) ? 1 : -1;
  }

  return -1;
}

function getChildrenDecorations(document, node, decorations) {
  const childrenDecorations = []; // 初始化排序数组，先放入节点子孙

  const orderArray = node.nodes.map((child, index) => ({
    child,
    order: index
  }));
  const nodePath = document.assertPath(node.key);
  const depth = nodePath.length;
  const last = node.nodes.length - 1; // 遍历 decorations，将其放入排序数组

  decorations.forEach(decoration => {
    const {
      start: startPoint,
      end: endPoint
    } = decoration;
    const startPath = document.getPath(startPoint.key);
    const endPath = document.getPath(endPoint.key);

    if (!startPath || !endPath) {
      return;
    }

    if (Path.isAfter(startPath, nodePath) || Path.isBefore(endPath, nodePath)) {
      return;
    } // 获得 decoration 相对于 node children 的起始位置


    const start = Path.isBefore(startPath, nodePath) ? 0 : startPath[depth];
    const end = Path.isAfter(endPath, nodePath) ? last : endPath[depth];
    orderArray.push({
      start: true,
      range: decoration,
      order: start - 0.5
    });
    orderArray.push({
      end: true,
      range: decoration,
      order: end + 0.5
    });
  });
  const activeDecorations = new Set();
  orderArray.sort(sort).forEach(item => {
    if (isRangeStart(item)) {
      activeDecorations.add(item.range);
    } else if (isRangeEnd(item)) {
      activeDecorations.delete(item.range);
    } else if (isChild(item)) {
      childrenDecorations.push(Array.from(activeDecorations));
    }
  });
  return childrenDecorations;
}
function getChildrenIsSelected(document, node, selection) {
  const childrenIsSelected = node.nodes.map(() => false);

  if (selection.isCollapsedAtEdge) {
    return childrenIsSelected;
  }

  const {
    start: startPoint,
    end: endPoint
  } = selection.sort(document);
  const startPath = document.getPath(startPoint.key);
  const endPath = document.getPath(endPoint.key);

  if (!startPath || !endPath) {
    return childrenIsSelected;
  }

  const nodePath = document.assertPath(node.key);

  if (Path.isAfter(startPath, nodePath) || isEdgeAfter(startPoint, startPath, nodePath)) {
    return childrenIsSelected;
  }

  if (Path.isBefore(endPath, nodePath) || isEdgeBefore(endPoint, endPath, nodePath)) {
    return childrenIsSelected;
  }

  const depth = nodePath.length;
  const last = node.nodes.length - 1;
  const start = Path.isBefore(startPath, nodePath) || isEdgeBefore(startPoint, startPath, nodePath) ? 0 : startPath[depth];
  const end = Path.isAfter(endPath, nodePath) || isEdgeAfter(endPoint, endPath, nodePath) ? last : endPath[depth];

  for (let i = start; i <= end; i += 1) {
    childrenIsSelected[i] = true;
  }

  return childrenIsSelected;
}

/**
 * @packageDocumentation
 * @ignore
 */
function getChildrenInjections(document, node, injections) {
  const nodePath = document.assertPath(node.key);
  const depth = nodePath.length;
  const childInjections = node.nodes.map(() => []);
  injections.forEach(injection => {
    const path = document.getPath(injection.key);

    if (path) {
      const index = path[depth];
      const injects = childInjections[path[depth]];

      if (index >= 0 && injects) {
        injects.push(injection);
      }
    }
  });
  return childInjections;
}

const CONTEXT_SPLIT = '@';
function getContexts(context) {
  return context ? context.split(CONTEXT_SPLIT) : [];
}
function getContextMeta(context) {
  if (typeof context !== 'string') {
    return null;
  }

  const matched = context.match(/\((.*?)\)$/);

  if (matched) {
    try {
      return JSON.parse(matched[1]);
    } catch {
      return null;
    }
  }

  return null;
}

var opContext = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CONTEXT_SPLIT: CONTEXT_SPLIT,
  getContexts: getContexts,
  getContextMeta: getContextMeta
});

class Observable {
  constructor() {
    this.linkHead = null;
  }

  subscribe(observer) {
    const link = {
      next: this.linkHead,
      prev: null,
      element: observer
    };

    if (this.linkHead) {
      this.linkHead.prev = link;
    }

    this.linkHead = link;
    return {
      unsubscribe: () => {
        if (link.next) {
          link.next.prev = link.prev;
        }

        if (link.prev) {
          link.prev.next = link.next;
        } else {
          this.linkHead = link.next;
        }
      }
    };
  }

  onData(data) {
    let link = this.linkHead;

    while (link) {
      link.element(data);
      link = link.next;
    }
  }

}
class Subject extends Observable {
  constructor() {
    super();
  }

  next(data) {
    this.onData(data);
  }

}
class ReplaySubject extends Observable {
  constructor(max = 1) {
    super();
    this.replays = [];
    this.max = void 0;
    this.max = max;
  }

  subscribe(observer) {
    const sub = super.subscribe(observer);
    this.replays.forEach(data => {
      observer(data);
    });
    return sub;
  }

  next(data) {
    this.onData(data);

    if (this.replays.length === this.max) {
      this.replays.shift();
    }

    this.replays.push(data);
  }

}

const isSetSelection = ({
  operation
}) => operation && operation.type === exports.OperationType.SetSelection;

function getSelectionData(controller) {
  const {
    document,
    selection
  } = controller.value;
  const blocks = selection.isCollapsedAtEdge ? [document.getNode(selection.anchor.key)] : document.getLeafBlocksAtRange(selection);
  const isHideSelection = controller.query('isHideSelection');
  return {
    range: selection,
    blocksKeys: new Set(blocks.map(b => b.key)),
    isHideSelection
  };
}
const isSelect = params => {
  const {
    ops,
    controller
  } = params;

  if (ops.length === 0) {
    return false;
  } // 从 blur 状态开始选区（点选/拖选），会有个先 focus 再 set_selction 的过程，可以 pending


  return ops.every((op, index) => {
    if (index === 0) {
      return op.key === 'isFocused' && controller.value.isFocused || isSetSelection(op);
    }

    return isSetSelection(op);
  });
};
const getPending$2 = ({
  controller
}) => ({
  type: exports.PendingType.selection,
  effect: () => {
    controller.selectionData$.next(getSelectionData(controller));
  }
});
const pattern$1 = [isSelect, getPending$2];

function isInsertTextOperation(op) {
  return op !== null && op.type === exports.OperationType.InsertText;
}

function isRemoveTextOperation(op) {
  return op !== null && op.type === exports.OperationType.RemoveText;
}

function isInsertOrRemove(operation) {
  return (isInsertTextOperation(operation) || isRemoveTextOperation(operation)) && operation.text.length === 1;
}

function isSetSelectionOperation(op) {
  return op !== null && op.type === exports.OperationType.SetSelection;
}

function isContinuousOp(prevOp, operation) {
  // @ts-ignore
  if (!Path.isEqual(operation.path, prevOp.path)) {
    return false;
  }

  if (isInsertTextOperation(prevOp) && isInsertTextOperation(operation)) {
    return operation.offset === prevOp.offset + prevOp.text.length;
  } else if (isInsertTextOperation(prevOp) && isRemoveTextOperation(operation)) {
    return operation.offset === prevOp.offset + prevOp.text.length - operation.text.length;
  } else if (isRemoveTextOperation(prevOp) && isInsertTextOperation(operation)) {
    return operation.offset === prevOp.offset;
  } else if (isRemoveTextOperation(prevOp) && isRemoveTextOperation(operation)) {
    return operation.offset === prevOp.offset - operation.text.length;
  }

  return false;
}

function isContinuousInput(ops) {
  const operations = ops.filter(({
    operation
  }) => !operation || !isSetSelectionOperation(operation));

  if (!operations.length) {
    return false;
  }

  const operationsWithoutComposing = operations.filter(({
    key
  }) => key !== 'composing');
  return operationsWithoutComposing.every(({
    operation
  }, index) => {
    if (!isInsertOrRemove(operation)) {
      return false;
    }

    if (index === 0) {
      return true;
    }

    const {
      operation: prevOp
    } = operationsWithoutComposing[index - 1];
    return !prevOp || isContinuousOp(prevOp, operation);
  });
}
/**
 * 是否为连续输入
 * @param params
 * @returns
 */


const isTextInput = params => {
  const {
    ops
  } = params;
  return isContinuousInput(ops);
};

const shouldAppend = (prevOps, ops) => {
  // 找到最后一个非 set_selection op，做连续性比较
  const {
    operation: prevOp
  } = lodash.last(prevOps.filter(({
    key,
    operation
  }) => key !== 'composing' && !isSetSelectionOperation(operation))) || {};
  const {
    operation
  } = ops.find(({
    key,
    operation
  }) => key !== 'composing' && !isSetSelectionOperation(operation)) || {};
  return !prevOp || !operation || isContinuousOp(prevOp, operation);
};

const getPending$1 = ({
  controller
}) => ({
  type: exports.PendingType.input,
  decorate: ops => {
    const {
      operation,
      value
    } = ops.find(({
      operation
    }) => !isSetSelectionOperation(operation));

    if (operation === null) {
      // NOTE: operation is composing, need to get meta from controller.value
      const {
        selection,
        document
      } = controller.value;
      const {
        key,
        offset
      } = selection.focus;
      return {
        key,
        startOffset: offset,
        startPath: document.getPath(key)
      };
    }

    const {
      path,
      offset
    } = operation;
    const text = value.document.getNodeByPath(path);
    return {
      key: text.key,
      startPath: path,
      startOffset: offset
    };
  },
  effect: (ops, ctx) => {
    ops.forEach(({
      operation
    }) => {
      // send input op
      if (isSetSelectionOperation(operation)) {
        return;
      }

      controller.inputData$.next({
        key: ctx.key,
        startPath: ctx.startPath,
        startOffset: ctx.startOffset
      });
    });
    controller.selectionData$.next(getSelectionData(controller));
  },
  shouldAppend
});

const pattern = [isTextInput, getPending$1];

var getPending = lodash.cond([pattern, pattern$1, [lodash.stubTrue, () => null]]);

class PendingQueue {
  static create(props) {
    return new PendingQueue(props);
  }

  constructor(props) {
    this.operations = [];
    this.pending = null;
    this.ctx = void 0;
    this.pendingGetter = void 0;
    this.debouncedFlush = void 0;
    this.controller = void 0;
    this.value = null;
    this.enablePending = void 0;

    this.flush = () => {
      this.controller.flush();
      this.clear();
    };

    const {
      debounceTime,
      controller,
      pendingGetter = getPending,
      enablePending
    } = props;
    this.pendingGetter = pendingGetter;
    this.controller = controller;
    this.debouncedFlush = lodash.debounce(this.flush, debounceTime);

    if (typeof enablePending === 'boolean') {
      this.enablePending = Object.values(exports.PendingType).reduce((result, key) => {
        result[key] = enablePending;
        return result;
      }, {});
    } else {
      this.enablePending = enablePending;
    }
  }

  get shouldDebouncedFlush() {
    // 需要周期性倾倒 pending queue 需满足以下条件之一：
    // 1. 如果驻留有 operation
    // 2. 如果驻留有堆 isFocused 的设置
    return this.operations.some(({
      operation,
      key
    }) => operation !== null || key === 'isFocused');
  }

  run(operations) {
    const {
      effect
    } = this.pending;
    this.value = this.controller.value;
    effect(operations, this.ctx);

    if (this.shouldDebouncedFlush) {
      this.debouncedFlush();
    }
  }

  isType(type) {
    return this.pending?.type === type;
  }

  get type() {
    return this.pending?.type;
  }

  queue(operations) {
    const params = {
      controller: this.controller,
      ops: operations
    };
    const pending = this.pendingGetter(params);

    if (!pending || !this.enablePending[pending.type]) {
      // 若 operations 不可 pending，则立即倾倒
      this.flush();
      this.controller.dispatchPendingTerminal();
    } else {
      const {
        decorate = () => null,
        shouldAppend = () => true,
        type
      } = pending;

      if (this.isType(type) && shouldAppend(this.operations, operations)) {
        // 如果是同类型且可合并的 pending，则合并
        Array.prototype.push.apply(this.operations, operations);
        this.run(operations);
      } else if (!this.pending) {
        // 如果 pending queue 不存在 pending 对象，则创建
        this.pending = pending;
        this.ctx = decorate(operations);
        this.operations = operations;
        this.run(operations);
      } else {
        // 若产生了不能合并的 pending，则立即倾倒 pending queue
        this.flush();
        this.controller.dispatchPendingTerminal();
      }
    }

    return this;
  }

  clear() {
    this.pending = null;
    this.operations = [];
    this.debouncedFlush.cancel();
    return this;
  }

  isEmpty() {
    return this.size() === 0;
  }

  size() {
    return this.operations.length;
  }

}

function setInjection(controller, node, data) {
  const {
    injections
  } = controller.value;
  const curInjection = injections.find(inj => inj.key === node.key) || {};
  const injection = Injection.create({
    key: node.key,
    data: { ...(curInjection.data || {}),
      ...data
    }
  });
  controller.setInjections([...injections.filter(inj => inj.key !== node.key), injection]);
}
function deleteInjection(controller, node, keys) {
  const {
    injections
  } = controller.value;
  const curInjection = injections.find(inj => inj.key === node.key) || {};
  const nextData = lodash.omit(curInjection.data, keys);
  const nextInjections = injections.filter(inj => inj.key !== node.key);

  if (!lodash.isEmpty(nextData)) {
    const injection = Injection.create({
      key: node.key,
      data: nextData
    });
    nextInjections.push(injection);
  }

  controller.setInjections(nextInjections);
}

class UserDataManager {
  constructor(controller) {
    this.update$ = new Subject();
    this.controller = void 0;
    this.localData = {};

    this.flush = ops => {
      this.updateNodes(ops);
      this.refreshData(ops);
    };

    this.mergeUserData = target => {
      const {
        uid,
        value
      } = this.controller;
      const {
        document
      } = value;
      const {
        userData
      } = document.data;
      const {
        userData: targetData
      } = target.data;

      if (uid && targetData?.[uid]) {
        const uuids = Object.keys(targetData[uid]);

        if (uuids.length > 0) {
          const data = omitDeepBy({ ...document.data,
            userData: { ...(userData || {}),
              [uid]: { ...(userData?.[uid] || {}),
                ...targetData[uid]
              }
            }
          }, isEmptyObj);

          if (data.userData !== document.data.userData) {
            return this.controller.withOpContext(`userdata/${uid}/${uuids.join(',')}`, () => {
              this.controller.command(setNodeByKey, document.key, {
                data
              });
            });
          }
        }
      }

      return this.controller;
    };

    this.controller = controller;
  }

  get(node, key) {
    if (Element$1.isElement(node)) {
      const {
        uid
      } = this.controller;
      const uuid = node.data?.uuid;
      const nData = node.data[key];

      if (uid && uuid) {
        const {
          userData
        } = this.controller.value.document.data;
        const uData = userData?.[uid]?.[uuid]?.[key];
        const lData = this.localData?.[uid]?.[uuid]?.[key];
        return lData ?? uData ?? nData;
      }

      return nData;
    }

    return undefined;
  }

  set(node, properties) {
    if (Element$1.isElement(node)) {
      const {
        uid,
        value
      } = this.controller;
      const {
        document
      } = value;
      const {
        userData
      } = document.data;
      const uuid = node.data?.uuid;

      if (uid && uuid) {
        // 有 uid 和 uuid，设置用户数据
        const data = omitDeepBy({ ...document.data,
          userData: this.mergeProperties(userData, uid, uuid, properties)
        }, isEmptyObj);

        if (data.userData !== document.data.userData) {
          return this.controller.withOpContext(`userdata/${uid}/${uuid}`, () => {
            this.controller.command(setNodeByKey, document.key, {
              data
            });
          });
        }
      } else {
        // 设置 node.data 数据
        const n = document.getNode(node?.key);

        if (n && Element$1.isElement(n)) {
          const data = { ...n.data,
            ...properties
          };

          if (!lodash.isEqual(data, n.data)) {
            return this.controller.withOpContext(`userdata`, () => {
              this.controller.command(setNodeByKey, n.key, {
                data
              });
            });
          }
        }
      }
    }

    return this.controller;
  }

  setLocal(node, properties) {
    if (Element$1.isElement(node)) {
      const {
        uid
      } = this.controller;
      const uuid = node.data?.uuid;

      if (uid && uuid) {
        this.localData = this.mergeProperties(this.localData, uid, uuid, properties);
        this.update$.next({
          uuid
        });
      } else {
        setInjection(this.controller, node, properties);
      }
    }

    return this.controller;
  }

  delete(node, keys) {
    if (Element$1.isElement(node)) {
      const uuid = node.data?.uuid;
      const {
        uid,
        value
      } = this.controller;
      const {
        document
      } = value;
      const {
        userData
      } = document.data;

      if (uid && uuid) {
        const data = omitDeepBy({ ...document.data,
          userData: this.deleteProperties(userData, uid, uuid, keys)
        }, isEmptyObj);

        if (data.userData !== document.data.userData) {
          return this.controller.withOpContext(`userdata/${uid}/${uuid}`, () => {
            this.controller.command(setNodeByKey, document.key, {
              data
            });
          });
        }
      } else {
        // 删除 node.data 数据
        const n = document.getNode(node?.key);

        if (n && Element$1.isElement(n)) {
          const data = lodash.omit(n.data, keys);

          if (!lodash.isEqual(data, n.data)) {
            return this.controller.withOpContext(`userdata`, () => {
              this.controller.command(setNodeByKey, n.key, {
                data
              });
            });
          }
        }
      }
    }

    return this.controller;
  }

  deleteLocal(node, keys) {
    if (Element$1.isElement(node)) {
      const {
        uid
      } = this.controller;
      const uuid = node.data?.uuid;

      if (uid && uuid) {
        this.localData = this.deleteProperties(this.localData, uid, uuid, keys);
        this.update$.next({
          uuid
        });
      } else {
        deleteInjection(this.controller, node, keys);
      }
    }

    return this.controller;
  }

  refreshData(ops) {
    // 根据 OP 类型，刷新 document.data 上数据
    const {
      value
    } = this.controller;
    const {
      document
    } = value;
    const {
      userData: originData
    } = document.data;
    const uuids = [];
    const uids = Object.keys(originData || {});
    let userData = originData;
    ops.forEach(op => {
      // op 是删除节点，将 document.data 中对应数据也删除
      if (op.type === 'remove_node' && Element$1.isElement(op.node) && !/merge_node|split_node/.test(op.context || '')) {
        // 遍历节点及子节点
        const iterator = node => {
          const uuid = node.data?.uuid;

          if (Element$1.isElement(node) && uuid) {
            uids.forEach(uid => {
              userData = this.deleteData(userData, uid, uuid);
            });

            if (userData !== originData) {
              uuids.push(uuid);
            }
          }
        };

        iterator(op.node);
        op.node.forEachDescendant(iterator);
      }
    }); // 批量更新

    if (uuids.length) {
      const data = omitDeepBy({ ...document.data,
        userData
      }, isEmptyObj);
      this.controller.withOpContext(`userdata/*/${uuids.join(',')}`, () => {
        this.controller.command(setNodeByKey, document.key, {
          data
        });
      });
    }
  }

  updateNodes(ops) {
    ops.forEach(op => {
      // update$.next 刷新节点视图
      const {
        context
      } = op;

      if (op.type === 'set_node') {
        const matched = context?.match(/userdata\/(.*)\/(.*)/);

        if (matched) {
          // context 上携带此次修改用户数据的 uid 和块 uuid
          const uid = matched[1];
          const uuids = matched[2].split(',');

          if (uid === this.controller.uid || uid === '*') {
            uuids.forEach(uuid => uuid && this.update$.next({
              uuid
            }));
          }
        }
      }
    });
  }

  mergeProperties(data, uid, uuid, properties) {
    return { ...(data || {}),
      [uid]: { ...(data?.[uid] || {}),
        [uuid]: { ...(data?.[uid]?.[uuid] || {}),
          ...properties
        }
      }
    };
  }

  deleteData(data, uid, uuid) {
    if (data?.[uid]?.[uuid] !== undefined) {
      // 删除对应 uuid 下所有数据
      return { ...data,
        [uid]: lodash.omit(data?.[uid], uuid)
      };
    }

    return data || {};
  }

  deleteProperties(data, uid, uuid, keys) {
    if (typeof data?.[uid]?.[uuid] === 'object') {
      // 对应 block uuid 下有数据，去除相应 keys 属性
      return { ...data,
        [uid]: { ...data?.[uid],
          [uuid]: lodash.omit(data?.[uid]?.[uuid], keys)
        }
      };
    }

    return data || {};
  }

}

let PerfType;

(function (PerfType) {
  PerfType["input"] = "input";
  PerfType["composing"] = "composing";
  PerfType["selection"] = "selection";
})(PerfType || (PerfType = {}));

/**
 * @packageDocumentation
 * @module Events
 */
function CangjiePerfEvent(detail) {
  return new CustomEvent('cangjiePerf', {
    detail: {
      dropped: false,
      ...detail
    }
  });
}

function isTextOp(operation) {
  return [exports.OperationType.InsertText, exports.OperationType.RemoveText, exports.OperationType.AddMark, exports.OperationType.RemoveMark, exports.OperationType.SetMark].includes(operation.type);
}

function getHotAmongNodes(srcNodes, newDoc) {
  return srcNodes.map(srcNode => {
    if (!srcNode) {
      return null;
    } // 如果操作节点在新的内容无法找到，则不继续查找其热区


    const node = newDoc.getNode(typeof srcNode === 'string' ? srcNode : srcNode.key);

    if (!node) {
      return null;
    }

    return Block.isBlock(node) ? node : newDoc.getClosest(node.key, node => Block.isBlock(node));
  }).filter(node => !!node).map(node => ({
    node: node,
    path: newDoc.assertPath(node.key)
  }));
}

function getHotsAtRange(range, afterChangeDoc, ancestorPath = []) {
  let blocks = [];

  if (Path.isRoot(ancestorPath)) {
    blocks = afterChangeDoc.getRootBlocksAtRange(range);
  } else {
    const ancestor = afterChangeDoc.assertNodeByPath(ancestorPath);
    const {
      start,
      end
    } = range.convertToTextPoints(afterChangeDoc);
    const startBlock = ancestor.getFurthsest(start.key, Block.isBlock);

    if (!startBlock) {
      return [];
    }

    if (start.key === end.key) {
      return [{
        node: startBlock,
        path: afterChangeDoc.assertPath(startBlock.key)
      }];
    }

    const endBlock = ancestor.getFurthsest(end.key, Block.isBlock);

    if (!endBlock) {
      return [];
    }

    blocks = ancestor.nodes.slice(ancestor.nodes.indexOf(startBlock), ancestor.nodes.indexOf(endBlock) + 1);
  }

  return blocks.map(node => {
    return {
      node,
      path: afterChangeDoc.assertPath(node.key)
    };
  });
}

function getOpHots(op, controller) {
  const {
    operation,
    key,
    value,
    newValue
  } = op;
  const {
    document: beforeChangeDoc
  } = value;
  const {
    document: afterChangeDoc
  } = newValue;
  const {
    document: newDoc
  } = controller.value;
  /* 增量变更热区 */

  if (operation) {
    // 文本类型的操作，热区为当前文本所在容器
    if (isTextOp(operation)) {
      const {
        path
      } = operation;
      const text = beforeChangeDoc.assertNodeByPath(path);
      const newText = newDoc.getNode(text.key);
      return getHotAmongNodes([newText], newDoc);
    } // 节点子孙的变更：插入/删除/分裂/合并，热区为变更所在的节点
    else if (operation.type === exports.OperationType.InsertNode || operation.type === exports.OperationType.RemoveNode || operation.type === exports.OperationType.SplitNode || operation.type === exports.OperationType.MergeNode) {
        const {
          path
        } = operation;
        const parent = beforeChangeDoc.assertNodeByPath(Path.parent(path));
        return getHotAmongNodes([parent], newDoc);
      } // 设置节点
      // 1. 若改变节点内容
      //   a. 若变更不影响分组，则热区为被设置的节点
      //   b. 若变更影响分组，则热区设置为上游节点
      // 2. 若改变节点类型，可能影响上游分组，热区为设置节点的 parent
      else if (operation.type === exports.OperationType.SetNode) {
          const {
            path,
            properties,
            prevProperties
          } = operation;

          if (properties.type !== prevProperties.type) {
            return getHotAmongNodes([beforeChangeDoc.assertNodeByPath(Path.parent(path))], newDoc);
          }

          return getHotAmongNodes([beforeChangeDoc.assertNodeByPath(path)], newDoc);
        } // 移动节点，热区为：
        // 1. 起始节点的 parent
        // 2. 结束节点的 parent
        else if (operation.type === exports.OperationType.MoveNode) {
            const {
              path,
              newPath
            } = operation;
            return getHotAmongNodes([beforeChangeDoc.assertNodeByPath(Path.parent(path)), beforeChangeDoc.assertNodeByPath(Path.parent(newPath))], newDoc);
          } // 设置选区，热区为跨越选区的所有最高层 block
          else if (operation.type === exports.OperationType.SetSelection) {
              const {
                selection,
                prevSelection
              } = operation;
              return getHotsAtRange(prevSelection, afterChangeDoc).concat(getHotsAtRange(selection, afterChangeDoc));
            }
  } else {
    /* 全量变更热区 */
    // 输入法的热区为输入法所在文本的容器
    if (key === 'composing') {
      return getHotAmongNodes([value.startText], newDoc);
    } // focus 状态不影响热区


    if (key === 'isFocused') {
      return 'ignore';
    } // injections 变更，找到变更前后的受影响的节点所在的热区


    if (key === 'injections') {
      return getHotAmongNodes([...lodash.difference(newValue.injections, value.injections), ...lodash.difference(value.injections, newValue.injections)].map(inj => inj.key), newDoc);
    } // decorations 变更，找到变更前后受影响的区间所在的热区


    if (key === 'decorations') {
      return [...lodash.difference(newValue.decorations, value.decorations), ...lodash.difference(value.decorations, newValue.decorations)].map(decoration => Selection.create({
        anchor: decoration.start,
        focus: decoration.end
      })).reduce((hots, range) => {
        hots.push(...getHotsAtRange(range, afterChangeDoc));
        return hots;
      }, []);
    }
  }

  return [];
}
/**
 * 如果在 hots 找到祖先或者自己，则不再添加
 * @param path
 * @returns
 */


function isExistedHot(path, searchTable) {
  const ancestorsAndSelf = Path.ancestors(path).slice(1);
  ancestorsAndSelf.push(path);
  return ancestorsAndSelf.some(p => searchTable.has(p.join(',')));
}
/**
 * 获得变更热区
 * @param srcOps
 * @param controller
 * @returns
 */


function getHots(srcOps, controller) {
  try {
    const ops = srcOps.filter(({
      operation
    }) => !operation || operation.type !== 'set_selection'); // 所有热区

    const all = []; // 去重热区，仅保留最高级祖先

    const uniq = [];
    /**
     * 用于 hots 去重的查找表
     * ```
     * {
     *   '0,1,0': true,
     *   '1,0': true,
     * }
     * ```
     */

    const searchTable = new Set();

    for (let i = 0; i < ops.length; i++) {
      const op = ops[i];
      const hots = getOpHots(op, controller);

      if (hots === 'ignore') {
        continue;
      } // 如果任意 op 未找到热区，即变更影响了全局，提前返回


      if (!hots.length) {
        return [];
      }

      all.push(...hots);
    }

    const {
      selection: prevSelection,
      document: prevDocument
    } = srcOps[0].value;
    const {
      selection,
      document
    } = controller.value; // 选区发生变更时，计算热区

    if (prevSelection !== selection) {
      // 获得变更前选区所在的节点
      const prevSelectionIn = prevSelection.getClosestNode(prevDocument);
      const prevSelectionInPath = prevDocument.assertPath(prevSelectionIn.key);
      const selectionIn = selection.getClosestNode(document);
      const selectionInPath = document.assertPath(selectionIn.key);
      const ancestor = Path.common(prevSelectionInPath, selectionInPath); // 如果在同节点移动，热区仅放入新选区所在的节点

      if (Path.isEqual(prevSelectionInPath, selectionInPath)) {
        all.push({
          node: selectionIn,
          path: selectionInPath
        });
      } // 如果是平层移动，放入老/新选区所在的节点
      else if (Path.isSibling(prevSelectionInPath, selectionInPath)) {
          all.push({
            node: prevSelectionIn,
            path: prevSelectionInPath
          });
          all.push({
            node: selectionIn,
            path: selectionInPath
          });
        } // 否则放入新老选区各自所在的，直到公共祖先的节点，保证节点子树每个节点的选中态都符合预期
        else {
            all.push(...getHotsAtRange(prevSelection, document, ancestor));
            all.push(...getHotsAtRange(selection, document, ancestor));
          }
    }

    all.sort((a, b) => a.path.length - b.path.length);
    all.forEach(hot => {
      if (!isExistedHot(hot.path, searchTable)) {
        uniq.push(hot);
        searchTable.add(hot.path.join(','));
      }
    });
    return uniq;
  } catch (_e) {
    // 热区计算失败时，清空热区
    return [];
  }
}
const FIELD_SHOULD_NOT_BREAK_PENDING = ['decorations', 'injections', 'remoteSelections', 'selection'];
/**
 * 是否是文本输入
 * @param context
 * @returns
 */

function isInputing(context) {
  const {
    operations,
    value
  } = context;

  if (value.selection.isExpanded) {
    return false;
  }

  const rest = operations.filter(operation => {
    return operation.operation || !FIELD_SHOULD_NOT_BREAK_PENDING.includes(operation.key);
  });

  if (!rest.length) {
    return false;
  } // PERF: for-loop


  const opsLen = rest.length;
  let path = null;

  for (let i = 0; i < opsLen; i++) {
    const {
      operation
    } = rest[i];

    if (!operation) {
      return false;
    }

    if (operation.type === 'set_selection') {
      continue;
    }

    const op = operation;

    if (!path) {
      path = op.path;
    } // 在同一个文本连续输入/删除时，可以 pending


    if (op.type !== 'insert_text' && op.type !== 'remove_text' || !Path.isEqual(path, op.path)) {
      return false;
    }
  }

  return true;
}
/**
 * 是否是设置选区
 * @param context
 * @returns
 */

function isSelecting(context) {
  return context.operations.every(({
    operation,
    key
  }, index) => {
    if (index === 0 && !operation) {
      return key === 'isFocused' && context.value.isFocused;
    }

    return operation && operation.type === 'set_selection';
  });
}
/**
 * 是否在输入法
 * @param context
 * @returns
 */

function isComposing(context) {
  const {
    composing
  } = context.value;
  return !!composing.length;
}
/**
 * 对于需要以动画速率运行的变更，周期性倾倒：
 * 1. 输入/删除文本
 * 2. 拖动选区
 *
 * ```plaintext
 *    +-------+       +-------+      +-------+     +-------+     +-------+
 *    |   h   |       |   e   |      |   l   |     |   l   |     |   o   |
 *    +-------+       +-------+      +-------+     +-------+     +-------+
 *        |               |              |             |             |
 *        v               v              v             v             v
 *    .-------.       .-------.      .-------.     .-------.     .-------.
 *   (  flush  )     (  flush  )    (  flush  )   (  flush  )   (  flush  )
 *    `-------'       `-------'      `-------'     `-------'     `-------'
 *
 *                                        |
 *                                        |
 *                                 debounced flush
 *                                        |
 *                                        v
 * + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
 *    +-------+       +-------+      +-------+     +-------+     +-------+
 * |  |   h   |       |   e   |      |   l   |     |   l   |     |   o   | |
 *    +-------+       +-------+      +-------+     +-------+     +-------+
 * + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
 *                                                                   |
 *                                                                   v
 *                                                               .-------.
 *                                                              (  flush  )
 *                                                               `-------'
 * ```
 * @param context
 * @returns
 */

const shouldDebounceFlush = lodash.cond([[isSelecting, () => exports.PendingType.selection], [isInputing, () => exports.PendingType.input], [lodash.stubTrue, () => null]]);
/**
 * 对于输入法等类型的临时变更，不进行 flush
 *
 * ```plaintext
 *  +-------+      +-------+     +-------+
 *  |   n   |      |   i   |     |   你   |
 *  +-------+      +-------+     +-------+
 *      |              |             |
 *      v              v             v
 *  .-------.      .-------.     .-------.
 * (  flush  )    (  flush  )   (  flush  )
 *  `-------'      `-------'     `-------'
 *
 *                      |
 *                      |
 *               suppress flush
 *                      |
 *                      v
 *                  +-------+
 *                  |   你   |
 *                  +-------+
 *                      |
 *                      v
 *                  .-------.
 *                 (  flush  )
 *                  `-------'
 * ```
 * @param context
 * @returns
 */

const shouldSuppressFlush = lodash.cond([[isComposing, () => exports.PendingType.input], [lodash.stubTrue, () => null]]);

const EVENTS_SET = new Set(EVENTS);
function isEventHandler(name) {
  return EVENTS_SET.has(name);
}

const DEFAULT_BUFFER_RANGE = 500;
const BLOCK_DEFAULT_MIN_HEIGHT = 25;
const DEFAULT_SCROLL_THROTTLE_INTERVAL = 50;
const DEFAULT_FIRST_PAINT_BLOCK_SIZE = 10;

/**
 * 循环查询元素
 * @param selector query 函数
 * @param remain 剩余时间
 */
function waitForElementByAnimationFrame(selector, remain = 1000) {
  const start = Date.now();
  return new Promise((resolve, reject) => {
    if (remain < 0) {
      if (typeof selector === 'function') {
        return reject(`waitForElementByAnimationFrame: element wait timeout`);
      }

      return reject(`waitForElementByAnimationFrame： ${selector} wait timeout`);
    }

    const element = typeof selector === 'function' ? selector() : window.document.querySelector(selector);

    if (element) {
      return resolve(element);
    } else {
      window.requestAnimationFrame(() => {
        const cost = Date.now() - start;
        const nextRemain = remain - cost;
        waitForElementByAnimationFrame(selector, nextRemain).then(resolve).catch(reject);
      });
    }
  });
}
function scrollContainerIsTop(scrollContainer) {
  return scrollContainer === document.body || scrollContainer === document.documentElement || scrollContainer === window;
}
function checkArrayAHasElementNotIncludedInArrayB(arrayA, arrayB) {
  return arrayA.some(arrayAElement => {
    return !arrayB.includes(arrayAElement);
  });
}

function formatMarginFromStyle(margin) {
  const result = parseFloat(margin);

  if (isNaN(result)) {
    return 0;
  }

  return result;
}

function measureBlockInfo(element) {
  // offsetHeight 一定是正数, boundingClientRect 可能是小数，和 mutationObserver 的对应
  const boundingClientRect = element.getBoundingClientRect();
  const computedStyle = window.getComputedStyle(element); // TODO: 专门为节点搞一个隐藏态，隐藏前的高度也记录，而非直接变 0

  const isVisible = computedStyle.display !== 'none';
  return {
    height: isVisible ? boundingClientRect.height : 0,
    marginTop: isVisible ? formatMarginFromStyle(computedStyle?.marginTop) : 0,
    marginBottom: isVisible ? formatMarginFromStyle(computedStyle?.marginBottom) : 0
  };
}
function calculateViewPort(scrollElement, scrollContainer, bufferRange, editorContainerToScrollContainerDistance, _viewPortStartY) {
  let {
    scrollTop
  } = scrollElement;

  if (scrollContainer === document.documentElement && scrollTop === 0 && document.body.scrollTop > 0) {
    scrollTop = document.body.scrollTop;
  }

  const viewPortStartY = typeof _viewPortStartY === 'number' ? _viewPortStartY : scrollTop - editorContainerToScrollContainerDistance;
  const viewPortEndY = viewPortStartY + (scrollContainerIsTop(scrollContainer) ? window.innerHeight : scrollContainer.offsetHeight);
  const bufferStartY = Math.max(0, viewPortStartY - bufferRange);
  const bufferEndY = viewPortEndY + bufferRange;
  return {
    viewPortStartY,
    viewPortEndY,
    bufferStartY,
    bufferEndY
  };
}
/**
 * 计算编辑器容器到最近的滚动容器的距离
 * 编辑器容器是各种计算的原点，而视口是基于滚动容器
 * 在滚动容器高度发生变化时需要重算，典型场景是 插入封面
 * 检测这个变化非常难，目前想到两种方案，一是开发者手动触发，二是 scrollContainer 下包一层大容器，监听这个容器高度的变化
 */

function calculateEditorContainerToScrollContainerDistance(editorContainer, scrollContainer, scrollElement, scrollContainerIsBody) {
  const editorContainerRect = editorContainer.getBoundingClientRect();
  const scrollContainerRect = scrollElement.getBoundingClientRect();
  const editorContainerStyle = window.getComputedStyle(editorContainer);
  const editorContainerToScrollContainerDistance = scrollContainerIsBody ? editorContainerRect.top - scrollContainerRect.top : editorContainerRect.top - scrollContainerRect.top + scrollElement.scrollTop;
  return editorContainerToScrollContainerDistance + formatMarginFromStyle(editorContainerStyle.paddingTop) + formatMarginFromStyle(editorContainerStyle.borderTopWidth);
}
function calculateExpectedLayoutInfo(bufferStartY, bufferEndY, viewStartY, view, nodeManager) {
  const nodeSize = view.nodes.length;
  let accHeight = 0;
  let lastMarginBottom = 0;
  let expectedBufferStartBlockFound = false;
  let expectedViewStartBlockFound = false;
  let expectedBufferEndBlockFound = false;
  let expectedBufferStartBlockOffset = 0;
  let expectedViewStartBlockOffset = 0;
  let expectedBufferEndBlockOffset = nodeSize - 1;
  let expectedBufferStartBlockY = 0;
  let expectedViewStartBlockY = 0;
  let expectedBufferEndBlockY = 0;

  for (let i = 0; i < nodeSize; i++) {
    const block = view.nodes[i];
    const cachedBlockProps = nodeManager.getCachedBlockPropsByKey(block.key);
    const {
      height: inputHeight,
      marginTop: inputMarginTop,
      marginBottom: inputMarginBottom
    } = cachedBlockProps || {};
    const marginTop = typeof inputMarginTop === 'number' ? inputMarginTop > lastMarginBottom ? inputMarginTop - lastMarginBottom : 0 : 0;
    const height = typeof inputHeight === 'number' ? inputHeight : BLOCK_DEFAULT_MIN_HEIGHT;
    const marginBottom = typeof inputMarginBottom === 'number' ? inputMarginBottom : 0;
    lastMarginBottom = marginBottom;
    const lastAccHeight = accHeight;
    accHeight += marginTop + height + marginBottom;

    if (!expectedBufferStartBlockFound && (lastAccHeight < bufferStartY || i === 0) && accHeight >= bufferStartY) {
      expectedBufferStartBlockFound = true;
      expectedBufferStartBlockOffset = i;
      expectedBufferStartBlockY = lastAccHeight;
    }

    if (!expectedViewStartBlockFound && (lastAccHeight < viewStartY || i === 0) && accHeight >= viewStartY) {
      expectedViewStartBlockFound = true;
      expectedViewStartBlockOffset = i;
      expectedViewStartBlockY = lastAccHeight;
    }

    if (!expectedBufferEndBlockFound && lastAccHeight < bufferEndY && accHeight >= bufferEndY) {
      expectedBufferEndBlockFound = true;
      expectedBufferEndBlockOffset = i;
      expectedBufferEndBlockY = accHeight;
    }
  }

  if (!expectedBufferEndBlockFound) {
    expectedBufferEndBlockY = accHeight;
    expectedBufferEndBlockOffset = nodeSize;
  }

  if (!expectedViewStartBlockFound) {
    expectedViewStartBlockOffset = nodeSize - 1;
  } // 极端情况，例如划到评论框，远远超出视口范围


  if (!expectedBufferEndBlockFound && !expectedBufferStartBlockFound) {
    if (bufferEndY < 0) {
      expectedBufferEndBlockOffset = -1;
      expectedBufferStartBlockOffset = -1;
      expectedBufferStartBlockY = 0;
      expectedBufferEndBlockY = 0;
    } else {
      expectedBufferEndBlockOffset = nodeSize;
      expectedBufferStartBlockOffset = nodeSize;
      expectedBufferStartBlockY = accHeight;
      expectedBufferEndBlockY = accHeight;
    }
  }

  return {
    expectedBufferStartBlockOffset,
    expectedViewStartBlockOffset,
    expectedBufferEndBlockOffset,
    expectedBufferStartBlockY,
    expectedViewStartBlockY,
    expectedBufferEndBlockY,
    accHeight
  };
}
function calculateBlockStartYByBlockIndex(blockIndex, view, nodeManager, includeLastMarginBottom = false) {
  let accHeight = 0;
  let lastMarginBottom = 0;

  for (let i = 0; i < blockIndex; i++) {
    const block = view.nodes[i];
    const cachedBlockProps = nodeManager.getCachedBlockPropsByKey(block.key);
    const {
      height: inputHeight,
      marginTop: inputMarginTop,
      marginBottom: inputMarginBottom
    } = cachedBlockProps || {};
    const marginTop = typeof inputMarginTop === 'number' ? inputMarginTop > lastMarginBottom ? inputMarginTop - lastMarginBottom : 0 : 0;
    const height = typeof inputHeight === 'number' ? inputHeight : BLOCK_DEFAULT_MIN_HEIGHT;
    const marginBottom = typeof inputMarginBottom === 'number' ? inputMarginBottom : 0;
    lastMarginBottom = marginBottom;
    accHeight += marginTop + height + (includeLastMarginBottom || i < blockIndex - 1 ? marginBottom : 0);
  }

  return accHeight;
}
const fastDiffOnValueChange = (prevView, currView, startBlockKey, startBlockOffset, endBlockOffset) => {
  if (prevView === currView) {
    return {
      type: 'equal'
    };
  }

  const oldStartKeyNewPath = currView.getPath(startBlockKey);

  if (!(oldStartKeyNewPath && oldStartKeyNewPath.length === 1)) {
    return {
      type: 'changed'
    };
  }

  const startKeyOffsetChange = oldStartKeyNewPath[0] - startBlockOffset;

  for (let i = startBlockOffset + 1; i <= endBlockOffset; i++) {
    const prevBlock = prevView.nodes[i];
    const currBlock = currView.nodes[i + startKeyOffsetChange];

    if (prevBlock?.key !== currBlock?.key) {
      return {
        type: 'changed'
      };
    }
  }

  if (startKeyOffsetChange === 0) {
    if (endBlockOffset >= prevView.nodes.length - 1 && currView.nodes[endBlockOffset + 1]) {
      return {
        type: 'changed'
      };
    }

    return {
      type: 'equal'
    };
  } // 用户视口在顶端，且在文章之前插入节点的情况


  if (startBlockOffset === 0 && startKeyOffsetChange > 0) {
    return {
      type: 'changed'
    };
  }

  return {
    type: 'translation',
    offset: startKeyOffsetChange
  };
};
function calculateBlockKeysNeedToMeasure(view, _prevView, layoutInfoResult, prevLayoutInfoResult) {
  const {
    expectedBufferStartBlockOffset,
    expectedBufferEndBlockOffset
  } = layoutInfoResult;
  const prevView = _prevView || view;

  if (!prevLayoutInfoResult) {
    return view.nodes.map(node => node.key).slice(expectedBufferStartBlockOffset, expectedBufferEndBlockOffset + 1);
  }

  const {
    expectedBufferStartBlockOffset: prevExpectedBufferStartBlockOffset,
    expectedBufferEndBlockOffset: prevExpectedBufferEndBlockOffset
  } = prevLayoutInfoResult; // 当内容没有变化时，使用更快的算法

  if (prevView === view) {
    if (expectedBufferStartBlockOffset < prevExpectedBufferStartBlockOffset) {
      const endIndex = Math.min(expectedBufferEndBlockOffset + 1, prevExpectedBufferStartBlockOffset);
      return view.nodes.map(node => node.key).slice(expectedBufferStartBlockOffset, endIndex);
    } else if (expectedBufferEndBlockOffset > prevExpectedBufferEndBlockOffset) {
      const startIndex = Math.max(expectedBufferStartBlockOffset, prevExpectedBufferEndBlockOffset + 1);
      return view.nodes.map(node => node.key).slice(startIndex, expectedBufferEndBlockOffset + 1);
    }

    return [];
  } else {
    const prevVisibleKeys = prevView.nodes.slice(prevExpectedBufferStartBlockOffset, prevExpectedBufferEndBlockOffset + 1).map(node => node.key);
    const currentVisibleKeys = view.nodes.slice(expectedBufferStartBlockOffset, expectedBufferEndBlockOffset + 1).map(node => node.key);
    const newBlockKeys = [];
    currentVisibleKeys.forEach(key => {
      if (!prevVisibleKeys.includes(key)) {
        newBlockKeys.push(key);
      }
    });
    return newBlockKeys;
  }
}

class NodeManager {
  constructor(options) {
    this.controller = void 0;
    this.blockCacheByKey = new Map();
    this.blockKeyQueue = [];
    const {
      controller
    } = options;
    this.controller = controller;
  }

  getCachedBlockPropsByKey(key) {
    return this.blockCacheByKey.get(key);
  }

  gc() {
    const {
      view
    } = this.controller;
    const viewTopBlockLength = view.nodes.length;

    if (this.blockKeyQueue.length > viewTopBlockLength) {
      const gcBlockKeyQueue = this.blockKeyQueue.splice(0, this.blockKeyQueue.length - viewTopBlockLength);
      gcBlockKeyQueue.forEach(key => {
        this.blockCacheByKey.delete(key);
      });
    }
  }

  setCachedBlockPropsByKey(key, blockInfo) {
    const prevBlockInfo = this.blockCacheByKey.get(key);
    this.blockCacheByKey.set(key, { ...prevBlockInfo,
      ...blockInfo
    });
    var index = this.blockKeyQueue.indexOf(key);

    if (index !== -1) {
      this.blockKeyQueue.splice(index, 1);
    }

    this.blockKeyQueue.push(key);
    this.gc();
    return;
  }

  loadMeasureResult(measureResults) {
    const document = this.controller.view;

    for (const key in measureResults) {
      const prevBlockInfo = this.blockCacheByKey.get(key) || {
        key,
        persistStateNode: []
      };
      const measureResult = measureResults[key];
      const block = document.getNode(key);
      const blockInfo = { ...prevBlockInfo,
        ...measureResult,
        key,
        uuid: block?.data?.uuid
      };
      this.setCachedBlockPropsByKey(key, blockInfo);
    }
  }

  getVirtualizePersistState(key) {
    const blockCache = this.blockCacheByKey.get(key);

    if (!blockCache?.persistStateNode) {
      return [];
    }

    return blockCache.persistStateNode;
  }

  updateVirtualizePersistState(key, topBlockKey, shouldPersistState) {
    const blockCache = this.getCachedBlockPropsByKey(topBlockKey);
    const persistStateNode = blockCache?.persistStateNode?.slice() || [];
    const keyIndex = persistStateNode.indexOf(key);

    if (shouldPersistState && keyIndex === -1) {
      persistStateNode.push(key);
    }

    if (!shouldPersistState && keyIndex >= 0) {
      persistStateNode.splice(keyIndex, 1);
    }

    this.setCachedBlockPropsByKey(topBlockKey, { ...blockCache,
      key: topBlockKey,
      persistStateNode
    });
  }

}

class OutputManager {
  // 暂时以 offset 为标准
  constructor(options) {
    this.controller = void 0;
    this.nodeManager = void 0;
    this.firstPaintBlockSize = void 0;
    this.startBlockOffset = void 0;
    this.endBlockOffset = void 0;
    this.startBlockKey = void 0;
    this.endBlockKey = void 0;
    this.startViewBlockOffset = 0;
    this.beforePlaceholderHeight = 0;
    this.afterPlaceholderHeight = 0;
    const {
      nodeManager,
      controller,
      firstPaintBlockSize
    } = options;
    this.controller = controller;
    this.nodeManager = nodeManager;
    this.firstPaintBlockSize = typeof firstPaintBlockSize === 'number' ? firstPaintBlockSize : DEFAULT_FIRST_PAINT_BLOCK_SIZE;
    this.setStartEndInfoByOffset(0, this.firstPaintBlockSize - 1);
    this.setPlaceholderHeight();
  }

  precheckOutputByLayoutInfo(layoutInfoResult) {
    const {
      expectedBufferStartBlockOffset,
      expectedBufferEndBlockOffset,
      expectedBufferStartBlockY,
      expectedBufferEndBlockY,
      accHeight
    } = layoutInfoResult;
    const {
      beforePlaceholderHeight,
      afterPlaceholderHeight
    } = this.calculatePlaceholderHeight(expectedBufferStartBlockY, expectedBufferEndBlockY, accHeight);
    const visibles = this.calculateVisibles(expectedBufferStartBlockOffset, expectedBufferEndBlockOffset);
    return {
      beforePlaceholderHeight,
      afterPlaceholderHeight,
      visibles
    };
  }

  loadCalculateLayoutInfo(layoutInfoResult) {
    const {
      expectedBufferStartBlockOffset,
      expectedBufferEndBlockOffset,
      expectedBufferStartBlockY,
      expectedBufferEndBlockY,
      expectedViewStartBlockOffset,
      accHeight
    } = layoutInfoResult;
    this.setStartEndInfoByOffset(expectedBufferStartBlockOffset, expectedBufferEndBlockOffset);
    this.setPlaceholderHeight(expectedBufferStartBlockY, expectedBufferEndBlockY, accHeight);
    this.startViewBlockOffset = expectedViewStartBlockOffset;
  }

  calculatePlaceholderHeight(expectedBlockStartY, expectedBlockEndY, accHeight) {
    if (typeof expectedBlockStartY === 'number' && typeof expectedBlockEndY === 'number' && typeof accHeight === 'number') {
      return {
        beforePlaceholderHeight: expectedBlockStartY,
        afterPlaceholderHeight: accHeight - expectedBlockEndY
      };
    }

    return {
      beforePlaceholderHeight: 0,
      afterPlaceholderHeight: Math.max(0, this.controller.view.nodes.length - this.firstPaintBlockSize) * BLOCK_DEFAULT_MIN_HEIGHT
    };
  }

  setPlaceholderHeight(expectedBlockStartY, expectedBlockEndY, accHeight) {
    if (typeof expectedBlockStartY === 'number' && typeof expectedBlockEndY === 'number' && typeof accHeight === 'number') {
      this.beforePlaceholderHeight = expectedBlockStartY;
      this.afterPlaceholderHeight = accHeight - expectedBlockEndY;
      return;
    }

    this.afterPlaceholderHeight = Math.max(0, this.controller.view.nodes.length - this.firstPaintBlockSize) * BLOCK_DEFAULT_MIN_HEIGHT;
    return;
  }

  setStartEndInfoByOffset(startOffset, endOffset) {
    const view = this.controller.view;
    this.startBlockOffset = startOffset;
    this.endBlockOffset = endOffset;
    const startBlock = view.getNodeByPath([startOffset]);
    const endBlock = view.getNodeByPath([endOffset]);
    this.startBlockKey = startBlock?.key;
    this.endBlockKey = endBlock?.key;
  }

  calculateVisibles(startBlockOffset, endBlockOffset) {
    const {
      view
    } = this.controller;
    const visibleBlockKeys = [];
    const blockFinalVisibleStates = view.nodes.map((node, index) => {
      if (index < startBlockOffset || index > endBlockOffset) {
        const cachedBlockProps = this.nodeManager.getCachedBlockPropsByKey(node.key);

        if (cachedBlockProps?.persistStateNode && cachedBlockProps.persistStateNode.length > 0) {
          return 'hide';
        }

        return 'destroy';
      }

      visibleBlockKeys.push(node.key);
      return 'show';
    });
    return {
      blockFinalVisibleStates,
      visibleBlockKeys
    };
  } // todo: cache


  get visibles() {
    const result = this.calculateVisibles(this.startBlockOffset, this.endBlockOffset);
    return result;
  }

}

/**
 * @packageDocumentation
 * @module domUtils
 */

/**
 * 查找 node 节点下 first/last 的 Text 节点
 * @param node 查找的节点
 * @param order 遍历的顺序 pre-前序遍历 post-后序遍历
 */
function findTextNode(node, order = 'pre') {
  const childNodes = order === 'post' ? Array.from(node.childNodes).reverse() : node.childNodes;

  for (let i = 0; i < childNodes.length; i += 1) {
    const child = childNodes[i];

    if (child instanceof Text) {
      return child;
    }

    const text = findTextNode(child, order);

    if (text instanceof Text) {
      return text;
    }
  }

  return null;
}
/**
 * 获取 DOM 的真实选区
 * @param root
 * @description 由于编辑器层没有浏览器的选区，所以使用 mark 的方式自行构造选区
 */


function findCurrentDOMRange(root = window.document) {
  const nodes = root.querySelectorAll('[data-cangjie-range');

  if (nodes.length <= 0) {
    return null;
  }

  const range = document.createRange();
  const start = nodes[0];
  const end = nodes[nodes.length - 1];
  const anchor = findTextNode(start, 'pre');
  const focus = findTextNode(end, 'post');

  if (!anchor || !focus) {
    return null;
  }

  try {
    range.setStart(anchor, 0);
    range.setEnd(focus, Math.max(focus.length, 0));
  } catch (error) {
    return null;
  }

  return range;
}

/**
 * @packageDocumentation
 * @module domUtils
 */
/**
 * 根据用户的 click 或 touch 事件获取仓颉的 Selection
 */

function findRangeByEvent(event, controller) {
  const {
    target,
    x,
    y
  } = event;
  return caretRangeFromTargetAndCoord(target, x, y, controller);
}

/**
 * 遍历节点内的每一个 cangjie content 节点，获取 getClientRects 列表
 */
function getDOMRects(node) {
  const rects = [];
  const leafContents = node.querySelectorAll(`[${Selector.leaf}]`);
  const voidContents = node.querySelectorAll(`[${Selector.void}]`); // TODO：代码块特殊处理，后期需要移除

  const specialCodes = node.querySelectorAll('.CodeMirror');

  const addRect = rect => {
    if (rect) {
      const {
        left,
        top,
        width,
        height
      } = rect;
      rects.push({
        left,
        top,
        width,
        height
      });
    }
  };

  Array.from(leafContents).forEach(leaf => {
    if (!leaf.closest(`[${Selector.void}]`)) {
      Array.from(leaf.getClientRects()).forEach(addRect);
    }
  });
  Array.from(voidContents).forEach(voidNode => {
    const rect = voidNode.getBoundingClientRect();
    addRect(rect);
  });
  Array.from(specialCodes).forEach(codeNode => {
    const rect = codeNode.closest(`[${Selector.leafBlock}]`)?.getBoundingClientRect();
    addRect(rect);
  });
  return rects;
}
/**
 * 获取分行。`rows` 构建了分行的结构，每一个 row 表示一行
 */


function splitRows(blockDOMNode, extendToFill = false) {
  const parentRect = blockDOMNode.getBoundingClientRect();
  const linesRects = getDOMRects(blockDOMNode);

  const newRow = rect => {
    const {
      top,
      height
    } = rect;
    return {
      top,
      height
    };
  };

  const rows = [];

  const sortIntoRows = rect => {
    if (!rows.length) {
      rows.push(newRow(rect));
      return;
    } // 尝试找到插入行（如果 rect 的 top 比某一行的 bottom 小，就算插入行）


    const insertRow = rows.find(row => rect.top < row.top + row.height); // 没有插入行的话，就创建一个

    if (!insertRow) {
      rows.push(newRow(rect));
      return;
    } // rect 的 bottom 比插入行的 top 小，则 rect 可以重新创建一行了


    if (rect.top + rect.height <= insertRow.top) {
      rows.splice(rows.indexOf(insertRow), 0, newRow(rect));
      return;
    } // rect 属于某个 row，更新一下 row


    if (rect.top < insertRow.top) {
      insertRow.top = rect.top;
    }

    if (rect.top + rect.height > insertRow.top + insertRow.height) {
      insertRow.height = rect.top + rect.height - insertRow.top;
    }
  }; // 对 block DOM 的所有 rects 进行分行


  linesRects.forEach(sortIntoRows);

  if (!rows.length) {
    rows.push(newRow(parentRect));
  }

  if (!extendToFill) {
    return rows;
  }

  const first = rows[0];
  const last = rows[rows.length - 1];
  first.height += first.top - parentRect.top;
  first.top = parentRect.top;
  last.height = parentRect.bottom - last.top; // extendToFill：扩展行高，填充行之间的空隙

  for (let i = 1; i < rows.length; i++) {
    const prev = rows[i - 1];
    const now = rows[i];
    const margin = now.top - prev.top - prev.height;
    prev.height += margin / 2;
    now.height += margin / 2;
    now.top -= margin / 2;
  }

  return rows;
}
/**
 * 选区、色块抗锯齿优化，调整 rect 的高度，使属于同一行的 rect 高度相同。
 */

function fitRows(rows, rects, offsetRect) {
  const newRects = [];
  rects.forEach(rect => {
    // 尝试找到插入行（如果 rect 的 top 比某一行的 bottom 小，就算插入行）
    const insertRow = rows.find(row => rect.top < row.top + row.height); // 如果没有找到，或者 rect 的 bottom 比插入行的 top 还要小，就不返回

    if (!insertRow || rect.top + rect.height < insertRow.top) {
      return;
    }

    const {
      height,
      top
    } = insertRow;
    const {
      left,
      width
    } = rect;
    newRects.push({
      left: left - offsetRect.left,
      top: top - offsetRect.top,
      height,
      width
    });
  });
  return newRects;
}
/**
 * 相邻的 rect 进行合并，避免碎片化的色块
 */

function mergeRects(rects) {
  const sortedRects = rects.sort((l, r) => {
    if (l.top !== r.top) {
      return l.top - r.top;
    }

    return l.left - r.left;
  }); // 左右相邻的 rects 合并成一个

  const newRects = [];
  sortedRects.forEach(rect => {
    const prev = newRects[newRects.length - 1];
    let {
      left,
      width
    } = rect;
    const {
      top,
      height
    } = rect;

    if (prev && Math.round(prev.top) === Math.round(top) && // top 相等且 prev.right >= left，此 rect 可以和前一个合并
    Math.round(prev.left + prev.width) >= Math.round(left)) {
      // right 取最大值
      const right = Math.max(prev.left + prev.width, left + width);
      left = prev.left;
      width = right - left;
      newRects.pop();
      newRects.push({
        left,
        top,
        width,
        height
      });
    } else {
      newRects.push(rect);
    }
  });
  return newRects;
}

/**
 * 查找指定节点下的选区容器
 * @param root 查询的根节点
 * @param layerFor 查找的指定容器的 selection-layer，若为空则不指定具体值
 */

function getSelectionLayers(root = window.document.body, layerFor = '') {
  const selector = layerFor ? `[${Selector.selectionLayer}="${layerFor}"]` : `[${Selector.selectionLayer}]`;
  return root.querySelectorAll(selector) || [];
}
/**
 * 获取本地光标 DOM
 * @param root
 * @returns
 */

function getCaretDom(root = window.document.body) {
  const layers = getSelectionLayers(root);

  for (let i = layers.length - 1; i >= 0; i--) {
    const layer = layers[i];
    const target = layer.shadowRoot ? layer.shadowRoot.querySelector('[data-cangjie-caret="true"]') : layer.querySelector('[data-cangjie-caret="true"]');

    if (target) {
      return target;
    }
  }

  return undefined;
}
/**
 * 查找归属于特定 data-cangjie-key 的容器 DOM 节点内的选区根节点
 * @param containerKey 指定容器 key
 * @returns
 */

function findSelectionSlot(containerKey) {
  const containerDOM = findDOMNodeSafely(containerKey);

  try {
    const selectionLayer = getSelectionLayers(containerDOM, containerKey)[0];
    const wrapper = selectionLayer.shadowRoot ? selectionLayer.shadowRoot.querySelector('div') : selectionLayer.querySelector('div');
    return wrapper;
  } catch (e) {
    console.warn(`[Selection] Get selection slot dom for [${containerKey}] failed`, e);
  }

  return null;
}

async function scrollToNodeByPath(path, controller, preventScrollWhenNodeIsVisible = false, doNothingWhenVirtualizeDisabled = false) {
  const node = controller.view.getNodeByPath(path);

  if (!node) {
    return;
  }

  if (!controller.enableVirtualize && doNothingWhenVirtualizeDisabled) {
    return;
  }

  const key = node.key;
  const index = path[0];
  const topBlock = controller.view.getNodeByPath([index]);
  const targetNode = Text$1.isText(node) ? controller.view.getParent(key) : node;

  if (targetNode?.key && preventScrollWhenNodeIsVisible) {
    const dom = findDOMNodeSafely(targetNode.key);

    if (dom) {
      return;
    }
  }

  if (controller.enableVirtualize && controller.virtualizeManager && topBlock && !controller.isNodeVisible(topBlock)) {
    const {
      virtualizeManager
    } = controller;

    if (!virtualizeManager.viewInitialized) {
      await virtualizeManager.waitUntilViewInitialized;
    }

    await virtualizeManager.workflowToScrollToNode(index);
  }

  if (targetNode) {
    try {
      const selector = `[data-cangjie-key="${targetNode.key}"]`;
      const nodeElement = await waitForElementByAnimationFrame(selector);

      if (nodeElement && typeof nodeElement.scrollIntoView === 'function') {
        nodeElement.scrollIntoView();
      }
    } catch (e) {
      console.warn(`Failed to scrollToNodeByPath`);
    }
  }
}
async function scrollToNodeByKey(key, controller, preventScrollWhenNodeIsVisible = false, doNothingWhenVirtualizeDisabled = false) {
  const path = controller.view.getPath(key);

  if (!path) {
    return;
  }

  await scrollToNodeByPath(path, controller, preventScrollWhenNodeIsVisible, doNothingWhenVirtualizeDisabled);
  return;
}

/**
 * @packageDocumentation
 * @ignore
 */

var index$3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  findNode: findNode,
  findPoint: findPoint,
  findRange: findRange,
  findDOMNode: findDOMNode,
  findDOMNodeSafely: findDOMNodeSafely,
  findDOMPoint: findDOMPoint,
  findDOMRange: findDOMRange,
  findCurrentDOMRange: findCurrentDOMRange,
  findRangeByEvent: findRangeByEvent,
  caretRangeFromTargetAndCoord: caretRangeFromTargetAndCoord,
  findCaretPosition: findCaretPosition,
  splitRows: splitRows,
  fitRows: fitRows,
  mergeRects: mergeRects,
  findClosestInContent: findClosestInContent,
  getLocalCaretPos: getLocalCaretPos,
  getLocalCaretPosDetail: getLocalCaretPosDetail,
  scrollToNodeByPath: scrollToNodeByPath,
  scrollToNodeByKey: scrollToNodeByKey,
  findScrollableContainer: findScrollableContainer,
  getScrollableContainerInfo: getScrollableContainerInfo,
  getDOMRectFromSelection: getDOMRectFromSelection,
  scrollToSelection: scrollToSelection,
  getSelectionLayers: getSelectionLayers,
  getCaretDom: getCaretDom,
  findSelectionSlot: findSelectionSlot
});

const RESIZE_DEBOUNCE_TIME = 150;
class ViewManager {
  // 暂时没用到的方法 未来可能用到 注释掉避免影响覆盖率
  // get viewPort() {
  //   return {
  //     viewPortStartY: this.viewPortStartY,
  //     viewPortEndY: this.viewPortEndY,
  //     bufferStartY: this.bufferStartY,
  //     bufferEndY: this.bufferEndY,
  //   }
  // }
  constructor(options) {
    this.nodeManager = void 0;
    this.editorContainer = void 0;
    this.scrollContainer = void 0;
    this.scrollElement = void 0;
    this.scrollListenerElement = void 0;
    this.scrollHandler = void 0;
    this.scrollInterval = void 0;
    this.resizeHandler = void 0;
    this.resizeObserver = null;
    this.bufferRange = void 0;
    this.editorContainerToScrollContainerDistance = void 0;
    this.scrollHistoryArray = [];
    this.throttledScrollListener = void 0;
    this.triggerViewUpdate = void 0;
    this.viewPortStartY = void 0;
    this.viewPortEndY = void 0;
    this.bufferStartY = void 0;
    this.bufferEndY = void 0;
    this.prevViewPortStartY = 0;

    this.scrollListener = () => {
      const {
        viewPortStartY
      } = this.calculateViewPort();
      const timestamp = new Date().valueOf();
      const value = {
        timestamp,
        viewPortStartY
      };
      const index = this.scrollHistoryArray.findIndex(scrollHistory => {
        return scrollHistory.viewPortStartY === viewPortStartY && timestamp - scrollHistory.timestamp < 1000;
      });

      if (index >= 0) {
        return;
      }

      this.scrollHistoryArray.push(value);

      if (this.scrollHistoryArray.length > 2) {
        this.scrollHistoryArray.shift();
      }

      this.scrollHandler();
    };

    const {
      editorContainer,
      scrollContainer,
      scrollHandler,
      scrollInterval,
      resizeHandler,
      bufferRange,
      triggerViewUpdate,
      nodeManager
    } = options;
    this.nodeManager = nodeManager;
    this.editorContainer = editorContainer;
    this.scrollContainer = scrollContainer;
    this.scrollHandler = scrollHandler;
    this.resizeHandler = resizeHandler;
    this.bufferRange = bufferRange || DEFAULT_BUFFER_RANGE;
    this.scrollElement = scrollContainerIsTop(this.scrollContainer) ? document.documentElement : scrollContainer;
    this.scrollListenerElement = scrollContainerIsTop(this.scrollContainer) ? document : scrollContainer;
    this.scrollInterval = typeof scrollInterval === 'number' ? scrollInterval : DEFAULT_SCROLL_THROTTLE_INTERVAL;
    this.triggerViewUpdate = triggerViewUpdate;
    this.updateEditorContainerToScrollContainerDistance();
    this.updateViewPort();
    this.throttledScrollListener = lodash.throttle(this.scrollListener, this.scrollInterval);
  }

  updateEditorContainerToScrollContainerDistance() {
    this.editorContainerToScrollContainerDistance = calculateEditorContainerToScrollContainerDistance(this.editorContainer, this.scrollContainer, this.scrollElement, scrollContainerIsTop(this.scrollContainer));
  }

  calculateViewPort(_viewPortStartY) {
    return calculateViewPort(this.scrollElement, this.scrollContainer, this.bufferRange, this.editorContainerToScrollContainerDistance, _viewPortStartY);
  }

  updateViewPort() {
    this.prevViewPortStartY = this.viewPortStartY;
    const {
      viewPortStartY,
      viewPortEndY,
      bufferStartY,
      bufferEndY
    } = this.calculateViewPort();
    this.viewPortStartY = viewPortStartY;
    this.viewPortEndY = viewPortEndY;
    this.bufferStartY = bufferStartY;
    this.bufferEndY = bufferEndY; // const gap = this.viewPortStartY - this.prevViewPortStartY;

    return;
  }

  initScrollListener() {
    this.scrollListenerElement.addEventListener('scroll', this.throttledScrollListener);
  }

  destroyScrollListener() {
    this.scrollListenerElement.removeEventListener('scroll', this.throttledScrollListener);
  }

  initResizeObserver() {
    if (typeof ResizeObserver === 'undefined') {
      return;
    }

    const handleResize = lodash.debounce(entries => {
      this.resizeHandler(entries);
    }, RESIZE_DEBOUNCE_TIME);
    const resizeObserver = new ResizeObserver(handleResize);
    this.resizeObserver = resizeObserver;
  }

  detroyResizeObserver() {
    this.resizeObserver = null;
  }

  addResizeObserverByKeys(blockKeys) {
    if (!this.resizeObserver) {
      return;
    }

    blockKeys.forEach(blockKey => {
      const blockElement = findDOMNodeSafely(blockKey);

      if (!blockElement) {
        return;
      }

      this.addResizeObserver(blockElement);
    });
  }

  addResizeObserver(element) {
    if (!this.resizeObserver) {
      return;
    }

    this.resizeObserver.observe(element);
  }

  removeResizeObserver(element) {
    if (!this.resizeObserver) {
      return;
    }

    this.resizeObserver.unobserve(element);
  }
  /**
   * 测量所有当前上屏节点的高度
   * @returns Object, key 为节点 key, value 为高度
   */


  measureCurrentViewBlocks(documentKey) {
    const documentElement = findDOMNodeSafely(documentKey);
    const result = {};
    documentElement?.childNodes.forEach(childNode => {
      const element = childNode;
      const cangjieKey = element.getAttribute(Selector.key);

      if (cangjieKey) {
        const measuredInfo = measureBlockInfo(element);
        result[cangjieKey] = measuredInfo;
      }
    });
    return result;
  }

  async measureBlocksByKeys(blockKeys) {
    const result = {};
    const measureTasks = blockKeys.map(blockKey => {
      const promise = Promise.resolve().then(() => {
        const blockElement = findDOMNodeSafely(blockKey);

        if (!blockElement) {
          return {};
        }

        const measuredInfo = measureBlockInfo(blockElement);
        result[blockKey] = measuredInfo;
        return measuredInfo;
      });
      return promise;
    });
    await Promise.all(measureTasks);
    return result;
  }

  calculateExpectedLayoutInfo(view, bufferStartY, bufferEndY, viewStartY) {
    const result = calculateExpectedLayoutInfo(typeof bufferStartY === 'number' ? bufferStartY : this.bufferStartY, typeof bufferEndY === 'number' ? bufferEndY : this.bufferEndY, typeof viewStartY === 'number' ? viewStartY : this.viewPortStartY, view, this.nodeManager);
    return result;
  }

  calculateBlockStartYByBlockIndex(index, view, includeLastMarginBottom = false) {
    return calculateBlockStartYByBlockIndex(index, view, this.nodeManager, includeLastMarginBottom);
  } // 这里仅仅是滚最外层


  scrollToNodeByIndex(index, view) {
    // this.updateEditorContainerToScrollContainerDistance();
    const startY = calculateBlockStartYByBlockIndex(index, view, this.nodeManager);
    const totalStartY = startY + this.editorContainerToScrollContainerDistance;
    this.scrollElement.scrollTo(this.scrollElement.scrollLeft, totalStartY);
  }

}

class VirtualizeManager {
  // active 状态，用于运行时关闭虚拟化
  // 虚拟化配置项
  // 节点缓存管理器，用于缓存节点的测量结果等，并提供了一些方便使用的加载测量结果的方法
  // 输出管理器，通过加载测算结果，生成节点是否可视等输出信息，Cangjie 渲染时 useVirtualize 依赖
  // 视图管理器，所有跟 视图、DOM 相关的逻辑均收敛到这里
  // 虚拟化 id，为虚拟化流程执行次数的标记，同时用于触发虚拟化流程导致的视图重渲；为 -1 时代表虚拟化关闭
  // 当前正忙的虚拟化 id，用于禁止其他流程的进行
  // 虚拟化的当前测算结果与上次测算结果，outputManager load 此结果后才会改变输出
  // 虚拟化视图是否初始化，这里提供一个 Promise，在虚拟化初始化后，此 Promise 会 resolve
  // 当前的 Controller
  // 之前的 view
  // 配置的 buffer 范围
  // 虚拟化是否在正常运行态
  get isActive() {
    return this._isActive;
  }
  /**
   * 虚拟化控制器初始化逻辑，在仓颉新建 Controller 时触发
   * @returns void
   */


  constructor(controller, options) {
    this._isActive = false;
    this.options = void 0;
    this.nodeManager = void 0;
    this.outputManager = void 0;
    this.viewManager = void 0;
    this.virtualizeId = 0;
    this.currentLockedVirtualizeId = null;
    this.prevLayoutInfoResult = void 0;
    this.layoutInfoResult = void 0;
    this.viewInitialized = false;

    this.setViewInitialized = () => {};

    this.waitUntilViewInitialized = void 0;
    this.controller = void 0;
    this.prevView = void 0;
    this.bufferRange = void 0;

    this.initViewWorkflow = async () => {
      const {
        view
      } = this.controller;
      const currentVirtualizeId = this.virtualizeId + 1; // Step 1：视图管理器测量所有已上屏节点

      const measureResult = this.viewManager.measureCurrentViewBlocks(view.key); // Step 2：节点管理器保存测量结果

      this.nodeManager.loadMeasureResult(measureResult); // Step 3：根据当前视窗和 Step 2 保存的节点测量结果
      // 进行计算流程，计算当前的布局，并保存。同时会记录上一次的布局信息

      this.prevLayoutInfoResult = this.layoutInfoResult;
      const layoutInfoResult = this.viewManager.calculateExpectedLayoutInfo(view);
      this.layoutInfoResult = layoutInfoResult; // Step 4：输出管理器加载布局计算结果，输出管理器控制着最后的输出，只有加载测算结果才会影响输出

      this.outputManager.loadCalculateLayoutInfo(layoutInfoResult); // Step 5：更新虚拟化模型控制器中的当前可见节点，触发模型重算

      const {
        visibles
      } = this.outputManager;
      this.controller.setVirtualize('visibles', visibles.visibleBlockKeys); // Step 6：刷新虚拟化结果，触发重渲

      const virtualizeId = this.flushVirtualize(currentVirtualizeId);

      if (visibles.visibleBlockKeys.length === 0) {
        return;
      } // Step 7: 等待此次虚拟化结果重渲上屏


      await waitForElementByAnimationFrame(`[data-virtualize-id="${virtualizeId}"]`); // Step 8: 为渲染上屏的节点添加 resizeObserver

      this.viewManager.addResizeObserverByKeys(visibles.visibleBlockKeys); // Step 9: 测量渲染上屏的节点的高度并保存，结束

      const nextMeasureResult = await this.viewManager.measureBlocksByKeys(visibles.visibleBlockKeys);
      this.nodeManager.loadMeasureResult(nextMeasureResult);
    };

    this.coreWorkflow = async (triggerReRenderActively = true, measureOnly = false, shouldAddLock = false) => {
      // Step 1: 前置流程，递增 virtualizeId，检查是否状态忙，状态忙则终止流程
      const currentVirtualizeId = this.virtualizeId + 1;

      if (this.checkLocked(currentVirtualizeId)) {
        return {
          layoutInfoResult: null,
          needToReRender: false,
          needToStartNextWorkflow: false
        };
      } // Step 2：加载上一次的测算结果
      // 上个流程测算结束后，测算结果会保存，但不会直接改变输出 (不会 load 进 OutputManager)
      // 会简单判断是否需要开启下一个流程后，交给下一个虚拟化流程去重渲


      this.outputManager.loadCalculateLayoutInfo(this.layoutInfoResult);
      const {
        afterPlaceholderHeight,
        beforePlaceholderHeight,
        visibles
      } = this.outputManager; // Step 2.1：根据上一次的测算结果，改变虚拟化模型中的可见节点

      this.controller.setVirtualize('visibles', visibles.visibleBlockKeys);
      const {
        view
      } = this.controller; // Step 3：根据上一次的测算结果（即将上屏的节点）和之前的测算结果（已经上屏的节点）
      // 判断新增了哪些节点，稍后只测量新增的节点，以提高性能

      const newBlockKeys = calculateBlockKeysNeedToMeasure(view, this.prevView, this.layoutInfoResult, this.prevLayoutInfoResult); // Step 4：根据传入参数，决定是否需要设置 busy 状态

      if (shouldAddLock) {
        this.lock(currentVirtualizeId);
      } // Step 5：保存新虚拟化 id；触发重渲，上屏根据上次测算结果得到的新节点


      this.flushVirtualize(currentVirtualizeId, triggerReRenderActively); // Step 6：等待重渲完毕，测量新上屏的节点并保存节点测量结果到 nodeManager
      // 如果因为被其他流程覆盖等原因等不到此虚拟化 id，则放弃此流程
      // 同时为新增的节点增加 resizeObserver

      if (newBlockKeys.length > 0) {
        try {
          await waitForElementByAnimationFrame(`[data-virtualize-id="${currentVirtualizeId}"]`);
        } catch (e) {
          this.unlock(currentVirtualizeId);
          return {
            layoutInfoResult: null,
            needToReRender: false,
            needToStartNextWorkflow: false
          };
        }

        this.viewManager.addResizeObserverByKeys(newBlockKeys);
        const nextMeasureResult = await this.viewManager.measureBlocksByKeys(newBlockKeys);
        this.nodeManager.loadMeasureResult(nextMeasureResult);
      } // Step 7：解除 busy 状态


      this.unlock(currentVirtualizeId); // 对只需要测量的流程，结束流程

      if (measureOnly) {
        return {
          layoutInfoResult: null,
          needToReRender: false,
          needToStartNextWorkflow: false
        };
      } // Step 8：根据测量的结果，进行对布局的计算


      const layoutInfoResult = this.viewManager.calculateExpectedLayoutInfo(view); // Step 9: 根据布局的结果，进行对节点详细布局情况和 placeholder 高度的计算
      // 使用 precheckOutputByLayoutInfo 意味着这个计算结果不会影响最终输出，只供 Step 10 的判断

      const {
        afterPlaceholderHeight: newAfterPlaceholderHeight,
        beforePlaceholderHeight: newBeforePlaceholderHeight,
        visibles: newVisibles
      } = this.outputManager.precheckOutputByLayoutInfo(layoutInfoResult); // Step 10: 根据 Step 9 的计算结果，判断是否要发起下一个虚拟化工作流，或者是否需要重渲 Placeholder
      // 如果需要上屏的节点有变化，则需要发起下一个工作流，在下一个工作流中上屏这些节点（并测量与计算）
      // 如果需要上屏的节点没有变化，但 Placeholder 高度发生了变化，直接触发重渲即可

      let needToReRender = false;
      let needToStartNextWorkflow = false; // 节点还是那些老的，没有变化

      if (equal__default["default"](visibles, newVisibles)) {
        // 但是 placeholder 高度有变化，要重渲
        if (afterPlaceholderHeight !== newAfterPlaceholderHeight || beforePlaceholderHeight !== newBeforePlaceholderHeight) {
          needToReRender = true;
        } // 出现新节点

      } else {
        needToReRender = true;

        if (checkArrayAHasElementNotIncludedInArrayB(newVisibles.visibleBlockKeys, visibles.visibleBlockKeys)) {
          needToStartNextWorkflow = true;
        }
      }

      return {
        layoutInfoResult,
        needToReRender,
        needToStartNextWorkflow
      };
    };

    this.workflowByCurrentViewPort = async () => {
      const {
        view
      } = this.controller; // Step 1: 根据当前视口情况，更新视口位置信息，根据视口位置信息和过去缓存的节点测量高度，算出一个新的布局结果
      // 同时储存上一次计算的布局结果

      this.prevLayoutInfoResult = this.layoutInfoResult;
      this.viewManager.updateViewPort();
      this.layoutInfoResult = this.viewManager.calculateExpectedLayoutInfo(view); // Step 2: 执行 coreWorkflow，Step 1 中的新的布局结果会上屏并进行测算
      // 根据新的测算结果，可能需要补充节点，或者剔除节点（needToStartNextWorkflow），出现这种情况需要发起下个工作流
      // 根据新的测算结果，placeholder 高度也可能发生变化，需要重渲一下

      const {
        needToStartNextWorkflow,
        needToReRender,
        layoutInfoResult
      } = await this.coreWorkflow(); // Step 3: 根据新测算结果需要补充节点，或者剔除节点，则需要发起下一个工作流；
      // Placeholder 有变化则需要 rerender 则重渲；
      // 否则流程结束

      if (needToStartNextWorkflow) {
        await this.workflowByCurrentViewPort();
      } else if (needToReRender) {
        this.prevLayoutInfoResult = this.layoutInfoResult;
        this.outputManager.loadCalculateLayoutInfo(layoutInfoResult);
        this.layoutInfoResult = layoutInfoResult;
        const {
          visibles
        } = this.outputManager;
        this.controller.setVirtualize('visibles', visibles.visibleBlockKeys);
        const newVirtualizeId = this.virtualizeId + 1;
        this.flushVirtualize(newVirtualizeId);
        return;
      }
    };

    this.workflowToScrollToNode = async nodeIndex => {
      const {
        view
      } = this.controller;
      this.viewManager.updateEditorContainerToScrollContainerDistance(); // Step 1：通过节点的 index，根据当前的测算结果，得到视口滚动到恰好显示此节点时，视口的 y 坐标
      // 指定 y 坐标是本工作流与其他工作流最大的不同之处，上面的工作流是通过视口位置得到 y 坐标

      const startY = this.viewManager.calculateBlockStartYByBlockIndex(nodeIndex, view);
      const {
        bufferStartY,
        bufferEndY,
        viewPortStartY
      } = this.viewManager.calculateViewPort(startY); // Step 2：假设视口滚动到此 y 坐标时，根据当前缓存的测算结果，计算布局信息

      this.prevLayoutInfoResult = this.layoutInfoResult;
      const layoutInfoResult = this.viewManager.calculateExpectedLayoutInfo(view, bufferStartY, bufferEndY, viewPortStartY);
      this.layoutInfoResult = layoutInfoResult; // Step 3：发起 coreWorkflow，上屏布局信息中需要上屏的节点，并测量

      await this.coreWorkflow(true, true, true); // Step 4: 触发一次滚动，将视口滚动到指定 y 坐标处，此时浏览器会触发 scroll 时事件，引发 workflowByCurrentViewPort 工作流

      this.viewManager.scrollToNodeByIndex(nodeIndex, view);
    };

    this.workflowOnValueChange = async () => {
      const prevView = this.prevView;
      const currView = this.controller.view;
      const view = this.controller.view;
      const {
        startBlockOffset,
        startBlockKey,
        endBlockOffset
      } = this.outputManager;
      const diffResult = fastDiffOnValueChange(prevView, currView, startBlockKey, startBlockOffset, endBlockOffset);

      if (diffResult.type === 'changed') {
        // Step 1：如果 diff 发现节点发生了变化，且不是平移，会根据最新的 viewModel 和视口信息，以及之前缓存的测量结果，计算布局信息
        this.prevLayoutInfoResult = this.layoutInfoResult;
        const layoutInfoResult = this.viewManager.calculateExpectedLayoutInfo(view);
        this.layoutInfoResult = layoutInfoResult; // Step 2: 发起 coreWorkflow，可能这里直接发起 workflowByCurrentViewPort 更好，后续修改

        await this.coreWorkflow(false);
      }

      this.prevView = currView;
    };

    this.scrollHandler = () => {
      this.workflowByCurrentViewPort();
    };

    this.resizeHandler = async entries => {
      const {
        view
      } = this.controller;
      const {
        afterPlaceholderHeight,
        beforePlaceholderHeight,
        visibles
      } = this.outputManager;
      const {
        visibleBlockKeys
      } = visibles;
      const resizedNodeEntries = entries.filter(entry => {
        const {
          target,
          contentRect
        } = entry;
        const key = target.getAttribute('data-cangjie-key');
        const parent = view.getParent(key);

        if (!(parent && Document.isDocument(parent))) {
          return false;
        }

        const hidden = target.style.display === 'none';

        if (!key || !view.nodes.some(node => node.key === key)) {
          return false;
        }

        if (hidden && !visibleBlockKeys.includes(key)) {
          return false;
        }

        const nodeProp = this.nodeManager.getCachedBlockPropsByKey(key); // 这里出于性能考虑暂不判断 marginTop 和 marginBottom

        if (nodeProp?.height !== contentRect.height) {
          return true;
        }

        return false;
      });
      const resizedBlockKeys = resizedNodeEntries.map(entry => {
        const {
          target
        } = entry;
        return target.getAttribute('data-cangjie-key');
      });
      const nextMeasureResult = await this.viewManager.measureBlocksByKeys(resizedBlockKeys);
      this.nodeManager.loadMeasureResult(nextMeasureResult);
      const layoutInfoResult = this.viewManager.calculateExpectedLayoutInfo(view);

      if (resizedBlockKeys.length > 0) {
        const {
          afterPlaceholderHeight: newAfterPlaceholderHeight,
          beforePlaceholderHeight: newBeforePlaceholderHeight,
          visibles: newVisibles
        } = this.outputManager.precheckOutputByLayoutInfo(layoutInfoResult);
        let needToReRender = false;
        let needToStartNextWorkflow = false;

        if (equal__default["default"](visibles, newVisibles)) {
          // 还是老节点，但是 placeholder 要变
          if (afterPlaceholderHeight !== newAfterPlaceholderHeight || beforePlaceholderHeight !== newBeforePlaceholderHeight) {
            needToReRender = true;
          } // 根据新结果，应出现新节点，通常有个东西高度大幅缩小了

        } else {
          needToReRender = true;

          if (checkArrayAHasElementNotIncludedInArrayB(newVisibles.visibleBlockKeys, visibles.visibleBlockKeys)) {
            needToStartNextWorkflow = true;
          }
        }

        if (needToStartNextWorkflow) {
          this.workflowByCurrentViewPort();
        } else if (needToReRender) {
          this.prevLayoutInfoResult = this.layoutInfoResult;
          this.outputManager.loadCalculateLayoutInfo(layoutInfoResult);
          this.layoutInfoResult = layoutInfoResult;
          const {
            visibles
          } = this.outputManager;
          this.controller.setVirtualize('visibles', visibles.visibleBlockKeys);
          const currentVirtualizeId = this.virtualizeId + 1;
          this.flushVirtualize(currentVirtualizeId);
        }
      }
    };

    const {
      bufferRange,
      firstPaintBlockSize
    } = options;
    this.options = options;
    this.bufferRange = bufferRange;
    this.controller = controller;
    this.prevView = controller.view;
    this.waitUntilViewInitialized = new Promise(resolve => {
      this.setViewInitialized = resolve;
    });
    this.nodeManager = new NodeManager({
      controller
    });
    this.outputManager = new OutputManager({
      controller,
      firstPaintBlockSize,
      nodeManager: this.nodeManager
    });
    this.controller.setVirtualize('visibles', this.outputManager.visibles.visibleBlockKeys);
  }
  /**
   * 在仓颉首屏渲染后的 Effect 中触发的逻辑，用于初始化 View/DOM 相关逻辑，如建立滚动事件监听
   * @returns void
   */


  initView(InitViewOptions) {
    const {
      editorContainer,
      scrollContainer,
      scrollInterval,
      triggerViewUpdate
    } = InitViewOptions;
    this.viewManager = new ViewManager({
      editorContainer,
      scrollContainer,
      scrollInterval,
      scrollHandler: this.scrollHandler,
      resizeHandler: this.resizeHandler,
      triggerViewUpdate,
      nodeManager: this.nodeManager,
      bufferRange: this.bufferRange
    });
    this.initViewWorkflow();
    this.viewInitialized = true;
    this.setViewInitialized();
  }
  /**
   * 启动虚拟化流程
   * @param flush 是否主动触发重渲
   * @returns void
   */


  start(flush = false) {
    if (!this.viewInitialized) {
      console.error('VirtualizeManager error: start invoked before UI Related Manager initialization');
    }

    if (!this.isActive) {
      this.viewManager.initScrollListener();
      this.viewManager.initResizeObserver();
    }

    if (flush) {
      this.flushVirtualize(this.virtualizeId + 1, true);
    }

    this._isActive = true;
  }
  /**
   * 关闭虚拟化流程
   * @param flush 是否主动触发重渲，如外界未触发重渲，需要主动触发重渲来显示所有节点
   * @returns void
   */


  stop(flush = false) {
    if (!this.viewInitialized) {
      console.error('VirtualizeManager error: stop invoked before UI Related Manager initialization');
    }

    if (this.isActive) {
      this.viewManager.destroyScrollListener();
      this.viewManager.detroyResizeObserver();
    }

    if (flush) {
      // virtualizeId 归零
      this.flushVirtualize(-1, true);
    }

    this._isActive = false;
  }
  /**
   * 为某个虚拟化工作流增加 busy 状态位，此时可以阻止其他虚拟化工作流的发起
   * @param virtualizeId 虚拟化 id
   * @returns virtualizeId 虚拟化 id
   */


  lock(virtualizeId) {
    if (this.currentLockedVirtualizeId !== null) {
      console.warn('warning: current has virtualizeId locked, unlock it first');
      return this.currentLockedVirtualizeId;
    }

    this.currentLockedVirtualizeId = virtualizeId;
    return virtualizeId;
  }
  /**
   * 为某个虚拟化工作流移除 busy 状态位
   * @param virtualizeId 虚拟化 id
   * @returns boolean 是否成功移除
   */


  unlock(virtualizeId) {
    if (this.currentLockedVirtualizeId === virtualizeId) {
      this.currentLockedVirtualizeId = null;
      return true;
    }

    return false;
  }
  /**
   * 检查是否存在 busy 状态位
   * @param virtualizeId 虚拟化 id
   * @returns boolean 是否存在 busy 状态位
   */


  checkLocked(virtualizeId) {
    if (this.currentLockedVirtualizeId !== null && virtualizeId !== this.currentLockedVirtualizeId) {
      return true;
    }

    return false;
  }
  /**
   * 更新虚拟化 id，刷新虚拟化结果（可选是否主动强制重渲）
   * @param virtualizeId 虚拟化 id
   * @param triggerReRenderActively 是否主动强制重渲
   * @returns 保存后的虚拟化 id
   */


  flushVirtualize(virtualizeId, triggerReRenderActively = true) {
    this.virtualizeId = virtualizeId;

    if (triggerReRenderActively) {
      this.viewManager?.triggerViewUpdate?.(this.virtualizeId);
    }

    return this.virtualizeId;
  }
  /**
   * 在 Cangjie 首屏渲染后执行的工作流，会测量首屏渲染的结果 (固定节点数，也不是全量节点)，并根据测量结果适当收缩节点数量
   * 最简单的虚拟化工作流，可以用于入门流程
   * @returns void
   */


}

/**
 * 模型分组管理
 */
class GroupManager {
  constructor(controller) {
    this.groups = {
      current: {},
      prev: {}
    };
    this.groups$ = new ReplaySubject();
    this.controller = void 0;
    this.CACHE = {
      NODE_GROUP: new Map()
    };
    this.controller = controller;
  }
  /**
   * 清理 group manager 内存占用
   */


  cleanup() {
    this.groups = {
      current: {},
      prev: {}
    };
    this.CACHE.NODE_GROUP.clear();
  }
  /**
   * 获得指定 key 的分组
   * @param key
   * @returns
   */


  getGroup(key) {
    return this.groups.current[key];
  }
  /**
   * 获得所有分组
   * @returns
   */


  getGroups() {
    return this.groups.current;
  }
  /**
   * 向订阅节点通知最新的分组信息
   * @param force
   * @returns
   */


  notifyNewGroups(force = false) {
    if (force || this.groups.current !== this.groups.prev) {
      this.groups.prev = this.groups.current;
      this.groups$.next(this.groups.current);
    }

    return this;
  }
  /**
   * 设置分组数据
   * @param key
   * @param data
   * @returns
   */


  setGroupData(key, data) {
    const group = this.getGroup(key);
    this.groups.current = { ...this.groups.current,
      [key]: { ...group,
        data: { ...data,
          [GROUP_COLLAPSED_KEY]: group.data[GROUP_COLLAPSED_KEY]
        }
      }
    };
    this.notifyNewGroups();
    return this;
  }
  /**
   * 融合分组数据
   * @param key
   * @param data
   * @returns
   */


  mergeGroupData(key, data) {
    const group = this.getGroup(key);
    this.groups.current = { ...this.groups.current,
      [key]: { ...group,
        data: { ...group.data,
          ...data
        }
      }
    };
    this.notifyNewGroups();
    return this;
  }
  /**
   * 生成全文所有的 Groups
   */


  generateAllGroups() {
    this.controller.value.document.forEachDescendant(node => {
      if (node.isElement()) {
        this.generateGroup(node);
      }
    });
    return this;
  }

  initGroups(groups) {
    if (groups) {
      this.groups.current = groups;
      this.groups.prev = groups;
    }

    return this;
  }
  /**
   * 获得节点所在的分组序列
   * @param node
   * @returns
   */


  getNodeGroups(node) {
    const {
      document
    } = this.controller.value;
    const groups = [];
    const elementGroup = this.getGroup(node.key);

    if (elementGroup) {
      groups.push({
        key: node.key,
        ...elementGroup
      });
    }

    let groupKey = this.CACHE.NODE_GROUP.get(node.key);

    while (groupKey !== undefined) {
      const group = this.getGroup(groupKey);

      if (group) {
        groups.push({
          key: groupKey,
          ...group
        });
      }

      let groupElement = document.getNode(groupKey);

      if (!groupElement) {
        break;
      }

      groupKey = this.CACHE.NODE_GROUP.get(groupElement.key);

      while (groupKey === undefined && groupElement && groupElement !== document) {
        const parent = document.assertParent(groupElement.key);
        groupKey = this.CACHE.NODE_GROUP.get(parent.key);
        groupElement = parent;
      }
    }

    return groups;
  }
  /**
   * 针对特殊变更，重新分组
   * @param operationWithValue
   */


  regenerateGroup(operationWithValue) {
    const {
      operation,
      value,
      newValue
    } = operationWithValue;

    if (operation.type === exports.OperationType.RemoveNode && operation.node.isElement()) {
      const prevGroup = this.getGroup(operation.node.key); // 节点删除后，对应删除其分组

      this.removeGroup(operation.node.key); // 从删除节点前一个节点开始重新分组

      this.regenerateGroupFrom(value.document.getPreviousSibling(operation.node.key), prevGroup?.data[GROUP_COLLAPSED_KEY] || false);
    } else if (operation.type === exports.OperationType.InsertNode && operation.node.isElement()) {
      const node = newValue.document.assertNodeByPath(operation.path);
      const prevNode = newValue.document.getPreviousSibling(node.key);
      const prevGroup = prevNode && this.getGroup(prevNode.key); // 从当前重新节点进行分组

      this.regenerateGroupFrom(operation.node, prevGroup?.data[GROUP_COLLAPSED_KEY] || false); // 对新插入节点的子节点进行分组

      operation.node.forEachDescendant(n => {
        if (n.isElement()) {
          this.generateGroup(n, prevGroup?.data[GROUP_COLLAPSED_KEY] || false);
        }
      });
    } else if (operation.type === exports.OperationType.SetNode) {
      // 删除节点原来的分组
      const node = newValue.document.assertNodeByPath(operation.path);
      const oldNode = value.document.assertNodeByPath(operation.path);
      const prevGroup = this.getGroup(node.key);
      this.getGroup(oldNode.key);
      this.removeGroup(node.key); // 从当前节点开始，重新分组

      this.regenerateGroupFrom(node, prevGroup?.data[GROUP_COLLAPSED_KEY] || false);
    } else if (operation.type === exports.OperationType.MergeNode) {
      const node = value.document.assertNodeByPath(operation.path);
      const prevGroup = this.getGroup(node.key);

      if (node.isElement()) {
        // 删除节点所在分组
        this.removeGroup(node.key); // 从合并到的节点开始重新分组

        this.regenerateGroupFrom(newValue.document.getPreviousSiblingByPath(operation.path), prevGroup?.data[GROUP_COLLAPSED_KEY] || false);
      }
    } else if (operation.type === exports.OperationType.SplitNode) {
      const node = value.document.assertNodeByPath(operation.path);

      if (node.isElement()) {
        const prevGroup = this.getGroup(node.key); // 删除节点所在分组

        this.removeGroup(node.key); // 从合并到的节点开始重新分组

        this.regenerateGroupFrom(newValue.document.getNextSiblingByPath(operation.path), prevGroup?.data[GROUP_COLLAPSED_KEY] || false);
      }
    } else if (operation.type === exports.OperationType.MoveNode) {
      // 从移动起点开始重新分组
      const node = value.document.assertNodeByPath(operation.path);
      this.regenerateGroupFrom(value.document.getPreviousSibling(node.key)); // 从移动终点开始重新分组

      this.regenerateGroupFrom(node);
    }

    return this;
  }

  removeGroup(key) {
    if (!key) {
      return this;
    }

    this.groups.current = lodash.omit(this.groups.current, key);
    this.CACHE.NODE_GROUP.delete(key);
    return this;
  }

  generateGroup(element, isCollapsed = false) {
    const group = this.controller.run('generateGroup', element);
    const currentGroup = this.getGroup(element.key); // 如果分组已经不存在，则分组列表中丢弃该分组

    if (!group && currentGroup) {
      this.groups.current = lodash.omit(this.groups.current, element.key);
    } // 若产生了新的分组，则添加该分组
    else if (group) {
        // 如果分组类型变更，则新建分组
        if (currentGroup?.type !== group.type) {
          this.groups.current = { ...this.groups.current,
            [element.key]: { ...group,
              data: { ...group.data,
                [GROUP_COLLAPSED_KEY]: isCollapsed
              }
            }
          };
        }

        const nodesInGroup = this.getNodesInGroup(element, this.getGroup(element.key));
        nodesInGroup.forEach(n => {
          this.CACHE.NODE_GROUP.set(n.key, element.key);
        });
      }

    return this;
  }

  getNodesInGroup(node, group) {
    const {
      document
    } = this.controller.value;
    let next = document.getNextSibling(node.key);
    const nodes = [];
    const groups = [group];
    let closestGroup = group;

    while (next && next.isElement() && closestGroup) {
      const isElementInGroup = this.controller.query('isElementInGroup', next, closestGroup);

      if (isElementInGroup !== false) {
        if (closestGroup === group) {
          nodes.push(next);
        }
      } else {
        groups.pop();
        closestGroup = groups[groups.length - 1];
        continue;
      }

      const maybeGroup = this.getGroup(next.key);

      if (maybeGroup) {
        groups.push(maybeGroup);
        closestGroup = maybeGroup;
      }

      next = document.getNextSibling(next.key);
    }

    return nodes;
  }

  regenerateGroupFrom(node, isCollapsed = false) {
    if (!node || !node.isElement()) {
      return this;
    }

    const {
      document
    } = this.controller.value; // 对变更节点所在的前序分组进行重新分组

    while (node) {
      this.generateGroup(node, isCollapsed);
      node = document.getPreviousSibling(node.key);
    }

    return this;
  }

}

/**
 * 获得不可见节点序列，按照距离可见节点的次序排序
 *
 * ```ts
 * // document.nodes: ['1', '2', '3', '4', '5', '6', '7'];
 *
 * const invisibles = getInvisibles(document, ['3', '4']);
 * // invisibles: ['7', '6', '1', '5',  '2']
 * ```
 * @param document
 * @param visibles
 * @returns
 */
function getInsivibleNodes(document, visibles) {
  if (!visibles.length) {
    return [];
  }

  const invisibles = [];
  const start = visibles[0];
  const end = visibles[visibles.length - 1];
  const topHalfInvisibles = lodash.takeWhile(document.nodes, n => n.key !== start);
  const bottomHalfInvisibles = lodash.takeRightWhile(document.nodes, n => n.key !== end).reverse();

  while (topHalfInvisibles.length || bottomHalfInvisibles.length) {
    if (topHalfInvisibles.length) {
      invisibles.push(topHalfInvisibles.pop());
    }

    if (bottomHalfInvisibles.length) {
      invisibles.push(bottomHalfInvisibles.pop());
    }
  }

  return invisibles.reverse();
}

function jsonMLGetDescription(asl, options) {
  // 仅最外层会用到currParagraph
  let currParagraph = asl[0] === 'root' ? 0 : null;
  const children = jsonMLGetChildren(asl);
  const validChildren = [];

  if (!Array.isArray(children)) {
    return asl;
  }

  for (const childAsl of children) {
    if (typeof currParagraph === 'number') {
      currParagraph++;

      if (options && typeof options.maxParagraph === 'number' && currParagraph > options.maxParagraph) {
        break;
      }
    }

    if (!(options && Array.isArray(options.ignore) && options.ignore.includes(childAsl[0]))) {
      validChildren.push(jsonMLGetDescription(childAsl, options));
    }
  }

  return [...jsonMLGetTagNameAndAttributes(asl), ...validChildren];
}
function jsonMLGetTagName(elem) {
  return elem[0] || '';
}

function isElement(maybeElem) {
  return Array.isArray(maybeElem) && typeof maybeElem[0] === 'string' || typeof maybeElem === 'string';
}

function isAttributes(maybeAttrs) {
  return !!maybeAttrs && typeof maybeAttrs === 'object' && !Array.isArray(maybeAttrs);
}

function jsonMLGetLastChild(node) {
  const children = jsonMLGetChildren(node);
  return children.length ? children[children.length - 1] : null;
}
function JsonMLHasAttributes(maybeElem) {
  return isElement(maybeElem) && isAttributes(maybeElem[1]);
}
function jsonMLGetAttributes(elem) {
  return JsonMLHasAttributes(elem) ? elem[1] : null;
}

function jsonMLGetTagNameAndAttributes(elem) {
  return JsonMLHasAttributes(elem) ? elem.slice(0, 2) : elem.slice(0, 1);
}

function jsonMLGetChildren(elem) {
  return JsonMLHasAttributes(elem) ? elem.slice(2) : elem.slice(1);
}
function jsonMLAppend(elem, ...children) {
  return [...elem.slice(0), ...children.slice(0)];
}
function jsonMLAppendAt(elem, index, ...children) {
  const meta = JsonMLHasAttributes(elem) ? elem.slice(0, 2) : elem.slice(0, 1);
  const ch = jsonMLGetChildren(elem);
  ch.splice(index, 0, ...children);
  return [...meta, ...ch];
}
function jsonMLIsEmptyContent(content) {
  const children = jsonMLGetChildren(content);

  if (children.length > 1) {
    return false;
  }

  const child = children[0];

  if (!child) {
    return true;
  }

  if (jsonMLGetTagName(child) !== 'p') {
    return false;
  }

  const grandChildren = jsonMLGetChildren(child);

  if (grandChildren.length > 1) {
    return false;
  }

  const grandChild = grandChildren[0];
  const grandChildAttrs = jsonMLGetAttributes(grandChild);

  if (grandChildAttrs && grandChildAttrs['data-type'] !== 'text') {
    return false;
  }

  const grandGrandChildren = jsonMLGetChildren(grandChild);

  if (grandGrandChildren.length > 1) {
    return false;
  }

  const grandGrandChild = grandGrandChildren[0];

  if (grandGrandChild) {
    const grandGrandChildAttrs = jsonMLGetAttributes(grandGrandChild);

    if (grandGrandChildAttrs && grandGrandChildAttrs['data-type'] !== 'leaf') {
      return false;
    }

    if (jsonMLGetChildren(grandGrandChild).join('')) {
      return false;
    }
  }

  return true;
}
/**
 * 读取 asl 中的纯文本（leaf 节点）
 * @param jsonML
 */

function jsonMLGetText(jsonML) {
  // 如果当前节点是叶子节点，则直接返回字符串
  const attrs = jsonMLGetAttributes(jsonML);

  if (attrs && attrs['data-type'] === 'leaf') {
    return jsonML[2] || '';
  } // 遍历孩子节点


  const children = jsonMLGetChildren(jsonML);
  return children.reduce((text, child) => {
    return text + jsonMLGetText(child);
  }, '');
}
function jsonMLIsText(node) {
  return jsonMLGetTagName(node) === 'span' && jsonMLGetAttributes(node)?.['data-type'] === 'text';
}

function isElementValue(node) {
  return Element$1.isElement(node);
}
function isDocumentValue(node) {
  return Document.isDocument(node);
}

/**
 * @export
 * @param {NamedNodeMap} attrs
 * @description 将 Node 节点的 attributes 属性转成 JSON 对象
 */

function nodeMapToObject(attrs) {
  const obj = {
    styleObj: {}
  };

  for (let i = attrs.length - 1; i >= 0; i--) {
    if (attrs[i].value !== '') {
      obj[attrs[i].name] = attrs[i].value;
    }
  }

  return obj;
}
/**
 * @export
 * @param {string} [styleStr='']
 * @return {*}  {Partial<CSSStyleDeclaration>}
 * @description 将 inlineStyle 字符串转为 驼峰格式的 JSON 对象
 */

function toStyleObject(styleStr = '') {
  if (!styleStr) {
    return {};
  }

  const output = {};
  const style = styleStr.split(';');

  for (let i = style.length - 1; i >= 0; i--) {
    const rule = style[i];

    if (rule) {
      const kv = rule.split(':');
      output[lodash.camelCase(lodash.trim(kv[0] || ''))] = lodash.trim(kv[1] || '');
    }
  }

  return output;
}
/**
 * @export
 * @param {string} str
 * @return {*}
 */

function normalizeSpacesInHTML(str) {
  return str.replace(/\s*\n\s*/g, '');
}

function createTextWithString(text) {
  return ['span', {
    'data-type': 'text'
  }, ['span', {
    'data-type': 'leaf'
  }, text]];
}
const createEmptyText = () => createTextWithString('');

function createEmptyParagraph(type = 'p') {
  return [type, createTextWithString('')];
}

function createJsonMLToValue$1(jsonMLToNode, strictSchema) {
  /**
   * 序列化整个 ASL 文档
   * @param jsonML content ASL
   * @param options 序列化参数
   */
  function jsonMLToValue(jsonML, options = {}) {
    const children = jsonMLGetChildren(jsonML);
    let newJsonML = jsonML;

    if (!(children && children.length > 0)) {
      newJsonML = jsonMLAppend(jsonML, createEmptyParagraph());
    }

    const document = jsonMLToNode(newJsonML); // 非 document 节点直接抛错

    if (!isDocumentValue(document)) {
      throw new Error(`Invalid jsonML, expect a document at the root of jsonML, but received ${JSON.stringify(jsonML, null, 2)}`);
    }

    const value = Value.create({
      document
    });
    const {
      normalize = true,
      strict = false
    } = options;
    const toNormalize = normalize || strict;
    if (!toNormalize) return value; // 加载一个 scheme plugin 对 value 进行 normalize

    const schemaPlugin = strict ? [{
      schema: strictSchema,
      models: []
    }] : [];
    const controller = Controller.create({
      value,
      plugins: schemaPlugin
    });
    return controller.value;
  }

  return jsonMLToValue;
}

function createAsyncValueToJsonML(asyncNodeToJsonML) {
  /**
   * 序列化 value to ASL
   * @param value
   */
  async function valueToJsonML(value) {
    return asyncNodeToJsonML(value.document);
  }

  return valueToJsonML;
}
function createValueToJsonML$1(nodeToJsonML) {
  /**
   * 序列化 value to ASL
   * @param value
   */
  function valueToJsonML(value) {
    return nodeToJsonML(value.document);
  }

  return valueToJsonML;
}

function createJsonMLToNode(plugins) {
  const rules = plugins.map(plugin => plugin.jsonMLToValue).filter(rule => !!rule);
  return function jsonMLToNode(jsonML, parent) {
    const rule = rules.find(r => r.match(jsonML, parent));

    if (!rule) {
      throw new Error(`Cannot find any rule which match ${JSON.stringify(jsonML, null, 2)}`);
    }

    let node = rule.convert(jsonML, parent); // Only element value has nodes children

    if (isElementValue(node)) {
      const children = jsonMLGetChildren(jsonML);
      node = node.merge({
        nodes: children.map(c => jsonMLToNode(c, jsonML))
      });
    }

    node = rule.decorate ? rule.decorate(node) : node;
    return node;
  };
}

function safeAppend(elem, children) {
  // BACKGROUND: Safari 下，`...children` 结果可能出现 null child
  if (IS_SAFARI) {
    return elem.slice(0).concat(children.slice(0));
  }

  return jsonMLAppend(elem, ...children);
}

function createAsyncNodeToJsonML(plugins) {
  const rules = plugins.map(plugin => plugin.valueToJsonML).filter(rule => !!rule);
  /**
   * 序列化 node to jsonML
   * @param node
   */

  async function nodeToJsonML(node) {
    const rule = rules.find(r => r.match(node));

    if (!rule) {
      const {
        klass,
        type
      } = node.toJSON();
      throw new Error(`Cannot find any rule which match ${JSON.stringify({
        klass,
        type
      })}`);
    }

    const decorated = rule.decorate ? rule.decorate(node) : node;
    let jsonML;

    if (rule.asyncConvert) {
      jsonML = await rule.asyncConvert(decorated);
    } else {
      jsonML = rule.convert(decorated);
    }

    if (!jsonML) {
      const {
        klass,
        type
      } = node.toJSON();
      throw new Error(`Invalid JsonML! JsonML is ${JSON.stringify({
        klass,
        type
      })}`);
    } // Only element value has nodes children


    if (isElementValue(decorated)) {
      const children = await Promise.all(decorated.nodes.map(child => nodeToJsonML(child)));
      return safeAppend(jsonML, children);
    }

    return jsonML;
  }

  return nodeToJsonML;
}
function createNodeToJsonML(plugins) {
  const rules = plugins.map(plugin => plugin.valueToJsonML).filter(rule => !!rule);
  /**
   * 序列化 node to jsonML
   * @param node
   */

  function nodeToJsonML(node) {
    const rule = rules.find(r => r.match(node));

    if (!rule) {
      const {
        klass,
        type
      } = node.toJSON();
      throw new Error(`Cannot find any rule which match ${JSON.stringify({
        klass,
        type
      })}`);
    }

    const decorated = rule.decorate ? rule.decorate(node) : node;
    const jsonML = rule.convert(decorated);

    if (!jsonML) {
      const {
        klass,
        type
      } = node.toJSON();
      throw new Error(`Invalid JsonML! JsonML is ${JSON.stringify({
        klass,
        type
      })}`);
    } // Only element value has nodes children


    if (isElementValue(decorated)) {
      const children = decorated.nodes.map(child => nodeToJsonML(child));
      return safeAppend(jsonML, children);
    }

    return jsonML;
  }

  return nodeToJsonML;
}

const MeasureStyle = {
  left: '-999px',
  position: 'absolute',
  visibility: 'hidden',
  whiteSpace: 'nowrap',
  zIndex: -999
};
const createIframe = () => {
  const iframe = document.createElement('iframe');

  for (const type in MeasureStyle) {
    iframe.style[type] = MeasureStyle[type];
  } // 开启沙盒模式，防止 xss 攻击


  iframe.setAttribute('sandbox', 'allow-same-origin');
  return iframe;
};

class DomParser {
  constructor() {
    this.domParser = new DOMParser();
    this.doc = void 0;
    this.skipTags = ['HEAD', 'STYLE'];
    this.state = void 0;
    this.onOpenTag = void 0;
    this.onText = void 0;
    this.onCloseTag = void 0;
    this.iframe = createIframe();

    this.init = (callback, options) => {
      const {
        onOpenTag,
        onText,
        onCloseTag
      } = callback;
      this.onOpenTag = onOpenTag;
      this.onText = onText;
      this.onCloseTag = onCloseTag;
      this.state = options.state;
    };

    this.write = chunk => {
      document.body.appendChild(this.iframe);
      this.doc = this.iframe.contentDocument;

      if (this.doc.body) {
        this.doc.body.innerHTML = chunk;
      }

      if (this.state) {
        this.state.htmlDom = this.doc.body;
      }

      this.traverse(this.doc.body);
      document.body.removeChild(this.iframe);
    };

    this.end = () => {
      this.doc = null;
      this.onOpenTag = null;
      this.onText = null;
      this.onCloseTag = null;
    };

    this.traverse = node => {
      if (!this.onText || !this.onOpenTag || !this.onCloseTag) {
        return;
      }

      if (node.nodeType === Node.TEXT_NODE) {
        if (node.textContent && normalizeSpacesInHTML(node.textContent)) {
          this.onText(node.textContent);
        }

        return;
      }

      if ([Node.ELEMENT_NODE, Node.DOCUMENT_NODE, Node.DOCUMENT_FRAGMENT_NODE].includes(node.nodeType)) {
        const {
          tagName: originTagName,
          attributes
        } = node;

        if (this.skipTags.includes(originTagName)) {
          return;
        }

        const traverseChildNodes = () => {
          Array.from(node.childNodes || []).forEach(child => {
            this.traverse(child);
          });
        };

        if (originTagName) {
          const tagName = originTagName.toLowerCase();
          const attrs = nodeMapToObject(attributes);
          const element = node;
          attrs.styleObj = window.getComputedStyle(element);
          const id = uuid.v1();

          if (this.state) {
            this.state.currentDom = element;
          }

          this.onOpenTag(tagName, attrs, id);
          traverseChildNodes();
          this.onCloseTag(tagName, attrs, id);
        } else {
          traverseChildNodes();
        }
      }
    };
  }

}

class State {
  // 这里用于记录zhi渲染的list的level, TODO 需要和getListLevel统一
  constructor(props) {
    this.root = ['root'];
    this.current = this.root;
    this.stack = [];
    this.marksList = [];
    this.listsList = [];
    this.htmlDom = void 0;
    this.currentDom = void 0;
    this.currentListId = null;
    this.currentListLevel = null;

    if (props.htmlDom) {
      this.htmlDom = props.htmlDom;
    }
  }

  addMarks(marks) {
    this.marksList.push(marks);
  }

  removeMarks(marks) {
    this.marksList = this.marksList.filter(m => m.id !== marks.id);
  }

  getMarks() {
    return this.marksList.reduce((attrs, marks) => ({ ...attrs,
      ...marks.value
    }), {});
  }

  wrapList(type) {
    this.listsList.push(type);
  }

  unwrapList() {
    this.listsList.pop();
  }

  isParentOrderedList() {
    return this.listsList[this.listsList.length - 1] === 'ordered-list';
  }

  getListItemLevel() {
    return this.listsList.length - 1;
  }

  append(...nodes) {
    nodes.forEach(node => {
      this.current.push(node);
    });
  }

  push(node) {
    this.stack.push(this.current);
    this.current = node;
  }

  pop() {
    const node = this.current;
    this.current = this.stack.pop() || this.root;
    return node;
  }

  peek() {
    return this.current;
  }

  closest(type) {
    if (jsonMLGetTagName(this.current) === type) {
      return this.current;
    }

    for (let i = this.stack.length - 1; i >= 0; i -= 1) {
      if (jsonMLGetTagName(this.stack[i]) === type) {
        return this.stack[i];
      }
    }

    return null;
  }

  isStackEmpty() {
    return this.stack.length === 0;
  }

  getParent() {
    return this.stack.length > 0 ? this.stack[this.stack.length - 1] : null;
  }

  getJsonML() {
    return this.root;
  }

}

/* eslint-disable guard-for-in */
class Deserializer {
  constructor(options) {
    this.plugins = void 0;
    this.htmlFrom = void 0;
    this.parser = void 0;
    this.iframe = createIframe();
    this.plugins = options.plugins;
    this.htmlFrom = options.htmlFrom;
    this.parser = options.parser || new DomParser();
  }

  isDomParser() {
    return this.parser instanceof DomParser;
  }

  deserialize(html, configs = {}) {
    const state = new State({});

    if (!this.isDomParser()) {
      document.body.appendChild(this.iframe);
      const {
        body: htmlDom
      } = this.iframe.contentDocument;

      if (htmlDom) {
        htmlDom.innerHTML = html;
      }

      state.htmlDom = htmlDom;
    }

    let rules = this.plugins.map(plugin => {
      const {
        htmlToJsonML
      } = plugin;

      if (htmlToJsonML) {
        return typeof htmlToJsonML === 'function' ? htmlToJsonML(this.htmlFrom) : htmlToJsonML;
      }

      return null;
    }).filter(rule => !!rule);
    rules = rules.map(rule => {
      if (!!rule.name && rule.name in configs) {
        rule = { ...rule,
          ...configs[rule.name]
        };
      }

      return rule;
    });

    function onEvent(event, ...args) {
      for (let i = 0; i < rules.length; i += 1) {
        const rule = rules[i][event];

        if (!rule) {
          continue; // eslint-disable-line no-continue
        } // @ts-ignore


        const ok = rule(state, ...args);
        if (ok) break;
      }
    }

    this.parser.init({
      onOpenTag(...args) {
        onEvent('onOpenTag', ...args);
      },

      onText(...args) {
        onEvent('onText', ...args);
      },

      onCloseTag(...args) {
        onEvent('onCloseTag', ...args);
      }

    }, {
      decodeEntities: true,
      state
    });
    this.parser.write(html);
    this.parser.end();

    if (!this.isDomParser()) {
      document.body.removeChild(this.iframe);
    }

    return state.getJsonML();
  }

}

const MS_WORD = 'MS_WORD';
const MS_EXCEL = 'MS_EXCEL'; // word、excel 以外的 office

const MS_OFFICE = 'MS_OFFICE';
const MS_OFFICES = [MS_WORD, MS_EXCEL, MS_OFFICE];
const YUQUE = 'YUQUE'; // 以下复制来源，保留所有样式

const REMAIN_STYLE_SOURCES = [MS_WORD, MS_EXCEL, MS_OFFICE, YUQUE];
function isMicrosoftWord(html) {
  return Boolean(html?.includes('xmlns:w="urn:schemas-microsoft-com:office:word"'));
}
function isMicrosoftExcel(html) {
  return Boolean(html?.includes('xmlns:x="urn:schemas-microsoft-com:office:excel"'));
}
function isMicrosoftOffice(html) {
  return Boolean(html?.includes('xmlns:x="urn:schemas-microsoft-com"'));
}
function isYuqueDocs(html) {
  return Boolean(html?.includes('<meta name="source" content="lake"/>') || html?.includes('class="lake-content"'));
}
function getHtmlFrom(html) {
  if (isMicrosoftWord(html)) {
    return MS_WORD;
  }

  if (isMicrosoftExcel(html)) {
    return MS_EXCEL;
  }

  if (isMicrosoftOffice(html)) {
    return MS_OFFICE;
  }

  if (isYuqueDocs(html)) {
    return YUQUE;
  }

  return 'web';
}

function getJsonMLFromAttr(root) {
  const clipboardDataNode = root.querySelector(`[${DATA_CLIPBORAD_CANGJIE}]`);
  /**
   * 需要判断数据节点是否是第一个，防止一些 html 夹杂着无用的 data-clipboard-data 节点，导致误解析
   */

  if (clipboardDataNode && root.body.firstElementChild === clipboardDataNode) {
    const clipboardData = clipboardDataNode.getAttribute(DATA_CLIPBORAD_CANGJIE);

    try {
      return JSON.parse(clipboardData);
    } catch (e) {
      // @ali/4ever-logger 依赖库里面有浏览器环境依赖，导致 server cp 脚本无法运行
      console.error(e);
    }
  }

  return null;
}

function createHtmlToJsonML(plugins, parser) {
  return function htmlToJsonML(html, configs = {}) {
    const htmlFrom = getHtmlFrom(html);
    const domParser = new DOMParser();
    const parsedDocument = domParser.parseFromString(html, 'text/html');
    const domJsonML = getJsonMLFromAttr(parsedDocument);
    if (domJsonML) return domJsonML;
    const deserializer = new Deserializer({
      plugins,
      htmlFrom,
      parser
    });
    const parsedHTML = parsedDocument.lastElementChild;
    return deserializer.deserialize(parsedHTML.outerHTML, configs);
  };
}

/* eslint-disable max-len */
const _createElement$i = React__namespace.createElement;

function jsonMLToHTML$1(props, node, path = []) {
  const {
    rules
  } = props;
  let rule = rules.find(r => r.match(node));

  if (!rule) {
    rule = {
      name: 'default',
      match: () => false,

      convert(node, key = [], convert) {
        const children = jsonMLGetChildren(node).map((child, index) => convert(child, [...key, index]));
        return /*#__PURE__*/_createElement$i(React__namespace.Fragment, null, children);
      }

    };
  }

  const convert = (...args) => {
    return jsonMLToHTML$1(props, ...args);
  };

  const element = rule.convert(node, path, convert);
  if (!element) return null;
  const elementWithKey = /*#__PURE__*/React__namespace.isValidElement(element) ? /*#__PURE__*/React__namespace.cloneElement(element, {
    key: (element.props.path || []).toString()
  }) : element;
  return elementWithKey;
}

function HTMLProvider(props) {
  const {
    content,
    rules,
    ...rest
  } = props;
  const elem = jsonMLToHTML$1(props, content);
  if (!elem) return null;
  return /*#__PURE__*/React__namespace.cloneElement(elem, rest);
}

function createJsonMLToHTML$1(plugins) {
  // 遍历取出 jsonMLToHTML 插件
  const defaultRules = plugins.map(plugin => plugin.jsonMLToHTML).filter(rule => !!rule);
  /**
   * 序列化 JsonML to HTML，主要适用于富文本拷贝导出
   * @param content JsonML 内容
   * @param configs 自定义插件，如果插件名已经存在，则会覆盖原插件的方法
   */

  function contentJsonMLToHTML(content, configs = {}) {
    // 加载 configs 中的插件
    const rules = defaultRules.map(rule => {
      if (rule.name in configs) {
        return { ...rule,
          ...configs[rule.name]
        };
      }

      return rule;
    });
    const before = plugins.map(p => p.jsonMLToHTML?.hooks?.before).filter(p => !!p).reduce((acc, p) => value => p(acc(value)), value => value);

    const elem = _createElement$i(HTMLProvider, {
      content: before(content),
      rules
    });

    return ReactDOMServer__namespace.renderToStaticMarkup(elem);
  }

  return contentJsonMLToHTML;
}

const NEWLINE = '\n';
function createTextToJsonML(plugins) {
  const rules = plugins.map(plugin => plugin.textToJsonML).filter(rule => !!rule);
  /**
   * 纯文本序列化成 ASL
   * @param text
   */

  function textToJsonML(text) {
    return normalizeText$2(text).split(NEWLINE).reduce((jsonML, line) => {
      const rule = rules.find(r => r.match(line));
      let children;

      if (rule) {
        children = rule.convert(line) || [];
      } else {
        children = [createTextWithString(line)];
      }

      const paragraph = jsonMLAppend(['p'], ...children);
      return jsonMLAppend(jsonML, paragraph);
    }, ['root']);
  }

  return textToJsonML;
}

function createNodeToText(plugins) {
  const rules = plugins.map(plugin => plugin.valueToText).filter(rule => !!rule);

  function nodeToText(node) {
    let rule = rules.find(item => item.match(node));

    if (!rule) {
      rule = {
        name: 'default',
        match: () => false,
        convert: n => {
          const {
            text
          } = n; // 块级元素在末尾追加换行

          if (Block.isBlock(node)) {
            return `${text}\n`;
          }

          return text;
        }
      };
    }

    const text = rule.convert(node, nodeToText);
    return text;
  }

  return nodeToText;
}

function createValueToText$1(nodeToText, injectValueData = v => v) {
  function valueToText(value) {
    // 计算好 injection
    const injectedValue = injectValueData(value);
    const texts = injectedValue.document.nodes.map(node => {
      return nodeToText(node);
    });
    let text = texts.join(''); // 末尾处的断行要移除掉
    // block 节点会附带一个 \n，但是用户选区中的断行需要保留，所以这里只移除一个 \n

    if (text.endsWith('\n')) {
      text = text.substring(0, text.length - 1);
    }
    /**
     * 从 Excel 中复制表格，纯文本粘贴会附带 \t,当 \t 足够多时会造成渲染性能问题。
     * https://notes.dingtalk.com/doc/E0Vzg7l3wnjKAzJe?orgId=16872003&dd_progress=false&showmenu=false
     * */


    text = text.replace(/\t+/g, '    ');
    return text;
  }

  return valueToText;
}

const markdownRuleNameMap = {
  table: ['table'],
  code: ['code', 'fence'],
  blockquote: ['blockquote'],
  hr: ['hr'],
  list: ['list'],
  heading: ['heading', 'lheading'],
  codespan: ['backticks'],
  strikethrough: ['strikethrough'],
  emphasis: ['emphasis'],
  link: ['link', 'autolink'],
  image: ['image'],
  html: ['html_block', 'html_inline']
};
async function createMarkdownToHTML(plugins) {
  const rules = plugins.map(plugin => plugin.markdownToHTML).filter(rule => !!rule); // default，从原 basic 插件迁移

  rules.push({
    ruleName: 'html',
    options: {
      html: true,
      xhtmlOut: true
    }
  }); // async loading markdown-it

  const MarkdownIt = (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require(
  /* webpackChunkName: 'cangjie-lib-markdown-it'*/
  'markdown-it')); })).default;
  const md = new MarkdownIt('zero'); // 应用 rule 到 md

  const summary = {
    names: [],
    options: {},
    rewrite: {},
    uses: []
  };
  rules.forEach(rule => {
    if (rule.ruleName) {
      summary.names.push(...markdownRuleNameMap[rule.ruleName]);
    }

    if (rule.options) {
      summary.options = { ...summary.options,
        ...rule.options
      };
    }

    if (rule.rewrite) {
      rule.rewrite.forEach(({
        name,
        createRenderer
      }) => {
        if (createRenderer) {
          summary.rewrite[name] = {
            renderer: createRenderer(md)
          };
        }
      });
    }

    if (rule.uses) {
      summary.uses.push(...rule.uses);
    }
  });
  md.enable(summary.names).set(summary.options);

  for (let name in summary.rewrite) {
    if (md.renderer.rules[name] && summary.rewrite[name].renderer) {
      md.renderer.rules[name] = summary.rewrite[name].renderer;
    }
  }

  for (let {
    plugin: pluginLoader,
    data
  } of summary.uses) {
    const plugin = await pluginLoader();
    const d = typeof data === 'function' ? await data() : data;
    md.use(plugin.default, ...(d || []));
  }

  function markdownToHTML(markdown) {
    const res = md.render(markdown);
    return res;
  }

  return markdownToHTML;
}

async function createHtmlToMarkdown(plugins) {
  const rules = plugins.map(plugin => plugin.htmlToMarkdown).filter(rule => !!rule);
  const Turndown = (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require(
  /* webpackChunkName: 'cangjie-lib-turndown'*/
  'turndown')); })).default;
  const turndownService = new Turndown({
    headingStyle: 'atx'
  });
  rules.forEach(rule => {
    const pluginRule = lodash.pick(rule, ['filter', 'replacement']);

    if (!lodash.isEmpty(pluginRule)) {
      turndownService.addRule(rule.name, pluginRule);
    }

    if (rule.use) {
      turndownService.use(rule.use);
    }
  });
  return html => {
    return turndownService.turndown(html);
  };
}

const _createElement$h = React__namespace.createElement;
var jsonMLToHTML = {
  name: 'root',

  match(node) {
    return jsonMLGetTagName(node) === 'root';
  },

  convert(node, key = [], convert) {
    const children = jsonMLGetChildren(node).map((child, index) => convert(child, [...key, index]));
    return /*#__PURE__*/_createElement$h("article", {
      className: "4ever-article"
    }, children);
  }

};

var jsonMLToValue = {
  name: 'document',

  match(node) {
    return jsonMLGetTagName(node) === 'root';
  },

  convert(node) {
    return Document.create({
      data: jsonMLGetAttributes(node) || {}
    });
  }

};

var valueToJsonML = {
  match(node) {
    return Document.isDocument(node);
  },

  convert(node) {
    return ['root', node.data];
  }

};

const schema = {
  document: {
    nodes: [{
      min: 1
    }],
    normalize: (controller, error) => {
      const {
        code,
        node
      } = error;

      if (code === 'child_min_invalid' && !node.nodes.length) {
        let defaultBlock = controller.query('getDefaultBlock');

        if (!defaultBlock) {
          defaultBlock = Block.create({
            type: Block.DEFAULT_TYPE
          });
        }

        if (defaultBlock) {
          controller.command(insertNodeByKey, node.key, 0, defaultBlock);
        } else {
          throw Error('normalize error in document plugin schema, no plugin implement getDefaultBlock query');
        }
      }
    }
  }
};

const createSerializerPlugin$1 = () => ({
  jsonMLToHTML,
  jsonMLToValue,
  valueToJsonML
});

function createSchema(plugins) {
  const s = plugins.reduce((prevSchema, plugin) => {
    if (!plugin.schemas) {
      return prevSchema;
    }

    const schemas = Array.isArray(plugin.schemas) ? plugin.schemas : [plugin.schemas];
    schemas.forEach(schema => {
      // document 是内部插件, 用到特殊定义，在内部处理
      const {
        type,
        isBlock,
        isVoid,
        isEdgeSelectable,
        schema: oldSchema
      } = schema;
      let val = {};

      if (['boolean', 'function'].includes(typeof isVoid)) {
        val.isVoid = isVoid;
      }

      if (typeof isEdgeSelectable === 'boolean') {
        val.isEdgeSelectable = isEdgeSelectable;
      }

      if (oldSchema) {
        val = { ...val,
          ...oldSchema
        };
      }

      if (type === 'document') {
        prevSchema['document'] = { ...prevSchema['document'],
          ...val
        };
      } else {
        prevSchema[isBlock || isBlock === undefined ? 'blocks' : 'inlines'][type] = val;
      }
    });
    return prevSchema;
  }, { ...schema,
    blocks: {},
    inlines: {}
  });
  return s;
}
/**
 * 兼容原先 strictSchema 定义。新增的规则都在插件中指定，schema 和 strictSchema 都支持。
 * 
 * 1. document 下只能是已注册的 block type
 * 2. heading1-5, paragraph 下只能是已注册的 inline type
 * 3. table 的 schema 跟 @一辙 讨论了下， 考虑存量数据兼容，还是不在 table 里指定，保留在 strictSchema 中。
 */

function createStrictSchema(plugins) {
  const schema = createSchema(plugins);
  const blockTypes = Object.keys(schema.blocks);
  const inlineTypes = Object.keys(schema.inlines);
  schema.document = { ...schema.document,
    nodes: [{
      match: blockTypes.map(t => ({
        type: t
      })),
      min: 1
    }]
  };
  ['paragraph', 'heading-1', 'heading-2', 'heading-3', 'heading-4', 'heading-5', 'heading-6'].forEach(type => {
    if (schema.blocks?.[type]) {
      schema.blocks[type] = { ...schema.blocks[type],
        nodes: [{
          match: [...inlineTypes.map(t => ({
            type: t
          })), {
            klass: 'text'
          }]
        }],
        normalize: (controller, error) => {
          const {
            code,
            child,
            node
          } = error;

          if (code === 'child_type_invalid' && blockTypes.includes(child.type)) {
            const parent = controller.value.document.getParent(node.key);

            if (parent) {
              const index = parent.nodes.indexOf(node.key);
              controller.command(moveNodeByKey, child.key, parent.key, index);
            }
          }
        }
      };
    }
  }); // 指定 table 插件时的特殊处理

  if (schema.blocks?.['table']) {
    const extra = {
      'table': {
        isEdgeSelectable: true,
        nodes: [{
          match: {
            type: 'table-row'
          },
          min: 1
        }]
      },
      'table-row': {
        nodes: [{
          match: {
            type: 'table-cell'
          },
          min: 1
        }]
      },
      'table-cell': {
        nodes: [{
          match: blockTypes.map(t => ({
            type: t
          })),
          min: 1
        }],
        normalize: (controller, error) => {
          const {
            code,
            child,
            node
          } = error;

          if (code === 'child_type_invalid' && node.nodes.length === 1) {
            controller.command(removeNodeByKey, child.key);
            let defaultBlock = controller.query('getDefaultBlock', node.nodes);

            if (!defaultBlock) {
              if (!defaultBlock) {
                defaultBlock = Block.create({
                  type: Block.DEFAULT_TYPE
                });
              }
            }

            controller.command(insertNodeByKey, node.key, 0, defaultBlock);
          } else if (!node.nodes.length) {
            let defaultBlock = Block.create({
              type: 'paragraph'
            });

            if (!defaultBlock) {
              defaultBlock = Block.create({
                type: Block.DEFAULT_TYPE
              });
            }

            controller.command(insertNodeByKey, node.key, 0, defaultBlock);
          } else {
            controller.command(removeNodeByKey, child.key);
            const index = node.nodes.indexOf(child);

            for (let i = index + 1; i < node.nodes.length - 1; i++) {
              const c = node.nodes[i];

              if (!blockTypes.includes(c.type)) {
                controller.command(removeNodeByKey, c.key);
              }
            }
          }
        }
      }
    };
    Object.keys(extra).forEach(type => {
      schema.blocks[type] = { ...(schema.blocks[type] || {}),
        ...extra[type]
      };
    });
  }

  return schema;
}

/**
 * 一般使用的有两种空白符，空格敲击的空白符（Simple space）码点是 32，Non-breaking space 的码点是 160
 * 在 Word 的规范中，32 码点的字符会被裁剪掉，160 码点会保留，裁剪规则如下：
 * - 文字头端的所有连续 32 码点空白符会被全部裁剪（同时也包括了 \n 符号）；
 * - 文字中端和尾端的所有连续 32 码点空白符会合并（Collapse）成一个空白符；
 * @see https://stackoverflow.com/questions/11984029/difference-between-32-and-nbsp
 */

const SIMPLE_SPACE_CODE = 32; // \n 符号

const BREAK_CODE = 10; // 需要被替换为\n的字符
const HEAD_TAG_REG = /^h\d$/i; // TODO: 兼容原 text 插件逻辑，待重构

const paragraphTags = {
  h1: 'h1',
  h2: 'h2',
  h3: 'h3',
  h4: 'h4',
  h5: 'h5',
  h6: 'h6',
  p: 'p',
  div: 'p',
  section: 'p'
}; // 解析非文档 html, 使用仓颉默认的字体大小等样式

function normalizeMarks(tagName, marks) {
  if (HEAD_TAG_REG.test(tagName)) {
    return lodash.omit(marks, ['vertAlign', 'sz', 'szUnit']);
  }

  return marks;
}
/**
 * Normalize 一行文本，剔除文本前面的空白符
 * @note 注意 Word 的规范中只会对 text/html 中的空白符进行裁剪，text/plain 中的空白符会保留
 * @param text
 */


function normalizeText$1(text) {
  let index = 0;

  for (; index < text.length; index++) {
    const code = text.charCodeAt(index);

    if (code === SIMPLE_SPACE_CODE || // 空格符号过滤
    code === BREAK_CODE // 断行符号过滤
    ) {
        continue;
      }

    break;
  } // 裁剪头端所有的空格符和断行符


  text = text.slice(index, text.length); // 合并中端和尾端的空格符

  text = text.replace(/ +/g, String.fromCharCode(SIMPLE_SPACE_CODE));
  return normalizeText$2(text);
}

function createHTMLToJsonML(htmlToAttrs) {

  const converts = htmlToAttrs.filter(f => !!f);

  function generateMarks(tag, attrs) {
    let marks = converts.reduce((prev, convert) => {
      return convert(tag, { ...attrs
      }, { ...prev
      });
    }, {});
    return lodash.isEmpty(marks) ? null : marks;
  }

  return function (pasteFrom) {
    return {
      name: 'text',
      onOpenTag: (state, name, attrs, id) => {
        const marks = generateMarks(name, attrs);

        if (marks) {
          state.addMarks({
            id,
            value: marks
          }); // fall through
        }

        return false;
      },
      onText: (state, text) => {
        let texts = [text]; // ['p']

        let parent = state.peek(); // ['span', { 'data-type': 'text' }]

        let prevSibling = jsonMLGetLastChild(parent);
        const parentTagName = jsonMLGetTagName(parent); // TODO 待改造

        if (!paragraphTags[parentTagName] && parentTagName !== 'a' && parentTagName !== 'inlineCode') {
          if (!prevSibling || !prevSibling.isPhantom) {
            const phantom = ['p'];
            phantom.isPhantom = true;
            parent = phantom;
            prevSibling = null;
            state.append(phantom);
          } else {
            parent = prevSibling;
            prevSibling = jsonMLGetLastChild(parent);
          }
        } // \n 只有出现在 a 及 p 中才被转换


        if (MS_OFFICES.includes(pasteFrom)) {
          // office 中的 \n 没有包含在 white-space: pre 中，统一作空格字符串使用
          texts = texts.map(txt => txt.replace(/\n/g, ' '));
        }

        let marks = state.getMarks();
        const parentType = parent[0];

        if (HEAD_TAG_REG.test(parentType) && !REMAIN_STYLE_SOURCES.includes(pasteFrom)) {
          marks = normalizeMarks(parentType, marks);
        }

        const leafAttrs = { ...marks,
          'data-type': 'leaf'
        }; // 如果 p 下面没有 text 节点

        if (!prevSibling || !jsonMLIsText(prevSibling)) {
          prevSibling = ['span', {
            'data-type': 'text'
          }];
          parent.push(prevSibling);
        }

        texts.forEach((txt, index) => {

          const prevLeaf = jsonMLGetLastChild(prevSibling); // 如果是空段落，则 normalize text

          if (!prevLeaf || jsonMLGetText(parent) === '') {
            txt = normalizeText$1(txt);
          }

          const leaf = ['span', leafAttrs, txt]; // 如果是空 text 或者与上一个 leaf 属性不匹配，则 push

          if (!prevLeaf || !equal__default["default"](leafAttrs, jsonMLGetAttributes(prevLeaf))) {
            prevSibling.push(leaf);
          } else {
            // 相同属性的 leaf 则 concat
            prevLeaf[prevLeaf.length - 1] += txt;
          }
        });
        return false;
      },
      onCloseTag: (state, name, attrs, id) => {
        state.removeMarks({
          id
        }); // fall through

        return false;
      }
    };
  };
}

function attrsToMarks(attrs, converts) {
  const handledKeys = new Set();
  const marks = converts.reduce((prev, convert) => {
    const rst = convert(attrs);
    if (!rst) return [...prev];
    const {
      keys,
      marks
    } = rst;
    keys.forEach(k => handledKeys.add(k));
    return [...prev, ...marks];
  }, []);
  const restKeys = Object.keys(attrs).filter(k => k !== 'data-type' && !handledKeys.has(k));
  restKeys.forEach(key => {
    const data = attrs[key];
    let markData = data;
    const isObj = typeof data === 'object' && !!data && !Array.isArray(data);

    if (!isObj) {
      // not a object
      markData = {
        value: data
      };
    }

    marks.push({
      type: key,
      data: markData
    });
  });
  return marks;
}

function createJsonMLToValue(attrToMarks) {
  const converts = attrToMarks.filter(f => !!f);
  const rule = {
    name: 'text',
    match: node => {
      return jsonMLIsText(node);
    },
    convert: node => {
      return Text$1.create({
        // @ts-ignore 
        leaves: jsonMLGetChildren(node).map(leaf => {
          const marks = attrsToMarks(jsonMLGetAttributes(leaf), converts);
          return {
            text: String(jsonMLGetChildren(leaf)[0]),
            marks
          };
        })
      });
    }
  };
  return rule;
}

const _createElement$g = React__namespace.createElement;

/**
 * 在 Word 的 CCP 导出规范中，文档中的空白符（Simple space）在 text/html 中会全部替换成 &nbsp;（码点 160）
 * 在导出 text/plain 中，则会保留 Simple space 的码点（32）
 */
const NON_BREAKING_SPACE_CODE = 160;

function normalizeText(text) {
  text = text.replace(/ /g, String.fromCharCode(NON_BREAKING_SPACE_CODE));
  return text;
}

function createLeafToElement(jsonMLAttrsToStyles) {
  return (leaf, key) => {
    const attrs = jsonMLGetAttributes(leaf) || {};
    const style = jsonMLAttrsToStyles.reduce((prev, attrToStyle) => {
      return attrToStyle({ ...attrs
      }, { ...prev
      });
    }, {}); // dataType 不需要透出给插件处理，兼容一下旧的 inlineCode

    const dataType = attrs.inlineCode ? 'inlineCode' : 'text';
    const text = normalizeText(jsonMLGetChildren(leaf)[0]);
    return /*#__PURE__*/_createElement$g("span", {
      "data-type": dataType,
      style: style,
      key: key.toString()
    }, text);
  };
}

function createJsonMLToHTML(jsonMLAttrsToStyles) {
  const leafToElement = createLeafToElement(jsonMLAttrsToStyles.filter(f => !!f));
  return {
    name: 'text',
    match: node => {
      return jsonMLIsText(node);
    },
    convert: (node, key) => {
      const children = jsonMLGetChildren(node).map((leaf, index) => leafToElement(leaf, [...key, index]));
      return /*#__PURE__*/_createElement$g(React__namespace.Fragment, null, children);
    }
  };
}

function marksToAttrs(marks, converts) {
  return marks.reduce((attrs, mark) => {
    let textMark;

    for (let i = 0, len = converts.length; i < len; i++) {
      const m = converts[i](mark);

      if (m) {
        textMark = m;
        break;
      }
    }

    if (!textMark) {
      textMark = {
        [mark.type]: mark.data
      };
    }

    return { ...attrs,
      ...textMark
    };
  }, {});
}
function createValueToJsonML(markToAttrs) {
  const converts = markToAttrs.filter(f => !!f);
  const rule = {
    match: node => {
      return Text$1.isText(node);
    },
    convert: node => {
      return ['span', {
        'data-type': 'text'
      }, // @ts-ignore
      ...node.leaves.reduce((acc, leaf) => [...acc, ['span', { ...marksToAttrs(leaf.marks, converts),
        'data-type': 'leaf'
      }, leaf.text]], [])];
    }
  };
  return rule;
}

const valueToText = {
  name: 'text',

  match(node) {
    return Text$1.isText(node);
  },

  convert(node) {
    return node.text;
  }

};
function createValueToText() {
  return valueToText;
}

const createSerializerPlugin = plugins => {
  return {
    htmlToJsonML: createHTMLToJsonML(plugins.map(p => p.leaf?.htmlToJsonMLAttrs)),
    jsonMLToHTML: createJsonMLToHTML(plugins.map(p => p.leaf?.jsonMLAttrsToStyle)),
    jsonMLToValue: createJsonMLToValue(plugins.map(p => p.leaf?.jsonMLAttrsToMarks)),
    valueToJsonML: createValueToJsonML(plugins.map(p => p.leaf?.markToJsonMLAttrs)),
    valueToText: createValueToText()
  };
};

/**
 * @packageDocumentation
 * @module Serializer
 */

function createBase(p, schema) {
  const plugins = [createSerializerPlugin$1(), createSerializerPlugin(p), ...p];
  const jsonMLToNode = createJsonMLToNode(plugins);
  const jsonMLToValue = createJsonMLToValue$1(jsonMLToNode, schema);
  const nodeToJsonML = createNodeToJsonML(plugins);
  const valueToJsonML = createValueToJsonML$1(nodeToJsonML);
  return {
    // 反序列化 ASL
    jsonMLToValue,
    // 序列化 ASL
    valueToJsonML,
    // 主要用于 operation 序列化、反序列化
    jsonMLToNode,
    nodeToJsonML
  };
}

function createText(p, base) {
  const plugins = [createSerializerPlugin(p), ...p, createSerializerPlugin$1()];
  const beforeValueToText = plugins.map(p => p.valueToText?.hooks?.before).filter(p => !!p).reduce((acc, p) => value => p(acc(value)), value => value);
  const textToJsonML = createTextToJsonML(plugins);
  const nodeToText = createNodeToText(plugins);
  const valueToText = createValueToText$1(nodeToText, beforeValueToText);
  return {
    // 纯文本粘贴
    textToJsonML,
    textToValue: function textToValue(text) {
      return base.jsonMLToValue(textToJsonML(text));
    },
    // 纯文本导出
    valueToText
  };
}

function createHtml(p, base, parser) {
  const plugins = [createSerializerPlugin(p), ...p, createSerializerPlugin$1()];
  const htmlToJsonML = createHtmlToJsonML(plugins, parser);
  const jsonMLToHTML = createJsonMLToHTML$1(plugins);
  return {
    // 富文本粘贴
    htmlToJsonML,
    htmlToValue: function htmlToValue(html) {
      return base.jsonMLToValue(htmlToJsonML(html), {
        strict: true
      });
    },
    // 输出 HTML
    jsonMLToHTML,
    valueToHTML: function valueToHTML(value) {
      return jsonMLToHTML(base.valueToJsonML(value));
    }
  };
}

function createAsync(p) {
  const plugins = [createSerializerPlugin(p), ...p, createSerializerPlugin$1()];
  const asyncNodeToJsonML = createAsyncNodeToJsonML(plugins);
  const asyncValueToJsonML = createAsyncValueToJsonML(asyncNodeToJsonML);
  return {
    asyncValueToJsonML
  };
}

function createMarkdown(p, base, hs) {
  const plugins = [createSerializerPlugin(p), ...p, createSerializerPlugin$1()];

  const markdownToJsonML = async markdown => {
    const markdownToHTML = await createMarkdownToHTML(plugins);
    const html = markdownToHTML(markdown);
    return hs.htmlToJsonML(html);
  };

  const jsonMLToMarkdown = async jsonML => {
    const jsonMLToHTML = createJsonMLToHTML$1(plugins);
    const htmlToMarkdown = await createHtmlToMarkdown(plugins);
    return htmlToMarkdown(jsonMLToHTML(jsonML));
  };

  return {
    // markdown 粘贴
    markdownToJsonML,
    markdownToValue: async markdown => {
      const jsonML = await markdownToJsonML(markdown);
      return base.jsonMLToValue(jsonML);
    },
    jsonMLToMarkdown
  };
}

function create(plugins, schema, parser) {
  const baseSerialzer = createBase(plugins, schema);
  const textSerializer = createText(plugins, baseSerialzer);
  const htmlSerializer = createHtml(plugins, baseSerialzer, parser);
  const mdSerializer = createMarkdown(plugins, baseSerialzer, htmlSerializer);
  const asyncSerializer = createAsync(plugins);
  return { ...baseSerialzer,
    ...textSerializer,
    ...htmlSerializer,
    ...mdSerializer,
    ...asyncSerializer
  };
}

function getSchemaAndPluginsFromMoPlugins(plugins) {
  const schema = createSchema(plugins);
  const serializerPlugins = plugins.map(p => p.serializer).filter(s => !!s);
  return {
    schema,
    serializerPlugins
  };
}
/**
 * @deprecated create serializer with `serializations plugins`
 * @returns serializer
 */


const createSerializerOld = create;
/**
 * create serializer only support jsonMl <=> value
 * @param plugins mo plugins
 * @returns serializer
 */

function createBaseSerializer(plugins) {
  const {
    schema,
    serializerPlugins
  } = getSchemaAndPluginsFromMoPlugins(plugins);
  return createBase(serializerPlugins, schema);
}
/**
 * create serializer with jsonMl、html、text、markdown
 * @param plugins mo plugins
 * @param parser optional html parser
 * @returns serializer
 */

function createSerializer(plugins, parser) {
  const {
    schema,
    serializerPlugins
  } = getSchemaAndPluginsFromMoPlugins(plugins);
  return create(serializerPlugins, schema, parser);
}

class Parser {
  constructor() {
    this.skipTags = ['head', 'style'];
    this.isInSkipTag = false;
    this.stack = [];
    this.callbacks = void 0;
    this.parser = void 0;

    this.init = (callbacks, options) => {
      this.callbacks = callbacks;
      this.parser = cangjieLibForTreeShaking.createHtmlParser({
        onopentag: this.onOpenTag,
        ontext: this.onText,
        // @ts-ignore
        onclosetag: this.onCloseTag
      }, options);
    };

    this.onOpenTag = (name, attrs) => {
      if (this.skipTags.includes(name)) {
        this.isInSkipTag = true;
        return;
      }

      if (this.isInSkipTag) return; // @ts-ignore

      attrs.styleObj = toStyleObject(attrs.style);
      const id = uuid.v1();
      this.callbacks?.onOpenTag(name, attrs, id);
      this.stack.push({
        name,
        attrs,
        id
      });
    };

    this.onText = text => {
      if (this.isInSkipTag || !normalizeSpacesInHTML(text)) return;
      this.callbacks?.onText(text);
    };

    this.onCloseTag = name => {
      if (this.skipTags.includes(name)) {
        this.isInSkipTag = false;
        return;
      }

      if (this.isInSkipTag) return;
      const open = this.stack.pop();

      if (!open || open.name !== name) {
        throw new Error(`htmlparser2 doesn't close tag(${name}) correctly!`);
      }

      this.callbacks?.onCloseTag(name, open.attrs, open.id);
    };
  }

  write(chunk) {
    this.parser?.write(chunk);
  }

  end() {
    this.parser?.end();
  }

}

/**
 * 边框样式枚举
 */
let BorderStyleEnum;

(function (BorderStyleEnum) {
  BorderStyleEnum["Single"] = "single";
  BorderStyleEnum["Thick"] = "thick";
  BorderStyleEnum["Double"] = "double";
  BorderStyleEnum["Dotted"] = "dotted";
  BorderStyleEnum["Dashed"] = "dashed";
  BorderStyleEnum["DotDash"] = "dotDash";
  BorderStyleEnum["DotDotDash"] = "dotDotDash";
  BorderStyleEnum["Triple"] = "triple";
  BorderStyleEnum["ThinThickSmallGap"] = "thinThickSmallGap";
  BorderStyleEnum["ThickThinSmallGap"] = "thickThinSmallGap";
  BorderStyleEnum["ThinThickThinSmallGap"] = "thinThickThinSmallGap";
  BorderStyleEnum["ThinThickMediumGap"] = "thinThickMediumGap";
  BorderStyleEnum["ThickThinMediumGap"] = "thickThinMediumGap";
  BorderStyleEnum["ThinThickThinMediumGap"] = "thinThickThinMediumGap";
  BorderStyleEnum["ThinThickLargeGap"] = "thinThickLargeGap";
  BorderStyleEnum["ThickThinLargeGap"] = "thickThinLargeGap";
  BorderStyleEnum["ThinThickThinLargeGap"] = "thinThickThinLargeGap";
  BorderStyleEnum["Wave"] = "wave";
  BorderStyleEnum["DoubleWave"] = "doubleWave";
  BorderStyleEnum["DashSmallGap"] = "dashSmallGap";
  BorderStyleEnum["DashDotStroked"] = "dashDotStroked";
  BorderStyleEnum["ThreeDEmboss"] = "threeDEmboss";
  BorderStyleEnum["ThreeDEngrave"] = "threeDEngrave";
  BorderStyleEnum["Outset"] = "outset";
  BorderStyleEnum["Inset"] = "inset";
  BorderStyleEnum["Apples"] = "apples";
  BorderStyleEnum["ArchedScallops"] = "archedScallops";
  BorderStyleEnum["BabyPacifier"] = "babyPacifier";
  BorderStyleEnum["BabyRattle"] = "babyRattle";
  BorderStyleEnum["Balloons3Colors"] = "balloons3Colors";
  BorderStyleEnum["BalloonsHotAir"] = "balloonsHotAir";
  BorderStyleEnum["BasicBlackDashes"] = "basicBlackDashes";
  BorderStyleEnum["BasicBlackDots"] = "basicBlackDots";
  BorderStyleEnum["BasicBlackSquares"] = "basicBlackSquares";
  BorderStyleEnum["BasicThinLines"] = "basicThinLines";
  BorderStyleEnum["BasicWhiteDashes"] = "basicWhiteDashes";
  BorderStyleEnum["BasicWhiteDots"] = "basicWhiteDots";
  BorderStyleEnum["BasicWhiteSquares"] = "basicWhiteSquares";
  BorderStyleEnum["BasicWideInline"] = "basicWideInline";
  BorderStyleEnum["BasicWideMidline"] = "basicWideMidline";
  BorderStyleEnum["BasicWideOutline"] = "basicWideOutline";
  BorderStyleEnum["Bats"] = "bats";
  BorderStyleEnum["Birds"] = "birds";
  BorderStyleEnum["BirdsFlight"] = "birdsFlight";
  BorderStyleEnum["Cabins"] = "cabins";
  BorderStyleEnum["CakeSlice"] = "cakeSlice";
  BorderStyleEnum["CandyCorn"] = "candyCorn";
  BorderStyleEnum["CelticKnotwork"] = "celticKnotwork";
  BorderStyleEnum["CertificateBanner"] = "certificateBanner";
  BorderStyleEnum["ChainLink"] = "chainLink";
  BorderStyleEnum["ChampagneBottle"] = "champagneBottle";
  BorderStyleEnum["CheckedBarBlack"] = "checkedBarBlack";
  BorderStyleEnum["CheckedBarColor"] = "checkedBarColor";
  BorderStyleEnum["Checkered"] = "checkered";
  BorderStyleEnum["ChristmasTree"] = "christmasTree";
  BorderStyleEnum["CirclesLines"] = "circlesLines";
  BorderStyleEnum["CirclesRectangles"] = "circlesRectangles";
  BorderStyleEnum["ClassicalWave"] = "classicalWave";
  BorderStyleEnum["Clocks"] = "clocks";
  BorderStyleEnum["Compass"] = "compass";
  BorderStyleEnum["Confetti"] = "confetti";
  BorderStyleEnum["ConfettiGrays"] = "confettiGrays";
  BorderStyleEnum["ConfettiOutline"] = "confettiOutline";
  BorderStyleEnum["ConfettiStreamers"] = "confettiStreamers";
  BorderStyleEnum["ConfettiWhite"] = "confettiWhite";
  BorderStyleEnum["CornerTriangles"] = "cornerTriangles";
  BorderStyleEnum["CouponCutoutDashes"] = "couponCutoutDashes";
  BorderStyleEnum["CouponCutoutDots"] = "couponCutoutDots";
  BorderStyleEnum["CrazyMaze"] = "crazyMaze";
  BorderStyleEnum["CreaturesButterfly"] = "creaturesButterfly";
  BorderStyleEnum["CreaturesFish"] = "creaturesFish";
  BorderStyleEnum["CreaturesInsects"] = "creaturesInsects";
  BorderStyleEnum["CreaturesLadyBug"] = "creaturesLadyBug";
  BorderStyleEnum["CrossStitch"] = "crossStitch";
  BorderStyleEnum["Cup"] = "cup";
  BorderStyleEnum["DecoArch"] = "decoArch";
  BorderStyleEnum["DecoArchColor"] = "decoArchColor";
  BorderStyleEnum["DecoBlocks"] = "decoBlocks";
  BorderStyleEnum["DiamondsGray"] = "diamondsGray";
  BorderStyleEnum["DoubleD"] = "doubleD";
  BorderStyleEnum["DoubleDiamonds"] = "doubleDiamonds";
  BorderStyleEnum["Earth1"] = "earth1";
  BorderStyleEnum["Earth2"] = "earth2";
  BorderStyleEnum["EclipsingSquares1"] = "eclipsingSquares1";
  BorderStyleEnum["EclipsingSquares2"] = "eclipsingSquares2";
  BorderStyleEnum["EggsBlack"] = "eggsBlack";
  BorderStyleEnum["Fans"] = "fans";
  BorderStyleEnum["Film"] = "film";
  BorderStyleEnum["Firecrackers"] = "firecrackers";
  BorderStyleEnum["FlowersBlockPrint"] = "flowersBlockPrint";
  BorderStyleEnum["FlowersDaisies"] = "flowersDaisies";
  BorderStyleEnum["FlowersModern1"] = "flowersModern1";
  BorderStyleEnum["FlowersModern2"] = "flowersModern2";
  BorderStyleEnum["FlowersPansy"] = "flowersPansy";
  BorderStyleEnum["FlowersRedRose"] = "flowersRedRose";
  BorderStyleEnum["FlowersRoses"] = "flowersRoses";
  BorderStyleEnum["FlowersTeacup"] = "flowersTeacup";
  BorderStyleEnum["FlowersTiny"] = "flowersTiny";
  BorderStyleEnum["Gems"] = "gems";
  BorderStyleEnum["GingerbreadMan"] = "gingerbreadMan";
  BorderStyleEnum["Gradient"] = "gradient";
  BorderStyleEnum["Handmade1"] = "handmade1";
  BorderStyleEnum["Handmade2"] = "handmade2";
  BorderStyleEnum["HeartBalloon"] = "heartBalloon";
  BorderStyleEnum["HeartGray"] = "heartGray";
  BorderStyleEnum["Hearts"] = "hearts";
  BorderStyleEnum["HeebieJeebies"] = "heebieJeebies";
  BorderStyleEnum["Holly"] = "holly";
  BorderStyleEnum["HouseFunky"] = "houseFunky";
  BorderStyleEnum["Hypnotic"] = "hypnotic";
  BorderStyleEnum["IceCreamCones"] = "iceCreamCones";
  BorderStyleEnum["LightBulb"] = "lightBulb";
  BorderStyleEnum["Lightning1"] = "lightning1";
  BorderStyleEnum["Lightning2"] = "lightning2";
  BorderStyleEnum["MapPins"] = "mapPins";
  BorderStyleEnum["MapleLeaf"] = "mapleLeaf";
  BorderStyleEnum["MapleMuffins"] = "mapleMuffins";
  BorderStyleEnum["Marquee"] = "marquee";
  BorderStyleEnum["MarqueeToothed"] = "marqueeToothed";
  BorderStyleEnum["Moons"] = "moons";
  BorderStyleEnum["Mosaic"] = "mosaic";
  BorderStyleEnum["MusicNotes"] = "musicNotes";
  BorderStyleEnum["Northwest"] = "northwest";
  BorderStyleEnum["Ovals"] = "ovals";
  BorderStyleEnum["Packages"] = "packages";
  BorderStyleEnum["PalmsBlack"] = "palmsBlack";
  BorderStyleEnum["PalmsColor"] = "palmsColor";
  BorderStyleEnum["PaperClips"] = "paperClips";
  BorderStyleEnum["Papyrus"] = "papyrus";
  BorderStyleEnum["PartyFavor"] = "partyFavor";
  BorderStyleEnum["PartyGlass"] = "partyGlass";
  BorderStyleEnum["Pencils"] = "pencils";
  BorderStyleEnum["People"] = "people";
  BorderStyleEnum["PeopleWaving"] = "peopleWaving";
  BorderStyleEnum["PeopleHats"] = "peopleHats";
  BorderStyleEnum["Poinsettias"] = "poinsettias";
  BorderStyleEnum["PostageStamp"] = "postageStamp";
  BorderStyleEnum["Pumpkin1"] = "pumpkin1";
  BorderStyleEnum["PushPinNote2"] = "pushPinNote2";
  BorderStyleEnum["PushPinNote1"] = "pushPinNote1";
  BorderStyleEnum["Pyramids"] = "pyramids";
  BorderStyleEnum["PyramidsAbove"] = "pyramidsAbove";
  BorderStyleEnum["Quadrants"] = "quadrants";
  BorderStyleEnum["Rings"] = "rings";
  BorderStyleEnum["Safari"] = "safari";
  BorderStyleEnum["Sawtooth"] = "sawtooth";
  BorderStyleEnum["SawtoothGray"] = "sawtoothGray";
  BorderStyleEnum["ScaredCat"] = "scaredCat";
  BorderStyleEnum["Seattle"] = "seattle";
  BorderStyleEnum["ShadowedSquares"] = "shadowedSquares";
  BorderStyleEnum["SharksTeeth"] = "sharksTeeth";
  BorderStyleEnum["ShorebirdTracks"] = "shorebirdTracks";
  BorderStyleEnum["Skyrocket"] = "skyrocket";
  BorderStyleEnum["SnowflakeFancy"] = "snowflakeFancy";
  BorderStyleEnum["Snowflakes"] = "snowflakes";
  BorderStyleEnum["Sombrero"] = "sombrero";
  BorderStyleEnum["Southwest"] = "southwest";
  BorderStyleEnum["Stars"] = "stars";
  BorderStyleEnum["StarsTop"] = "starsTop";
  BorderStyleEnum["Stars3d"] = "stars3d";
  BorderStyleEnum["StarsBlack"] = "starsBlack";
  BorderStyleEnum["StarsShadowed"] = "starsShadowed";
  BorderStyleEnum["Sun"] = "sun";
  BorderStyleEnum["Swirligig"] = "swirligig";
  BorderStyleEnum["TornPaper"] = "tornPaper";
  BorderStyleEnum["TornPaperBlack"] = "tornPaperBlack";
  BorderStyleEnum["Trees"] = "trees";
  BorderStyleEnum["TriangleParty"] = "triangleParty";
  BorderStyleEnum["Triangles"] = "triangles";
  BorderStyleEnum["Tribal1"] = "tribal1";
  BorderStyleEnum["Tribal2"] = "tribal2";
  BorderStyleEnum["Tribal3"] = "tribal3";
  BorderStyleEnum["Tribal4"] = "tribal4";
  BorderStyleEnum["Tribal5"] = "tribal5";
  BorderStyleEnum["Tribal6"] = "tribal6";
  BorderStyleEnum["TwistedLines1"] = "twistedLines1";
  BorderStyleEnum["TwistedLines2"] = "twistedLines2";
  BorderStyleEnum["Vine"] = "vine";
  BorderStyleEnum["Waveline"] = "waveline";
  BorderStyleEnum["WeavingAngles"] = "weavingAngles";
  BorderStyleEnum["WeavingBraid"] = "weavingBraid";
  BorderStyleEnum["WeavingRibbon"] = "weavingRibbon";
  BorderStyleEnum["WeavingStrips"] = "weavingStrips";
  BorderStyleEnum["WhiteFlowers"] = "whiteFlowers";
  BorderStyleEnum["Woodwork"] = "woodwork";
  BorderStyleEnum["XIllusions"] = "xIllusions";
  BorderStyleEnum["ZanyTriangles"] = "zanyTriangles";
  BorderStyleEnum["ZigZag"] = "zigZag";
  BorderStyleEnum["ZigZagStitch"] = "zigZagStitch";
})(BorderStyleEnum || (BorderStyleEnum = {}));

let PageBorderDisplay;

(function (PageBorderDisplay) {
  PageBorderDisplay["ALL_PAGES"] = "allPages";
  PageBorderDisplay["FIRST_PAGE"] = "firstPage";
  PageBorderDisplay["NOT_FIRST_PAGE"] = "notFirstPage";
})(PageBorderDisplay || (PageBorderDisplay = {}));

let PageBorderOffsetFrom;

(function (PageBorderOffsetFrom) {
  PageBorderOffsetFrom["PAGE"] = "page";
  PageBorderOffsetFrom["TEXT"] = "text";
})(PageBorderOffsetFrom || (PageBorderOffsetFrom = {}));

let PageBorderZOrder;

(function (PageBorderZOrder) {
  PageBorderZOrder["BACK"] = "back";
  PageBorderZOrder["FRONT"] = "front";
})(PageBorderZOrder || (PageBorderZOrder = {}));

var index$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get BorderStyleEnum () { return BorderStyleEnum; },
  get PageBorderDisplay () { return PageBorderDisplay; },
  get PageBorderOffsetFrom () { return PageBorderOffsetFrom; },
  get PageBorderZOrder () { return PageBorderZOrder; }
});

var border = /*#__PURE__*/Object.freeze({
  __proto__: null
});

var tableBorder = /*#__PURE__*/Object.freeze({
  __proto__: null
});

var WrapPr = /*#__PURE__*/Object.freeze({
  __proto__: null
});

var FramePr = /*#__PURE__*/Object.freeze({
  __proto__: null
});

var TblpPr = /*#__PURE__*/Object.freeze({
  __proto__: null
});

var TblW = /*#__PURE__*/Object.freeze({
  __proto__: null
});

var CalloutPr = /*#__PURE__*/Object.freeze({
  __proto__: null
});

var index$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Border: border,
  TableBorder: tableBorder,
  WrapPr: WrapPr,
  FramePr: FramePr,
  TblpPr: TblpPr,
  TblW: TblW,
  CalloutPr: CalloutPr
});

/**
 * 获得 Controller 实例，使用 `useControllerStatic` hook 的组件，不会随着编辑器内容的变化而发生重渲
 * @returns 
 */

function useControllerStatic() {
  const context = React.useContext(ControllerContext);

  if (!context) {
    throw new Error("The `useControllerStatic` hook must be used inside the <Cangjie.Provider> component's context.");
  }

  return context.controller;
}

/* eslint-disable max-lines */
const FieldsNotAffectSpace = ['composing', 'isFocused', 'decorations', 'selection', 'remoteSelections'];
const OperationsNotAffectSpace = [exports.OperationType.InsertText, exports.OperationType.RemoveText, exports.OperationType.SetMark, exports.OperationType.AddMark, exports.OperationType.RemoveMark, exports.OperationType.SetSelection];

function isSetValueNotAffectSpace(key) {
  return FieldsNotAffectSpace.includes(key);
}

function isOperationNotAffectSpace(operation) {
  return OperationsNotAffectSpace.includes(operation.type);
}

function getDirtyKeysFromOperation(value, operation) {
  const {
    type,
    // @ts-ignore
    path,
    // @ts-ignore
    node
  } = operation;
  const {
    document
  } = value;
  const opNode = node || document.getNodeByPath(path);
  const opNodeKey = opNode?.key;

  switch (type) {
    // PERF: Cangjie does not support normalizing `text.text` `leaf.marks`, just ignore changes for performance(~10ms in Huge Document story)
    // PERF: 🚫🚫🚫 No [...xxx]. Spread syntax will affect performance when huge node changed.
    // Ref: packages/cangjie/src/plugins/schema.ts
    // case 'add_mark':
    // case 'insert_text':
    // case 'remove_mark':
    // case 'remove_text':
    // case 'set_mark':
    case exports.OperationType.SetNode:
      {
        const ancestors = document.getAncestorsByPath(path).map(n => n?.key);
        ancestors.push(opNodeKey);
        return ancestors;
      }

    case exports.OperationType.InsertNode:
      {
        const table = Text$1.isText(node) ? {} : node.getKeysToEdgesTable();
        const ancestors = document.getAncestorsByPath(path).map(n => n?.key);
        ancestors.push(node.key);
        Array.prototype.push.apply(ancestors, Object.keys(table));
        return ancestors;
      }

    case exports.OperationType.SplitNode:
      {
        const ancestors = document.getAncestorsByPath(path).map(n => n?.key); // @ts-ignore

        const nextKey = document.getNextNodeByPath(path).key;
        ancestors.push(opNodeKey, nextKey);
        return ancestors;
      }

    case exports.OperationType.MergeNode:
      {
        const ancestors = Path.ancestors(path);
        const previousPath = Path.decrement(path);
        ancestors.push(previousPath);
        return ancestors.map(p => document.getNodeByPath(p)).map(n => n?.key);
      }

    case exports.OperationType.MoveNode:
      {
        // Path is more accurate than key when node moved.
        const {
          newPath
        } = operation;

        if (Path.isEqual(path, newPath)) {
          return [];
        }

        let parentPath = Path.parent(path);
        let newParentPath = Path.parent(newPath); // HACK: this clause only exists because the `move_path` logic isn't
        // consistent when it deals with siblings.

        if (!Path.isSibling(path, newPath)) {
          if (newParentPath.length && Path.isYounger(path, newPath)) {
            newParentPath = Path.decrement(newParentPath, 1, path.length - 1);
          }

          if (parentPath.length && (Path.isYounger(newPath, path) || Path.isAncestor(newPath, path))) {
            parentPath = Path.increment(parentPath, 1, newPath.length - 1);
          }
        }

        const oldAncestors = Path.ancestors(parentPath);
        const newAncestors = Path.ancestors(newParentPath);
        oldAncestors.push(parentPath);
        Array.prototype.push.apply(oldAncestors, newAncestors);
        oldAncestors.push(newParentPath);
        return oldAncestors.map(p => document.getNodeByPath(p)).map(n => n?.key);
      }

    case exports.OperationType.RemoveNode:
      {
        // The node has been deleted, ancestors connot be getted by "document.getAncestors"
        const ancestors = Path.ancestors(path);
        return ancestors.map(p => document.getNodeByPath(p)).map(n => n?.key);
      }

    default:
      {
        return [];
      }
  }
}
/**
 * diff比较（严格：顺序改变算diff）
 * @param element
 * @param prevElement
 * @param curIndexKey
 * @param preIndexKey
 * @deprecated
 */

function getDirtyKeysFromElementDiffStrictly(element, prevElement, curIndexKey, preIndexKey) {
  const dirtyKeys = [];

  if (element === prevElement && curIndexKey === preIndexKey) {
    return dirtyKeys;
  }

  dirtyKeys.push(element.key);

  if (!Element$1.isElement(element)) {
    return dirtyKeys;
  }

  if (!Element$1.isElement(prevElement)) {
    return Object.keys(element.getKeysToEdgesTable()).concat(element.key);
  }

  for (let i = 0; i < element.nodes.length; i += 1) {
    const child = element.nodes[i];
    const prevChild = prevElement.getNode(child.key);
    const preChildIndexKey = prevElement?.nodes[i]?.key;

    if (child !== prevChild || child.key !== preChildIndexKey) {
      dirtyKeys.push(...getDirtyKeysFromElementDiffStrictly(child, prevChild, child.key, preChildIndexKey));
    }
  }

  return dirtyKeys;
}

function getDirtyKeysFromElementDiff(element, prevElement) {
  const dirtyKeys = [];

  if (element === prevElement) {
    return dirtyKeys;
  }

  dirtyKeys.push(element.key);

  if (!Element$1.isElement(element)) {
    return dirtyKeys;
  }

  if (!Element$1.isElement(prevElement)) {
    return Object.keys(element.getKeysToEdgesTable()).concat(element.key);
  }

  for (let i = 0; i < element.nodes.length; i += 1) {
    const child = element.nodes[i];
    const prevChild = prevElement.getNode(child.key);

    if (child !== prevChild) {
      getDirtyKeysFromElementDiff(child, prevChild).forEach(key => dirtyKeys.push(key));
    }
  }

  return dirtyKeys;
}

const composingMark = Mark.create('cangjieComposing');
const defaultScrollType = 'toSelection';
function insertComposingIntoLeaves(leaves, offset, composing, selection, decorations) {
  const [before, after] = Leaf.splitLeaves(leaves, offset);
  const beforeLastLeaf = before[before.length - 1];
  const beforeLastMarks = beforeLastLeaf ? beforeLastLeaf.marks : [];
  let marks = null;

  if (selection.marks) {
    const decorationsMarks = decorations.map(({
      mark
    }) => mark);
    const activeDecorationsMarks = beforeLastMarks.filter(mark => decorationsMarks.some(m => equal__default["default"](m, mark)));
    marks = [...activeDecorationsMarks, ...selection.marks];
  } else {
    marks = beforeLastMarks;
  }

  const middle = Leaf.create({
    text: composing,
    marks: [...marks, composingMark]
  });
  const shouldConcatBefore = before.length > 1 || before[0]?.text;
  const shouldConcatAfter = after.length > 1 || after[0]?.text;
  return [...(shouldConcatBefore ? before : []), middle, ...(shouldConcatAfter ? after : [])];
}
const DEFAULT_VIRTUALIZE_OPTIONS = {
  enable: false,
  enableOnDemandViewCalculation: true,
  pendingDebounceTime: 500,
  invisibleCalculationDebounceTime: 500,
  maxOPsForHotsAnalyze: 10,
  bufferRange: DEFAULT_BUFFER_RANGE,
  firstPaintBlockSize: DEFAULT_FIRST_PAINT_BLOCK_SIZE,
  disableViewVirtualize: false
};
class Controller {
  /**
   * 内部使用了[[Controller.useController]]，把Wrapper封装为一个高阶组件，并传入controller
   */

  /**
   * 构建一个新的Controller对象
   * @param props 构建参数
   * @param options 构建选项
   */
  static create(props, options) {
    return new Controller(props, options);
  }

  /**
   * 文档的数据[[Value]]对象，参照[[ControllerProperties]]
   */
  get value() {
    return this.$value;
  }

  /**
   * 获取当前的历史operations
   */
  get operations() {
    return this.$operations;
  }

  registerPlugin(plugin) {
    if (Array.isArray(plugin)) {
      plugin.forEach(p => this.registerPlugin(p));
      return;
    }

    const {
      commands: cmds,
      actions,
      isActions,
      queries,
      renderNode,
      schema: pluginSchema,
      ...rest
    } = plugin;

    if (cmds) {
      // NOTE: `commands` which has registered will have higher priority.
      this.commands = Object.assign({}, cmds, this.commands);
    }

    if (actions) {
      this.actions = Object.assign({}, actions, this.actions);
    }

    if (isActions) {
      this.isActions = Object.assign({}, isActions, this.isActions);
    }

    if (queries) {
      // NOTE: `queries` which has registered will have higher priority.
      Object.keys(queries).forEach(query => {
        const prevQuery = this.queries[query];
        const nextQuery = queries[query];

        if (!prevQuery) {
          this.queries[query] = nextQuery;
          return;
        }

        this.queries[query] = (...args) => {
          const ret = prevQuery(...args);
          return ret === undefined ? nextQuery(...args) : ret;
        };
      });
    }

    if (renderNode) {
      if (typeof renderNode === 'function') {
        if (!this.handlers.renderNode) {
          this.handlers.renderNode = [];
        }

        this.handlers.renderNode.push(renderNode);
      } else {
        Object.keys(renderNode).forEach(nodeType => {
          if (!this.renderNodes[nodeType]) {
            this.renderNodes[nodeType] = [renderNode[nodeType]];
          } else {
            this.renderNodes[nodeType].push(renderNode[nodeType]);
          }
        });
      }
    }

    if (pluginSchema) {
      this.registerPlugin(createNormalizationPlugin(pluginSchema));
    }

    Object.keys(rest).forEach(key => {
      if (!this.handlers[key]) {
        this.handlers[key] = [];
      }

      this.handlers[key].push(plugin[key]);
    });
  }

  constructor(props, options) {
    this.flag = {
      normalizing: true,
      pending: true,
      saving: true,

      /**
       * @experimental
       */
      tracking: true,
      withCommand: false,
      destroyed: false,
      perf: {
        input: [],
        composing: [],
        selection: []
      },
      scrollType: defaultScrollType,
      opRelatedId: null
    };
    this.VIEW_CACHE = {
      /** 内存模型缓存 */
      VALUE: new WeakSet(),

      /** 节点视图模型缓存，若节点的视图数据不变，则复用缓存，避免计算 */
      ELEMENT: new WeakMap(),

      /** 已装饰的节点，key 为节点数据模型，value 为视图数据 */
      DECORATED_ELEMENT: new WeakMap(),

      /** 已注入数据的节点缓存，key 为分组节点，value 为 [注入数据的节点，节点被注入的 injections] */
      INJECTED_ELEMENT: new WeakMap(),

      /** 分组节点缓存，key 装饰后的及节点视图，value 为分组节点 */
      GROUPED_ELEMENT: new WeakMap(),

      /** 文本节点缓存 */
      TEXT: new WeakMap(),

      /** 叶子节点缓存 */
      LEAVES: new WeakMap(),

      /** 数据节点调用 `decorateNode` 结果缓存 */
      DECORATE_NODE: new WeakMap(),

      /** 数据节点调用 `injectToNode` 结果缓存 */
      INJECT_TO_NODE: new WeakMap(),

      /** 节点视图模型缓存 */
      DATA: new WeakMap(),

      /** 视图节点最终被注入的 injections, decorations 缓存  */
      INJECT_TO_VIEW_ELEMENT: new WeakMap(),

      /** 视图文本节点最终被注入的 decorations 缓存 */
      INJECT_TO_VIEW_TEXT: new WeakMap(),

      /** 节点选中态计算缓存 */
      IS_SELECTED: new Set(),

      /** 为计算过视图模型的节点 */
      VIEW_NEVER_CALCULATED: new Set()
    };
    this.dirtyKeys = new Set();
    this.context = [];
    this.biz = void 0;
    this.uid = void 0;
    this.userData = new UserDataManager(this);
    this.inputData$ = new Subject();
    this.selectionData$ = new Subject();
    this.hots$ = new Subject();
    this.terminal$ = new Subject();
    this.virtualizeManager = null;
    this.serializer = void 0;
    this.baseSerializer = void 0;
    this.schema = void 0;
    this.strictSchema = void 0;
    this.$value = null;
    this.$viewDoc = null;
    this.$scrollableContainer = null;
    this.$operations = [];
    this.$operationWithValues = [];
    this.onChange = void 0;
    this.commands = {};
    this.queries = {};
    this.actions = {};
    this.isActions = {};
    this.handlers = {};
    this.renderNodes = {};
    this.flushType = void 0;
    this.flushTask = null;
    this.canCopy = void 0;
    this.readOnly = void 0;
    this.autoFocus = void 0;
    this.hideSelectionOnBlur = void 0;
    this.showCaret = void 0;
    this.testType = void 0;
    this.onBusyStateChange = void 0;
    this.pendingQueue = void 0;
    this.virtualizeOptions = void 0;
    this.debouncedFlush = void 0;
    this.debouncedStartInvisibleCalculationScheduler = void 0;
    this.groupManager = new GroupManager(this);
    this.onPending = void 0;
    this.uuidConfig = void 0;
    this.hots = {
      hots: [],
      keys: {},
      pendingType: null,
      lengthOfPending: 0,
      forceRecalculate: false
    };
    this.virtualize = {
      visibles: [],
      invisibleCalculationId: null
    };
    this.visibles$ = new Subject();

    this.setComposing = composing => {
      return this.setValueField('composing', composing);
    };

    this.setIsFocused = isFocused => {
      return this.setValueField('isFocused', isFocused);
    };

    this.startInvisibleCalculationScheduler = visibles => {
      /** 若浏览器不支持 requestIdleCallback，则不开启闲时计算 */
      if (typeof window.requestIdleCallback !== 'function') {
        return;
      }

      if (this.virtualize.invisibleCalculationId) {
        window.cancelIdleCallback(this.virtualize.invisibleCalculationId);
      }

      const invisibles = getInsivibleNodes(this.value.document, visibles);
      this.scheduleInvisibleCalculation(invisibles);
    };

    this.scheduleInvisibleCalculation = invisibles => {
      this.virtualize.invisibleCalculationId = window.requestIdleCallback(deadline => this.runInvisibleViewCalculation(deadline, invisibles));
    };

    this.runInvisibleViewCalculation = (deadline, invisibles) => {
      while ((deadline.timeRemaining() > 0 || deadline.didTimeout) && invisibles.length) {
        // 每次取出一个不可见节点计算
        this.calculateInvisibleView(invisibles.pop());
      }

      if (invisibles.length) {
        // 继续下一个计算
        this.scheduleInvisibleCalculation(invisibles);
      } else {
        this.virtualize.invisibleCalculationId = null;
      }
    };

    this.calculateInvisibleView = invisible => {
      const {
        injections,
        decorations,
        document
      } = this.value;
      const docInjections = this.VIEW_CACHE.INJECT_TO_NODE.get(document) || [];
      const docDecorations = this.VIEW_CACHE.DECORATE_NODE.get(document) || [];
      const viewElement = this.toViewElement(invisible, decorations.concat(docDecorations), injections.concat(docInjections));

      if (!this.VIEW_CACHE.ELEMENT.get(document)) {
        const {
          decorations,
          injections
        } = this.value;
        this.toView(document, decorations, injections);
      }

      const [viewDocument, prevDecorations, prevInjections, prevComposing] = this.VIEW_CACHE.ELEMENT.get(document);
      const newViewDocument = viewDocument.replaceNode(this.view.assertPath(viewElement.key), viewElement,
      /** 重新 toView，会带来新的视图子树，因此需要重构 key-to-path table */
      false);
      this.VIEW_CACHE.ELEMENT.set(document, [newViewDocument, prevDecorations, prevInjections, prevComposing]);
      this.VIEW_CACHE.VALUE.delete(this.value);
      this.$viewDoc = newViewDocument;
      return viewElement;
    };

    this.calculateViewInVisibleNode = (node, parentVisible = false) => {
      const {
        document
      } = this.value; // 如果是视图模型节点，递归计算其子树下未被计算过的视图模型

      if (!document.hasNode(node.key) && this.isNodeVisible(node)) {
        return node.mapDescendants(descendant => {
          return descendant.isElement() ? this.calculateViewInVisibleNode(descendant, true) : descendant;
        });
      } // 如果可见节点下，存在未被计算的视图模型，则计算之保证可见节点的视图正确
      else if (document.hasNode(node.key) && parentVisible && this.VIEW_CACHE.VIEW_NEVER_CALCULATED.has(node.key)) {
          return this.calculateInvisibleView(node);
        }

      return node;
    };

    const {
      biz = 'cangjie',
      dataUid,
      plugins = [],
      value,
      onChange = () => {},
      readOnly,
      canCopy = true,
      autoFocus,
      flushType = 'microtask',
      configs,
      onBusyStateChange,
      onPending
    } = props;
    this.biz = biz;
    this.setUid(dataUid);

    this.onChange = change => {
      onChange(change);
    };

    this.readOnly = !!readOnly;
    this.autoFocus = !!autoFocus;
    this.showCaret = options?.showCaret;
    this.canCopy = canCopy;
    this.flushType = flushType;
    this.onBusyStateChange = onBusyStateChange;
    this.onPending = onPending || lodash.noop;
    let {
      enablePending = false,
      virtualize = DEFAULT_VIRTUALIZE_OPTIONS
    } = options || {}; // 虚拟化和 OP Pending 互斥

    if (virtualize.enable) {
      enablePending = false;
    }

    if (enablePending) {
      virtualize.enable = false;
    }

    const {
      __pendingQueue__ = {},
      hideSelectionOnBlur = false,
      uuid = {
        enable: false
      }
    } = options || {};
    this.hideSelectionOnBlur = hideSelectionOnBlur;
    this.pendingQueue = PendingQueue.create({
      debounceTime: 500,
      ...__pendingQueue__,
      controller: this,
      enablePending
    });
    this.virtualizeOptions = virtualize;
    this.virtualizeOptions = { ...DEFAULT_VIRTUALIZE_OPTIONS,
      ...virtualize
    };
    this.debouncedFlush = lodash.debounce(this.flush, this.virtualizeOptions.pendingDebounceTime);
    this.debouncedStartInvisibleCalculationScheduler = lodash.debounce(this.startInvisibleCalculationScheduler, this.virtualizeOptions.invisibleCalculationDebounceTime);

    if (IS_MOBILE || IS_TOUCH_DEVICE) {
      this.registerPlugin(createMobilePlugin(configs));
    }

    if (uuid.enable && !uuid.gen) {
      throw new Error('[Cangjie-UUID]: Missing uuid generator');
    }

    this.uuidConfig = {
      enable: uuid.enable
    }; // Step 1: collect `commands` & `queries` from `plugins`.

    this.registerPlugin([createCoreSchemaPlugin(), createGroupPlugin(), ...plugins, uuid.enable && !!uuid.gen ? createUUIDPlugin(uuid) : {}, createHistoryPlugin(configs), createCorePlugin(), createContextMenuPlugin(configs)]); // Step 2: wrap `commands` & `queries` into `onCommand` & `onQuery` respectively.

    this.registerPlugin([createCommandsPlugin({ ...Commands,
      ...this.commands
    }), createQueriesPlugin({
      isAtomic: () => false,
      isEmpty: (_, block) => lodash.isEmpty(block),
      isVoid: () => false,
      ...this.queries
    }), createRenderNodePlugin(this.renderNodes)]);
    /**
     * schema and serializer: used by other plugins(like clipboard) to deal with model normalize and serialization
     */
    // step 3: create serializer

    this.serializer = createSerializer(plugins); // 迁移期间，原 Plugin 定义不能加 key，待迁移完成再去掉 as any

    this.baseSerializer = createBaseSerializer(plugins); // step 4: create schema

    this.schema = createSchema(plugins);
    this.strictSchema = createStrictSchema(plugins);
    this.setValue(value, options);

    if (virtualize.enable && !virtualize.disableViewVirtualize) {
      this.virtualizeManager = new VirtualizeManager(this, virtualize);
    }

    this.run('onConstruct');
  }

  setReadOnly(readOnly) {
    // @ts-ignore Internal set only
    this.readOnly = readOnly;
  }
  /**
   * 设置一个新的value对象
   * @param value 新的value对象
   * @param options 设置选项
   */


  setValue(value, options) {
    const {
      clearOperations = true,
      clearHots = true,
      normalize = value !== this.value
    } = options || {}; // this.value 初始值为 null

    const prevDocument = this.value?.document;
    const prevSelection = this.value?.selection;
    this.$value = value;

    if (clearOperations) {
      this.$operations = [];
    }

    if (clearHots) {
      this.clearHots();
    } // Next Value


    const {
      document,
      selection
    } = this.value; // document 变更

    if (normalize && !equal__default["default"](document, prevDocument)) {
      const dirtyKeys = prevDocument ? getDirtyKeysFromElementDiff(document, prevDocument) : Object.keys(document.getKeysToEdgesTable()).concat(document.key);
      dirtyKeys.forEach(key => {
        this.dirtyKeys.add(key);
      });
      this.withoutTracking(() => this.normalizeDirtyKeys());
    } // selection 变更


    if (normalize && !equal__default["default"](selection, prevSelection)) {
      this.normalizeSelection();
    }

    return this;
  }

  setValueField(key, value) {
    const beforeSetValue = this.value; // @ts-ignore

    this.setValue(this.value.set(key, value), {
      normalize: false,
      clearOperations: false,
      clearHots: false
    });
    this.$operationWithValues.push({
      operation: null,
      key,
      value: beforeSetValue,
      newValue: this.value
    });
    this.scheduleFlush();
    return this;
  }
  /**
   * 重置编辑器的 value，服务于受控组件的 `props.value` 变化时
   * `controller.resetValue(value)` 内部将驱动各个插件在重置 value 时所要完成的任务或者副作用
   * @param value
   * @param options
   */


  resetValue(value, options) {
    const controllerValue = this.value;
    this.setValue(value, options);
    this.run('onResetValue', value, controllerValue);
  }
  /**
   * 1. 设置Value的data字段
   * 2. 并更新Value
   * 3. 调用flush刷新
   */


  setData(data) {
    return this.setValueField('data', data);
  }
  /**
   * 1. 设置Value的injection字段
   * 2. 并更新Value
   * 3. 调用flush刷新
   */


  setInjections(injections) {
    return this.setValueField('injections', injections);
  }
  /**
   * 1. 设置Value的decoration字段
   * 2. 并更新Value
   * 3. 调用flush刷新
   */


  setDecorations(decorations) {
    return this.setValueField('decorations', decorations);
  }

  /**
   * 依次调用所有plugin的key字段，并传入下方的args字段，以及controller和next
   * @param key 对应plugin的key字段
   * @param args 传入plugin的参数
   */
  run(key, ...args) {
    const fns = this.handlers[key];

    if (!fns) {
      // @ts-ignore
      return null;
    }

    const controller = this;
    let i = 0;
    let prevArgs = args;

    function next(...as) {
      // PERF
      const currentArgs = as.length === 0 ? prevArgs : [...as, ...prevArgs.slice(as.length)]; // @ts-ignore

      prevArgs = currentArgs;
      const fn = fns[i];

      if (!fn) {
        return null;
      }

      i += 1; // PERF

      switch (currentArgs.length) {
        case 0:
          return fn(controller, next);

        case 1:
          return fn(currentArgs[0], controller, next);

        case 2:
          return fn(currentArgs[0], currentArgs[1], controller, next);

        default:
          return fn(...currentArgs, controller, next);
      }
    }

    if (isEventHandler(key)) {
      const prevWithCommand = this.flag.withCommand;
      this.flag.withCommand = true;
      const ret = next();
      this.flag.withCommand = prevWithCommand;
      return ret;
    }

    return next();
  }
  /**
   * 执行刷新操作。这里会调用normalize，并执行onChange Plugin和onChange回调
   */


  flush() {
    if (this.flag.destroyed) {
      return this;
    }

    this.run('onChange');
    this.normalizeSelection();
    const {
      value,
      operations
    } = this;
    const change = {
      value,
      operations
    };
    this.$operations = [];
    this.pendingQueue.clear();
    this.hots.lengthOfPending = 0;
    this.perfClearAll();
    this.hots.pendingType = null;
    this.debouncedFlush.cancel(); // 先取消 task，再置空

    if (this.flushTask) {
      this.flushTask.cancel();
      this.flushTask = null;
    }

    this.$operationWithValues = [];
    this.onChange(change);
    this.onBusyStateChange?.(!!this.query('isEditorBusy'));
    this.groupManager.notifyNewGroups();
    return this;
  }
  /**
   * 调度执行 flush，在微任务中执行
   */


  scheduleFlush() {
    // 如果 task 不存在则创建
    if (!this.flushTask) {
      this.flushTask = FlushTask.create(() => {
        // 在下一次任务调度时，判断 operations 是否需要 pending 或 hots
        // 重置 flush task，使下一个周期内的 operations 能被 pending 判定
        if (this.flushTask) {
          this.flushTask.cancel();
          this.flushTask = null;
        } // 获得 flush task 周期内产生的热区


        if (this.enableHots) {
          const flushContext = {
            operations: this.$operationWithValues,
            value: this.$value
          };
          const suppressed = shouldSuppressFlush(flushContext);
          const debounced = !suppressed ? shouldDebounceFlush(flushContext) : null;

          if (suppressed) {
            // 是否抑制 Flush
            // PERF：更新时沿用计算好的热区
            this.setHots(this.hots.pendingType === suppressed && this.hots.hots.length ? this.hots.hots : getHots(this.$operationWithValues, this), suppressed);
            this.onPending(this.$value);
          } else if (debounced) {
            // 是否 Debounce Flush
            this.setHots(getHots(this.$operationWithValues.slice(this.hots.lengthOfPending), this), debounced);
            this.onPending(this.$value);
            this.debouncedFlush();
          } else {
            this.setHots([], null);
            this.flush();
          }
        } else if (this.isPendingEnable) {
          // 需要 pending
          this.pendingQueue.queue(this.$operationWithValues.slice(this.pendingQueue.size()));
        } else {
          // 不需要 pending，立即 flush 堆积的 operations
          this.flush();
        }

        this.onBusyStateChange?.(!!this.query('isEditorBusy'));
      }, {
        flushType: this.flushType
      }).start();
    }
  }

  transformDirtyKey(operation) {
    if (operation.type === 'split_node') {
      // @ts-ignore
      const {
        node,
        path
      } = operation;
      const operationNode = node || this.value.document.getNodeByPath(path);

      if (this.dirtyKeys.has(operationNode?.key)) {
        const extraDirty = this.value.document.getNodeByPath(Path.increment(path));

        if (extraDirty) {
          this.dirtyKeys.add(extraDirty.key);
        }
      }
    }
  }
  /**
   * Apply operation directly
   * @param operation
   * @returns
   */


  privateApplyOperation(op) {
    // PERF: 无 Context 时，不向 OP 注入 `context`
    const opWithContext = this.context.length ? { ...op,
      context: this.context.join(CONTEXT_SPLIT)
    } : op;
    const operation = this.run('mapOperation', opWithContext);
    const beforeApplyValue = this.value;
    this.$value = this.value.applyOperation(operation);
    const operationWithValue = {
      operation,
      value: beforeApplyValue,
      newValue: this.value
    };
    this.$operationWithValues.push(operationWithValue);
    this.groupManager.regenerateGroup(operationWithValue);
    this.operations.push(operation);
    const dirtyKeysFromOp = getDirtyKeysFromOperation(this.value, operation);
    dirtyKeysFromOp.forEach(key => {
      if (key) {
        this.dirtyKeys.add(key);
      }
    });
    this.transformDirtyKey(operation);
    this.scheduleFlush();
    this.userData.flush([operation]);
    return this;
  }
  /**
   * 执行单个Operation
   * @param operation 需要执行的operation
   */


  applyOperation(operation) {
    if (this.flag.tracking) {
      // 插件内部不允许嵌套执行
      this.withoutTracking(() => this.run('onApplyOperation', operation));
      return this;
    }

    return this.privateApplyOperation(operation);
  }

  normalizeNodeByKey(key) {
    let node = this.value.document.getNode(key);
    if (!node) return;
    let iterations = 0;
    let childrenLength = 1;

    if (!Text$1.isText(node)) {
      if (Element$1.isElement(node)) {
        childrenLength = node.nodes.length;
      } else {
        throw new Error('Unknown node, this is probably caused by multiple instances of Cangjie.');
      }
    }

    const max = 100 + childrenLength;

    while (node) {
      const fn = this.run('normalizeNode', node);

      if (!fn) {
        break;
      }

      this.withCommand(fn);
      const newValue = this.value;
      const newDocument = newValue.document;
      let found = newDocument.getNode(node.key);

      if (found && found.key === node.key) {
        node = found;
      } else {
        found = newDocument.getNode(node.key);

        if (found) {
          node = found;
        } else {
          break;
        }
      } // eslint-disable-next-line no-plusplus


      iterations++;

      if (iterations > max) {
        throw new Error('A schema rule could not be normalized after sufficient iterations. This is usually due to a `rule.normalize` or `plugin.normalizeNode` function of a schema being incorrectly written, causing an infinite loop.');
      }
    }
  }

  normalizeDirtyKeys() {
    if (!this.flag.normalizing || !this.dirtyKeys.size) {
      return;
    }

    this.withoutNormalizing(self => {
      while (self.dirtyKeys.size) {
        self.dirtyKeys.forEach(key => {
          self.dirtyKeys.delete(key);
          this.normalizeNodeByKey(key);
        });
      }
    });
  }

  normalizeSelection() {
    const {
      document,
      selection
    } = this.value;
    const {
      anchor,
      focus
    } = selection;
    const anchorNode = document.getNode(anchor.key);
    const focusNode = document.getNode(focus.key);

    if (!anchorNode || !focusNode) {
      this.command(moveToStartOfDocument);
    } else {
      if (anchor.isTextPoint() && anchor.offset > anchorNode.text.length) {
        this.command(moveAnchorToEndOfNode, anchorNode);
      }

      if (focus.isTextPoint() && focus.offset > focusNode.text.length) {
        this.command(moveFocusToEndOfNode, focusNode);
      }
    }
  }

  groupNodes(range, parent, groups = []) {
    const groupedNodes = [];
    let remainedRange = range;
    let isChildrenGrouped = false;

    while (remainedRange[0] < remainedRange[1]) {
      const [start] = remainedRange;
      const first = parent.nodes[start];
      const {
        node,
        remainedRange: remained
      } = this.run('groupNodes', remainedRange, {
        parent,
        groups
      });

      if (node !== first) {
        isChildrenGrouped = true;
        const maybeNestedGroup = node.merge({
          nodes: this.groupNodes([start, remained[0]], parent, [...groups, node])
        });
        groupedNodes.push(maybeNestedGroup);

        if (!maybeNestedGroup.nodes[0] && process.env.NODE_ENV === 'development') {
          throw new Error('Cangjie.Plugin[groupNodes] expect return non-empty group.');
        }
      } else {
        groupedNodes.push(node);
      }

      remainedRange = remained;
    }

    const lastGroup = groups[groups.length - 1] || parent;

    if (isChildrenGrouped) {
      // 如果分组可见，需保证分组下的不可见节点的视图模型被成功计算
      if (this.enableOnDemandViewCalculation) {
        return groupedNodes.map(node => this.calculateViewInVisibleNode(node));
      }

      return groupedNodes;
    }

    return isChildrenGrouped ? groupedNodes : lastGroup.nodes;
  }

  toViewText(text, decorations) {
    this.VIEW_CACHE.VIEW_NEVER_CALCULATED.delete(text.key);
    const {
      selection,
      composing
    } = this.value;
    const {
      anchor: point
    } = selection;
    const isCollapsedInText = selection.isCollapsed && point.isTextPoint() && point.key === text.key;

    if (!decorations.length && (!isCollapsedInText || !composing)) {
      return text;
    } // split leaves


    let {
      leaves
    } = text;

    if (decorations.length) {
      const [cachedViewLeaves, cachedDepDecorations] = this.VIEW_CACHE.LEAVES.get(leaves) || [];

      if (cachedViewLeaves && equal__default["default"](cachedDepDecorations, decorations)) {
        leaves = cachedViewLeaves;
      } else {
        const viewLeaves = text.getLeaves(decorations);
        this.VIEW_CACHE.LEAVES.set(leaves, [viewLeaves, decorations]);
        leaves = viewLeaves;
      }
    }

    if (isCollapsedInText && composing && point.isTextPoint()) {
      const hasComposingLeaf = leaves.some(leaf => leaf.marks.some(mark => mark.type === 'cangjieComposing'));

      if (!hasComposingLeaf) {
        leaves = insertComposingIntoLeaves(leaves, point.offset, composing, selection, decorations);
      }
    }

    const [cachedViewText, cachedDepLeaves] = this.VIEW_CACHE.TEXT.get(text) || [];

    if (cachedViewText && equal__default["default"](cachedDepLeaves, leaves)) {
      return cachedViewText;
    }

    const viewText = text.set('leaves', leaves);
    this.VIEW_CACHE.TEXT.set(text, [viewText, leaves]);
    this.VIEW_CACHE.DATA.set(viewText, {
      decorations,
      injections: []
    });
    this.VIEW_CACHE.INJECT_TO_VIEW_TEXT.set(viewText, {
      decorations
    });
    return viewText;
  }

  toViewElement(element, decorations, injections,
  /** 若当前节点可见，则其子孙节点也被认为可见 */
  isNodeVisible = false) {
    this.VIEW_CACHE.VIEW_NEVER_CALCULATED.delete(element.key);
    const {
      document,
      selection,
      composing
    } = this.value;
    const {
      anchor: point
    } = selection;
    const isCollapsedInElement = selection.isCollapsed && point.isTextPoint() && !!element.getKeysToEdgesTable()[point.key];
    const isCollapsedInEmptyElement = isCollapsedInElement && element.isEmpty();
    const computedComposing = isCollapsedInElement ? composing : '';
    const [viewElement, prevDecorations, prevInjections, prevComposing] = this.VIEW_CACHE.ELEMENT.get(element) || [];

    if (viewElement && equal__default["default"](decorations, prevDecorations) && equal__default["default"](injections, prevInjections) && computedComposing === prevComposing && !isCollapsedInEmptyElement) {
      return viewElement;
    }

    let nodeDecorations = this.VIEW_CACHE.DECORATE_NODE.get(element);

    if (isCollapsedInEmptyElement || !nodeDecorations) {
      nodeDecorations = this.run('decorateNode', element);
    }

    this.VIEW_CACHE.DECORATE_NODE.set(element, nodeDecorations);
    const allDecorations = nodeDecorations.length ? nodeDecorations.concat(decorations) : decorations;
    let nodeInjections = this.VIEW_CACHE.INJECT_TO_NODE.get(element);

    if (isCollapsedInEmptyElement || !nodeInjections) {
      nodeInjections = this.run('injectToNode', element);
    }

    this.VIEW_CACHE.INJECT_TO_NODE.set(element, nodeInjections);
    const allInjections = nodeInjections.length ? nodeInjections.concat(injections) : injections;
    const selfInjections = [];
    const descendantsInjections = [];
    allInjections.forEach(injection => {
      if (injection.key === element.key) {
        selfInjections.push(injection);
      } else {
        descendantsInjections.push(injection);
      }
    });
    let decoratedElement = element;
    const [cachedDecoratedElement, cachedDepsData] = this.VIEW_CACHE.DECORATED_ELEMENT.get(element) || [];
    const depsData = {
      decorations: allDecorations,
      injections: descendantsInjections,
      composing: computedComposing
    };

    if (cachedDecoratedElement && equal__default["default"](cachedDepsData, depsData)) {
      decoratedElement = cachedDecoratedElement;
    } else {
      // delegate view data to children
      const childrenDecorations = allDecorations.length ? getChildrenDecorations(document, element, allDecorations) : null;
      const childrenInjections = descendantsInjections.length ? getChildrenInjections(document, element, descendantsInjections) : null;
      let isChildrenDecorated = false;
      const decoratedNodes = element.nodes.map((child, index) => {
        const decoratedChild = this.toView(child, childrenDecorations ? childrenDecorations[index] : [], childrenInjections ? childrenInjections[index] : [], isNodeVisible);
        isChildrenDecorated = isChildrenDecorated || decoratedChild !== child;
        return decoratedChild;
      });
      const decorated = isChildrenDecorated ? element.set('nodes', decoratedNodes) : element;
      this.VIEW_CACHE.DECORATED_ELEMENT.set(element, [decorated, depsData]);
      decoratedElement = decorated;
    }

    let groupedElement = decoratedElement;
    const cachedGroupedElement = this.VIEW_CACHE.GROUPED_ELEMENT.get(decoratedElement);

    if (cachedGroupedElement) {
      groupedElement = cachedGroupedElement;
    } else {
      const groupedNodes = Block.isBlocks(decoratedElement.nodes) ? this.groupNodes([0, decoratedElement.nodes.length], decoratedElement) : decoratedElement.nodes;
      groupedElement = groupedNodes === decoratedElement.nodes ? decoratedElement : decoratedElement.set('nodes', groupedNodes);
      this.VIEW_CACHE.GROUPED_ELEMENT.set(decoratedElement, groupedElement);
    }

    const [cachedViewElement, cachedDepInjections] = this.VIEW_CACHE.INJECTED_ELEMENT.get(groupedElement) || [];

    if (cachedViewElement && equal__default["default"](cachedDepInjections, selfInjections)) {
      return cachedViewElement;
    }

    const injectedElement = Injection.injectIntoNode(selfInjections, groupedElement);
    this.VIEW_CACHE.INJECTED_ELEMENT.set(groupedElement, [injectedElement, selfInjections]);
    this.VIEW_CACHE.ELEMENT.set(element, [injectedElement, decorations, injections, composing]);
    this.VIEW_CACHE.DATA.set(injectedElement, depsData);
    this.VIEW_CACHE.INJECT_TO_VIEW_ELEMENT.set(injectedElement, {
      decorations,
      injections
    });
    return injectedElement;
  }
  /**
   * 将 Data Model 上的节点转换为 View Model 的节点
   * @param node
   * @param data
   */


  toView(node, decorations, injections, isNodeVisible = false) {
    const n = node.toSubType(); // 开启视图模型的按需重算后，节点视图模型将根据其可见与否决定是否重算

    if (this.enableOnDemandViewCalculation) {
      if (Document.isDocument(n)) {
        return this.toViewElement(n, decorations, injections);
      }

      if (isNodeVisible || this.isNodeVisible(node)) {
        return n.isText() ? this.toViewText(n, decorations) : this.toViewElement(n, decorations, injections, true);
      } else {
        if (n.isText()) {
          const [viewCache] = this.VIEW_CACHE.TEXT.get(n) || [];

          if (!viewCache) {
            this.VIEW_CACHE.VIEW_NEVER_CALCULATED.add(n.key);
          }

          return viewCache || n;
        } else {
          const [viewCache] = this.VIEW_CACHE.ELEMENT.get(n) || [];

          if (!viewCache) {
            this.VIEW_CACHE.VIEW_NEVER_CALCULATED.add(n.key);
          }

          return viewCache || n;
        }
      }
    } else {
      return n.isText() ? this.toViewText(n, decorations) : this.toViewElement(n, decorations, injections);
    }
  }
  /**
   * 热区计算时，获得应当注入 Hot View Node 的 View Data
   * 根据当前变更判断是否需要重算 View Data
   * 1. 若需要：则携带（1）parent node 的被分发的视图数据（2） Top-Level(`controller.value.injections`, `controller.value.decorations`) 的视图数据， 重新为 node 分发视图数据
   * 2. 否则，使用缓存的视图数据
   * @param viewNode
   * @param dataNode
   * @returns
   */


  getInjectedViewData(viewNode, dataNode) {
    if (Document.isDocument(dataNode)) {
      return {
        decorations: this.value.decorations,
        injections: this.value.injections
      };
    }

    const {
      document
    } = this.value;
    const parent = document.assertParent(dataNode.key);
    const firstOp = this.$operationWithValues[0];
    const cacheKey = Element$1.isElement(viewNode) ? viewNode : parent;
    const cache = this.VIEW_CACHE.INJECT_TO_VIEW_ELEMENT.get(cacheKey);
    const deps = {
      decorations: [],
      injections: [],
      ...(cache || {})
    }; // 当上一次注入的 cache 无法获取时，也需要重新分发

    const decorationsChanged = !cache || firstOp && firstOp.value.decorations !== this.$value.decorations;
    const injectionsChanged = !cache || firstOp && firstOp.value.injections !== this.$value.injections;
    let injectedDecorations = deps.decorations;
    let injectedInjections = deps.injections; // 获得缓存的 deps

    if (decorationsChanged) {
      const {
        decorations: parentDecorations = []
      } = this.VIEW_CACHE.INJECT_TO_VIEW_ELEMENT.get(parent) || {};
      injectedDecorations = parent ? getChildrenDecorations(document, parent, this.value.decorations.concat(parentDecorations))[parent.nodes.indexOf(dataNode)] : this.value.decorations;
    }

    if (injectionsChanged) {
      const {
        injections: parentInjections = []
      } = this.VIEW_CACHE.INJECT_TO_VIEW_ELEMENT.get(parent) || {}; // BACKGGROUND: 部分插件 `injectToNode` 的实现有 anti-pattern，
      // 并非从当前节点测算，而从顶层节点（`document`）测算，因而其 injections 会写入顶层节点缓存
      // 故而这里要并入顶层节点的 injections 重新分发

      const docInjects = this.VIEW_CACHE.INJECT_TO_NODE.get(document) || [];
      injectedInjections = parent ? getChildrenInjections(document, parent, this.value.injections.concat(parentInjections).concat(docInjects))[parent.nodes.indexOf(dataNode)] : this.value.injections;
    } // 重新计算后，更新缓存


    this.VIEW_CACHE.INJECT_TO_VIEW_ELEMENT.set(cacheKey, {
      injections: injectedInjections,
      decorations: injectedDecorations
    });
    return {
      decorations: injectedDecorations,
      injections: injectedInjections
    };
  }
  /**
   * 重新计算热区中的视图模型
   * @param viewNode
   * @returns
   */


  recalculateView(viewNode) {
    const cachedViewNode = this.$viewDoc.assertNode(viewNode.key);
    const dataNode = this.value.document.getNode(viewNode.key); // 诸如分组节点这样不存在与数据模型上的视图节点，不会被热区计算考虑，直接返回

    if (!dataNode) {
      return {
        node: viewNode,
        document: this.$viewDoc
      };
    }

    let newViewNode = cachedViewNode;
    let newViewDoc = this.$viewDoc; // 2. 结合最新的依赖，重算视图模型

    if (Element$1.isElement(viewNode)) {
      const {
        decorations,
        injections
      } = this.getInjectedViewData(viewNode, dataNode);
      newViewNode = this.toViewElement(dataNode, decorations, injections, true);
      const path = this.$viewDoc.assertPath(newViewNode.key);
      newViewDoc = this.$viewDoc.replaceNode(path, newViewNode, this.noSpacialEffect());
    } // 3. 刷新视图模型缓存，并返回重新计算得到的 Node 和 Document 视图


    this.$viewDoc = newViewDoc;
    return {
      node: newViewNode,
      document: newViewDoc
    };
  }
  /**
   * 是否当前未产生节点空间的影响
   * 1. 协同变更无法评估是否对空间有影响
   * 2. 非协同变更：
   *   * Pending 时，无空间影响
   *   * 非 Pending 时，判断累积的操作是否有空间影响
   * @returns
   */


  noSpacialEffect() {
    return !this.hots.forceRecalculate && (this.isPending || this.$operationWithValues.every(op => {
      const {
        operation,
        key
      } = op;

      if (!operation) {
        return isSetValueNotAffectSpace(key);
      }

      return isOperationNotAffectSpace(operation);
    }));
  }
  /**
   * 获得热区状态下的视图
   * @param node
   * @param document
   * @param shouldRecalculate
   * @returns
   */


  getView(node, document, shouldRecalculate) {
    if (this.hots.forceRecalculate) {
      return this.recalculateView(node);
    }

    if (shouldRecalculate && this.pendingType !== exports.PendingType.selection) {
      return this.recalculateView(node);
    } // 如果没有变更，直接返回缓存的计算结果


    if (this.hasHots()) {
      const view = this.$viewDoc.assertNode(node.key);
      return {
        node: view,
        document: this.$viewDoc
      };
    }

    return {
      node,
      document
    };
  }
  /**
   * 执行一个函数，并在执行过程中，禁止任何的 normalize
   * @param fn 执行函数
   */


  withoutNormalizing(fn) {
    const prevNormalizing = this.flag.normalizing;
    this.flag.normalizing = false;
    fn(this);
    this.flag.normalizing = prevNormalizing;
    return this;
  }
  /**
   * 执行一个函数，并在执行过程中，禁止任何的 pending
   * @param fn 执行函数
   * @returns
   */


  withoutPending(fn) {
    const prevPending = this.flag.pending;
    this.flag.pending = false;
    fn(this);
    this.flag.pending = prevPending;
    return this;
  }
  /**
   * 执行一个函数，并在执行过程中，不记录 undo stack
   * @param fn 执行函数
   * @returns
   */


  withoutSaving(fn, {
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  } = {}) {
    const prevSaving = this.flag.saving;
    this.flag.saving = false;
    let nextOperationIndex = this.operations.length;
    this.withOpContext('cj/history/withoutsaving', () => fn(this));

    if (!__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) {
      while (nextOperationIndex < this.operations.length) {
        const operation = this.operations[nextOperationIndex];
        const operationType = operation.type;

        if (operationType !== 'set_node' && operationType !== 'set_mark' && operationType !== 'add_mark' && operationType !== 'remove_mark' && operationType !== 'set_selection') {
          throw new Error('Cangjie.Controller.withoutSaving only support Operation[type=set_node|set_mark|add_mark|remove_mark|set_selection].');
        }

        nextOperationIndex += 1;
      }
    }

    this.flag.saving = prevSaving;
    return this;
  }
  /**
   * 执行一个函数，并在执行过程中禁止 op tracking
   * @param fn 执行函数
   * @returns
   */


  withoutTracking(fn) {
    const prevTracking = this.flag.tracking;
    this.flag.tracking = false;
    fn(this);
    this.flag.tracking = prevTracking;
    return this;
  }

  withCommand(fn) {
    const prevWithCommand = this.flag.withCommand;
    this.flag.withCommand = true;
    fn(this);
    this.flag.withCommand = prevWithCommand;
    return this;
  }

  withOpContext(context, fn, meta) {
    if (meta) {
      this.context.push(`${context}(${JSON.stringify(meta)})`);
    } else {
      this.context.push(context);
    }

    fn(this);
    this.context.pop();
    return this;
  }
  /**
   * 执行一个command
   * @param cmd command函数或者字符串。传入函数会直接执行，字符串则会调用所有插件的onCommand中对应的处理函数
   * @param args command的参数
   */


  command(cmd, ...args) {
    if (process.env.NODE_ENV === 'development') {
      warning__default["default"](this.flag.withCommand, 'Should not use Cangjie.Controller.command out of handlers or normalizer.');
    }

    if (typeof cmd === 'function') {
      cmd(this, ...args);
    } else {
      this.run('onCommand', {
        type: cmd,
        args
      });
    }

    this.withoutTracking(() => this.normalizeDirtyKeys());
    return this;
  }
  /**
   * 执行一个query
   * @param qry query函数或者字符串。传入函数会直接执行，字符串则会调用所有插件的onQuery中对应的处理函数
   * @param args query的参数
   */


  query(qry, ...args) {
    if (typeof qry === 'function') {
      return qry(this, ...args);
    }

    return this.run('onQuery', {
      type: qry,
      args
    });
  }
  /**
   * 触发一个插件的 action
   * @param name string action 名称
   * @param args  action 调用参数
   *
   * TODO: 插件迁移完成后，删掉 string 的定义
   */


  dispatch(name, ...args) {
    const creator = this.actions[name];

    if (creator) {
      this.run('onAction', creator(...args));
    }
  }
  /**
   * 获取 action 判断函数。 返回的结果用于判断入参是否是某种 action, 支持 type predicate
   * @param name action Name: 插件基于 PluginActionPredicates 注册
   * @returns (action: any): action is SomeAction
   *
   * TODO: 插件迁移完成后，删掉 string 的定义
   */


  isActionFactory(name) {
    return this.isActions[name];
  }
  /**
   * 销毁当前 controller 实例
   */


  destroy() {
    this.flag.destroyed = true;
    this.groupManager.cleanup();

    if (this.virtualize.invisibleCalculationId) {
      window.cancelIdleCallback(this.virtualize.invisibleCalculationId);
    }

    this.debouncedFlush.cancel();
    this.debouncedStartInvisibleCalculationScheduler.cancel();
    this.cleanup();
  }
  /**
   * 清理编辑器以及插件的cache
   */


  cleanup() {
    this.run('onCleanup');
  }
  /**
   * 获得当前编辑器的视图模型
   */


  get view() {
    if (this.hasHots() && this.$viewDoc) {
      return this.$viewDoc;
    }

    const {
      document,
      decorations,
      injections
    } = this.value;

    if (this.VIEW_CACHE.VALUE.has(this.value)) {
      const [decoratedDocument] = this.VIEW_CACHE.DECORATED_ELEMENT.get(document) || [];

      if (decoratedDocument) {
        const groupedDocument = this.VIEW_CACHE.GROUPED_ELEMENT.get(decoratedDocument);

        if (groupedDocument) {
          const [viewDocument] = this.VIEW_CACHE.INJECTED_ELEMENT.get(groupedDocument) || [];

          if (viewDocument) {
            return viewDocument;
          }
        }
      }
    }

    this.VIEW_CACHE.VALUE.add(this.value);
    const viewDoc = this.toView(document, decorations, injections);
    this.$viewDoc = viewDoc;
    return viewDoc;
  }
  /**
   * 获得 `node`  的视图数据
   * @param node
   */


  getViewData(node) {
    return this.VIEW_CACHE.DATA.get(node) || {
      decorations: [],
      injections: []
    };
  }

  setOpRelatedId(id) {
    this.flag.opRelatedId = id;
    return this;
  }

  get opRelatedId() {
    return this.flag.opRelatedId;
  }

  get shouldResumePosition() {
    return this.flag.scrollType === 'maintain';
  }

  get shouldScrollToSelection() {
    return this.flag.scrollType === 'toSelection';
  }

  setScrollType(type) {
    this.flag.scrollType = type;
  }

  get isPending() {
    // OP Pending 或热区过程中
    return !!this.pendingQueue.type || !!this.hots.pendingType;
  }

  get enablePending() {
    return this.pendingQueue.enablePending;
  }

  get isPendingEnable() {
    return Object.values(this.pendingQueue.enablePending).some(s => !!s) && this.flag.pending;
  }

  get pendingType() {
    // 热区 debounce 时，pending type
    if (this.hasHots()) {
      return this.hots.pendingType;
    }

    return this.pendingQueue.type || this.testType;
  }

  get isTracking() {
    return this.flag.tracking;
  } // 通知 pending 结束事件


  dispatchPendingTerminal() {
    this.terminal$.next(null);
  }

  perfStart(payload) {
    const {
      type,
      subtype
    } = payload;
    const perf = this.flag.perf[type];
    const timestamp = performance.now();
    perf.push({
      type,
      subtype: subtype || type,
      timestamp
    });
    perfMark(`cangjie-perf-${subtype || type}-start-${timestamp}`);
  }

  perfEnd(type, dropped = false) {
    const perf = this.flag.perf[type];
    const start = perf.shift();

    if (!start) {
      return;
    }

    const {
      subtype,
      timestamp
    } = start;
    const endKey = `cangjie-perf-${subtype || type}-end-${timestamp}`;
    const startKey = `cangjie-perf-${subtype || type}-start-${timestamp}`;
    perfMark(endKey);

    if (start.ignore) {
      perfMeasure('cangjie-perf-ignore', startKey, endKey);
      return;
    }

    perfMeasure(`cangjie-perf-${subtype}`, startKey, endKey); // 计算准确时间

    const current = performance.now();
    let duration = current - timestamp;

    if (perf.length > 0) {
      duration -= current - perf[0].timestamp;
    }

    this.run('onCangjiePerf', CangjiePerfEvent({
      type: subtype,
      duration,
      dropped
    }));
  }
  /**
   * 丢弃 perf 数据
   * @description BACKGROUND:
   * 通常 perf 队列遵循 **先进先出** 的原则，每一次入队都意味着一次交互事件的产生，正常出队的时机是在渲染后的 setTimeout 任务里（通过 perfEnd 出队）。
   * - 有些情况下我们不需要记录此次 perf 值（eg. 交互事件后未触发视图改变），所以通过 `perfDrop(type)` 异步地丢弃之；
   * - 特殊情况下，如果在正常出队前发现数据无效（eg. 丢帧：marcoTask 先于渲染执行）需要丢弃，则通过 `perfDrop(type, true)` 同步地丢弃之。
   * @param type PerfType
   * @param immediately 是否立即丢弃
   */


  perfDrop(type, immediately = false) {
    if (immediately) {
      const {
        subtype,
        timestamp
      } = this.flag.perf[type].shift() || {};
      const endKey = `cangjie-perf-${subtype}-end-${timestamp}`;
      subtype && perfMark(endKey);
      return;
    } // 延迟丢弃时，先标记该数据 ignore


    const lastIndex = this.flag.perf[type].length - 1;

    if (lastIndex >= 0 && this.flag.perf[type][lastIndex]) {
      this.flag.perf[type][lastIndex].ignore = true;
      setTimeout(() => {
        const {
          subtype,
          timestamp
        } = this.flag.perf[type].shift() || {};
        const endKey = `cangjie-perf-${subtype}-end-${timestamp}`;
        subtype && perfMark(endKey);
      });
    }
  }

  perfClearAll() {
    Object.keys(this.flag.perf).forEach(type => {
      this.flag.perf[type] = [];
    });
  }

  setUid(dataUid) {
    this.uid = dataUid === undefined ? undefined : String(dataUid);
  }

  switchUid(dataUid) {
    this.setUid(dataUid);
    this.userData.update$.next({
      uuid: '*'
    });
  }

  getHots() {
    if (this.$operationWithValues.length <= (this.virtualizeOptions.maxOPsForHotsAnalyze || 0)) {
      return getHots(this.$operationWithValues, this);
    }

    return [];
  }

  setHots(hots, pendingType, forceRecalculate = false) {
    this.hots = {
      hots,
      keys: hots.reduce((ret, hot) => {
        ret[hot.node.key] = true;
        return ret;
      }, {}),
      pendingType,
      lengthOfPending: pendingType ? this.$operationWithValues.length : 0,
      forceRecalculate
    };

    if (hots.length) {
      this.hots$.next(hots);
    }

    return this;
  }

  clearHots() {
    this.hots = {
      hots: [],
      keys: {},
      pendingType: null,
      lengthOfPending: 0,
      forceRecalculate: false
    };
    return this;
  }

  hasHots() {
    return this.hots.hots.length > 0;
  }
  /** 是否开启热区 */


  get enableHots() {
    const {
      enable,
      pendingDebounceTime
    } = this.virtualizeOptions;
    return enable && typeof pendingDebounceTime === 'number' && pendingDebounceTime > 0;
  }
  /**
   * 当前节点视图是否热
   * @param viewNode
   * @returns
   */


  isViewHot(viewNode) {
    if (!this.enableHots) {
      return false;
    }

    return !!this.hots.keys[viewNode.key] && this.$value.document.hasNode(viewNode.key);
  }

  addIsSelected(key) {
    this.VIEW_CACHE.IS_SELECTED.add(key);
  }

  getIsSelected(key) {
    return this.VIEW_CACHE.IS_SELECTED.has(key);
  }

  removeIsSelected(key) {
    this.VIEW_CACHE.IS_SELECTED.delete(key);
  }
  /**
   * 1. 若配置了闪享光标，则 blur 时需要显示远程光标
   * 2. 否则，根据配置项 hideSelectionOnBlur 决定是否需要隐藏
   * @returns 是否需要不显示选区
   */


  shouldHideSelectionOnBlur() {
    return !this.showCaret?.onBlur && this.hideSelectionOnBlur;
  }
  /**
   * 是否开启虚拟化
   */


  get enableVirtualize() {
    return this.virtualizeOptions.enable;
  }
  /**
   * 是否开启模型虚拟化以及视图虚拟化
   */


  get enableVirtualizeView() {
    return this.virtualizeOptions.enable && !this.virtualizeOptions.disableViewVirtualize;
  }
  /** 是否开启按需计算 */


  get enableOnDemandViewCalculation() {
    return !!this.virtualizeOptions.enable && this.virtualizeOptions.enableOnDemandViewCalculation;
  }
  /**
   * 虚拟化时，是否节点可见
   * @param node
   * @returns
   */


  isNodeVisible(node) {
    if (!Element$1.isElement(node)) {
      return false;
    }

    const {
      visibles
    } = this.virtualize;
    return visibles.some(visible => {
      if (node.key === visible) {
        return true;
      } // 如果可见节点是视图模型上的节点，则判断节点是否在视图模型上


      if (!this.value.document.hasNode(visible)) {
        const viewElement = this.$viewDoc?.getNode(visible);
        return viewElement?.isElement() && viewElement.hasNode(node.key);
      }

      return false;
    });
  }
  /**
   * 是否 visibles 中存在未计算过视图模型的节点
   * 当节点被认为不可见后，它的视图模型不会被计算，那么下一次可见时：
   * - 节点本身可见
   * - 节点所在分组可见
   * 此时，需要保证节点的视图模型能够被正确计算
   * @param visibles
   * @returns
   */


  hasViewNeverCalculatedInVisibles(visibles) {
    return visibles.some(visible => {
      if (this.VIEW_CACHE.VIEW_NEVER_CALCULATED.has(visible)) {
        return true;
      }

      if (!this.value.document.hasNode(visible)) {
        const viewElement = this.$viewDoc?.assertElement(visible);
        return !!viewElement?.findDescendant(node => node.isElement() && this.VIEW_CACHE.VIEW_NEVER_CALCULATED.has(node.key));
      }

      return false;
    });
  }
  /**
   * 设置虚拟化的可见节点集合
   * @param visibles
   */


  setVirtualize(key, value) {
    const {
      document
    } = this.value;

    if (key === 'visibles' && !equal__default["default"](this.virtualize[key], value)) {
      const visibles = value;
      this.virtualize.visibles = visibles; // 如果 visible 中存在未计算过视图模型的节点，则需要重算视图模型

      if (this.hasViewNeverCalculatedInVisibles(visibles)) {
        //清理视图缓存，避免节点可见后，取到旧的视图模型缓存
        this.clearHots();
        this.VIEW_CACHE.VALUE.delete(this.value);
        this.VIEW_CACHE.ELEMENT.delete(document);
        this.VIEW_CACHE.DECORATED_ELEMENT.delete(document);
        this.VIEW_CACHE.INJECTED_ELEMENT.delete(document);
        this.VIEW_CACHE.GROUPED_ELEMENT.delete(document);
        this.view;
      }

      this.visibles$.next(visibles); // 每当可视节点发生变化，则重新开始调度不可见节点的计算

      this.debouncedStartInvisibleCalculationScheduler(visibles);
    } else {
      this.virtualize[key] = value;
    }

    return this;
  }

  get visibleBlocks() {
    return this.virtualize.visibles;
  }

  set scrollableContainer(scrollableContainer) {
    this.$scrollableContainer = scrollableContainer;
  }

  get scrollableContainer() {
    return this.$scrollableContainer || window;
  }

  get enableUUID() {
    return this.uuidConfig.enable;
  }

}
/**
 * @ignore
 */

Controller.useController = useController;
Controller.useControllerStatic = useControllerStatic;
Controller.connectController = connectController;
const ControllerContext = /*#__PURE__*/React__namespace.createContext(null);

/**
 * @packageDocumentation
 * @module Hooks
 */

/**
 * 样式 context
 */
const StyleContext = /*#__PURE__*/React__default["default"].createContext(undefined);
function useStyle() {
  return React__default["default"].useContext(StyleContext);
}
/**
 * 获取节点样式
 * @returns React.CSSProperties
 */

function useNodeStyle(controller, node, visible = true) {
  const docStyle = React__default["default"].useContext(StyleContext); // 非 block 元素不消费 style，return 以提高性能

  if (!Block.isBlock(node)) return {};
  const style = controller.run('getNodeStyle', {
    node,
    docStyle
  }) || {};

  if (visible === false) {
    style.display = 'none';
  }

  return style;
}
/**
 * 获取全局默认文本样式
 * @returns React.CSSProperties
 */

function useContentStyle(controller) {
  const docStyle = React__default["default"].useContext(StyleContext);
  const style = controller.run('getContentStyle', {
    docStyle
  }) || {};
  return style;
}

/**
 * @packageDocumentation
 * @module Controller
 */
const _createElement$f = React__namespace.createElement;
function Provider(props) {
  const {
    biz,
    dataUid,
    plugins,
    value,
    onChange = lodash.noop,
    controllerRef = lodash.noop,
    children,
    readOnly = false,
    autoFocus = false,
    canCopy,
    options,
    flushType,
    configs,
    onBusyStateChange,
    onFirstRender,
    docStyle,
    onPending = lodash.noop
  } = props;
  const pluginsRef = React__namespace.useRef();
  const onChangeRef = React__namespace.useRef();
  const prevValueRef = React__namespace.useRef(value);
  const controller = React__namespace.useMemo(() => {
    const controllerIns = Controller.create({
      biz,
      dataUid,
      plugins,
      value,
      onChange,
      readOnly,
      autoFocus,
      canCopy,
      flushType,
      configs,
      onBusyStateChange,
      onPending
    }, options);
    pluginsRef.current = plugins;
    onChangeRef.current = onChange;
    controllerIns.groupManager.generateAllGroups();
    return controllerIns; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  React__namespace.useLayoutEffect(() => {
    if (onFirstRender) {
      onFirstRender(controller);
    }
  }, []);
  React__namespace.useEffect(() => {
    controller.showCaret = options?.showCaret;
  }, [options?.showCaret?.onBlur, options?.showCaret?.onReadOnly]); // 因 canCopy 而重新生成 controller 会导致后续的交互出 BUG

  React__namespace.useEffect(() => {
    if (typeof canCopy === 'boolean') {
      controller.canCopy = canCopy;
    }
  }, [controller, canCopy]);
  React__namespace.useEffect(() => {
    if (process.env.NODE_ENV === 'development') {
      warning__default["default"](plugins === pluginsRef.current, "Cangjie.Provider will ignore `plugins`'s change.");
      warning__default["default"](onChange === onChangeRef.current, "Cangjie.Provider will ignore `onChange`'s change.");
    }
  }, [plugins, onChange]);
  React__namespace.useEffect(() => {
    // uid 变化，刷新用户数据
    controller.switchUid(dataUid);
  }, [dataUid]);
  controllerRef(controller);

  if (readOnly !== controller.readOnly) {
    controller.setReadOnly(readOnly);
  }

  if (controller.enableVirtualize && controller.virtualizeManager?.viewInitialized) {
    controller.virtualizeManager.workflowOnValueChange();
  } // Note: This action will trigger normalize


  if (value !== prevValueRef.current && value !== controller.value) {
    controller.resetValue(value, options);
  }

  prevValueRef.current = value;
  const context = React__namespace.useMemo(() => {
    const subject = new Subject();
    return {
      controller,
      subject
    };
  }, [controller]); // Note: Force re-render except first mount.

  const didMountRef = React__namespace.useRef(false);
  React__namespace.useEffect(() => {
    if (didMountRef.current) {
      context.subject.next(value);
    } else {
      didMountRef.current = true;
    }
  }, [value]);
  React__namespace.useEffect(() => {
    if (autoFocus) {
      controller.command(focus).flush();
    }
  }, [controller, autoFocus]);
  React__namespace.useEffect(() => {
    // 首次渲染完成，刷新分组信息
    controller.groupManager.notifyNewGroups(true);
    return () => {
      controller.destroy();
    };
  }, [controller]);
  React__namespace.useEffect(() => {
    if (IS_DEV) {
      const [main] = React__namespace.version.split('.');
      warning__default["default"](Number(main) < 18, 'React > 17 is not fully supported, editor will have some weird problems.');
    }
  }, []);
  return /*#__PURE__*/_createElement$f(ControllerContext.Provider, {
    value: context
  }, /*#__PURE__*/_createElement$f(StyleContext.Provider, {
    value: docStyle
  }, children));
}

/**
 * @packageDocumentation
 * @module Models
 */
class Decoration extends ImmutableRecord {
  static create(props) {
    if (Decoration.isDecoration(props)) {
      return props;
    }

    if (isPlainObject__default["default"](props)) {
      const {
        start,
        end,
        mark
      } = props;
      return new Decoration({
        start: TextPoint.create(start),
        end: TextPoint.create(end),
        mark: Mark.create(mark)
      });
    }

    throw new Error(`\`Decoration.create\` only accepts objects or decorations, but you passed it: ${props}`);
  }

  static fromJSON(json) {
    const {
      start,
      end,
      mark
    } = json;
    return Decoration.create({
      start: TextPoint.fromJSON(start),
      end: TextPoint.fromJSON(end),
      mark: Mark.fromJSON(mark)
    });
  }

  static isDecoration(maybeDecoration) {
    return maybeDecoration instanceof Decoration;
  }
  /**
   * Decoration的start point
   */


  constructor(props) {
    super();
    this.start = void 0;
    this.end = void 0;
    this.mark = void 0;
    const {
      start,
      end,
      mark
    } = props;
    this.start = start;
    this.end = end;
    this.mark = mark;
    this.freeze();
  }

  merge(props) {
    return new Decoration({
      start: this.start,
      end: this.end,
      mark: this.mark,
      ...props
    });
  }

  set(key, value) {
    return this.merge({
      [key]: value
    });
  }

  toJSON(options) {
    return {
      start: this.start.toJSON(options),
      end: this.end.toJSON(options),
      mark: this.mark.toJSON()
    };
  }

}

function mergeUserProperties(value, operation) {
  const {
    path,
    properties,
    context
  } = operation; // 将当前 OP 中用户数据与 value 上的合并
  // 避免协同编辑下，不同用户/不同段落 OP 数据相互覆盖

  const matched = context?.match(/userdata\/(.*)\/(.*)/);
  const targetData = properties?.data?.userData || {};

  if (matched && path?.length === 0 && targetData) {
    let mergedData = value.document.data?.userData || {}; // context 上携带此次修改用户数据的 uid 和块 uuid

    const mUid = matched[1];
    let uids = [];

    if (mUid === '*') {
      uids = lodash.union(Object.keys(mergedData), Object.keys(targetData));
    } else if (mUid) {
      uids = [mUid];
    }

    const uuids = matched[2].split(',');
    uids.forEach(uid => {
      uuids.forEach(uuid => {
        const target = targetData?.[uid]?.[uuid];

        if (uuid) {
          if (target === undefined) {
            // 删除数据
            mergedData = { ...mergedData,
              [uid]: lodash.omit(mergedData?.[uid], uuid)
            };
          } else {
            // 用 op 中 uuid 对应数据覆盖 document 上对应的
            mergedData = { ...mergedData,
              [uid]: { ...mergedData?.[uid],
                [uuid]: target
              }
            };
          }
        }
      });
    });
    return { ...properties,
      data: omitDeepBy({ ...properties.data,
        userData: mergedData
      }, isEmptyObj)
    };
  }

  return properties;
}

/* eslint-disable no-dupe-class-members */

const warning = typeof console !== 'undefined' ? lodash.once(console.warn.bind(console) || (() => {})) : lodash.noop;

function getDefaultSelection(document) {
  const firstNode = document.getFirstNode();

  if (Text$1.isText(firstNode)) {
    const point = TextPoint.create({
      key: firstNode.key,
      offset: 0
    });
    return Selection.create({
      anchor: point,
      focus: point
    });
  }

  const point = EdgePoint.create({
    key: document.key,
    edge: EdgePoint.BEFORE
  });
  return Selection.create({
    anchor: point,
    focus: point
  });
}

class Value extends ImmutableRecord {
  static create(props = {}) {
    if (Value.isValue(props)) {
      return props;
    }

    if (isPlainObject__default["default"](props)) {
      const {
        data = {},
        document: doc = {},
        selection,
        remoteSelections = [],
        injections = [],
        decorations = [],
        composing = '',
        isFocused = false
      } = props;
      const document = Document.create(doc);
      return new Value({
        data,
        document,
        selection: selection || getDefaultSelection(document),
        remoteSelections,
        injections,
        decorations,
        composing,
        isFocused
      });
    }

    throw new Error(`\`Value.create\` only accepts objects or values, but you passed it: ${props}`);
  }

  static fromJSON(json) {
    const {
      document = {},
      injections,
      selection,
      remoteSelections,
      decorations
    } = json;
    const documentValue = Document.fromJSON(document);
    return Value.create({ ...json,
      injections: injections ? injections.map(Injection.fromJSON) : undefined,
      document: documentValue,
      selection: selection ? Selection.fromJSON(selection) : getDefaultSelection(documentValue),
      remoteSelections: remoteSelections ? remoteSelections.map(Selection.fromJSON) : undefined,
      decorations: decorations ? decorations.map(Decoration.fromJSON) : undefined
    });
  }

  static isValue(maybeValue) {
    return maybeValue instanceof Value;
  }
  /**
   * value 的 injections 数组
   */


  /**
   * 当前的选区
   */
  get rangeSelection() {
    if ('development' === process.env.NODE_ENV) {
      warning('`Value.rangeSelection` is deprecated, please use `Value.selection`');
    }

    return this.selection;
  }
  /**
   * 远程选区
   */


  constructor(props) {
    super();
    this.injections = void 0;
    this.decorations = void 0;
    this.isFocused = void 0;
    this.data = void 0;
    this.document = void 0;
    this.selection = void 0;
    this.remoteSelections = [];
    this.composing = '';
    const {
      data,
      document,
      selection,
      remoteSelections,
      injections,
      decorations,
      composing,
      isFocused
    } = props;
    this.data = { ...data
    };
    this.document = document;
    this.selection = selection;
    this.remoteSelections = remoteSelections;
    this.injections = injections;
    this.decorations = decorations;
    this.composing = composing;
    this.isFocused = isFocused;
    this.freeze();
  }
  /**
   * 获取当前选中的blocks
   */


  get blocks() {
    return !this.selection ? [] : this.document.getLeafBlocksAtRange(this.selection);
  }
  /**
   * 获取当前选中的inlines
   */


  get inlines() {
    return !this.selection ? [] : this.document.getLeafInlinesAtRange(this.selection);
  }

  getElement(pointName, type) {
    const {
      document,
      selection
    } = this;

    if (!selection) {
      return null;
    }

    const point = selection.getPoint(pointName, document);

    if (type === 'block') {
      return document.getClosestBlockFromPoint(point.key);
    } else if (type === 'inline') {
      return document.getClosestInline(point.key);
    } else {
      return document.getNode(point.key);
    }
  }
  /**
   * 获取当前选中的anchor位置对应的block
   */


  get anchorBlock() {
    return this.getElement('anchor', 'block');
  }
  /**
   * 获取当前选中的focus位置对应的block
   */


  get focusBlock() {
    return this.getElement('focus', 'block');
  }
  /**
   * 获取当前选中的start位置对应的block
   */


  get startBlock() {
    return this.getElement('start', 'block');
  }
  /**
   * 获取当前选中的end位置对应的block
   */


  get endBlock() {
    return this.getElement('end', 'block');
  }
  /**
   * 获取当前选中的anchor位置对应的inline
   */


  get anchorInline() {
    return this.getElement('anchor', 'inline');
  }
  /**
   * 获取当前选中的focus位置对应的inline
   */


  get focusInline() {
    return this.getElement('focus', 'inline');
  }
  /**
   * 获取当前选中的start位置对应的inline
   */


  get startInline() {
    return this.getElement('start', 'inline');
  }
  /**
   * 获取当前选中的end位置对应的inline
   */


  get endInline() {
    return this.getElement('end', 'inline');
  }
  /**
   * 获取当前选中的anchor位置对应的text
   */


  get anchorText() {
    return this.getElement('anchor', 'text');
  }
  /**
   * 获取当前选中的focus位置对应的text
   */


  get focusText() {
    return this.getElement('focus', 'text');
  }
  /**
   * 获取当前选中的start位置对应的text
   */


  get startText() {
    return this.getElement('start', 'text');
  }
  /**
   * 获取当前选中的end位置对应的text
   */


  get endText() {
    return this.getElement('end', 'text');
  }
  /**
   * 获取当前选中位置对应的marks。
   * 如果用户设置了正在编辑的样式，返回用户的设置Marks；否则返回当前文字的Marks。
   */


  get activeMarks() {
    if (!this.selection) {
      return [];
    }

    return this.selection.marks || this.document.getActiveMarksAtRange(this.selection);
  }
  /**
   * 是否是blur状态
   */


  get isBlurred() {
    return !this.isFocused;
  }
  /**
   * 获取当前选区对应的fragment
   */


  get fragment() {
    const {
      selection,
      document
    } = this;
    return selection ? document.getFragmentAtRange(selection) : Document.create();
  }

  merge(props) {
    return new Value({
      data: this.data,
      document: this.document,
      selection: this.selection,
      remoteSelections: this.remoteSelections,
      injections: this.injections,
      decorations: this.decorations,
      composing: this.composing,
      isFocused: this.isFocused,
      ...props
    });
  }

  set(key, value) {
    return this.merge({
      [key]: value
    });
  }

  updatePoints(document, map, removed) {
    const updateSelections = (selections, selection) => {
      if (!Selection.isSelection(selection)) {
        return [...selections, selection];
      }

      let {
        anchor,
        focus
      } = selection;

      if (anchor.isEdgePoint() || focus.isEdgePoint()) {
        ({
          anchor,
          focus
        } = selection.convertToTextPoints(document));
      }

      const newAnchor = map(anchor);
      const newFocus = map(focus);

      if (!newAnchor || !newFocus) {
        return selections;
      }

      if (equal__default["default"](newAnchor, anchor) && equal__default["default"](newFocus, focus) && Selection.isValidSelection(document, selection)) {
        // 如果选区没有任何变化，返回原选区即可
        return [...selections, selection];
      }

      return [...selections, selection.merge({
        anchor: newAnchor,
        focus: newFocus
      })];
    }; // FIXME: 当 Document 内没有 Text 节点时，无法被 focus，等价于废档


    const selections = [this.selection].reduce(updateSelections, []);
    const remoteSelections = this.remoteSelections.reduce(updateSelections, []);
    const decorations = this.decorations.reduce((decs, dec) => {
      const {
        start,
        end
      } = dec;
      const newStart = map(start);
      const newEnd = map(end);

      if (!newStart || !newEnd) {
        return decs;
      }

      const startText = document.getNode(newStart.key);
      const endText = document.getNode(newEnd.key);

      if (!startText || !endText) {
        return decs;
      }

      if (removed && Block.isBlock(removed) && [start, end].every(n => removed.getNode(n.key))) {
        // 删除 Block 节点时, 内部包含的 decoration 清空掉
        return decs;
      }

      if (equal__default["default"](newStart, newEnd) && startText.text) {
        return decs;
      }

      return [...decs, dec.merge({
        start: newStart,
        end: newEnd
      })];
    }, []);
    return this.merge({
      selection: selections[0] || getDefaultSelection(document),
      remoteSelections,
      decorations
    });
  }

  addMark(path, offset, length, mark) {
    let {
      document
    } = this;
    document = document.addMark(path, offset, length, mark);
    return this.set('document', document);
  }

  insertNode(path, node) {
    let {
      document
    } = this;
    document = document.insertNode(path, node);
    return this.set('document', document);
  }

  insertText(path, offset, text, marks) {
    const {
      document: prevDoc
    } = this;
    const document = prevDoc.insertText(path, offset, text, marks); // node must be Text if .insertText works.

    const node = prevDoc.assertTextByPath(path);
    return this.updatePoints(document, point => {
      // 若在当前选区之前插入文本，则需要后移选区
      // insert 'e'
      //   │    cursor
      //   ▼     │
      //  HlloWor│ld
      //         │
      //
      //     │
      //     │ inserted
      //     ▼
      //
      //          │
      //  HelloWor│d
      //          │
      //        cursor
      if (node.key === point.key && offset <= point.offset) {
        return point.moveForward(text.length);
      }

      return point;
    }).set('document', document);
  }

  mergeNode(path) {
    const {
      document: prevDoc,
      injections: prevInject
    } = this;
    const document = prevDoc.mergeNode(path);
    const injections = prevInject.filter(({
      key
    }) => {
      const injectTargetPath = prevDoc.getPath(key);
      return injectTargetPath && !Path.isEqual(injectTargetPath, path);
    }); // prev & node could not be null if .mergeNode works.

    const prev = prevDoc.getPreviousSiblingByPath(path);
    const node = prevDoc.getNodeByPath(path);
    return this.updatePoints(document, point => {
      // 如果选区所在的文本被 merge，则需要将光标移动到合并后的文本，并且修正光标起点
      //     ┌─────────┐  cursor
      //     │         │ │
      // ┌───▼───┐ ┌───┴─┼────┐
      // │ Hello │ │ Worl│d   │
      // └───────┘ └─────┼────┘
      //                 │
      //        │
      //        │ merged
      //        │
      //        ▼  
      //
      //           │
      // ┌─────────┼──┐
      // │HelloWorl│d │
      // └─────────┼──┘
      //           │
      //          cursor
      if (Text$1.isText(node) && point.key === node.key) {
        return point.merge({
          key: prev.key,
          offset: prev.text.length + point.offset
        });
      }

      return point;
    }).merge({
      document,
      injections
    });
  }

  moveNode(path, newPath) {
    if (equal__default["default"](path, newPath)) {
      return this;
    }

    let {
      document
    } = this;
    document = document.moveNode(path, newPath);
    return this.set('document', document);
  }

  removeMark(path, offset, length, mark) {
    let {
      document
    } = this;
    document = document.removeMark(path, offset, length, mark);
    return this.set('document', document);
  }

  removeNode(path) {
    const {
      document: prevDoc,
      injections: prevInject
    } = this;
    const node = prevDoc.assertNodeByPath(path);
    const prev = prevDoc.getPreviousNodeByPath(path);
    const next = prevDoc.getNextNodeByPath(path);
    const document = prevDoc.removeNode(path);
    const injections = prevInject.filter(({
      key
    }) => {
      const injectTargetPath = prevDoc.getPath(key);
      return injectTargetPath && !Path.isEqual(injectTargetPath, path);
    }); // `document.nodes` is empty.

    if (!prev && !next) {
      return this.merge({
        document,
        selection: getDefaultSelection(document),
        remoteSelections: [],
        injections: [],
        decorations: [],
        composing: ''
      });
    }

    return this.updatePoints(document, point => {
      if (node.key === point.key || node.isElement() && node.hasNode(point.key)) {
        // 若删除选区所在的节点或者其父节点，则要么移动选区到上一节点末，要么移动选区到下一节点开头
        //              cursor
        // ┌───────┐ ┌────┼───┐
        // │ Hello │ │ Wor│ld │
        // └───────┘ └────┼───┘
        //
        //          │
        //          │ removed
        //          ▼
        //
        // ┌──────┼┐
        // │ Hello││
        // └──────┼┘
        //      cursor
        if (prev) {
          const lastText = prev.getLastText();

          if (lastText) {
            return point.moveToEndOfNode(lastText);
          }
        } //       cursor
        //       │
        //  ┌────┼───┐ ┌───────┐
        //  │ Wor│ld │ │ Hello │
        //  └────┼───┘ └───────┘
        //       │
        //         │
        //         │ removed
        //         ▼
        //   │
        //  ┌┼──────┐
        //  ││Hello │
        //  └┼──────┘
        //   │
        // cursor


        if (next) {
          const firstText = next.getFirstText();

          if (firstText) {
            return point.moveToStartOfNode(firstText);
          }
        }

        return null;
      }

      return point;
    }, node).merge({
      document,
      injections
    });
  }

  removeText(path, offset, text) {
    const {
      document: prevDoc
    } = this;
    const document = prevDoc.removeText(path, offset, text); // node must be Text if .insertText works.

    const node = prevDoc.assertTextByPath(path);
    const start = offset;
    const end = start + text.length;
    return this.updatePoints(document, point => {
      if (node.key === point.key) {
        // 若当前选区在删除文本之后，则需要前移选区
        //          cursor
        //   ┌────┐   │
        //  H│ello│Wor│d
        //   └────┘   │
        //
        //       │
        //       │      removed
        //       ▼
        //
        //      │
        //  HWor│d
        //      │
        //    cursor
        if (point.offset >= end) {
          return point.moveBackward(text.length);
        } // 若当前选区在删除文本起点之后，则前移选区到删除起点
        //   ┌────┐
        //  H│ello│World
        //   └────┘
        //      ──────  selection
        //
        //      │
        //      │      removed
        //      ▼
        //
        //   HWorld
        //    ──── selection


        if (point.offset > start) {
          return point.set('offset', start);
        }
      }

      return point;
    }).set('document', document);
  }

  setMark(path, offset, length, mark, properties) {
    let {
      document
    } = this;
    document = document.setMark(path, offset, length, mark, properties);
    return this.set('document', document);
  }

  setNode(path, properties) {
    let {
      document
    } = this;
    document = document.setNode(path, properties);
    return this.set('document', document);
  }
  /**
   * 拷贝出一个新value，并设置选区字段
   */


  setSelection(selection) {
    return this.set('selection', selection);
  }

  splitNode(path, position, properties) {
    const {
      document: prevDoc
    } = this;
    const document = prevDoc.splitNode(path, position, properties); // node could not be null if .splitNode works.

    const node = prevDoc.getNodeByPath(path);
    return this.updatePoints(document, point => {
      // 如果在当前文本进行分裂，则需要调整选区到分裂后的文本
      //   position
      //       │    cursor
      //       │   │
      //  Hello│Wor│ld
      //       │   │
      //       │
      //
      //        │  split node
      //        ▼
      //
      //  Hello
      //  Wor│ld
      //    cursor
      if (Text$1.isText(node) && point.key === node.key && position <= point.offset) {
        // next is just create by .splitNode
        const next = document.getNextSiblingByPath(path);
        return point.merge({
          key: next.key,
          offset: point.offset - position
        });
      }

      return point;
    }).set('document', document);
  }
  /**
   * 应用operation，并返回一个新value
   */


  applyOperation(operation) {
    let value = null;
    const {
      type
    } = operation;

    if (type === exports.OperationType.AddMark) {
      const {
        path,
        offset,
        length,
        mark
      } = operation;
      value = this.addMark(path, offset, length, mark);
    } else if (type === exports.OperationType.InsertNode) {
      const {
        path,
        node
      } = operation;
      value = this.insertNode(path, node);
    } else if (type === exports.OperationType.InsertText) {
      const {
        path,
        offset,
        text,
        marks = []
      } = operation;
      value = this.insertText(path, offset, text, marks);
    } else if (type === exports.OperationType.MergeNode) {
      const {
        path
      } = operation;
      value = this.mergeNode(path);
    } else if (type === exports.OperationType.MoveNode) {
      const {
        path,
        newPath
      } = operation;
      value = this.moveNode(path, newPath);
    } else if (type === exports.OperationType.RemoveMark) {
      const {
        path,
        offset,
        length,
        mark
      } = operation;
      value = this.removeMark(path, offset, length, mark);
    } else if (type === exports.OperationType.RemoveNode) {
      const {
        path
      } = operation;
      value = this.removeNode(path);
    } else if (type === exports.OperationType.RemoveText) {
      const {
        path,
        offset,
        text
      } = operation;
      value = this.removeText(path, offset, text);
    } else if (type === exports.OperationType.SetMark) {
      const {
        path,
        offset,
        length,
        mark,
        properties
      } = operation;
      value = this.setMark(path, offset, length, mark, properties);
    } else if (type === exports.OperationType.SetNode) {
      const {
        path
      } = operation;
      const properties = mergeUserProperties(this, operation);
      value = this.setNode(path, properties);
    } else if (type === exports.OperationType.SetSelection) {
      const {
        selection
      } = operation;
      value = this.setSelection(selection);
    } else if (type === exports.OperationType.SplitNode) {
      const {
        path,
        position,
        properties
      } = operation;
      value = this.splitNode(path, position, properties);
    } else {
      throw new Error(`Unknown operation type: "${type}".`);
    }

    if (value.selection.anchor.key === value.document.key) {
      const selection = getDefaultSelection(value.document);
      return value.setSelection(selection);
    }

    return value;
  }

  toJSON(options) {
    const object = {
      klass: 'value',
      document: this.document.toJSON(options)
    };

    if (options?.preserveDecorations) {
      object.decorations = this.decorations.map(decotation => {
        const {
          start,
          end,
          mark
        } = decotation.toJSON(options);
        return {
          mark,
          start: { ...start,
            path: this.document.getPath(decotation.start.key)
          },
          end: { ...end,
            path: this.document.getPath(decotation.end.key)
          }
        };
      });
    }

    if (options?.preserveSelections) {
      const {
        selection
      } = this;
      const {
        anchor,
        focus
      } = selection.toJSON(options);
      object.selection = {
        anchor: { ...anchor,
          // @ts-ignore
          path: this.document.getPath(selection.anchor.key)
        },
        focus: { ...focus,
          // @ts-ignore
          path: this.document.getPath(selection.focus.key)
        }
      };
    }

    if (options?.preserveInjections) {
      object.injections = this.injections.map(injection => injection.toJSON());
    }

    return object;
  }

}

/* eslint-disable no-continue */

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  correctPointInsideInlineOrBlock: correctPointInsideInlineOrBlock,
  pointAtDistance: pointAtDistance,
  pointAtStartOfNode: pointAtStartOfNode,
  pointAtEndOfNode: pointAtEndOfNode,
  getUpsidePoint: getUpsidePoint,
  getUpsideRange: getUpsideRange,
  getDownsidePoint: getDownsidePoint,
  getDownsideRange: getDownsideRange
});

function usePendingTerminal(terminal$, onTerminate) {
  React__default["default"].useEffect(() => {
    const subs = terminal$.subscribe(onTerminate);
    return subs.unsubscribe;
  }, [onTerminate, terminal$]);
}

/**
 * @packageDocumentation
 * @module Plugin-PlaceHolder
 */
const _createElement$e = React__namespace.createElement;
const placeholderMarkType = 'cangjiePlaceholder';
const defaultPlaceholerSymbol = Symbol();
const placeholderStyle = {
  pointerEvents: 'none',
  userSelect: 'none',
  WebkitUserSelect: 'none',
  position: 'relative'
}; // 用于外部宽度没有撑开的情况

const innerStyleWithWidth = {
  width: 'fit-content',
  whiteSpace: 'nowrap',
  color: 'rgba(23,26,29, 0.4)'
};
const innerStyle = {
  position: 'absolute',
  ...innerStyleWithWidth
};
const ContentPlaceholderContext = /*#__PURE__*/React__namespace.createContext(null);

function useContentPlaceholder() {
  return React__namespace.useContext(ContentPlaceholderContext);
}

function blockEvent(event) {
  event.preventDefault();
  event.stopPropagation();
}

const defaultPx = '14.667';
const FONTSIZE_BIGGER = IS_MOBILE ? 1.06 : 1; // 并不需要精确计算placeholder的fontsize，目前只在非排版下使用

function formatFontSize(mark) {
  if (mark?.data?.value) {
    const {
      value,
      szUnit
    } = mark.data;
    const unit = szUnit || 'px';

    if (unit === 'pt') {
      // word等转换的pt数据依然需要格式化
      return `${value * FONTSIZE_BIGGER}pt`;
    } else if (unit === 'px' && mark.data.value === 14) {
      // 特殊处理默认字号：稍微放大至11pt(14.667px)
      return `${defaultPx}px`;
    }
  }

  return '';
}

function PlaceholderProvider({
  placeholder = '',
  children
}) {
  const placeholderRef = React__namespace.useRef(placeholder);
  placeholderRef.current = placeholder;
  return /*#__PURE__*/_createElement$e(ContentPlaceholderContext.Provider, {
    value: placeholderRef
  }, children);
}

function Placeholder(props) {
  const [, forceUpdate] = React__namespace.useReducer(c => !c, false);
  const contentPlaceholderRef = useContentPlaceholder(); // 逻辑收敛到Placeholder组件

  const {
    controller,
    node,
    mark,
    children
  } = props;
  const {
    selection,
    isFocused,
    composing
  } = controller.value;
  const focusKey = selection?.focus?.key;
  const {
    config,
    block
  } = mark.data;
  const disable = !config || config.disable || composing;
  const {
    text,
    needWidth,
    focusMode,
    when
  } = config;
  const isDefaultPlaceholder = defaultPlaceholerSymbol === text;
  const showDefaultPlaceholder = React__namespace.useMemo(() => {
    // 这里需要对默认placeholder做一个特殊的处理，默认placeholder是需要关心全文的，而不是上下文就可以了
    if (!isDefaultPlaceholder) return false;
    return when(controller, block);
  }, [controller.value, block, isDefaultPlaceholder, when]);
  const noRender = disable || focusMode && (!isFocused || !focusKey || node.key !== focusKey || controller.value.selection.isExpanded);
  const innerPlaceholderStyle = React__namespace.useMemo(() => {
    const style = needWidth ? innerStyleWithWidth : innerStyle;
    const leave = node.leaves?.length === 1 ? node.leaves[0] : null;
    const size = leave?.marks?.find(m => m.type === 'sz');

    if (size) {
      const fontSize = formatFontSize(size);

      if (fontSize) {
        return { ...style,
          fontSize
        };
      }
    }

    return style;
  }, [node, needWidth]);
  const handlePendingSelectionChange = React__namespace.useCallback(() => {
    if (!disable && focusKey !== controller.value.selection?.focus?.key && (node.key === focusKey || node.key === controller.value.selection?.focus?.key)) {
      forceUpdate();
    }
  }, [controller, focusKey, node, disable]);
  const handlePendingTerminate = React__namespace.useCallback(() => {
    if (node.key !== controller.value.selection?.focus?.key && !noRender) {
      forceUpdate();
    }
  }, [noRender, node, controller]);
  usePendingTerminal(controller.terminal$, handlePendingTerminate);
  useSelectionData(controller.selectionData$, null, handlePendingSelectionChange, []); // 当监听到热区时，也要重渲 placeholder，避免 placeholder 不消失

  useSelectingHots(controller, handlePendingSelectionChange);
  if (noRender || isDefaultPlaceholder && !showDefaultPlaceholder) return /*#__PURE__*/_createElement$e(React__namespace.Fragment, null, children);
  const textContent = typeof text === 'function' ? text(controller, node) : text;
  return /*#__PURE__*/_createElement$e(React__namespace.Fragment, null, children, /*#__PURE__*/_createElement$e("span", {
    onTouchStart: blockEvent,
    onMouseDown: blockEvent,
    style: placeholderStyle,
    "data-testid": "cangjie-placeholder",
    "data-cangjie-placeholder": true
  }, /*#__PURE__*/_createElement$e("span", {
    style: innerPlaceholderStyle
  }, isDefaultPlaceholder ? contentPlaceholderRef?.current : textContent)));
}

function createPlaceholderPlugin(config = {}) {
  const {
    isPlaceholderVisible
  } = config; // HACK: use `Symbol` as placeholder before getting placholder from `Cangjie.Content`.

  const contentPlaceholderConfig = isPlaceholderVisible ? {
    when: isPlaceholderVisible,
    text: defaultPlaceholerSymbol
  } : null;
  let placeholdersConfig = null;

  function decorateNode(node, controller, next) {
    if (!node.isEmpty()) {
      return next();
    } // 读取placeholder配置


    if (!placeholdersConfig) {
      placeholdersConfig = [];

      if (contentPlaceholderConfig) {
        // 内置空白行placeholder逻辑
        placeholdersConfig.push(contentPlaceholderConfig);
      } // @ts-ignore


      const {
        placeholder
      } = controller.handlers;
      placeholder?.forEach(item => {
        if (Array.isArray(item)) {
          placeholdersConfig.push(...item);
        } else {
          // @ts-ignore
          placeholdersConfig.push(item);
        }
      });
      placeholdersConfig = placeholdersConfig.filter(({
        text,
        disable
      }) => !!(text || disable));
    }

    const match = placeholdersConfig.find(({
      when
    }) => when(controller, node));

    if (!match) {
      return next();
    }

    const first = node.getFirstText();
    const last = node.getLastText();

    if (!first || !last) {
      return next();
    }

    const start = TextPoint.create({
      key: first.key,
      offset: 0
    });
    const end = TextPoint.create({
      key: last.key,
      offset: last.text.length
    });
    return [Decoration.create({
      start,
      end,
      mark: Mark.create({
        type: placeholderMarkType,
        data: {
          config: match,
          block: node
        }
      })
    }), ...next()];
  }

  function renderEditable(props, _, next) {
    return /*#__PURE__*/_createElement$e(PlaceholderProvider, props, next());
  }

  function renderMark(props, controller, next) {
    const {
      parent,
      node,
      mark,
      children
    } = props;

    if (mark.type !== placeholderMarkType) {
      return next();
    }

    return /*#__PURE__*/_createElement$e(Placeholder, {
      key: `${parent.key}_placeholder`,
      controller: controller,
      node: node,
      mark: mark
    }, children());
  }

  return {
    decorateNode,
    renderEditable,
    renderMark
  };
}

const hasIntersectionObserver = process.env.NODE_ENV === 'test' || typeof window !== 'undefined' && 'IntersectionObserver' in window;

class IntersectionObserver {
  static getInstance() {
    if (!IntersectionObserver.instance) {
      IntersectionObserver.instance = new IntersectionObserver();
    }

    return IntersectionObserver.instance;
  }

  constructor() {
    this.elementToHandler = void 0;
    this.nativeIO = void 0;

    this.handleIntersectionChange = entries => {
      entries.forEach(entry => {
        const handler = this.elementToHandler.get(entry.target);

        if (handler) {
          handler(entry);
        }
      });
    };

    this.elementToHandler = new WeakMap();
    this.nativeIO = hasIntersectionObserver ? new window.IntersectionObserver(this.handleIntersectionChange) : null;
  }

  observe(element, handler) {
    this.elementToHandler.set(element, handler);
    this.nativeIO?.observe(element);
  }

  unobserve(element) {
    this.elementToHandler.delete(element);
    this.nativeIO?.unobserve(element);
  }

}

IntersectionObserver.instance = null;
function useElementVisibility(elementRef, defaultVisible = false) {
  const [visible, setVisible] = React__namespace.useState(defaultVisible);

  const unobserve = () => {
    if (elementRef.current) {
      IntersectionObserver.getInstance().unobserve(elementRef.current);
    }
  };

  React__namespace.useLayoutEffect(() => {
    if (elementRef.current) {
      IntersectionObserver.getInstance().observe(elementRef.current, entry => setVisible(entry.isIntersecting));
      return unobserve;
    }

    return undefined;
  }, []);
  return [visible, unobserve];
}

const _createElement$d = React__namespace.createElement;
let LazyRenderStrategyType;

(function (LazyRenderStrategyType) {
  LazyRenderStrategyType["LazyLoad"] = "lazyload";
  LazyRenderStrategyType["Pruning"] = "pruning";
})(LazyRenderStrategyType || (LazyRenderStrategyType = {}));

function LazyLoadWrapper({
  node,
  placeholder = null,
  size,
  children
}) {
  const placeholderRef = React__namespace.useRef(null);
  const [visible, unobserve] = useElementVisibility(placeholderRef);

  if (visible) {
    unobserve();
  }

  if (!visible) {
    return /*#__PURE__*/_createElement$d("div", {
      ref: placeholderRef,
      "data-cangjie-key": node.key,
      "data-cangjie-lazy-load": true,
      style: size
    }, placeholder);
  }

  return children;
}

function PruningManager({
  controller,
  children
}) {
  const selectionUpdator = React__namespace.useCallback(({
    range
  }) => {
    if (range.isExpanded) {
      return;
    }

    const point = range.focus;
    const key = point.isTextPoint() ? `${point.key}:0` : point.key;
    const dom = findDOMNodeSafely(key);

    if (dom) {
      showPrunedElements(dom);
    }
  }, [controller]);
  const onHots = React__namespace.useCallback(() => {
    selectionUpdator({
      range: controller.value.selection
    });
  }, [controller, selectionUpdator]);
  useSelectionData(controller.selectionData$, null, selectionUpdator, []);
  useSelectingHots(controller, onHots);
  return children;
}

function PruningWrapper(props) {
  const zoom = useZoom();
  const {
    controller,
    node,
    forceVisible,
    children
  } = props;
  const [isSelected, setIsSelected] = React__namespace.useState(props.isSelected);
  const placeholderRef = React__namespace.useRef(null);
  const [placeholderStyle, setPlaceholderStyle] = React__namespace.useState();
  const [isElementVisible] = useElementVisibility(placeholderRef, true);
  const visible = isElementVisible || isSelected || forceVisible;
  const prevVisible = React__namespace.useRef(visible);
  const onHots = React__namespace.useCallback(() => {
    const {
      selection
    } = controller.value;
    setIsSelected(controller.view.isNodeInRange(node.key, selection));
  }, [controller, node.key]);
  useSelectionData(controller.selectionData$, null, onHots, []);
  useSelectingHots(controller, onHots);
  React__namespace.useLayoutEffect(() => {
    if (prevVisible.current === visible) {
      return;
    }

    if (prevVisible.current && !visible) {
      const placeholder = placeholderRef.current;

      if (!placeholder) {
        return;
      }

      const placeholderClientRect = placeholder.getBoundingClientRect(); // HACK: `IntersectionObserver` cannot detect zero height element in Safari iframe.

      const height = placeholderClientRect.height || 1; // FIX: thrashing
      //   1. When placeholder is visible
      //   2. Remove `display: none` of placeholder
      //   3. Descendant's margin will push placeholder out of view
      // So placeholder will thrash if `margin-top` & `margin-bottom` is incorrect.

      const marginTop = placeholder.previousElementSibling ? placeholderClientRect.top - placeholder.previousElementSibling.getBoundingClientRect().bottom : 0;
      const marginBottom = placeholder.nextElementSibling ? placeholder.nextElementSibling.getBoundingClientRect().top - placeholderClientRect.bottom : 0;
      setPlaceholderStyle({
        height: height / zoom,
        marginTop: marginTop / zoom,
        marginBottom: marginBottom / zoom
      });
    } else {
      // !prevVisible.current && visible
      setPlaceholderStyle(undefined);
    }

    prevVisible.current = visible;
  }, [visible, zoom]);
  return /*#__PURE__*/_createElement$d("div", {
    ref: placeholderRef,
    "data-cangjie-perf-pruning": !visible,
    style: placeholderStyle
  }, /*#__PURE__*/_createElement$d("div", {
    style: placeholderStyle && {
      display: 'none'
    }
  }, children));
}

const DATA_CANGJIE_PERF_PRUNING = 'data-cangjie-perf-pruning';

function showPrunedElements(target) {
  const ancestorsWithPruning = [];
  let ancestor = target;

  while (ancestor) {
    if (ancestor.getAttribute(DATA_CANGJIE_PERF_PRUNING) === 'true') {
      ancestorsWithPruning.push(ancestor);
    }

    ancestor = ancestor.parentElement;
  }

  ancestorsWithPruning.forEach(node => {
    if (node instanceof HTMLElement) {
      node.style.height = '';
      node.style.marginTop = '';
      node.style.marginBottom = '';
      node.setAttribute(DATA_CANGJIE_PERF_PRUNING, 'false');
    }

    const {
      firstElementChild
    } = node;

    if (firstElementChild instanceof HTMLElement) {
      firstElementChild.style.display = '';
    }
  });
}

function createPerfLazyRenderPlugin(config = {}) {
  if (!hasIntersectionObserver) {
    return {};
  }

  function renderEditable(_, controller, next) {
    return /*#__PURE__*/_createElement$d(PruningManager, {
      controller: controller
    }, next());
  }

  function renderNode({
    node,
    isSelected
  }, controller, next) {
    const strategy = controller.query('lazyRenderStrategy', node) || {};
    const {
      type = LazyRenderStrategyType.LazyLoad
    } = strategy;

    if (controller.enableVirtualize) {
      return next();
    }

    if (type === LazyRenderStrategyType.LazyLoad && (strategy.placeholder || strategy.size)) {
      const size = !strategy.size ? undefined : {
        width: strategy.size.width,
        // HACK: `IntersectionObserver` cannot detect zero height element in Safari iframe.
        height: strategy.size.height || 1
      };
      return /*#__PURE__*/_createElement$d(LazyLoadWrapper, {
        node: node,
        placeholder: strategy.placeholder,
        size: size
      }, next());
    }

    if (type === LazyRenderStrategyType.Pruning) {
      return /*#__PURE__*/_createElement$d(PruningWrapper, {
        controller: controller,
        node: node,
        isSelected: isSelected,
        forceVisible: strategy.forceVisible || false
      }, next());
    }

    return next();
  }

  if (config.lazyRenderStrategy) {
    return {
      queries: {
        lazyRenderStrategy: config.lazyRenderStrategy
      },
      renderEditable,
      renderNode
    };
  }

  return {
    renderEditable,
    renderNode
  };
}

createPerfLazyRenderPlugin.factory = (defaultConfig = {}) => (config = {}) => createPerfLazyRenderPlugin({ ...defaultConfig,
  ...config
});

createPerfLazyRenderPlugin.LazyRenderStrategyType = LazyRenderStrategyType;
createPerfLazyRenderPlugin.showPrunedElements = showPrunedElements;
createPerfLazyRenderPlugin.useElementVisibility = useElementVisibility;

const _createElement$c = React__namespace.createElement;
const FirstRenderContext = /*#__PURE__*/React__namespace.createContext(null);

function FirstRenderManager({
  controller,
  isFirstRenderSlice,
  firstFrameSize,
  children
}) {
  const animationFrameSubject = React__namespace.useMemo(() => new Subject(), []);
  const delayRenderSlices = React__namespace.useMemo(() => {
    const delays = new Set();
    let remained = firstFrameSize;
    const document = controller.view;
    document.forEachDescendant(node => {
      if (remained <= 0 && isFirstRenderSlice(node)) {
        delays.add(node.key);
      }

      remained -= 1;
    });
    return delays;
  }, []);
  const context = React__namespace.useMemo(() => ({
    animationFrameSubject,
    delayRenderSlices
  }), [animationFrameSubject, delayRenderSlices]);
  React__namespace.useEffect(() => {
    let raf = null;

    function loop() {
      if (!delayRenderSlices.size) {
        return;
      }

      raf = window.requestAnimationFrame(() => {
        context.animationFrameSubject.next(undefined);
        loop();
      });
    }

    loop();
    return () => {
      if (raf) {
        window.cancelAnimationFrame(raf);
      }
    };
  }, []);
  return /*#__PURE__*/_createElement$c(FirstRenderContext.Provider, {
    value: context
  }, children);
}

function useShouldMount(node) {
  const context = React__namespace.useContext(FirstRenderContext);

  if (!context) {
    throw new Error("The `useShouldMount` hook must be used inside the <FirstRenderManager> component's context.");
  }

  const [shouldMount, setShouldMount] = React__namespace.useState(!context.delayRenderSlices.has(node.key));
  React__namespace.useEffect(() => {
    if (shouldMount) {
      return undefined;
    }

    const subscription = context.animationFrameSubject.subscribe(() => {
      subscription.unsubscribe();
      context.delayRenderSlices.delete(node.key);
      setShouldMount(true);
    });
    return subscription.unsubscribe;
  }, []);
  return shouldMount;
}

function FirstRenderSlice({
  node,
  children
}) {
  const shouldMount = useShouldMount(node);
  return shouldMount ? children : null;
}

function createPerfFirstRenderPlugin(config) {
  const {
    isFirstRenderSlice,
    firstFrameSize = 1000
  } = config;

  function renderEditable(_, controller, next) {
    return /*#__PURE__*/_createElement$c(FirstRenderManager, {
      controller: controller,
      isFirstRenderSlice: isFirstRenderSlice,
      firstFrameSize: firstFrameSize
    }, next());
  }

  function renderNode(props, _, next) {
    const {
      node
    } = props;

    if (!isFirstRenderSlice(node)) {
      return next();
    }

    return /*#__PURE__*/_createElement$c(FirstRenderSlice, {
      node: node
    }, next());
  }

  return {
    renderEditable,
    renderNode
  };
}

createPerfFirstRenderPlugin.factory = defaultConfig => config => createPerfFirstRenderPlugin({ ...defaultConfig,
  ...config
});

const Context = /*#__PURE__*/React__default["default"].createContext(null);
/**
 * @deprecated
 */

function useSelectionContext() {
  const context = React__default["default"].useContext(Context);

  if (!context) {
    throw new Error('SelectionContext not found.');
  }

  return context;
}

/**
 * @packageDocumentation
 * @module Hooks
 */

function updatePosition(caret, point, selectionContext, zoom = 1, isHanging = false) {
  const root = caret.closest(`[${Selector.content}]`) || undefined;
  const {
    relativeRect: nodeRect
  } = selectionContext;
  const relativeRect = nodeRect || caret.parentElement?.getBoundingClientRect();
  let position = null;

  if (point.isEdgePoint()) {
    position = findEdgePointPosition(point, root);
  } else {
    const preferredEdge = isHanging ? 'start' : 'end';
    position = findTextPointPosition(point, preferredEdge, root);
  }

  if (!position || !relativeRect) {
    return;
  }

  const {
    clientTop,
    clientLeft,
    height
  } = position; // 有相对定位的容器就以提供的相对定位为准，否则以光标的父节点为准

  const relativeLeft = nodeRect ? nodeRect.left - nodeRect.scrollLeft : relativeRect.left;
  const left = clientLeft - relativeLeft;
  const top = clientTop - relativeRect.top;
  caret.style.top = `${top / zoom}px`;
  caret.style.left = point.isTextPoint() ? `${left / zoom - CURSOR_WIDTH / 2}px` : `${left / zoom + CURSOR_WIDTH / 2}px`;
  caret.style.height = `${height / zoom}px`;
}
/**
 * @deprecated
 * 已废弃
 */


function useOffsetPosition(caretRef, pointStr, where, zoom = 1, isHanging = false, deps = []) // 其他会引起光标位置变化的依赖
{
  const selectionContext = useSelectionContext();
  React__namespace.useLayoutEffect(() => {
    const caret = caretRef.current;

    if (!caret || !pointStr) {
      return;
    }

    const offsetSeperatorIndex = pointStr?.lastIndexOf('-');
    const key = pointStr?.substring(0, offsetSeperatorIndex);

    if (!key) {
      return;
    }

    let point;

    if (typeof where === 'number') {
      point = TextPoint.create({
        key,
        offset: where
      });
    } else {
      point = EdgePoint.create({
        key,
        edge: where
      });
    }

    updatePosition(caret, point, selectionContext, zoom, isHanging);
  }, [pointStr, where, zoom, isHanging, caretRef, selectionContext, ...deps]);
}

const THROTTLE_TIME_RESIZE$1 = 300;
/**
 * 在 ref 上层对应的 leaf block 尺寸变动时，调用 updator。内置了 throttle。
 */

function useLeafBlockResizer(ref, updator, deps) {
  React__namespace.useEffect(() => {
    const node = ref.current?.closest(`[${Selector.leafBlock}]`);

    if (!node) {
      return undefined;
    }

    const callback = lodash.throttle(() => {
      updator();
    }, THROTTLE_TIME_RESIZE$1); // @ts-ignore

    if (typeof ResizeObserver !== 'undefined') {
      // @ts-ignore
      const observer = new ResizeObserver(callback);
      observer.observe(node);
      return () => {
        callback.cancel();
        observer.unobserve(node);
      };
    }

    window.addEventListener('resize', callback);
    return () => {
      callback.cancel();
      window.removeEventListener('resize', callback);
    };
  }, deps || []);
}

/**
 * 获取用户数据
 * @param node 
 * @param key 
 * @returns 
 */

function useUserData(node, key) {
  const controller = useControllerStatic();
  const {
    uid
  } = controller;
  const initValue = controller.userData.get(node, key);
  const {
    uuid
  } = node.data;
  const [data, setData] = React.useState(initValue);
  React.useEffect(() => {
    if (uid && uuid) {
      // 订阅用户数据 update$ 更新（uid 和 uuid 存在的情况，存储在 document.data）
      const sub = controller.userData.update$.subscribe(event => {
        const {
          uuid: euuid
        } = event;

        if (euuid === uuid || euuid === '*') {
          // 同一个节点，用户数据发生改变
          const cNode = controller.value.document.getNode(node.key.split('-')[0]);

          if (cNode && Element$1.isElement(cNode)) {
            const nextData = controller.userData.get(cNode, key);
            setData(nextData);
          }
        }
      });
      return () => sub.unsubscribe();
    } else {
      // 观察节点 node 变化（uid 或 uuid 不存在的情况，存储在 node.data）
      const nextData = node.data?.[key];

      if (nextData !== data) {
        setData(nextData);
      }

      return lodash.noop;
    }
  }, [controller, node, uuid, uid, key, data]);
  return data;
}

/**
 * 获得所在分组的数据 
 * @param node 
 * @param selector 
 * @param defaultValue 
 * @returns 
 * 
 * @example
 * ```tsx
 * const Element = props => {
 *   const hidden = useGroupData(groups => groups.some(group => group.hidden));
 * 
 *   // ...
 * }
 * ```
 */
function useGroupData(node, selector, defaultValue) {
  let finalNode = node;
  const controller = useControllerStatic(); // 兼容老 Group 的代码

  const legacyGroupIndex = node.key.indexOf('-group');

  if (legacyGroupIndex > -1) {
    const nodeKey = node.key.split('-group')[0];
    const originalNode = controller.view.getNode(nodeKey);

    if (originalNode) {
      finalNode = originalNode;
    }
  }

  const groups = controller.groupManager.getNodeGroups(finalNode);
  const selectorRef = React.useRef(selector);
  selectorRef.current = selector; // default state 就要取实际值，否则数据有延迟，有延迟就对虚拟化不友好

  const defaultData = selectorRef.current(groups) || defaultValue;
  const [data, setData] = React.useState(defaultData); // 响应上游的分组信息变更

  React.useEffect(() => {
    let sub = null;

    if (finalNode && Element$1.isElement(finalNode)) {
      sub = controller.groupManager.groups$.subscribe(groupsMap => {
        const groups = controller.groupManager.getNodeGroups(finalNode);
        setData(selectorRef.current(groups));
      });
    }

    return () => {
      if (sub) {
        sub.unsubscribe();
      }
    };
  }, [controller, finalNode]);
  return data;
}

/**
 *
 * If the HTML node is hide behind a horizontal scroll container, make it
 * visible
 */
function makeElementVisible(
/**
 * dom node
 */
domNode,
/**
 * which edge should be visible.
 * options: start edge | end edge | all edges
 */
edge,
/**
 * extra space added to the domNode's edge
 */
extra) {
  const {
    left,
    right
  } = domNode.getBoundingClientRect();
  let leftEdge = edge === 'end' ? right : left;
  let rightEdge = edge === 'start' ? left : right;
  leftEdge -= extra;
  rightEdge += extra;
  let node = domNode;

  while (node && !node.getAttribute(Selector.content)) {
    if (node.scrollWidth > node.offsetWidth) {
      const rect = node.getBoundingClientRect();
      const offsetLeft = leftEdge - rect.left;
      const offsetRight = rightEdge - rect.right;

      if (offsetLeft < 0 || offsetRight > 0) {
        const horizonOffset = offsetLeft < 0 ? offsetLeft : offsetRight;
        node.scrollLeft += horizonOffset;
        break;
      }
    }

    node = node.parentElement;
  }
}

/**
 * @packageDocumentation
 * @ignore
 */
// PC: no prefix/surfix by default
let EMPTY_PREFIX = '';
let EMPTY_SURFIX = '';

if (IS_IOS) {
  // iOS / Mac - Safari: will ignore the only space in textarea.
  EMPTY_PREFIX = '\n.';
  EMPTY_SURFIX = ' \n';
} else if (IS_MOBILE) {
  // Android: will toggle between uppercase and lowercase
  // while deleting with dot as the only character in textarea.
  EMPTY_PREFIX = ' '; // Android: Arrow buttons will not trigger any keyboard event when caret is at the edge of textarea value
  // eg1. textarea value is: ' <cursor />', keydown event will not triggered by ArrowRight/ArrowDown
  // eg2. textarea value is: '<cursor />', keydown event will not triggered by ArrowRight/ArrowDown/ArrowUp/ArrowLeft

  EMPTY_SURFIX = ' ';
}

const IS_TOUCH_MOBILE = IS_MOBILE || IS_TOUCH_DEVICE;
const getEmptyValue = t => `${EMPTY_PREFIX}${t}${EMPTY_SURFIX}`;
const EMPTY_TEXT_AREA_VALUE = getEmptyValue('');
const CHARACTERS_LENGTH_AFTER_USER_INPUT = EMPTY_SURFIX.length;

function resetTextAreaValue(textAreaRef, textAreaCacheRef) {
  textAreaCacheRef.current = EMPTY_TEXT_AREA_VALUE;
  const defaultCaretPosition = EMPTY_TEXT_AREA_VALUE.length - CHARACTERS_LENGTH_AFTER_USER_INPUT; // BACKGROUND:
  //   Android 中，点击非工具栏区域 blur 后，再 focus 回编辑器
  //   会出现 textarea.value === ' ' && textarea.selectionStart === 0 的情况
  //   导致无法删除文字，输入文字后会吞掉光标前一个字

  if (textAreaRef.current && (textAreaRef.current.value !== EMPTY_TEXT_AREA_VALUE || textAreaRef.current.selectionStart !== defaultCaretPosition || textAreaRef.current.selectionEnd !== defaultCaretPosition)) {
    textAreaRef.current.value = EMPTY_TEXT_AREA_VALUE;
    textAreaRef.current.selectionStart = defaultCaretPosition;
    textAreaRef.current.selectionEnd = defaultCaretPosition;
  }
}

function diffTextAreaValue(prevTextAreaValue, textAreaValue) {
  const prevValueCaretPosition = prevTextAreaValue.length - CHARACTERS_LENGTH_AFTER_USER_INPUT;
  const currentValueCaretPosition = textAreaValue.length - CHARACTERS_LENGTH_AFTER_USER_INPUT;
  const minValueCaretPosition = Math.min(prevValueCaretPosition, currentValueCaretPosition);
  let leftDiffOffset = 0;

  while (leftDiffOffset < minValueCaretPosition) {
    if (prevTextAreaValue[leftDiffOffset] !== textAreaValue[leftDiffOffset]) {
      break;
    }

    leftDiffOffset += 1;
  }

  return {
    range: [leftDiffOffset, prevValueCaretPosition],
    text: textAreaValue.slice(leftDiffOffset, currentValueCaretPosition)
  };
}

function insertText(controller, rawData) {
  // Safari 空格会发出 CharCode 为 160 的空格，这里抹平浏览器差异
  // convert <CharCode 160: &nbsp;> to <CharCode 32: space>
  const data = rawData.replace(/\xA0/g, ' ');
  const cangjieInput = CangjieInputEvent({
    type: 'insertText',
    data
  });
  controller.run('onCangjieInput', cangjieInput);
}

function removeText(controller, data) {
  controller.run('onCangjieInput', CangjieInputEvent({
    type: 'deleteContentBackward',
    data
  }));
}

function updateComposing(controller, composing) {
  controller.run('onCangjieComposingChange', composing);
}

function useInputDetector(controller, textAreaRef) {
  const {
    selection,
    isBlurred
  } = controller.value;
  const isComposing = React__namespace.useRef(false);
  const prevSelectionAfterInput = React__namespace.useRef(null);
  const resetTimer = React__namespace.useRef(null);
  const composingData = React__namespace.useRef('');
  const prevTextAreaValue = React__namespace.useRef(EMPTY_TEXT_AREA_VALUE);
  const reset = React__namespace.useCallback(() => {
    resetTextAreaValue(textAreaRef, prevTextAreaValue);
  }, [textAreaRef]);
  React__namespace.useEffect(() => {
    // 仅当选区的位置变化才需要 reset textarea 结束 composing 状态，不应受其它因素影响
    // eg. 分页模式下用输入法输入，首字母输入后仅 selection.data.isHanging 会变为 true（https://code.aone.alibaba-inc.com/alidocs/we-word/codereview/7664706）
    //     这种情况下只影响选区渲染的位置，不应该打断输入
    if (prevSelectionAfterInput.current?.plainViewKey === selection.plainViewKey) {
      return;
    } // 分页模式下，会将 dataSelection 转为 viewSelection，并将原始 selection 放到 data 中
    // 因此可以通过 dataSelection 来判断是否为同一个位置，避免因排版将 composing 部分放到下一行导致选区变化，从而中断输入法
    // eg.
    //    Line 1: xxxxxxxxxxx<cursor/>[n]    <-- before：输入法输入时，光标和 composing 部分在行尾
    //    Line 2: <cursor/>[ni]xxxxxxxxxxx   <-- after：输入法输入时，光标和 composing 部分被放到下一行首
    //    此时，不应执行 reset


    const dataSelection = selection.data.dataSelection;
    const prevDataSelection = prevSelectionAfterInput.current?.data.dataSelection;

    if (isComposing && dataSelection && prevDataSelection && prevDataSelection.plainViewKey === dataSelection.plainViewKey) {
      return;
    } // BACKGROUND:
    // iOS 下，reset() 中设置 selectionStart/selectionEnd 的行为会造成 textarea 自动 focus
    // 导致编辑器的 autoFocus 配置失效
    // 因此需要人为控制 blur 状态下不执行 reset


    if (isBlurred) {
      return;
    }

    reset();
  }, [reset, selection, isBlurred]);
  React__namespace.useEffect(() => {
    return () => {
      resetTimer.current && clearTimeout(resetTimer.current);
    };
  }, []);
  return React__namespace.useMemo(() => ({
    reset,

    onChange(event) {
      let {
        value
      } = event.target; // Safari 空格会发出 CharCode 为 160 的空格，这里抹平浏览器差异
      // 避免 diffTextAreaValue 时 offset 算错

      value = value.replace(/\xA0/g, ' ');
      const {
        range,
        text
      } = diffTextAreaValue(prevTextAreaValue.current, value);
      const [rangeStartIndex, rangeEndIndex] = range;
      let mismatchLength = rangeEndIndex - rangeStartIndex;
      const composing = composingData.current; // console.info(`onchange, value=[${value}], range=${range}, text=[${text}], composing=[${composing}]`);

      if (mismatchLength > 0 && composing.length > 0) {
        const delLength = Math.min(mismatchLength, composing.length);
        composingData.current = composing.slice(0, composing.length - delLength);
        mismatchLength -= delLength;
        updateComposing(controller, composingData.current);
      }

      if (mismatchLength > 0) {
        const data = prevTextAreaValue.current.slice(rangeStartIndex, rangeStartIndex + mismatchLength);
        removeText(controller, data);
      }

      let newText = text;

      if (isComposing.current && newText) {
        composingData.current += newText;
        updateComposing(controller, composingData.current);
        newText = '';
      }

      if (newText) {
        insertText(controller, newText);
      }

      if (value.length < EMPTY_TEXT_AREA_VALUE.length) {
        mismatchLength <= 0 && removeText(controller, ' ');
        composingData.current = '';
        resetTimer.current = setTimeout(reset, 0);
      }

      prevTextAreaValue.current = value;
      prevSelectionAfterInput.current = controller.value.selection;
    },

    onCompositionStart() {
      isComposing.current = true;
      prevSelectionAfterInput.current = controller.value.selection;
    },

    onCompositionEnd() {
      isComposing.current = false;

      if (composingData.current) {
        insertText(controller, composingData.current);
        updateComposing(controller, '');
        composingData.current = '';
      }

      prevSelectionAfterInput.current = controller.value.selection;
    },

    // 返回值意义: shouldContinue other keydown handlers
    onKeyDown(event) {
      if (IS_TOUCH_MOBILE && (hotkeys.isCopy(event) || hotkeys.isCut(event))) {
        // Background: iOS + Safari + 外接键盘的情况下，用中文输入法输入 cmd + C 等快捷键，会出现
        //             keydown 后触发 compositionStart -> onChange 的情况
        // Hack: https://stackoverflow.com/questions/63204395/how-can-i-reliably-cancel-a-compositionstart-event
        // Ref: https://alidocs.dingtalk.com/i/nodes/2m0X9MnDA3QJwww90al4JqklwBK7RezY
        if (IS_IPAD) {
          controller.run('onCangjieBlur');
          setTimeout(() => controller.run('onCangjieFocus'), 100);
        }

        return true;
      }

      if (IS_SAFARI) {
        // BACKGROUND: Safari 下输入法输入 abc，然后逐个删除，到最后会把 abc 之前的文字删掉
        // 正常情况下，事件触发顺序为 onKeydown -> onChange -> onCompositionEnd；
        // 而 Safari 下是 onChange -> onCompositionEnd -> onKeydown，标志位就失去了参考价值
        // http://gwiki.cn/2019/02/js%E7%9A%84%E7%BC%96%E8%BE%91%E4%BA%8B%E4%BB%B6
        // https://developer.mozilla.org/en-US/docs/Web/Events/keydown
        // 利用 event 事件信息，使输入法处理过程中，忽略 onKeydown
        // @ts-ignore
        if (event.isComposing || event.keyCode === 229) {
          return false;
        }
      }

      return !isComposing.current || !hotkeys.isCompose(event) && !hotkeys.isUndo(event) && !hotkeys.isRedo(event);
    }

  }), [controller, textAreaRef]);
}

/* eslint-disable react/no-find-dom-node */
const MULTIPLE_CLICK_DELAY = 500;
const TAP_HOLD_DELAY = 600; // 方向键需要快速响应，目前暂未发现明显问题

const CARET_MOVE_GAP_TIME = 0;
const MULTIPLE_CLICK_RANGE = 10;

function getWordSelection(controller, target, x, y) {
  const r = caretRangeFromTargetAndCoord(target, x, y, controller);

  if (!r) {
    return null;
  }

  const {
    document
  } = controller.value;
  return Selection.selectWordAtPoint(document, r.anchor);
} // get a new selection at Line Start or Line End of the current selection.


function getSelectionAtLine(where, controller, selection) {
  const {
    value
  } = controller;
  const {
    document
  } = value;

  if (!selection) {
    return null;
  }

  const isStart = where === 'start';
  const {
    focus,
    isHanging
  } = selection;

  if (focus.isEdgePoint()) {
    const edge = isStart ? EdgePoint.BEFORE : EdgePoint.AFTER;
    const anchor = EdgePoint.create({
      key: focus.key,
      edge
    });
    return Selection.create({
      anchor,
      focus: anchor
    });
  }

  let range = null; // selection's range

  let blockDomNode = null; // selection's closest block node

  try {
    const block = document.getClosestBlock(focus.key);
    range = findDOMRange(selection, controller);

    if (block) {
      blockDomNode = findDOMNode(block.key);
    }
  } catch (_) {
    return null;
  }

  if (!range || !blockDomNode) {
    return null;
  } // selection's rect


  const rects = range.getClientRects();

  if (!rects.length) {
    return null;
  }

  let rect = rects[isHanging ? rects.length - 1 : 0];
  const edgeRects = isPointAtEdge(focus) ? findRectsInEdgePoint(focus) : [];

  if (edgeRects && edgeRects.length) {
    rect = edgeRects[isHanging ? edgeRects.length - 1 : 0];
  } // selection's closest block's rect


  makeElementVisible(blockDomNode, where, CURSOR_WIDTH);
  const blockRect = blockDomNode.getBoundingClientRect(); // target selection's position

  const position = {
    x: where === 'start' ? blockRect.left + 1 : blockRect.right - 1,
    y: rect.top + rect.height / 2
  };
  const newRange = caretRangeFromTargetAndCoord(blockDomNode, position.x, position.y, controller);

  if (!newRange) {
    return null;
  }

  let {
    anchor: point
  } = newRange; // if the target point is inside a void element, take the next point

  const parent = document.getParent(point.key);

  if (parent && controller.query('isVoid', parent)) {
    point = controller.query(pointAtDistance, point, isStart ? -1 : 1);
  }

  const newSelection = Selection.create({
    anchor: point,
    focus: point
  });
  return newSelection;
}

function shouldSelectOnRightClick(targetPoint, controller) {
  const {
    selection,
    document
  } = controller.value;

  if (!selection || selection.isCollapsed) {
    return true;
  }

  const {
    start,
    end
  } = selection.sort(document);
  const rangeStart = Selection.create({
    anchor: targetPoint,
    focus: start
  });
  const rangeEnd = Selection.create({
    anchor: end,
    focus: targetPoint
  });
  const isBeforeStart = rangeStart.isExpanded && rangeStart.isForward(document);
  const isAfterEnd = rangeEnd.isExpanded && rangeEnd.isForward(document);
  return isBeforeStart || isAfterEnd;
}

function useSelectionCalculator(controller, textAreaRef, scrollableContainerRef) {
  const isJustTapHold = React__namespace.useRef(false);
  const tapHoldTimer = React__namespace.useRef(null);
  const outsideScoller = React__namespace.useRef(null);
  const lastSingleClick = React__namespace.useRef({
    time: 0,
    x: 0,
    y: 0
  });
  const lastDoubleClick = React__namespace.useRef({
    time: 0,
    x: 0,
    y: 0
  });
  const lastCaretMoveTime = React__namespace.useRef(0);
  const prevSelectionRef = React__namespace.useRef(null);
  const onCangjieSelect = React__namespace.useCallback((selection, trigger) => {
    const {
      composing,
      isFocused
    } = controller.value;

    if (composing && selection.isExpanded) {
      return;
    }

    if (!isFocused) {
      controller.run('onCangjieFocus');
    }

    const newSelection = selection.marks === null ? selection : selection.set('marks', null);
    const subtypeTriggerMap = {
      selectStart: 'focusText',
      selecting: 'selectText',
      selectAll: 'selectAll'
    };

    if (!trigger || !subtypeTriggerMap[trigger] || equal__default["default"](prevSelectionRef.current, newSelection)) {
      // 需要 delay 丢弃的 perf 事件
      controller.perfDrop(PerfType.selection);
    }

    prevSelectionRef.current = newSelection;
    return controller.run('onCangjieSelect', CangjieSelectEvent({
      selection: newSelection,
      trigger: trigger || 'userSelect'
    }));
  }, [controller]);

  const moveUpward = () => {
    const now = Date.now();
    const isGapTimeTooShort = now - lastCaretMoveTime.current < CARET_MOVE_GAP_TIME;

    if (isGapTimeTooShort) {
      return;
    }

    lastCaretMoveTime.current = now;
    const newRange = controller.query(getUpsideRange);

    if (!newRange) {
      return;
    }

    onCangjieSelect(newRange, SelectionTrigger.MoveUpward);
  };

  const moveDownward = () => {
    const now = Date.now();
    const isGapTimeTooShort = now - lastCaretMoveTime.current < CARET_MOVE_GAP_TIME;

    if (isGapTimeTooShort) {
      return;
    }

    lastCaretMoveTime.current = now;
    const newRange = controller.query(getDownsideRange);

    if (!newRange) {
      return;
    }

    onCangjieSelect(newRange, SelectionTrigger.MoveDownward);
  };

  const moveBackward = () => {
    const {
      document,
      selection
    } = controller.value;

    if (selection.isExpanded) {
      const isAtEdge = isPointAtEdge(selection.getStart(document));
      onCangjieSelect(selection.moveToStart(document).setHanging(isAtEdge));
      return;
    }

    const isProceeded = shoudStopInsideVoid(controller, 'moveBackward');

    if (isProceeded) {
      return;
    }

    const isAtEdge = isPointAtEdge(selection.anchor);

    if (isAtEdge && selection.isHanging) {
      onCangjieSelect(selection.setHanging(false));
      return;
    }

    const now = Date.now();
    const isGapTimeTooShort = now - lastCaretMoveTime.current < CARET_MOVE_GAP_TIME;

    if (isGapTimeTooShort) {
      return;
    }

    const newSelection = selection.moveAnchorBackward(1, movePointBackward(controller, lodash.curry.placeholder, lodash.curry.placeholder, 'offset')).moveToAnchor();
    const isNextPointAtEdge = isPointAtEdge(newSelection.anchor);
    lastCaretMoveTime.current = now;
    onCangjieSelect(newSelection.setHanging(isNextPointAtEdge), SelectionTrigger.MoveBackward);
  };

  const moveForward = () => {
    const {
      document,
      selection
    } = controller.value;

    if (selection.isExpanded) {
      onCangjieSelect(selection.moveToEnd(document));
      return;
    }

    const isProceeded = shoudStopInsideVoid(controller, SelectionTrigger.MoveForward);

    if (isProceeded) {
      return;
    }

    const isAtEdge = isPointAtEdge(selection.anchor);

    if (isAtEdge && !selection.isHanging) {
      onCangjieSelect(selection.setHanging(true));
      return;
    }

    const now = Date.now();
    const isGapTimeTooShort = now - lastCaretMoveTime.current < CARET_MOVE_GAP_TIME;

    if (isGapTimeTooShort) {
      return;
    }

    lastCaretMoveTime.current = now;
    onCangjieSelect(selection.moveAnchorForward(1, movePointForward(controller, lodash.curry.placeholder, lodash.curry.placeholder, 'offset')).moveToAnchor(), SelectionTrigger.MoveForward);
  };

  const handleNativeSelectionChange = () => {
    if (!textAreaRef.current || document.activeElement !== textAreaRef.current) {
      return;
    } // iOS - Voice Input will try to select all words when finished
    // ref: https://aone.alibaba-inc.com/v2/project/585561/bug/32431619


    if (textAreaRef.current.selectionStart !== textAreaRef.current.selectionEnd) {
      return;
    } // Detect users move selection by external keyboard arrow keys under iOS@<13
    // Ref: https://bugs.webkit.org/show_bug.cgi?id=149054


    const defaultCaretPosition = textAreaRef.current.value.length - CHARACTERS_LENGTH_AFTER_USER_INPUT;
    const newCaretPosition = textAreaRef.current.selectionStart;

    if (IS_IOS) {
      // Mobile 3rd IME will delete to beginning when choosing english suggestion
      // In this case both `newCaretPosition` and `defaultCaretPosition` is 0
      // We handle this case by adding `defaultCaretPosition !== 0`
      if (newCaretPosition === 0 && defaultCaretPosition !== 0) {
        moveUpward();
      } else if (newCaretPosition === textAreaRef.current.value.length) {
        moveDownward();
      } else if (newCaretPosition - defaultCaretPosition < 0) {
        moveBackward();
      } else if (newCaretPosition - defaultCaretPosition > 0) {
        moveForward();
      }
    } // Reset selection to end of textarea while users change it.
    // e.g. Users move selection by 3D touch.
    // Note: selectionStart is offset of characters and works fine with emoji.


    if (textAreaRef.current.selectionStart !== defaultCaretPosition) {
      textAreaRef.current.selectionStart = defaultCaretPosition;
    }

    if (textAreaRef.current.selectionEnd !== defaultCaretPosition) {
      textAreaRef.current.selectionEnd = defaultCaretPosition;
    }
  };

  React__namespace.useEffect(() => {
    if (IS_MOBILE) {
      document.addEventListener('selectionchange', handleNativeSelectionChange);
      return () => {
        document.removeEventListener('selectionchange', handleNativeSelectionChange);
      };
    }

    return undefined;
  }, [controller]);
  React__namespace.useEffect(() => {
    return () => {
      if (outsideScoller.current) {
        outsideScoller.current.cancel();
        outsideScoller.current = null;
      }
    };
  }, [controller]);
  return React__namespace.useMemo(() => ({
    onKeyDown(event) {
      const {
        value,
        readOnly
      } = controller;
      const {
        document,
        selection
      } = value;

      if (!selection) {
        return;
      }

      const now = Date.now();
      const isGapTimeTooShort = now - lastCaretMoveTime.current < CARET_MOVE_GAP_TIME;

      if (hotkeys.isSelectAll(event)) {
        controller.perfStart({
          type: PerfType.selection,
          subtype: 'selectAll'
        });
        event.preventDefault();
        onCangjieSelect(selection.moveToRangeOfNode(document, controller), SelectionTrigger.SelectAll);
        return;
      }

      if (hotkeys.isMoveBackward(event)) {
        event.preventDefault();
        moveBackward();
        return;
      }

      if (hotkeys.isMoveForward(event)) {
        event.preventDefault();
        moveForward();
        return;
      }

      if (hotkeys.isMoveUpward(event)) {
        if (readOnly && selection.isCollapsed) {
          return;
        }

        event.preventDefault();
        moveUpward();
        return;
      }

      if (hotkeys.isMoveDownward(event)) {
        if (readOnly && selection.isCollapsed) {
          return;
        }

        event.preventDefault();
        moveDownward();
        return;
      }

      if (hotkeys.isMoveWordBackward(event)) {
        event.preventDefault();

        if (isGapTimeTooShort) {
          return;
        }

        lastCaretMoveTime.current = now;
        onCangjieSelect(selection.move(movePointWordBackward(controller, 'focus')).moveToFocus());
        return;
      }

      if (hotkeys.isMoveWordForward(event)) {
        event.preventDefault();

        if (isGapTimeTooShort) {
          return;
        }

        lastCaretMoveTime.current = now;
        onCangjieSelect(selection.move(movePointWordForward(controller, 'focus')).moveToFocus());
        return;
      }

      if (hotkeys.isMoveLineBackward(event)) {
        event.preventDefault();
        const range = getSelectionAtLine('start', controller, selection);

        if (range) {
          const isAtEdge = isPointAtEdge(range.anchor);
          onCangjieSelect(range.setHanging(isAtEdge));
        }

        return;
      }

      if (hotkeys.isMoveLineForward(event)) {
        event.preventDefault();
        const range = getSelectionAtLine('end', controller, selection);

        if (range) {
          onCangjieSelect(range);
        }

        return;
      }

      if (hotkeys.isMoveToDocumentStart(event)) {
        event.preventDefault();
        onCangjieSelect(selection.moveToStartOfDocument(controller));
        return;
      }

      if (hotkeys.isMoveToDocumentEnd(event)) {
        event.preventDefault();
        onCangjieSelect(selection.moveToEndOfDocument(controller));
        return;
      }

      if (hotkeys.isExtendBackward(event)) {
        event.preventDefault();

        if (isGapTimeTooShort) {
          return;
        }

        lastCaretMoveTime.current = now;
        onCangjieSelect(selection.moveFocusBackward(1, movePointBackward(controller, lodash.curry.placeholder, lodash.curry.placeholder, 'offset')));
        return;
      }

      if (hotkeys.isExtendForward(event)) {
        event.preventDefault();

        if (isGapTimeTooShort) {
          return;
        }

        lastCaretMoveTime.current = now;
        onCangjieSelect(selection.moveFocusForward(1, movePointForward(controller, lodash.curry.placeholder, lodash.curry.placeholder, 'offset')));
        return;
      }

      if (hotkeys.isExtendUpward(event)) {
        event.preventDefault();

        if (isGapTimeTooShort || !selection) {
          return;
        }

        lastCaretMoveTime.current = now;
        const point = getUpsidePoint(controller, selection.focus, selection.isHanging);
        const {
          focus,
          anchor
        } = selection;
        onCangjieSelect(Selection.create({
          anchor,
          focus: point || focus.moveToStartOfNode(document)
        }));
        return;
      }

      if (hotkeys.isExtendDownward(event)) {
        event.preventDefault();

        if (isGapTimeTooShort || !selection) {
          return;
        }

        lastCaretMoveTime.current = now;
        const {
          focus,
          anchor,
          isHanging
        } = selection;
        const point = getDownsidePoint(controller, focus, isHanging);
        onCangjieSelect(Selection.create({
          anchor,
          focus: point || focus.moveToEndOfNode(document)
        }));
        return;
      }

      if (hotkeys.isExtendWordBackward(event)) {
        event.preventDefault();

        if (isGapTimeTooShort) {
          return;
        }

        lastCaretMoveTime.current = now;
        onCangjieSelect(selection.move(movePointWordBackward(controller, 'focus')));
        return;
      }

      if (hotkeys.isExtendWordForward(event)) {
        event.preventDefault();

        if (isGapTimeTooShort) {
          return;
        }

        lastCaretMoveTime.current = now;
        onCangjieSelect(selection.move(movePointWordForward(controller, 'focus')));
        return;
      }

      if (hotkeys.isExtendLineBackward(event)) {
        event.preventDefault();
        const range = getSelectionAtLine('start', controller, selection);

        if (range) {
          onCangjieSelect(Selection.create({
            anchor: selection.anchor,
            focus: range.focus
          }));
        }

        return;
      }

      if (hotkeys.isExtendToDocumentStart(event)) {
        event.preventDefault();
        onCangjieSelect(selection.moveFocusToStartOfNode(document, controller));
        return;
      }

      if (hotkeys.isExtendToDocumentEnd(event)) {
        event.preventDefault();
        onCangjieSelect(selection.moveFocusToEndOfNode(document, controller));
        return;
      }

      if (hotkeys.isExtendLineForward(event)) {
        event.preventDefault();
        const range = getSelectionAtLine('end', controller, selection);

        if (range) {
          onCangjieSelect(Selection.create({
            anchor: selection.anchor,
            focus: range.focus
          }));
        }
      }
    },

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onKeyUp(event) {
      lastCaretMoveTime.current = 0;
    },

    onMultipleClick(event) {
      const now = Date.now();

      if (event.button === 2) {
        return;
      }

      if (now - lastDoubleClick.current.time < MULTIPLE_CLICK_DELAY && Math.abs(event.clientY - lastDoubleClick.current.y) < MULTIPLE_CLICK_RANGE && Math.abs(event.clientX - lastDoubleClick.current.x) < MULTIPLE_CLICK_RANGE) {
        lastDoubleClick.current = {
          time: 0,
          x: 0,
          y: 0
        };
        lastSingleClick.current = {
          time: 0,
          x: 0,
          y: 0
        };
        const range = caretRangeFromTargetAndCoord(event.target, event.clientX, event.clientY, controller);

        if (!range) {
          return;
        }

        const {
          value
        } = controller;
        const {
          document,
          selection
        } = value;
        const anchorBlock = document.getClosestBlock(range.anchor.key);

        if (selection && anchorBlock) {
          onCangjieSelect(selection.moveToRangeOfNode(anchorBlock, controller), SelectionTrigger.MultipleClick);
        }

        return;
      }

      if (controller.query('isQuickPreview')) {
        return;
      }

      if (now - lastSingleClick.current.time > MULTIPLE_CLICK_DELAY || Math.abs(event.clientY - lastSingleClick.current.y) > MULTIPLE_CLICK_RANGE || Math.abs(event.clientX - lastSingleClick.current.x) > MULTIPLE_CLICK_RANGE) {
        lastSingleClick.current = {
          time: now,
          x: event.clientX,
          y: event.clientY
        };
        lastDoubleClick.current = {
          time: 0,
          x: event.clientX,
          y: event.clientY
        };
        return;
      }

      lastSingleClick.current = {
        time: 0,
        x: 0,
        y: 0
      };
      lastDoubleClick.current = {
        time: now,
        x: event.clientX,
        y: event.clientY
      };
      const range = getWordSelection(controller, event.target, event.clientX, event.clientY);

      if (range) {
        onCangjieSelect(range, SelectionTrigger.MultipleClick);
      }
    },

    onSelectStart(event) {
      let isSelecting = false;

      function onSelectUpdate(e) {
        controller.perfStart({
          type: PerfType.selection,
          subtype: 'selectText'
        });

        if (!scrollableContainerRef.current) {
          controller.perfDrop(PerfType.selection);
          return;
        }

        outsideScoller.current && outsideScoller.current(e);
        const {
          target
        } = e;
        const x = e.clientX;
        const y = e.clientY;

        if (!target) {
          controller.perfDrop(PerfType.selection);
          return;
        }

        const range = caretRangeFromTargetAndCoord(target, x, y, controller);

        if (!range) {
          controller.perfDrop(PerfType.selection);
          return;
        }

        const {
          selection
        } = controller.value;

        if (!selection || equal__default["default"](range, selection)) {
          controller.perfDrop(PerfType.selection);
          return;
        }

        isSelecting = true;
        onCangjieSelect(selection.set('focus', range.focus), SelectionTrigger.Selecting);
      }

      function onSelectEnd() {
        if (outsideScoller.current) {
          outsideScoller.current.cancel();
          outsideScoller.current = null;
        }

        stopScroll(controller);

        if (isSelecting) {
          const {
            selection
          } = controller.value;
          onCangjieSelect(selection.set('data', lodash.omit(selection.data, 'trigger')));
        }

        window.document.removeEventListener('mousemove', onSelectUpdate);
        window.document.removeEventListener('mouseup', onSelectEnd);
        window.document.removeEventListener('mouseleave', onSelectEnd);
      }

      controller.perfStart({
        type: PerfType.selection,
        subtype: 'focusText'
      });

      if (isJustTapHold.current) {
        controller.perfDrop(PerfType.selection);
        isJustTapHold.current = false;
        return;
      }

      const rawRange = caretRangeFromTargetAndCoord(event.target, event.clientX, event.clientY, controller);
      const isClickAtLeftSide = isCoordAtLeftSide(event.clientX, controller);

      if (!rawRange) {
        controller.perfDrop(PerfType.selection);
        return;
      }

      const range = rawRange.setHanging(isClickAtLeftSide && isPointAtEdge(rawRange.anchor)); // HACK: Safari + third-party IME + MacOS checked TapToHold option
      // sometimes mouseup event triggers before mousedown in a click progress
      // Ref: https://github.com/facebook/react/issues/20787

      if (IS_MAC && IS_SAFARI && event.buttons === 0) {
        // in this backgound, event.buttons is 0
        const {
          selection
        } = controller.value;

        if (event.shiftKey) {
          onCangjieSelect(selection.set('focus', range.focus), SelectionTrigger.SelectStart);
        } else {
          onCangjieSelect(range, SelectionTrigger.SelectStart);
        }

        return;
      } // Right button clicked.
      // Ref: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button


      if (event.button === 2) {
        const shouldSelect = shouldSelectOnRightClick(range.focus, controller);

        if (shouldSelect) {
          onCangjieSelect(range);
          return;
        }

        controller.perfDrop(PerfType.selection);

        if (!controller.value.isFocused) {
          controller.run('onCangjieFocus');
        }

        return;
      }

      if (scrollableContainerRef.current) {
        outsideScoller.current = startScroll({
          scroller: scrollableContainerRef.current,
          controller
        });
      }

      window.document.addEventListener('mousemove', onSelectUpdate);
      window.document.addEventListener('mouseup', onSelectEnd);
      window.document.addEventListener('mouseleave', onSelectEnd);
      const {
        selection
      } = controller.value;

      if (event.shiftKey) {
        onCangjieSelect(selection.set('focus', range.focus), SelectionTrigger.SelectStart);
      } else {
        onCangjieSelect(range, SelectionTrigger.SelectStart);
      }
    },

    onTapHoldStart(event) {
      if (tapHoldTimer.current) {
        clearTimeout(tapHoldTimer.current);
      }

      const {
        target,
        clientX,
        clientY
      } = event.touches[0];
      tapHoldTimer.current = window.setTimeout(() => {
        isJustTapHold.current = true;
        const range = getWordSelection(controller, target, clientX, clientY);

        if (range) {
          onCangjieSelect(range);
        }
      }, TAP_HOLD_DELAY);
    },

    onTapHoldEnd() {
      if (tapHoldTimer.current) {
        clearTimeout(tapHoldTimer.current);
        tapHoldTimer.current = null;
      }
    }

  }), [controller, scrollableContainerRef, onCangjieSelect]);
}

/**
 * @packageDocumentation
 * @module Events
 * @description Prevent clipboard data from being destroyed when asynchronous retrieval of data
 */
function PasteInputEvent(detail) {
  return new CustomEvent('pasteInput', {
    detail
  });
}

const _createElement$b = React__namespace.createElement;
const SHOULD_FOLLOW_CARET = !IS_IOS || IS_IPAD;
const textAreaProps = IS_MOBILE ? {} : {
  spellCheck: false
};
const commonStyle = {
  position: 'fixed',
  overflow: 'hidden',
  width: 1,
  height: 1,
  lineHeight: 1,
  whiteSpace: 'pre-wrap',
  zIndex: -1,
  opacity: 0,
  background: 'transparent',
  color: 'transparent',
  outline: 'none',
  caretColor: 'transparent',
  willChange: 'left,top'
}; //@ts-ignore

if (process.env.NODE_ENV !== 'uitest') {
  // https://developer.mozilla.org/en-US/docs/Web/CSS/contain
  commonStyle.contain = 'strict';
}

const wrapperStyle = SHOULD_FOLLOW_CARET ? commonStyle : { ...commonStyle,
  top: 0,
  left: -99 // 修复iOS we-web下输入文字时滚动问题
  // height: 'auto',

};
const textAreaStyle = {
  fontSize: 'inherit',
  lineHeight: 1,
  padding: 0,
  border: 'none',
  // [IMPORTANT]
  // 1. iOS@<13 need to preserve `\n` to detect `moveUpward` & `moveDownward`,
  //    see: cangjie/src/hooks/useSelectionCalculator.ts
  // 2. Desktop need `nowrap` to prevent that IME positioning incorrectly
  whiteSpace: IS_IOS ? 'pre-wrap' : 'nowrap',
  // [IMPORTANT]
  // 1. Textarea will enlarge ancestors' rectangle when width is `auto`.
  // 2. `useInputDetector` will treat inputting as deleting if width is smaller than `1em`.
  width: '1em'
};

function usePointPosition(textareaWrapperRef, point, zoom) {
  const controller = useController();
  const container = useZoomContainer();
  React__namespace.useEffect(() => {
    if (!SHOULD_FOLLOW_CARET || !point) {
      return;
    }

    const textareaWrapper = textareaWrapperRef.current;

    if (!textareaWrapper) {
      return;
    }

    if (!container) {
      return;
    }

    const {
      isHanging
    } = controller.value.selection;
    const preferredEdge = isHanging ? 'start' : 'end';
    const rect = findCaretPosition(point, preferredEdge, container);

    if (!rect) {
      return;
    }

    const {
      clientLeft,
      clientTop
    } = rect;
    textareaWrapper.style.top = `${clientTop}px`;
    textareaWrapper.style.left = `${clientLeft}px`;
    textareaWrapper.style.fontSize = `${rect.height / zoom}px`;
  });
}

const HiddenTextArea = /*#__PURE__*/React__namespace.forwardRef((props, ref) => {
  const {
    selection,
    ...rest
  } = props;
  const wrapperRef = /*#__PURE__*/React__namespace.createRef();
  const zoom = useZoom();
  const controller = useController();
  let {
    anchor: point
  } = selection; // if the target point is inside a void element, take the previous point

  const {
    document
  } = controller.value;
  const parentNode = document.getParent(point.key);

  if (parentNode && controller.query('isVoid', parentNode)) {
    point = controller.query(pointAtDistance, point, -1);
  }

  usePointPosition(wrapperRef, point, zoom);

  const children = /*#__PURE__*/_createElement$b("div", {
    ref: wrapperRef,
    style: wrapperStyle,
    "data-cangjie-hidden": true
  }, /*#__PURE__*/_createElement$b("textarea", _extends__default["default"]({}, rest, textAreaProps, {
    ref: ref,
    rows: 1,
    style: textAreaStyle,
    "data-cangjie-input": true // https://aone.alibaba-inc.com/v2/project/585561/bug/45423783#
    // iOS 15+ 有时会出现输入英文时页面 crash 然后 reload
    // 从现象上看，若关闭了系统输入法的「自动改正」开关，就不会出现
    // 因此这里加个 Non-standard Attribute 做个防御
    ,
    autoCorrect: "off"
  })));

  return /*#__PURE__*/ReactDOM__default["default"].createPortal(children, window.document.body);
});

/* eslint-disable prefer-arrow-callback */
function useResumePosition(scrollableContainerRef, containerRef, controller) {
  // 缓存用户最近一次的光标位置，以实现多人协同时，内容变动，固定用户视角
  const snapshotCursorY = React__namespace.useRef(null);
  const snapshotScrollTop = React__namespace.useRef(0);
  const prevSelectionRef = React__namespace.useRef(null);
  const {
    document,
    selection,
    injections
  } = controller.value;
  React__namespace.useMemo(function snapshotCursorPos() {
    if (!controller.shouldResumePosition || controller.enableVirtualizeView) {
      return;
    } // 记录选区数据发生变化，DOM 尚未变更时，DOM 光标的位置
    // BACKGROUND：DOM 更新后，若选区数据（key）未发生变化，而选区对应的空间（Path）变化，则光标差异源于协同编辑，需要做滚动调整
    // HACK：`getSnapshotBeforeUpdate` 没有等价实现，使用 React.memo 实现 DOM 变更前的 Snapshot


    const val = controller.value;

    if (val.isFocused && scrollableContainerRef.current && prevSelectionRef.current) {
      snapshotScrollTop.current = scrollableContainerRef.current.scrollTop;
      const cursorRect = getDOMRectFromSelection(prevSelectionRef.current || val.selection, containerRef.current, controller);

      if (cursorRect) {
        const cursorY = scrollableContainerRef.current.scrollTop + cursorRect.top;
        snapshotCursorY.current = cursorY;
      }
    } else {
      snapshotCursorY.current = null;
    }
  }, [document, selection, injections]);
  React__namespace.useEffect(function scrollback() {
    if (!controller.shouldResumePosition || controller.enableVirtualizeView) {
      return;
    }

    const val = controller.value;

    if (val.isFocused && snapshotCursorY.current !== null && scrollableContainerRef.current) {
      // 当 DOM 更新后:
      // 如果选区所在的空间发生了变化，即当前选区的空间，不等于最近一次单人编辑时缓存的空间
      // 则认为选区因协同数据而发生了变化，此时需要做滚回操作
      const cursorRect = getDOMRectFromSelection(val.selection, containerRef.current, controller);

      if (!cursorRect) {
        snapshotCursorY.current = null;
      } else {
        const cursorY = scrollableContainerRef.current.scrollTop + cursorRect.top;
        const offset = cursorY - snapshotCursorY.current;

        if (offset !== 0) {
          scrollableContainerRef.current.scrollTop = snapshotScrollTop.current + offset;
        } // 刷新 DOM 光标位置


        snapshotCursorY.current = cursorY;
      }
    } // 消费后重置回默认值


    controller.setScrollType(defaultScrollType);
  }, [document, selection, injections]);
  React__namespace.useEffect(() => {
    prevSelectionRef.current = selection;
  }, [selection]);
}

const DEBOUNCE_TIME_SCROLL_BY_SELECTION = 60;
function useScrollBySelection(scrollableContainerRef, contentRef, controller) {
  const {
    selection,
    composing
  } = controller.value;
  const scrollDepsRef = React__default["default"].useRef({
    selection: null,
    composing: ''
  });
  const scrollBySelection = React__default["default"].useMemo(() => lodash.debounce((targetSelection, targetComposing) => {
    if ((targetSelection.isExpanded || !controller.readOnly) && // 拖选时 or 编辑态下的光标 可触发滚动
    controller.value.isFocused && contentRef.current && scrollableContainerRef.current && (!equal__default["default"](targetSelection, scrollDepsRef.current.selection) || targetComposing !== scrollDepsRef.current.composing)) {
      scrollDepsRef.current = {
        selection: targetSelection,
        composing
      }; // 移动端：选区 Expand 时候，没必要每次渲染都进行 scroll，不然会导致无法跨段落选择

      if (IS_MOBILE && targetSelection.isExpanded) {
        return;
      } // 表格设置的选区，禁止 scroll


      if (targetSelection.data.isByTable) {
        return;
      }

      if (isScrolling(controller)) {
        return;
      } // 全选状态下，就不要scroll了。


      const {
        document: latestDocument,
        selection: latestSelection
      } = controller.value;
      const {
        start,
        end
      } = latestSelection.sort(latestDocument);
      const startPoint = controller.query(pointAtStartOfNode, latestDocument);
      const endPoint = controller.query(pointAtEndOfNode, latestDocument);
      const skipScroll = equal__default["default"](start, startPoint) && equal__default["default"](end, endPoint);

      if (skipScroll) {
        return;
      }

      const target = composing ? Selection.create({ ...targetSelection,
        focus: TextPoint.create({ ...targetSelection.focus,
          offset: targetSelection.focus.offset + targetComposing.length
        })
      }) : targetSelection;
      scrollToSelection(target, contentRef.current, scrollableContainerRef.current, controller);
    }
  }, DEBOUNCE_TIME_SCROLL_BY_SELECTION), [contentRef, scrollableContainerRef, controller]); // 根据选区变化滚动页面

  React__default["default"].useEffect(() => {
    // 排除渲染后需要滚回至原位置而非选区所在位置的情况
    // BACKGROUND: 协同编辑时，若协同者在同一段落的本地选区之前编辑，会导致本地选区变化
    if (controller.shouldScrollToSelection) {
      scrollBySelection(selection, composing);
    }

    return () => {
      scrollBySelection.cancel();
    }; // 这里不能加 document 依赖，因为可能会导致多人协同的时候，异常滚动。
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [controller, selection, composing]);
}

const _createElement$a = React__namespace.createElement;
const attrbiute = {
  [Selector.nonSelect]: true
};
const style = {
  pointerEvents: 'none'
};

const isComponentPropsEqual = (prevProps, nextProps) => {
  return prevProps.isFocused === nextProps.isFocused && prevProps.isRemote === nextProps.isRemote && equal__default["default"](prevProps.rects, nextProps.rects) && equal__default["default"](prevProps.selection, nextProps.selection);
};
/**
 * 负责渲染 expanded selection
 */


const Range = /*#__PURE__*/React__namespace.memo(props => {
  const {
    rects,
    controller,
    isFocused,
    isRemote,
    selection
  } = props;
  const color = React__namespace.useMemo(() => controller.query('selectionColor', selection, !isRemote // isFocused 在 query 内部会消费掉
  // eslint-disable-next-line react-hooks/exhaustive-deps
  ), [controller, selection, isRemote, isFocused]);
  return /*#__PURE__*/_createElement$a("div", {
    "data-cangjie-selection": selection.viewKey,
    style: style,
    "data-testid": "cangjie-range",
    className: "cangjie-range"
  }, rects.map(rect => {
    const position = 'absolute';
    const {
      left,
      top,
      width,
      height
    } = rect;
    const key = `${left}-${top}-${width}-${height}`;
    const style = {
      position,
      left,
      top,
      width,
      height,
      backgroundColor: color || CANGJIE_SELECTION_INACTIVE_COLOR
    };
    return /*#__PURE__*/_createElement$a("div", _extends__default["default"]({
      key: key
    }, attrbiute, {
      style: style
    }));
  }));
}, isComponentPropsEqual);

/* eslint-disable prefer-arrow-callback */

function isDelayed(selection, controller) {
  return selection !== controller.value.selection;
}

function usePerf(controller, noTrack) {
  /********************************************************************************************\
  * 正常绘制流程                                                                                 *
  *                 +---------+    +---------+   +---------+   +---------+   +----------+      *
  *  ---------------+ keydown +----+ render  +---+   rAF   +---+  paint  +---+setTimeout+----> *
  * Timeline        +---------+    +---------+   +---------+   +---------+   +----------+      *
  *                                                                                            *
  \********************************************************************************************/

  /*************************************************************************************************************\
  * 丢帧场景                                                                                                     *
  *                                +--------------+                                                             *
  *                          +---->| 未被绘制，丢帧 |                                                             *
  *                          |     +--------------+                                                             *
  *                          |                                                                                  *
  *            +--------------------------+                                                                     *
  *            | +---------+  +---------+ | +----------+  +---------+  +---------+ +---------+  +---------+     *
  *  ----------+-+ keydown +--+ render  +-+-+setTimeout+--+ keydown +--+ render  +-+   rAF   +--+  paint  +---> *
  * Timeline   | +---------+  +---------+ | +----------+  +---------+  +---------+ +---------+  +---------+     *
  *            +--------------------------+                                                                     *
  *                                                                                                             *
  \*************************************************************************************************************/
  React.useEffect(() => {
    if (noTrack) {
      return;
    } // 如果是 pending 期间的选区更新，进行输入统计


    const {
      pendingType
    } = controller;

    if (pendingType === exports.PendingType.input || pendingType === exports.PendingType.selection) {
      const {
        selection
      } = controller.value;
      let dropped = true;
      window.requestAnimationFrame(function preparePaint() {
        // 在下一次 repaint 发生前，若光标不再等于组件 update 时的光标，则认为丢帧
        dropped = isDelayed(selection, controller);
        const perfType = pendingType === exports.PendingType.input ? controller.value.composing ? PerfType.composing : PerfType.input : PerfType.selection;
        controller.perfEnd(perfType, dropped);
      });
    }
  });
}

const _createElement$9 = React__default["default"].createElement;
const SelectionRenderer = /*#__PURE__*/React__default["default"].memo(props => {
  const {
    appearances,
    isFocused,
    controller
  } = props;
  const prevSelectionRef = React__default["default"].useRef(null);
  const [globalStyle, setGlobalStyle] = React__default["default"].useState(null);
  usePerf(controller, prevSelectionRef.current === controller.value.selection);
  React__default["default"].useEffect(() => {
    const style = controller.query('selectionGlobalStyle');
    setGlobalStyle(style);
  }, []);
  const wrappers = Array.from(appearances.keys());

  var _ref = /*#__PURE__*/_createElement$9("style", null, globalStyle);

  return /*#__PURE__*/_createElement$9(React__default["default"].Fragment, null, wrappers.map(wrapper => {
    if (!wrapper) {
      return null;
    }

    const info = appearances.get(wrapper);
    let hasRemote = false;

    const content = /*#__PURE__*/_createElement$9(React__default["default"].Fragment, null, info.map(({
      appearance,
      isRemote,
      selection,
      color
    }, index) => {
      hasRemote = hasRemote || isRemote;
      return Array.isArray(appearance) ? /*#__PURE__*/_createElement$9(Range, {
        key: `range-${index}`,
        rects: appearance,
        isRemote: isRemote,
        isFocused: isFocused,
        controller: controller,
        selection: selection
      }) : /*#__PURE__*/_createElement$9(Caret, {
        key: `caret-${index}`,
        color: color,
        isRemote: isRemote,
        isFocused: isFocused,
        controller: controller,
        selection: selection,
        position: appearance
      });
    }), hasRemote && _ref);

    return /*#__PURE__*/ReactDOM__default["default"].createPortal(content, wrapper);
  }));
});

/**
 * @packageDocumentation
 * @ignore
 */
const RE_RGB = /^rgba?\((.+)\)/i;
const ALPHA_THRESHOLD = 0.5;
const LUMINANCE_THRESHOLD = 0.5;

function isCoordInsideDOMRect(x, y, rect) {
  const {
    left,
    right,
    top,
    bottom
  } = rect;
  return x >= left && x <= right && y >= top && y <= bottom;
}
function getBgColor(targetBlock, at, point) {
  let element = targetBlock;

  if (point.isTextPoint()) {
    const leaves = targetBlock.querySelectorAll(`[${Selector.key}^="${point.key}:"]`);
    const target = Array.from(leaves).find(b => {
      return isCoordInsideDOMRect(at.left, at.top + at.height / 2, b.getBoundingClientRect());
    });

    if (target) {
      element = target;
    }
  }

  while (element) {
    const color = window.getComputedStyle(element).backgroundColor;
    const rgba = rgbaFromString(color);

    if (rgba && rgba[3] > ALPHA_THRESHOLD && element.getBoundingClientRect().width > 0) {
      return rgba;
    }

    element = element.parentElement;
  }

  return [255, 255, 255, 1];
}
/**
 * rgba 字符串转为 rgba 数组。
 * 'rgba(0,0,0,0.88)' => [0,0,0,0.88]
 * 'RGB(0,0,0)' => [0,0,0,1]
 */

function rgbaFromString(str) {
  const rgb = RE_RGB.exec(str) || [];
  const rgbs = (rgb[1] || '').split(',');

  if (rgbs.length < 3) {
    return null;
  } else if (rgbs.length === 3) {
    rgbs.push('1');
  }

  const rgba = [0, 0, 0, 0];
  rgba[0] = parseInt(rgbs[0], 10);
  rgba[1] = parseInt(rgbs[1], 10);
  rgba[2] = parseInt(rgbs[2], 10);
  rgba[3] = parseFloat(rgbs[3]);
  return rgba;
}
/**
 * 获取相对的 luminance。
 * https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
 */


function getLuminance(rgba) {
  const a = [];

  for (let i = 0; i < 3; i++) {
    const x = rgba[i] / 255;
    a[i] = x <= 0.03928 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
  }

  return 0.2126 * a[0] + 0.7152 * a[1] + 0.0722 * a[2];
}
/**
 * 根据背景色，获取光标的颜色。
 */


function getCaretColor(backgroundColor) {
  const luminance = getLuminance(backgroundColor);
  return luminance > LUMINANCE_THRESHOLD ? 'black' : 'white';
}

/**
 * 从 cangjie-leaf 中获取 rects
 */

function getRectsFromLeaf(element, selection, document) {
  const {
    start,
    end
  } = selection.convertToTextPoints(document);
  const [keyStr, leafOffsetStr] = element.getAttribute(Selector.key)?.split(':') || [];
  const textNode = element.firstChild;

  if (!keyStr || !leafOffsetStr || !textNode) {
    return [];
  } // 检测 leaf 所在的 text 是否在选区内


  if (!document.isNodeInRange(keyStr, selection)) {
    return [];
  }

  const textLength = textNode.textContent?.length || 0;
  const leafOffset = parseInt(leafOffsetStr, 10); // 检测 leaf 是否在选区内

  if (keyStr === start.key && start.offset > leafOffset + textLength) {
    return [];
  }

  if (keyStr === end.key && end.offset < leafOffset) {
    return [];
  } // 是否是一半的 leaf


  let startOffset = -1;
  let endOffset = -1;

  if (keyStr === start.key && start.offset >= leafOffset && start.offset <= leafOffset + textLength) {
    startOffset = start.offset - leafOffset;
  }

  if (keyStr === end.key && end.offset >= leafOffset && end.offset <= leafOffset + textLength) {
    endOffset = end.offset - leafOffset;
  }

  if (startOffset >= 0 || endOffset >= 0) {
    try {
      const range = window.document.createRange();
      range.setStart(textNode, Math.max(startOffset, 0));
      range.setEnd(textNode, endOffset < 0 ? textLength : endOffset);
      return Array.from(range.getClientRects());
    } catch (error) {
      return [];
    }
  } // 到这里，肯定是完整的 leaf


  return Array.from(element.getClientRects());
}

function getDOMPath(dom, root = window.document.body) {
  const path = [];
  let current = dom;

  while (current && current !== root) {
    path.push(current);
    current = current.parentElement;
  }

  return path.reverse();
}
function getTraverseRootsByDOMPath(path1, path2) {
  const length = Math.min(path1.length, path2.length);
  let current = 0;

  for (; current < length; current++) {
    if (path1[current] !== path2[current]) {
      break;
    }
  }

  if (current === length) {
    return [path1[length - 1], path1[length - 1], path1.slice(0, length)];
  }

  return [path1[current], path2[current], current > 0 ? path1.slice(0, current) : []];
}

function traverseDOMTree(root, callback, parentContext = {}, options) {
  let {
    isStarted,
    isEnded
  } = options;
  const {
    stopTraverse,
    context
  } = callback(root, parentContext);

  if (stopTraverse) {
    return {
      isStarted,
      isEnded
    };
  }

  const childContext = lodash.merge({ ...parentContext
  }, context);
  const {
    startPath,
    endPath,
    rootPath
  } = options;

  for (const ele of root.children) {
    const path = rootPath.concat(ele);
    const [,, commonStartPath] = getTraverseRootsByDOMPath(startPath, path);
    const [,, commonEndPath] = getTraverseRootsByDOMPath(endPath, path); // 未遍历到 start dom 且在遍历 start dom 的祖先节点

    if (!isStarted && commonStartPath.length === path.length) {
      const started = commonStartPath.length === startPath.length;
      const newOpt = traverseDOMTree(ele, callback, childContext, {
        startPath,
        endPath,
        rootPath: path,
        isStarted: started,
        isEnded
      });
      isStarted = newOpt.isStarted;
      isEnded = newOpt.isEnded;
    } else if (isStarted && (!isEnded || commonEndPath.length === endPath.length)) {
      // 已到过 start dom 且未遍历完 end dom tree
      const ended = commonEndPath.length === endPath.length;
      const newOpt = traverseDOMTree(ele, callback, childContext, {
        startPath,
        endPath,
        rootPath: path,
        isStarted,
        isEnded: ended
      });
      isStarted = newOpt.isStarted;
      isEnded = newOpt.isEnded;
    } else if (isEnded && commonEndPath.length < endPath.length) {
      // 已遍历完 end dom tree
      break;
    }
  }

  return {
    isStarted,
    isEnded
  };
}
/**
 * 情况一：startAncestor, endAncestor 为相同节点
 * startAncestor/endAncestor/commonPath
 *                / \
 *               /   \
 *             void  block
 *                     /\
 *                    /  \
 *                 leaf  leaf
 *
 * 情况二：startAncestor, endAncestor 为兄弟节点
 *             commonPath
 *             /    |    \
 *            /     |     \
 *  startAncestor  ...  endAncestor
 *     / \               /    \
 *    /   \             /      \
 * void    block      block     block
 *          /\         /\        /\
 *         /  \       /  \      /  \
 *      leaf  leaf leaf  leaf leaf leaf
 * (startPath)              (endPath)
 *
 * 情况三：startAncestor, endAncestor 为兄弟节点，且 startPath = startAncestor or endPath = endAncestor
 *             commonPath
 *             /    |    \
 *            /     |     \
 *  startAncestor  ...  endAncestor
 * (startPath/void)       /    \
 *                       /      \
 *                     block     block
 *                      / \       / \
 *                     /   \     /   \
 *                   leaf  leaf leaf leaf
 *                                 (endPath)
 */

function traverseDOMForest(startPath, endPath, callback) {
  const [startAncestor, endAncestor, commonPath] = getTraverseRootsByDOMPath(startPath, endPath);
  let root = commonPath.length === startPath.length ? startPath[startPath.length - 1] : startAncestor;
  let {
    isStarted,
    isEnded
  } = {
    isStarted: commonPath.length === startPath.length,
    isEnded: commonPath.length === endPath.length
  };

  while (root) {
    const opt = traverseDOMTree(root, callback, {}, {
      startPath,
      endPath,
      rootPath: [...commonPath, root],
      isStarted: isStarted || commonPath.length + 1 === startPath.length && root === startPath[startPath.length - 1],
      isEnded: isEnded || commonPath.length + 1 === endPath.length && root === endPath[endPath.length - 1]
    });
    isStarted = opt.isStarted;
    isEnded = opt.isEnded;

    if (root === endAncestor) {
      break;
    }

    root = root.nextElementSibling;
  }
}

// 复用选区定位逻辑中对同一行的判断来进行分行
const isOverlapped = (a, b) => {
  return isRectOnSameLineOfRect({ ...a,
    height: a.bottom - a.top
  }, { ...b,
    height: b.bottom - b.top
  });
};

const getMaxLineSize = (a, b) => ({
  top: Math.min(a.top, b.top),
  bottom: Math.max(a.bottom, b.bottom)
}); // 扩展行高，填充行之间的空隙


function extendToFillBetweenLines(lines, startRects = [], endRects = []) {
  const length = lines.length;

  if (length === 0) {
    return [];
  }

  let first = lines[0];
  let last = lines[length - 1]; // 用选区 start 所在 block 的 rects 扩展第一行的高度

  for (const rect of startRects) {
    if (rect && isOverlapped(rect, first)) {
      first = getMaxLineSize(rect, first);
    }
  } // 用选区 end 所在 block 的 rects 扩展最后一行的高度


  for (const rect of endRects) {
    if (rect && isOverlapped(rect, last)) {
      last = getMaxLineSize(rect, last);
    }
  }

  const filled = [first, ...lines.slice(1, length - 1), last];

  for (let i = 1; i < length; i++) {
    const prev = filled[i - 1];
    const now = filled[i];
    const margin = now.top - prev.bottom;
    prev.bottom += margin / 2;
    now.top -= margin / 2;
  }

  return filled;
}

function splitRectsIntoLines(rects) {
  // 将 rects 以从上到下、从左到右排序 - O(NlogN)
  const sortedRects = rects.filter(v => v.width).sort((a, b) => a.top - b.top || a.left - b.left);
  const lines = [];
  const lineSizes = []; // 将 sortedRects 按顺序归纳到每一行中，并记录每行的尺寸 - O(N)

  let currentIndex = 0;
  sortedRects.forEach(rect => {
    if (lines.length === 0) {
      lines.push([rect]);
      lineSizes.push({
        top: rect.top,
        bottom: rect.bottom
      });
      return;
    } // 新的一行


    if (!isOverlapped(rect, lineSizes[currentIndex]) || rect.lineId !== lines[currentIndex][0].lineId) {
      lines.push([rect]);
      lineSizes.push({
        top: rect.top,
        bottom: rect.bottom
      });
      currentIndex += 1;
      return;
    } // 属于当前行


    lines[currentIndex].push(rect);
    lineSizes[currentIndex] = getMaxLineSize(rect, lineSizes[currentIndex]);
  });
  return [lines, lineSizes];
}

function antiAliasingRects(rects, startRects = [], endRects = []) {
  // 将 rects 以从上到下、从左到右排序，并记录每行的尺寸 - O(NlogN)（N 为 rect 个数）
  const [lines, lineSizes] = splitRectsIntoLines(rects);
  const startSizes = extendToFillBetweenLines(splitRectsIntoLines(startRects)[1]);
  const endSizes = extendToFillBetweenLines(splitRectsIntoLines(endRects)[1]); // 填充行之间的空隙：获得每行填充后的尺寸 - O(M)（M 为行数）

  const filledSizes = extendToFillBetweenLines(lineSizes, startSizes, endSizes); // 填充行之间的空隙：将 rects 更新为填充后的尺寸并合并相邻的 - ~O(N)

  const result = [];
  lines.forEach((lineRects, index) => {
    const top = filledSizes[index].top;
    const height = filledSizes[index].bottom - top;
    const fitted = lineRects.map(rect => ({
      top,
      height,
      left: rect.left,
      width: rect.width
    }));
    const merged = mergeRects(fitted);
    result.push(...merged);
  });
  return result;
}

const isEdgeSelectable = dom => dom.getAttribute(Selector.edgeSelectable) === 'true';

const isLeaf = dom => dom.getAttribute(Selector.leaf) === 'true';

const isVoid = dom => dom.getAttribute(Selector.void) === 'true';

const isFloatInlineBox = dom => dom.getAttribute('data-type') === 'float-inline-box';

const isFloatBlockBox = dom => dom.getAttribute('data-type') === 'float-block-box';

const isLine = dom => dom.getAttribute('data-type') === 'line'; // const isGroupBlock = (dom: HTMLElement) => dom.getAttribute(Selector.groupBlock) === 'true';


const isPage = dom => dom.getAttribute('data-type') === 'page';

const isTableCell = dom => dom.getAttribute('data-type') === 'table-cell';

const isFullyContained = (key, voidElement, selection, document) => {
  const {
    start,
    end
  } = selection.sort(document);
  const startPath = document.getPath(start.key);
  const endPath = document.getPath(end.key);
  const targetPath = document.getPath(key);

  if (!startPath || !endPath || !targetPath) {
    return false;
  }

  if (Path.isAncestor(targetPath, startPath) || Path.isAncestor(targetPath, endPath)) {
    // eg. 目标节点为 [0, 1]，start/end 为 [0, 1, 0]
    // => 目标节点若为 void 元素，则选区包含了目标
    // => 目标节点若非 void，则选区未完全包含目标
    return voidElement;
  }

  return document.isNodeInRange(key, selection);
};

const GlobalGroupKey = 'global-group';
const DefaultGapLabel = 'default-gap-label';

const getGapLabel = decesdant => {
  const conditions = [// isGroupBlock, // TODO FIXME: groupNodes 隔开的上下的全局段落，会被分组到一起做空隙填充，需要再对每个连续的全局区块单独命名
  isPage, isTableCell, isFloatInlineBox, // 浮动元素单独为一组，不参与普通 Rect 的间隙填充逻辑
  isFloatBlockBox // eg. 首字下沉
  ];
  const shouldGap = conditions.find(cond => cond(decesdant));
  return shouldGap ? decesdant.getAttribute(Selector.key) || DefaultGapLabel : undefined;
};
/**
 * 判断当前节点的子节点中是否仅有一个 leaf/void 节点
 * @param decesdant
 * @returns
 */


const hasOnlyLeafChild = decesdant => {
  let count = 0;
  const len = decesdant.children.length;

  for (let i = 0; i < len; i++) {
    if (isLeaf(decesdant.children[i]) || isVoid(decesdant.children[i])) {
      count++;
    } // perf: 找到超过 1 个符合要求的，就提前 return


    if (count > 1) {
      return false;
    }
  }

  return count === 1;
};

const addLineIdToRect = (rect, lineId) => {
  return { ...(rect.toJSON ? rect.toJSON() : rect),
    lineId
  };
};

const addToRectGroupWithGap = (rects, target, context = {}) => {
  const key = context.scrollableKey || GlobalGroupKey;
  const label = context.gapLabel || DefaultGapLabel;

  if (!target[key]) {
    target[key] = {};
  }

  if (!target[key][label]) {
    target[key][label] = [];
  }

  target[key][label].push(...rects);
};

function getRectsFromSelection(selection, contentDOM, controller) {
  const {
    document
  } = controller.value;
  const {
    start,
    end
  } = selection.sort(document);
  const startBlock = start.isEdgePoint() ? document.getNode(start.key) : document.getClosestBlock(start.key);
  const endBlock = end.isEdgePoint() ? document.getNode(end.key) : document.getClosestBlock(end.key);
  const startPath = document.getPath(start.key);
  const endPath = document.getPath(end.key);
  const startBlockPath = startBlock && document.getPath(startBlock.key);
  const endBlockPath = endBlock && document.getPath(endBlock.key);

  if (!startBlock || !endBlock || !startPath || !endPath || !startBlockPath || !endBlockPath) {
    throw new Error('start/end block or path is empty');
  }

  const selectionRects = {};
  const startRects = {};
  const endRects = {}; // 遍历过程中的 DOM 节点处理逻辑

  const traverseHandler = (decesdant, context = {}) => {
    const domKey = decesdant.getAttribute(Selector.key);

    if (!domKey) {
      return {
        stopTraverse: false
      };
    }

    const voidDOM = isVoid(decesdant);
    const leafDOM = isLeaf(decesdant);
    const lineDOM = isLine(decesdant);
    const edgeSelectableDOM = isEdgeSelectable(decesdant); // 记录 start/end 所在 block 的所有 rects，用于后续修正选区边界的 rect

    if (voidDOM || leafDOM) {
      const path = document.getPath(domKey.split(':')[0]) || [];

      if (Path.isAncestor(startBlockPath, path)) {
        addToRectGroupWithGap(Array.from(decesdant.getClientRects()).map(v => addLineIdToRect(v, context.lineId)), startRects, context);
      }

      if (Path.isAncestor(endBlockPath, path)) {
        addToRectGroupWithGap(Array.from(decesdant.getClientRects()).map(v => addLineIdToRect(v, context.lineId)), endRects, context);
      }
    }

    if (edgeSelectableDOM || voidDOM) {
      if (isFullyContained(domKey, voidDOM, selection, document)) {
        const rect = decesdant.getBoundingClientRect();
        addToRectGroupWithGap([addLineIdToRect(rect, context.lineId)], selectionRects, context);
        return {
          stopTraverse: true
        }; // 不再继续递归
      }

      if (voidDOM) {
        return {
          stopTraverse: true
        };
      }
    }

    if (leafDOM) {
      let newRects = getRectsFromLeaf(decesdant, selection, document);

      if (context.onlyLeafChild && newRects.length === 1 && newRects[0].width < 1) {
        const {
          left,
          top,
          height
        } = newRects[0];
        const width = CANGJIE_SELECTION_EMPTY_WIDTH;
        newRects = [{ ...newRects[0].toJSON(),
          left,
          top,
          width,
          height
        }];
      }

      addToRectGroupWithGap(newRects.map(v => addLineIdToRect(v, context.lineId)), selectionRects, context);
      return {
        stopTraverse: true
      };
    }

    const gapLabel = getGapLabel(decesdant) || context.gapLabel;
    return {
      stopTraverse: false,
      context: {
        gapLabel,
        lineId: lineDOM ? domKey : undefined,
        onlyLeafChild: hasOnlyLeafChild(decesdant)
      }
    };
  };

  const commonAncestorNode = document.getNodeByPath(Path.common(startPath, endPath));

  if (!commonAncestorNode) {
    throw new Error('commonAncestorNode is empty');
  }

  const commonAncestor = (commonAncestorNode.isElement() ? commonAncestorNode : document.getClosestBlock(commonAncestorNode.key)) || document; // 由于 view 或 实际 DOM 树与 document 结构并非一致，所以通过查找 DOM 树上需遍历的子树根结点来做

  let startBlockDOM = findDOMNodeSafely(startBlock.key, contentDOM);
  let endBlockDOM = findDOMNodeSafely(endBlock.key, contentDOM); // 分页模式下存在虚拟化，若找不到 DOM 则全量遍历已有 DOM

  if (!startBlockDOM || !endBlockDOM) {
    const commonAncestorDOM = findDOMNodeSafely(commonAncestor.key, contentDOM);
    startBlockDOM = startBlockDOM || commonAncestorDOM?.firstElementChild;
    endBlockDOM = endBlockDOM || commonAncestorDOM?.lastElementChild;
  } // 仍找不到则报错


  if (!startBlockDOM || !endBlockDOM) {
    throw new Error('start/end block DOM is empty');
  }

  const startDOMPath = getDOMPath(startBlockDOM, contentDOM);
  const endDOMPath = getDOMPath(endBlockDOM, contentDOM); // 以遍历森林的方式遍历 [startDOMPath, endDOMPath] 之间的节点

  traverseDOMForest(startDOMPath, endDOMPath, traverseHandler);
  const res = [];
  Object.keys(selectionRects).forEach(groupKey => {
    // res[groupKey] = [];
    Object.keys(selectionRects[groupKey]).forEach(gapLabel => {
      // TO BE SOLVED: 1. 存在上下 margin 的 block 元素在跨 block 选区时高度会不稳定
      const lines = antiAliasingRects(selectionRects[groupKey][gapLabel], startRects[groupKey]?.[gapLabel], endRects[groupKey]?.[gapLabel]);
      res.push(...lines);
    });
  });
  return res;
}

function addToResult(result, wrapper, data) {
  if (!result.get(wrapper)) {
    result.set(wrapper, []);
  }

  const targetGroup = result.get(wrapper);
  targetGroup.push(data);
}

const getComposingLeaf = node => node?.isText() ? node.leaves.find(leaf => leaf.marks.some(mark => mark.type === 'cangjieComposing')) : undefined;
/**
 * 输入法输入时，找到光标实际所在的 point
 *
 * @param anchor
 * @param composingLen
 * @param document 包含 composing mark 的 document
 * @returns
 * - composing leaf 未跨 Text 时，修正 offset 到 anchor.offset + composingLen
 * - composing leaf 跨 Text 时，修正到 composing 末尾所在的 Text 内，offset 为最后一个 Text 内的 composing 部分长度
 */


const findComposingPoint = (anchor, composingLen, document) => {
  let len = 0;
  let composingEndLeaf;
  const startText = document.getNode(anchor.key);
  let textNode = startText; // 分页模式下，document 上存在 composing mark，则继续向后找到 composing 末尾；否则使用 startText 即可

  if (getComposingLeaf(startText)) {
    const pointAncestor = document.getFurthestOnlyChildAncestor(anchor.key);

    while (len < composingLen && textNode?.isText()) {
      composingEndLeaf = getComposingLeaf(textNode);
      len += composingEndLeaf?.text.length || 0;

      if (len < composingLen) {
        textNode = pointAncestor ? pointAncestor.getNextText(textNode.key) : null;
      }
    }
  }

  if (textNode) {
    return TextPoint.create({
      key: textNode.key,
      offset: startText !== textNode && composingEndLeaf ? composingEndLeaf.text.length : anchor.offset + composingLen
    });
  } // 兜底使用原值


  return anchor;
};
function getSelectionAppearance(selectionWrapperMap, zoom, isRemote, contentRef, controller) {
  const result = new Map();

  if (!contentRef.current) {
    return result;
  }

  if (controller.shouldHideSelectionOnBlur() && controller.value.isBlurred) {
    return result;
  }

  const wrapperRectCache = new WeakMap();
  const composingLen = controller.value.composing.length;
  selectionWrapperMap.forEach(({
    wrapper,
    originSelection
  }, selection) => {
    if (!wrapper) {
      return;
    }

    const offsetRect = wrapperRectCache.get(wrapper) || wrapper.getBoundingClientRect();
    wrapperRectCache.set(wrapper, offsetRect);

    if (originSelection.isCollapsed) {
      const preferredEdge = originSelection.isHanging ? 'start' : 'end';
      let point = selection.anchor;

      if (!isRemote && point.isTextPoint() && composingLen) {
        point = findComposingPoint(point, composingLen, controller.value.document);
      }

      let targetBlockDOM = null;

      try {
        // 存在 selection 先更新而 document 后更新，导致找不到 block 的情况，需要 catch 住，下次更新即可正常渲染
        const block = controller.value.document.getClosestBlockFromPoint(point.key);
        targetBlockDOM = block ? findDOMNodeSafely(block.key, contentRef.current || undefined) : null;
      } catch (e) {// ignore
      }

      if (!targetBlockDOM) {
        return;
      } // 计算位置


      const {
        clientLeft,
        clientTop,
        height
      } = findCaretPosition(point, preferredEdge, targetBlockDOM, undefined, zoom) || {};

      if (typeof clientLeft === 'undefined' || typeof clientTop === 'undefined' || typeof height === 'undefined') {
        return;
      }

      const correctedPosition = {
        top: clientTop - offsetRect.top / zoom,
        left: clientLeft - offsetRect.left / zoom,
        height
      };

      if (!isRemote) {
        cacheLocalCaret(controller, correctedPosition, wrapper);
      }

      let color; // 为本地光标计算颜色

      if (!isRemote) {
        const backgroundColor = getBgColor(targetBlockDOM, {
          top: clientTop,
          left: clientLeft,
          height
        }, point);
        color = getCaretColor(backgroundColor);
      }

      const data = {
        isRemote,
        color,
        selection: originSelection,
        appearance: correctedPosition
      };
      addToResult(result, wrapper, data);
      return;
    }

    try {
      const rects = getRectsFromSelection(selection, contentRef.current, controller);
      const data = {
        isRemote,
        selection: originSelection,
        appearance: rects.map(rc => ({
          top: (rc.top - offsetRect.top) / zoom,
          left: (rc.left - offsetRect.left) / zoom,
          height: rc.height / zoom,
          width: rc.width / zoom
        }))
      };
      addToResult(result, wrapper, data);
    } catch (err) {
      console.warn('[Selection] Failed to get rects from expanded selection', err);
    }
  });
  return result;
}

const _createElement$8 = React__default["default"].createElement;
let nativeSupport = false; // 仓颉代码会执行在 node 里，这里做一下防护

if (typeof Element !== 'undefined' && typeof Element.prototype !== 'undefined') {
  nativeSupport = 'attachShadow' in Element.prototype && typeof Element.prototype.attachShadow === 'function';
}

function ShadowRoot(props) {
  if (!nativeSupport) {
    return /*#__PURE__*/_createElement$8("div", props.attributes, props.children);
  }

  return /*#__PURE__*/_createElement$8(root__default["default"].div, props.attributes, props.children);
}

const _createElement$7 = React__default["default"].createElement;
const slotStyle = {
  position: 'absolute',
  zIndex: 10,
  // 相对于顶部定位，避免折叠/展开等操作引起的选区定位不稳定
  top: 0
};
const SelectionSlot = /*#__PURE__*/React__default["default"].forwardRef((props, slotRef) => {
  return /*#__PURE__*/_createElement$7(ShadowRoot, {
    attributes: {
      [Selector.selectionLayer]: props.layerFor,
      'data-testid': 'cangjie-selection-layer',
      style: {
        position: 'absolute',
        left: 0,
        top: 0
      }
    }
  }, /*#__PURE__*/_createElement$7("div", {
    ref: slotRef,
    style: slotStyle
  }), props.children);
});

function splitSelectionAndGetWrapper(controller, selection, globalRef) {
  const wrappers = controller.query('getSelectionContainers', {
    selection: selection,
    defaultWrapper: globalRef.current
  }) || new Map();

  if (wrappers.size < 1) {
    wrappers.set(selection, {
      wrapper: globalRef.current,
      originSelection: selection
    });
    return wrappers;
  }

  const res = new Map();
  wrappers.forEach((v, k) => {
    res.set(k, { ...v,
      wrapper: v.wrapper || globalRef.current
    });
  });
  return res;
}

/**
 * 计算选区应该分布的根节点
 *
 * A. 对于单个原始 selection
 * 1. 若为 collapsed，则返回值的 key 为该 selection，value 为它应渲染目标宿主节点 + originSelection
 * 2. 若为 expanded，则返回值 key 为该 selection 按需切割的子 selection，value 为其对应渲染的目标宿主节点 + originSelection
 *
 * B. remoteSelections 会分别将每一项按上面的规则分割并聚合到一个 Map 中
 *
 * @param controller Controller
 * @param globalWrapperRef 渲染在全局的根节点
 * @returns [local, remotes]: [SelectionWrapperMap, SelectionWrapperMap]
 */

function useSelectionWrappers(controller, globalWrapperRef) {
  const {
    remoteSelections,
    selection,
    document
  } = controller.value;
  const prevSelection = React__default["default"].useRef(null);
  const [visibles, setVisibles] = React__default["default"].useState([]);
  const getWrappersBySelection = React__default["default"].useCallback(sel => {
    const wrappers = splitSelectionAndGetWrapper(controller, sel, globalWrapperRef);
    return wrappers;
  }, [document, controller]);
  const local = React__default["default"].useMemo(() => {
    const isHideSelection = controller.query('isHideSelection', {
      selection
    });
    const croppedSelection = getCroppedSelection(controller, selection, controller.visibleBlocks); // 不显示本地选区时 or 首次渲染 globalWrapperRef 仍为空时

    if (isHideSelection || !globalWrapperRef.current || !croppedSelection) {
      return new Map();
    }

    return getWrappersBySelection(croppedSelection); // 首次渲染出 globalWrapperRef 后，使其重新计算一下以得到选区 appearance
  }, [selection, document, controller, globalWrapperRef.current, visibles]);
  const remotes = React__default["default"].useMemo(() => {
    const map = new Map();
    remoteSelections.forEach(sel => {
      const croppedSelection = getCroppedSelection(controller, sel, controller.visibleBlocks);

      if (croppedSelection) {
        const wrappers = getWrappersBySelection(croppedSelection);
        wrappers.forEach((v, key) => map.set(key, v));
      }
    });
    return map;
  }, [remoteSelections, document, controller, visibles]);
  React__default["default"].useEffect(() => {
    prevSelection.current = selection;
  }, [selection, document]);
  React__default["default"].useEffect(() => {
    const sub = controller.visibles$.subscribe(visibles => {
      setVisibles(visibles);
    });
    return () => {
      sub.unsubscribe();
    };
  }, [controller]);
  return [local, remotes];
}

const _createElement$6 = React__default["default"].createElement;
const THROTTLE_TIME_RESIZE = 300;

const SelectionLayer = props => {
  const {
    controller,
    contentRef,
    scrollableContainerRef
  } = props;
  const {
    composing,
    isFocused,
    selection,
    document,
    injections,
    decorations
  } = controller.value;
  const zoom = useZoom() || 1;
  const [_, forceUpdate] = React__default["default"].useReducer(c => c + 1, 0);
  const [resizeFlag, setResizeFlag] = React__default["default"].useState(0);
  const globalWrapperRef = React__default["default"].useRef(null);
  const isUnmountedRef = React__default["default"].useRef(false); // 本地选区外观

  const [local, setLocal] = React__default["default"].useState(new Map()); // 远程选区外观

  const [remotes, setRemotes] = React__default["default"].useState(new Map());
  const localDepsRef = React__default["default"].useRef({
    composing,
    selection,
    node: null
  });
  React__default["default"].useEffect(() => {
    isUnmountedRef.current = false;
    return () => {
      isUnmountedRef.current = true;
    };
  }, []);
  React__default["default"].useEffect(() => {
    if (!contentRef.current) {
      return undefined;
    }

    const resizeUpdator = lodash.throttle(() => {
      if (controller.shouldHideSelectionOnBlur() && controller.value.isBlurred) {
        return;
      }

      setResizeFlag(val => (val + 1) % 2); // 这里无需读取真实的 size 造成 reflow，只需要可以感知到变化即可
    }, THROTTLE_TIME_RESIZE);

    if (typeof ResizeObserver !== 'undefined') {
      const observer = new ResizeObserver(resizeUpdator);
      observer.observe(contentRef.current);
      return () => {
        resizeUpdator.cancel();

        if (contentRef.current) {
          observer.unobserve(contentRef.current);
        }
      };
    }

    window.addEventListener('resize', resizeUpdator);
    return () => {
      resizeUpdator.cancel();
      window.removeEventListener('resize', resizeUpdator);
    };
  }, []);
  React__default["default"].useEffect(() => {
    localDepsRef.current.node = selection.isCollapsed ? document.getPreviousNode(selection.anchor.key) : null;
  }, [selection, document]);
  const shouldForceUpdate = React__default["default"].useCallback(range => {
    if (equal__default["default"](range, selection) && controller.value.composing === localDepsRef.current.composing) {
      // 仅 focus 发生变化时，需要及时 rerender 选区
      if (isFocused !== controller.value.isFocused) {
        return true;
      } // BACKGROUND: 在文本型链接的最后 delete 时，链接文字变少了，但选区不会发生变化
      // 所以需要在这种情况下 force re-render


      if (range.isCollapsed) {
        const prevNode = controller.value.document.getPreviousNode(range.anchor.key);

        if (!equal__default["default"](prevNode, localDepsRef.current.node)) {
          return true;
        }
      }

      return false;
    }

    return true;
  }, [controller, isFocused, selection]);
  const selectionUpdator = React__default["default"].useCallback(({
    range
  }) => {
    if (shouldForceUpdate(range)) {
      localDepsRef.current.composing = controller.value.composing;
      localDepsRef.current.selection = range;
      forceUpdate();
    }
  }, [controller, shouldForceUpdate]);
  const onHots = React__default["default"].useCallback(() => {
    selectionUpdator({
      range: controller.value.selection
    });
  }, [controller, selectionUpdator]);
  const onInputingHots = React__default["default"].useCallback(() => {
    // 保证节点完成渲染之后才计算和绘制选区
    Promise.resolve().then(onHots);
  }, [onHots]);
  useSelectionDataAtTheStartOfNextFrame(controller.selectionData$, null, selectionUpdator, []);
  useSelectingHotsAtTheStartOfNextFrame(controller, onHots);
  useInputingHots(controller, onInputingHots); // 根据本地选区变化滚动页面

  useScrollBySelection(scrollableContainerRef, contentRef, controller);
  useResumePosition(scrollableContainerRef, contentRef, controller); // 计算选区渲染所分布的根节点

  const [localWrappersMap, remoteWrappersMap] = useSelectionWrappers(controller, globalWrapperRef); // 选区需保证 node 渲染完成后再更新

  React__default["default"].useLayoutEffect(() => {
    const appearance = getSelectionAppearance(localWrappersMap, zoom, false, contentRef, controller);
    setLocal(appearance);
  }, [localWrappersMap, composing, zoom, // BACKGROUND: https://aone.alibaba-inc.com/v2/project/897543/bug/41787750#
  isFocused, controller, resizeFlag, injections, decorations]);
  React__default["default"].useLayoutEffect(() => {
    const appearance = getSelectionAppearance(remoteWrappersMap, zoom, true, contentRef, controller);
    setRemotes(appearance);
  }, [remoteWrappersMap, controller, zoom, isFocused, resizeFlag, document, injections, decorations]);
  return /*#__PURE__*/_createElement$6(SelectionSlot, {
    ref: globalWrapperRef,
    layerFor: "global"
  }, /*#__PURE__*/_createElement$6(SelectionRenderer, {
    appearances: local,
    isFocused: isFocused,
    controller: controller
  }), /*#__PURE__*/_createElement$6(SelectionRenderer, {
    appearances: remotes,
    isFocused: isFocused,
    controller: controller
  }));
};

function useCangjieKeyBindingRef(key) {
  const ref = React__namespace.useRef(null);
  const {
    controller
  } = React__namespace.useContext(ControllerContext);
  React__namespace.useLayoutEffect(() => {
    if (!CONTROLLER_TO_KEY_DOM.has(controller)) {
      CONTROLLER_TO_KEY_DOM.set(controller, new Map());
    }

    const KEY_DOM = CONTROLLER_TO_KEY_DOM.get(controller);

    if (ref.current) {
      const dom = ReactDOM__namespace.findDOMNode(ref.current);
      KEY_DOM.set(key, dom);
    } else {
      KEY_DOM.delete(key);
    }
  });
  return ref;
}

/**
 * 是否分组被折叠 
 * @param group 
 * @returns 
 */
function isGroupCollapsed(group) {
  return group.data[GROUP_COLLAPSED_KEY];
}
/**
 * 是否分组为空 
 * @param controller 
 * @param group 
 * @returns 
 */

function isGroupEmpty(controller, group) {
  const {
    document
  } = controller.value;
  const next = document.getNextSibling(group.key);

  if (next?.isElement() && controller.query('isElementInGroup', next, group) !== false) {
    return false;
  }

  return true;
}

var groupUtils = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isGroupCollapsed: isGroupCollapsed,
  isGroupEmpty: isGroupEmpty
});

const _createElement$5 = React__default["default"].createElement;
const blockStyle = {
  position: 'relative'
};
const inlineStyle = { ...blockStyle,
  display: 'inline-block',
  textIndent: 'initial',
  // 设置行高后，使void 节点的高度不变
  lineHeight: 'initial',
  maxWidth: '100%'
};
const voidStyle = { ...inlineStyle
};

const VoidInlineWrapper = ({
  attributes,
  children
}) => {
  return /*#__PURE__*/_createElement$5("span", _extends__default["default"]({
    "data-cangjie-void": true,
    style: voidStyle
  }, attributes), /*#__PURE__*/_createElement$5("span", {
    style: inlineStyle
  }, children));
};

const VoidBlockWrapper = ({
  attributes,
  node,
  children,
  controller,
  visible
}) => {
  const seletableAttrs = {
    [Selector.edgeSelectable]: true
  }; // @ts-ignore

  const fold = Block.isBlock(node) ? useUserData(node, 'fold') || false : false;
  const hidden = useGroupData(node, groups => {
    return groups.some(group => isGroupCollapsed(group) && group.key !== node.key);
  }, fold); // 合并虚拟化的 visible 与 flattenGroup 的 visible

  const finalVisible = visible !== false && !hidden;
  const nodeStyle = useNodeStyle(controller, node, finalVisible);
  return /*#__PURE__*/_createElement$5("div", _extends__default["default"]({
    "data-cangjie-void": true,
    "data-block-uuid": node.data.uuid,
    style: nodeStyle
  }, attributes, seletableAttrs), children);
};

const VoidWrapper = props => {
  const isBlock = Block.isBlock(props.node);
  return isBlock ? /*#__PURE__*/_createElement$5(VoidBlockWrapper, props) : /*#__PURE__*/_createElement$5(VoidInlineWrapper, props);
};

const _createElement$4 = React__namespace.createElement;

const LeafComponent = props => {
  const {
    leafKey,
    style,
    children
  } = props;
  const ref = useCangjieKeyBindingRef(leafKey);
  return /*#__PURE__*/_createElement$4("span", {
    ref: ref,
    "data-cangjie-key": leafKey,
    "data-cangjie-leaf": true,
    "data-cangjie-mark": props['data-cangjie-mark'],
    style: style,
    "data-testid": leafKey
  }, children);
};

function replaceNodeIntoElement(origin, path, node) {
  // invalid path
  if (!path) {
    return origin;
  } // path 指向自身


  if (!path.length) {
    return node;
  }

  const {
    nodes
  } = origin;
  const offset = path[0];
  let target = node; // 递归找到目标位置

  if (path.length > 1) {
    const parent = nodes[offset];

    if (parent && parent.isElement()) {
      target = replaceNodeIntoElement(parent, path.slice(1), node);
    } else {
      target = parent;
    }
  } // 替换目标节点


  if (nodes[offset] && nodes[offset] !== target) {
    const next = nodes.slice(0);
    next[offset] = target;
    return origin.set('nodes', next);
  }

  return origin;
}

function useInputPending(elements, nodePath, controller, enablePending, pending$, updateElements) {
  const {
    node,
    document
  } = elements; // 根据最新 node，使用 toView 局部重算 view node

  const pendingHandler = React.useCallback(data => {
    const {
      startPath: textPath,
      startOffset,
      key: textKey
    } = data; // 判断当前编辑的 text 节点是否在 node 中

    const oldViewText = Block.isBlock(node) ? node.getNode(textKey) : null;

    if (Block.isBlock(node) && oldViewText) {
      // 获取最新 text 和缓存的 view data
      const text = controller.value.document.getNodeByPath(textPath);

      if (text && oldViewText) {
        const viewData = controller.getViewData(oldViewText);
        const {
          injections
        } = viewData; // 推算出新的 decorations

        const decorations = viewData.decorations.slice(0);
        decorations.forEach((d, i) => {
          if (Decoration.isDecoration(d)) {
            const {
              key
            } = text;
            const {
              start,
              end
            } = d;

            if (start.key === key && end.key === key) {
              const delta = text.text.length - oldViewText.text.length;

              if (delta && startOffset <= start.offset) {
                // 在 decoration 前面增删文字
                const tmp = d.set('start', TextPoint.create({
                  key,
                  offset: start.offset + delta
                }));
                decorations[i] = tmp.set('end', TextPoint.create({
                  key,
                  offset: end.offset + delta
                }));
              } else if (delta && startOffset <= end.offset) {
                // 在 decoration 里面增删文字
                decorations[i] = d.set('end', TextPoint.create({
                  key,
                  offset: end.offset + delta
                }));
              }
            }
          }
        });
        const viewText = controller.toView(text, decorations, injections); // 替换 view node 中的 text 节点

        let rPath = textPath.slice(nodePath.length);

        if (node.getNodeByPath(rPath)?.key !== viewText.key) {
          rPath = node.getPath(viewText.key);
        }

        const viewNode = replaceNodeIntoElement(node, rPath, viewText); // 替换 view document 中的 node 节点

        let dPath = nodePath;

        if (document.getNodeByPath(dPath)?.key !== viewNode.key) {
          dPath = document.getPath(viewNode.key);
        }

        const documentView = replaceNodeIntoElement(document, dPath, viewNode);
        updateElements({
          node: viewNode,
          document: documentView
        });
      }
    }
  }, [controller, document, node, nodePath, updateElements]);
  React.useEffect(() => {
    // 只在 leaf block 监听 pending 流
    if (Block.isLeafBlock(node) && enablePending) {
      const sub = pending$.subscribe(pendingHandler);
      return () => sub.unsubscribe();
    }

    return lodash.noop;
  }, [pending$, pendingHandler, node, enablePending]);
}

/**
 * 开启热区时，使用热区视图模型
 * @param controller
 * @param viewNode
 * @param viewDocument
 * @returns
 */

function useView(controller, viewNode, viewDocument, isSelected) {
  /**************************************************************************************\
  *                                                                                      *
  *                                                                                      *
  *         Render with hots$                                  Render with props         *
  *                                                                                      *
  *           +------------+                                     +------------+          *
  *           |    hot$    |                                     |   props    |          *
  *           |  +-------+ |                                     |            |          *
  *           |  |  hot  | |                                     | +--------+ |          *
  *           |  +-------+ |                                     | |document| |          *
  *           |  +-------+ |             .-------.               | +--------+ |          *
  *           |  |  hot  | |<--observe--( <Node/> )<---inject----|            |          *
  *           |  +-------+ |             `-------'               | +--------+ |          *
  *           |  +-------+ |                                     | |  node  | |          *
  *           |  |  hot  | |                                     | +--------+ |          *
  *           |  +-------+ |                                     |            |          *
  *           +------------+                                     +------------+          *
  *                  |                                                  |                *
  *                  |                                                  |                *
  *                  v                                                  v                *
  *            .-----------.                                      .-----------.          *
  *      +----( isViewHot?  )-----+                      +---Y---(  hasHots?   )--+      *
  *      N     `-----------'      Y                      |        `-----------'   |      *
  *      |                        |                      |                        |      *
  *      v                        v                      v                        |      *
  * +--------+            +--------------+         .-----------.                  |      *
  * |        |            |              |   +----(isInsideHot? )                 |      *
  * | silent |            |recalculateView|   |     `-----------'                  |      *
  * |        |            |              |   |           |                        |      *
  * +--------+            +--------------+   |           N                        N      *
  *                               |          Y           v                        |      *
  *                               v          |      +--------+                    |      *
  *                      +------------------+|      |        |                    |      *
  *                      | {node, document} ||      | silent |                    |      *
  *                      +------------------+|      |        |                    |      *
  *                                |         |      +--------+                    |      *
  *                                v         v                                    |      *
  *                             +------------------------+                        |      *
  *                             |                        |                        |      *
  *                             | render(node, document) |<-----------------------+      *
  *                             |                        |                               *
  *                             +------------------------+                               *
  *                                                                                      *
  \**************************************************************************************/
  const [, forceUpdate] = React.useReducer(c => !c, false);
  const selectedRef = React.useRef(isSelected);
  const onHots = React.useCallback(() => {
    if (controller.isViewHot(viewNode)) {
      // 若正在框选节点，其选中态未发生变化，则不重渲
      if (controller.pendingType === exports.PendingType.selection && controller.value.selection.isExpanded) {
        const prevSelected = selectedRef.current;
        const {
          node,
          document
        } = controller.getView(viewNode, viewDocument, false);
        selectedRef.current = isSelectionInNode(node, document, controller.value.selection);

        if (prevSelected === selectedRef.current) {
          return;
        }
      }

      forceUpdate();
    }
  }, [controller, viewNode, viewDocument, isSelected, forceUpdate]);
  useHots(controller, onHots, undefined, !Block.isBlock(viewNode));

  if (!controller.hasHots()) {
    return {
      node: viewNode,
      document: viewDocument,
      isSelected
    };
  }

  controller.removeIsSelected(viewNode.key); // 重渲时，若节点为热区节点，需要重算其视图模型

  if (controller.isViewHot(viewNode)) {
    const {
      node,
      document
    } = controller.getView(viewNode, viewDocument, true);
    let selected = false;

    if (controller.pendingType === exports.PendingType.input) {
      selected = true;
    } else if (controller.pendingType === exports.PendingType.selection && controller.value.selection.isExpanded) {
      // 这种情况已经计算完成，直接使用缓存
      selected = selectedRef.current;
    } else {
      selected = isSelectionInNode(node, document, controller.value.selection);
    }

    selectedRef.current = selected;

    if (selected) {
      controller.addIsSelected(viewNode.key);
    }

    return {
      node,
      document,
      isSelected: selected
    };
  } // 重渲时，若节点非热区，则返回缓存的视图模型


  const {
    node,
    document
  } = controller.getView(viewNode, viewDocument, false);
  selectedRef.current = isSelected;
  return {
    node,
    document,
    isSelected
  };
}

const GroupWrapper = props => {
  const {
    children,
    node
  } = props;
  const isCollapsed = useGroupData(node, groups => {
    const group = groups.find(g => g.key === node.key);
    return group?.data[GROUP_COLLAPSED_KEY];
  }, false);
  return /*#__PURE__*/React__namespace.cloneElement(children, {
    isCollapsed
  });
};

const _createElement$3 = React__namespace.createElement;

function isComposingMark({
  type
}) {
  return type === 'cangjieComposing';
}

function isNotComposingMark(mark) {
  return !isComposingMark(mark);
}

const checkRerenderNodesBySelectionChange = memoizeOne__default["default"]((prevSelection, selection, prevDocument, document) => {
  const shouldRenderNodeKeys = new Set();
  const {
    start,
    end
  } = selection.convertToTextPoints(document);
  const {
    start: prevStart,
    end: prevEnd
  } = prevSelection.convertToTextPoints(document);

  if (selection === prevSelection) {
    return shouldRenderNodeKeys;
  }

  if (start !== prevStart) {
    shouldRenderNodeKeys.add(start.key);
    const startAnchestors = document.getAncestors(start.key);
    startAnchestors.forEach(anchestor => {
      shouldRenderNodeKeys.add(anchestor.key);
    });
    shouldRenderNodeKeys.add(prevStart.key);
    const prevStartAnchestors = document.getAncestors(prevStart.key);
    prevStartAnchestors.forEach(anchestor => {
      shouldRenderNodeKeys.add(anchestor.key);
    });
  }

  if (end !== prevEnd) {
    shouldRenderNodeKeys.add(end.key);
    const endAnchestors = document.getAncestors(end.key);
    endAnchestors.forEach(anchestor => {
      shouldRenderNodeKeys.add(anchestor.key);
    });
    shouldRenderNodeKeys.add(prevEnd.key);
    const prevEndAnchestors = document.getAncestors(prevEnd.key);
    prevEndAnchestors.forEach(anchestor => {
      shouldRenderNodeKeys.add(anchestor.key);
    });
  }

  return shouldRenderNodeKeys;
}); // TODO: 等 selectionLayer 提到 content，修改这里的判断逻辑

function shouldComponentUpdate(prevProps, nextProps) {
  const {
    controller
  } = prevProps;
  const shouldUpdate = controller.run('shouldNodeComponentUpdate', prevProps, nextProps);
  const n = nextProps;
  const p = prevProps;

  if (shouldUpdate !== null) {
    if (shouldUpdate) {
      return true;
    }

    if (process.env.NODE_ENV === 'development') {
      warning__default["default"](shouldUpdate !== false, "Returning false in `shouldNodeComponentUpdate` does not disable Cangjie's internal `shouldComponentUpdate` logic. If you want to prevent updates, use React's `shouldComponentUpdate` instead.");
    }
  }

  if (n.node !== p.node) {
    return true;
  }

  if (n.visible !== p.visible) {
    return true;
  }

  const isSelectionPending = controller.pendingType === exports.PendingType.selection; // 当存在 Hots & Pending 时，节点的重渲会存在两个诱因：
  // 1. 外部 Props 重渲
  // 2. 内部受 Hots & Pending 的控制重渲
  //
  // 假定节点树为：
  // ```tsx
  //   <value>
  //   <document>
  //     <block type="paragrah" key="p0">
  //       <block type="paragraph" key="hello">
  //         <text key="hello-text">Hello</text>
  //       </block>
  //       <block type="paragraph" key="world">
  //         <text key="world-text">World</text>
  //         <cursor />
  //       </block>
  //     </block>
  //     <block type="paragraph" key="p1">
  //       <block type="paragraph" key="cangjie">
  //         <text key="cangjie-text">Cangjie</text>
  //       </block>
  //     </block>
  //   </document>
  // </value>
  //```
  //
  // 1. 当光标从 `world-text` 移动到 `hello-text`：计算热区为 ['world', 'hello']，且开始选区 Pending
  //   1.1 Hots 驱动 `world` 组件树重渲：`world` 未选中
  //     * `world-text` 因为 props 变更而重渲 `prevProps.isSelected !== nextProps.isSelected`
  //   1.2 Hots 驱动 `hello` 组件树重渲：`hello` 选中
  //     * `hello-text` 因为 props 变更而重渲 `prevProps.isSelected !== nextProps.isSelected`
  //
  // 2. 当光标从 `hello-text` 移动到 `cangjie-text`：计算热区为 ['p0', 'p1']
  //    2.1 Hots 驱动 `p0` 组件树重渲：`p0` 节点树取消选中
  //      * `hello` 重渲，且 `prevProps.isSelected === nextProps.isSelectd === false`，但由于 `hello` 在 pending 期间被选中，因此 `hello` 应重渲以取消选中态
  //      * `hello` 组件树重渲...
  //    2.2 Hots 驱动 `p1` 组件树重渲：`p1` 节点树选中
  //      * `cangjie` 重渲，且 `prevProps.isSelectd !== nextProps.isSelected`，因此 `cangjie 重渲`
  //      * `cangjie` 组件树重渲..
  //

  if (isSelectionPending) {
    const pendingSelected = controller.getIsSelected(n.node.key);

    if (p.isSelected === n.isSelected) {
      return p.isSelected !== pendingSelected;
    }
  } // 1. 考虑节点树及其选中态为：
  // ```tsx
  // <value>
  //   <document>
  //     <block key="container" type="container" isSelected={true}>
  //       <block key="hello" type="paragraph" isSelected={true}>Hello</block>
  //       <block key="world" type="paragraph" isSelected={false}>World</block>
  //       <block key="cangjie" type="paragprah">Cangjie</block>
  //     </block>
  //   </document>
  // </value>
  // ```
  // 当选区从 `hello` 移动到 `world` 时，节点重渲的顺序为
  //   * `container` 因为选中态而重渲：为了保证其内部发生的选区变化也能响应，因此重渲 `container`
  //   * `hello` 选中态变化，重渲 `hello`
  //   * `world` 选中态变化，重渲 `world`
  //   * `cangjie` 选中态未变化，不重渲
  // ```tsx
  // <value>
  //   <document>
  //     <block key="container" type="container" isSelected={true}>
  //       <block key="hello" type="paragraph" isSelected={true}>Hello</block>
  //       <block key="world" type="paragraph">World</block>
  //       <block key="cangjie" type="paragraph">Cangjie</block>
  //     </block>
  //   </document>
  // </value>
  // ```
  // 
  // 2. 考虑节点树及其选中态为：
  // ```tsx
  // <value>
  //   <document>
  //     <block key="container1" type="container" isSelected={true}>
  //       <block key="hello" type="paragraph" isSelected={true}>Hello</block>
  //       <block key="world" type="paragraph"}>World</block>
  //     </block>
  //     <block key="container2" type="container">
  //       <block key="cangjie" type="paragraph">Cangjie</block>
  //     </block>
  //   </document>
  // </value>
  // ```
  // 当选区从 `container1` 移动到 `cangjie` 时，节点重渲的顺序为
  //   * `container1` 因为要取消选中而重渲：为了保证取消选中后，其内部节点的选中态也能取消，因此重渲 `container1`
  //     * `hello` 选中态变化，重渲 `hello`
  //     * `world` 选中态未变化，不重渲 `world`
  //   * `container2` 因为选中态变化重渲：为了保证其内部发生的选区变化也能响应，因此重渲 `container`
  //     * `cangjie` 因为选中态变化而重渲
  // ```tsx
  // <value>
  //   <document>
  //     <block key="container" type="container" isSelected={true}>
  //       <block key="hello" type="paragraph" isSelected={true}>Hello</block>
  //       <block key="world" type="paragraph" isSelected={false}>World</block>
  //       <block key="cangjie" type="paragprah">Cangjie</block>
  //     </block>
  //   </document>
  // </value>
  // ```


  if (n.prevValue?.selection) {
    const shouldRenderSets = checkRerenderNodesBySelectionChange(n.prevValue.selection, n.value.selection, p.document, n.document);

    if (shouldRenderSets.has(n.node.key)) {
      return true;
    }
  }

  if (n.prevValue?.isFocused !== n.value.isFocused) {
    return n.isSelected !== p.isSelected || n.isSelected || p.isSelected;
  }

  return n.isSelected !== p.isSelected;
}

function renderLeaves(parent, node, controller) {
  const {
    value
  } = controller;
  const {
    composing
  } = value;
  const {
    leaves
  } = node;
  const ls = [];
  let nextStartOffset = 0;

  for (let i = 0; i < leaves.length; i += 1) {
    const leaf = leaves[i];
    const startOffset = nextStartOffset;
    nextStartOffset += leaf.text.length;
    const hasComposingMark = leaf.marks.some(isComposingMark);
    const text = leaf.text || CANGJIE_EMPTY;
    const children = [hasComposingMark ? /*#__PURE__*/_createElement$3("u", {
      "data-cangjie-composing": true
    }, text) : text];

    if (composing) {
      const marks = leaf.marks.filter(isNotComposingMark);

      while (i + 1 < leaves.length) {
        const nextLeaf = leaves[i + 1];
        const nextHasComposingMark = nextLeaf.marks.some(isComposingMark);
        const marksWithoutComposing = nextHasComposingMark ? nextLeaf.marks.filter(isNotComposingMark) : nextLeaf.marks;

        if (!equal__default["default"](marks, marksWithoutComposing)) {
          break;
        }

        i += 1;
        nextStartOffset += nextLeaf.text.length;
        children.push(nextHasComposingMark ? /*#__PURE__*/_createElement$3("u", {
          "data-cangjie-composing": true
        }, nextLeaf.text) : nextLeaf.text);
      }
    }

    ls.push(renderLeaf(controller, parent, node, leaf, /*#__PURE__*/_createElement$3(React__namespace.Fragment, null, children), startOffset));
  }

  return ls;
}

const NodeComponent = /*#__PURE__*/React__namespace.memo(props => {
  const {
    controller,
    parent,
    path,
    composing,
    prevValue,
    visible = true
  } = props;
  const {
    value,
    enablePending,
    virtualizeManager
  } = controller;
  const {
    selection
  } = value;
  let {
    node,
    document
  } = props;
  const ref = useCangjieKeyBindingRef(node.key);
  const [pendingElements, updatePendingElements] = React__namespace.useState({
    document,
    node
  }); // @ts-ignore

  const fold = Block.isBlock(node) ? useUserData(node, 'fold') || false : false;
  const hidden = useGroupData(node, groups => {
    return groups.some(group => isGroupCollapsed(group) && group.key !== node.key);
  }, fold);
  const finalVisible = visible !== false && !hidden;
  const {
    node: view,
    document: viewDocument,
    isSelected
  } = useView(controller, node, document, props.isSelected);
  const {
    inputData$
  } = controller; // 监听输入缓冲数据流

  useInputPending({
    node,
    document
  }, path, controller, enablePending.input, inputData$, updatePendingElements);

  if (controller.enableVirtualize && virtualizeManager) {
    const {
      nodeManager: virtualizeNodeManager
    } = virtualizeManager;
    const path = document.getPath(node.key);

    if (path) {
      const topPath = path.slice(0, 1);
      const topBlock = document.getNodeByPath(topPath); // 是顶层节点

      if (node === topBlock) {
        const virtualizePersistState = virtualizeNodeManager.getVirtualizePersistState(topBlock.key);
        virtualizePersistState.forEach(childNodeKey => {
          const childNode = document.getNode(childNodeKey);

          if (topBlock.hasNode(childNodeKey) && childNode && controller.query('shouldPersistState', {
            node: childNode
          })) {
            virtualizeNodeManager.updateVirtualizePersistState(childNodeKey, topBlock.key, true);
          } else {
            virtualizeNodeManager.updateVirtualizePersistState(childNodeKey, topBlock.key, false);
          }
        });
      }

      const shouldPersistState = controller.query('shouldPersistState', {
        node
      });

      if (shouldPersistState) {
        virtualizeNodeManager.updateVirtualizePersistState(node.key, topBlock.key, true);
      }
    }
  } // 输入缓冲开始，使用 pending node


  if (Block.isLeafBlock(props.node) && controller.isPending && controller.pendingType === exports.PendingType.input) {
    node = pendingElements.node;
    document = pendingElements.document;
  } // 如果使用热区技术，使用热区重算的模型


  if (controller.enableHots) {
    node = view;
    document = viewDocument;
  }

  const blockStyle = useNodeStyle(controller, node, finalVisible);

  const children = () => {
    const n = node.toSubType();

    if (n.isElement()) {
      const childrenIsSelected = getChildrenIsSelected(document, n, selection);
      const renderedChildren = n.nodes.map((n, i) => renderNode(controller, value, document, node, n, path.concat(i), childrenIsSelected[i], finalVisible, prevValue));
      return renderedChildren;
    }

    return renderLeaves(parent, n, controller);
  };

  if (Text$1.isText(node)) {
    if (process.env.NODE_ENV === 'test') {
      // 服务于 Test 环境下对 text 渲染的监听
      controller.run('renderText', {
        node
      });
    }

    return /*#__PURE__*/_createElement$3(React__namespace.Fragment, null, children());
  }

  const isVoid = controller.query('isVoid', node);
  const isNonEmptyBlock = Block.isBlock(node) && !!node.nodes.length;
  const isLeafBlock = isNonEmptyBlock && Block.isLeafBlock(node);
  const isSelectable = isNonEmptyBlock && controller.query('isEdgeSelectable', node);
  const binding = {
    ref,
    [Selector.key]: node.key
  };
  const attributes = {
    key: node.key
  };
  const attributesWithBinding = { ...attributes,
    ...binding
  };
  let nonVoidAttributes = attributesWithBinding;

  if (isLeafBlock) {
    nonVoidAttributes = { ...nonVoidAttributes,
      style: blockStyle,
      [Selector.leafBlock]: true,
      [Selector.uuid]: controller.query('anchor', node)
    };
  }

  if (isSelectable) {
    nonVoidAttributes = { ...nonVoidAttributes,
      style: blockStyle,
      [Selector.uuid]: controller.query('anchor', node),
      [Selector.edgeSelectable]: true
    };
  }

  const element = controller.run('renderNode', {
    controller,
    attributes: isVoid ? attributes : nonVoidAttributes,
    composing,
    isSelected,
    parent,
    node,
    path,
    children,
    visible: finalVisible
  });

  if (element === null) {
    return null;
  }

  if (isVoid) {
    return /*#__PURE__*/_createElement$3(VoidWrapper, _extends__default["default"]({}, props, {
      attributes: attributesWithBinding
    }), element);
  }

  if (node.isElement()) {
    const group = controller.groupManager.getGroup(node.key);

    if (group) {
      const props = {
        controller,
        node,
        path,
        group,
        isCollapsed: false,
        isEmpty: isGroupEmpty(controller, { ...group,
          key: node.key
        }),
        attributes: {
          [Selector.groupKey]: node.key
        },
        children: () => element,
        visible: finalVisible
      };
      const groupElement = controller.run('renderGroup', props);

      if (groupElement) {
        return /*#__PURE__*/_createElement$3(GroupWrapper, {
          node: node
        }, groupElement);
      }
    }
  }

  return element;
}, (prevProps, nextProps) => !shouldComponentUpdate(prevProps, nextProps));

function renderLeaf(controller, parent, text, leaf, child, offset) {
  const {
    composing
  } = controller.value;
  const leafKey = `${text.key}:${offset}`;

  const initialChild = /*#__PURE__*/_createElement$3(LeafComponent, {
    key: leafKey,
    leafKey: leafKey
  }, child);

  const children = leaf.marks.reduce((child, mark) => controller.run('renderMark', {
    parent,
    node: text,
    offset,
    composing,
    mark,
    marks: leaf.marks,
    text: leaf.text,
    children: () => child
  }), initialChild);
  return children;
}

function renderNode(controller, value, document, parent, node, path, isSelected, visible = true, prevValue) {
  const {
    composing
  } = value;

  const comp = /*#__PURE__*/_createElement$3(NodeComponent, {
    key: node.key,
    controller: controller,
    value: value,
    document: document,
    parent: parent,
    node: node,
    path: path,
    composing: composing,
    isSelected: isSelected,
    visible: visible,
    prevValue: prevValue
  });

  return comp;
}

const _createElement$2 = React__default["default"].createElement;
const VirtualizePlaceholder = props => {
  const {
    height = 0
  } = props;
  return /*#__PURE__*/_createElement$2("div", {
    "data-cangjie-virualize-placeholder": true,
    style: {
      height
    }
  });
};

function useVirtualize(controller, containerRef, getScrollableContainer) {
  const {
    virtualizeManager,
    enableVirtualizeView
  } = controller;
  const [virtualizeId, setVirtualizeId] = React.useState(0);
  React.useEffect(() => {
    if (!virtualizeManager) {
      return;
    }

    if (enableVirtualizeView) {
      virtualizeManager.initView({
        scrollContainer: getScrollableContainer(),
        editorContainer: containerRef.current,
        triggerViewUpdate: setVirtualizeId
      });
      virtualizeManager.start();
    } else {
      virtualizeManager.stop();
    }

    return;
  }, [enableVirtualizeView, virtualizeManager]);

  if (!enableVirtualizeView || !virtualizeManager) {
    return null;
  }

  const {
    outputManager
  } = virtualizeManager;
  const {
    beforePlaceholderHeight,
    afterPlaceholderHeight,
    visibles
  } = outputManager;
  const virtualizeResult = {
    virtualizeId: typeof virtualizeManager.virtualizeId === 'number' ? virtualizeManager.virtualizeId : virtualizeId,
    beforePlaceholderHeight,
    afterPlaceholderHeight,
    visibles
  };
  return [virtualizeResult, setVirtualizeId];
}

const _createElement$1 = React__namespace.createElement;

const arePropsEqual = (prevProps, nextProps) => {
  const {
    selection: prevSelection,
    document: prevView,
    isFocused: prevIsFocused
  } = prevProps;
  const {
    selection: nextSelection,
    document: nextView,
    isFocused: nextIsFocused,
    controller
  } = nextProps; // 有热区时，不更新，内容交给节点子树自行更新

  if (controller.hasHots()) {
    return true;
  }

  return equal__default["default"](prevSelection, nextSelection) && prevView === nextView && prevIsFocused === nextIsFocused;
};

const EditableContent = /*#__PURE__*/React__namespace.memo(props => {
  const {
    controller,
    contentRef: ref,
    getScrollableContainer,
    selection,
    document
  } = props;
  const {
    value
  } = controller;
  const prevValue = React__namespace.useRef();
  React__namespace.useEffect(() => {
    prevValue.current = value;
  }, [value]);
  const childrenIsSelected = getChildrenIsSelected(document, document, selection);
  const editableRef = useCangjieKeyBindingRef(props[Selector.key]); // HACK: use `useCombinedRefs` will break `useCangjieKeyBindingRef`.

  React__namespace.useLayoutEffect(() => {
    if (!ref) {
      return;
    }

    if (typeof ref === 'function') {
      ref(editableRef.current);
    } else {
      ref.current = editableRef.current;
    }
  });
  const useVirtualizeResult = useVirtualize(controller, editableRef, getScrollableContainer);
  const {
    virtualizeId = -1,
    beforePlaceholderHeight = 0,
    afterPlaceholderHeight = 0,
    visibles = null
  } = useVirtualizeResult ? useVirtualizeResult[0] : {};
  const virtualizeAttr = React__namespace.useMemo(() => {
    return controller.enableVirtualize ? {
      "data-virtualize-id": virtualizeId
    } : {};
  }, [controller.enableVirtualize, virtualizeId]); // 因为任何原因拿不到虚拟化结果，走非虚拟化分支

  if (useVirtualizeResult === null || virtualizeId === -1) {
    const children = document.nodes.map((child, index) => renderNode(controller, value, document, document, child, [index], childrenIsSelected[index], true, prevValue.current));
    return /*#__PURE__*/_createElement$1(React__namespace.Fragment, null, /*#__PURE__*/_createElement$1("div", {
      ref: editableRef,
      "data-cangjie-key": document.key,
      "data-cangjie-editable": true
    }, children));
  }

  const {
    blockFinalVisibleStates
  } = visibles;
  const children = document.nodes.map((child, index) => {
    const blockFinalVisibleState = blockFinalVisibleStates[index];
    const visible = blockFinalVisibleState === 'show';

    if (blockFinalVisibleState === 'destroy') {
      return null;
    }

    return renderNode(controller, value, document, document, child, [index], childrenIsSelected[index], visible, prevValue.current);
  });
  return /*#__PURE__*/_createElement$1(React__namespace.Fragment, null, /*#__PURE__*/_createElement$1("div", _extends__default["default"]({
    ref: editableRef,
    "data-cangjie-key": document.key,
    "data-cangjie-editable": true
  }, virtualizeAttr), controller.enableVirtualize ? /*#__PURE__*/_createElement$1(VirtualizePlaceholder, {
    height: beforePlaceholderHeight
  }) : null, children, controller.enableVirtualize ? /*#__PURE__*/_createElement$1(VirtualizePlaceholder, {
    height: afterPlaceholderHeight
  }) : null));
}, arePropsEqual);

/* eslint-disable @typescript-eslint/consistent-type-definitions */

const FOCUS_SCROLL_DELAY = 300; // 移动端弹键盘时，等待 visual viewport change 的最大时间

const MAX_VIEWPORT_WAIT_TIME = 3000;

/**
 * 移动端处理「点击后，滚动视口到光标」的逻辑
 * 这里需要等待键盘弹出后，才能计算跳转，因此依赖了 visual viewbox
 * 如果不支持 visual viewbox，就用 setTimeout
 */
function useClickToScroll() {
  const scrollerRef = React__default["default"].useRef(null); // resize 事件发生。这里看如果有 scrollerRef，就开始滚动

  const handleResize = React__default["default"].useCallback(() => {
    if (scrollerRef.current) {
      const {
        callback,
        waitTimer
      } = scrollerRef.current;
      callback();
      clearTimeout(waitTimer);
      scrollerRef.current = null;
    }
  }, []); // 注册 visual box 事件

  React__default["default"].useEffect(() => {
    if (!window.visualViewport) {
      return undefined;
    }

    window.visualViewport.addEventListener('resize', handleResize);
    return () => {
      window.visualViewport.removeEventListener('resize', handleResize);
    };
  }, [handleResize]);
  const scheduler = React__default["default"].useCallback(callback => {
    if (scrollerRef.current) {
      clearTimeout(scrollerRef.current.waitTimer);
    }

    if (window.visualViewport) {
      // 如果支持 visualViewport 就开始检测 size 变化
      const fallbackCall = () => {
        scrollerRef.current = null;
      };

      const waitTimer = setTimeout(fallbackCall, MAX_VIEWPORT_WAIT_TIME);
      scrollerRef.current = {
        callback,
        waitTimer
      };
    } else {
      // 不支持的话，就用 setTimeout
      setTimeout(callback, FOCUS_SCROLL_DELAY);
    }
  }, []);
  return scheduler;
}

const ScrollableContentContext = /*#__PURE__*/React.createContext(null);
/**
 * 滚动内容，默认是body
 */

function useScrollableContent() {
  return React.useContext(ScrollableContentContext);
}

const _createElement = React__default["default"].createElement;
const EVENT_HANDLERS = ['onDrop', 'onMouseMove'];
const editorStyle = {
  position: 'relative',
  whiteSpace: 'pre-wrap',
  wordWrap: 'break-word',
  cursor: 'text',
  userSelect: 'none',
  WebkitUserSelect: 'none',
  WebkitTapHighlightColor: 'transparent'
};
const CLIPBOARD_IDENTIFIER = '<article class="4ever-article" data-clipboard-cangjie';

function useWindowEvent(type, handler) {
  React__default["default"].useEffect(() => {
    window.addEventListener(type, handler);
    return () => window.removeEventListener(type, handler);
  }, [handler, type]);
}

// 多编辑器实例需要共享
let touchStartFlag = false;
/**
 * 是否 Event 不需要被拦截
 * @param target
 */

function isNotEditable(target) {
  let el;

  try {
    // COMPAT: 兼容在某些 Firefox 下，target 无法获取 `.closet()` 方法导致 crash
    if (target.nodeType === 8) {
      return true;
    } // COMPAT: 如果 event target 是 Text Node，则判断其父节点


    el = target.nodeType === 3 ? target.parentNode : target;
  } catch (err) {
    return true;
  }

  return !el || findClosestInContent(el, `[${Selector.notEditable}]`);
}
/**
 * target 是否一个 Input 或者 TextArea
 */


function isInputTarget(target) {
  return target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement;
}

function useCombinedRefs(...refs) {
  const targetRef = React__default["default"].useRef();
  React__default["default"].useLayoutEffect(() => {
    refs.forEach(ref => {
      if (!ref) return;

      if (typeof ref === 'function') {
        ref(targetRef.current);
      } else {
        ref.current = targetRef.current;
      }
    });
  }, [refs]);
  return targetRef;
} // 避免没有意义的复制、剪切


const isValidCopyOrCut = controller => {
  const {
    selection,
    document
  } = controller.value;

  if (selection.isExpanded) {
    return true;
  }

  const node = document.getParent(selection.focus.key);

  if (!node) {
    return false;
  }

  const isVoid = controller.query('isVoid', node);
  return Boolean(isVoid);
};

var _ref = /*#__PURE__*/_createElement("div", {
  "data-cangjie-hidden": true,
  "data-cangjie-zoomer": true
});

const Content = /*#__PURE__*/React__default["default"].forwardRef((props, ref) => {
  const containerRef = React__default["default"].useRef(null);
  const combinedContainerRef = useCombinedRefs(containerRef, ref);
  const contentRef = React__default["default"].useRef(null);
  const scrollableContainerRef = React__default["default"].useRef(null);
  const textareaRef = React__default["default"].useRef(null);
  const prevWindowHeight = React__default["default"].useRef(window.innerHeight);
  const prevWindowWidth = React__default["default"].useRef(window.innerWidth);
  const [isTextareaDisabled, setIsTextareaDisabled] = React__default["default"].useState(false);
  const controller = useController();
  const {
    readOnly,
    value,
    autoFocus
  } = controller;
  const docStyle = useContentStyle(controller);
  const {
    selection,
    isFocused
  } = value;
  const document = controller.view;
  const {
    className,
    tagName: Container = 'div',
    tabIndex = 0,
    zoom = 1,
    style: customStyle = {},
    defaultStyle,
    getScrollableContainer = () => window
  } = props;
  const handlers = EVENT_HANDLERS.reduce((hdls, type) => ({ ...hdls,
    [type]: event => controller.run(type, event)
  }), {}); // CSS transform只允许内部设置，禁止外部设置

  let zoomStyle = {};

  if (typeof zoom === 'number' && zoom !== 1) {
    zoomStyle = {
      transform: `scale(${zoom})`,
      transformOrigin: '0 0'
    };
  } // 移动端的 textarea focus 会触发视图的滚动，且 preventScroll not working，在 readonly 模式下禁止 focus
  // TODO: 关于 textarea 的滚动控制可以参考 Google Docs 的 iframe 方案


  const disableNativeFocus = readOnly && IS_MOBILE;
  const selectionCalculator = useSelectionCalculator(controller, textareaRef, scrollableContainerRef);
  const inputDetector = useInputDetector(controller, textareaRef);

  const handleClickToFocus = event => {
    if (isNotEditable(event.target) && event.target === window.document.activeElement) {
      // 不干扰节点自己的 focus 逻辑
      return;
    }

    if (!readOnly) {
      controller.run('onCangjieFocus');
    }

    const textarea = textareaRef.current;

    if (controller.value.isFocused && !disableNativeFocus) {
      // HACK: `.focus` only works in mouse event handler on mobile.
      textarea?.focus({
        preventScroll: true
      });
    }

    controller.run('onClick', event);
  };

  const handleMouseDown = event => {
    if (isNotEditable(event.target)) return;
    controller.run('onMouseDown', event);

    if (!event.defaultPrevented) {
      event.preventDefault();
      inputDetector.onCompositionEnd();
      selectionCalculator.onSelectStart(event);
      selectionCalculator.onMultipleClick(event);
    }
  };

  const handleMouseUp = event => {
    if (isNotEditable(event.target)) return;
    controller.run('onMouseUp', event);
  };

  const handleKeyDown = event => {
    if (isNotEditable(event.target)) return;

    if (!readOnly) {
      if (controller.value.composing) {
        controller.perfStart({
          type: PerfType.composing
        });
      } else if (controller.pendingType === exports.PendingType.input) {
        const payload = hotkeys.isDeleteBackward(event) || hotkeys.isDeleteForward(event) ? {
          type: PerfType.input,
          subtype: 'delete'
        } : {
          type: PerfType.input
        };
        controller.perfStart(payload);
      }

      const shouldContinue = inputDetector.onKeyDown(event);

      if (shouldContinue === false) {
        return;
      } // 目前许多的编辑行为在 onKeyDown 事件中，所以暂时禁止掉
      // TODO: 将编辑行为的 onKeyDown 事件和选区交互行为分离 @展炤


      controller.run('onKeyDown', event);
    }

    if (!event.defaultPrevented) {
      selectionCalculator.onKeyDown(event);
    }
  };

  const handleKeyUp = event => {
    if (isNotEditable(event.target)) return;
    selectionCalculator.onKeyUp(event);
    controller.run('onKeyUp', event);
  };

  const handleTouchStart = event => {
    if (isNotEditable(event.target)) return;
    selectionCalculator.onTapHoldStart(event);
    controller.run('onTouchStart', event);
  };

  const handleTouchMove = event => {
    if (isNotEditable(event.target)) return;
    selectionCalculator.onTapHoldEnd();
    controller.run('onTouchMove', event);
  };

  const handleTouchEnd = event => {
    if (isNotEditable(event.target)) return;
    selectionCalculator.onTapHoldEnd();
    controller.run('onTouchEnd', event);
  };

  const handleTouchStartCapture = () => {
    touchStartFlag = true;
  };

  const handleTouchEndCapture = () => {
    touchStartFlag = false;
  };

  const handleContextMenu = event => {
    if (isNotEditable(event.target) || isInputTarget(event.target)) {
      return;
    }

    const {
      isCollapsed
    } = controller.value.selection;

    if (!readOnly) {
      controller.run('onCangjieFocus');
    }

    if (isCollapsed) {
      controller.run('onClick', event);
    }

    controller.run('onContextMenu', event);
  };

  const handleDragStart = event => {
    if (isNotEditable(event.target)) return;
    controller.run('onDragStart', event);
  };

  const handleDragOver = event => {
    // PERF: just allow drop
    if (!event.defaultPrevented) {
      event.preventDefault();
    }
  };

  const handleDrop = event => {
    if (isNotEditable(event.target)) return;
    controller.run('onDrop', event);
  };

  const handleDragEnter = event => {
    if (isNotEditable(event.target)) return;
    controller.run('onDragEnter', event);
  };

  const handleCopy = React__default["default"].useCallback(event => {
    if (!isValidCopyOrCut(controller)) {
      event.preventDefault();
      return;
    }

    controller.run('onCopy', event);
  }, [controller]);
  const handleCut = React__default["default"].useCallback(event => {
    if (!isValidCopyOrCut(controller)) {
      event.preventDefault();
      return;
    }

    controller.run('onCut', event);
  }, [controller]);
  const scheduleScroll = useClickToScroll();
  const handleFocus = React__default["default"].useCallback(() => {
    controller.run('onCangjieFocus'); // BACKGROUND:
    //   Android 中，点击非工具栏区域 blur 后，再 focus 回编辑器
    //   会出现 textarea.value === ' ' && textarea.selectionStart === 0 的情况
    //   导致无法删除文字，输入文字后会吞掉光标前一个字
    // 所以必须要在 focus 时 reset，而不是 blur 时

    inputDetector.reset(); // Should reset `textarea` to **EMPTY**.

    if (!IS_MOBILE) {
      return;
    }

    const scrollToCaret = () => {
      const {
        selection: currentSelection
      } = controller.value;

      if (!currentSelection || !containerRef.current || !scrollableContainerRef.current || readOnly) {
        return;
      }

      scrollToSelection(currentSelection, containerRef.current, scrollableContainerRef.current, controller);
    };

    scheduleScroll(scrollToCaret);
  }, [controller, inputDetector, readOnly, scheduleScroll]);

  const handleBlur = () => {
    const textarea = textareaRef.current;

    if (touchStartFlag && textarea) {
      textarea.focus({
        preventScroll: true
      });
      touchStartFlag = false;
      return;
    } // 此处是浏览器 bug，blur 时没有触发 compositionend，要手动触发
    // https://w3c.github.io/uievents/#compositionend
    // 由于 disabled 会导致切换应用后无法自动 focus
    // 所以只在 composing 期间才执行 compositionEnd


    if (value.composing) {
      triggerCompositionEnd();
    } // 只读模式下，如果用户在同页面点了其它内容，则先取消选区


    if (readOnly && window.document.activeElement !== textarea) {
      const newSelection = controller.value.selection.moveToFocus();
      controller.run('onCangjieSelect', CangjieSelectEvent({
        selection: newSelection
      }));
    }

    controller.run('onCangjieBlur');
  }; // 安卓下通过返回键/收起键 收起的键盘，不会触发失焦，再点击也不会触发focus
  // 不过失焦触发的键盘收起仍然能通过 iOS 逻辑 handle
  // 其余只能通过 resize 事件监听键盘的弹起
  // 安卓下分屏模式、折叠屏机很常见，也经常横竖屏切换，很大程度不能保证 resize 是键盘引发
  // 符合以下两个条件再触发滚动最大程度保证行为符合用户预期：
  // 1、resize 只是高度发生减小宽度未变 2、之前光标在视野内，resize 后不在视野内了


  const handleWindowResize = () => {
    const {
      selection: rs,
      isBlurred
    } = controller.value;

    if (isBlurred || !rs || !containerRef.current || !scrollableContainerRef.current) {
      return;
    }

    const height = window.innerHeight;
    const width = window.innerWidth;
    const previousHeight = prevWindowHeight.current;
    const previousWidth = prevWindowWidth.current;
    prevWindowHeight.current = height;
    prevWindowWidth.current = width;

    if (!IS_ANDROID || height >= previousHeight || previousWidth !== width) {
      return;
    }

    const rect = getDOMRectFromSelection(rs, containerRef.current, controller);

    if (!rect) {
      return;
    }

    if (rect.top < previousHeight && rect.bottom >= height) {
      scrollToSelection(rs, containerRef.current, scrollableContainerRef.current, controller);
    }
  }; // 设置 disabled 并异步取消 disabled 以取消 composing
  // 不能用 Promose.resolve() micro task 方式，会导致多编辑器互相切换时异常


  const triggerCompositionEnd = React__default["default"].useCallback(() => {
    setIsTextareaDisabled(true);
    setTimeout(() => {
      setIsTextareaDisabled(false);
    });
    inputDetector.onCompositionEnd();
  }, [inputDetector]);
  useWindowEvent('resize', handleWindowResize);
  React__default["default"].useLayoutEffect(() => {
    const textarea = textareaRef.current;

    if (!textarea) {
      return;
    }

    const isNativeFocused = window.document.activeElement === textarea;
    const isFocusedNow = controller.value.isFocused;

    if (isFocusedNow && !isNativeFocused && !disableNativeFocus) {
      textarea.focus({
        preventScroll: true
      });
    }

    if (!isFocused && isNativeFocused && window.document.hasFocus()) {
      textarea.blur();
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [isFocused]);
  React__default["default"].useLayoutEffect(() => {
    if (containerRef.current) {
      ROOT_TO_CONTROLLER.set(containerRef.current, controller);
    }
  }, [controller]);
  React__default["default"].useLayoutEffect(() => {
    if (!scrollableContainerRef.current) {
      scrollableContainerRef.current = getScrollableContainer();
      controller.scrollableContainer = scrollableContainerRef.current;
    }
  });
  React__default["default"].useEffect(() => {
    return () => {
      if (containerRef.current && ROOT_TO_CONTROLLER.has(containerRef.current)) {
        ROOT_TO_CONTROLLER.delete(containerRef.current);
      }
    };
  }, []); // 移动端只读场景下，无法监听到键盘事件，因此这里将事件绑定在 document 上
  // Ref: https://aone.alibaba-inc.com/v2/project/897543/bug/45864425#

  const isReadMode = Boolean(readOnly || controller.query('isQuickPreview'));
  React__default["default"].useEffect(() => {
    const handleReadOnlyKeyDown = event => {
      if (isNotEditable(event.target)) return;
      selectionCalculator.onKeyDown(event);
    };

    const handleReadOnlyKeyUp = event => {
      if (isNotEditable(event.target)) return;
      selectionCalculator.onKeyUp(event);
    };

    if (isReadMode && IS_MOBILE) {
      window.document.addEventListener('keydown', handleReadOnlyKeyDown);
      window.document.addEventListener('keyup', handleReadOnlyKeyUp);
    }

    return () => {
      if (isReadMode && IS_MOBILE) {
        window.document.removeEventListener('keydown', handleReadOnlyKeyDown);
        window.document.removeEventListener('keyup', handleReadOnlyKeyUp);
      }
    };
  }, [readOnly, selectionCalculator, isReadMode]); // 编辑模式下 textarea 监听输入行为

  const editableListeners = readOnly ? {} : {
    onChange: inputDetector.onChange,
    onCompositionStart: inputDetector.onCompositionStart,
    onCompositionEnd: inputDetector.onCompositionEnd,
    onCut: handleCut,
    onPaste: event => {
      event.preventDefault();
      const {
        clipboardData
      } = event; // perf: clipboardData.files 读取耗费性能，减少读取次数
      // TODO 优化 win 上

      const isCangjie = clipboardData.types.includes(MIME_TYPES.FRAGMENT) || (clipboardData.getData(MIME_TYPES.HTML) || '').includes(CLIPBOARD_IDENTIFIER);
      const isFile = clipboardData.types.includes('Files') && !isCangjie;
      /**
       * 支持异步读取 native event 对象上的数据
       * React 16 及更早版本需要调用 event.persist 方法， 参考：https://reactjs.org/docs/legacy-event-pooling.html
       * React 17 以上版本 event pool 被移除，默认支持异步读取， 参考：https://reactjs.org/blog/2020/08/10/react-v17-rc.html#no-event-pooling
       */

      if (event.persist) {
        event.persist();
      } // 粘贴的是文件，走同步事件，其他类型走异步事件


      if (window.DataTransfer && !isFile) {
        let cloneData;

        try {
          cloneData = new DataTransfer();
        } catch (e) {
          // 兼容chrome 60以下不支持的DataTransfer构造函数的版本
          cloneData = new CustomDataTransfer();
        }

        const pasteInputEvent = PasteInputEvent({});

        for (const {
          type,
          kind
        } of clipboardData.items) {
          if (kind === 'file') {
            continue;
          }

          const data = clipboardData.getData(type);
          cloneData.setData(type, data);
        } // @ts-ignore


        pasteInputEvent.clipboardData = cloneData; // @ts-ignore

        controller.run('onPaste', pasteInputEvent);
      } else {
        controller.run('onPaste', event);
      }
    }
  };
  const textareaKeys = {
    [Selector.dockey]: document.key
  }; // TODO: 在 Safari 下阅读模式会丢失内容焦点，导致键盘事件和CCP事件全部失效
  // Use jsx will lose type check

  var _ref2 = /*#__PURE__*/_createElement(EditableContent, {
    document: document,
    selection: selection,
    isFocused: isFocused,
    controller: controller,
    contentRef: contentRef,
    containerRef: containerRef,
    getScrollableContainer: getScrollableContainer
  });

  const content = _createElement(Container, { ...handlers,
    ref: combinedContainerRef,
    [Selector.content]: true,
    'data-zoom': zoom,
    className,
    style: {
      /**
       * 优先级（从低到高）：
       * editorStyle: 用于设置一些编辑器通用的样式
       * defaultStyle: 排版相关默认样式，仓颉不耦合具体排版样式，此字段仅对 bi/zhi 开放，不对外
       * docStyle: 默认全局样式，从 provider 传入的配置解析
       * customStyle: 外部传入的任意样式
       * zoomStyle: 放大时作用，因此优先级最高
       */
      ...editorStyle,
      ...defaultStyle,
      ...docStyle,
      ...customStyle,
      ...zoomStyle
    },
    onClick: handleClickToFocus,
    onMouseDown: handleMouseDown,
    onMouseUp: handleMouseUp,
    onKeyDown: handleKeyDown,
    onKeyUp: handleKeyUp,
    onTouchStart: handleTouchStart,
    onTouchMove: handleTouchMove,
    onTouchEnd: handleTouchEnd,
    onTouchStartCapture: handleTouchStartCapture,
    onTouchEndCapture: handleTouchEndCapture,
    onContextMenu: handleContextMenu,
    onDragOver: handleDragOver,
    onDrop: handleDrop,
    onDragEnter: handleDragEnter,
    onDragStart: handleDragStart
  }, IS_MOBILE ? _ref : null,
  /*#__PURE__*/

  /**
   * 阅读模式为什么要挂载 textarea 节点？
   * user-select: none 时浏览器由于丢失了原生选区，无法触发 onCopy 事件，所以这里挂载一个 readOnly 的 textarea 节点用于获取
   * 浏览器的焦点。
   */
  _createElement(HiddenTextArea
  /**
   * readonly mode disable composition and input
   * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea
   */
  , _extends__default["default"]({
    readOnly: readOnly,
    autoFocus: autoFocus && !readOnly,
    ref: textareaRef,
    tabIndex: tabIndex,
    selection: selection,
    onCopy: handleCopy,
    onFocus: handleFocus,
    onBlur: handleBlur,
    disabled: isTextareaDisabled
  }, textareaKeys, editableListeners)), controller.run('renderEditable', { ...props,
    contentRef,
    children: () => _ref2
  }), /*#__PURE__*/_createElement(SelectionLayer, {
    controller: controller,
    contentRef: combinedContainerRef,
    scrollableContainerRef: scrollableContainerRef
  }));

  const externalZoom = useExternalZoom();
  return /*#__PURE__*/_createElement(ZoomContainerContext.Provider, {
    value: containerRef.current
  }, /*#__PURE__*/_createElement(ZoomContext.Provider, {
    value: zoom * externalZoom
  }, controller.run('renderContent', { ...props,
    contentRef,
    children: () => content
  })));
});
/**
 * Cangjie Content 组件
 * (new plugin 修改)scollbaleContainer 和 scrollableContent 属于 cangjie 本身的职责，从 bi/zhi 移动到 cangjie 中
 * @returns
 */

function ContentWithContext(props) {
  const contentRef = React.useRef(null);
  const {
    getScrollableContainer = () => window,
    getScrollableContent = () => contentRef.current || window.document.body,
    ...rest
  } = props;
  return /*#__PURE__*/_createElement(ScrollableContainerContext.Provider, {
    value: getScrollableContainer()
  }, /*#__PURE__*/_createElement(ScrollableContentContext.Provider, {
    value: getScrollableContent()
  }, /*#__PURE__*/_createElement(Content, _extends__default["default"]({}, rest, {
    ref: contentRef,
    getScrollableContent: getScrollableContent,
    getScrollableContainer: getScrollableContainer
  }))));
}

Content.displayName = 'CangjieContent';

var normalizePendingConfig = (config => {
  let input = false;
  let selection = false;

  if (typeof config === 'boolean' || !config) {
    // @ts-ignore typing narrow error ????
    input = config || false; // @ts-ignore typing narrow error

    selection = config || false;
  } else {
    input = config.input || false;
    selection = config.selection || false;
  }

  return {
    input,
    selection
  };
});

/** 
 * 插件 action 创建快捷方法，解决 action 的 typing 问题
 */
// utils handler for createAction and judgeAction
const createActionHandlers = type => {
  const createAction = (payload = {}) => ({
    type,
    payload
  });

  const isAction = action => action?.type === type;

  return [createAction, isAction];
};

function getUserData(document, node, uid, key) {
  if (!Element$1.isElement(node)) {
    return undefined;
  }

  const uuid = node.data?.uuid;
  const nData = node.data[key];

  if (uid && uuid) {
    const uData = document.data.userData?.[uid]?.[uuid]?.[key];
    return uData || nData;
  }

  return nData;
}

/* eslint-disable import/first */
const GroupPlugin = {
  actions: groupActions,
  utils: groupUtils
};

class RangeSelection extends Selection {}

exports.ACTION_CLEAR_MOBILE_MENU = ACTION_CLEAR_MOBILE_MENU;
exports.Block = Block;
exports.CangjieClipboardEvent = CangjieClipboardEvent;
exports.CangjieDataTransfer = CangjieDataTransfer;
exports.CangjieInputEvent = CangjieInputEvent;
exports.CangjieSelectEvent = CangjieSelectEvent;
exports.Commands = Commands;
exports.Content = ContentWithContext;
exports.ContextMenu = contextMenu$1;
exports.Controller = Controller;
exports.DATA_CLIPBORAD_CANGJIE = DATA_CLIPBORAD_CANGJIE;
exports.Decoration = Decoration;
exports.Document = Document;
exports.EdgePoint = EdgePoint;
exports.Element = Element$1;
exports.ExternalZoomContext = ExternalZoomContext;
exports.FlushTask = FlushTask;
exports.GroupPlugin = GroupPlugin;
exports.History = History;
exports.HtmlParser = Parser;
exports.ImmutableRecord = ImmutableRecord;
exports.Injection = Injection;
exports.Inline = Inline;
exports.JsonMLHasAttributes = JsonMLHasAttributes;
exports.Leaf = Leaf;
exports.MS_OFFICE = MS_OFFICE;
exports.MS_OFFICES = MS_OFFICES;
exports.MS_WORD = MS_WORD;
exports.Mark = Mark;
exports.MoCommon = index$2;
exports.MoInterfaces = index$1;
exports.MoState = State;
exports.Node = Node$1;
exports.Operation = Operation;
exports.Path = Path;
exports.Point = Point;
exports.Provider = Provider;
exports.Queries = index;
exports.REMAIN_STYLE_SOURCES = REMAIN_STYLE_SOURCES;
exports.RangeSelection = RangeSelection;
exports.SLASH_PLACEHOLDER = SLASH_PLACEHOLDER;
exports.ScrollableContentContext = ScrollableContentContext;
exports.Selection = Selection;
exports.SelectionSlot = SelectionSlot;
exports.ShadowRoot = ShadowRoot;
exports.StyleContext = StyleContext;
exports.Text = Text$1;
exports.TextPoint = TextPoint;
exports.Value = Value;
exports.YUQUE = YUQUE;
exports.constants = constants;
exports.createActionHandlers = createActionHandlers;
exports.createBaseSerializer = createBaseSerializer;
exports.createEmptyParagraph = createEmptyParagraph;
exports.createEmptyText = createEmptyText;
exports.createPerfFirstRenderPlugin = createPerfFirstRenderPlugin;
exports.createPerfLazyRenderPlugin = createPerfLazyRenderPlugin;
exports.createPlaceholderPlugin = createPlaceholderPlugin;
exports.createSchema = createSchema;
exports.createSerializer = createSerializer;
exports.createSerializerOld = createSerializerOld;
exports.createStrictSchema = createStrictSchema;
exports.createTextWithString = createTextWithString;
exports.domUtils = index$3;
exports.environment = environment;
exports.getAttributes = jsonMLGetAttributes;
exports.getChildren = jsonMLGetChildren;
exports.getDirtyKeysFromElementDiffStrictly = getDirtyKeysFromElementDiffStrictly;
exports.getTagName = jsonMLGetTagName;
exports.getUserData = getUserData;
exports.hotkeys = hotkeys;
exports.jsonMLAppend = jsonMLAppend;
exports.jsonMLAppendAt = jsonMLAppendAt;
exports.jsonMLGetAttributes = jsonMLGetAttributes;
exports.jsonMLGetChildren = jsonMLGetChildren;
exports.jsonMLGetDescription = jsonMLGetDescription;
exports.jsonMLGetLastChild = jsonMLGetLastChild;
exports.jsonMLGetTagName = jsonMLGetTagName;
exports.jsonMLGetText = jsonMLGetText;
exports.jsonMLIsEmptyContent = jsonMLIsEmptyContent;
exports.jsonMLIsText = jsonMLIsText;
exports.keyUtils = keyUtils;
exports.normalizePendingConfig = normalizePendingConfig;
exports.omitEmptyObj = omitEmptyObj;
exports.opContextUtils = opContext;
exports.setUtils = setUtils;
exports.textUtils = textUtils;
exports.toStyleObject = toStyleObject;
exports.transferUtils = transfer;
exports.useContentStyle = useContentStyle;
exports.useExternalZoom = useExternalZoom;
exports.useGroupData = useGroupData;
exports.useHots = useHots;
exports.useHotsAtTheStartOfNextFrame = useHotsAtTheStartOfNextFrame;
exports.useInputingHots = useInputingHots;
exports.useInputingHotsAtTheStartOfNextFrame = useInputingHotsAtTheStartOfNextFrame;
exports.useLeafBlockResizer = useLeafBlockResizer;
exports.useNodeStyle = useNodeStyle;
exports.useOffsetPosition = useOffsetPosition;
exports.useScroll = useScroll;
exports.useScrollableContainer = useScrollableContainer;
exports.useScrollableContent = useScrollableContent;
exports.useSelectingHots = useSelectingHots;
exports.useSelectingHotsAtTheStartOfNextFrame = useSelectingHotsAtTheStartOfNextFrame;
exports.useSelectionData = useSelectionData;
exports.useStyle = useStyle;
exports.useUserData = useUserData;
exports.useZoom = useZoom;
exports.useZoomContainer = useZoomContainer;
//# sourceMappingURL=index.js.map
