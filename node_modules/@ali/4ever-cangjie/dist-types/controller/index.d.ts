/**
 * @packageDocumentation
 * @module Controller
 */
import * as React from 'react';
import useController from './useController';
import connectController from './connectController';
import Command, { PluginCommandArgs, PluginCommandName, PluginCommands } from '../interfaces/command';
import type { default as Query, PluginQueryArgs, PluginQueryName, PluginQueryReturn, PluginQueries } from '../interfaces/query';
import Plugin from '../interfaces/plugin';
import Data from '../interfaces/data';
import RenderNode from '../interfaces/renderNode';
import Operation from '../models/operation';
import Document from '../models/document';
import Value from '../models/value';
import Injection from '../models/injection';
import Decoration from '../models/decoration';
import Node from '../models/node';
import Selection from '../models/selection';
import Leaf from '../models/leaf';
import { Schema } from '../plugins/normalization';
import { ControllerOptions, ControllerProperties, PendingType, ShowCaretConfig, Terminal } from '../interfaces/controller';
import { Subject } from '../models/observable';
import { InputData } from '../interfaces/input';
import { SelectionData } from '../hooks/useSelectionData';
import UserDataManager from './userData';
import { PerfType } from '../interfaces/perf';
import { Hot } from '../interfaces/hot';
import VirtualizeManager from '../virtualize/virtualizeManager';
import type { RestParameters, RunParameters } from '../interfaces/utility';
import type { PluginActionCreators, PluginActionPredicates } from '../interfaces/action';
import GroupManager from './groupManager';
import { BaseMo, Mo } from '../mo';
import useControllerStatic from './useControllerStatic';
export declare function getDirtyKeysFromOperation(value: Value, operation: Operation): (string | undefined)[];
/**
 * diff比较（严格：顺序改变算diff）
 * @param element
 * @param prevElement
 * @param curIndexKey
 * @param preIndexKey
 * @deprecated
 */
export declare function getDirtyKeysFromElementDiffStrictly(element: Node, prevElement: Node | null, curIndexKey?: string, preIndexKey?: string): string[];
interface ViewData {
    decorations: Decoration[];
    injections: Injection[];
}
declare type ScrollType = /** default: 跟随选区滚动 */ 'toSelection'
/** 保持当前滚动位置稳定，一般是一次性的，消费过该数据后应置回 default 值 */
 | 'maintain';
export declare const defaultScrollType: ScrollType;
interface Virtualize {
    /** 当前可见的元素集合 */
    visibles: string[];
    /** 当前正在调度的不可见节点模型计算 */
    invisibleCalculationId: null | number;
}
export declare function insertComposingIntoLeaves(leaves: Leaf[], offset: number, composing: string, selection: Selection, decorations: Decoration[]): Leaf[];
export default class Controller {
    static useController: typeof useController;
    static useControllerStatic: typeof useControllerStatic;
    /**
     * 内部使用了[[Controller.useController]]，把Wrapper封装为一个高阶组件，并传入controller
     */
    static connectController: typeof connectController;
    /**
     * 构建一个新的Controller对象
     * @param props 构建参数
     * @param options 构建选项
     */
    static create(props: ControllerProperties, options?: ControllerOptions): Controller;
    private flag;
    private readonly VIEW_CACHE;
    private readonly dirtyKeys;
    private readonly context;
    /**
     * 业务ID。业务方自行通过constructor设置、自行使用
     */
    readonly biz: string;
    /**
     * 展示相应 uid 下的用户数据
     */
    uid?: string;
    /**
     * 用户数据
     */
    userData: UserDataManager;
    /**
     * 输入数据流
     */
    inputData$: Subject<InputData>;
    /**
     * 选区变化数据流
     */
    selectionData$: Subject<SelectionData>;
    /**
     * hots 流
     */
    hots$: Subject<Hot[]>;
    /**
     * pending 停止信号
     */
    terminal$: Subject<Terminal | null>;
    virtualizeManager: VirtualizeManager | null;
    /** serializer */
    readonly serializer: Mo;
    readonly baseSerializer: BaseMo;
    /** schema */
    readonly schema: Schema;
    readonly strictSchema: Schema;
    private $value;
    private $viewDoc;
    private $scrollableContainer;
    /**
     * 文档的数据[[Value]]对象，参照[[ControllerProperties]]
     */
    get value(): Value;
    private $operations;
    private $operationWithValues;
    /**
     * 获取当前的历史operations
     */
    get operations(): Operation[];
    private readonly onChange;
    private commands;
    private queries;
    private actions;
    private isActions;
    private handlers;
    private renderNodes;
    /**
     * flush 的调度方法
     */
    private readonly flushType;
    /**
     * flush 任务，这个方法主要处理一些需要手动 flush 的场景，手动 flush 会取消当前正在 pending 中的 task，防止二次 flush
     */
    private flushTask;
    /**
     * Only disable copy on readOnly mode
     */
    canCopy: boolean;
    readonly readOnly: boolean;
    readonly autoFocus: boolean;
    hideSelectionOnBlur?: boolean;
    showCaret?: ShowCaretConfig;
    testType?: PendingType;
    private readonly onBusyStateChange?;
    private readonly pendingQueue;
    private virtualizeOptions;
    private debouncedFlush;
    private debouncedStartInvisibleCalculationScheduler;
    groupManager: GroupManager;
    private readonly onPending;
    private readonly uuidConfig;
    /** 热区 */
    hots: {
        /** 热区序列 */
        hots: Hot[];
        /** PERF: 保存热区节点 key，加快热区判定效率 */
        keys: Record<string, true>;
        /** 存在 Pending 的变更时，被 Pending 的操作类型 */
        pendingType: PendingType | null;
        /** 上一次 pending 的 op 规模 */
        lengthOfPending: number;
        /** 必须重新计算 node view */
        forceRecalculate: boolean;
    };
    private virtualize;
    visibles$: Subject<string[]>;
    private registerPlugin;
    private constructor();
    setReadOnly(readOnly: boolean): void;
    /**
     * 设置一个新的value对象
     * @param value 新的value对象
     * @param options 设置选项
     */
    setValue(value: Value, options?: ControllerOptions & {
        clearOperations?: boolean;
        clearHots?: boolean;
    }): this;
    private setValueField;
    /**
     * 重置编辑器的 value，服务于受控组件的 `props.value` 变化时
     * `controller.resetValue(value)` 内部将驱动各个插件在重置 value 时所要完成的任务或者副作用
     * @param value
     * @param options
     */
    resetValue(value: Value, options?: ControllerOptions): void;
    /**
     * 1. 设置Value的data字段
     * 2. 并更新Value
     * 3. 调用flush刷新
     */
    setData(data: Data): this;
    /**
     * 1. 设置Value的injection字段
     * 2. 并更新Value
     * 3. 调用flush刷新
     */
    setInjections(injections: Injection[]): this;
    /**
     * 1. 设置Value的decoration字段
     * 2. 并更新Value
     * 3. 调用flush刷新
     */
    setDecorations(decorations: Decoration[]): this;
    setComposing: (composing: string) => this;
    setIsFocused: (isFocused: boolean) => this;
    /**
     * 依次调用所有plugin的key字段，并传入下方的args字段，以及controller和next
     * @param key 对应plugin的key字段
     * @param args 传入plugin的参数
     */
    run<K extends keyof Omit<Plugin, 'commands' | 'actions' | 'isActions' | 'queries' | 'schema' | 'models' | 'toolbar'>>(key: K, ...args: RunParameters<Required<Plugin>[K]>): ReturnType<Required<Omit<Plugin, 'renderNode'> & {
        renderNode: RenderNode;
    }>[K]>;
    /**
     * 执行刷新操作。这里会调用normalize，并执行onChange Plugin和onChange回调
     */
    flush(): this;
    /**
     * 调度执行 flush，在微任务中执行
     */
    private scheduleFlush;
    private transformDirtyKey;
    /**
     * Apply operation directly
     * @param operation
     * @returns
     */
    private privateApplyOperation;
    /**
     * 执行单个Operation
     * @param operation 需要执行的operation
     */
    applyOperation(operation: Operation): this;
    private normalizeNodeByKey;
    private normalizeDirtyKeys;
    private normalizeSelection;
    private groupNodes;
    private toViewText;
    private toViewElement;
    /**
     * 将 Data Model 上的节点转换为 View Model 的节点
     * @param node
     * @param data
     */
    toView(node: Node, decorations: Decoration[], injections: Injection[], isNodeVisible?: boolean): Node;
    /**
     * 热区计算时，获得应当注入 Hot View Node 的 View Data
     * 根据当前变更判断是否需要重算 View Data
     * 1. 若需要：则携带（1）parent node 的被分发的视图数据（2） Top-Level(`controller.value.injections`, `controller.value.decorations`) 的视图数据， 重新为 node 分发视图数据
     * 2. 否则，使用缓存的视图数据
     * @param viewNode
     * @param dataNode
     * @returns
     */
    private getInjectedViewData;
    /**
     * 重新计算热区中的视图模型
     * @param viewNode
     * @returns
     */
    recalculateView(viewNode: Node): {
        node: Node;
        document: Document;
    };
    /**
     * 是否当前未产生节点空间的影响
     * 1. 协同变更无法评估是否对空间有影响
     * 2. 非协同变更：
     *   * Pending 时，无空间影响
     *   * 非 Pending 时，判断累积的操作是否有空间影响
     * @returns
     */
    private noSpacialEffect;
    /**
     * 获得热区状态下的视图
     * @param node
     * @param document
     * @param shouldRecalculate
     * @returns
     */
    getView(node: Node, document: Document, shouldRecalculate: boolean): {
        node: Node;
        document: Document;
    };
    /**
     * 执行一个函数，并在执行过程中，禁止任何的 normalize
     * @param fn 执行函数
     */
    withoutNormalizing(fn: (self: Controller) => void): this;
    /**
     * 执行一个函数，并在执行过程中，禁止任何的 pending
     * @param fn 执行函数
     * @returns
     */
    withoutPending(fn: (self: Controller) => void): this;
    /**
     * 执行一个函数，并在执行过程中，不记录 undo stack
     * @param fn 执行函数
     * @returns
     */
    withoutSaving(fn: (self: Controller) => void, { __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, }?: {
        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED?: boolean;
    }): this;
    /**
     * 执行一个函数，并在执行过程中禁止 op tracking
     * @param fn 执行函数
     * @returns
     */
    withoutTracking(fn: (self: Controller) => void): this;
    withCommand(fn: (self: Controller) => void): this;
    withOpContext(context: string, fn: (self: Controller) => void, meta?: any[]): this;
    /**
     * 执行一个command
     * @param cmd command函数或者字符串。传入函数会直接执行，字符串则会调用所有插件的onCommand中对应的处理函数
     * @param args command的参数
     */
    command<T extends keyof PluginCommands | Command | string>(cmd: T extends keyof PluginCommands ? PluginCommandName<T> : T, ...args: T extends Command ? RestParameters<T> : T extends keyof PluginCommands ? PluginCommandArgs<T> : any[]): this;
    /**
     * 执行一个query
     * @param qry query函数或者字符串。传入函数会直接执行，字符串则会调用所有插件的onQuery中对应的处理函数
     * @param args query的参数
     */
    query<T extends keyof PluginQueries | Query | string>(qry: T extends keyof PluginQueries ? PluginQueryName<T> : T, ...args: T extends Query ? RestParameters<T> : T extends keyof PluginQueries ? PluginQueryArgs<T> : any[]): T extends Query ? ReturnType<T> : T extends keyof PluginQueries ? PluginQueryReturn<T> : any;
    /**
     * 触发一个插件的 action
     * @param name string action 名称
     * @param args  action 调用参数
     *
     * TODO: 插件迁移完成后，删掉 string 的定义
     */
    dispatch<T extends keyof PluginActionCreators | string = keyof PluginActionCreators>(name: T, ...args: T extends keyof PluginActionCreators ? Parameters<PluginActionCreators[T]> : any[]): void;
    /**
     * 获取 action 判断函数。 返回的结果用于判断入参是否是某种 action, 支持 type predicate
     * @param name action Name: 插件基于 PluginActionPredicates 注册
     * @returns (action: any): action is SomeAction
     *
     * TODO: 插件迁移完成后，删掉 string 的定义
     */
    isActionFactory<T extends keyof PluginActionPredicates | string = keyof PluginActionPredicates>(name: T): T extends keyof PluginActionPredicates ? PluginActionPredicates[T] | undefined : ((action: any) => boolean) | undefined;
    /**
     * 销毁当前 controller 实例
     */
    destroy(): void;
    /**
     * 清理编辑器以及插件的cache
     */
    cleanup(): void;
    /**
     * 获得当前编辑器的视图模型
     */
    get view(): Document;
    /**
     * 获得 `node`  的视图数据
     * @param node
     */
    getViewData(node: Node): ViewData;
    setOpRelatedId(id: string | null): this;
    get opRelatedId(): string | null;
    get shouldResumePosition(): boolean;
    get shouldScrollToSelection(): boolean;
    setScrollType(type: ScrollType): void;
    get isPending(): boolean;
    get enablePending(): Partial<Record<PendingType, boolean>>;
    get isPendingEnable(): boolean;
    get pendingType(): PendingType | null | undefined;
    get isTracking(): boolean;
    dispatchPendingTerminal(): void;
    perfStart(payload: {
        type: PerfType;
        subtype?: string;
    }): void;
    perfEnd(type: PerfType, dropped?: boolean): void;
    /**
     * 丢弃 perf 数据
     * @description BACKGROUND:
     * 通常 perf 队列遵循 **先进先出** 的原则，每一次入队都意味着一次交互事件的产生，正常出队的时机是在渲染后的 setTimeout 任务里（通过 perfEnd 出队）。
     * - 有些情况下我们不需要记录此次 perf 值（eg. 交互事件后未触发视图改变），所以通过 `perfDrop(type)` 异步地丢弃之；
     * - 特殊情况下，如果在正常出队前发现数据无效（eg. 丢帧：marcoTask 先于渲染执行）需要丢弃，则通过 `perfDrop(type, true)` 同步地丢弃之。
     * @param type PerfType
     * @param immediately 是否立即丢弃
     */
    perfDrop(type: PerfType, immediately?: boolean): void;
    private perfClearAll;
    private setUid;
    switchUid(dataUid: string | number | undefined): void;
    getHots(): Hot[];
    setHots(hots: Hot[], pendingType: PendingType | null, forceRecalculate?: boolean): this;
    clearHots(): this;
    hasHots(): boolean;
    /** 是否开启热区 */
    get enableHots(): boolean;
    /**
     * 当前节点视图是否热
     * @param viewNode
     * @returns
     */
    isViewHot(viewNode: Node): boolean;
    addIsSelected(key: string): void;
    getIsSelected(key: string): boolean;
    removeIsSelected(key: string): void;
    /**
     * 1. 若配置了闪享光标，则 blur 时需要显示远程光标
     * 2. 否则，根据配置项 hideSelectionOnBlur 决定是否需要隐藏
     * @returns 是否需要不显示选区
     */
    shouldHideSelectionOnBlur(): boolean | undefined;
    /**
     * 是否开启虚拟化
     */
    get enableVirtualize(): boolean;
    /**
     * 是否开启模型虚拟化以及视图虚拟化
     */
    get enableVirtualizeView(): boolean;
    /** 是否开启按需计算 */
    get enableOnDemandViewCalculation(): boolean | undefined;
    /**
     * 虚拟化时，是否节点可见
     * @param node
     * @returns
     */
    isNodeVisible(node: Node): boolean;
    /**
     * 是否 visibles 中存在未计算过视图模型的节点
     * 当节点被认为不可见后，它的视图模型不会被计算，那么下一次可见时：
     * - 节点本身可见
     * - 节点所在分组可见
     * 此时，需要保证节点的视图模型能够被正确计算
     * @param visibles
     * @returns
     */
    private hasViewNeverCalculatedInVisibles;
    /**
     * 设置虚拟化的可见节点集合
     * @param visibles
     */
    setVirtualize<T extends keyof Virtualize>(key: T, value: Virtualize[T]): this;
    private startInvisibleCalculationScheduler;
    private scheduleInvisibleCalculation;
    private runInvisibleViewCalculation;
    private calculateInvisibleView;
    /**
     * 计算可见节点子树下的未被计算的视图模型
     * @param node
     * @returns
     */
    private calculateViewInVisibleNode;
    get visibleBlocks(): string[];
    set scrollableContainer(scrollableContainer: Window | HTMLElement | null);
    get scrollableContainer(): Window | HTMLElement | null;
    get enableUUID(): boolean;
}
/**
 * @ignore
 */
export declare const ControllerContext: React.Context<{
    controller: Controller;
    subject: Subject<Value>;
} | null>;
export {};
