import Decoration from './decoration';
import Node, { NodeProperties } from './node';
import Leaf, { LeafJSON } from './leaf';
import Mark, { MarkProperties } from './mark';
import { Serializable, SerializeOptions } from '../interfaces/serializable';
declare type TextChildren = Leaf[];
export interface TextProperties extends NodeProperties {
    leaves?: TextChildren;
}
export interface TextJSON {
    klass: 'text';
    key?: string;
    leaves: LeafJSON[];
}
export default class Text extends Node implements Serializable<TextJSON> {
    static create(properties?: Text | TextProperties | string): Text;
    static fromJSON(json: TextJSON): Text;
    static isText(maybeText: any): maybeText is Text;
    static isEmptyText(maybeText: any): maybeText is Text;
    static isTextList(maybeTextList: any): maybeTextList is Text[];
    protected constructor(props: Required<TextProperties>, options?: {
        normalize: boolean;
    });
    readonly leaves: TextChildren;
    /**
     * 获取对应的文本string
     */
    get text(): string;
    /**
     * 获取所有的marks
     */
    get marks(): Mark<import("../interfaces/data").default>[];
    /**
     * 获取自身树下的所有 Text 节点
     * 如果自身是 Text，则返回只含有自身的数组
     */
    getTexts(): Text[];
    merge(props: Partial<TextProperties>): Text;
    set<T extends keyof TextProperties>(key: T, value: Required<TextProperties>[T]): Text;
    regenerateKey(): Text;
    getLeaves(decorations?: Decoration[]): TextChildren;
    /**
     * 获取所有的marks
     */
    getMarks(): Mark<import("../interfaces/data").default>[];
    /**
     * 获取text内所有文字都有的，公共marks
     */
    getActiveMarks(): Mark<import("../interfaces/data").default>[];
    /**
     * 根据offset区间，获取marks
     */
    getMarksBetweenOffsets(startOffset: number, endOffset: number): Mark<import("../interfaces/data").default>[];
    /**
     * 根据offset区间，获取区间内所有文字都含有的，公共marks
     */
    getActiveMarksBetweenOffsets(startOffset: number, endOffset: number): Mark<import("../interfaces/data").default>[];
    /**
     * 获取第index个文字，对应的marks
     */
    getMarksAtIndex(index: number): Mark<import("../interfaces/data").default>[];
    /**
     * 拷贝出一个新的text节点，并在指定的位置添加mark
     * 如果offset不合法，则返回自身
     */
    addMark(offset: number, length: number, mark: Mark): Text;
    /**
     * 拷贝出一个新的text节点，并在指定的位置添加marks。
     * 如果marks是0，或者offset不合法，则返回自身
     */
    addMarks(offset: number, length: number, marks: Mark[]): Text;
    /**
     * 拷贝出一个新的text节点，并在指定的位置过滤掉对应的mark
     * 如果当前没有这个mark，或者offset不合法，则返回自身
     */
    removeMark(offset: number, length: number, mark: Mark): Text;
    /**
     * 在指定的区间，设置一个新的Mark
     * 如果指定区间不合法，或者区间内已经存在同样的mark，则返回自身
     */
    setMark(offset: number, length: number, mark: Mark, properties: Partial<MarkProperties>): Text;
    /**
     * 复制出一个新的text，并在指定的位置，插入对应的文字和marks
     */
    insertText(offset: number, text: string, marks?: Mark[]): Text;
    /**
     * 在指定的位置，删掉指定的text长度的文字
     * 本杰：TODO: check whether deleted text is same as text?
     */
    removeText(offset: number, text: string): Text;
    /**
     * 拷贝出一个新的text，并把传入的text的leaves添加上去
     */
    mergeText(other: Text): Text;
    /**
     * 在指定的位置做一个split，返回split后的两个text
     */
    splitText(position: number): Text[];
    toJSON(options?: SerializeOptions): TextJSON;
}
export {};
