import ImmutableRecord from './immutableRecord';
import { EdgePoint, TextPoint, TextPointJSON, EdgePointJSON, PointEdge } from './point';
import Node from './node';
import Document from './document';
import { Serializable, SerializeOptions } from '../interfaces/serializable';
import Data from '../interfaces/data';
import Mark, { MarkJSON } from './mark';
import Controller from '../controller';
import Block from './block';
/**
 * @ignore
 */
export declare type SupportEdge = 'start' | 'end';
export declare type SupportPointName = 'anchor' | 'focus' | 'start' | 'end';
/**
 * @ignore
 */
export declare type SupportSide = 'previous' | 'next';
/**
 * @ignore
 */
export declare type SupportKlass = 'block' | 'inline' | 'text';
export declare enum SelectionTrigger {
    Selecting = "selecting",
    SelectStart = "selectStart",
    SelectAll = "selectAll",
    MoveUpward = "moveUpward",
    MoveDownward = "moveDownward",
    MoveBackward = "moveBackward",
    MoveForward = "moveForward",
    MultipleClick = "multipleClick"
}
export interface SelectionProperties {
    data?: Data;
    anchor: TextPoint | EdgePoint;
    focus: TextPoint | EdgePoint;
    marks?: Mark[] | null;
}
export declare type RangeSelectionProperties = SelectionProperties;
export interface SelectionJSON {
    data?: Data;
    anchor: TextPointJSON | EdgePointJSON;
    focus: TextPointJSON | EdgePointJSON;
    marks?: MarkJSON[] | null;
}
export declare type RangeSelectionJSON = SelectionJSON;
declare type Mover = (selection: Selection) => Selection;
declare type PointMoverCreator = (pn: SupportPointName, n: number) => Mover;
export default class Selection extends ImmutableRecord implements Serializable<SelectionJSON> {
    static create(props: Selection | SelectionProperties): Selection;
    /**
     * 调整range的开始位置和结束位置，使其"收缩"到最小的位置， 如果ignoreEnd的值为true，则忽略对结束位置的调整
     * @param document
     * @param ignoreEnd 如果ignoreEnd的值为true，则忽略对结束位置的调整
     * @example
     * before:1234<anchor/><link>56<focus/>78</link>90
     * after:1234<link><anchor/>56<focus/>78</link>90
     */
    shrinkBoundary(document: Document, ignoreEnd?: boolean): Selection;
    static fromJSON(json: SelectionJSON): Selection;
    static isSelection(maybeSelection: any): maybeSelection is Selection;
    static isRangeSelection(maybeSelection: any): maybeSelection is Selection;
    static isValidSelection(document: Document, selection: any): boolean;
    static isValidRangeSelection(document: Document, selection: any): boolean;
    static selectWordAtPoint(document: Document, point: TextPoint | EdgePoint): Selection | null;
    static isEqual(rangSelection: Selection, target: Selection): boolean;
    readonly data: Data;
    readonly anchor: TextPoint | EdgePoint;
    readonly focus: TextPoint | EdgePoint;
    readonly marks: Mark[] | null;
    protected constructor(props: Required<SelectionProperties>);
    /**
     * 选区是否指向同一个位置（caret）
     */
    get isCollapsed(): boolean;
    /**
     * 选区是否是扩展
     */
    get isExpanded(): boolean;
    get viewKey(): string;
    get plainViewKey(): string;
    merge(props: Partial<SelectionProperties>): Selection;
    set<T extends keyof SelectionProperties>(key: T, value: SelectionProperties[T]): Selection;
    private isForwardInDocument;
    /**
     * 选区是不是正序的（anchor在前，focus在后）
     */
    isForward(document: Document): boolean;
    /**
     * 选区是不是倒序的（anchor在后，focus在前）
     */
    isBackward(document: Document): boolean;
    /**
     * 获取start point
     */
    getStart(document: Document): TextPoint | EdgePoint;
    /**
     * 获取end point
     */
    getEnd(document: Document): TextPoint | EdgePoint;
    /**
     * 根据PointName，获取point
     */
    getPoint(pointName: SupportPointName, document: Document): TextPoint | EdgePoint;
    /**
     * 同时获取start point、end point
     */
    sort(document: Document): {
        start: TextPoint | EdgePoint;
        end: TextPoint | EdgePoint;
    };
    /**
     * 把当前的数据选区的 Points 转换成 TextPoints。
     */
    convertToTextPoints(document: Document): {
        anchor: TextPoint;
        focus: TextPoint;
        start: TextPoint;
        end: TextPoint;
    };
    /**
     * 获得当前选区所处的 Node
     * @param document
     */
    getClosestNode(document: Document): Block<Data, import("./block").BlockChildren> | null;
    /**
     * 选区是否在Hanging状态
     */
    get isHanging(): boolean;
    get isCollapsedAtEdge(): boolean;
    /**
     * 拷贝出一个新的选区，并设置选区的Haning状态
     */
    setHanging(isHanging: boolean): Selection;
    /**
     * 拷贝出一个新的选区，并把start point移到end point的位置
     */
    moveToEnd(document: Document): Selection;
    moveStartToStartOfNode(node: Node, controller: Controller): Selection;
    moveStartToEndOfNode(node: Node, controller: Controller): Selection;
    moveEndToStartOfNode(node: Node, controller: Controller): Selection;
    moveEndToEndOfNode(node: Node, controller: Controller): Selection;
    moveAnchorToStartOfNode(node: Node, controller: Controller): Selection;
    moveAnchorToEndOfNode(node: Node, controller: Controller): Selection;
    moveFocusToStartOfNode(node: Node, controller: Controller): Selection;
    moveFocusToEndOfNode(node: Node, controller: Controller): Selection;
    moveAnchorTo(key: string, where: number | PointEdge): Selection;
    moveFocusTo(key: string, where: number | PointEdge): Selection;
    moveToStartOfNode(node: Node, controller: Controller): Selection;
    moveToEndOfNode(node: Node, controller: Controller): Selection;
    /**
     * 拷贝出一个新的选区，并把anchor和focus调换位置
     */
    flip(): Selection;
    moveAnchorBackward(n?: number, mover?: PointMoverCreator): Selection;
    moveAnchorForward(n?: number, mover?: PointMoverCreator): Selection;
    moveFocusBackward(n?: number, mover?: PointMoverCreator): Selection;
    moveFocusForward(n?: number, mover?: PointMoverCreator): Selection;
    moveToFocus(): Selection;
    moveToAnchor(): Selection;
    moveToStart(document: Document): Selection;
    moveToRangeOfNode(node: Node, controller: Controller): Selection;
    moveForward(n?: number, mover?: PointMoverCreator): Selection;
    moveStartBackward(document: Document, n: number): Selection;
    moveStartForward(document: Document, n: number): Selection;
    moveEndBackward(document: Document, n: number): Selection;
    moveEndForward(document: Document, n: number): Selection;
    moveBackward(n?: number, mover?: PointMoverCreator): Selection;
    move(mover: Mover): Selection;
    moveToStartOfDocument(controller: Controller): Selection;
    moveToEndOfDocument(controller: Controller): Selection;
    movePointEdgeKlass(controller: Controller, pointName: SupportPointName, edge: SupportEdge, klass: SupportKlass): Selection;
    movePointEdgeSideKlass(controller: Controller, pointName: SupportPointName, edge: SupportEdge, side: SupportSide, klass: SupportKlass): Selection;
    updatePoints(updater: (point: TextPoint | EdgePoint) => TextPoint | EdgePoint): Selection;
    toJSON(options?: SerializeOptions): {
        klass: string;
        anchor: TextPointJSON | EdgePointJSON;
        focus: TextPointJSON | EdgePointJSON;
        marks: MarkJSON<Data>[] | null;
    };
}
export {};
