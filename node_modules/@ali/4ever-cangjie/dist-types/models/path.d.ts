import Operation from './operation';
/**
 * @ignore
 */
export declare type PathJSON = number[];
export default class Path extends Array<number> {
    /**
     * Compare priority between `path` and `target`:
     *
     * - if `path` is before `target`, return -1
     * - if `path` is after `target`, return 1
     * - if `path` is equal to `target`, return 0
     * - else if something went wrong, return null
     *
     * @param path - path
     * @param target - target path
     *
     * # Example
     *
     * ```ts
     * Path.compare([1,0], [1,0])     // 0
     * Path.compare([1,1,1], [1,0])   // 1
     * Path.compare([1,0,0,1], [1,1]) // -1
     * ```
     */
    static compare(path: Path, target: Path): 0 | 1 | -1 | null;
    /**
     * Crop `a` and `b` into the same size.
     *
     * @param a
     * @param b
     * @param size - crop size, default is the shortest between a and b
     *
     * # Example
     *
     * ```ts
     * Path.crop([1,1,0], [1,1])    // [1,1]
     * Path.crop([1,1,0], [1,1], 1) // [1]
     * ```
     */
    static crop(a: Path, b: Path, size?: number): Path[];
    /**
     * Decrement a `path` by `n` at `index`.
     *
     * @param path
     * @param n - default is 1
     * @param index - default is the last index
     *
     * # Example
     *
     * ```ts
     * Path.decrement([1,1,1])       // [1,1,0]
     * Path.decrement([1,1,3], 2)    // [1,1,1]
     * Path.decrement([1,1,3], 1, 1) // [1,0,3]
     * ```
     */
    static decrement(path: Path, n?: number, index?: number): Path;
    /**
     * Increment a `path` by `n` at `index`.
     *
     * @param path
     * @param n - default is 1
     * @param index - default is the last index
     *
     * # Example
     *
     * ```ts
     * Path.increment([1,1,1])       // [1,1,2]
     * Path.increment([1,1,1], 2)    // [1,1,3]
     * Path.increment([1,1,1], 2, 1) // [1,3,1]
     * ```
     */
    static increment(path: Path, n?: number, index?: number): Path;
    /**
     * Link the `subPath` to the `ancestor`.
     *
     * @param ancestor
     * @param subPath
     *
     * # Example
     *
     * ```ts
     * Path.link([1,0], [1]) // [1,0,1]
     * ```
     */
    static link(ancestor: Path, subPath: Path): number[];
    /**
     * If the `path` is the ancestor of the `target`.
     *
     * @param path
     * @param target
     *
     * # Example
     *
     * Given the document tree:
     *
     * ```txt
     *         []
     *        /  \
     *     [0]   [1]
     *    /  \
     * [0,0]  [0,1]
     * ```
     *
     * ```ts
     * Path.isAncestor([], [0,0])  // true
     * Path.isAncestor([0], [0,0]) // true
     * ```
     */
    static isAncestor(path: Path, target: Path): boolean;
    /**
     * If the `path` is descendant of the `target`.
     *
     * @param path
     * @param target
     *
     * # Example
     *
     * Given the document tree:
     *
     * ```txt
     *         []
     *        /  \
     *      [0]   [1]
     *         __/ | \__
     *    [1,0]  [1,1]  [1,2]
     *      /
     *   [1,0,0]
     * ```
     *
     * ```ts
     * Path.isDescendant([1,0], [1]) // true
     * Path.isDescendant([1], [])   // true
     * ```
     */
    static isDescendant(path: Path, target: Path): boolean;
    /**
     * If the `path` is before the `target`.
     *
     * @param path
     * @param target
     *
     * # Example
     *
     * Given the document tree:
     *
     * ```txt
     *         []
     *        / \
     *      [0] [1]
     *         /  \
     *    [1,0]   [1,1]
     * ```
     *
     * ```ts
     * Path.isBefore([0], [1,1])   // true
     * Path.isBefore([1,0], [1,1]) // true
     * ```
     */
    static isBefore(path: Path, target: Path): boolean;
    /**
     * If the `path` is after the `target`.
     *
     * @param path
     * @param target
     *
     * # Example
     *
     * Given the document tree:
     *
     * ```txt
     *         []
     *        /  \
     *     [0]   [1]
     *          /  \
     *     [1,0]   [1,1]
     * ```
     *
     * ```ts
     * Path.isAfter([1], [0])   // true
     * Path.isAfter([1,0], [0]) // true
     * ```
     */
    static isAfter(path: Path, target: Path): boolean;
    /**
     * If the `path` is equal to `target`.
     *
     * @param path
     * @param target
     *
     * # Example
     *
     * ```ts
     * Path.isEqual([], [])       // true
     * Path.isEqual([1,0], [1,0]) // true
     * Path.isEqual([0], [1])     // false
     * ```
     */
    static isEqual(path: Path, target: Path): boolean;
    /**
     * If the `path` is the sibling of the `target`.
     *
     * @param path
     * @param target
     *
     * # Example
     *
     * Given the document tree:
     *
     * ```txt
     *         []
     *        /  \
     *      [0]   [1]
     *         __/ | \__
     *    [1,0]  [1,1]  [1,2]
     * ```
     *
     * ```ts
     * Path.isSibling([1,0], [1,1]) // true
     * Path.isSibling([1,2], [1,1]) // true
     * ```
     */
    static isSibling(path: Path, target: Path): boolean;
    /**
     * If the `path` is the previous sibling of the `target`.
     *
     * @param path
     * @param target
     *
     * # Example
     *
     * Given the document tree:
     *
     * ```txt
     *         []
     *        /  \
     *      [0]   [1]
     *         __/ | \__
     *    [1,0]  [1,1]  [1,2]
     * ```
     *
     * ```ts
     * Path.isPrevSibling([0], [1]) // true
     * Path.isPrevsSibling([1,1], [1,2]) // true
     * Path.isPrevsSibling([0], [1,2]) // false
     * ```
     */
    static isPrevSibling(path: Path, target: Path): boolean;
    /**
     * If the `path` is younger than the `target`.It means at the level which `path` lives, the `path` is ends before `target`.
     *
     * @param path
     * @param target
     *
     * # Example
     *
     * Given the document tree:
     *
     * ```txt
     *         []
     *        / \
     *     [0]   [1]
     *        __/ | \__
     *   [1,0]  [1,1]  [1,2]
     *          /   \
     *   [1,1,0]   [1,1,1]
     * ```
     *
     * ```ts
     * Path.isYounger([1,1,0], [1,1,1]) // true
     * Path.isYounger([1,0], [1,1,1])   // true
     * Path.isYounger([0], [1,1,1])     // true
     * ```
     */
    static isYounger(path: Path, target: Path): boolean;
    /**
     * If the `path` is deeper than the `target`.
     *
     * @param path
     * @param target
     *
     * # Example
     *
     * Given the document tree:
     *
     * ```txt
     *         []
     *        /  \
     *      [0]  [1]
     *           /  \
     *      [1,0]   [1,1]
     * ```
     *
     * ```ts
     * Path.isDeeper([1,0], [1]) // true
     * Path.isDeeper([1,0], [])  // true
     * ```
     */
    static isDeeper(path: Path, target: Path): boolean;
    /**
     * If the `path` is parent of the `target`.
     *
     * @param path
     * @param target
     *
     * # Example
     *
     * Given the document tree:
     *
     * ```txt
     *        []
     *       / \
     *    [0]  [1]
     *         /  \
     *    [1,0]   [1,1]
     * ```
     *
     * ```ts
     * Path.isParent([1], [1,0]) // true
     * Path.isParent([], [1])    // true
     * ```
     */
    static isParent(path: Path, target: Path): boolean;
    /**
     * If the `path` is child of the `target`
     *
     *
     * @param path
     * @param target
     *
     * # Example
     *
     * Given the document tree:
     *
     * ```txt
     *         []
     *        /  \
     *      [0]  [1]
     *          /  \
     *     [1,0]   [1,1]
     * ```
     *
     * ```ts
     * Path.isChild([1,0], [1]) // true
     * ```
     */
    static isChild(path: Path, target: Path): boolean;
    /**
     * Get the next sibiling of the `path`.
     *
     * @param path
     *
     * # Example
     *
     * Given the document tree:
     *
     * ```txt
     *         []
     *        /  \
     *      [0]  [1]
     *          /  \
     *     [1,0]   [1,1]
     * ```
     *
     * ```ts
     * Path.next([1,0]) // [1,1]
     * Path.next([])    // null
     * ```
     */
    static next(path: Path): number[] | null;
    /**
     * Get the previous sibiling of the `path`.
     *
     * @param path
     *
     * # Example
     *
     * Given the document tree:
     *
     * ```txt
     *         []
     *        /  \
     *      [0]  [1]
     *          /  \
     *     [1,0]   [1,1]
     * ```
     *
     * ```ts
     * Path.previous([1,1]) // [1,0]
     * Path.previous([])    // null
     * Path.previous([1,0]) // null
     * ```
     */
    static previous(path: Path): number[] | null;
    /**
     * Get the parent path of the `path`,
     * Note: the parent of root is still root.
     *
     * @param path
     *
     * # Example
     *
     * Given the document tree:
     *
     * ```txt
     *         []
     *        /  \
     *      [0]  [1]
     *          /  \
     *     [1,0]   [1,1]
     * ```
     *
     * ```ts
     * Path.parent([1,0]) // [1]
     * Path.parent([0])   // []
     * Path.parent([])    // []
     * ```
     */
    static parent(path: Path): number[];
    /**
     * Get all ancestors of the `path`.
     *
     * @param path
     *
     * # Example
     *
     * Given the document tree:
     *
     *```txt
     *        []
     *       /  \
     *    [0]   [1]
     *       __/ | \__
     *  [1,0]  [1,1]  [1,2]
     *          /
     *      [1,1,0]
     * ```
     *
     * ```ts
     * Path.ancestors([1,1,0]) // [[], [1], [1,1]]
     * ```
     */
    static ancestors(path: Path): Path[];
    /**
     * Get the common ancestor between `a` and `b`.
     *
     * @param a
     * @param b
     *
     * # Example
     *
     * Given the document tree:
     *
     *```txt
     *        []
     *       /  \
     *    [0]   [1]
     *       __/ | \__
     *  [1,0]  [1,1]  [1,2]
     *          /       /
     *      [1,1,0]  [1,2,0]
     * ```
     *
     * ```ts
     * Path.common([1,1,0], [1,2,0]) // [1]
     * ```
     */
    static common(a: Path, b: Path): Path;
    /**
     * Get the path of `path` relative to `ancestor`.
     *
     * @param a
     * @param b
     *
     * # Example
     *
     * Given the document tree:
     *
     *```txt
     *        []
     *       /  \
     *    [0]   [1]
     *       __/ | \__
     *  [1,0]  [1,1]  [1,2]
     *          /       /
     *      [1,1,0]  [1,2,0]
     * ```
     *
     * ```ts
     * Path.relative([1,1,0], [1]) // [1,0]
     * Path.relative([1,0,0], [0]) // null
     * ```
     */
    static relative(path: Path, ancestor: Path): number[] | null;
    /**
     * Transform the `path` based on `operation`.
     * @param path
     * @param operation
     */
    static transform(path: Path, operation: Operation): Path[];
    /**
   * If the `path` is root path
   *
   *
   * @param path
   * @param target
   *
   * # Example
   *
   *
   * ```ts
   * Path.isRoot([]) // true
   * ```
   */
    static isRoot(path: Path): boolean;
}
