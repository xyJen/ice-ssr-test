import ImmutableRecord from './immutableRecord';
import Mark, { MarkJSON } from './mark';
import { Serializable } from '../interfaces/serializable';
export interface LeafProperties {
    text: string;
    marks?: Mark[];
}
export interface LeafJSON {
    klass?: 'leaf';
    key?: string;
    text: string;
    marks?: MarkJSON[];
}
export default class Leaf extends ImmutableRecord implements Serializable<LeafJSON> {
    static create(properties?: Leaf | LeafProperties | string): Leaf;
    static fromJSON(json: LeafJSON): Leaf;
    static isLeaf(maybeLeaf: any): maybeLeaf is Leaf;
    /**
     * 对leaves进行normalize，并返回新Leafs
     */
    static normalizeLeaves(leaves: Leaf[]): Leaf[];
    /**
     * 对leaves执行split操作。
     * @offset text的偏移量，如果位于某一个leaf内部，则分割该leaf
     */
    static splitLeaves(leaves: Leaf[], offset: number): [Leaf[], Leaf[]];
    /**
     * 在leaves中搜索第offset个字符对应的位置
     */
    static searchLeafAtOffset(leaves: Leaf[], offset: number): {
        index: number;
        leaf: Leaf;
        startOffset: number;
        endOffset: number;
    } | null;
    protected constructor(props: Required<LeafProperties>);
    readonly text: string;
    readonly marks: Mark[];
    merge(props: Partial<LeafProperties>): Leaf;
    set<T extends keyof LeafProperties>(key: T, value: Required<LeafProperties>[T]): Leaf;
    /**
     * 拷贝一个新Leaf，并把Mark加上去
     */
    addMark(mark: Mark): Leaf;
    /**
     * 拷贝一个新Leaf，并把Marks加上去
     */
    addMarks(marks: Mark[]): Leaf;
    /**
     * 拷贝一个新Leaf，并把Mark过滤掉
     */
    removeMark(mark: Mark): Leaf;
    /**
     * 拷贝一个新Leaf，并把Mark替换掉
     * 如果mark不存在、mark和新mark相等，则返回当前的Leaf
     */
    setMark(mark: Mark, newMark: Mark): Leaf;
    toJSON(): LeafJSON;
}
