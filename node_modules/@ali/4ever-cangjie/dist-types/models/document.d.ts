import Element, { ElementProperties } from './element';
import Node from './node';
import Block, { BlockJSON } from './block';
import Inline from './inline';
import Text from './text';
import Mark from './mark';
import Path from './path';
import Selection from './selection';
import Controller from '../controller/index';
import { SerializeOptions } from '../interfaces/serializable';
import Data from '../interfaces/data';
export interface DocumentProperties extends ElementProperties {
    nodes?: Block[];
}
export interface DocumentJSON {
    klass?: 'document';
    key?: string;
    data?: Data;
    nodes?: BlockJSON[];
}
export default class Document extends Element {
    static create(props?: Document | DocumentProperties): Document;
    static fromJSON(json: DocumentJSON): Document;
    static isDocument(maybeDocument: any): maybeDocument is Document;
    protected constructor(props: Required<DocumentProperties>);
    readonly type: string;
    readonly nodes: Block[];
    merge(props: Partial<DocumentProperties>): Document;
    set<T extends keyof DocumentProperties>(key: T, value: Required<DocumentProperties>[T]): Document;
    /**
     * 获取selection内对应的所有marks
     */
    getMarksAtRange(range: Selection): Mark<Data>[];
    /**
     * 获取selection内对应的所有公共marks
     */
    getActiveMarksAtRange(range: Selection): Mark<Data>[];
    getMarksAtPosition(key: string, offset: number): Mark<Data>[];
    /**
     * 获取插入点对应的marks
     * 如果选区是collapse的，返回插入位置的marks;
     * 如果插入位置在新的text节点，则尝试获取同一block的前一个text对应的mark；
     * 如果选区是expand，则返回start位置对应的marks
     */
    getInsertMarksAtRange(range: Selection): Mark<Data>[];
    getNodesAtRange(range?: Selection): Node[];
    /**
     * 获取最近的支持 edge 选择的 block 节点。
     * 如果 key 对应的节点满足条件，会直接返回此节点。
     */
    getClosestSelectableBlock(key: string, controller: Controller): Element<Data, Node[]> | null;
    /**
     * 获取 rootKey 节点下距离 key 最远的支持 edge 选择的 block 节点。
     * 如果 key 对应的节点满足条件，也会返回此节点。
     */
    getFurthestSelectableBlock(key: string, rootKey: string, controller: Controller): Element<Data, Node[]> | null;
    /**
     * 获取最近的Void父节点
     */
    getClosestVoid(key: string, controller: Controller): Element<Data, Node[]> | null;
    /**
     * 获取最近的Void父节点
     */
    private getClosestVoidByPath;
    /**
     * 是否有一个Void父节点
     */
    hasVoidParent(key: string, controller: Controller): boolean;
    private hasVoidParentByPath;
    /**
     * 获取最顶层的一个Void节点
     */
    getFurthsestVoid(key: string, controller: Controller): Element<Data, Node[]> | null;
    /**
     * 根据选区，获取一个fragment
     */
    getFragmentAtRange(range: Selection, controller?: Controller): Document;
    /**
     * 获取特定区间的所有叶子block
     */
    getLeafBlocksAtRange(range: Selection): Block[];
    /**
     * 循环获取document下的所有叶子blocks节点
     */
    getBlocks(): Block<Data, import("./block").BlockChildren>[];
    /**
     * 循环获取document下的所有叶子blocks节点
     */
    getBlocksByType(type: string): Block<Data, import("./block").BlockChildren>[];
    /**
     * 循环获取document下的特定区间内的全部blocks节点
     */
    getRootBlocksAtRange(range?: Selection): Block[];
    /**
     * 判断节点是否在Selection之内
     */
    isNodeInRange(key: string, range: Selection): boolean;
    /**
     * 判断节点是否在Selection之内
     */
    isNodeInRangeByPath(path: Path, range: Selection): boolean;
    /**
     * 获取Selection内所有的Text节点
     */
    getTextsAtRange(range: Selection): Text[];
    /**
     * 获取Selection内所有的叶子Inline节点
     */
    getLeafInlinesAtRange(range: Selection): Inline[];
    /**
     * 获取Selection内的所有最远Inline节点
     */
    getRootInlinesAtRange(range?: Selection): Inline[];
    toJSON(options?: SerializeOptions): DocumentJSON;
}
