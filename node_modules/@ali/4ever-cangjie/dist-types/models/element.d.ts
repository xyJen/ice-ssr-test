/**
 * @packageDocumentation
 * @module Models
 */
import Text from './text';
import Node, { NodeProperties } from './node';
import Path from './path';
import Mark, { MarkProperties } from './mark';
import Data from '../interfaces/data';
import Block from './block';
import Inline from './inline';
export declare type KeysToEdgesTable = Record<string, [string, number]>;
export declare const KEYS_TO_EDGES_TABLE_CACHE: WeakMap<Element<Data, Node[]>, KeysToEdgesTable>;
export declare function linkKeysToEdgesTable(src: Element, target: Element): void;
declare type Predicate<T extends Node = Node> = (node: T, index?: number, self?: T[]) => boolean;
declare type Iterator<N extends Node = Node, T = void> = (node: N) => T;
export declare type ElementTypeName = 'block' | 'inline' | 'text';
export interface ElementProperties<D extends Data = Data, N extends Node[] = Node[]> extends NodeProperties {
    data?: D;
    nodes?: N;
}
export default abstract class Element<D extends Data = Data, N extends Node[] = Node[]> extends Node {
    /**
     * 判断 `maybeElement` 是否为 Element
     * @param maybeElement
     * @returns
     *
     * @example
     * ```tsx
     * const block = (<block type="paragraph">Hello</block>);
     * const inline = (<inline type="link">www.dingtalk.com</inline>);
     * const text = (<text>Hello</text>);
     *
     * assertTrue(Element.isElement(block));
     * assertTrue(Element.isElement(inline));
     * assertFlase(Element.isElement(text));
     * ```
     */
    static isElement(maybeElement: any): maybeElement is Element;
    readonly data: D;
    readonly nodes: N;
    protected constructor(props: Required<ElementProperties<D, N>>);
    abstract readonly type: string;
    abstract merge(props: Partial<ElementProperties<D, N>>): Element;
    abstract set<K extends keyof ElementProperties<N>>(key: K, value: Required<ElementProperties<D, N>>[K]): Element<D, N>;
    /**
     * 判断节点是否是 Inline 类型
     *
     * @example
     * ```tsx
     * const document = (<document><block type="paragraph">Hello</block></document>);
     * const block = (<block type="paragraph">Hello</block>);
     * const inline = (<inline type="link">www.dingtalk.com</inline>);
     *
     * assertTrue(inline.isInline());
     * assertFalse(block.isInline());
     * assertFalse(document.isInline());
     * ```
     */
    isInline(): this is Inline;
    /**
     * 判断节点是否是 Block 类型
     *
     * @example
     * ```tsx
     * const document = (<document><block type="paragraph">Hello</block></document>);
     * const block = (<block type="paragraph">Hello</block>);
     * const inline = (<inline type="link">www.dingtalk.com</inline>);
     *
     * assertTrue(block.isBlock());
     * assertFalse(inline.isBlock());
     * assertFalse(document.isBlock());
     * ```
     */
    isBlock(): this is Block;
    /**
     * 重新生成节点 key，避免出现 key 重复的节点
  
    * @example
     * ```tsx
     * const block = (<block type="paragraph">Hello</block>);
     *
     * const newBlock = block.regenerateKey();
     * assertFalse(block.key === newBlock.key);
     * ```
     * @returns
     */
    regenerateKey(): Element<D, N>;
    /**
     * 获取子节点
     * @param key
     * @throws NodeNotFoundError 无法找到节点时，抛出异常
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">
     *       <text key="hello">Hello</text>
     *     </block>
     *     <block type="paragraph" key="world-block">
     *       <text key="world">World</text>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(element.assertNode('own'), <block key="own" />);
     * assertEqual(element.assertNode('hello'), <text key="hello" />);
     * assertEqual(element.assertNode('world-block'), <block type="paragraph" key="world-block"/>);
     * assert(() => element.assertNode('not-exists')).toThrow();
     * ```
     */
    assertNode(key: string): Node;
    /**
     * 获取子节点
     * @param path
     * @throws NodeNotFoundError 无法找到节点时，抛出异常
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">
     *       <text key="hello">Hello</text>
     *     </block>
     *     <block type="paragraph" key="world-block">
     *       <text key="world">World</text>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(element.assertNodeByPath([]), <block key="own" />);
     * assertEqual(element.assertNodeByPath([0,0]), <text key="hello" />);
     * assertEqual(element.assertNodeByPath([1]), <block type="paragraph" key="world-block"/>);
     * assert(() => element.assertNodeByPath([2])).toThrow();
     * ```
     *
     *
     */
    assertNodeByPath(path: Path): Node;
    /**
     * 获取子 text 节点
     * @param key
     * @throws NodeNotFoundError 无法找到节点时，抛出异常
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">
     *       <text key="hello">Hello</text>
     *     </block>
     *     <block type="paragraph" key="world-block">
     *       <text key="world">World</text>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.assertText('hello'),
     *   <text key="hello">Hello</text>
     * );
     * assert(() => element.assertText('hello-block')).toThrow();
     * assert(() => element.assertText('not-exists')).toThrow();
     * ```
     */
    assertText(key: string): Text;
    /**
     * 获取子 text 节点
     * @param path
     * @throws NodeNotFoundError 无法找到节点时，抛出异常
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">
     *       <text key="hello">Hello</text>
     *     </block>
     *     <block type="paragraph" key="world-block">
     *       <text key="world">World</text>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.assertTextByPath([0,0]),
     *   <text key="hello">Hello</text>
     * );
     * assert(() => element.assertTextByPath([0])).toThrow();
     * assert(() => element.assertTextByPath([0,1])).toThrow();
     * ```
     */
    assertTextByPath(path: Path): Text;
    /**
     * 根据 `key`，获取子 element 节点
     * @param key
     * @throws NodeNotFoundError 无法找到节点时，抛出异常
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">
     *       <text key="hello">Hello</text>
     *     </block>
     *     <block type="paragraph" key="world-block">
     *       <text key="world">World</text>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.assertElement('hello-block'),
     *   <block type="paragraph" key="hello-block" />
     * );
     * assert(() => element.assertElement('hello')).toThrow();
     * assert(() => element.assertElement('not-exists')).toThrow();
     * ```
     */
    assertElement(key: string): Element<Data, Node[]>;
    /**
     * 获取子 element 节点
     * @param path
     * @throws NodeNotFoundError 无法找到节点时，抛出异常
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">
     *       <text key="hello">Hello</text>
     *     </block>
     *     <block type="paragraph" key="world-block">
     *       <text key="world">World</text>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.assertElementByPath([0]),
     *   <block type="paragraph" key="hello-block" />
     * );
     * assert(() => element.assertElementByPath([0,0])).toThrow();
     * assert(() => element.assertElementByPath([2])).toThrow();
     * ```
     */
    assertElementByPath(path: Path): Element<Data, Node[]>;
    /**
     * 获取节点 path
     * @param key
     * @throws NodeNotFoundError 无法找到节点时，抛出异常
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">
     *       <text key="hello">Hello</text>
     *     </block>
     *     <block type="paragraph" key="world-block">
     *       <text key="world">World</text>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(element.assertPath('own'), []);
     * assertEqual(element.assertPath('hello-block'), [0]);
     * assertEqual(element.assertPath('hello'), [0, 0]);
     * assert(() => element.assertPath('not-exists')).toThrow();
     * ```
     */
    assertPath(key: string): Path;
    /**
     * 判断节点是否存在于当前的节点子树中
     * @param key
     * @returns
     *
     * @example
     *
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">
     *       <text key="hello">Hello</text>
     *     </block>
     *     <block type="paragraph" key="world-block">
     *       <text key="world">World</text>
     *     </block>
     *   </block>
     * );
     *
     * assertTrue(element.hasNode('hello'));
     * assertFalse(element.hasNode('own));
     * assertFalse(element.hasNode('not-exists'));
     * ```
     */
    hasNode(key: string): boolean;
    /**
     * 判断节点是否为空：仅含有一个空的 text 节点
     *
     * @example
     *
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <text />
     *   </block>
     * );
     *
     * assertTrue(element.isEmpty());
     * ```
     */
    isEmpty(): boolean;
    /**
     * 获取子节点
     * @param key
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">
     *       <text key="hello">Hello</text>
     *     </block>
     *     <block type="paragraph" key="world-block">
     *       <text key="world">World</text>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(element.getNode('own'), <block key="own" />);
     * assertEqual(element.getNode('hello'), <text key="hello" />);
     * assertEqual(element.getNode('world-block'), <block type="paragraph" key="world-block"/>);
     * assertEqual(element.getNode(), null);
     * ```
     */
    getNode(key: string): Node | null;
    /**
     * 获取子节点，如果没有找到，将返回 null
     * @param path
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">
     *       <text key="hello">Hello</text>
     *     </block>
     *     <block type="paragraph" key="world-block">
     *       <text key="world">World</text>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(element.getNodeByPath([]), <block key="own" />);
     * assertEqual(element.getNodeByPath([0,0]), <text key="hello" />);
     * assertEqual(element.getNodeByPath([1]), <block type="paragraph" key="world-block"/>);
     * assertEqual(element.getNodeByPath([2]), null);
     * ```
     */
    getNodeByPath(path: Path | null): Node | null;
    /**
     * 获取相对于当前节点的 path，如果没有找到，就返回 `null`
     * @param key
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">
     *       <text key="hello">Hello</text>
     *     </block>
     *     <block type="paragraph" key="world-block">
     *       <text key="world">World</text>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(element.getPath('own'), []);
     * assertEqual(element.getPath('hello'), [0,0]);
     * assertEqual(element.getPath('world-block'), [1]);
     * assertEqual(element.getPath('not-exists'), null);
     * ```
     */
    getPath(key: string): Path | null;
    /**
     * 获取上一个兄弟节点，若不存在，将返回 null
     * @param key
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">Hello</block>
     *     <block type="paragraph" key="world-block">World</block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getPreviousSibling('world-block'),
     *   <block type="paragraph" key="hello-block">Hello</block>
     * );
     * assertEqual(
     *   element.getPreviousSibling('hello-block'),
     *   null
     * );
     * ```
     */
    getPreviousSibling(key: string): Node | null;
    /**
     * 获取上一个兄弟节点，若不存在，将返回 null
     * @param path
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">Hello</block>
     *     <block type="paragraph" key="world-block">World</block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getPreviousSiblingByPath([1]),
     *   <block type="paragraph" key="hello-block">Hello</block>
     * );
     * assertEqual(
     *   element.getPreviousSiblingByPath([0]),
     *   null
     * );
     * ```
     */
    getPreviousSiblingByPath(path: Path): Node | null;
    /**
     * 获取下一个兄弟节点，若不存在，返回 null
     * @param key
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">Hello</block>
     *     <block type="paragraph" key="world-block">World</block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getNextSibling('hello-block'),
     *   <block type="paragraph" key="world-block">World</block>
     * );
     * assertEqual(
     *   element.getNextSibling('world-block'),
     *   null
     * );
     * ```
     */
    getNextSibling(key: string): Node | null;
    /**
     * 获取下一个兄弟节点，若不存在，返回 null
     * @param path
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">Hello</block>
     *     <block type="paragraph" key="world-block">World</block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getNextSiblingByPath([0]),
     *   <block type="paragraph" key="world-block">World</block>
     * );
     * assertEqual(
     *   element.getNextSiblingByPath([1]),
     *   null
     * );
     * ```
     */
    getNextSiblingByPath(path: Path): Node | null;
    /**
     * 获取上一个叶子节点，若不存在，将返回 null
     * @param key
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="container">
     *       <block type="paragraph" key="hello-block">Hello</block>
     *       <block type="paragraph" key="world-block">World</block>
     *     </block>
     *     <block type="container">
     *       <block type="paragraph" key="cangjie-block">Cangjie</block>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getPreviousNode('cangjie-block'),
     *   <text>World</text>
     * );
     * assertEqual(
     *   element.getPreviousNode('hello-block'),
     *   null
     * );
     * ```
     */
    getPreviousNode(key: string): Node | null;
    /**
     * 获取上一个叶子节点，若不存在，将返回 null
     * @param path
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="container">
     *       <block type="paragraph" key="hello-block">Hello</block>
     *       <block type="paragraph" key="world-block">World</block>
     *     </block>
     *     <block type="container">
     *       <block type="paragraph" key="cangjie-block">Cangjie</block>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getPreviousNodeByPath([1,0]),
     *   <text>World</text>
     * );
     * assertEqual(
     *   element.getPreviousNodeByPath([0,0]),
     *   null
     * );
     * ```
     */
    getPreviousNodeByPath(path: Path): Node | null;
    /**
     * 获取下一个叶子节点，若不存在，将返回 null
     * @param key
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="container">
     *       <block type="paragraph" key="hello-block">Hello</block>
     *     </block>
     *     <block type="container">
     *       <block type="paragraph" key="world-block">World</block>
     *       <block type="paragraph" key="cangjie-block">Cangjie</block>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getNextNode('hello-block'),
     *   <text>World</text>
     * );
     * assertEqual(
     *   element.getNextNode('cangjie-block'),
     *   null
     * );
     * ```
     */
    getNextNode(key: string): Node | null;
    /**
     * 获取下一个叶子节点，若不存在，将返回 null
     * @param path
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="container">
     *       <block type="paragraph" key="hello-block">Hello</block>
     *     </block>
     *     <block type="container">
     *       <block type="paragraph" key="world-block">World</block>
     *       <block type="paragraph" key="cangjie-block">Cangjie</block>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getNextNodeByPath([0, 0]),
     *   <text>World</text>
     * );
     * assertEqual(
     *   element.getNextNodeByPath([1,1]),
     *   null
     * );
     * ```
     */
    getNextNodeByPath(path: Path): Node | null;
    /**
     * 获取上一个文本节点
     * @param key
     * @throws NodeNotFoundError 若节点不存在，则抛错
     * @returns
     *
     * * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="container">
     *       <block type="paragraph" key="hello-block">Hello</block>
     *       <block type="paragraph" key="world-block">World</block>
     *     </block>
     *     <block type="container">
     *       <block type="paragraph" key="cangjie-block">Cangjie</block>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.assertPreviousText('cangjie-block'),
     *   <text>World</text>
     * );
     * assert(() => element.assertPreviousText('hello-block')).toThrow();
     * ```
     */
    assertPreviousText(key: string): Text;
    /**
     * 获取上一个文本节点，若不存在，将返回 null
     * @param key
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="container">
     *       <block type="paragraph" key="hello-block">Hello</block>
     *       <block type="paragraph" key="world-block">World</block>
     *     </block>
     *     <block type="container">
     *       <block type="paragraph" key="cangjie-block">Cangjie</block>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getPreviousText('cangjie-block'),
     *   <text>World</text>
     * );
     * assertEqual(
     *   element.getPreviousText('hello-block'),
     *   null
     * );
     * ```
     */
    getPreviousText(key: string): Text | null;
    /**
     * 获取上一个文本节点，若不存在，将返回 null
     * @param path
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="container">
     *       <block type="paragraph" key="hello-block">Hello</block>
     *       <block type="paragraph" key="world-block">World</block>
     *     </block>
     *     <block type="container">
     *       <block type="paragraph" key="cangjie-block">Cangjie</block>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getPreviousTextByPath([1,0]),
     *   <text>World</text>
     * );
     * assertEqual(
     *   element.getPreviousTextByPath([0]),
     *   null
     * );
     * ```
     */
    getPreviousTextByPath(path: Path): Text | null;
    /**
     * 获取下一个文本节点，若不存在，将返回 null
     * @param key
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="container">
     *       <block type="paragraph" key="hello-block">Hello</block>
     *     </block>
     *     <block type="container">
     *       <block type="paragraph" key="world-block">World</block>
     *       <block type="paragraph" key="cangjie-block">Cangjie</block>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getNextText('hello-block'),
     *   <text>World</text>
     * );
     * assertEqual(
     *   element.getNextText('cangjie-block'),
     *   null
     * );
     * ```
     */
    getNextText(key: string): Text | null;
    /**
     * 获取下一个文本节点，若不存在，将返回 null
     * @param path
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="container">
     *       <block type="paragraph" key="hello-block">Hello</block>
     *     </block>
     *     <block type="container">
     *       <block type="paragraph" key="world-block">World</block>
     *       <block type="paragraph" key="cangjie-block">Cangjie</block>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getNextTextByPath([0,0]),
     *   <text>World</text>
     * );
     * assertEqual(
     *   element.getNextTextByPath([1,1]),
     *   null
     * );
     * ```
     */
    getNextTextByPath(path: Path): Text | null;
    /**
     * 获取上一个 block，若不存在，将返回 null
     * @param key
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="container">
     *       <block type="paragraph" key="hello-block">Hello</block>
     *       <block type="paragraph" key="world-block">World</block>
     *     </block>
     *     <block type="container">
     *       <block type="paragraph" key="cangjie-block">Cangjie</block>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getPreviousBlock('cangjie-block'),
     *   <block type="paragraph" key="world-block">World</block>
     * );
     * assertEqual(
     *   element.getPreviousBlock('hello-block'),
     *   null
     * );
     * ```
     */
    getPreviousBlock(key: string): Block<Data, import("./block").BlockChildren> | null;
    /**
     * 获取下一个 block，若不存在，将返回 null
     * @param key
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="container">
     *       <block type="paragraph" key="hello-block">Hello</block>
     *     </block>
     *     <block type="container">
     *       <block type="paragraph" key="world-block">World</block>
     *       <block type="paragraph" key="cangjie-block">Cangjie</block>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getNextBlock('hello-block'),
     *   <block type="paragraph" key="world-block">World</block>
     * );
     * assertEqual(
     *   element.getNextBlock('cangjie-block'),
     *   null
     * );
     * ```
     */
    getNextBlock(key: string): Block<Data, import("./block").BlockChildren> | null;
    /**
     * 获取节点 Key-to-Path 的映射表
     *
     * @example
     * ```ts
     * const element = (
     *   <block type="container" key="container">
     *     <block type="paragraph" key="world-block">
     *       <text key="world">World</text>
     *     </block>
     *     <block type="paragraph" key="hello-block">
     *       <text key="hello">Hello</text>
     *     </block>
     *   </block>
     * );
     *
     * const table = element.getKeysToEdgesTable();
     * assertEqual(
     *   table,
     *   {
     *     'world-block': ['container', 0],
     *     'world':       ['world-block', 0],
     *     'hello-block': ['container', 1],
     *     'hello':       ['hello-block', 0]
     *   }
     * );
     * ```
     */
    getKeysToEdgesTable(): KeysToEdgesTable;
    /**
     * 获取节点下的文本
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="container">
     *       <block type="paragraph" key="hello-block">Hello</block>
     *     </block>
     *     <block type="container">
     *       <block type="paragraph" key="world-block">World</block>
     *       <block type="paragraph" key="cangjie-block">Cangjie</block>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(element.text, 'HelloWorldCangjie');
     * ```
     */
    get text(): string;
    /**
     * 获得最远的满足 `predicate` 断言的祖先节点
     * @param key
     * @param predicate
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="container" key="container-1">
     *       <block type="container" key="container-2">
     *         <block type="paragraph">
     *           <text key="hello">Hello</text>
     *         </block>
     *       </block>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getFurthsest('hello', (node) => node.type === 'container'),
     *   <block type="container" key="container-1" />
     * );
     * ```
     */
    getFurthsest(key: string, predicate: Predicate<Element>): Element<Data, Node[]> | null;
    /**
     * 获得最远的满足 `predicate` 断言的祖先节点
     *
     * @param path
     * @param predicate
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="container" key="container-1">
     *       <block type="container" key="container-2">
     *         <block type="paragraph">
     *           <text key="hello">Hello</text>
     *         </block>
     *       </block>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getFurthsestByPath([0,0,0,0], (node) => node.type === 'container'),
     *   <block type="container" key="container-1" />
     * );
     * ```
     */
    getFurthsestByPath(path: Path, predicate: Predicate<Element>): Element<Data, Node[]> | null;
    /**
     * 获得最远的 Inline 祖先
     * @param key
     * @param returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <inline type="inline-block">
     *       <inline type="link">
     *         <text key="hello">Hello</text>
     *       </inline>
     *     </inline>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getFurthsestInline('hello'),
     *   <inline type="inline-block" />
     * );
     * ```
     */
    getFurthsestInline(key: string): Inline | null;
    /**
     * 获得最远的 Block 祖先
     * @param key
     * @param returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="container" key="container-1">
     *       <block type="container" data={{highlight: true}} key="container-2">
     *         <block type="paragraph">
     *           <text key="hello">Hello</text>
     *         </block>
     *       </block>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getFurthsestBlock('hello'),
     *   <block type="container" key="container-1" />
     * );
     * ```
     */
    getFurthsestBlock(key: string): Block | null;
    /**
     * 获得最远的、仅含有一个子孙的祖先
     * @param key
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="container" key="multiple-child">
     *       <block type="container" key="only-child">
     *         <block type="paragraph">
     *           <text key="hello">Hello</text>
     *         </block>
     *       </block>
     *       <block type="paragraph">World</block>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getFurthestOnlyChildAncestor('hello'),
     *   <block type="container" key="only-child" />
     * );
     * ```
     */
    getFurthestOnlyChildAncestor(key: string): Element<Data, Node[]> | null;
    /**
     * 获得最远的、仅含有一个子孙的祖先
     * @param path
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="container" key="multiple-child">
     *       <block type="container" key="only-child">
     *         <block type="paragraph">
     *           <text key="hello">Hello</text>
     *         </block>
     *       </block>
     *       <block type="paragraph">World</block>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getFurthestOnlyChildAncestorByPath([0,0,0,0]),
     *   (<block type="container" key="only-child" />)
     * );
     * ```
     */
    getFurthestOnlyChildAncestorByPath(path: Path): Element<Data, Node[]> | null;
    /**
     * 获得节点所有的祖先
     * @param key
     * @returns 祖先序列
     *
     * @example
     * ```tsx
     * const element = (
     *   <block type="container">
     *     <block type="paragraph">
     *       <text key="hello">Hello</text>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getAncestors('hello'),
     *   [
     *     <block type="container" />,
     *     <block type="paragraph" />
     *   ]
     * )
     * ```
     */
    getAncestors(key: string): Element[];
    /**
     * 获得节点所有的祖先
     * @param path
     * @returns 祖先序列
     *
     * @example
     *
     * ```tsx
     * const element = (
     *   <block type="container">
     *     <block type="paragraph">
     *       <text key="hello">Hello</text>
     *     </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getAncestorsByPath([0,0]),
     *   [
     *     <block type="container" />,
     *     <block type="paragraph" />
     *   ]
     * )
     * ```
     */
    getAncestorsByPath(path: Path | null): Element[];
    /**
     * 获得最近的满足 `predicate` 断言的祖先，祖先不包含当前节点
     * @param key
     * @param predicate
     * @returns
     *
     * @example
     *
     * ```tsx
     * const element = (
     *   <block type="container" key="container-1">
     *    <block type="container" key="container-2">
     *      <block type="paragraph">
     *        <text key="hello">Hello</text>
     *       </block>
     *    </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getClosest('hello', (node) => node.type === 'container'),
     *   <block type="container" key="container-2" />,
     * );
     *
     * assertEqual(
     *   element.getClosest('hello', (node) => node.key === 'container-1'),
     *   null,
     * );
     * ```
     */
    getClosest(key: string, predicate: Predicate<Element>): Element<Data, Node[]> | null;
    /**
     * 获得最近的满足 `predicate` 断言的祖先，祖先不包含当前节点
     * @param key
     * @param predicate
     * @returns
     *
     * @example
     *
     * ```tsx
     * const element = (
     *   <block type="container" key="container-1">
     *    <block type="container" key="container-2">
     *      <block type="paragraph">
     *        <text key="hello">Hello</text>
     *       </block>
     *    </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getClosestByPath([0,0,0], (node) => node.type === 'container'),
     *   <block type="container" key="container-2" />,
     * );
     * assertEqual(
     *   element.getClosestByPath([0,0,0], (node) => node.key === 'container-1'),
     *   null,
     * );
     * ```
     */
    getClosestByPath(path: Path | null, predicate: Predicate<Element>): Element | null;
    /**
     * 获得最近的 Inline
     * @param key
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block type="container">
     *    <inline type="highlight">
     *      <inline type="link">
     *        <text key="hello">Hello</text>
     *       </inline>
     *    </inline>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getClosestInline('hello'),
     *   <inline type="link" />,
     * );
     * ```
     */
    getClosestInline(key: string): Inline | null;
    /**
     * 获得最近的 Inline
     * @param path
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block type="container">
     *    <inline type="highlight">
     *      <inline type="link">
     *        <text key="hello">Hello</text>
     *       </inline>
     *    </inline>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getClosestInlineByPath([0,0,0]),
     *   <inline type="link" />,
     * );
     * ```
     */
    getClosestInlineByPath(path: Path): Inline | null;
    /**
     * 获取最近的 block 祖先
     * @param key
     * @returns
     * @throws NodeNotFoundError 若节点不存在，抛错
     *
     * @example
     * ```tsx
     * const element = (
     *   <block type="container" key="container-1">
     *    <block type="container" key="container-2">
     *      <block type="paragraph">
     *        <text key="hello">Hello</text>
     *       </block>
     *    </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.assertClosestBlock('hello'),
     *   <block type="paragraph" />
     * );
     * assert(() =>element.assertClosestBlock('hello')).toThrow();
     * ```
     */
    assertClosestBlock(key: string): Block;
    /**
     * 获取最近的 block 祖先
     * @param key
     * @param returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block type="container" key="container-1">
     *    <block type="container" key="container-2">
     *      <block type="paragraph">
     *        <text key="hello">Hello</text>
     *       </block>
     *    </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getClosestBlock('hello'),
     *   <block type="paragraph" />
     * );
     * assertEqual(
     *   element.getClosestBlock('hello'),
     *   null
     * );
     * ```
     */
    getClosestBlock(key: string): Block | null;
    /**
     * 获取最近的 block 祖先
     * @param path
     * @param returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block type="container" key="container-1">
     *    <block type="container" key="container-2">
     *      <block type="paragraph">
     *        <text key="hello">Hello</text>
     *       </block>
     *    </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getClosestBlockByPath([0,0,0]),
     *   <block type="paragraph" />
     * );
     * assertEqual(
     *   element.getClosestBlockByPath([]),
     *   null
     * );
     * ```
     */
    getClosestBlockByPath(path: Path): Block | null;
    /**
     * 获取最近的 block 祖先，如果节点本身就是 block，则返回节点
     * @param key
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block type="container" key="container-1">
     *    <block type="container" key="container-2">
     *      <block type="paragraph" key="hello-block">
     *        <text key="hello">Hello</text>
     *       </block>
     *    </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getClosestBlockFromPoint('hello-block'),
     *   <block type="paragraph" />
     * );
     * assertEqual(
     *   element.getClosestBlockFromPoint('hello'),
     *   <block type="paragraph" />
     * );
     * ```
     */
    getClosestBlockFromPoint(key: string): Block | null;
    /**
     * 获得最远的祖先
     * @param key
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block type="container" key="container-1">
     *    <block type="container" key="container-2">
     *      <block type="paragraph" key="paragraph">
     *        <text key="hello">Hello</text>
     *       </block>
     *    </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getFurthestAncestor('hello'),
     *   <block type="container" key="container-2" />
     * );
     * assertEqual(
     *   element.getFurthestAncestor('container-1'),
     *   null,
     * );
     * ```
     */
    getFurthestAncestor(key: string): Node | null;
    /**
     * 获得最远的祖先
     * @param key
     * @throws NodeNotFoundError 节点不存在时，抛错
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block type="container" key="container-1">
     *    <block type="container" key="container-2">
     *      <block type="paragraph" key="paragraph">
     *        <text key="hello">Hello</text>
     *       </block>
     *    </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.assertFurthestAncestor('hello'),
     *   <block type="container" key="container-2" />
     * );
     * assert(
     *   () =>element.assertFurthestAncestor('container-1'),
     * ).toThrow();
     * ```
     */
    assertFurthestAncestor(key: string): Node;
    /**
     * 获得节点的偏移位置，以文本为单位测算
     * @param key
     * @returns
     * @throws NodeNotFoundError 节点不存在时，抛错
     *
     * @example
     * ```tsx
     * const element = (
     *   <block type="container" key="container-1">
     *    <block type="paragraph" key="world-block">World</block>
     *    <block type="container" key="container-2">
     *      <block type="paragraph" key="hello-block">
     *        <text key="hello">Hello</text>
     *       </block>
     *    </block>
     *   </block>
     * );
     *
     * assertEqual(element.getOffset('hello'), 5);
     * assertEqual(element.getOffset('hello-block'), 5);
     * assertEqual(element.getOffset('world-block'), 0);
     * ```
     */
    getOffset(key: string): number;
    /**
     * 获取父节点
     * @param key
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block type="container" key="container-1">
     *    <block type="container" key="container-2">
     *      <block type="paragraph" key="paragraph">
     *        <text key="hello">Hello</text>
     *       </block>
     *    </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getParent('hello'),
     *   <block type="paragraph" />
     * );
     *
     * assertEqual(
     *   element.getParent('container-1'),
     *   null,
     * );
     * ```
     */
    getParent(key: string): Element<Data, Node[]> | null;
    /**
     * 获取父节点
     * @param key
     * @returns
     * @throws NodeNotFoundError 节点不存在时，抛错
     *
     * @example
     * ```tsx
     * const element = (
     *   <block type="container" key="container-1">
     *    <block type="container" key="container-2">
     *      <block type="paragraph" key="paragraph">
     *        <text key="hello">Hello</text>
     *       </block>
     *    </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.assertParent('hello'),
     *   <block type="paragraph" />
     * );
     * assert(() => element.assertParent('container-1')).toThrow();
     * ```
     */
    assertParent(key: string): Element<Data, Node[]>;
    /**
     * 获取父节点
     * @param path
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block type="container" key="container-1">
     *    <block type="container" key="container-2">
     *      <block type="paragraph" key="paragraph">
     *        <text key="hello">Hello</text>
     *       </block>
     *    </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getParentByPath([0,0,0]),
     *   <block type="paragraph" />
     * );
     *
     * assertEqual(
     *   element.getParentByPath([]),
     *   null,
     * );
     * ```
     */
    getParentByPath(path: Path | null): Element | null;
    /**
     * 获取公共祖先
     * @param a
     * @param b
     * @throws NodeNotFoundError 节点不存在，抛错
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block type="container" key="container">
     *    <block type="paragraph" key="hello">Hello</block>
     *    <block type="container">
     *      <block type="paragraph" key="world">World</block>
     *    </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.assertCommonAncestor('hello', 'world'),
     *   <block type="container" key="container" />
     * );
     * assertEqual(
     *   element.assertCommonAncestor('container', 'world'),
     *   <block type="container" key="container" />
     * );
     * assertEqual(
     *   () => element.assertCommonAncestor('not-exists', 'hello'),
     * ).toThrow();
     * ```
     */
    assertCommonAncestor(a: string, b: string): Element<Data, Node[]>;
    /**
     * 获取公共祖先
     * @param a
     * @param b
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block type="container" key="container">
     *    <block type="paragraph" key="hello">Hello</block>
     *    <block type="container">
     *      <block type="paragraph" key="world">World</block>
     *    </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getCommonAncestor('hello', 'world'),
     *   <block type="container" key="container" />
     * );
     * assertEqual(
     *   element.getCommonAncestor('container', 'world'),
     *   <block type="container" key="container" />
     * );
     * assertEqual(
     *   element.getCommonAncestor('not-exists', 'hello'),
     *   null,
     * );
     * ```
     */
    getCommonAncestor(a: string, b: string): Element<Data, Node[]> | null;
    /**
     * 获取 [`startKey`, `endKey`] 之间的所有 text
     * @param startKey 起始 text key
     * @param endKey   结束 text key
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block type="container" key="container">
     *    <block type="paragraph">
     *      <text key="hello">Hello</text>
     *    </block>
     *    <block type="paragraph">
     *      <text key="world">World</text>
     *    </block>
     *    <block type="container">
     *      <block type="paragraph">
     *        <text key="cangjie">Cangjie</text>
     *      </block>
     *    </block>
     *    <block type="paragraph">
     *      <text key="footer">Footer</text>
     *    </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getTextsBetweenPositions('hello', 'cangjie'),
     *   [
     *     <text key="hello">Hello</text>,
     *     <text key="world">World</text>,
     *     <text key="cangjie">Cangjie</text>,
     *   ]
     * );
     * ```
     */
    getTextsBetweenPositions(startKey: string, endKey: string): Text[];
    /**
     * 获取节点树下所有 text
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block type="container" key="container">
     *    <block type="paragraph">
     *      <text key="hello">Hello</text>
     *    </block>
     *    <block type="paragraph">
     *      <text key="world">World</text>
     *    </block>
     *    <block type="container">
     *      <block type="paragraph">
     *        <text key="cangjie">Cangjie</text>
     *      </block>
     *    </block>
     *    <block type="paragraph">
     *      <text key="footer">Footer</text>
     *    </block>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getTexts(),
     *   [
     *     <text key="hello">Hello</text>,
     *     <text key="world">World</text>,
     *     <text key="cangjie">Cangjie</text>,
     *     <text key="footer">Footer</text>
     *   ]
     * );
     * ```
     */
    getTexts(): Text[];
    /**
     * 获取节点树下所有 inline
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block type="container" key="container">
     *    <inline type="link">www.dingtalk.com</inline>
     *    <block type="paragraph">
     *      <inline type="link">www.dingding.com</inline>
     *    </block>
     *    <inline type="mention" data={{name: 'john'}}/>
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getInlines(),
     *   [
     *     <inline type="link">www.dingtalk.com</inline>,
     *     <inline type="link">www.dingding.com</type="link">,
     *     <inline type="mention" data={{name: 'john'}}/>,
     *   ]
     * );
     * ```
     */
    getInlines(): Inline[];
    /**
     * 获得节点树下所有类型为 `type` 的 inline
     * @param type
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block type="container" key="container">
     *    <inline type="link">www.dingtalk.com</inline>
     *    <block type="paragraph">
     *      <inline type="link">www.dingding.com</inline>
     *    </block>
     *    <inline type="mention" data={{name: 'john'}} />
     *   </block>
     * );
     *
     * assertEqual(
     *   element.getInlinesByType('link'),
     *   [
     *     <inline type="link">www.dingtalk.com</inline>,
     *     <inline type="link">www.dingding.com</type="link">,
     *   ]
     * );
     * ```
     */
    getInlinesByType(type: string): Inline[];
    /**
     * Map 节点树的所有子孙
     * @param map 节点映射函数
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block type="container">
     *     <block type="paragraph">Hello</block>
     *     <block type="code">const foo = 'bar';</block>
     *     <block type="paragraph">World</block>
     *   </block>
     * );
     *
     * const newElement = element.mapDescendants(node => {
     *   if (node.isElement() && node.type === "paragraph") {
     *     return node.set('data', { highlight: true });
     *   }
     *   return node;
     * })
     *
     * assertEqual(
     *   newElement,
     *   <block type="container">
     *     <block type="paragraph" data={{ highlight: true }}>Hello</block>
     *     <block type="code">const foo = 'bar';</block>
     *     <block type="paragraph" data={{ highlight: true }}>World</block>
     *   </block>
     * )
     * ```
     */
    mapDescendants(map: Iterator<Node, Node>): any;
    /**
     * 遍历自身树下所有子节点：遍历顺序为前序遍历
     * @param iterator 遍历函数；如果返回 `false`，则停止遍历当前节点的子孙，防止冗余遍历引起的性能开销
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block type="container">
     *     <block type="paragraph">Hello</block>
     *     <block type="code">const foo = 'bar';</block>
     *     <block type="paragraph">World</block>
     *   </block>
     * );
     *
     * const paragraphs: Block[] = [];
     * element.forEachDescendant(node => {
     *   if (node.isElement()) {
     *     if (node.type === "paragraph") {
     *       paragraphs.push(node);
     *     } else if (node.type === "code"){
     *       // code 下不再有 paragraph，可以提前终止对 code 的遍历
     *       return false;
     *     }
     *   }
     * });
     *
     * assertEqual(
     *   paragraphs,
     *   <block type="paragraph">Hello</block>
     *   <block type="paragraph">World</block>
     * )
     * ```
     */
    forEachDescendant(iterator: Iterator<Node | Element, boolean | void>): null;
    /**
     * 判断子孙节点中，是否有符合条件的节点
     * @param predicate 遍历函数, 相比 forEachDescendant 会降低节点遍历开销
     * @returns {boolean}
     * @example
     * ```tsx
     * const element = (
     *   <block type="container">
     *     <block type="paragraph">Hello</block>
     *     <block type="code">const foo = 'bar';</block>
     *     <block type="paragraph">World</block>
     *   </block>
     * );
     *
     * const hasCode = element.someDescendants(node => {
     *   return node.isElement() && node.type === 'code';
     * });
     *
     * const hasCard = element.someDescendants(node => {
     *  return node.isElement() && node.type === 'card';
     * })
     *
     * assertEqual(hasCode, true);
     * assertEqual(hasCard, false);
     * );
     * ```
     */
    someDescendant(predicate: Iterator<Node | Element, boolean | void>): any;
    /**
     * 过滤子孙，仅保留符合 `predicate` 断言的节点
     * @param predicate
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block type="container">
     *     <block type="paragraph">Hello</block>
     *     <block type="code">const foo = 'bar';</block>
     *     <block type="paragraph">World</block>
     *   </block>
     * );
     *
     * const filtered = element.filterDescendants(node => {
     *   return node.isElement() && node.type !== 'code';
     * });
     *
     * assertEqual(
     *   filtered,
     *   [
     *     <block type="paragraph">Hello</block>,
     *     <block type="paragraph">World</block>
     *   ]
     * );
     * ```
     */
    filterDescendants(predicate: Iterator<Node | Element, boolean>): Node[];
    /**
     * 查找节点树满足 `predicate` 断言的子孙
     * @param predicate
     * @returns
  
     * @example
     * ```tsx
     * const element = (
     *   <block type="container">
     *     <block type="paragraph">Hello</block>
     *     <block type="code">const foo = 'bar';</block>
     *     <block type="paragraph">World</block>
     *   </block>
     * );
     *
     * const code = element.findDescendant(node => {
     *   return node.isElement() && node.type === 'code'
     * });
     *
     * assertEqual(
     *   code,
     *   <block type="code">const foo = 'bar';</block>
     * );
     * ```
     */
    findDescendant(predicate: Iterator<Node | Element, boolean>): Node | null;
    /**
     * 是否 `node` 位于节点子孙中
     * @param node
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block type="container">
     *     <block type="paragraph" key="hello">Hello</block>
     *   </block>
     * );
     *
     * const hello = element.assertNode('hello');
     * const root = element.assertNodeByPath([]);
     * const cangjie = <block type="paragraph">World</block>;
     *
     * assertTrue(element.contains(hello));
     * assertFalse(element.contains(root));
     * assertFlase(element.contains(cangjie));
     * ```
     */
    contains(node?: Node | null): boolean;
    /**
     * 替换节点子树中 `path` 位置的节点为 `node`
     * @param path
     * @param node
     * @param noSpacialEffect 是否操作将影响空间，若不影响空间，将不进行 Key-to-Path Table 的重构
     * @throws NodeNotFoundError 如果节点路径错误，将抛错
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">
     *       <text key="hello">Hello</text>
     *     </block>
     *     <block type="paragraph" key="world-block">
     *       <text key="world">World</text>
     *     </block>
     *   </block>
     * );
     *
     * const newElement = element.replaceNode(
     *   [1],
     *   <block type="paragraph" key="cangjie-block">Cangjie</block>
     * );
     *
     * assertEqual(newElement, (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">
     *       <text key="hello">Hello</text>
     *     </block>
     *     <block type="paragraph" key="cangjie-block">Cangjie</block>
     *   </block>
     * ));
     * ```
     */
    replaceNode(path: Path, node: Node, noSpacialEffect?: boolean): this;
    /**
     * 在对应 `path` 的 text 节点的 `offset` 位置，为长度为 `length` 的区间添加 `mark`
     *
     * @param path
     * @param offset 偏移位置
     * @param length 文本区间长度
     * @param mark
     * @throws NodeNotFoundError 如果节点路径错误，将抛错
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">
     *       <text key="hello">HelloWorld</text>
     *     </block>
     *   </block>
     * );
     *
     * const newElement = element.addMark(
     *   [0, 0],
     *   5,
     *   5,
     *   Mark.craete('bold')
     * );
     *
     * assertEqual(newElement, (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">
     *       <text key="hello">Hello<m type="world">World</m></text>
     *     </block>
     *   </block>
     * ));
     * ```
     */
    addMark(path: Path, offset: number, length: number, mark: Mark): this;
    /**
     * 在对应 `path` 的 text 节点的 `offset` 位置，为长度为 `length` 的区间删除 `mark`
     * @param path
     * @param offset
     * @param length
     * @param mark
     * @throws NodeNotFoundError 如果节点路径错误，将抛错
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">
     *        <text key="hello">Hello<m type="world">World</m></text>
     *     </block>
     *   </block>
     * );
     *
     * const newElement = element.removeMark(
     *   [0, 0],
     *   5,
     *   5,
     *   Mark.craete('bold')
     * );
     *
     * assertEqual(newElement, (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">
     *       <text key="hello">HelloWorld</text>
     *     </block>
     *   </block>
     * ));
     * ```
     */
    removeMark(path: Path, offset: number, length: number, mark: Mark): this;
    /**
     * 在对应 `path` 的 text 节点的 `offset` 位置，为长度为 `length` 的区间设置 mark data
     * @param path
     * @param offset
     * @param length
     * @param mark
     * @param properties
     * @throws NodeNotFoundError 如果节点路径错误，将抛错
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">
     *        <text key="hello">Hello
     *          <m type="world" data={{ weight: 500 }}>World</m>
     *        </text>
     *     </block>
     *   </block>
     * );
     *
     * const newElement = element.setMark(
     *   [0, 0],
     *   5,
     *   5,
     *   Mark.craete('bold'),
     *   { data: { weight: 700 } }
     * );
     *
     * assertEqual(newElement, (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">
     *        <text key="hello">Hello
     *          <m type="world" data={{ weight: 700 }}>World</m>
     *        </text>
     *     </block>
     *   </block>
     * ));
     * ```
     */
    setMark(path: Path, offset: number, length: number, mark: Mark, properties: Partial<MarkProperties>): this;
    /**
     * 在对应 `path` 的 text 节点的 `offset` 位置，插入文本 `text`，并指定这段文本的 `marks`
     * @param path
     * @param offset
     * @param text
     * @param marks
     * @throws NodeNotFoundError 如果节点路径错误，将抛错
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">Hello</block>
     *   </block>
     * );
     *
     * const newElement = element.insertText(
     *   [0, 0],
     *   5,
     *   'World',
     *   [Mark.craete('bold'), Mark.create('italic)],
     * );
     *
     * assertEqual(newElement, (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">
     *       Hello
     *       <m type="bold"><m type="italic">World</m></m>
     *     </block>
     *   </block>
     * ));
     * ```
     */
    insertText(path: Path, offset: number, text: string, marks: Mark[]): this;
    /**
     * 在对应 `path` 的 text 节点的 `offset` 位置，删除指定的文本 `text`
     * @param path
     * @param offset
     * @param text
     * @throws NodeNotFoundError 如果节点路径错误，将抛错
     * @returns
     *
     * @exmple
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">HelloWorld</block>
     *   </block>
     * );
     *
     * const newElement = element.removeText(
     *   [0, 0],
     *   5,
     *   'World'
     * );
     *
     * assertEqual(newElement, (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">Hello</block>
     *   </block>
     * ));
     * ```
     */
    removeText(path: Path, offset: number, text: string): this;
    /**
     * 在 `path` 位置插入节点 `node`
     * @param path
     * @param node
     * @throws NodeNotFoundError 如果节点路径错误，将抛错
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">
     *       <text key="hello">Hello</text>
     *     </block>
     *   </block>
     * );
     *
     * const newElement = element.insertNode(
     *   [1],
     *   <block type="paragraph" key="world">World</block>
     * );
     *
     * assertEqual(newElement, (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">
     *       <text key="hello">Hello</text>
     *     </block>
     *     <block type="paragraph" key="world">World</block>
     *   </block>
     * ));
     * ```
     */
    insertNode(path: Path, node: Node): this;
    /**
     * 删除节点子树中 `path` 位置的节点
     * @param path
     * @throws NodeNotFoundError 如果节点路径错误，将抛错
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">Hello</block>
     *     <block type="container" key="container">
     *        <block type="paragraph" key="world-block">World</block>
     *        <block type="paragraph" key="cangjie-block">Cangjie</block>
     *     </block>
     *   </block>
     * );
     *
     * const newElement = element.removeNode([1,0]);
     *
     * assertEqual(newElement, (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">Hello</block>
     *     <block type="container" key="container">
     *       <block type="paragraph" key="cangjie-block">Cangjie</block>
     *     </block>
     *   </block>
     * ));
     * ```
     */
    removeNode(path: Path): this;
    /**
     * 将 `path` 位置的节点，合并到其前一个兄弟节点
     * @param path
     * @throws NodeNotFoundError 如果节点路径错误，将抛错
     * @throws Error 如果节点与兄弟节点类型不一致，将抛错
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">Hello</block>
     *     <block type="paragraph" key="world-block">World</block>
     *   </block>
     * );
     *
     * const newElement = element.mergeNode([1]);
     *
     * assertEqual(newElement, (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">
     *       HelloWorld
     *     </block>
     *   </block>
     * ));
     * ```
     */
    mergeNode(path: Path): this;
    /**
     * 对指定 `path` 位置的节点在 `position` 处进行拆分
     * @param path
     * @param position 拆分位置。如果是 text 节点，代表文字的偏移量；如果是 element 节点，代表子节点 index
     * @param properties 拆分 element 后，为拆分的节点设置 properties
     * @throws NodeNotFoundError 如果节点路径错误，将抛错
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block>
     *     <block type="container">
     *       <block type="paragraph" key="hello-block">Hello</block>
     *       <block type="paragraph" key="world-block">World</block>
     *     </block>
     *   </block>
     * );
     *
     * // Split Element
     * const elementSplitted = element.splitNode([0], 1, { data: { highlight: true } });
     *
     * assertEqual(newElement, (
     *   <block>
     *     <block type="container">
     *       <block type="paragraph" key="hello-block">Hello</block>
     *     </block>
     *     <block type="container" data={{ highlight: true }}>
     *       <block type="paragraph" key="world-block">World</block>
     *     </block>
     *   </block>
     * ));
     *
     * // Split Text
     * const textSplitted = element.splitNode([0,0], 3);
     *
     * assertEqual(newElement, (
     *   <block>
     *     <block type="container">
     *       <block type="paragraph" key="hello-block">
     *         <text>Hel</text><text>lo</text></block>
     *       </block>
     *     <block type="paragraph" key="world-block">World</block>
     *   </block>
     * ));
     * ```
     */
    splitNode(path: Path, position: number, properties?: Partial<ElementProperties<D, N>>): this;
    /**
     * 将 `path` 位置的节点移动到新的位置 `newPath`
     * @param path
     * @param newPath
     * @throws NodeNotFoundError 如果节点路径错误，将抛错
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">Hello</block>
     *     <block type="container" key="container">
     *        <block type="paragraph" key="world-block">World</block>
     *        <block type="paragraph" key="cangjie-block">Cangjie</block>
     *     </block>
     *   </block>
     * );
     *
     * const newElement = element.moveNode([1,0], [1]);
     *
     * assertEqual(newElement, (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block">Hello</block>
     *     <block type="paragraph" key="world-block">World</block>
     *     <block type="container" key="container">
     *       <block type="paragraph" key="cangjie-block">Cangjie</block>
     *     </block>
     *   </block>
     * ));
     * ```
     */
    moveNode(path: Path, newPath: Path): this;
    /**
     * 对指定 `path` 位置的节点设置属性
     * @param path
     * @param properties
     * @throws NodeNotFoundError 如果节点路径错误，将抛错
     * @returns
     *
     * @example
     * ```tsx
     * const element = (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block" data={{ highlight: true }}>Hello</block>
     *     <block type="paragraph" key="world-block">World</block>
     *   </block>
     * );
     *
     * const newElement = element.setNode([0], { data: { highlight: false } });
     *
     * assertEqual(newElement, (
     *   <block key="own">
     *     <block type="paragraph" key="hello-block" data={{ highlight: false }}>Hello</block>
     *     <block type="paragraph" key="world-block">World</block>
     *   </block>
     * ));
     * ```
     */
    setNode(path: Path, properties: Partial<ElementProperties<D, N>>): this;
}
export {};
