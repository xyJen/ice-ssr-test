import NodeManager from "./nodeManager";
import Document from '../models/document';
import { LayoutInfoResult } from "./interface";
export declare function measureBlockInfo(element: HTMLElement): {
    height: number;
    marginTop: number;
    marginBottom: number;
};
interface DiffResult {
    type: 'equal' | 'changed' | 'translation';
    offset?: number;
}
export declare function calculateViewPort(scrollElement: HTMLElement, scrollContainer: HTMLElement, bufferRange: number, editorContainerToScrollContainerDistance: number, _viewPortStartY?: number): {
    viewPortStartY: number;
    viewPortEndY: number;
    bufferStartY: number;
    bufferEndY: number;
};
/**
 * 计算编辑器容器到最近的滚动容器的距离
 * 编辑器容器是各种计算的原点，而视口是基于滚动容器
 * 在滚动容器高度发生变化时需要重算，典型场景是 插入封面
 * 检测这个变化非常难，目前想到两种方案，一是开发者手动触发，二是 scrollContainer 下包一层大容器，监听这个容器高度的变化
 */
export declare function calculateEditorContainerToScrollContainerDistance(editorContainer: HTMLElement, scrollContainer: HTMLElement, scrollElement: HTMLElement, scrollContainerIsBody: boolean): number;
export declare function calculateExpectedLayoutInfo(bufferStartY: number, bufferEndY: number, viewStartY: number, view: Document, nodeManager: NodeManager): LayoutInfoResult;
export declare function calculateBlockStartYByBlockIndex(blockIndex: number, view: Document, nodeManager: NodeManager, includeLastMarginBottom?: boolean): number;
export declare const fastDiffOnValueChange: (prevView: Document, currView: Document, startBlockKey: string, startBlockOffset: number, endBlockOffset: number) => DiffResult;
export declare function calculateBlockKeysNeedToMeasure(view: Document, _prevView: Document, layoutInfoResult: LayoutInfoResult, prevLayoutInfoResult?: LayoutInfoResult | null): string[];
export {};
