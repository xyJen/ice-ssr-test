import Controller from "../controller";
import { LayoutInfoResult, VirtualizeOptions, ViewRelatedOptions } from "./interface";
import NodeManager from "./nodeManager";
import OutputManager from "./outputManager";
import ViewManager from "./viewManager";
export default class VirtualizeManager {
    private _isActive;
    options: VirtualizeOptions;
    nodeManager: NodeManager;
    outputManager: OutputManager;
    viewManager?: ViewManager;
    virtualizeId: number;
    private currentLockedVirtualizeId;
    prevLayoutInfoResult?: LayoutInfoResult;
    layoutInfoResult?: LayoutInfoResult;
    viewInitialized: boolean;
    private setViewInitialized;
    waitUntilViewInitialized: Promise<void>;
    private controller;
    private prevView;
    private bufferRange?;
    get isActive(): boolean;
    /**
     * 虚拟化控制器初始化逻辑，在仓颉新建 Controller 时触发
     * @returns void
     */
    constructor(controller: Controller, options: VirtualizeOptions);
    /**
     * 在仓颉首屏渲染后的 Effect 中触发的逻辑，用于初始化 View/DOM 相关逻辑，如建立滚动事件监听
     * @returns void
     */
    initView(InitViewOptions: ViewRelatedOptions): void;
    /**
     * 启动虚拟化流程
     * @param flush 是否主动触发重渲
     * @returns void
     */
    start(flush?: boolean): void;
    /**
     * 关闭虚拟化流程
     * @param flush 是否主动触发重渲，如外界未触发重渲，需要主动触发重渲来显示所有节点
     * @returns void
     */
    stop(flush?: boolean): void;
    /**
     * 为某个虚拟化工作流增加 busy 状态位，此时可以阻止其他虚拟化工作流的发起
     * @param virtualizeId 虚拟化 id
     * @returns virtualizeId 虚拟化 id
     */
    private lock;
    /**
     * 为某个虚拟化工作流移除 busy 状态位
     * @param virtualizeId 虚拟化 id
     * @returns boolean 是否成功移除
     */
    private unlock;
    /**
     * 检查是否存在 busy 状态位
     * @param virtualizeId 虚拟化 id
     * @returns boolean 是否存在 busy 状态位
     */
    private checkLocked;
    /**
     * 更新虚拟化 id，刷新虚拟化结果（可选是否主动强制重渲）
     * @param virtualizeId 虚拟化 id
     * @param triggerReRenderActively 是否主动强制重渲
     * @returns 保存后的虚拟化 id
     */
    flushVirtualize(virtualizeId: number, triggerReRenderActively?: boolean): number;
    /**
     * 在 Cangjie 首屏渲染后执行的工作流，会测量首屏渲染的结果 (固定节点数，也不是全量节点)，并根据测量结果适当收缩节点数量
     * 最简单的虚拟化工作流，可以用于入门流程
     * @returns void
     */
    private initViewWorkflow;
    /**
     * 虚拟化粒度最小的核心工作流，一般通过其他具体业务场景的工作流调用，也可以被循环调用
     * 窗口滚动、滚动到节点、节点变化都依赖了次此工作流，initViewWorkflow 其实也可以复用，后续修改
     *
     * @param triggerReRenderActively 是否主动强制重渲
     * @param measureOnly 只上屏并测量，不触发后续流程
     * @param shouldAddLock 是否为流程设置 Busy 状态位
     * @returns 保存后的虚拟化 id
     */
    private coreWorkflow;
    /**
     * 根据当前浏览器视口位置，决定需要渲染哪些节点，以及 Placeholder 需要渲染多高的工作流
     * 浏览器的 scroll 事件会触发此工作流
     * 这个工作流的特点是会递归调用自己，直到得到最终的结果
     */
    private workflowByCurrentViewPort;
    /**
     * 根据指定的节点 index，跳转到此节点的工作流
     * 供大纲等跳转场景使用
     * @param nodeIndex Cangjie 节点在文档内的 index
     */
    workflowToScrollToNode: (nodeIndex: number) => Promise<void>;
    /**
     * 节点变化时触发的工作流
     */
    workflowOnValueChange: () => Promise<void>;
    /**
     * scroll 事件触发的工作流
     */
    private scrollHandler;
    /**
     * resizeObserver 触发的工作流
     * 节点高度变化时，会触发 resizeObserver 回调，这里检查发现高度确实变化了，则会触发后续工作流
     * 详细注释后续再补充
     */
    private resizeHandler;
}
