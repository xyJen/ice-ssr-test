"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _everUtils = require("@ali/4ever-utils");

var _getBorder = _interopRequireDefault(require("./getBorder"));

var _constants = require("../constants");

var _default = (data, isAutoFit) => {
  let rotationObj;
  const {
    width,
    height,
    opacity,
    outline,
    rectClip = {},
    radius = _constants.DEFAULT_RADIUS
  } = data;
  const rotation = (0, _everUtils.normalizeAngle)(data?.rotation || 0);
  let border;
  let outlineWidth = 0;

  if (outline && outline.width) {
    border = (0, _getBorder.default)(outline);
    outlineWidth = outline.width;
  }

  if (rotation !== 0 && width > 0 && height > 0) {
    rotationObj = (0, _everUtils.calcRotationObj)(width, height, rotation);
  }

  const frameStyle = {
    width,
    height,
    opacity,
    transform: undefined
  };
  const borderStyle = {
    border,
    borderRadius: radius
  };

  if (rotationObj) {
    frameStyle.transform = `translate(${rotationObj.translateX}px, ${rotationObj.translateY}px) rotate(${rotation}deg)`;
  }

  const rotateStyle = {
    width: rotationObj ? rotationObj.rWidth : width,
    height: rotationObj ? rotationObj.rHeight : height
  };
  const l = rectClip.left || 0;
  const r = rectClip.right || 0;
  const t = rectClip.top || 0;
  const b = rectClip.bottom || 0;
  const imgStyle = {
    left: -l - outlineWidth,
    top: -t - outlineWidth,
    width: typeof width === 'number' ? width + l + r : width,
    height: typeof height === 'number' ? height + t + b : height,
    position: 'absolute',
    // 解决 iPad 上 overflow 不生效的问题
    clipPath: `inset(${t + outlineWidth}px ${r + outlineWidth}px ${b + outlineWidth}px ${l + outlineWidth}px)`,
    WebkitClipPath: `inset(${t + outlineWidth}px ${r + outlineWidth}px ${b + outlineWidth}px ${l + outlineWidth}px)`
  };

  if (isAutoFit) {
    const proportion = Number((rotateStyle.height / rotateStyle.width).toFixed(5));

    if (!Number.isNaN(proportion) && typeof width === 'number' && typeof height === 'number') {
      const imgWidth = width + l + r;
      const imgHeight = height + t + b;
      imgStyle.left = `calc(100% * ${-l / width})`;
      imgStyle.top = `calc(100% * ${-t / height})`;
      imgStyle.width = `calc(100% * ${imgWidth / width})`;
      imgStyle.height = `calc(100% * ${imgHeight / height})`;
      const clipPath = `inset(calc(100% * ${t / imgHeight}) calc(100% * ${r / imgWidth}) calc(100% * ${b / imgHeight}) calc(100% * ${l / imgWidth}))`;
      imgStyle.clipPath = clipPath;
      imgStyle.WebkitClipPath = clipPath;

      if (rotationObj) {
        frameStyle.transform = `rotate(${rotation}deg)`;
        frameStyle.left = `calc(100% * ${rotationObj.translateX / rotateStyle.width})`;
        frameStyle.top = `calc(100% * ${rotationObj.translateY / rotateStyle.height})`;
        frameStyle.width = `calc(100% * ${width / rotateStyle.width})`;
        frameStyle.height = `calc(100% * ${height / rotateStyle.height})`;
      } else {
        frameStyle.left = 0;
        frameStyle.top = 0;
        frameStyle.width = '100%';
        frameStyle.height = '100%';
      }

      rotateStyle.maxWidth = '100%';
      rotateStyle.paddingTop = `calc(100% * ${proportion})`;
      rotateStyle.height = 0;
    }
  }

  return {
    rotateStyle,
    frameStyle,
    imgStyle,
    borderStyle,
    outlineWidth
  };
};

exports.default = _default;
//# sourceMappingURL=calcComplexImage.js.map