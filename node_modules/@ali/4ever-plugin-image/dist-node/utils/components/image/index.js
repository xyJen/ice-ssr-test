"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _react = _interopRequireDefault(require("react"));

var _everCangjie = require("@ali/4ever-cangjie");

var _everPluginTable = require("@ali/4ever-plugin-table");

var _everUtils = require("@ali/4ever-utils");

var _hooks = require("../../hooks");

var _uploading = _interopRequireDefault(require("../uploading"));

var _constants = require("./constants");

var _Image = require("./Image");

var _types = require("../types");

var _isNodeInTable = require("../../utils/isNodeInTable");

const _createElement = /*#__PURE__*/_react.default.createElement;

require('intersection-observer');

function getRenderSrcInitVal(node, config, imageManager) {
  const {
    src
  } = node.data;
  const {
    forceRenderDirectly,
    enableLazyLoad
  } = config;

  if (src && typeof forceRenderDirectly === 'function') {
    return forceRenderDirectly(src, node);
  } // 没有设置 transformImageURL 且不开启懒加载，就直接渲染图片


  if (!src || !imageManager && !enableLazyLoad) {
    return src;
  }

  if (imageManager && imageManager.isImgSrcRegistered(src)) {
    return imageManager.getTransformedURL(src);
  }

  return '';
}

class ImageInnerComp extends _react.default.Component {
  constructor(props) {
    super(props);
    this.logFlag = {};
    this.loadStartTime = void 0;
    this.observer = null;
    this.wrapperRef = /*#__PURE__*/_react.default.createRef();
    this.isInTable = false;

    this.startLoadImage = () => {
      const {
        imageManager,
        node
      } = this.props;

      if (imageManager) {
        imageManager?.register(node.data.src, node).then(renderSrc => {
          this.setState({
            renderSrc
          });
        });
      } else {
        this.setState({
          renderSrc: node.data.src
        });
      }
    };

    this.onStatusChange = status => {
      const {
        imageConfig = {},
        node,
        onLoad
      } = this.props;
      const {
        renderSrc
      } = this.state;
      const {
        onError: configOnError,
        onLoad: configOnLoad
      } = imageConfig;
      renderSrc && this.setState({
        status
      });

      if (status === _types.Status.Error) {
        if (typeof configOnError === 'function' && !this.logFlag.error) {
          this.logFlag.error = true;
          const errorSrc = configOnError(renderSrc, node.data.extraData);

          if (typeof errorSrc === 'string' && errorSrc) {
            this.setState({
              renderSrc: errorSrc
            });
          }
        }

        return;
      }

      if (status === _types.Status.Success && node.data.src && renderSrc) {
        if (typeof configOnLoad === 'function' && !this.logFlag.load) {
          const time = this.loadStartTime ? Date.now() - this.loadStartTime : 0;
          configOnLoad(renderSrc, time, node.data);
        }

        onLoad && onLoad(renderSrc);
      }
    };

    const {
      imageConfig: _imageConfig,
      imageManager: _imageManager,
      node: _node
    } = props;
    this.state = {
      renderSrc: getRenderSrcInitVal(_node, _imageConfig, _imageManager),
      status: _types.Status.Loading
    };
  }

  componentDidMount() {
    const {
      imageConfig,
      node,
      uploadPlaceholder,
      isTransferring,
      isInStickyTableRow,
      scrollableContainer,
      controller,
      imageManager
    } = this.props;
    const {
      onInit,
      enableLazyLoad
    } = imageConfig;
    const {
      src
    } = node.data;
    onInit && onInit(node.data.src);
    const isUploading = !src && typeof uploadPlaceholder === 'string';
    const disableLazyLoad = isUploading || isTransferring || isInStickyTableRow;

    if (!disableLazyLoad && enableLazyLoad && this.wrapperRef.current) {
      const root = scrollableContainer instanceof Window || scrollableContainer === window.document.documentElement ? null : scrollableContainer || null;
      this.observer = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
          if (entry.intersectionRatio > 0 || entry.isIntersecting) {
            this.startLoadImage();
            observer.disconnect();
          }
        });
      }, {
        threshold: [0],
        rootMargin: _constants.ROOT_MARGIN,
        root
      });
      this.observer.observe(this.wrapperRef.current);
    } // 未开启懒加载，需要触发图片转换


    if (!enableLazyLoad && !this.state.renderSrc) {
      this.startLoadImage();
    }

    this.isInTable = (0, _isNodeInTable.isNodeInTable)(node, controller.value.document);
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    const {
      src: prevSrc
    } = prevProps.node.data;
    const {
      src
    } = this.props.node.data;

    if (!prevSrc && src) {
      const {
        uploadPlaceholder
      } = this.props; // 上传

      if (uploadPlaceholder) {
        const preloadImg = new window.Image();
        preloadImg.src = src;

        if (preloadImg.decode) {
          preloadImg.decode().then(() => {
            this.startLoadImage();
          }).catch(() => {
            this.startLoadImage();
          });
        } else {
          this.startLoadImage();
        }

        return;
      } // 转存 or 移动端插入图片


      this.startLoadImage();
    }
  }

  componentWillUnmount() {
    this.observer?.disconnect();
  }

  render() {
    const {
      node,
      uploadPlaceholder,
      uploadProgress,
      onRef,
      isMobile,
      imageConfig,
      isTransferring,
      isInserting,
      style,
      onClick,
      onDoubleClick,
      onMouseDown,
      onContextMenu,
      onTouchStart,
      onTouchMove,
      onTouchEnd
    } = this.props;
    const {
      renderSrc,
      status
    } = this.state;
    const {
      data
    } = node;
    const {
      disableNativeDownload,
      disableStretchMode,
      protocolAllowList,
      forceRenderDirectly
    } = imageConfig;
    const showUploadPlaceholder = !renderSrc && typeof uploadPlaceholder === 'string' && !!uploadPlaceholder;
    const isUploading = status === _types.Status.Loading && typeof uploadPlaceholder === 'string';
    const disableTouchCallout = isMobile && disableNativeDownload && disableNativeDownload();
    const metaStyle = { ...style,
      opacity: isUploading ? 0.2 : 1,
      WebkitTouchCallout: disableTouchCallout ? 'none' : 'unset'
    };
    const isAutoFit = isMobile || !(typeof disableStretchMode === 'function' && disableStretchMode()) || this.isInTable;
    const imgSrc = showUploadPlaceholder ? uploadPlaceholder : (0, _everUtils.sanitizeUrl)(renderSrc, protocolAllowList); // 以下情况不会因为 data.src 为空就渲染图裂，而是加载状态
    // 1. 转存图片
    // 2. 移动端插入图片
    // 3. 上传当前浏览器不支持的图片格式，无法在上传过程预览，但是上传后可通过格式转换渲染出来

    const forceLoading = !data.src && (isTransferring || isInserting || uploadPlaceholder === '');

    if (!this.loadStartTime && !!renderSrc) {
      this.loadStartTime = Date.now();
    }

    return /*#__PURE__*/_createElement(_react.default.Fragment, null, /*#__PURE__*/_createElement(_Image.Image, {
      data: data,
      imgSrc: imgSrc,
      style: metaStyle,
      onStatusChange: this.onStatusChange,
      onImgRef: onRef,
      onWrapperRef: this.wrapperRef,
      isMobile: isMobile,
      disableLoading: !!forceRenderDirectly,
      forceLoading: forceLoading,
      onClick: onClick,
      onDoubleClick: onDoubleClick,
      onMouseDown: onMouseDown,
      onContextMenu: onContextMenu,
      onTouchStart: onTouchStart,
      onTouchMove: onTouchMove,
      onTouchEnd: onTouchEnd,
      isAutoFit: isAutoFit
    }), isUploading && /*#__PURE__*/_createElement(_uploading.default, {
      progress: uploadProgress || 0
    }));
  }

}

const ImageComp = /*#__PURE__*/_react.default.forwardRef((props, ref) => {
  const imageManager = (0, _hooks.useImageManager)();
  const [isInStickyTableRow] = (0, _everPluginTable.useRowIsSticky)();
  const scrollableContainer = (0, _everCangjie.useScrollableContainer)();
  const scale = (0, _everCangjie.useZoom)();
  return /*#__PURE__*/_createElement(ImageInnerComp, (0, _extends2.default)({}, props, {
    imageManager: imageManager,
    isInStickyTableRow: isInStickyTableRow,
    scrollableContainer: scrollableContainer,
    scale: scale,
    onRef: ref
  }));
});

var _default = ImageComp;
exports.default = _default;
//# sourceMappingURL=index.js.map