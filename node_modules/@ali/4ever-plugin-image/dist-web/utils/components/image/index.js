import _extends from "@babel/runtime/helpers/extends";
import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";
import React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import { useScrollableContainer, useZoom } from '@ali/4ever-cangjie';
import { useRowIsSticky } from '@ali/4ever-plugin-table';
import { sanitizeUrl } from '@ali/4ever-utils';
import { useImageManager } from "../../hooks";
import Uploading from "../uploading";
import { ROOT_MARGIN } from "./constants";
import { Image as ImgComp } from "./Image";
import { Status } from "../types";
import { isNodeInTable } from "../../utils/isNodeInTable";

require('intersection-observer');

function getRenderSrcInitVal(node, config, imageManager) {
  var src = node.data.src;
  var forceRenderDirectly = config.forceRenderDirectly,
      enableLazyLoad = config.enableLazyLoad;

  if (src && typeof forceRenderDirectly === 'function') {
    return forceRenderDirectly(src, node);
  } // 没有设置 transformImageURL 且不开启懒加载，就直接渲染图片


  if (!src || !imageManager && !enableLazyLoad) {
    return src;
  }

  if (imageManager && imageManager.isImgSrcRegistered(src)) {
    return imageManager.getTransformedURL(src);
  }

  return '';
}

var ImageInnerComp = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(ImageInnerComp, _React$Component);

  function ImageInnerComp(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.logFlag = {};
    _this.loadStartTime = void 0;
    _this.observer = null;
    _this.wrapperRef = /*#__PURE__*/React.createRef();
    _this.isInTable = false;

    _this.startLoadImage = function () {
      var _this$props = _this.props,
          imageManager = _this$props.imageManager,
          node = _this$props.node;

      if (imageManager) {
        imageManager == null ? void 0 : imageManager.register(node.data.src, node).then(function (renderSrc) {
          _this.setState({
            renderSrc: renderSrc
          });
        });
      } else {
        _this.setState({
          renderSrc: node.data.src
        });
      }
    };

    _this.onStatusChange = function (status) {
      var _this$props2 = _this.props,
          _this$props2$imageCon = _this$props2.imageConfig,
          imageConfig = _this$props2$imageCon === void 0 ? {} : _this$props2$imageCon,
          node = _this$props2.node,
          onLoad = _this$props2.onLoad;
      var renderSrc = _this.state.renderSrc;
      var configOnError = imageConfig.onError,
          configOnLoad = imageConfig.onLoad;
      renderSrc && _this.setState({
        status: status
      });

      if (status === Status.Error) {
        if (typeof configOnError === 'function' && !_this.logFlag.error) {
          _this.logFlag.error = true;
          var errorSrc = configOnError(renderSrc, node.data.extraData);

          if (typeof errorSrc === 'string' && errorSrc) {
            _this.setState({
              renderSrc: errorSrc
            });
          }
        }

        return;
      }

      if (status === Status.Success && node.data.src && renderSrc) {
        if (typeof configOnLoad === 'function' && !_this.logFlag.load) {
          var time = _this.loadStartTime ? Date.now() - _this.loadStartTime : 0;
          configOnLoad(renderSrc, time, node.data);
        }

        onLoad && onLoad(renderSrc);
      }
    };

    var _imageConfig = props.imageConfig,
        _imageManager = props.imageManager,
        _node = props.node;
    _this.state = {
      renderSrc: getRenderSrcInitVal(_node, _imageConfig, _imageManager),
      status: Status.Loading
    };
    return _this;
  }

  var _proto = ImageInnerComp.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;

    var _this$props3 = this.props,
        imageConfig = _this$props3.imageConfig,
        node = _this$props3.node,
        uploadPlaceholder = _this$props3.uploadPlaceholder,
        isTransferring = _this$props3.isTransferring,
        isInStickyTableRow = _this$props3.isInStickyTableRow,
        scrollableContainer = _this$props3.scrollableContainer,
        controller = _this$props3.controller,
        imageManager = _this$props3.imageManager;
    var onInit = imageConfig.onInit,
        enableLazyLoad = imageConfig.enableLazyLoad;
    var src = node.data.src;
    onInit && onInit(node.data.src);
    var isUploading = !src && typeof uploadPlaceholder === 'string';
    var disableLazyLoad = isUploading || isTransferring || isInStickyTableRow;

    if (!disableLazyLoad && enableLazyLoad && this.wrapperRef.current) {
      var root = scrollableContainer instanceof Window || scrollableContainer === window.document.documentElement ? null : scrollableContainer || null;
      this.observer = new IntersectionObserver(function (entries, observer) {
        entries.forEach(function (entry) {
          if (entry.intersectionRatio > 0 || entry.isIntersecting) {
            _this2.startLoadImage();

            observer.disconnect();
          }
        });
      }, {
        threshold: [0],
        rootMargin: ROOT_MARGIN,
        root: root
      });
      this.observer.observe(this.wrapperRef.current);
    } // 未开启懒加载，需要触发图片转换


    if (!enableLazyLoad && !this.state.renderSrc) {
      this.startLoadImage();
    }

    this.isInTable = isNodeInTable(node, controller.value.document);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState, snapshot) {
    var _this3 = this;

    var prevSrc = prevProps.node.data.src;
    var src = this.props.node.data.src;

    if (!prevSrc && src) {
      var uploadPlaceholder = this.props.uploadPlaceholder; // 上传

      if (uploadPlaceholder) {
        var preloadImg = new window.Image();
        preloadImg.src = src;

        if (preloadImg.decode) {
          preloadImg.decode().then(function () {
            _this3.startLoadImage();
          })["catch"](function () {
            _this3.startLoadImage();
          });
        } else {
          this.startLoadImage();
        }

        return;
      } // 转存 or 移动端插入图片


      this.startLoadImage();
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    var _this$observer;

    (_this$observer = this.observer) == null ? void 0 : _this$observer.disconnect();
  };

  _proto.render = function render() {
    var _this$props4 = this.props,
        node = _this$props4.node,
        uploadPlaceholder = _this$props4.uploadPlaceholder,
        uploadProgress = _this$props4.uploadProgress,
        onRef = _this$props4.onRef,
        isMobile = _this$props4.isMobile,
        imageConfig = _this$props4.imageConfig,
        isTransferring = _this$props4.isTransferring,
        isInserting = _this$props4.isInserting,
        style = _this$props4.style,
        onClick = _this$props4.onClick,
        onDoubleClick = _this$props4.onDoubleClick,
        onMouseDown = _this$props4.onMouseDown,
        onContextMenu = _this$props4.onContextMenu,
        onTouchStart = _this$props4.onTouchStart,
        onTouchMove = _this$props4.onTouchMove,
        onTouchEnd = _this$props4.onTouchEnd;
    var _this$state = this.state,
        renderSrc = _this$state.renderSrc,
        status = _this$state.status;
    var data = node.data;
    var disableNativeDownload = imageConfig.disableNativeDownload,
        disableStretchMode = imageConfig.disableStretchMode,
        protocolAllowList = imageConfig.protocolAllowList,
        forceRenderDirectly = imageConfig.forceRenderDirectly;
    var showUploadPlaceholder = !renderSrc && typeof uploadPlaceholder === 'string' && !!uploadPlaceholder;
    var isUploading = status === Status.Loading && typeof uploadPlaceholder === 'string';
    var disableTouchCallout = isMobile && disableNativeDownload && disableNativeDownload();

    var metaStyle = _extends({}, style, {
      opacity: isUploading ? 0.2 : 1,
      WebkitTouchCallout: disableTouchCallout ? 'none' : 'unset'
    });

    var isAutoFit = isMobile || !(typeof disableStretchMode === 'function' && disableStretchMode()) || this.isInTable;
    var imgSrc = showUploadPlaceholder ? uploadPlaceholder : sanitizeUrl(renderSrc, protocolAllowList); // 以下情况不会因为 data.src 为空就渲染图裂，而是加载状态
    // 1. 转存图片
    // 2. 移动端插入图片
    // 3. 上传当前浏览器不支持的图片格式，无法在上传过程预览，但是上传后可通过格式转换渲染出来

    var forceLoading = !data.src && (isTransferring || isInserting || uploadPlaceholder === '');

    if (!this.loadStartTime && !!renderSrc) {
      this.loadStartTime = Date.now();
    }

    return /*#__PURE__*/_createElement(React.Fragment, null, /*#__PURE__*/_createElement(ImgComp, {
      data: data,
      imgSrc: imgSrc,
      style: metaStyle,
      onStatusChange: this.onStatusChange,
      onImgRef: onRef,
      onWrapperRef: this.wrapperRef,
      isMobile: isMobile,
      disableLoading: !!forceRenderDirectly,
      forceLoading: forceLoading,
      onClick: onClick,
      onDoubleClick: onDoubleClick,
      onMouseDown: onMouseDown,
      onContextMenu: onContextMenu,
      onTouchStart: onTouchStart,
      onTouchMove: onTouchMove,
      onTouchEnd: onTouchEnd,
      isAutoFit: isAutoFit
    }), isUploading && /*#__PURE__*/_createElement(Uploading, {
      progress: uploadProgress || 0
    }));
  };

  return ImageInnerComp;
}(React.Component);

var ImageComp = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var imageManager = useImageManager();

  var _useRowIsSticky = useRowIsSticky(),
      isInStickyTableRow = _useRowIsSticky[0];

  var scrollableContainer = useScrollableContainer();
  var scale = useZoom();
  return /*#__PURE__*/_createElement(ImageInnerComp, _extends({}, props, {
    imageManager: imageManager,
    isInStickyTableRow: isInStickyTableRow,
    scrollableContainer: scrollableContainer,
    scale: scale,
    onRef: ref
  }));
});
export default ImageComp;
//# sourceMappingURL=index.js.map