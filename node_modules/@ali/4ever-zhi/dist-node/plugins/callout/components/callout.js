"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var React = _interopRequireWildcard(require("react"));

var _everCangjie = require("@ali/4ever-cangjie");

var _everUtils = require("@ali/4ever-utils");

var _everBamboo = require("@ali/4ever-bamboo");

var _utils = require("../utils");

const _createElement = /*#__PURE__*/React.createElement;
const {
  StickerItem
} = _everBamboo.StickerPlugin;
const {
  CalloutBoxWrapper,
  CalloutBox,
  ContentBox,
  StickerBox,
  StickerInnerBox,
  DEFAULTS,
  STICKER_SIZE,
  PADDING_TOP
} = _everBamboo.CalloutPlugin;

/**
 * 高亮区块
 * @param props
 * @returns
 */
const Callout = props => {
  const {
    node,
    attributes,
    children,
    sticker
  } = props;
  const contentBoxRef = React.useRef();
  const stickerBoxRef = React.useRef();
  const {
    nodes
  } = node;
  const {
    bgcolor = DEFAULTS.bgcolor,
    sticker: stickerCode = DEFAULTS.stcode,
    border,
    showSticker
  } = React.useMemo(() => {
    if ((0, _utils.isCallout)(node)) {
      const {
        calloutPr
      } = node.data;
      return {
        bgcolor: calloutPr?.backgroundColor,
        sticker: calloutPr?.stickerCode,
        showSticker: true
      };
    } else {
      const {
        metadata
      } = node.data;
      return { ...metadata,
        showSticker: Boolean(metadata.showstk)
      };
    }
  }, [node]); // 边框色默认为背景色, 使边框和文字对齐

  let borderColor = border || bgcolor;

  if (!border && bgcolor === '#FFFFFF') {
    borderColor = DEFAULTS.whiteBorder;
  }

  const [stickerTop, setStickerTop] = React.useState(0);
  const zoom = (0, _everCangjie.useZoom)();
  React.useEffect(() => {
    if (stickerBoxRef.current && nodes[0]) {
      const rect = (0, _everUtils.getRectOfNodeFirstText)(nodes[0]);
      const stickerRect = stickerBoxRef.current?.getBoundingClientRect();

      if (rect && rect.height && stickerRect) {
        const newTop = rect.top / zoom - stickerRect.top / zoom - PADDING_TOP + (rect.height / zoom - STICKER_SIZE) / 2 - 1;
        setStickerTop(Math.round(newTop));
      }
    }
  }, [node, nodes, stickerBoxRef, zoom]);
  const stopPropagation = React.useCallback(event => {
    event.stopPropagation();
  }, []);
  return /*#__PURE__*/_createElement(CalloutBoxWrapper, (0, _extends2.default)({}, attributes, {
    "data-cangjie-group-block": true
  }), /*#__PURE__*/_createElement(CalloutBox, {
    className: "callout-box",
    backgroundColor: bgcolor,
    borderColor: borderColor,
    tabIndex: 0
  }, Boolean(showSticker) && /*#__PURE__*/_createElement(StickerBox, {
    ref: stickerBoxRef,
    onMouseDown: stopPropagation,
    onClick: stopPropagation
  }, /*#__PURE__*/_createElement(StickerInnerBox, {
    style: {
      top: stickerTop
    }
  }, /*#__PURE__*/_createElement(StickerItem, {
    sz: STICKER_SIZE,
    code: stickerCode,
    sticker: sticker
  }))), /*#__PURE__*/_createElement(ContentBox, {
    showSticker: showSticker,
    ref: contentBoxRef
  }, children)));
};

Callout.displayName = 'Callout';
var _default = Callout;
exports.default = _default;
//# sourceMappingURL=callout.js.map