import _extends from "@babel/runtime/helpers/extends";

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import * as React from 'react';
import { v4 as uuid } from 'uuid';
import NavigationBar from '../components/NavigationBar';
import DividerPlugin from '../plugins/divider';
import { initialSelection } from '../share/var';
import getDecorated from '../utils/decorate';
import { getLineAndCol } from '../utils/tool';
import mergeConfig from '../utils/mergeConfig';
import defaultConfig from './defaultConfig';
import Emitter from '../share/emitter';
import BlockCodeBlock from '../plugins/block/code-block';
import BlockQuote from '../plugins/block/quote';
import FontBold from '../plugins/font/bold';
import FontItalic from '../plugins/font/italic';
import FontStrikethrough from '../plugins/font/strikethrough';
import Header from '../plugins/header';
import Image from '../plugins/Image';
import Link from '../plugins/link';
import ListOrdered from '../plugins/list/ordered';
import ListUnordered from '../plugins/list/unordered';
import Emoji from '../plugins/emoji';
import Table from '../plugins/table';
import classNames from 'classnames'; // import TabInsert from '../plugins/tabInsert';

var nodeMdText = /*#__PURE__*/React.createRef();
var nodeMdPreview = /*#__PURE__*/React.createRef();
var keyboardListeners = [];
var pluginApis = new Map();
var emitter;
emitter = new Emitter();

var getEventType = function getEventType(event) {
  switch (event) {
    case 'change':
      return emitter.EVENT_CHANGE;

    case 'fullscreen':
      return emitter.EVENT_FULL_SCREEN;

    case 'viewchange':
      return emitter.EVENT_VIEW_CHANGE;

    case 'keydown':
      return emitter.EVENT_KEY_DOWN;

    case 'editor_keydown':
      return emitter.EVENT_EDITOR_KEY_DOWN;

    case 'blur':
      return emitter.EVENT_BLUR;

    case 'focus':
      return emitter.EVENT_FOCUS;

    case 'scroll':
      return emitter.EVENT_SCROLL;
  }
}; // nodeMdText = React.createRef();


export { nodeMdText };
export var EditorToolbar = function EditorToolbar(props) {
  if (props.nodeMdText) {
    nodeMdText = props.nodeMdText;
  }

  var config;
  config = mergeConfig(defaultConfig, props.config, props);

  var _React$useState = React.useState(''),
      stateText = _React$useState[0],
      setStateText = _React$useState[1];

  var _React$useState2 = React.useState(''),
      stateHtml = _React$useState2[0],
      setStateHtml = _React$useState2[1];

  var PluginList = [];

  var use = function use(comp, config) {
    if (config === void 0) {
      config = {};
    }

    // Check for duplicate plugins
    for (var i = 0; i < PluginList.length; i++) {
      if (PluginList[i].comp === comp) {
        PluginList.splice(i, 1, {
          comp: comp,
          config: config
        });
        return;
      }
    }

    PluginList.push({
      comp: comp,
      config: config
    });
  };

  var editor = {
    getSelection: function getSelection() {
      var source = nodeMdText.current;

      if (!source) {
        return _extends({}, initialSelection);
      }

      var start = source.selectionStart;
      var end = source.selectionEnd;
      var text = (source.value || '').slice(start, end);
      return {
        start: start,
        end: end,
        text: text
      };
    },
    insertMarkdown: function insertMarkdown(type, option) {
      if (option === void 0) {
        option = {};
      }

      var curSelection = editor.getSelection();
      var decorateOption = option ? _extends({}, option) : {};

      if (type === 'image') {
        decorateOption = _extends({}, decorateOption, {
          target: option.target || curSelection.text || '',
          imageUrl: option.imageUrl || config.imageUrl
        });
      }

      if (type === 'link') {
        decorateOption = _extends({}, decorateOption, {
          linkUrl: config.linkUrl
        });
      }

      if (type === 'tab' && curSelection.start !== curSelection.end) {
        var curLineStart = editor.getMdValue().slice(0, curSelection.start).lastIndexOf('\n') + 1;
        editor.setSelection({
          start: curLineStart,
          end: curSelection.end
        });
      }

      var decorate = getDecorated(curSelection.text, type, decorateOption);
      var text = decorate.text;
      var selection = decorate.selection;

      if (decorate.newBlock) {
        var startLineInfo = getLineAndCol(editor.getMdValue(), curSelection.start);
        var col = startLineInfo.col,
            curLine = startLineInfo.curLine;

        if (col > 0 && curLine.length > 0) {
          text = "\n" + text;

          if (selection) {
            selection.start++;
            selection.end++;
          }
        }

        var afterText = startLineInfo.afterText;

        if (curSelection.start !== curSelection.end) {
          afterText = getLineAndCol(editor.getMdValue(), curSelection.end).afterText;
        }

        if (afterText.trim() !== '' && afterText.substr(0, 2) !== '\n\n') {
          if (afterText.substr(0, 1) !== '\n') {
            text += '\n';
          }

          text += '\n';
        }
      }

      editor.insertText(text, true, selection);
    },
    getMdValue: function getMdValue() {
      var _nodeMdText$current;

      return ((_nodeMdText$current = nodeMdText.current) === null || _nodeMdText$current === void 0 ? void 0 : _nodeMdText$current.value) || '';
    },
    setSelection: function setSelection(to) {
      if (nodeMdText.current) {
        nodeMdText.current.setSelectionRange(to.start, to.end, 'forward');
        nodeMdText.current.focus();
      }
    },
    insertText: function insertText(value, replaceSelected, newSelection) {
      var _nodeMdText$current2;

      if (value === void 0) {
        value = '';
      }

      if (replaceSelected === void 0) {
        replaceSelected = false;
      }

      var text = ((_nodeMdText$current2 = nodeMdText.current) === null || _nodeMdText$current2 === void 0 ? void 0 : _nodeMdText$current2.value) || '';
      var selection = editor.getSelection();
      var beforeContent = text.slice(0, selection.start);
      var afterContent = text.slice(replaceSelected ? selection.end : selection.start, text.length);
      editor.setText(beforeContent + value + afterContent, undefined, newSelection ? {
        start: newSelection.start + beforeContent.length,
        end: newSelection.end + beforeContent.length
      } : {
        start: selection.start,
        end: selection.start
      });
    },
    setText: function setText(value, event, newSelection) {
      var _nodeMdText$current3;

      if (value === void 0) {
        value = '';
      }

      // const { onChangeTrigger = 'both' } = config;
      var onChangeTrigger = 'both';
      var text = value.replace(/â†µ/g, '\n');

      if (((_nodeMdText$current3 = nodeMdText.current) === null || _nodeMdText$current3 === void 0 ? void 0 : _nodeMdText$current3.value) === value) {
        return;
      }

      setStateText(text);

      if (nodeMdText.current) {
        nodeMdText.current.value = text;
      }

      if (props.onChange && (onChangeTrigger === 'both' || onChangeTrigger === 'beforeRender')) {
        props.onChange({
          text: text,
          html: editor.getHtmlValue()
        }, event);
      }

      emitter.emit(emitter.EVENT_CHANGE, value, event, typeof event === 'undefined');

      if (newSelection) {
        setTimeout(function () {
          return editor.setSelection(newSelection);
        });
      } // if (!this.hasContentChanged) {
      //   this.hasContentChanged = true;
      // }
      // const rendering = this.renderHTML(text);
      // if (onChangeTrigger === 'both' || onChangeTrigger === 'afterRender') {
      //   rendering.then(() => {
      //     if (this.props.onChange) {
      //       this.props.onChange(
      //         {
      //           text: this.state.text,
      //           html: this.getHtmlValue(),
      //         },
      //         event,
      //       );
      //     }
      //   });
      // }

    },
    getHtmlValue: function getHtmlValue() {
      if (typeof stateHtml === 'string') {
        return stateHtml;
      }

      if (nodeMdPreview.current) {
        return nodeMdPreview.current.getHtml();
      }

      return '';
    },
    offKeyboard: function offKeyboard(data) {
      if (Array.isArray(data)) {
        data.forEach(function (it) {
          return editor.offKeyboard(it);
        });
        return;
      }

      var index = keyboardListeners.indexOf(data);

      if (index >= 0) {
        keyboardListeners.splice(index, 1);
      }
    },
    onKeyboard: function onKeyboard(data) {
      if (Array.isArray(data)) {
        data.forEach(function (it) {
          return editor.onKeyboard(it);
        });
        return;
      }

      if (!keyboardListeners.includes(data)) {
        keyboardListeners.push(data);
      }
    },
    registerPluginApi: function registerPluginApi(name, cb) {
      pluginApis.set(name, cb);
    },
    unregisterPluginApi: function unregisterPluginApi(name) {
      pluginApis.delete(name);
    },
    off: function off(event, cb) {
      var eventType = getEventType(event);

      if (eventType) {
        emitter.off(eventType, cb);
      }
    },
    on: function on(event, cb) {
      var eventType = getEventType(event);

      if (eventType) {
        emitter.on(eventType, cb);
      }
    },
    insertPlaceholder: function insertPlaceholder(placeholder, wait) {
      editor.insertText(placeholder, true);
      wait.then(function (str) {
        var text = editor.getMdValue().replace(placeholder, str);
        editor.setText(text);
      });
    },
    handleFocus: function handleFocus(e) {
      var onFocus = props.onFocus;

      if (onFocus) {
        onFocus(e);
      }

      emitter.emit(emitter.EVENT_FOCUS, e);
    }
  };
  use(Header);
  use(FontBold);
  use(FontItalic); // use(FontUnderline);

  use(FontStrikethrough);
  use(Emoji);
  use(Table);
  use(BlockQuote); // use(BlockCodeInline);

  use(BlockCodeBlock);
  use(Link);
  use(ListUnordered);
  use(ListOrdered); // use(BlockWrap);

  use(Image); // use(Clear);
  // use(Logger);
  // use(ModeToggle);
  // use(FullScreen);

  var getPlugins = function getPlugins() {
    var plugins = [];

    if (props.plugins) {
      // If plugins option is configured, use only specified plugins
      var addToPlugins = function addToPlugins(name) {
        if (name === DividerPlugin.pluginName) {
          plugins.push({
            comp: DividerPlugin,
            config: {}
          });
          return;
        }

        for (var _iterator = _createForOfIteratorHelperLoose(PluginList), _step; !(_step = _iterator()).done;) {
          var it = _step.value;

          if (it.comp.pluginName === name) {
            plugins.push(it);
            return;
          }
        }
      };

      for (var _iterator2 = _createForOfIteratorHelperLoose(props.plugins), _step2; !(_step2 = _iterator2()).done;) {
        var name = _step2.value;

        // Special handling of fonts to ensure backward compatibility
        if (name === 'fonts') {
          addToPlugins('font-bold');
          addToPlugins('font-italic');
          addToPlugins('font-underline');
          addToPlugins('font-strikethrough');
          addToPlugins('list-unordered');
          addToPlugins('list-ordered');
          addToPlugins('block-quote');
          addToPlugins('block-wrap');
          addToPlugins('block-code-inline');
          addToPlugins('block-code-block');
        } else {
          addToPlugins(name);
        }
      }
    } else {
      // Use all registered plugins
      plugins = [].concat(PluginList);
    }

    var result = {};
    plugins.forEach(function (it) {
      if (typeof result[it.comp.align] === 'undefined') {
        result[it.comp.align] = [];
      }

      var key = it.comp.pluginName === 'divider' ? uuid() : it.comp.pluginName;
      result[it.comp.align].push( /*#__PURE__*/React.createElement(it.comp, {
        editor: editor,
        editorConfig: config,
        config: _extends({}, it.comp.defaultConfig || {}, it.config || {}),
        key: key
      }));
    });
    return result;
  };

  var _React$useState3 = React.useState(getPlugins()),
      pluginState = _React$useState3[0],
      setpluginState = _React$useState3[1];

  var getPluginAt = function getPluginAt(at) {
    return pluginState[at] || [];
  };

  return /*#__PURE__*/React.createElement("div", {
    className: classNames(props.className, "rc-md-editor")
  }, /*#__PURE__*/React.createElement(NavigationBar, {
    visible: true,
    left: getPluginAt('left'),
    right: getPluginAt('right')
  }));
};