import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _extends from "@babel/runtime/helpers/extends";

var _this = this;

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import _regeneratorRuntime from "@babel/runtime/regenerator";
import * as React from 'react';
import { v4 as uuid } from 'uuid';
import NavigationBar from '../components/NavigationBar';
import DividerPlugin from '../plugins/divider';
import { initialSelection } from '../share/var';
import getDecorated from '../utils/decorate';
import { getLineAndCol, isKeyMatch } from '../utils/tool';
import mergeConfig from '../utils/mergeConfig';
import defaultConfig from './defaultConfig';
import Emitter from '../share/emitter';
import classNames from 'classnames';
import getUploadPlaceholder from '../utils/uploadPlaceholder';
import ChooseItem from './chooseItem';

var getCaretCoordinates = require('textarea-caret');

import debounce from '../components/tools';
import { EditorPreview } from '../previewOnly';
import './index.less'; // import TabInsert from '../plugins/tabInsert';

var nodeMdText = /*#__PURE__*/React.createRef();
var nodeMdPreviewWrapper = /*#__PURE__*/React.createRef();
var nodeMdPreview = /*#__PURE__*/React.createRef(); // const nodeMdPreview = React.createRef<HtmlRender>();

var keyboardListeners = [];
var pluginApis = new Map();
var emitter;
var shouldSyncScroll = 'md';
var scrollScale = 1;
var hasContentChanged = true;
var isSyncingScroll = false;
emitter = new Emitter();

var getEventType = function getEventType(event) {
  switch (event) {
    case 'change':
      return emitter.EVENT_CHANGE;

    case 'fullscreen':
      return emitter.EVENT_FULL_SCREEN;

    case 'viewchange':
      return emitter.EVENT_VIEW_CHANGE;

    case 'keydown':
      return emitter.EVENT_KEY_DOWN;

    case 'editor_keydown':
      return emitter.EVENT_EDITOR_KEY_DOWN;

    case 'blur':
      return emitter.EVENT_BLUR;

    case 'focus':
      return emitter.EVENT_FOCUS;

    case 'scroll':
      return emitter.EVENT_SCROLL;
  }
}; // nodeMdText = React.createRef();


export { nodeMdText };
var PluginList = [];
export var use = function use(comp, config) {
  if (config === void 0) {
    config = {};
  }

  // Check for duplicate plugins
  for (var i = 0; i < PluginList.length; i++) {
    if (PluginList[i].comp === comp) {
      PluginList.splice(i, 1, {
        comp: comp,
        config: config
      });
      return;
    }
  }

  PluginList.push({
    comp: comp,
    config: config
  });
};
export var EditorInput = function EditorInput(props) {
  if (props.nodeMdEditor) {
    nodeMdText = props.nodeMdEditor;
  }

  var config;
  config = mergeConfig(defaultConfig, props.config, props);

  if (props.richText !== undefined) {
    config.richText = props.richText;
  }

  var _React$useState = React.useState(props.value || props.defaultValue),
      stateText = _React$useState[0],
      setStateText = _React$useState[1];

  var _React$useState2 = React.useState(''),
      stateHtml = _React$useState2[0],
      setStateHtml = _React$useState2[1];

  var _React$useState3 = React.useState(false),
      chooseVisible = _React$useState3[0],
      setChooseVisible = _React$useState3[1];

  var _React$useState4 = React.useState(),
      chooseList = _React$useState4[0],
      setChooseList = _React$useState4[1];

  var _React$useState5 = React.useState(0),
      chooseStart = _React$useState5[0],
      setChooseStart = _React$useState5[1];

  var _React$useState6 = React.useState(0),
      chooseEnd = _React$useState6[0],
      setChooseEnd = _React$useState6[1];

  var _React$useState7 = React.useState(false),
      startMatch = _React$useState7[0],
      setStartMatch = _React$useState7[1]; // 弹窗展示时，根据光标更新位置


  var _React$useState8 = React.useState({
    x: 0,
    y: 0,
    overflowX: false,
    overflowY: false
  }),
      dialogPosition = _React$useState8[0],
      setDialogPosition = _React$useState8[1];

  var _React$useState9 = React.useState(0),
      activeChoose = _React$useState9[0],
      setActiveChoose = _React$useState9[1];

  var _React$useState10 = React.useState(false),
      composing = _React$useState10[0],
      setComposing = _React$useState10[1];

  var _React$useState11 = React.useState(config.view || defaultConfig.view),
      view = _React$useState11[0],
      setViewValue = _React$useState11[1]; // use(FullScreen);


  var editor = {
    getSelection: function getSelection() {
      var source = nodeMdText.current;

      if (!source) {
        return _extends({}, initialSelection);
      }

      var start = source.selectionStart;
      var end = source.selectionEnd;
      var text = (source.value || '').slice(start, end);
      return {
        start: start,
        end: end,
        text: text
      };
    },
    // 这里的逻辑主要是先确定选取，然后在通过getDecorated来确定如何替换
    insertMarkdown: function insertMarkdown(type, option) {
      if (option === void 0) {
        option = {};
      }

      var hasMDsymbol = false; //判断是否有md的symbol

      var curSelection = editor.getSelection();
      var decorateOption = option ? _extends({}, option) : {};

      if (type === 'image') {
        decorateOption = _extends({}, decorateOption, {
          target: option.target || curSelection.text || '',
          imageUrl: option.imageUrl || config.imageUrl
        });
      }

      if (type === 'link') {
        decorateOption = _extends({}, decorateOption, {
          linkUrl: config.linkUrl
        });
      }

      if (type === 'tab') {
        var _nodeMdText$current;

        var curLineStart = editor.getMdValue().slice(0, curSelection.start).lastIndexOf('\n') + 1;

        var _text = (((_nodeMdText$current = nodeMdText.current) === null || _nodeMdText$current === void 0 ? void 0 : _nodeMdText$current.value) || '').slice(curLineStart, curSelection.end);

        var lineInfo = getLineAndCol(_text, curLineStart);
        var isSymbol = lineInfo.curLine.match(/^(\s*?)\*|\-|\+ /);
        var isOrderList = lineInfo.curLine.match(/^(\s*?)(\d+)\. /);
        var curlength = lineInfo.curLine.length;
        var isFocusEnd = lineInfo.curLine[curlength - 1] === ' ';

        if ((isSymbol || isOrderList) && curSelection.start === curSelection.end && isFocusEnd) {
          editor.setSelection({
            start: curLineStart,
            end: curSelection.end
          });
          curSelection = editor.getSelection();
          hasMDsymbol = true;
        }
      }

      if (type === 'shiftTab' && curSelection.start !== curSelection.end) {
        var _curLineStart = editor.getMdValue().slice(0, curSelection.start).lastIndexOf('\n') + 1;

        editor.setSelection({
          start: _curLineStart,
          end: curSelection.end
        });
        curSelection = editor.getSelection();
      }

      var decorate = getDecorated(curSelection.text, type, decorateOption);
      var text = decorate.text;
      var selection = decorate.selection;

      if (decorate.newBlock) {
        var startLineInfo = getLineAndCol(editor.getMdValue(), curSelection.start);
        var col = startLineInfo.col,
            curLine = startLineInfo.curLine;

        if (col > 0 && curLine.length > 0) {
          text = "\n" + text;

          if (selection) {
            selection.start++;
            selection.end++;
          }
        }

        var afterText = startLineInfo.afterText;

        if (curSelection.start !== curSelection.end) {
          afterText = getLineAndCol(editor.getMdValue(), curSelection.end).afterText;
        }

        if (afterText.trim() !== '' && afterText.substr(0, 2) !== '\n\n') {
          if (afterText.substr(0, 1) !== '\n') {
            text += '\n';
          }

          text += '\n';
        }
      }

      editor.insertText(text, true, selection); //插入tab后，重新定位光标

      if (hasMDsymbol) {
        setTimeout(function () {
          var _nodeMdText$current2, _nodeMdText$current3;

          curSelection = editor.getSelection();
          (_nodeMdText$current2 = nodeMdText.current) === null || _nodeMdText$current2 === void 0 ? void 0 : _nodeMdText$current2.focus();
          (_nodeMdText$current3 = nodeMdText.current) === null || _nodeMdText$current3 === void 0 ? void 0 : _nodeMdText$current3.setSelectionRange(curSelection.end, curSelection.end);
        });
      }
    },
    getMdValue: function getMdValue() {
      var _nodeMdText$current4;

      return ((_nodeMdText$current4 = nodeMdText.current) === null || _nodeMdText$current4 === void 0 ? void 0 : _nodeMdText$current4.value) || stateText || '';
    },
    setSelection: function setSelection(to) {
      if (nodeMdText.current) {
        nodeMdText.current.setSelectionRange(to.start, to.end, 'forward');
        nodeMdText.current.focus();
      }
    },
    insertText: function insertText(value, replaceSelected, newSelection) {
      var _nodeMdText$current5;

      if (value === void 0) {
        value = '';
      }

      if (replaceSelected === void 0) {
        replaceSelected = false;
      }

      var text = ((_nodeMdText$current5 = nodeMdText.current) === null || _nodeMdText$current5 === void 0 ? void 0 : _nodeMdText$current5.value) || '';
      var selection = editor.getSelection();
      var beforeContent = text.slice(0, selection.start);
      var afterContent = text.slice(replaceSelected ? selection.end : selection.start, text.length);
      editor.setText(beforeContent + value + afterContent, undefined, newSelection ? {
        start: newSelection.start + beforeContent.length,
        end: newSelection.end + beforeContent.length
      } : {
        start: selection.start,
        end: selection.start
      });
    },
    setText: function setText(value, event, newSelection) {
      if (value === void 0) {
        value = '';
      }

      // const { onChangeTrigger = 'both' } = config;
      var onChangeTrigger = 'both';
      var text = value.replace(/↵/g, '\n'); // if (nodeMdText.current?.value === value) {
      //   return;
      // }

      setStateText(text);

      if (nodeMdText.current) {
        nodeMdText.current.value = text;
      }

      if (props.onChange && (onChangeTrigger === 'both' || onChangeTrigger === 'beforeRender')) {
        props.onChange({
          text: text,
          html: editor.getHtmlValue()
        }, event);
      } // console.log(value)


      emitter.emit(emitter.EVENT_CHANGE, value, event, typeof event === 'undefined');

      if (newSelection) {
        setTimeout(function () {
          return editor.setSelection(newSelection);
        });
      }

      if (!hasContentChanged) {
        hasContentChanged = true;
      } // const rendering = this.renderHTML(text);
      // if (onChangeTrigger === 'both' || onChangeTrigger === 'afterRender') {
      //   rendering.then(() => {
      //     if (this.props.onChange) {
      //       this.props.onChange(
      //         {
      //           text: this.state.text,
      //           html: this.getHtmlValue(),
      //         },
      //         event,
      //       );
      //     }
      //   });
      // }

    },
    getHtmlValue: function getHtmlValue() {
      if (typeof stateHtml === 'string') {
        return stateHtml;
      }

      if (nodeMdPreview.current) {
        return nodeMdPreview.current.getHtml();
      }

      return '';
    },
    offKeyboard: function offKeyboard(data) {
      if (Array.isArray(data)) {
        data.forEach(function (it) {
          return editor.offKeyboard(it);
        });
        return;
      }

      var index = keyboardListeners.indexOf(data);

      if (index >= 0) {
        keyboardListeners.splice(index, 1);
      }
    },
    onKeyboard: function onKeyboard(data) {
      if (Array.isArray(data)) {
        data.forEach(function (it) {
          return editor.onKeyboard(it);
        });
        return;
      }

      if (!keyboardListeners.includes(data)) {
        keyboardListeners.push(data);
      }
    },
    registerPluginApi: function registerPluginApi(name, cb) {
      pluginApis.set(name, cb);
    },
    unregisterPluginApi: function unregisterPluginApi(name) {
      pluginApis.delete(name);
    },
    off: function off(event, cb) {
      var eventType = getEventType(event);

      if (eventType) {
        emitter.off(eventType, cb);
      }
    },
    on: function on(event, cb) {
      var eventType = getEventType(event);

      if (eventType) {
        emitter.on(eventType, cb);
      }
    },
    insertPlaceholder: function insertPlaceholder(placeholder, wait) {
      editor.insertText(placeholder, true);
      wait.then(function (str) {
        var text = editor.getMdValue().replace(placeholder, str);
        editor.setText(text);
      });
    },
    handleFocus: function handleFocus(e) {
      var onFocus = props.onFocus;

      if (onFocus) {
        onFocus(e);
      }

      emitter.emit(emitter.EVENT_FOCUS, e);
    },
    setView: function setView(to) {
      var newView = _extends({}, view, to);

      setViewValue(newView);
      emitter.emit(emitter.EVENT_VIEW_CHANGE, newView);
    },
    getView: function getView() {
      return _extends({}, view);
    }
  };

  var handleChange = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(e) {
      var value;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              e.persist();
              value = e.target.value; // 触发内部事件

              editor.setText(value, e);

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function handleChange(_x) {
      return _ref.apply(this, arguments);
    };
  }(); // 下面两个函数都是为了输入特殊字符选择item用的。
  // const chooseDebouce = React.useMemo(()=>{
  //   debounce(async () => {
  //     console.log(23333)
  //     const text = nodeMdText.current?.value || '';
  //     const chooseSelection = editor.getSelection();
  //     const queryString = text.slice(chooseStart+1, chooseSelection.end);
  //     console.log(queryString)
  //     setChooseList(await props.onCharMatch[activeChoose].queryFunc(queryString))
  //   }, 500)
  // },[])


  var chooseDebouce = React.useCallback(debounce( /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(chooseStart) {
      var _nodeMdText$current6;

      var text, chooseSelection, queryString;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              text = ((_nodeMdText$current6 = nodeMdText.current) === null || _nodeMdText$current6 === void 0 ? void 0 : _nodeMdText$current6.value) || '';
              chooseSelection = editor.getSelection();
              queryString = text.slice(chooseStart, chooseSelection.end);
              _context2.t0 = setChooseList;
              _context2.next = 6;
              return props.onCharMatch[activeChoose].queryFunc(queryString);

            case 6:
              _context2.t1 = _context2.sent;
              (0, _context2.t0)(_context2.t1);

            case 8:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function (_x2) {
      return _ref2.apply(this, arguments);
    };
  }(), 300), []);

  var handleKeyUp = function handleKeyUp(e) {
    var _nodeMdText$current7, _props$onCharMatch;

    var keyCode = e.keyCode,
        key = e.key,
        currentTarget = e.currentTarget;
    var text = ((_nodeMdText$current7 = nodeMdText.current) === null || _nodeMdText$current7 === void 0 ? void 0 : _nodeMdText$current7.value) || '';
    var chooseSelection = editor.getSelection();
    var curPos = currentTarget.selectionStart;
    var lineInfo = getLineAndCol(text, curPos);

    if ((_props$onCharMatch = props.onCharMatch) !== null && _props$onCharMatch !== void 0 && _props$onCharMatch.length) {
      props.onCharMatch.map( /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(item, index) {
          var _nodeMdText$current8, _nodeMdText$current9, _nodeMdText$current10, _nodeMdText$current11, _nodeMdText$current12, _nodeMdText$current13, coordinates, containerHeight, containerWidth, yposition;

          return _regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  if (!(text[curPos - 1] === item.matchChar || key === 'Backspace' && text[curPos - 1] === item.matchChar)) {
                    _context3.next = 17;
                    break;
                  }

                  coordinates = getCaretCoordinates(nodeMdText.current, (_nodeMdText$current8 = nodeMdText.current) === null || _nodeMdText$current8 === void 0 ? void 0 : _nodeMdText$current8.selectionEnd);
                  containerHeight = (_nodeMdText$current9 = nodeMdText.current) === null || _nodeMdText$current9 === void 0 ? void 0 : _nodeMdText$current9.clientHeight;
                  containerWidth = (_nodeMdText$current10 = nodeMdText.current) === null || _nodeMdText$current10 === void 0 ? void 0 : _nodeMdText$current10.clientWidth;
                  yposition = props.useToolbar ? coordinates.top - ((_nodeMdText$current11 = nodeMdText.current) === null || _nodeMdText$current11 === void 0 ? void 0 : _nodeMdText$current11.scrollTop) + 38 : coordinates.top - ((_nodeMdText$current12 = nodeMdText.current) === null || _nodeMdText$current12 === void 0 ? void 0 : _nodeMdText$current12.scrollTop);
                  setDialogPosition({
                    x: coordinates.left,
                    y: yposition,
                    overflowX: coordinates.left + 150 > containerWidth,
                    overflowY: coordinates.top - ((_nodeMdText$current13 = nodeMdText.current) === null || _nodeMdText$current13 === void 0 ? void 0 : _nodeMdText$current13.scrollTop) + 120 > containerHeight
                  });
                  setActiveChoose(index);

                  if (startMatch) {
                    _context3.next = 13;
                    break;
                  }

                  _context3.t0 = setChooseList;
                  _context3.next = 11;
                  return item.queryFunc('');

                case 11:
                  _context3.t1 = _context3.sent;
                  (0, _context3.t0)(_context3.t1);

                case 13:
                  setChooseStart(chooseSelection.start);
                  setChooseEnd(currentTarget.selectionStart);
                  setChooseVisible(true);
                  setStartMatch(true);

                case 17:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        return function (_x3, _x4) {
          return _ref3.apply(this, arguments);
        };
      }());

      if (startMatch && !key.includes('Arrow')) {
        setChooseEnd(currentTarget.selectionStart);
        chooseDebouce(chooseStart);
      }
    }

    if (key === 'Escape' || key === ' ' && text[curPos - 1] === ' ') {
      setChooseVisible(false);
      setStartMatch(false);
    }

    if (chooseStart > chooseSelection.start && (key === 'ArrowLeft' || key === 'Backspace')) {
      setChooseVisible(false);
      setStartMatch(false);
    }
  };

  var handleEditorKeyDown = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(e) {
      var keyCode, key, currentTarget, onKeyDown, _text2, curPos, lineInfo, emptyCurrentLine, addSymbol, isSymbol, isOrderList, toInsert;

      return _regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              keyCode = e.keyCode, key = e.key, currentTarget = e.currentTarget;
              onKeyDown = props.onKeyDown;

              if (onKeyDown) {
                onKeyDown(e);
              }

              if (!((keyCode === 13 || key === 'Enter') && composing === false && !chooseVisible)) {
                _context4.next = 24;
                break;
              }

              _text2 = currentTarget.value;
              curPos = currentTarget.selectionStart;
              lineInfo = getLineAndCol(_text2, curPos);

              emptyCurrentLine = function emptyCurrentLine() {
                var newValue = currentTarget.value.substr(0, curPos - lineInfo.curLine.length) + currentTarget.value.substr(curPos);
                editor.setText(newValue, undefined, {
                  start: curPos - lineInfo.curLine.length,
                  end: curPos - lineInfo.curLine.length
                });
                e.preventDefault();
              };

              addSymbol = function addSymbol(symbol) {
                editor.insertText("\n" + symbol, false, {
                  start: symbol.length + 1,
                  end: symbol.length + 1
                });
                e.preventDefault();
              }; // Enter key, check previous line


              isSymbol = lineInfo.curLine.match(/^(\s*?)\* /);

              if (!isSymbol) {
                _context4.next = 16;
                break;
              }

              if (!/^(\s*?)\* $/.test(lineInfo.curLine)) {
                _context4.next = 14;
                break;
              }

              emptyCurrentLine();
              return _context4.abrupt("return");

            case 14:
              addSymbol(isSymbol[0]);
              return _context4.abrupt("return");

            case 16:
              isOrderList = lineInfo.curLine.match(/^(\s*?)(\d+)\. /);

              if (!isOrderList) {
                _context4.next = 24;
                break;
              }

              if (!/^(\s*?)(\d+)\. $/.test(lineInfo.curLine)) {
                _context4.next = 21;
                break;
              }

              emptyCurrentLine();
              return _context4.abrupt("return");

            case 21:
              toInsert = "" + isOrderList[1] + (parseInt(isOrderList[2], 10) + 1) + ". ";
              addSymbol(toInsert);
              return _context4.abrupt("return");

            case 24:
              // 触发默认事件
              emitter.emit(emitter.EVENT_EDITOR_KEY_DOWN, e);

            case 25:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    return function handleEditorKeyDown(_x5) {
      return _ref4.apply(this, arguments);
    };
  }();

  var handleBlur = function handleBlur(e) {
    var onBlur = props.onBlur;

    if (onBlur) {
      onBlur(e);
    }

    emitter.emit(emitter.EVENT_BLUR, e);
  };

  var handleFocus = function handleFocus(e) {
    var onFocus = props.onFocus;

    if (onFocus) {
      onFocus(e);
    }

    setChooseVisible(false);
    editor.setText(e.target.value, e); // 用于完善撤销按钮

    emitter.emit(emitter.EVENT_FOCUS, e);
  };

  var uploadWithDataTransfer = function uploadWithDataTransfer(items) {
    var _config = config,
        onImageUpload = _config.onImageUpload;

    if (!onImageUpload) {
      return;
    }

    var queue = [];
    Array.prototype.forEach.call(items, function (it) {
      if (it.kind === 'file' && it.type.includes('image')) {
        var file = it.getAsFile();

        if (file) {
          var _placeholder = getUploadPlaceholder(file, onImageUpload);

          queue.push(Promise.resolve(_placeholder.placeholder));

          _placeholder.uploaded.then(function (str) {
            var text = editor.getMdValue().replace(_placeholder.placeholder, str);
            var offset = str.length - _placeholder.placeholder.length; // 计算出替换后的光标位置

            var selection = editor.getSelection();
            editor.setText(text, undefined, {
              start: selection.start + offset,
              end: selection.start + offset
            });
          });
        }
      } else if (it.kind === 'string' && it.type === 'text/plain') {
        queue.push(new Promise(function (resolve) {
          return it.getAsString(resolve);
        }));
      }
    });
    Promise.all(queue).then(function (res) {
      var text = res.join('');
      var selection = editor.getSelection();
      editor.insertText(text, true, {
        start: selection.start === selection.end ? text.length : 0,
        end: text.length
      });
    });
  };

  var handleDrop = function handleDrop(e) {
    if (!config.onImageUpload) {
      return;
    }

    var event = e.nativeEvent;

    if (!event.dataTransfer) {
      return;
    }

    var items = event.dataTransfer.items;

    if (items) {
      e.preventDefault();
      uploadWithDataTransfer(items);
    }
  };

  var handleKeyDown = function handleKeyDown(e) {
    // 遍历监听数组，找找有没有被监听
    for (var _iterator = _createForOfIteratorHelperLoose(keyboardListeners), _step; !(_step = _iterator()).done;) {
      var it = _step.value;

      if (isKeyMatch(e, it)) {
        e.preventDefault();
        it.callback(e);
        return;
      }
    } // 如果没有，触发默认事件


    emitter.emit(emitter.EVENT_KEY_DOWN, e);
  };

  var handlePaste = function handlePaste(e) {
    if (!config.allowPasteImage || !config.onImageUpload) {
      return;
    }

    var event = e.nativeEvent; // @ts-ignore

    var items = (event.clipboardData || window.clipboardData).items;

    if (items) {
      e.preventDefault();
      uploadWithDataTransfer(items);
    }
  };

  var getPlugins = function getPlugins() {
    var plugins = [];

    if (props.plugins) {
      // If plugins option is configured, use only specified plugins
      var addToPlugins = function addToPlugins(name) {
        if (name === DividerPlugin.pluginName) {
          plugins.push({
            comp: DividerPlugin,
            config: {}
          });
          return;
        }

        for (var _iterator2 = _createForOfIteratorHelperLoose(Editor.plugins), _step2; !(_step2 = _iterator2()).done;) {
          var it = _step2.value;

          if (it.comp.pluginName === name) {
            plugins.push(it);
            return;
          }
        }
      };

      for (var _iterator3 = _createForOfIteratorHelperLoose(props.plugins), _step3; !(_step3 = _iterator3()).done;) {
        var _name = _step3.value;

        // Special handling of fonts to ensure backward compatibility
        if (_name === 'fonts') {
          addToPlugins('font-bold');
          addToPlugins('font-italic');
          addToPlugins('font-underline');
          addToPlugins('font-strikethrough');
          addToPlugins('list-unordered');
          addToPlugins('list-ordered');
          addToPlugins('block-quote');
          addToPlugins('block-wrap');
          addToPlugins('block-code-inline');
          addToPlugins('block-code-block');
        } else {
          addToPlugins(_name);
        }
      }
    } else {
      // Use all registered plugins
      plugins = [].concat(PluginList);
    }

    var result = {};
    plugins.forEach(function (it) {
      if (typeof result[it.comp.align] === 'undefined') {
        result[it.comp.align] = [];
      }

      var key = it.comp.pluginName === 'divider' ? uuid() : it.comp.pluginName;
      result[it.comp.align].push( /*#__PURE__*/React.createElement(it.comp, {
        editor: editor,
        editorConfig: config,
        config: _extends({}, it.comp.defaultConfig || {}, it.config || {}),
        key: key
      }));
    });
    return result;
  };

  var handleSyncScroll = function handleSyncScroll(type, e) {
    // prevent loop
    if (type !== shouldSyncScroll) {
      return;
    } // trigger events


    if (props.onScroll) {
      props.onScroll(e, type);
    }

    emitter.emit(emitter.EVENT_SCROLL, e, type); // should sync scroll?

    var _config2 = config,
        _config2$syncScrollMo = _config2.syncScrollMode,
        syncScrollMode = _config2$syncScrollMo === void 0 ? [] : _config2$syncScrollMo;

    if (!syncScrollMode.includes(type === 'md' ? 'rightFollowLeft' : 'leftFollowRight')) {
      return;
    }

    if (hasContentChanged && nodeMdText.current && nodeMdPreviewWrapper.current) {
      // 计算出左右的比例
      scrollScale = nodeMdText.current.scrollHeight / nodeMdPreviewWrapper.current.scrollHeight;
      hasContentChanged = false;
    }

    if (!isSyncingScroll) {
      isSyncingScroll = true;
      requestAnimationFrame(function () {
        if (nodeMdText.current && nodeMdPreviewWrapper.current) {
          if (type === 'md') {
            // left to right
            nodeMdPreviewWrapper.current.scrollTop = nodeMdText.current.scrollTop / scrollScale;
          } else {
            // right to left
            nodeMdText.current.scrollTop = nodeMdPreviewWrapper.current.scrollTop * scrollScale;
          }
        }

        isSyncingScroll = false;
      });
    }
  };

  var handleInputScroll = handleSyncScroll.bind(_this, 'md');
  var handlePreviewScroll = handleSyncScroll.bind(_this, 'html');

  var SelectChooseItem = function SelectChooseItem(item) {
    var _nodeMdText$current14, _nodeMdText$current15, _nodeMdText$current16;

    var chooseSelection = editor.getSelection();
    var text = ((_nodeMdText$current14 = nodeMdText.current) === null || _nodeMdText$current14 === void 0 ? void 0 : _nodeMdText$current14.value) || '';
    var beforeContent = text.slice(0, chooseStart);
    var afterContent = text.slice(chooseEnd, text.length);
    editor.setText(beforeContent + item.value + ' ' + afterContent);
    setChooseVisible(false);
    setStartMatch(false);
    (_nodeMdText$current15 = nodeMdText.current) === null || _nodeMdText$current15 === void 0 ? void 0 : _nodeMdText$current15.setSelectionRange(chooseStart + item.value.length + 1, chooseStart + item.value.length + 1);
    (_nodeMdText$current16 = nodeMdText.current) === null || _nodeMdText$current16 === void 0 ? void 0 : _nodeMdText$current16.focus();
  };

  var _React$useState12 = React.useState(getPlugins()),
      pluginState = _React$useState12[0],
      setpluginState = _React$useState12[1];

  var getPluginAt = function getPluginAt(at) {
    return pluginState[at] || [];
  };

  var id = props.id,
      _props$className = props.className,
      className = _props$className === void 0 ? '' : _props$className,
      style = props.style,
      _props$name = props.name,
      name = _props$name === void 0 ? 'textarea' : _props$name,
      autoFocus = props.autoFocus,
      placeholder = props.placeholder,
      readOnly = props.readOnly,
      text = props.text;
  var editorId = id ? id + "_md" : undefined;
  var previewerId = id ? id + "_html" : undefined;

  if (!props.useToolbar) {
    return /*#__PURE__*/React.createElement("div", {
      className: classNames(className, "rc-md-editor"),
      onKeyDown: handleKeyDown
    }, /*#__PURE__*/React.createElement(NavigationBar, {
      visible: props.useToolbar,
      left: getPluginAt('left'),
      right: getPluginAt('right')
    }), /*#__PURE__*/React.createElement("textarea", {
      defaultValue: props.defaultValue,
      id: editorId,
      style: style,
      ref: nodeMdText,
      name: name,
      autoFocus: autoFocus,
      placeholder: placeholder,
      readOnly: readOnly || false,
      value: stateText,
      className: "section-container input " + (config.markdownClass || ''),
      wrap: "hard",
      onChange: handleChange,
      onScroll: handleInputScroll,
      onMouseOver: function onMouseOver() {
        return shouldSyncScroll = 'md';
      },
      onKeyDown: handleEditorKeyDown,
      onCompositionStart: function onCompositionStart() {
        return setComposing(true);
      },
      onCompositionEnd: function onCompositionEnd() {
        return setComposing(false);
      },
      onPaste: handlePaste,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onDrop: handleDrop,
      onKeyUp: handleKeyUp
    }), chooseVisible && /*#__PURE__*/React.createElement(ChooseItem, {
      ItemList: chooseList,
      selectFunc: SelectChooseItem,
      dialogPosition: dialogPosition,
      chineseInputBool: composing
    }));
  }

  return /*#__PURE__*/React.createElement("div", {
    className: classNames(className, "rc-md-editor"),
    onKeyDown: handleKeyDown
  }, /*#__PURE__*/React.createElement(NavigationBar, {
    visible: props.useToolbar,
    left: getPluginAt('left'),
    right: getPluginAt('right')
  }), /*#__PURE__*/React.createElement("div", {
    className: "editor-container"
  }, /*#__PURE__*/React.createElement("section", {
    className: "section sec-md " + (view.md ? 'visible' : 'in-visible')
  }, /*#__PURE__*/React.createElement("textarea", {
    defaultValue: props.defaultValue,
    id: editorId,
    style: style,
    ref: nodeMdText,
    name: name,
    autoFocus: autoFocus,
    placeholder: placeholder,
    readOnly: readOnly || false,
    value: stateText,
    className: "section-container input " + (config.markdownClass || ''),
    wrap: "hard",
    onChange: handleChange,
    onScroll: handleInputScroll,
    onMouseOver: function onMouseOver() {
      return shouldSyncScroll = 'md';
    },
    onKeyDown: handleEditorKeyDown,
    onCompositionStart: function onCompositionStart() {
      return setComposing(true);
    },
    onCompositionEnd: function onCompositionEnd() {
      return setComposing(false);
    },
    onPaste: handlePaste,
    onFocus: handleFocus,
    onBlur: handleBlur,
    onDrop: handleDrop,
    onKeyUp: handleKeyUp
  })), props.useToolbar && /*#__PURE__*/React.createElement("section", {
    className: "section sec-html " + (view.html ? 'visible' : 'in-visible')
  }, /*#__PURE__*/React.createElement("div", {
    id: previewerId,
    className: "section-container html-wrap",
    ref: nodeMdPreviewWrapper,
    onMouseOver: function onMouseOver() {
      return shouldSyncScroll = 'html';
    },
    onScroll: handlePreviewScroll
  }, /*#__PURE__*/React.createElement(EditorPreview, {
    MarkdownValue: stateText || props.defaultValue,
    className: config.htmlClass,
    ref: nodeMdPreview
  })))), chooseVisible && /*#__PURE__*/React.createElement(ChooseItem, {
    ItemList: chooseList,
    selectFunc: SelectChooseItem,
    dialogPosition: dialogPosition,
    chineseInputBool: composing
  }));
};