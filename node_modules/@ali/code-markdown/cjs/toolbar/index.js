"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.nodeMdText = exports.EditorToolbar = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var React = _interopRequireWildcard(require("react"));

var _uuid = require("uuid");

var _NavigationBar = _interopRequireDefault(require("../components/NavigationBar"));

var _divider = _interopRequireDefault(require("../plugins/divider"));

var _var = require("../share/var");

var _decorate = _interopRequireDefault(require("../utils/decorate"));

var _tool = require("../utils/tool");

var _mergeConfig = _interopRequireDefault(require("../utils/mergeConfig"));

var _defaultConfig = _interopRequireDefault(require("./defaultConfig"));

var _emitter = _interopRequireDefault(require("../share/emitter"));

var _codeBlock = _interopRequireDefault(require("../plugins/block/code-block"));

var _quote = _interopRequireDefault(require("../plugins/block/quote"));

var _bold = _interopRequireDefault(require("../plugins/font/bold"));

var _italic = _interopRequireDefault(require("../plugins/font/italic"));

var _strikethrough = _interopRequireDefault(require("../plugins/font/strikethrough"));

var _header = _interopRequireDefault(require("../plugins/header"));

var _Image = _interopRequireDefault(require("../plugins/Image"));

var _link = _interopRequireDefault(require("../plugins/link"));

var _ordered = _interopRequireDefault(require("../plugins/list/ordered"));

var _unordered = _interopRequireDefault(require("../plugins/list/unordered"));

var _emoji = _interopRequireDefault(require("../plugins/emoji"));

var _table = _interopRequireDefault(require("../plugins/table"));

var _classnames = _interopRequireDefault(require("classnames"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var nodeMdText = /*#__PURE__*/React.createRef();
exports.nodeMdText = nodeMdText;
var nodeMdPreview = /*#__PURE__*/React.createRef();
var keyboardListeners = [];
var pluginApis = new Map();
var emitter;
emitter = new _emitter.default();

var getEventType = function getEventType(event) {
  switch (event) {
    case 'change':
      return emitter.EVENT_CHANGE;

    case 'fullscreen':
      return emitter.EVENT_FULL_SCREEN;

    case 'viewchange':
      return emitter.EVENT_VIEW_CHANGE;

    case 'keydown':
      return emitter.EVENT_KEY_DOWN;

    case 'editor_keydown':
      return emitter.EVENT_EDITOR_KEY_DOWN;

    case 'blur':
      return emitter.EVENT_BLUR;

    case 'focus':
      return emitter.EVENT_FOCUS;

    case 'scroll':
      return emitter.EVENT_SCROLL;
  }
}; // nodeMdText = React.createRef();


var EditorToolbar = function EditorToolbar(props) {
  if (props.nodeMdText) {
    exports.nodeMdText = nodeMdText = props.nodeMdText;
  }

  var config;
  config = (0, _mergeConfig.default)(_defaultConfig.default, props.config, props);

  var _React$useState = React.useState(''),
      stateText = _React$useState[0],
      setStateText = _React$useState[1];

  var _React$useState2 = React.useState(''),
      stateHtml = _React$useState2[0],
      setStateHtml = _React$useState2[1];

  var PluginList = [];

  var use = function use(comp, config) {
    if (config === void 0) {
      config = {};
    }

    // Check for duplicate plugins
    for (var i = 0; i < PluginList.length; i++) {
      if (PluginList[i].comp === comp) {
        PluginList.splice(i, 1, {
          comp: comp,
          config: config
        });
        return;
      }
    }

    PluginList.push({
      comp: comp,
      config: config
    });
  };

  var editor = {
    getSelection: function getSelection() {
      var source = nodeMdText.current;

      if (!source) {
        return (0, _extends2.default)({}, _var.initialSelection);
      }

      var start = source.selectionStart;
      var end = source.selectionEnd;
      var text = (source.value || '').slice(start, end);
      return {
        start: start,
        end: end,
        text: text
      };
    },
    insertMarkdown: function insertMarkdown(type, option) {
      if (option === void 0) {
        option = {};
      }

      var curSelection = editor.getSelection();
      var decorateOption = option ? (0, _extends2.default)({}, option) : {};

      if (type === 'image') {
        decorateOption = (0, _extends2.default)({}, decorateOption, {
          target: option.target || curSelection.text || '',
          imageUrl: option.imageUrl || config.imageUrl
        });
      }

      if (type === 'link') {
        decorateOption = (0, _extends2.default)({}, decorateOption, {
          linkUrl: config.linkUrl
        });
      }

      if (type === 'tab' && curSelection.start !== curSelection.end) {
        var curLineStart = editor.getMdValue().slice(0, curSelection.start).lastIndexOf('\n') + 1;
        editor.setSelection({
          start: curLineStart,
          end: curSelection.end
        });
      }

      var decorate = (0, _decorate.default)(curSelection.text, type, decorateOption);
      var text = decorate.text;
      var selection = decorate.selection;

      if (decorate.newBlock) {
        var startLineInfo = (0, _tool.getLineAndCol)(editor.getMdValue(), curSelection.start);
        var col = startLineInfo.col,
            curLine = startLineInfo.curLine;

        if (col > 0 && curLine.length > 0) {
          text = "\n" + text;

          if (selection) {
            selection.start++;
            selection.end++;
          }
        }

        var afterText = startLineInfo.afterText;

        if (curSelection.start !== curSelection.end) {
          afterText = (0, _tool.getLineAndCol)(editor.getMdValue(), curSelection.end).afterText;
        }

        if (afterText.trim() !== '' && afterText.substr(0, 2) !== '\n\n') {
          if (afterText.substr(0, 1) !== '\n') {
            text += '\n';
          }

          text += '\n';
        }
      }

      editor.insertText(text, true, selection);
    },
    getMdValue: function getMdValue() {
      var _nodeMdText$current;

      return ((_nodeMdText$current = nodeMdText.current) === null || _nodeMdText$current === void 0 ? void 0 : _nodeMdText$current.value) || '';
    },
    setSelection: function setSelection(to) {
      if (nodeMdText.current) {
        nodeMdText.current.setSelectionRange(to.start, to.end, 'forward');
        nodeMdText.current.focus();
      }
    },
    insertText: function insertText(value, replaceSelected, newSelection) {
      var _nodeMdText$current2;

      if (value === void 0) {
        value = '';
      }

      if (replaceSelected === void 0) {
        replaceSelected = false;
      }

      var text = ((_nodeMdText$current2 = nodeMdText.current) === null || _nodeMdText$current2 === void 0 ? void 0 : _nodeMdText$current2.value) || '';
      var selection = editor.getSelection();
      var beforeContent = text.slice(0, selection.start);
      var afterContent = text.slice(replaceSelected ? selection.end : selection.start, text.length);
      editor.setText(beforeContent + value + afterContent, undefined, newSelection ? {
        start: newSelection.start + beforeContent.length,
        end: newSelection.end + beforeContent.length
      } : {
        start: selection.start,
        end: selection.start
      });
    },
    setText: function setText(value, event, newSelection) {
      var _nodeMdText$current3;

      if (value === void 0) {
        value = '';
      }

      // const { onChangeTrigger = 'both' } = config;
      var onChangeTrigger = 'both';
      var text = value.replace(/â†µ/g, '\n');

      if (((_nodeMdText$current3 = nodeMdText.current) === null || _nodeMdText$current3 === void 0 ? void 0 : _nodeMdText$current3.value) === value) {
        return;
      }

      setStateText(text);

      if (nodeMdText.current) {
        nodeMdText.current.value = text;
      }

      if (props.onChange && (onChangeTrigger === 'both' || onChangeTrigger === 'beforeRender')) {
        props.onChange({
          text: text,
          html: editor.getHtmlValue()
        }, event);
      }

      emitter.emit(emitter.EVENT_CHANGE, value, event, typeof event === 'undefined');

      if (newSelection) {
        setTimeout(function () {
          return editor.setSelection(newSelection);
        });
      } // if (!this.hasContentChanged) {
      //   this.hasContentChanged = true;
      // }
      // const rendering = this.renderHTML(text);
      // if (onChangeTrigger === 'both' || onChangeTrigger === 'afterRender') {
      //   rendering.then(() => {
      //     if (this.props.onChange) {
      //       this.props.onChange(
      //         {
      //           text: this.state.text,
      //           html: this.getHtmlValue(),
      //         },
      //         event,
      //       );
      //     }
      //   });
      // }

    },
    getHtmlValue: function getHtmlValue() {
      if (typeof stateHtml === 'string') {
        return stateHtml;
      }

      if (nodeMdPreview.current) {
        return nodeMdPreview.current.getHtml();
      }

      return '';
    },
    offKeyboard: function offKeyboard(data) {
      if (Array.isArray(data)) {
        data.forEach(function (it) {
          return editor.offKeyboard(it);
        });
        return;
      }

      var index = keyboardListeners.indexOf(data);

      if (index >= 0) {
        keyboardListeners.splice(index, 1);
      }
    },
    onKeyboard: function onKeyboard(data) {
      if (Array.isArray(data)) {
        data.forEach(function (it) {
          return editor.onKeyboard(it);
        });
        return;
      }

      if (!keyboardListeners.includes(data)) {
        keyboardListeners.push(data);
      }
    },
    registerPluginApi: function registerPluginApi(name, cb) {
      pluginApis.set(name, cb);
    },
    unregisterPluginApi: function unregisterPluginApi(name) {
      pluginApis.delete(name);
    },
    off: function off(event, cb) {
      var eventType = getEventType(event);

      if (eventType) {
        emitter.off(eventType, cb);
      }
    },
    on: function on(event, cb) {
      var eventType = getEventType(event);

      if (eventType) {
        emitter.on(eventType, cb);
      }
    },
    insertPlaceholder: function insertPlaceholder(placeholder, wait) {
      editor.insertText(placeholder, true);
      wait.then(function (str) {
        var text = editor.getMdValue().replace(placeholder, str);
        editor.setText(text);
      });
    },
    handleFocus: function handleFocus(e) {
      var onFocus = props.onFocus;

      if (onFocus) {
        onFocus(e);
      }

      emitter.emit(emitter.EVENT_FOCUS, e);
    }
  };
  use(_header.default);
  use(_bold.default);
  use(_italic.default); // use(FontUnderline);

  use(_strikethrough.default);
  use(_emoji.default);
  use(_table.default);
  use(_quote.default); // use(BlockCodeInline);

  use(_codeBlock.default);
  use(_link.default);
  use(_unordered.default);
  use(_ordered.default); // use(BlockWrap);

  use(_Image.default); // use(Clear);
  // use(Logger);
  // use(ModeToggle);
  // use(FullScreen);

  var getPlugins = function getPlugins() {
    var plugins = [];

    if (props.plugins) {
      // If plugins option is configured, use only specified plugins
      var addToPlugins = function addToPlugins(name) {
        if (name === _divider.default.pluginName) {
          plugins.push({
            comp: _divider.default,
            config: {}
          });
          return;
        }

        for (var _iterator = _createForOfIteratorHelperLoose(PluginList), _step; !(_step = _iterator()).done;) {
          var it = _step.value;

          if (it.comp.pluginName === name) {
            plugins.push(it);
            return;
          }
        }
      };

      for (var _iterator2 = _createForOfIteratorHelperLoose(props.plugins), _step2; !(_step2 = _iterator2()).done;) {
        var name = _step2.value;

        // Special handling of fonts to ensure backward compatibility
        if (name === 'fonts') {
          addToPlugins('font-bold');
          addToPlugins('font-italic');
          addToPlugins('font-underline');
          addToPlugins('font-strikethrough');
          addToPlugins('list-unordered');
          addToPlugins('list-ordered');
          addToPlugins('block-quote');
          addToPlugins('block-wrap');
          addToPlugins('block-code-inline');
          addToPlugins('block-code-block');
        } else {
          addToPlugins(name);
        }
      }
    } else {
      // Use all registered plugins
      plugins = [].concat(PluginList);
    }

    var result = {};
    plugins.forEach(function (it) {
      if (typeof result[it.comp.align] === 'undefined') {
        result[it.comp.align] = [];
      }

      var key = it.comp.pluginName === 'divider' ? (0, _uuid.v4)() : it.comp.pluginName;
      result[it.comp.align].push( /*#__PURE__*/React.createElement(it.comp, {
        editor: editor,
        editorConfig: config,
        config: (0, _extends2.default)({}, it.comp.defaultConfig || {}, it.config || {}),
        key: key
      }));
    });
    return result;
  };

  var _React$useState3 = React.useState(getPlugins()),
      pluginState = _React$useState3[0],
      setpluginState = _React$useState3[1];

  var getPluginAt = function getPluginAt(at) {
    return pluginState[at] || [];
  };

  return /*#__PURE__*/React.createElement("div", {
    className: (0, _classnames.default)(props.className, "rc-md-editor")
  }, /*#__PURE__*/React.createElement(_NavigationBar.default, {
    visible: true,
    left: getPluginAt('left'),
    right: getPluginAt('right')
  }));
};

exports.EditorToolbar = EditorToolbar;