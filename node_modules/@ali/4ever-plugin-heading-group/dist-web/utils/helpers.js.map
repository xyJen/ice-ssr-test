{"version":3,"sources":["../../../src/utils/helpers.ts"],"names":["getUserData","isSubject","isHeadingGroup","isFoldInGroup","document","node","controller","path","getPath","key","length","i","subPath","slice","block","getNodeByPath","fold","uid","isUnfoldInGroup"],"mappings":"AAAA,SAA+BA,WAA/B,QAAwD,oBAAxD;AACA,SAASC,SAAT,QAA0B,2BAA1B;AACA,SAASC,cAAT;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,aAAT,CAAuBC,QAAvB,EAA2CC,IAA3C,EAAuDC,UAAvD,EAA+E;AACpF,MAAMC,IAAI,GAAGH,QAAQ,CAACI,OAAT,CAAiBH,IAAI,CAACI,GAAtB,CAAb,CADoF,CAGpF;;AACA,MAAI,CAACF,IAAD,IAASA,IAAI,CAACG,MAAL,KAAgB,CAA7B,EAAgC;AAC9B,WAAO,KAAP;AACD,GANmF,CAQpF;;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,IAAI,CAACG,MAAzB,EAAiCC,CAAC,EAAlC,EAAsC;AACpC,QAAMC,OAAO,GAAGL,IAAI,CAACM,KAAL,CAAW,CAAX,EAAcF,CAAd,CAAhB;AACA,QAAMG,KAAK,GAAGV,QAAQ,CAACW,aAAT,CAAuBH,OAAvB,CAAd;;AACA,QAAIX,SAAS,CAACa,KAAD,CAAT,IAAoBZ,cAAc,CAACY,KAAD,CAAtC,EAA+C;AAC7C,UAAME,IAAI,GAAGhB,WAAW,CAACI,QAAD,EAAWU,KAAX,EAAkBR,UAAlB,oBAAkBA,UAAU,CAAEW,GAA9B,EAAmC,MAAnC,CAAxB;;AACA,UAAID,IAAJ,EAAU;AACR,eAAO,IAAP;AACD;;AACD;AACD,KAND,MAMO;AACL;AACA,aAAO,KAAP;AACD;AACF;;AAED,SAAO,KAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASE,eAAT,CAAyBd,QAAzB,EAA6CC,IAA7C,EAAyDC,UAAzD,EAAiF;AACtF,MAAMC,IAAI,GAAGH,QAAQ,CAACI,OAAT,CAAiBH,IAAI,CAACI,GAAtB,CAAb,CADsF,CAGtF;;AACA,MAAI,CAACF,IAAD,IAASA,IAAI,CAACG,MAAL,KAAgB,CAA7B,EAAgC;AAC9B,WAAO,KAAP;AACD;;AAED,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,IAAI,CAACG,MAAzB,EAAiCC,CAAC,EAAlC,EAAsC;AACpC,QAAMC,OAAO,GAAGL,IAAI,CAACM,KAAL,CAAW,CAAX,EAAcF,CAAd,CAAhB;AACA,QAAMG,KAAK,GAAGV,QAAQ,CAACW,aAAT,CAAuBH,OAAvB,CAAd;;AACA,QAAIX,SAAS,CAACa,KAAD,CAAT,IAAoBZ,cAAc,CAACY,KAAD,CAAtC,EAA+C;AAC7C,UAAME,IAAI,GAAGhB,WAAW,CAACI,QAAD,EAAWU,KAAX,EAAkBR,UAAlB,oBAAkBA,UAAU,CAAEW,GAA9B,EAAmC,MAAnC,CAAxB;;AACA,UAAID,IAAJ,EAAU;AACR,eAAO,KAAP;AACD;;AACD;AACD,KAND,MAMO;AACL;AACA,aAAO,IAAP;AACD;AACF;;AAED,SAAO,IAAP;AACD","sourcesContent":["import { Controller, Document, getUserData, Node } from '@ali/4ever-cangjie';\nimport { isSubject } from '@ali/4ever-plugin-subject';\nimport { isHeadingGroup } from './utils';\n\n/**\n * 节点是否在折叠的 Group 之内\n * @param document\n * @param node\n * @returns\n */\nexport function isFoldInGroup(document: Document, node: Node, controller: Controller) {\n  const path = document.getPath(node.key);\n\n  // path 不存在则返回 false\n  if (!path || path.length === 0) {\n    return false;\n  }\n\n  // 查询节点的父节点是否是折叠态\n  for (let i = 1; i < path.length; i++) {\n    const subPath = path.slice(0, i);\n    const block = document.getNodeByPath(subPath);\n    if (isSubject(block) || isHeadingGroup(block)) {\n      const fold = getUserData(document, block, controller?.uid, 'fold');\n      if (fold) {\n        return true;\n      }\n      continue;\n    } else {\n      // 短路优化：若不为 group 节点则返回 false\n      return false;\n    }\n  }\n\n  return false;\n}\n\n/**\n * 节点是否在未折叠的 Group 内\n * @param document\n * @param node\n * @returns\n * @description 通常此方法需要与 `isFoldInGroup` 配合使用\n */\nexport function isUnfoldInGroup(document: Document, node: Node, controller: Controller) {\n  const path = document.getPath(node.key);\n\n  // path 不存在则返回 false\n  if (!path || path.length === 0) {\n    return false;\n  }\n\n  for (let i = 1; i < path.length; i++) {\n    const subPath = path.slice(0, i);\n    const block = document.getNodeByPath(subPath);\n    if (isSubject(block) || isHeadingGroup(block)) {\n      const fold = getUserData(document, block, controller?.uid, 'fold');\n      if (fold) {\n        return false;\n      }\n      continue;\n    } else {\n      // 短路优化：如果 group 组中途断掉，则返回 true\n      return true;\n    }\n  }\n\n  return true;\n}\n"],"file":"helpers.js"}