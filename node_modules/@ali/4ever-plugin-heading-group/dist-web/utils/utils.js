import { Block, Injection } from '@ali/4ever-cangjie';
import { generateHeadingGroupKey as generateGroupKey, generateHeadingGroupType as generateGroupType, groupHeading as group } from '@ali/4ever-utils';
export { generateGroupKey, generateGroupType, group };
export function not(fn) {
  return function notFn() {
    return !fn.apply(void 0, arguments);
  };
}
/**
 * 生成条件组查询器
 * @param predicates
 * @returns
 */

export function condition() {
  for (var _len = arguments.length, predicates = new Array(_len), _key = 0; _key < _len; _key++) {
    predicates[_key] = arguments[_key];
  }

  function some(node) {
    return predicates.some(function (predicate) {
      return predicate(node);
    });
  }

  return {
    some: some,
    not: not(some)
  };
}
var HEADING_GROUP_REG = /^heading-\d-group$/;
/**
 * 判断是否是折叠标题类型
 * @param type
 * @returns
 */

export function isGroupType(type) {
  return HEADING_GROUP_REG.test(type);
}
/**
 * 判断节点是否是标题组
 * @param node
 * @returns
 */

export function isHeadingGroup(node) {
  return Block.isBlock(node) && isGroupType(node.type);
}
/**
 * 检测节点是否是某个类型的 group
 * @param node
 * @param type
 * @returns
 */

export function isGroupFrom(node, type) {
  return Block.isBlock(node) && node.type === generateGroupType(type);
}
/**
 * 读取标题等级
 * @param node
 * @returns
 */

export function getHeadingLevel(node) {
  switch (node.type) {
    case 'heading-1':
      {
        return 1;
      }

    case 'heading-2':
      {
        return 2;
      }

    case 'heading-3':
      {
        return 3;
      }

    case 'heading-4':
      {
        return 4;
      }

    case 'heading-5':
      {
        return 5;
      }

    case 'heading-6':
      {
        return 6;
      }

    default:
      {
        return -1;
      }
  }
}
/**
 * 注入一组 Injection 至一组节点组中
 * @param injections
 * @param nodes
 * @returns
 */

export function injectToNodes(injections, nodes) {
  var injectionMap = new Map();
  injections.forEach(function (injection) {
    var injectionList = injectionMap.get(injection.key);

    if (injectionList) {
      injectionList.push(injection);
    } else {
      injectionMap.set(injection.key, [injection]);
    }
  });
  return nodes.map(function (node) {
    var injectionList = injectionMap.get(node.key);

    if (injectionList) {
      return Injection.injectIntoNode(injectionList, node);
    }

    return node;
  });
}
export function isHeadingGroupAvailable(controller) {
  return controller == null ? void 0 : controller.query('isHeadingGroupAvailable');
}

function isHeading(node) {
  return Block.isBlock(node) && getHeadingLevel(node) > 0;
}
/**
 * @description 获取下一个可视节点
 */


export function getNextViewGroupNode(node, controller) {
  var document = controller.value.document;
  var level = getHeadingLevel(node);
  var parent = document.getParent(node.key);

  if (!parent || level <= 0 || !isHeadingGroupAvailable(controller)) {
    return null;
  }

  var nextNode = parent.getNextBlock(node.key);

  if (!controller.userData.get(node, 'fold')) {
    return nextNode;
  }

  while (nextNode) {
    var nextLevel = getHeadingLevel(nextNode);

    if (nextLevel > 0 && nextLevel <= level) {
      return nextNode;
    }

    nextNode = parent.getNextBlock(nextNode.key);
  }

  return nextNode;
}
/**
 * @description 获取上一个可视节点
 */

export function getPreviousViewGroupNode(node, controller) {
  var document = controller.value.document;
  var level = getHeadingLevel(node);
  var parent = document.getParent(node.key);

  if (!parent || !isHeadingGroupAvailable(controller)) {
    return null;
  }

  var group = {};
  var previousNode = parent.getPreviousBlock(node.key);
  var previousViewNode = previousNode;
  var maxLevel = 10;

  while (previousNode) {
    var prevLevel = getHeadingLevel(previousNode);
    var fold = controller.userData.get(previousNode, 'fold');

    if (isHeading(previousNode) && fold && !group[prevLevel] && prevLevel <= maxLevel) {
      if (!isHeading(previousViewNode)) {
        previousViewNode = previousNode;
      } else if (getHeadingLevel(previousViewNode) > prevLevel) {
        previousViewNode = previousNode;
      }
    }

    if (isHeading(previousNode) && !group[prevLevel]) {
      group[prevLevel] = previousNode;

      if (prevLevel < maxLevel) {
        maxLevel = prevLevel;
      }
    }

    if (prevLevel > 1 && prevLevel <= level || prevLevel === 1) {
      return previousViewNode;
    }

    previousNode = parent.getPreviousBlock(previousNode.key);
  }

  return previousViewNode;
}
//# sourceMappingURL=utils.js.map