"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.not = not;
exports.condition = condition;
exports.isGroupType = isGroupType;
exports.isHeadingGroup = isHeadingGroup;
exports.isGroupFrom = isGroupFrom;
exports.getHeadingLevel = getHeadingLevel;
exports.injectToNodes = injectToNodes;
exports.isHeadingGroupAvailable = isHeadingGroupAvailable;
exports.getNextViewGroupNode = getNextViewGroupNode;
exports.getPreviousViewGroupNode = getPreviousViewGroupNode;
Object.defineProperty(exports, "generateGroupKey", {
  enumerable: true,
  get: function () {
    return _everUtils.generateHeadingGroupKey;
  }
});
Object.defineProperty(exports, "generateGroupType", {
  enumerable: true,
  get: function () {
    return _everUtils.generateHeadingGroupType;
  }
});
Object.defineProperty(exports, "group", {
  enumerable: true,
  get: function () {
    return _everUtils.groupHeading;
  }
});

var _everCangjie = require("@ali/4ever-cangjie");

var _everUtils = require("@ali/4ever-utils");

function not(fn) {
  return function notFn(...args) {
    return !fn(...args);
  };
}
/**
 * 生成条件组查询器
 * @param predicates
 * @returns
 */


function condition(...predicates) {
  function some(node) {
    return predicates.some(predicate => predicate(node));
  }

  return {
    some,
    not: not(some)
  };
}

const HEADING_GROUP_REG = /^heading-\d-group$/;
/**
 * 判断是否是折叠标题类型
 * @param type
 * @returns
 */

function isGroupType(type) {
  return HEADING_GROUP_REG.test(type);
}
/**
 * 判断节点是否是标题组
 * @param node
 * @returns
 */


function isHeadingGroup(node) {
  return _everCangjie.Block.isBlock(node) && isGroupType(node.type);
}
/**
 * 检测节点是否是某个类型的 group
 * @param node
 * @param type
 * @returns
 */


function isGroupFrom(node, type) {
  return _everCangjie.Block.isBlock(node) && node.type === (0, _everUtils.generateHeadingGroupType)(type);
}
/**
 * 读取标题等级
 * @param node
 * @returns
 */


function getHeadingLevel(node) {
  switch (node.type) {
    case 'heading-1':
      {
        return 1;
      }

    case 'heading-2':
      {
        return 2;
      }

    case 'heading-3':
      {
        return 3;
      }

    case 'heading-4':
      {
        return 4;
      }

    case 'heading-5':
      {
        return 5;
      }

    case 'heading-6':
      {
        return 6;
      }

    default:
      {
        return -1;
      }
  }
}
/**
 * 注入一组 Injection 至一组节点组中
 * @param injections
 * @param nodes
 * @returns
 */


function injectToNodes(injections, nodes) {
  const injectionMap = new Map();
  injections.forEach(injection => {
    const injectionList = injectionMap.get(injection.key);

    if (injectionList) {
      injectionList.push(injection);
    } else {
      injectionMap.set(injection.key, [injection]);
    }
  });
  return nodes.map(node => {
    const injectionList = injectionMap.get(node.key);

    if (injectionList) {
      return _everCangjie.Injection.injectIntoNode(injectionList, node);
    }

    return node;
  });
}

function isHeadingGroupAvailable(controller) {
  return controller?.query('isHeadingGroupAvailable');
}

function isHeading(node) {
  return _everCangjie.Block.isBlock(node) && getHeadingLevel(node) > 0;
}
/**
 * @description 获取下一个可视节点
 */


function getNextViewGroupNode(node, controller) {
  const {
    document
  } = controller.value;
  const level = getHeadingLevel(node);
  const parent = document.getParent(node.key);

  if (!parent || level <= 0 || !isHeadingGroupAvailable(controller)) {
    return null;
  }

  let nextNode = parent.getNextBlock(node.key);

  if (!controller.userData.get(node, 'fold')) {
    return nextNode;
  }

  while (nextNode) {
    const nextLevel = getHeadingLevel(nextNode);

    if (nextLevel > 0 && nextLevel <= level) {
      return nextNode;
    }

    nextNode = parent.getNextBlock(nextNode.key);
  }

  return nextNode;
}
/**
 * @description 获取上一个可视节点
 */


function getPreviousViewGroupNode(node, controller) {
  const {
    document
  } = controller.value;
  const level = getHeadingLevel(node);
  const parent = document.getParent(node.key);

  if (!parent || !isHeadingGroupAvailable(controller)) {
    return null;
  }

  const group = {};
  let previousNode = parent.getPreviousBlock(node.key);
  let previousViewNode = previousNode;
  let maxLevel = 10;

  while (previousNode) {
    const prevLevel = getHeadingLevel(previousNode);
    const fold = controller.userData.get(previousNode, 'fold');

    if (isHeading(previousNode) && fold && !group[prevLevel] && prevLevel <= maxLevel) {
      if (!isHeading(previousViewNode)) {
        previousViewNode = previousNode;
      } else if (getHeadingLevel(previousViewNode) > prevLevel) {
        previousViewNode = previousNode;
      }
    }

    if (isHeading(previousNode) && !group[prevLevel]) {
      group[prevLevel] = previousNode;

      if (prevLevel < maxLevel) {
        maxLevel = prevLevel;
      }
    }

    if (prevLevel > 1 && prevLevel <= level || prevLevel === 1) {
      return previousViewNode;
    }

    previousNode = parent.getPreviousBlock(previousNode.key);
  }

  return previousViewNode;
}
//# sourceMappingURL=utils.js.map