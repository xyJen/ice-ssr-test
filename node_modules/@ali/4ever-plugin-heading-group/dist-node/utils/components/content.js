"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var React = _interopRequireWildcard(require("react"));

var _styledComponents = _interopRequireDefault(require("styled-components"));

var _classnames = _interopRequireDefault(require("classnames"));

const _createElement = /*#__PURE__*/React.createElement;

const ContentBox = /*#__PURE__*/_styledComponents.default.div(["&.transition{max-height:fit-content;transition:all 0.2s ease-in-out;overflow:hidden;&.fold{display:block;}}&.fold{max-height:0;overflow:hidden;display:none;}"]);

const PocketBox = /*#__PURE__*/_styledComponents.default.div([":first-child > [data-cangjie-leaf-block] > *{margin-top:0 !important;}& >:first-child > [data-name='heading-group-title'] > [data-name='heading-group-title-content'] > [data-cangjie-leaf-block] > *{margin-top:0 !important;}"]);

const Content = props => {
  const {
    fold,
    animate,
    style,
    className,
    dataName,
    children
  } = props;
  const foldRef = React.useRef(fold);
  const contentRef = React.useRef(null);
  const pocketRef = React.useRef(null);
  const [internalFold, setInternalFold] = React.useState(fold);
  const [transition, setTransition] = React.useState(false);
  const setAnimationHeight = React.useCallback(fold => {
    if (pocketRef.current && contentRef.current) {
      contentRef.current.style.maxHeight = fold ? '0' : `${pocketRef.current.offsetHeight}px`;
    }
  }, []);
  /**
   * Step1: 折叠状态发生变化，准备添加动画，并设置动画初始状态，在 task 末尾设置动画目标状态
   */

  React.useLayoutEffect(() => {
    if (fold !== foldRef.current) {
      if (animate) {
        setTransition(true); // 设置初始状态

        setAnimationHeight(foldRef.current);
        Promise.resolve().then(() => {
          // 设置目标状态
          setAnimationHeight(fold);
        });
      } else {
        setTransition(false);
        setInternalFold(fold);
      }

      foldRef.current = fold;
    }
  }, [animate, fold]);
  /**
   * Step2: 动画结束后移除动画类，更新折叠状态并设置高度自适应
   */

  const handleTransitionEnd = React.useCallback(() => {
    setTransition(false);
    setInternalFold(foldRef.current);

    if (contentRef.current) {
      // 动画结束重置 css 状态，自动撑起高度
      contentRef.current.style.maxHeight = 'fit-content';
    }
  }, []);
  const classNames = (0, _classnames.default)({
    transition,
    fold: internalFold
  });
  return /*#__PURE__*/_createElement(ContentBox, {
    ref: contentRef,
    className: classNames,
    style: style,
    onTransitionEnd: handleTransitionEnd
  }, /*#__PURE__*/_createElement(PocketBox, {
    ref: pocketRef,
    "data-name": dataName,
    "data-heading-fold": fold,
    className: className
  }, children));
};

Content.displayName = 'Content';
var _default = Content;
exports.default = _default;
//# sourceMappingURL=content.js.map