{"version":3,"sources":["../../../src/utils/utils.ts"],"names":["not","fn","notFn","args","condition","predicates","some","node","predicate","HEADING_GROUP_REG","isGroupType","type","test","isHeadingGroup","Block","isBlock","isGroupFrom","getHeadingLevel","injectToNodes","injections","nodes","injectionMap","Map","forEach","injection","injectionList","get","key","push","set","map","Injection","injectIntoNode","isHeadingGroupAvailable","controller","query","isHeading","getNextViewGroupNode","document","value","level","parent","getParent","nextNode","getNextBlock","userData","nextLevel","getPreviousViewGroupNode","group","previousNode","getPreviousBlock","previousViewNode","maxLevel","prevLevel","fold"],"mappings":"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","sourcesContent":["import { Controller, Block, Element, Injection } from '@ali/4ever-cangjie';\nimport type { FoldableHeadingData } from '@ali/4ever-plugin-heading';\nimport {\n  generateHeadingGroupKey as generateGroupKey,\n  generateHeadingGroupType as generateGroupType,\n  groupHeading as group,\n} from '@ali/4ever-utils';\n\nexport {\n  generateGroupKey,\n  generateGroupType,\n  group\n}\n\nexport type Condition = (node: any) => boolean;\n\nexport function not<T extends (...args: any[]) => boolean>(fn: T): T {\n  return function notFn(...args: any[]) {\n    return !fn(...args);\n  } as T;\n}\n\n/**\n * 生成条件组查询器\n * @param predicates\n * @returns\n */\nexport function condition<T extends Condition>(...predicates: T[]) {\n  function some(node: any) {\n    return predicates.some((predicate) => predicate(node));\n  }\n\n  return {\n    some,\n    not: not(some),\n  };\n}\n\nconst HEADING_GROUP_REG = /^heading-\\d-group$/;\n\n/**\n * 判断是否是折叠标题类型\n * @param type\n * @returns\n */\nexport function isGroupType(type: string): boolean {\n  return HEADING_GROUP_REG.test(type);\n}\n\n/**\n * 判断节点是否是标题组\n * @param node\n * @returns\n */\nexport function isHeadingGroup(node: any): node is Block<FoldableHeadingData> {\n  return Block.isBlock(node) && isGroupType(node.type);\n}\n\n/**\n * 检测节点是否是某个类型的 group\n * @param node\n * @param type\n * @returns\n */\n export function isGroupFrom(node: any, type: string): node is Block {\n  return Block.isBlock(node) && node.type === generateGroupType(type);\n}\n\n/**\n * 读取标题等级\n * @param node\n * @returns\n */\nexport function getHeadingLevel(node: Block): number {\n  switch (node.type) {\n    case 'heading-1': {\n      return 1;\n    }\n\n    case 'heading-2': {\n      return 2;\n    }\n\n    case 'heading-3': {\n      return 3;\n    }\n\n    case 'heading-4': {\n      return 4;\n    }\n\n    case 'heading-5': {\n      return 5;\n    }\n\n    case 'heading-6': {\n      return 6;\n    }\n\n    default: {\n      return -1;\n    }\n  }\n}\n\n/**\n * 注入一组 Injection 至一组节点组中\n * @param injections\n * @param nodes\n * @returns\n */\nexport function injectToNodes<T extends Element>(injections: Injection[], nodes: T[]): T[] {\n  const injectionMap = new Map<string, Injection[]>();\n  injections.forEach((injection) => {\n    const injectionList = injectionMap.get(injection.key);\n    if (injectionList) {\n      injectionList.push(injection);\n    } else {\n      injectionMap.set(injection.key, [injection]);\n    }\n  });\n  return nodes.map((node) => {\n    const injectionList = injectionMap.get(node.key);\n    if (injectionList) {\n      return Injection.injectIntoNode(injectionList, node) as T;\n    }\n    return node;\n  });\n}\n\nexport function isHeadingGroupAvailable(controller: Controller): boolean {\n  return controller?.query('isHeadingGroupAvailable');\n}\n\nfunction isHeading (node: Block | null): node is Block {\n  return Block.isBlock(node) && getHeadingLevel(node) > 0;\n}\n\n/**\n * @description 获取下一个可视节点\n */\nexport function getNextViewGroupNode(node: Block, controller: Controller) {\n  const { document } = controller.value;\n  const level = getHeadingLevel(node);\n  const parent = document.getParent(node.key);\n  if (!parent || level <= 0 || !isHeadingGroupAvailable(controller)) {\n    return null\n  }\n  let nextNode = parent.getNextBlock(node.key);\n\n  if (!controller.userData.get(node, 'fold')) {\n    return nextNode;\n  }\n\n  while(nextNode) {\n    const nextLevel = getHeadingLevel(nextNode);\n    if (nextLevel > 0 && nextLevel <= level) {\n      return nextNode;\n    }\n    nextNode = parent.getNextBlock(nextNode.key);\n  }\n  return nextNode;\n}\n\n/**\n * @description 获取上一个可视节点\n */\nexport function getPreviousViewGroupNode(node: Block, controller: Controller) {\n  const { document } = controller.value;\n  const level = getHeadingLevel(node);\n  const parent = document.getParent(node.key);\n  if (!parent || !isHeadingGroupAvailable(controller)) {\n    return null;\n  }\n  const group = {};\n\n  let previousNode = parent.getPreviousBlock(node.key);\n  let previousViewNode = previousNode;\n  let maxLevel = 10;\n\n  while (previousNode) {\n    const prevLevel = getHeadingLevel(previousNode);\n    const fold = controller.userData.get(previousNode, 'fold');\n    if (isHeading(previousNode) && fold && !group[prevLevel] && prevLevel <= maxLevel) {\n      if (!isHeading(previousViewNode)) {\n        previousViewNode = previousNode;\n      } else if (getHeadingLevel(previousViewNode) > prevLevel) {\n        previousViewNode = previousNode;\n      }\n    }\n\n    if (isHeading(previousNode) && !group[prevLevel]) {\n      group[prevLevel] = previousNode;\n      if (prevLevel < maxLevel) {\n        maxLevel = prevLevel;\n      }\n    }\n\n    if ((prevLevel > 1 && prevLevel <= level) || prevLevel === 1) {\n      return previousViewNode;\n    }\n\n    previousNode = parent.getPreviousBlock(previousNode.key);\n  }\n  return previousViewNode;\n}"],"file":"utils.js"}