"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var React = _interopRequireWildcard(require("react"));

var ReactDOM = _interopRequireWildcard(require("react-dom"));

var _lodash = require("lodash");

var _fastdom = _interopRequireDefault(require("fastdom"));

var _everCangjie = require("@ali/4ever-cangjie");

var _everPluginPcContexMenu = require("@ali/4ever-plugin-pc-contex-menu");

var _everUtils = require("@ali/4ever-utils");

var _actions = require("../actions");

var _getPositionOfCell = _interopRequireDefault(require("../utils/getPositionOfCell"));

var _constants = require("../constants");

var _createTableSelectionForFocusedCell = _interopRequireDefault(require("../utils/createTableSelectionForFocusedCell"));

var _cornerToolbar = _interopRequireDefault(require("./cornerToolbar"));

var _colToolbar = _interopRequireDefault(require("./colToolbar"));

var _rowToolbar = _interopRequireDefault(require("./rowToolbar"));

var _tableResizeController = _interopRequireDefault(require("./tableResizeController"));

var _styled = require("./styled");

var _logger = require("../utils/logger");

var _tableWithSelection = _interopRequireDefault(require("./tableWithSelection"));

var _cornerButton = _interopRequireDefault(require("./cornerButton"));

var _useSelectionStatus = require("../../utils/hooks/useSelectionStatus");

var _constants2 = require("../../utils/constants");

var _tableScrollContainer = _interopRequireDefault(require("../../components/tableScrollContainer"));

var _useTableIsSelected = require("../../utils/hooks/useTableIsSelected");

var _utils = _interopRequireDefault(require("../../utils/utils"));

var _usePixelColsWidth = require("../../utils/hooks/usePixelColsWidth");

var _tableContextContainer = _interopRequireDefault(require("../../components/tableContextContainer"));

var _contextContainer = require("./contextContainer");

/* eslint-disable max-lines */

/* eslint-disable react/no-find-dom-node */
const _createElement = /*#__PURE__*/React.createElement;
const {
  getTableIsSelected,
  visibleUtil
} = _utils.default;

function getColIndex(cell, border, table) {
  const cellKey = cell.getAttribute('data-cangjie-key');
  const position = (0, _getPositionOfCell.default)(cellKey, table);
  const colIndex = position && position.colIndex;

  if (!(typeof colIndex === 'number' && colIndex >= 0)) {
    return null;
  }

  return border === 'left' ? colIndex - 1 : colIndex + (parseInt(cell.getAttribute('colspan'), 10) || 1) - 1;
}

function getRowKey(cell, border) {
  const row = cell.parentElement;

  if (!row) {
    return null;
  }

  const rowElements = Array.from(row.parentElement.children);
  const rowIndex = rowElements.indexOf(row);
  const adjustedRowIndex = border === 'top' ? rowIndex - 1 : rowIndex;
  const adjustedRow = rowElements[adjustedRowIndex];

  if (adjustedRow) {
    return adjustedRow.getAttribute('data-cangjie-key');
  }

  return null;
}

function getPrevVisibleCell(cell) {
  let prevVisibleCell = cell.previousElementSibling;

  while (prevVisibleCell && prevVisibleCell.style.display === 'none') {
    prevVisibleCell = prevVisibleCell.previousElementSibling;
  }

  return prevVisibleCell;
}

function getNextVisibleCell(cell) {
  let nextVisibleCell = cell.nextElementSibling;

  while (nextVisibleCell && nextVisibleCell.style.display === 'none') {
    nextVisibleCell = nextVisibleCell.nextElementSibling;
  }

  return nextVisibleCell;
}

let lastActiveTableKey = null;
const {
  closeContextMenu
} = _everPluginPcContexMenu.actions;

function getLastActiveTableKey() {
  return lastActiveTableKey;
}

class Table extends React.Component {
  constructor(props) {
    super(props);
    this.colResizeable = false;
    this.rowResizeable = false;
    this.resizingColIndex = null;
    this.resizingRowKey = null;
    this.resizingColCell = null;
    this.resizingColNextCell = null;
    this.resizingRow = null;
    this.startTableX = null;
    this.startTableY = null;
    this.wrapperRef = /*#__PURE__*/React.createRef();
    this.realTableWrapperRef = /*#__PURE__*/React.createRef();
    this.tableRef = /*#__PURE__*/React.createRef();
    this.colResizerRef = /*#__PURE__*/React.createRef();
    this.rowResizerRef = /*#__PURE__*/React.createRef();
    this.colIndicatorRef = /*#__PURE__*/React.createRef();
    this.rowIndicatorRef = /*#__PURE__*/React.createRef();
    this.tableResizeControllerRef = /*#__PURE__*/React.createRef();
    this.tableResizeControlLinesRef = /*#__PURE__*/React.createRef();
    this.tableLeftShadowRef = /*#__PURE__*/React.createRef();
    this.tableRightShadowRef = /*#__PURE__*/React.createRef();
    this.lastEndCellKey = null;
    this.tableSelection = null;
    this.colsNodes = [];
    this.updateShadowRafId = null;
    this.tableCursorStyle = null;
    this.isResizingTable = false;

    this.closeContextMenu = () => {
      const {
        controller
      } = this.props;
      controller.run('onAction', closeContextMenu());
    };

    this.getContainerWidth = () => {
      const {
        controller,
        node
      } = this.props;
      const {
        value
      } = controller;
      const containerBlock = (0, _everUtils.getClosestContainerBlock)(value, node);
      const containerWidth = (0, _everUtils.getInnerWidth)(containerBlock);
      return containerWidth;
    };

    this.handleMouseEnter = () => {
      if (!this.realTableWrapperRef.current) return;
      this.tableCursorStyle = this.realTableWrapperRef.current.style.cursor;
    };

    this.handleMouseMove = event => {
      const {
        zoomContainer
      } = this.props;
      const relativeEvent = (0, _everUtils.getRelativeMouseEvent)(event, zoomContainer);

      if (this.startTableX || // 正在调整列宽
      this.startTableY || this.isInNestedTable(event)) {
        return;
      }

      const targetCell = event.target.closest('td');
      const prevCursor = this.tableCursorStyle;

      if (!targetCell) {
        return;
      }

      const targetCellRect = (0, _everUtils.getBoundingRelativeRect)(targetCell, zoomContainer);
      const deltaToLeft = relativeEvent.relativeX - targetCellRect.left;
      const deltaToRight = targetCellRect.right - relativeEvent.relativeX;
      const deltaToTop = relativeEvent.relativeY - targetCellRect.top;
      const deltaToBottom = targetCellRect.bottom - relativeEvent.relativeY; // DETECT_DELTA不加成scale比较合理

      if (deltaToLeft <= _constants.DETECT_DELTA) {
        if (!targetCell.previousElementSibling) {
          this.colResizeable = false;
          targetCell.style.cursor = prevCursor;
        } else {
          this.colResizeable = 'left';
          this.rowResizeable = false;
          targetCell.style.cursor = 'col-resize';
        }
      } else if (deltaToRight <= _constants.DETECT_DELTA) {
        this.colResizeable = 'right';
        this.rowResizeable = false;
        targetCell.style.cursor = 'col-resize';
      } else if (deltaToTop <= 4) {
        if (!targetCell.parentElement.previousElementSibling) {
          this.rowResizeable = false;
          targetCell.style.cursor = prevCursor;
        } else {
          this.rowResizeable = 'top';
          this.colResizeable = false;
          targetCell.style.cursor = 'row-resize';
        }
      } else if (deltaToBottom <= _constants.DETECT_DELTA) {
        this.rowResizeable = 'bottom';
        this.colResizeable = false;
        targetCell.style.cursor = 'row-resize';
      } else {
        this.rowResizeable = false;
        this.colResizeable = false; // 单元格的鼠标默认样式

        targetCell.style.cursor = prevCursor;
      }
    };

    this.handleMouseDown = event => {
      const {
        node
      } = this.props;
      lastActiveTableKey = node.key; // 右键 mouseDown 不处理

      if (this.isInNestedTable(event) || event.buttons === 2) {
        return;
      }

      if (this.colResizeable) {
        this.handleColResizeStart(event);
      } else if (this.rowResizeable) {
        this.handleRowResizeStart(event);
      }
    };

    this.handleTableResizeStart = event => {
      const {
        scale,
        zoomContainer
      } = this.props;
      event.preventDefault();
      event.stopPropagation();
      const relativeEvent = (0, _everUtils.getRelativeMouseEvent)(event, zoomContainer);
      const realTableWrapper = ReactDOM.findDOMNode(this.realTableWrapperRef.current);
      const realTableWrapperRect = (0, _everUtils.getBoundingRelativeRect)(realTableWrapper, zoomContainer);
      this.startTableX = Math.round((relativeEvent.relativeX - realTableWrapperRect.left) / scale);
      this.startTableY = Math.round((relativeEvent.relativeY - realTableWrapperRect.top) / scale);

      if (this.tableResizeControlLinesRef.current) {
        this.tableResizeControlLinesRef.current.style.display = 'block';
      }

      this.isResizingTable = true;
      document.addEventListener('mousemove', this.handleTableResizing);
      document.addEventListener('mouseup', this.handleTableResizeEnd);
    };

    this.handleTableResizing = event => {
      const {
        scale,
        zoomContainer
      } = this.props;
      if (!zoomContainer) return;
      event.preventDefault();
      event.stopPropagation();
      const relativeEvent = (0, _everUtils.getRelativeMouseEvent)(event, zoomContainer);
      const realTableWrapper = this.realTableWrapperRef.current;
      if (!realTableWrapper || !this.tableRef.current || !this.tableResizeControllerRef.current) return;
      const realTableWrapperRect = (0, _everUtils.getBoundingRelativeRect)(realTableWrapper, zoomContainer);
      const table = this.tableRef.current;
      const tableRect = (0, _everUtils.getBoundingRelativeRect)(table, zoomContainer);
      const tableResizeController = this.tableResizeControllerRef.current;
      const currentTableX = Math.max(_constants.MIN_COL_WIDTH, Math.round((relativeEvent.relativeX - realTableWrapperRect.left) / scale));
      const currentTableY = Math.max(_constants.MIN_ROW_HEIGHT, Math.round((relativeEvent.relativeY - tableRect.top) / scale));
      tableResizeController.style.left = `${currentTableX}px`;
      tableResizeController.style.top = `${currentTableY + Math.round((tableRect.top - realTableWrapperRect.top) / scale)}px`;
    };

    this.handleTableResizeEnd = event => {
      this.isResizingTable = false;
      event.preventDefault();
      event.stopPropagation();
      const {
        controller,
        node,
        zoomContainer,
        scale
      } = this.props;
      const rowsHeight = controller.query('getAllRowsHeight', {
        node
      });
      const relativeEvent = (0, _everUtils.getRelativeMouseEvent)(event, zoomContainer);
      const realTableWrapper = this.realTableWrapperRef.current;

      if (!realTableWrapper) {
        return;
      }

      const realTableWrapperRect = (0, _everUtils.getBoundingRelativeRect)(realTableWrapper, zoomContainer);
      const deltaX = Math.round((relativeEvent.relativeX - realTableWrapperRect.left) / scale) - this.startTableX;
      const deltaY = Math.round((relativeEvent.relativeY - realTableWrapperRect.top) / scale) - this.startTableY;
      this.startTableX = null;
      this.startTableY = null;

      if (this.tableResizeControlLinesRef.current) {
        this.tableResizeControlLinesRef.current.style.display = 'none';
      }

      document.removeEventListener('mousemove', this.handleTableResizing);
      document.removeEventListener('mouseup', this.handleTableResizeEnd);
      const maxTableWidth = controller.query('maxTableWidth', {
        node
      });
      controller.run('onAction', (0, _actions.resizeTableWidth)(node, deltaX, maxTableWidth));
      controller.run('onAction', (0, _actions.resizeTableHeight)(node, rowsHeight, deltaY));
      this.updateShadowState();
    };

    this.handleColResizeStart = event => {
      const {
        scale,
        zoomContainer,
        node
      } = this.props;
      const relativeEvent = (0, _everUtils.getRelativeMouseEvent)(event, zoomContainer);
      event.preventDefault();
      const targetCell = event.target.closest('td');

      if (!targetCell) {
        return;
      } // @ts-ignore


      this.resizingColIndex = getColIndex(targetCell, this.colResizeable, node);

      if (typeof this.resizingColIndex !== 'number') {
        return;
      }

      this.resizingColCell = this.colResizeable === 'left' ? getPrevVisibleCell(targetCell) : targetCell;
      this.resizingColNextCell = this.colResizeable === 'left' ? targetCell : getNextVisibleCell(targetCell);
      const realTableWrapper = ReactDOM.findDOMNode(this.realTableWrapperRef.current);
      const realTableWrapperRect = (0, _everUtils.getBoundingRelativeRect)(realTableWrapper, zoomContainer);
      const table = ReactDOM.findDOMNode(this.tableRef.current);
      const tableRect = (0, _everUtils.getBoundingRelativeRect)(table, zoomContainer);
      const firstRowDOM = table.querySelector('tr');
      if (!firstRowDOM) return;
      const firstRowRect = (0, _everUtils.getBoundingRelativeRect)(firstRowDOM, zoomContainer);
      this.startTableX = relativeEvent.relativeX - realTableWrapperRect.left;
      const colResizer = ReactDOM.findDOMNode(this.colResizerRef.current);
      colResizer.style.display = 'block';
      colResizer.style.height = `${Math.round(tableRect.bottom - firstRowRect.top) / scale + (this.isSelected() ? _constants.TOOLBAR_ITEM_SIZE / scale : 0)}px`;
      colResizer.style.left = `${Math.round(this.startTableX / scale)}px`;
      document.addEventListener('mousemove', this.handleColResizing);
      document.addEventListener('mouseup', this.handleColResizeEnd);
    };

    this.handleColResizing = event => {
      const {
        node,
        colsWidth
      } = this.props;
      const {
        scale,
        zoomContainer
      } = this.props;
      if (!zoomContainer) return;
      const relativeEvent = (0, _everUtils.getRelativeMouseEvent)(event, zoomContainer);
      event.preventDefault();
      const realTableWrapper = this.realTableWrapperRef.current;
      const colResizer = this.colResizerRef.current; // Fix: 找不到节点

      if (!realTableWrapper || !colResizer || !this.resizingColCell) return;
      const realTableWrapperRect = (0, _everUtils.getBoundingRelativeRect)(realTableWrapper, zoomContainer);
      const resizingColCellRect = (0, _everUtils.getBoundingRelativeRect)(this.resizingColCell, zoomContainer);
      const resizingColCellRectLeft = resizingColCellRect.left;
      const resizingColCellIndex = this.resizingColIndex - parseInt(this.resizingColCell.getAttribute('colspan'), 10) + 1;

      if (!node.data.colsWidth) {
        (0, _logger.logNPEInfo)(node, {
          type: `node.data.colsWidth is ${node.data.colsWidth}`,
          nodeData: node.data
        });
        return;
      }

      const fixedColWidth = (colsWidth || []).slice(resizingColCellIndex, this.resizingColIndex).reduce((sum, colWidth) => sum + colWidth, 0);
      const validLeftLimit = resizingColCellRectLeft + fixedColWidth * scale + _constants.MIN_COL_WIDTH * scale;
      const totalWidth = (colsWidth || []).reduce((sum, colWidth) => sum + colWidth, 0);
      let validRightLimit = Infinity;

      if (this.resizingColNextCell && totalWidth <= this.getContainerWidth() - 2) {
        const resizingColNextCellRect = (0, _everUtils.getBoundingRelativeRect)(this.resizingColNextCell, zoomContainer);
        const resizingColNextCellRectLeft = resizingColNextCellRect.left;
        const resizingColNextCellIndex = resizingColCellIndex + parseInt(this.resizingColCell.getAttribute('colspan'), 10);
        validRightLimit = resizingColNextCellRectLeft + (colsWidth[resizingColNextCellIndex] - _constants.MIN_COL_WIDTH) * scale;
      }

      let validClientX = Math.max(validLeftLimit, relativeEvent.relativeX);
      validClientX = Math.min(validRightLimit, validClientX);
      colResizer.style.left = `${Math.round((validClientX - realTableWrapperRect.left) / scale)}px`;
    };

    this.handleColResizeEnd = () => {
      const {
        scale
      } = this.props;
      const colResizer = ReactDOM.findDOMNode(this.colResizerRef.current);

      if (!colResizer) {
        return;
      }

      const delta = parseInt(colResizer.style.left, 10) - Math.round(this.startTableX / scale);

      if (!isNaN(delta)) {
        this.handleColResize(this.resizingColIndex, delta);
      }

      document.removeEventListener('mousemove', this.handleColResizing);
      document.removeEventListener('mouseup', this.handleColResizeEnd);
      colResizer.style.display = 'none';
      colResizer.style.left = '';
      this.resizingColIndex = null;
      this.resizingColCell = null;
      this.resizingColNextCell = null;
      this.startTableX = null;
    };

    this.handleColResize = (resizeColIndex, delta) => {
      const {
        controller,
        node
      } = this.props;
      controller.run('onAction', (0, _actions.resizeTableColWidth)({
        node,
        colIndex: resizeColIndex,
        delta
      }));
      this.updateShadowState();
    };

    this.handleRowResizeStart = event => {
      const {
        scale,
        zoomContainer,
        isSelected
      } = this.props;
      const relativeEvent = (0, _everUtils.getRelativeMouseEvent)(event, zoomContainer);
      event.preventDefault();
      const targetCell = event.target.closest('td');

      if (!targetCell) {
        return;
      }

      const resizingRowKey = getRowKey(targetCell, this.rowResizeable);

      if (!resizingRowKey) {
        return;
      }

      this.resizingRowKey = resizingRowKey;
      this.resizingRow = this.rowResizeable === 'top' ? targetCell.parentElement.previousElementSibling : targetCell.parentElement;
      const realTableWrapper = ReactDOM.findDOMNode(this.realTableWrapperRef.current);
      const realTableWrapperRect = (0, _everUtils.getBoundingRelativeRect)(realTableWrapper, zoomContainer);
      const table = ReactDOM.findDOMNode(this.tableRef.current);
      const tableRect = (0, _everUtils.getBoundingRelativeRect)(table, zoomContainer);
      this.startTableY = relativeEvent.relativeY - realTableWrapperRect.top;
      const rowResizer = ReactDOM.findDOMNode(this.rowResizerRef.current);
      rowResizer.style.display = 'block';
      rowResizer.style.marginTop = '-1px';
      const tableWidth = Math.min(tableRect.width, realTableWrapperRect.width);
      rowResizer.style.width = `${Math.round((tableWidth + (isSelected ? _constants.TOOLBAR_ITEM_SIZE : 0)) / scale)}px`;
      rowResizer.style.top = `${Math.round(this.startTableY / scale)}px`;
      document.addEventListener('mousemove', this.handleRowResizing);
      document.addEventListener('mouseup', this.handleRowResizeEnd);
    };

    this.handleRowResizing = event => {
      const {
        scale,
        zoomContainer
      } = this.props;
      const relativeEvent = (0, _everUtils.getRelativeMouseEvent)(event, zoomContainer);
      event.preventDefault();
      const realTableWrapper = ReactDOM.findDOMNode(this.realTableWrapperRef.current);
      const rowResizer = ReactDOM.findDOMNode(this.rowResizerRef.current); // Fix: 找不到节点

      if (!realTableWrapper || !rowResizer || !this.resizingRow) return;
      const realTableWrapperRect = (0, _everUtils.getBoundingRelativeRect)(realTableWrapper, zoomContainer);
      const resizingColRectTop = (0, _everUtils.getBoundingRelativeRect)(this.resizingRow, zoomContainer).top;
      const validTopLimit = resizingColRectTop + _constants.MIN_ROW_HEIGHT * scale;
      const validClientY = Math.max(validTopLimit, relativeEvent.relativeY);
      rowResizer.style.top = `${Math.round((validClientY - realTableWrapperRect.top) / scale)}px`;
    };

    this.handleRowResizeEnd = () => {
      const {
        scale
      } = this.props;
      const rowResizer = ReactDOM.findDOMNode(this.rowResizerRef.current);

      if (!rowResizer) {
        return;
      }

      const delta = parseInt(rowResizer.style.top, 10) - Math.round(this.startTableY / scale);

      if (!isNaN(delta)) {
        this.handleRowResize(this.resizingRowKey, delta);
      }

      document.removeEventListener('mousemove', this.handleRowResizing);
      document.removeEventListener('mouseup', this.handleRowResizeEnd);
      rowResizer.style.display = 'none';
      rowResizer.style.top = '';
      this.resizingRowKey = null;
      this.resizingRow = null;
      this.startTableY = null;
    };

    this.handleRowResize = (resizingRowKey, delta) => {
      const {
        controller
      } = this.props;
      const tableRow = controller.value.document.getNode(resizingRowKey); // 协同者可能删除 row

      if (!tableRow) return;
      const originalHeight = controller.query('getRowsHeight', {
        node: tableRow
      });
      controller.run('onAction', (0, _actions.setTableRowHeight)(tableRow, originalHeight + delta));
    };

    this.handleSelectRow = (selectedRowRange, shouldHideContextMenu = true) => {
      const {
        controller,
        node
      } = this.props; // selections不止一个的情况，交给pi处理

      lastActiveTableKey = node.key;
      const {
        start,
        end
      } = selectedRowRange;
      controller.run('onAction', (0, _actions.selectTableRows)(node, start, end));

      if (shouldHideContextMenu) {
        this.closeContextMenu();
      }
    };

    this.handleSelectCol = (selectedColRange, shouldHideContextMenu = true) => {
      const {
        controller,
        node
      } = this.props; // selections不止一个的情况，交给pi处理

      lastActiveTableKey = node.key;
      const {
        start,
        end
      } = selectedColRange;
      controller.run('onAction', (0, _actions.selectTableCols)(node, start, end));

      if (shouldHideContextMenu) {
        this.closeContextMenu();
      }
    };

    this.handleSelectCorner = () => {
      const {
        controller,
        node
      } = this.props; // selections不止一个的情况，交给pi处理

      lastActiveTableKey = node.key;
      controller.run('onAction', (0, _actions.selectTable)(node));
      this.closeContextMenu();
    };

    this.updateShadowStyleCallback = visible => {
      if (!visible) return;
      const {
        scale,
        zoomContainer,
        node: dataTable
      } = this.props;
      visibleUtil.unregisterVisibleChange(dataTable.key, this.updateShadowStyleCallback);
      const table = ReactDOM.findDOMNode(this.tableRef.current);

      if (!table) {
        return;
      }

      const tableRect = (0, _everUtils.getBoundingRelativeRect)(table, zoomContainer);
      const tableLeftShadow = ReactDOM.findDOMNode(this.tableLeftShadowRef.current);
      const tableRightShadow = ReactDOM.findDOMNode(this.tableRightShadowRef.current);
      const height = `${Math.round(tableRect.height / scale)}px`;

      if (tableLeftShadow) {
        tableLeftShadow.style.height = height;
      }

      if (tableRightShadow) {
        tableRightShadow.style.height = height;
      }
    };

    this.updateShadowStyle = () => {
      const {
        node
      } = this.props;

      if (visibleUtil.getVisible(node.key)) {
        this.updateShadowStyleCallback(true);
      } else {
        visibleUtil.unregisterVisibleChange(node.key, this.updateShadowStyleCallback);
        visibleUtil.registerVisibleChange(node.key, this.updateShadowStyleCallback);
      }
    };

    this.updateScrollLeft = () => {
      const {
        node
      } = this.props;
      const {
        percentOfScrollLeft
      } = node.data || {};
      const scrollContainer = this.realTableWrapperRef.current;

      if (!scrollContainer || !this.tableRef.current) {
        return;
      }

      if (typeof percentOfScrollLeft === 'number') {
        const containerWidth = scrollContainer.offsetWidth;
        const tableWidth = this.tableRef.current.offsetWidth;
        const totalScroll = tableWidth - containerWidth;
        scrollContainer.scrollTo({
          left: percentOfScrollLeft * totalScroll,
          behavior: 'smooth'
        });
      }
    };

    this.updateTableResizeController = () => {
      const {
        controller,
        scale,
        zoomContainer
      } = this.props;

      if (!this.isSelected() || !zoomContainer) {
        return;
      }

      const tableDOM = ReactDOM.findDOMNode(this.tableRef.current);
      const realTableWrapper = ReactDOM.findDOMNode(this.realTableWrapperRef.current);
      const tableResizeController = ReactDOM.findDOMNode(this.tableResizeControllerRef.current);

      if (!tableResizeController || !tableDOM || !realTableWrapper) {
        return;
      }

      const tableRect = (0, _everUtils.getBoundingRelativeRect)(tableDOM, zoomContainer);
      const realTableWrapperRect = (0, _everUtils.getBoundingRelativeRect)(realTableWrapper, zoomContainer);

      if (!controller.query('isTableSupportResize')) {
        tableResizeController.style.display = 'none';
        return;
      } // 可能出现小数的偏差，容错


      if (tableRect.right <= realTableWrapperRect.right + 1) {
        tableResizeController.style.display = '';
        tableResizeController.style.left = `${Math.round((tableRect.right - realTableWrapperRect.left) / scale)}px`;
        tableResizeController.style.top = `${Math.round((tableRect.bottom - realTableWrapperRect.top) / scale)}px`;
      } else {
        tableResizeController.style.display = 'none';
      }
    };

    this.updateOnRender = (0, _lodash.throttle)(() => {
      this.updateTableResizeController();
      this.updateShadowStyle();
    });

    this.handleTableToolbarContextMenu = event => {
      event.preventDefault();
      const {
        controller
      } = this.props;
      controller.run('onContextMenu', event);
    };

    this.handleMenuEvent = type => {
      const {
        controller,
        node
      } = this.props;
      let selection = this.getTableSelection();

      if (!selection) {
        selection = (0, _createTableSelectionForFocusedCell.default)(controller.value, node);
      }

      if (type === 'delete-table') {
        controller.run('onAction', (0, _actions.deleteTable)(node));
      } else if (type === 'table-width-fit-container') {
        controller.run('onAction', (0, _actions.resizeTableWidthFitContainer)(node));
      }
    };

    this.updateShadowState = () => {
      // 文档模型更新后，DOM 不会立刻更新，所以需要等待 DOM 更新后再计算阴影的状态
      if (this.updateShadowRafId !== null) {
        window.cancelAnimationFrame(this.updateShadowRafId);
      }

      this.updateShadowRafId = window.requestAnimationFrame(() => {
        _fastdom.default.measure(() => {
          const table = ReactDOM.findDOMNode(this.tableRef.current);
          const realTableWrapper = ReactDOM.findDOMNode(this.realTableWrapperRef.current);

          if (!table || !realTableWrapper) {
            return;
          }

          const {
            zoomContainer
          } = this.props;
          const tableRect = (0, _everUtils.getBoundingRelativeRect)(table, zoomContainer);
          const realTableWrapperRect = (0, _everUtils.getBoundingRelativeRect)(realTableWrapper, zoomContainer);
          const shouldShowTableLeftShadow = realTableWrapper.scrollLeft > 0;
          const scrollableContentWidth = tableRect.width;
          const shouldShowTableRightShadow = scrollableContentWidth - realTableWrapper.scrollLeft > realTableWrapperRect.width;
          const {
            shouldShowTableLeftShadow: prevLeft,
            shouldShowTableRightShadow: prevRight
          } = this.state;

          if (prevLeft !== shouldShowTableLeftShadow || prevRight !== shouldShowTableRightShadow) {
            this.setState({
              shouldShowTableLeftShadow,
              shouldShowTableRightShadow
            });
          }
        });
      });
    };

    this.handleTableScroll = (0, _lodash.throttle)(() => {
      const {
        controller,
        node,
        tableConfig
      } = this.props;
      const table = ReactDOM.findDOMNode(this.tableRef.current);

      if (!table || !this.realTableWrapperRef.current) {
        return;
      }

      controller.run('onAction', (0, _actions.scrollTable)(this.realTableWrapperRef.current));

      if (tableConfig?.onScroll) {
        tableConfig.onScroll(this.realTableWrapperRef.current, node);
      }

      this.updateShadowState();
    });

    this.getTableSelection = () => {
      const {
        controller,
        node
      } = this.props;
      const tblSelections = controller.query('viewTableSelections');

      if (!tblSelections) {
        return null;
      }

      const curTableSelection = tblSelections.find(ts => ts.key === node.key);

      if (!curTableSelection) {
        return null;
      }

      return curTableSelection;
    };

    this.getTableLeftMaxBorder = table => {
      return table.nodes.reduce((acc, row) => {
        if (!row.nodes) {
          return acc;
        }

        const firstCell = row.nodes[0];

        if (firstCell && firstCell.data && !firstCell.data.hidden && firstCell.data.bdr && firstCell.data.bdr.left && firstCell.data.bdr.left.sz > acc) {
          return firstCell.data.bdr.left.sz;
        }

        return acc;
      }, 1);
    };

    this.getAllColsNodes = colsNodes => {
      this.colsNodes = colsNodes;
    };

    this.handleSetIsHighlightSelection = isHighlight => {
      this.setState({
        isSelectionHighlight: isHighlight
      });
    };

    this.handleSetHoverSelection = sel => {
      this.setState({
        hoverSelection: sel
      });
    };

    this.isShowCornerToolbar = () => {
      const {
        tableConfig
      } = this.props;
      return !tableConfig?.hideCornerButton?.();
    };

    this.handleMouseEnterTable = () => {
      // 调整表格宽高时，会频繁触发 mouseenter 和 mouseleave
      // 所以调整期间不更新 isHoverTable
      if (this.isResizingTable) return;
      this.setState({
        isHoverTable: true
      });
    };

    this.handleMouseLeaveTable = () => {
      if (this.isResizingTable) return;
      this.setState({
        isHoverTable: false
      });
    };

    this.setWholeTableHoverSelection = () => {
      const cols = this.props.node.data?.colsWidth?.length;
      const rows = this.props.node?.nodes.length;

      if (!cols || !rows) {
        this.handleSetHoverSelection(null);
        return;
      }

      this.handleSetHoverSelection({
        key: this.props.node.key,
        endColIndex: cols - 1,
        endRowIndex: rows - 1,
        startColIndex: 0,
        startRowIndex: 0
      });
    };

    this.removeWholeTableHoverSelection = () => {
      this.handleSetHoverSelection(null);
    };

    this.handleMouseEnterCornerToolbar = () => {
      this.setWholeTableHoverSelection();
      this.setState({
        isHoverCornerToolbar: true
      });
    };

    this.handleMouseLeaveCornerToolbar = () => {
      this.removeWholeTableHoverSelection();
      this.setState({
        isHoverCornerToolbar: false
      });
    };

    this.state = {
      shouldShowTableLeftShadow: false,
      shouldShowTableRightShadow: false,
      isSelectionHighlight: false,
      hoverSelection: null,
      isHoverTable: false,
      isHoverCornerToolbar: false
    };
  }

  componentDidMount() {
    this.updateOnRender();
    this.updateShadowState();
    this.updateScrollLeft();
  }

  componentDidUpdate(prevProps) {
    _fastdom.default.measure(() => {
      const {
        node,
        isSelected
      } = this.props;
      this.updateOnRender();
      const {
        node: prevNode,
        isSelected: prevIsSelected
      } = prevProps;

      if (isSelected !== prevIsSelected || (node.data.colsWidth || []).length !== (prevNode.data.colsWidth || []).length) {
        this.handleTableScroll();
      }

      if (node.data?.percentOfScrollLeft !== prevNode.data?.percentOfScrollLeft) {
        this.updateScrollLeft();
      }
    });
  }

  componentWillUnmount() {
    this.handleTableScroll.cancel();
    this.updateOnRender.cancel();

    if (this.updateShadowRafId !== null) {
      window.cancelAnimationFrame(this.updateShadowRafId);
    }

    document.removeEventListener('mousemove', this.handleColResizing);
    document.removeEventListener('mouseup', this.handleColResizeEnd);
    document.removeEventListener('mousemove', this.handleRowResizing);
    document.removeEventListener('mouseup', this.handleRowResizeEnd);
    document.removeEventListener('mousemove', this.handleTableResizing);
    document.removeEventListener('mouseup', this.handleTableResizeEnd);
  }

  isInNestedTable(event) {
    const table = event.target.closest('table');
    return table !== ReactDOM.findDOMNode(this.tableRef.current);
  }

  isSelected() {
    const {
      isSelected
    } = this.props;
    return isSelected || Boolean(this.getTableSelection());
  }

  render() {
    const {
      controller,
      node,
      children,
      locale,
      scale = 1,
      zoomContainer,
      scrollableContainer,
      tableConfig = {},
      draggableConfig,
      visible
    } = this.props;
    const {
      hideDeleteButton = false,
      hideWidthFitButton = false,
      enableAutofitWidth,
      enableHeader,
      setTableHeaderStyle
    } = tableConfig;
    const {
      shouldShowTableLeftShadow,
      shouldShowTableRightShadow,
      isSelectionHighlight,
      hoverSelection,
      isHoverCornerToolbar
    } = this.state;
    const leftOffset = Math.floor(this.getTableLeftMaxBorder(node) / 2);
    const isSelected = this.isSelected();
    const isSelectWholeTable = controller.query('isSelectWholeTable', {
      node
    });
    const isHideDeleteButton = typeof hideDeleteButton === 'function' ? hideDeleteButton() : hideDeleteButton;
    const style = {};

    if (visible === false) {
      style.display = 'none';
    }

    return /*#__PURE__*/_createElement(_styled.Wrapper, {
      ref: this.wrapperRef,
      onClick: () => {
        // onClick 多覆盖了悬浮工具栏onMouseDown被拦截的情况
        lastActiveTableKey = node.key;
      },
      onMouseDown: this.handleMouseDown,
      onMouseEnter: this.handleMouseEnterTable,
      onMouseLeave: this.handleMouseLeaveTable,
      style: style,
      "data-type": "table"
    }, /*#__PURE__*/_createElement(_useTableIsSelected.TableIsSelectedContext.Provider, {
      value: isSelected
    }, /*#__PURE__*/_createElement(_tableScrollContainer.default, {
      className: "real-table-wrapper",
      table: node,
      controller: controller,
      ref: this.realTableWrapperRef,
      onMouseEnter: this.handleMouseEnter,
      onMouseMove: this.handleMouseMove,
      onScroll: this.handleTableScroll,
      disableHorizontalScrollbar: tableConfig?.disableHorizontalScrollbar // note: 解决左border因滚动表格overflow auto被遮挡的问题
      ,
      style: {
        marginLeft: -leftOffset,
        paddingLeft: leftOffset,
        // 设置 paddingTop、marginTop 保证列工具栏「点」不会被 overflow hidden
        paddingTop: _constants2.REALTABLE_PADDING.top / scale,
        marginTop: -_constants2.REALTABLE_PADDING.top / scale,
        paddingBottom: _constants2.REALTABLE_PADDING.bottom // 由于选中后表格边框有1px边距，因此不加bottom会产生滚动条

      }
    }, /*#__PURE__*/_createElement(_colToolbar.default, {
      locale: locale,
      controller: controller,
      table: node,
      tableRef: this.tableRef,
      positionedAncestorRef: this.realTableWrapperRef,
      scrollContainer: this.realTableWrapperRef,
      colIndicatorRef: this.colIndicatorRef,
      isTableSelected: isSelected,
      onContextMenu: this.handleTableToolbarContextMenu,
      onSelect: this.handleSelectCol,
      onColResize: this.handleColResize,
      onGetAllColsNodes: this.getAllColsNodes,
      zoomContainer: zoomContainer,
      getLastActiveTableKey: getLastActiveTableKey,
      scale: scale,
      setIsHighlightSelection: this.handleSetIsHighlightSelection,
      hoverSelection: hoverSelection,
      setHoverSelection: this.handleSetHoverSelection,
      isHideDeleteButton: isHideDeleteButton,
      isHoverCornerToolbar: isHoverCornerToolbar
    }), /*#__PURE__*/_createElement(_tableWithSelection.default, {
      ref: this.tableRef,
      node: node,
      controller: controller,
      left: -leftOffset,
      scale: scale,
      tableSelection: this.getTableSelection(),
      getTableSelection: this.getTableSelection,
      hoverSelection: hoverSelection,
      isSelectionHighlight: isSelectionHighlight
    }, children())), /*#__PURE__*/_createElement(_tableResizeController.default, {
      visible: isSelected,
      onMouseDown: this.handleTableResizeStart,
      ref: {
        // @ts-ignore
        tableResizeControllerRef: this.tableResizeControllerRef,
        tableResizeControlLinesRef: this.tableResizeControlLinesRef
      }
    }), /*#__PURE__*/_createElement(_styled.ColResizer, {
      ref: this.colResizerRef
    }), /*#__PURE__*/_createElement(_styled.RowResizer, {
      ref: this.rowResizerRef,
      style: {
        left: isSelected ? -_constants.TOOLBAR_ITEM_SIZE / scale : 0
      }
    }), /*#__PURE__*/_createElement(_styled.ColIndicator, {
      ref: this.colIndicatorRef,
      isTableSelected: isSelected,
      "data-testid": "table-col-indicator",
      scale: scale
    }), /*#__PURE__*/_createElement(_styled.RowIndicator, {
      ref: this.rowIndicatorRef,
      isTableSelected: isSelected,
      "data-testid": "table-row-indicator"
    }), /*#__PURE__*/_createElement(_styled.TableLeftSideShadow, {
      ref: this.tableLeftShadowRef,
      scale: scale,
      style: {
        display: shouldShowTableLeftShadow ? 'block' : 'none'
      }
    }), /*#__PURE__*/_createElement(_styled.TableRightSideShadow, {
      ref: this.tableRightShadowRef,
      scale: scale,
      style: {
        display: shouldShowTableRightShadow ? 'block' : 'none'
      }
    }), /*#__PURE__*/_createElement(_rowToolbar.default, {
      locale: locale,
      isSelected: isSelected,
      controller: controller,
      table: node,
      tableRef: this.tableRef,
      offsetParentRef: this.wrapperRef,
      realTableWrapperRef: this.realTableWrapperRef,
      rowIndicatorRef: this.rowIndicatorRef,
      isSelectWholeTable: isSelectWholeTable,
      onContextMenu: this.handleTableToolbarContextMenu,
      onSelect: this.handleSelectRow,
      onRowResize: this.handleRowResize,
      zoomContainer: zoomContainer,
      getLastActiveTableKey: getLastActiveTableKey,
      scale: scale,
      setIsHighlightSelection: this.handleSetIsHighlightSelection,
      setHoverSelection: this.handleSetHoverSelection,
      hoverSelection: hoverSelection,
      scrollableContainer: scrollableContainer,
      isHideDeleteButton: isHideDeleteButton,
      isHoverCornerToolbar: isHoverCornerToolbar
    }), this.isShowCornerToolbar() && /*#__PURE__*/_createElement(_cornerToolbar.default, {
      locale: locale,
      visible: this.isSelected() || this.state.isHoverTable,
      controller: controller,
      realTableWrapperRef: this.realTableWrapperRef,
      table: node,
      isSelectWholeTable: !!isSelectWholeTable,
      onSelect: this.handleSelectCorner,
      onMouseEnter: this.handleMouseEnterCornerToolbar,
      onMouseLeave: this.handleMouseLeaveCornerToolbar,
      onToolbarEvent: this.handleMenuEvent,
      zoomContainer: zoomContainer,
      getLastActiveTableKey: getLastActiveTableKey,
      scale: scale,
      setIsHighlightSelection: this.handleSetIsHighlightSelection,
      hideWidthFitButton: hideWidthFitButton,
      draggableConfig: draggableConfig,
      enableAutofitWidth: enableAutofitWidth,
      enableHeader: enableHeader,
      setTableHeaderStyle: setTableHeaderStyle
    }), /*#__PURE__*/_createElement(_cornerButton.default, {
      scale: scale,
      isSelected: isSelected,
      onClick: this.handleSelectCorner,
      active: isSelectWholeTable || isHoverCornerToolbar,
      onMouseEnter: this.handleMouseEnterCornerToolbar,
      onMouseLeave: this.handleMouseLeaveCornerToolbar,
      hoverSelection: !!hoverSelection
    })));
  }

}

const Container = props => {
  const scrollableContainer = (0, _everCangjie.useScrollableContainer)();
  const zoomContainer = (0, _everCangjie.useZoomContainer)() || window.document.body;
  const scale = (0, _everCangjie.useZoom)();
  const {
    controller,
    node,
    visible
  } = props;
  const [pendingSelectedWhole, setPendingSelectedWhole] = React.useState(false); // 当仓颉pendingEnable开启的时候通过监听selectionData$的变化来实时确定是否需要更新table
  // 避免等待500ms的防抖延时后再更新
  // pendingEnable为false的情况下，useSelectionStatus注册的回调函数不会执行，因为此时渲染更新是实时的

  const [realSelected, setRealSelected] = React.useState(false);
  const [, forceUpdate] = React.useReducer(c => !c, false);
  React.useEffect(() => {
    const newTable = controller.value.document.getNode(node.key);
    if (!newTable) return;
    setRealSelected(getTableIsSelected(newTable, controller));
  }, [node, controller.value.selection, controller]);
  const shouldUpdateTable = React.useCallback(({
    isPendingSelected,
    isSelectWholeTable
  }) => {
    setRealSelected(isPendingSelected);
    setPendingSelectedWhole(isSelectWholeTable);

    if (controller.hasHots()) {
      forceUpdate();
    }
  }, [controller, node]);
  (0, _useSelectionStatus.useSelectionStatus)(controller, node, shouldUpdateTable, []);
  React.useEffect(() => {
    controller.run('onAction', (0, _actions.adjustColsWidth)(node));
  });
  const memoProps = React.useMemo(() => {
    return { ...props,
      isSelected: realSelected,
      isSelectWholeTable: pendingSelectedWhole
    };
  }, [props, realSelected, pendingSelectedWhole]);
  return /*#__PURE__*/_createElement(_contextContainer.ContextContainer, {
    isSelected: realSelected
  }, /*#__PURE__*/_createElement(_usePixelColsWidth.PixelColsWidthContext.Consumer, null, ([pixelColsWidth]) => /*#__PURE__*/_createElement(Table, (0, _extends2.default)({}, memoProps, {
    scrollableContainer: scrollableContainer,
    zoomContainer: zoomContainer,
    scale: scale || 1,
    colsWidth: pixelColsWidth,
    visible: visible
  }))));
};

var _default = props => {
  const {
    controller,
    node,
    tableConfig = {}
  } = props;
  const {
    enableHeaderSticky
  } = tableConfig;
  return /*#__PURE__*/_createElement(_tableContextContainer.default, {
    controller: controller,
    table: node,
    enableHeaderSticky: enableHeaderSticky
  }, /*#__PURE__*/_createElement(Container, props));
};

exports.default = _default;
//# sourceMappingURL=table.js.map