"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _fastDeepEqual = _interopRequireDefault(require("fast-deep-equal"));

var ReactDOM = _interopRequireWildcard(require("react-dom"));

var _styledComponents = _interopRequireDefault(require("styled-components"));

var _lodash = require("lodash");

var _fastdom = _interopRequireDefault(require("fastdom"));

var _everLogger = _interopRequireDefault(require("@ali/4ever-logger"));

var _models = _interopRequireDefault(require("../../../mo/models"));

var _everCangjie = require("@ali/4ever-cangjie");

var _everUtils = require("@ali/4ever-utils");

var _constants = require("../../constants");

var _styled = require("../styled");

var _logger = require("../../utils/logger");

var _getAllRowsDomRect = _interopRequireDefault(require("../../queries/getAllRowsDomRect"));

var _actions = require("../../actions");

var _inlineToolbarInsertButton = _interopRequireDefault(require("../inlineToolbarButtons/inlineToolbarInsertButton"));

var _inlineToolbarDeleteButton = _interopRequireDefault(require("../inlineToolbarButtons/inlineToolbarDeleteButton"));

var _insertButtonIndicator = _interopRequireWildcard(require("../inlineToolbarButtons/insertButtonIndicator"));

var _dragElement = _interopRequireDefault(require("./dragElement"));

var _rowToolbarItem = _interopRequireDefault(require("./rowToolbarItem"));

var _scrollContainer = require("../../utils/scrollContainer");

var _createToolbarWithTableSelection = _interopRequireDefault(require("../createToolbarWithTableSelection"));

var _getDataTableSelectionByTable = _interopRequireDefault(require("../../utils/getDataTableSelectionByTable"));

var _getSelectedRangeFromTableSelection = require("../../utils/getSelectedRangeFromTableSelection");

var _hasIntersectionObserver = _interopRequireDefault(require("../../utils/hasIntersectionObserver"));

var _constants2 = _interopRequireDefault(require("../../../utils/constants"));

var hooks = _interopRequireWildcard(require("../../../utils/hooks"));

/* eslint-disable @typescript-eslint/no-shadow */

/* eslint-disable max-lines */

/* eslint-disable react/no-find-dom-node */
const _createElement = /*#__PURE__*/_react.default.createElement;
const {
  usePixelColsWidth,
  useRowsClientHeight,
  useRowIsSticky,
  useScrollableContainerRect
} = hooks;
const {
  REALTABLE_PADDING,
  TOOLBAR_ITEM_SIZE,
  MIN_ROW_HEIGHT,
  STICKY_ROW_TOP_HEIGHT,
  STICKY_TOOLBAR_INDEX_MAP
} = _constants2.default;

const RowToolbarWrapper = /*#__PURE__*/_styledComponents.default.div(["display:", ";position:absolute;left:", "px;box-sizing:border-box;width:", "px;padding-left:", "px;z-index:", ";top:", "px;"], ({
  visible
}) => visible ? 'block' : 'none', props => -(TOOLBAR_ITEM_SIZE + _constants.HOVER_SHOW_INSERT_DELTA) / props.scale, props => (TOOLBAR_ITEM_SIZE + 1 + _constants.HOVER_SHOW_INSERT_DELTA) / props.scale, props => _constants.HOVER_SHOW_INSERT_DELTA / props.scale, STICKY_TOOLBAR_INDEX_MAP.rowToolbar, p => (REALTABLE_PADDING.top + TOOLBAR_ITEM_SIZE) / p.scale);

const RowInlineToolbar = /*#__PURE__*/_styledComponents.default.div(["position:absolute;z-index:100;opacity:", ";transition:opacity ease-in 0.25s;pointer-events:", ";"], p => p.isShow ? 1 : 0, p => p.isShow ? 'auto' : 'none');

const RowToolbarResizer = /*#__PURE__*/_styledComponents.default.div(["position:absolute;bottom:-4px;right:-1px;height:7px;width:", "px;background-color:transparent;z-index:1;cursor:row-resize;&:hover{background-color:#3296FA;}"], props => (TOOLBAR_ITEM_SIZE + 1) / props.scale);

const TableRowToolbar = props => {
  const {
    table,
    isSelected,
    controller,
    zoomContainer,
    scale,
    tableRef,
    offsetParentRef,
    realTableWrapperRef,
    rowIndicatorRef,
    selection,
    hoverSelection,
    scrollableContainer,
    onContextMenu,
    onSelect,
    onRowResize,
    setIsHighlightSelection,
    setHoverSelection,
    getLastActiveTableKey,
    locale,
    isHideDeleteButton,
    isHoverCornerToolbar
  } = props;
  const [colsWidth] = usePixelColsWidth();

  const isRowHeader = _models.default.isRowHeader(table);

  const [isSticky] = useRowIsSticky();
  const [scrollRect] = useScrollableContainerRect();
  const [rowsClientHeight] = useRowsClientHeight();

  const rowsHeight = _react.default.useMemo(() => {
    return table.nodes.map(row => rowsClientHeight[row.key] || 0);
  }, [rowsClientHeight, table.nodes]);

  const [contextMenuVisible, setContextMenuVisible] = _react.default.useState(false);

  const [positionOfInsertButton, setInsetBtnPos] = _react.default.useState(-1);

  const [isHoverDelete, setIsHoverDelete] = _react.default.useState(false);

  const [hoverToolbarItemIndex, setHoverToolbarItemIndex] = _react.default.useState(-1);

  const [isDragging, setIsDragging] = _react.default.useState(false);

  const [draggingRowHeight, setDraggingRowHeight] = _react.default.useState(0);

  const deleteButtonRef = _react.default.useRef(null);

  const rowToolbarRef = _react.default.useRef(null);

  const insertButtonRef = _react.default.useRef(null);

  const draggingRowResizer = _react.default.useRef(null);

  const startPositionTop = _react.default.useRef(null);

  const startClientY = _react.default.useRef(null);

  const originBodyCursor = _react.default.useRef('');

  const rowResizerRef = _react.default.useRef(null);

  const deleteButtonTop = _react.default.useRef(-1); // 当前 viewTable 下的所有行的 DOMRect
  // 不是 dataTable


  const rowsRect = _react.default.useRef([]);

  const isResizingRowFlag = _react.default.useRef(false);

  const dragElementRef = _react.default.useRef(null);

  const dataInsertIndex = _react.default.useRef(-1);

  const startSelectIndex = _react.default.useRef(-1);

  const selectedIndexRange = _react.default.useRef(null);

  const intersectionObRef = _react.default.useRef(null);

  const observerTargets = _react.default.useRef(null);

  const isInitObserver = _react.default.useRef(false); // intersectionOb是否已经监听，避免多次重复监听


  const initObserver = _react.default.useCallback(() => {
    intersectionObRef.current = new IntersectionObserver(changes => {
      for (const change of changes) {
        if (change.intersectionRatio <= 0) {
          change.target.style.visibility = 'hidden';
        } else {
          change.target.style.visibility = 'inherit';
        }
      }
    }, {
      threshold: [0, 1]
    });
    observerTargets.current = document.querySelectorAll('[data-ob="true"]');
    observerTargets.current.forEach(target => {
      intersectionObRef.current.observe(target);
    });
  }, []);

  const detachObserver = _react.default.useCallback(() => {
    if (observerTargets.current && intersectionObRef.current) {
      observerTargets.current.forEach(target => {
        intersectionObRef.current.unobserve(target);
      });
      intersectionObRef.current.disconnect();
    }
  }, []);

  (0, _react.useEffect)(() => {
    if (_hasIntersectionObserver.default && isSelected && !isInitObserver.current) {
      // 监听后标记为true，避免重复执行
      isInitObserver.current = true;
      initObserver();
    }
  }, [initObserver, isSelected]);

  const getRowIndexByClientY = _react.default.useCallback(clientY => {
    const index = controller.query('getRowIndexByClientY', {
      node: table,
      clientY
    });
    return index === null ? -1 : index;
  }, [controller, table]);

  const calcRowsHeight = _react.default.useCallback((startIndex, endIndex) => {
    const end = endIndex === undefined ? endIndex : endIndex + 1;
    return rowsHeight.slice(startIndex, end).reduce((totalHeight, h) => {
      return totalHeight + h;
    }, 0);
  }, [rowsHeight]);

  const updateInsertButtonStyle = _react.default.useCallback(() => {
    if (positionOfInsertButton === -1 || !insertButtonRef.current || !selection) {
      return;
    }

    const insertButtonNode = insertButtonRef.current;
    const bottom = calcRowsHeight(positionOfInsertButton);
    const menuRect = (0, _everUtils.getBoundingRelativeRect)(insertButtonNode, zoomContainer);
    const right = _constants.DISTANCE_BETWEEN_INSERT_BUTTON_AND_TOOLBAR + TOOLBAR_ITEM_SIZE;
    const insertButtonTop = (bottom - menuRect.height / 2) / scale;
    const style = {
      position: 'absolute',
      right: 'unset',
      top: 'unset',
      transform: 'unset',
      bottom: 'unset',
      left: 'unset'
    };

    if (isSticky && (positionOfInsertButton === 0 || positionOfInsertButton === 1)) {
      style.position = 'fixed';
      style.right = 'unset';
      const top = scrollRect.top + STICKY_ROW_TOP_HEIGHT - menuRect.height / 2;
      const rowHeight = positionOfInsertButton === 0 ? 0 : rowsHeight[0];
      style.top = `${top + rowHeight}px`;

      if (Number.isFinite(scrollRect.left)) {
        style.left = `${scrollRect.left}px`;
      }

      style.transform = 'translateX(calc(-100% - 2px))';
    } else {
      style.bottom = `${Math.round(insertButtonTop)}px`;
      style.right = `${Math.round(right / scale)}px`;
    }

    Object.entries(style).forEach(([k, v]) => {
      insertButtonNode.style[k] = v;
    });
  }, [positionOfInsertButton, selection, calcRowsHeight, zoomContainer, scale, isSticky, scrollRect, rowsHeight]);

  const updateIndicatorStyle = _react.default.useCallback(() => {
    if (!selection || !rowIndicatorRef.current || positionOfInsertButton === -1) {
      return;
    }

    try {
      const targetRow = table.nodes[Math.min(positionOfInsertButton, table.nodes.length - 1)]; // Fix to https://work.aone.alibaba-inc.com/issue/38856463. targetRow会存在拿不到的情况，未能复现早值班问题，暂时不好定位具体原因
      // 先做兜底处理,可能跟协同场景下的一些特殊操作有关?

      if (!targetRow?.key) {
        return;
      }

      const rowDOM = _everCangjie.domUtils.findDOMNode(targetRow.key);

      const tableDOM = _everCangjie.domUtils.findDOMNode(table.key);

      const trueTableDOM = tableRef.current;
      const rowRect = (0, _everUtils.getBoundingRelativeRect)(rowDOM, offsetParentRef.current);
      const tableRect = (0, _everUtils.getBoundingRelativeRect)(tableDOM, zoomContainer);
      const trueTableRect = (0, _everUtils.getBoundingRelativeRect)(trueTableDOM, zoomContainer);
      const width = Math.min(tableRect.width, trueTableRect.width) + TOOLBAR_ITEM_SIZE;
      rowIndicatorRef.current.style.width = `${Math.round(width / scale)}px`;
      rowIndicatorRef.current.style.transform = `translateX(${-TOOLBAR_ITEM_SIZE / scale}px)`;
      let relativeTop = rowRect.top;

      if (positionOfInsertButton === table.nodes.length) {
        relativeTop = rowRect.bottom;
      }

      if (isSticky && (positionOfInsertButton === 0 || positionOfInsertButton === 1)) {
        const top = scrollRect.top + STICKY_ROW_TOP_HEIGHT;
        const rowHeight = positionOfInsertButton === 0 ? 0 : rowsHeight[0];
        rowIndicatorRef.current.style.top = `${top + rowHeight}px`;
        rowIndicatorRef.current.style.position = 'fixed';
      } else {
        rowIndicatorRef.current.style.top = `${Math.round(relativeTop / scale)}px`;
        rowIndicatorRef.current.style.position = 'absolute';
      }
    } catch (e) {
      _everLogger.default.info({
        type: 'updateIndicatorStyle',
        info: JSON.stringify(e)
      });
    }
  }, [selection, rowIndicatorRef, positionOfInsertButton, table.nodes, table.key, tableRef, offsetParentRef, zoomContainer, scale, isSticky, scrollRect.top, rowsHeight]);

  const getDataSelectedIndexRange = _react.default.useCallback(() => {
    const tableSelection = (0, _getDataTableSelectionByTable.default)(controller, table);
    return (0, _getSelectedRangeFromTableSelection.getSelectedRowRangeFromTableSelection)({
      controller,
      table,
      tableSelection
    });
  }, [controller, table]);

  const getSelectedIndexRange = _react.default.useCallback(() => {
    const tableSelection = (0, _getDataTableSelectionByTable.default)(controller, table);
    return (0, _getSelectedRangeFromTableSelection.getSelectedRowRangeFromTableSelection)({
      controller,
      table,
      tableSelection
    });
  }, [controller, table]);

  const getSortedSelectedRange = _react.default.useCallback(r => {
    const range = r || getSelectedIndexRange();

    if (!range) {
      return null;
    }

    const {
      start,
      end
    } = range;
    const min = Math.min(start, end);
    const max = Math.max(start, end);
    return {
      min,
      max
    };
  }, [getSelectedIndexRange]);

  const updateToolbarStyle = _react.default.useCallback(() => {
    updateInsertButtonStyle();
    updateIndicatorStyle();
  }, [updateInsertButtonStyle, updateIndicatorStyle]);

  const updateDeleteButtonStyle = _react.default.useCallback(() => {
    if (!deleteButtonRef.current || !selection) {
      return;
    }

    deleteButtonRef.current.style.display = 'block';
    const thisNode = ReactDOM.findDOMNode(rowToolbarRef.current);
    const targetStartNode = thisNode.children[selection.startRowIndex]?.children[0];
    const targetEndNode = thisNode.children[selection.endRowIndex]?.children[0]; // TODO: targetEndNode/targetStartNode 为空根因待排查
    // 添加日志定位

    if (!targetEndNode || !targetStartNode) {
      (0, _logger.logNPEInfo)(table, {
        selection,
        message: `${targetEndNode ? 'targetStartNode' : 'targetEndNode'} is undefined \n`
      });
      return;
    }

    const menuNode = ReactDOM.findDOMNode(deleteButtonRef.current);
    const targetStartRect = (0, _everUtils.getBoundingRelativeRect)(targetStartNode, zoomContainer);
    const targetEndRect = (0, _everUtils.getBoundingRelativeRect)(targetEndNode, zoomContainer);
    const menuRect = (0, _everUtils.getBoundingRelativeRect)(menuNode, zoomContainer);
    const mid = (targetEndRect.bottom - targetStartRect.top) / 2;
    const relativeTop = targetStartRect.top + mid - menuRect.height / 2;
    const left = targetStartRect.left - menuRect.width - _constants.DISTANCE_BETWEEN_DELETE_BUTTON_AND_TOOLBAR;
    deleteButtonTop.current = relativeTop / scale;
    menuNode.style.top = `${deleteButtonTop.current}px`;
    menuNode.style.left = `${left / scale}px`;
  }, [selection, zoomContainer, table, scale]);

  const handlePreventDefault = _react.default.useCallback(event => {
    event.preventDefault();
    event.stopPropagation();
  }, []);

  const showIndicatorVisible = _react.default.useCallback(isVisible => {
    if (!rowIndicatorRef.current) {
      return;
    }

    const opacity = isVisible ? '1' : '0';
    rowIndicatorRef.current.style.opacity = opacity;
  }, [rowIndicatorRef]); // 根据鼠标位置判断是否出现插入按钮


  const handleMouseMove = _react.default.useCallback((0, _lodash.throttle)(event => {
    // event 应该是非空的，但是有监控有报错显示为空
    // https://aone.alibaba-inc.com/v2/project/995011/bug/43391898
    if (!rowToolbarRef.current || isResizingRowFlag.current || isDragging || !event) {
      return;
    }

    const {
      clientX,
      clientY
    } = event; // 鼠标位置在插入按钮区域时，不隐藏插入按钮

    if (positionOfInsertButton !== -1 && insertButtonRef.current) {
      const insertButtonNode = ReactDOM.findDOMNode(insertButtonRef.current);
      const {
        left,
        top,
        right,
        bottom
      } = insertButtonNode.getBoundingClientRect();

      if (clientX >= left && clientX <= right && clientY >= top && clientY <= bottom) {
        return;
      }
    }

    const toolbarRect = rowToolbarRef.current.getBoundingClientRect();
    const {
      left,
      top,
      right,
      bottom
    } = toolbarRect; // 鼠标位置不在 toolbar 区域内时，不显示插入按钮

    if (clientX < left || clientX > right || clientY < top - _insertButtonIndicator.INDICATOR_WRAPPER_WIDTH / 2 || clientY > bottom + _insertButtonIndicator.INDICATOR_WRAPPER_WIDTH / 2) {
      showIndicatorVisible(false);
      setPositionOfInsertButton(-1);
    }
  }, 200, {
    leading: true
  }), [isDragging, positionOfInsertButton, showIndicatorVisible, getDataSelectedIndexRange]);

  const setPositionOfInsertButton = _react.default.useCallback(index => {
    let i = index;

    if (isRowHeader && i === 0) {
      i = -1;
    }

    setInsetBtnPos(i);
    dataInsertIndex.current = i;
  }, [isRowHeader]);

  const handleMouseOverRowToolbarItem = _react.default.useCallback(event => {
    if (isResizingRowFlag.current) return; // 如果不是ToolbarItem触发的则不处理

    const isToolbarItem = event.target.getAttribute('data-ob');
    if (!isToolbarItem) return;
    const index = parseInt(event.target.getAttribute('data-index'), 10);
    if (isNaN(index)) return;
    const tableCols = table.data?.colsWidth?.length;

    if (tableCols) {
      // 构造hover选区
      const hoverSelection = {
        key: table.key,
        startColIndex: 0,
        endColIndex: tableCols - 1,
        startRowIndex: index,
        endRowIndex: index
      };
      setHoverSelection(hoverSelection); // hover的时候不显示插入按钮

      showIndicatorVisible(false);
      setPositionOfInsertButton(-1);
    }
  }, [setHoverSelection, setPositionOfInsertButton, showIndicatorVisible, table.data?.colsWidth?.length, table.key]);

  const handleMouseOutRowToolbarItem = _react.default.useCallback(e => {
    // 如果不是ToolbarItem触发的则不处理
    const isToolbarItem = e.target.getAttribute('data-ob');
    if (!isToolbarItem) return;
    setHoverSelection(null);
  }, [setHoverSelection]);

  const hideContextMenu = _react.default.useCallback(() => {
    setContextMenuVisible(false);
    document.removeEventListener('mousedown', hideContextMenu);
  }, []);

  const selectRows = _react.default.useCallback((start, end, shouldHideContextMenu = true) => {
    if (start === end) {
      startSelectIndex.current = start;
    }

    selectedIndexRange.current = {
      start,
      end
    };
    onSelect({
      start,
      end
    }, shouldHideContextMenu);
  }, [onSelect]);

  const shouldEnableEndDrag = _react.default.useCallback((insertIndex, rowsLength) => {
    if (insertIndex === 0 && isRowHeader) return false;

    if (insertIndex > 0 && insertIndex < rowsLength) {
      const maxColIndex = table.data.colsWidth.length - 1;
      const aboveRowSelection = {
        startRowIndex: 0,
        endRowIndex: insertIndex - 1,
        startColIndex: 0,
        endColIndex: maxColIndex,
        key: table.key
      };
      return controller.query('isAllSelectedCellsComplete', {
        node: table,
        tableSelection: aboveRowSelection
      });
    }

    return true;
  }, [table, controller, isRowHeader]);

  const handleMultiSelectRow = _react.default.useCallback((0, _lodash.throttle)(event => {
    if (isDragging) {
      return;
    }

    const selectedIndexRange = getDataSelectedIndexRange();
    const {
      buttons
    } = event; // 协同下，rowToolbar 可能不存在

    if (buttons !== 1 || !rowToolbarRef.current || !selectedIndexRange) {
      removeMultiSelectListener();
      return;
    }

    const endSelectedIndex = getRowIndexByClientY(event.clientY);

    if (deleteButtonRef.current) {
      deleteButtonRef.current.style.transition = 'top ease-out 0.1s';
    }

    (0, _scrollContainer.scrollVerticalContainer)(event.clientY, scrollableContainer);
    selectRows(startSelectIndex.current, endSelectedIndex);
  }, 100), [isDragging, getDataSelectedIndexRange, getRowIndexByClientY, selectRows]);

  const moveRowToIndex = _react.default.useCallback((originIndexRange, targetIndex) => {
    const {
      min,
      max
    } = getSortedSelectedRange(originIndexRange);
    controller.run('onAction', (0, _actions.moveTableRows)(table, {
      start: min,
      end: max
    }, targetIndex));
    const startIndex = min < targetIndex ? targetIndex - (max - min + 1) : targetIndex;
    selectRows(startIndex, startIndex + max - min);
  }, [controller, table, getSortedSelectedRange, selectRows]);

  const updateDragElementPosition = _react.default.useCallback((x, y) => {
    if (!dragElementRef.current) {
      return;
    }

    dragElementRef.current.style.left = `${x / scale}px`;
    dragElementRef.current.style.top = `${y / scale}px`;
  }, [scale]);

  const calcInsertIndexByRowsRects = _react.default.useCallback((clientY, rects) => {
    let rowsRects = rects;

    if (!rowsRects) {
      rowsRects = controller.query('getAllRowsDomRect', {
        node: table
      });
    }

    let insertIndex = -1;

    for (let i = 0; i < rowsRects.length; i++) {
      const rowRect = rowsRects[i];

      if (!rowRect) {
        continue;
      }

      if (clientY >= rowRect.top && clientY <= rowRect.top + rowRect.height / 2) {
        insertIndex = i;
        break;
      }

      if (clientY > rowRect.top + rowRect.height / 2 && clientY < rowRect.bottom) {
        insertIndex = i + 1;
        break;
      }
    }

    return insertIndex;
  }, [controller, table]);

  const updateDraggingStyle = _react.default.useCallback(relativeEvent => {
    const {
      clientX,
      clientY,
      relativeX,
      relativeY
    } = relativeEvent;

    const tableDOM = _everCangjie.domUtils.findDOMNode(table.key);

    if (!tableDOM) {
      return;
    }

    updateDragElementPosition(relativeX, relativeY);
    const tableRect = tableDOM.getBoundingClientRect();

    if (clientX < tableRect.left - TOOLBAR_ITEM_SIZE || clientX > tableRect.right || clientY < tableRect.top - TOOLBAR_ITEM_SIZE || clientY > tableRect.bottom) {
      showIndicatorVisible(false);
      setPositionOfInsertButton(-1);
      return;
    }

    (0, _scrollContainer.scrollVerticalContainer)(clientY, scrollableContainer); // 先根据 dataModel 计算应该插入行的 index 判断是否可以插入
    // 再根据 viewModel 计算行插入指示器渲染的位置

    let insertIndex = calcInsertIndexByRowsRects(clientY);
    const sortedRange = getSortedSelectedRange();

    if (!sortedRange) {
      return;
    }

    const {
      min,
      max
    } = sortedRange;

    if (insertIndex >= min && insertIndex <= max + 1) {
      insertIndex = -1;
    }

    const dataRowNodes = controller.query('getAllRowsNodes', {
      node: table
    });
    if (!dataRowNodes) return;
    const shouldDragEnd = shouldEnableEndDrag(insertIndex, dataRowNodes.length);

    if (!shouldDragEnd) {
      insertIndex = -1;
    }

    const dataInsertIndexTemp = insertIndex;

    if (insertIndex !== -1) {
      insertIndex = calcInsertIndexByRowsRects(clientY, rowsRect.current);
    }

    showIndicatorVisible(insertIndex !== -1);
    setPositionOfInsertButton(insertIndex);
    dataInsertIndex.current = dataInsertIndexTemp;
  }, [table, controller, scrollableContainer, updateDragElementPosition, showIndicatorVisible, shouldEnableEndDrag, calcInsertIndexByRowsRects, getSortedSelectedRange, setPositionOfInsertButton]);

  const handleDragging = _react.default.useCallback(event => {
    const tableDOM = _everCangjie.domUtils.findDOMNode(table.key);

    if (!tableDOM || event.buttons !== 1) {
      handleDragEnd();
      return;
    }

    event.stopPropagation();
    const relativeEvent = (0, _everUtils.getRelativeMouseEvent)(event, zoomContainer);
    updateDraggingStyle(relativeEvent);
  }, [table, zoomContainer, updateDraggingStyle]);

  const handleDragEnd = _react.default.useCallback(() => {
    setIsDragging(false);
    showIndicatorVisible(false); // Tip: 为避免循环依赖问题，所以这里没有调用removeDragEventListener函数

    document.removeEventListener('mousemove', handleDragging);
    document.removeEventListener('mouseup', handleDragEnd);

    if (dataInsertIndex.current === -1) {
      return;
    }

    const selectedIndexRange = getDataSelectedIndexRange();
    moveRowToIndex(selectedIndexRange, dataInsertIndex.current);
    setPositionOfInsertButton(-1);
  }, [showIndicatorVisible, handleDragging, getDataSelectedIndexRange, moveRowToIndex, setPositionOfInsertButton]);

  const handleDragStart = _react.default.useCallback((relativeEvent, rowHeight) => {
    setIsDragging(true);
    setDraggingRowHeight(rowHeight);
    updateDraggingStyle(relativeEvent);
    document.addEventListener('mousemove', handleDragging);
    document.addEventListener('mouseup', handleDragEnd);
  }, [updateDraggingStyle, handleDragging, handleDragEnd]);

  const removeDragEventListener = _react.default.useCallback(() => {
    document.removeEventListener('mousemove', handleDragging);
    document.removeEventListener('mouseup', handleDragEnd);
  }, [handleDragging, handleDragEnd]);

  const removeMultiSelectListener = _react.default.useCallback(() => {
    if (deleteButtonRef.current) {
      deleteButtonRef.current.style.transition = 'none';
    }

    document.removeEventListener('mousemove', handleMultiSelectRow);
    document.removeEventListener('mouseup', removeMultiSelectListener);
  }, [handleMultiSelectRow]);

  const addMultiSelectListener = _react.default.useCallback(() => {
    document.addEventListener('mousemove', handleMultiSelectRow);
    document.addEventListener('mouseup', removeMultiSelectListener);
  }, [handleMultiSelectRow, removeMultiSelectListener]);

  const enableDragIcon = _react.default.useCallback(() => {
    const tbs = (0, _getSelectedRangeFromTableSelection.getSelectedRowRangeFromTableSelection)({
      controller,
      table,
      tableSelection: selection
    });
    const range = getSortedSelectedRange(tbs); // 禁止拖拽表头行

    if (isRowHeader && range?.min === 0) return false;
    return Boolean(range && hoverToolbarItemIndex >= range.min && hoverToolbarItemIndex <= range.max);
  }, [controller, table, selection, getSortedSelectedRange, isRowHeader, hoverToolbarItemIndex]);

  const handleSelectRow = _react.default.useCallback(event => {
    handlePreventDefault(event);
    const index = getRowIndexByClientY(event.clientY);
    const sortRange = getDataSelectedIndexRange();
    controller.run('onAction', (0, _actions.clickTableToolbar)(table, 'row', event.target)); // shift 键多选行

    const selectedIndexRange = getDataSelectedIndexRange();

    if (event.shiftKey && selectedIndexRange && startSelectIndex.current !== index) {
      let start = startSelectIndex.current; // 这里为单测兼容 startSelectIndex.current 为 -1 的情况
      // 正常用户操作不会有此类问题

      if (start === -1) {
        start = selectedIndexRange.start;
      }

      selectRows(start, index);
      return;
    } // 直接选中行


    if (!sortRange || index > sortRange.end || index < sortRange.start) {
      selectRows(index, index);
      addMultiSelectListener();
      return;
    }

    const relativeEvent = (0, _everUtils.getRelativeMouseEvent)(event, zoomContainer);
    let timer;
    const isRightClick = event.buttons === 2;

    const clearTimer = () => {
      clearTimeout(timer);
      selectRows(index, index, !isRightClick);
      removeCancelDragEventListener();
    };

    const removeCancelDragEventListener = () => {
      document.removeEventListener('mousemove', clearTimer);
      document.removeEventListener('mouseup', clearTimer);
    };

    const rowHeight = event.target.getBoundingClientRect().height;
    timer = window.setTimeout(() => {
      removeMultiSelectListener();
      handleDragStart(relativeEvent, rowHeight);
      removeCancelDragEventListener();
    }, _constants.DRAG_TRIGGER_TIME);

    if (!enableDragIcon()) {
      clearTimer();
    }

    addMultiSelectListener();
    document.addEventListener('mousemove', clearTimer);
    document.addEventListener('mouseup', clearTimer);
  }, [controller, table, zoomContainer, handlePreventDefault, getRowIndexByClientY, getDataSelectedIndexRange, selectRows, addMultiSelectListener, handleDragStart, removeMultiSelectListener, enableDragIcon]);

  const handleRowResizing = _react.default.useCallback(event => {
    if (!draggingRowResizer.current || !zoomContainer) {
      return;
    }

    event.preventDefault();
    const relativeEvent = (0, _everUtils.getRelativeMouseEvent)(event, zoomContainer);
    const rowToolbarItem = draggingRowResizer.current.parentElement;

    if (!rowToolbarItem) {
      return;
    }

    const rowToolbarItemRect = (0, _everUtils.getBoundingRelativeRect)(rowToolbarItem, zoomContainer);
    const validClientY = Math.max(rowToolbarItemRect.top + MIN_ROW_HEIGHT * scale, relativeEvent.relativeY);
    const delta = validClientY - startClientY.current;
    const top = `${Math.round(startPositionTop.current + delta / scale)}px`;
    const colResizer = ReactDOM.findDOMNode(rowResizerRef.current);

    if (!colResizer) {
      return;
    }

    colResizer.style.top = top;
    draggingRowResizer.current.style.top = top;
  }, [zoomContainer, scale]); // @ts-ignore


  const handleRowResizeEnd = _react.default.useCallback(() => {
    isResizingRowFlag.current = false;

    if (!draggingRowResizer.current || !startPositionTop.current) {
      return;
    }

    const delta = parseInt(draggingRowResizer.current.style.top, 10) - Math.round(startPositionTop.current);
    const resizingRowIndex = parseInt(draggingRowResizer.current.getAttribute('data-index'), 10);
    const resizingRowKey = table.nodes[resizingRowIndex].key; // @ts-ignore

    onRowResize(resizingRowKey, delta);
    draggingRowResizer.current.style.backgroundColor = '';
    draggingRowResizer.current.style.top = '';
    draggingRowResizer.current = null;
    startPositionTop.current = null;
    startClientY.current = null;
    document.body.style.cursor = originBodyCursor.current;
    originBodyCursor.current = '';
    const rowResizer = ReactDOM.findDOMNode(rowResizerRef.current);

    if (!rowResizer) {
      return null;
    }

    rowResizer.style.display = 'none';
    document.removeEventListener('mousemove', handleRowResizing);
    document.removeEventListener('mouseup', handleRowResizeEnd);
  }, [onRowResize, table, handleRowResizing]);

  const handleRowResizeStart = _react.default.useCallback(event => {
    if (!rowToolbarRef.current) return;
    isResizingRowFlag.current = true;
    event.preventDefault();
    event.stopPropagation();
    const relativeEvent = (0, _everUtils.getRelativeMouseEvent)(event, zoomContainer);
    startClientY.current = relativeEvent.relativeY;
    draggingRowResizer.current = event.target;
    const resizerRect = (0, _everUtils.getBoundingRelativeRect)(draggingRowResizer.current, rowToolbarRef.current);
    startPositionTop.current = (resizerRect.top + resizerRect.height / 2) / scale;
    draggingRowResizer.current.style.backgroundColor = 'transparent';
    originBodyCursor.current = document.body.style.cursor;
    document.body.style.setProperty('cursor', 'row-resize', 'important');
    const table = ReactDOM.findDOMNode(tableRef.current);
    const tableRect = (0, _everUtils.getBoundingRelativeRect)(table, zoomContainer);

    if (!realTableWrapperRef.current) {
      return;
    }

    const realTableWrapperRect = realTableWrapperRef.current.getBoundingClientRect(); // eslint-disable-next-line react/no-find-dom-node

    const rowResizer = ReactDOM.findDOMNode(rowResizerRef.current);
    rowResizer.style.display = 'block';
    rowResizer.style.top = `${startPositionTop.current}px`;
    const tableWidth = Math.min(tableRect.width, realTableWrapperRect.width);
    rowResizer.style.width = `${Math.round(tableWidth / scale)}px`;
    rowResizer.style.left = `${(TOOLBAR_ITEM_SIZE + _constants.HOVER_SHOW_INSERT_DELTA) / scale}px`;
    document.addEventListener('mousemove', handleRowResizing);
    document.addEventListener('mouseup', handleRowResizeEnd);
  }, [zoomContainer, scale, realTableWrapperRef, tableRef, handleRowResizing, handleRowResizeEnd]);

  const deleteRow = _react.default.useCallback(() => {
    controller.run('onAction', (0, _actions.deleteTableRows)(table));
  }, [table, controller]);

  const insertRow = _react.default.useCallback(() => {
    const rowsLength = table.nodes.length;
    const targetRow = table.nodes[Math.min(positionOfInsertButton, rowsLength - 1)];
    const type = positionOfInsertButton === rowsLength ? 'insert-row-below' : 'insert-row-above'; // 理论上 targetRow 一定存在，添加 log 定位问题

    if (!targetRow) {
      (0, _logger.logNPEInfo)(table, {
        type: `insertRow targetRow is undefined ${targetRow}`,
        positionOfInsertButton,
        rowsLength
      });
      return;
    }

    controller.run('onAction', (0, _actions.insertTableRow)(targetRow, type));
  }, [positionOfInsertButton, controller, table]);

  const highlightSelection = _react.default.useCallback(() => {
    setIsHighlightSelection(true);
    setIsHoverDelete(true);
  }, [setIsHighlightSelection]);

  const cancelHighlightSelection = _react.default.useCallback(() => {
    setIsHighlightSelection(false);
    setIsHoverDelete(false);
  }, [setIsHighlightSelection]);

  const handleMouseOver = _react.default.useCallback(e => {
    const targetDom = e.target || e.srcElement;
    const isInsideRowToolbar = targetDom ? rowToolbarRef.current?.contains(targetDom) || false : false;
    setCanInsertBtnShow(isInsideRowToolbar); // 通过mouseMove去模拟mouseOver，通过判断e.targte是否为目标dom的子元素或者自身即可

    if (isResizingRowFlag.current || isDragging || !rowToolbarRef.current || !isInsideRowToolbar) {
      return;
    }

    const {
      clientY
    } = e;
    const toolbarTop = rowToolbarRef.current.getBoundingClientRect().top;
    const relativeY = clientY - toolbarTop;
    let totalHeight = 0;
    const index = rowsHeight.findIndex(height => {
      if (relativeY >= totalHeight && relativeY <= totalHeight + height) {
        return true;
      }

      totalHeight += height;
      return false;
    });

    if (index === 0 && isRowHeader) {
      setHoverToolbarItemIndex(-1);
    } else {
      setHoverToolbarItemIndex(index);
    }
  }, [isDragging, rowsHeight, isRowHeader]);

  const [canInsertBtnShow, setCanInsertBtnShow] = _react.default.useState(true); // 这里通过mouseMove去动态感知全选按钮是否hover到，以此来确定是否需要展示插入行按钮


  _react.default.useEffect(() => {
    if (isSelected) {
      document.addEventListener('mousemove', handleMouseOver, true);
      return () => {
        document.removeEventListener('mousemove', handleMouseOver, true);
      };
    }

    return undefined;
  }, [handleMouseOver, isSelected]);

  const handleMouseOut = _react.default.useCallback(() => {
    if (isResizingRowFlag.current || isDragging) {
      return;
    }

    setHoverToolbarItemIndex(-1);
  }, [isDragging]);

  const handleMouseEnterIndicator = _react.default.useCallback(insertIndex => {
    setPositionOfInsertButton(insertIndex);
    showIndicatorVisible(insertIndex !== -1);
  }, [setPositionOfInsertButton, showIndicatorVisible]);

  const handleContextMenu = _react.default.useCallback(event => {
    handlePreventDefault(event);
    onContextMenu(event);
    setContextMenuVisible(true);
  }, [handlePreventDefault, onContextMenu, setContextMenuVisible]);

  const renderRowToolbarItems = _react.default.useMemo(() => {
    const rowsCount = table.nodes.length;
    const children = [];
    const isSelectWholeTable = controller.query('isSelectWholeTable', {
      node: table
    });
    const indexRange = getSelectedIndexRange();
    const deleteRange = isHoverDelete ? indexRange : null;
    const selectRanges = indexRange ? [indexRange] : [];

    if (isHoverCornerToolbar || isSelectWholeTable) {
      selectRanges.push({
        start: 0,
        end: rowsCount - 1
      });
    } else if (hoverSelection && hoverSelection.startRowIndex === hoverSelection.endRowIndex) {
      selectRanges.push({
        start: hoverSelection.startRowIndex,
        end: hoverSelection.endRowIndex
      });
    }

    const activeRange = selection ? {
      start: selection.startRowIndex,
      end: selection.endRowIndex
    } : null;

    const getInsertButtonIndicator = (i, isFirst) => {
      const indicatorStyle = {
        position: 'absolute',
        right: 8 / scale
      };

      if (isFirst) {
        indicatorStyle.top = 0;
        indicatorStyle.transform = 'translateY(-50%)';
      } else {
        indicatorStyle.bottom = 0;
        indicatorStyle.transform = 'translateY(50%)';
      }

      return /*#__PURE__*/_createElement(_insertButtonIndicator.default, {
        key: i,
        "data-index": i,
        scale: scale,
        onClick: insertRow,
        onMouseEnter: handleMouseEnterIndicator,
        style: indicatorStyle
      });
    };

    for (let i = 0; i < rowsCount; i += 1) {
      children.push( /*#__PURE__*/_createElement(_rowToolbarItem.default, {
        key: table.nodes[i].key,
        index: i,
        width: TOOLBAR_ITEM_SIZE,
        table: table,
        deleteRange: deleteRange,
        selectRanges: selectRanges,
        activeRange: activeRange,
        isSticky: isSticky,
        scale: scale,
        rowHeight: rowsHeight[i],
        onMouseOut: handleMouseOutRowToolbarItem,
        onMouseOver: handleMouseOverRowToolbarItem,
        onMouseDown: handleSelectRow,
        onContextMenu: handleContextMenu,
        onClick: handlePreventDefault
      }, i === 0 && !isRowHeader ? getInsertButtonIndicator(i, true) : null, getInsertButtonIndicator(i + 1), /*#__PURE__*/_createElement(RowToolbarResizer, {
        "data-index": i,
        onMouseDown: handleRowResizeStart,
        scale: scale,
        "data-testid": "table-row-toolbar-resizer"
      })));
    }

    return children;
  }, [table, controller, getSelectedIndexRange, isHoverDelete, isHoverCornerToolbar, hoverSelection, selection, scale, insertRow, handleMouseEnterIndicator, isSticky, rowsHeight, handleMouseOutRowToolbarItem, handleMouseOverRowToolbarItem, handleSelectRow, handleContextMenu, handlePreventDefault, isRowHeader, handleRowResizeStart]);

  const isShowButton = _react.default.useCallback(() => {
    return !contextMenuVisible && zoomContainer && getLastActiveTableKey() === table.key && selection;
  }, [contextMenuVisible, zoomContainer, getLastActiveTableKey, table.key, selection]); // 展示插入按钮时隐藏删除按钮


  const isShowDelete = _react.default.useCallback(() => {
    const selectedIndexRange = getSelectedIndexRange();
    return Boolean(isShowButton() && selectedIndexRange && positionOfInsertButton === -1 && !isDragging && !isHideDeleteButton);
  }, [getSelectedIndexRange, isShowButton, positionOfInsertButton, isDragging, isHideDeleteButton]);

  const preTableRef = _react.default.useRef(); // 缓存行高变化，由于表格的行高是基于table和controller进行计算，因此只需要在table和controller更新时判断是否需要更新缓存即可
  // 由于行高信息取决于table-row节点的data属性和table-cell节点的data属性，因此只需要判断当前table.nodes跟上次的table.nodes是否相同即可


  _react.default.useLayoutEffect(() => {
    if (!isSelected && !isHoverCornerToolbar) return;

    _fastdom.default.measure(() => {
      if (!(0, _fastDeepEqual.default)(preTableRef.current, table.nodes)) {
        preTableRef.current = table.nodes;
        rowsRect.current = (0, _getAllRowsDomRect.default)(controller, {
          node: table
        });
      }
    });
  }, [controller, table, table.nodes, isSelected, isHoverCornerToolbar]);

  const colsWidthRef = _react.default.useRef(table.data.colsWidth);

  const scaleRef = _react.default.useRef(scale); // scale 变化的时候也需要重新计算行高信息


  _react.default.useLayoutEffect(() => {
    if (!isSelected) return;

    _fastdom.default.measure(() => {
      if (scaleRef.current !== scale || !(0, _fastDeepEqual.default)(colsWidth, colsWidthRef.current)) {
        rowsRect.current = (0, _getAllRowsDomRect.default)(controller, {
          node: table
        });
        scaleRef.current = scale;
        colsWidthRef.current = colsWidth;
      }
    }); // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [scale, colsWidth, isSelected]);

  (0, _react.useLayoutEffect)(() => {
    if (!isSelected) return;

    _fastdom.default.measure(() => {
      updateToolbarStyle();
      updateDeleteButtonStyle();
    });
  }, [updateDeleteButtonStyle, updateToolbarStyle, isSelected]);
  (0, _react.useEffect)(() => {
    document.addEventListener('mousemove', handleMouseMove);
    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
    };
  }, [handleMouseMove]); // componentWillUnmount

  (0, _react.useEffect)(() => {
    return () => {
      document.removeEventListener('mousemove', handleRowResizing);
      document.removeEventListener('mouseup', handleRowResizeEnd);
      removeMultiSelectListener();
      removeDragEventListener();
      detachObserver(); // 移除监听
    };
  }, []);
  (0, _react.useEffect)(() => {
    if (contextMenuVisible) {
      document.addEventListener('mousedown', hideContextMenu);
      return () => {
        document.removeEventListener('mousedown', hideContextMenu);
      };
    }

    return undefined;
  }, [contextMenuVisible, hideContextMenu]);

  const onHotsNextFrame = _react.default.useCallback(hots => {
    // PERF: 非当前表格热区不处理
    if (hots.some(hot => table.key === hot.node.key || table.hasNode(hot.node.key))) {
      rowsRect.current = (0, _getAllRowsDomRect.default)(controller, {
        node: table
      });
    }
  }, [controller, table]);

  (0, _everCangjie.useHotsAtTheStartOfNextFrame)(controller, onHotsNextFrame);
  const tableWidth = colsWidth.reduce((sum, width) => sum + width, 0); // 表格全选按钮和insertBtn不能并存

  const isShowInsertButton = !isDragging && positionOfInsertButton !== -1 && canInsertBtnShow;
  const isRowInlineToolbarShow = Boolean(isShowButton() && isShowInsertButton);

  if (!isRowInlineToolbarShow) {
    showIndicatorVisible(false);
  }

  const style = {
    display: isSelected ? 'block' : 'none',
    paddingTop: isSticky ? rowsHeight[0] + 1 : 0
  };
  return /*#__PURE__*/_createElement(RowToolbarWrapper, {
    style: style,
    role: "toolbar",
    "data-testid": "table-row-toolbar",
    scale: scale,
    ref: rowToolbarRef,
    onMouseOut: handleMouseOut
  }, renderRowToolbarItems, /*#__PURE__*/_createElement(_styled.RowResizer, {
    ref: rowResizerRef
  }), /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/_createElement(RowInlineToolbar, {
    isShow: isShowDelete(),
    ref: deleteButtonRef,
    "data-testid": "table-row-inline-toolbar"
  }, /*#__PURE__*/_createElement(_inlineToolbarDeleteButton.default, {
    scale: scale,
    mode: "row",
    locale: locale,
    onDelete: deleteRow,
    onHighlightSelection: highlightSelection,
    onCancelHighlightSelection: cancelHighlightSelection
  })), zoomContainer), /*#__PURE__*/_createElement(RowInlineToolbar, {
    ref: insertButtonRef,
    "data-testid": "table-row-inline-toolbar-insert",
    isShow: isRowInlineToolbarShow,
    onMouseMove: handlePreventDefault
  }, /*#__PURE__*/_createElement(_inlineToolbarInsertButton.default, {
    locale: locale,
    table: table,
    rowIndicatorRef: rowIndicatorRef,
    selection: selection,
    mode: "row",
    tableRef: tableRef,
    scale: scale,
    onInsert: insertRow,
    zoomContainer: zoomContainer,
    insertIndex: positionOfInsertButton,
    onShowIndicatorVisible: showIndicatorVisible
  })), zoomContainer && /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/_createElement(_dragElement.default, {
    ref: dragElementRef,
    visible: isDragging,
    height: draggingRowHeight,
    width: tableWidth + TOOLBAR_ITEM_SIZE
  }), zoomContainer));
};

var _default = (0, _createToolbarWithTableSelection.default)(TableRowToolbar);

exports.default = _default;
//# sourceMappingURL=index.js.map