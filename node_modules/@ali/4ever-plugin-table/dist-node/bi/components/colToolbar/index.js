"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var React = _interopRequireWildcard(require("react"));

var ReactDOM = _interopRequireWildcard(require("react-dom"));

var _styledComponents = _interopRequireDefault(require("styled-components"));

var _lodash = require("lodash");

var _fastdom = _interopRequireDefault(require("fastdom"));

var _everCangjie = require("@ali/4ever-cangjie");

var _models = _interopRequireDefault(require("../../../mo/models"));

var _everUtils = require("@ali/4ever-utils");

var _constants = require("../../constants");

var _tableColToolbarItem = require("./tableColToolbarItem");

var _styled = require("../styled");

var _actions = require("../../actions");

var _inlineToolbarInsertButton = _interopRequireDefault(require("../inlineToolbarButtons/inlineToolbarInsertButton"));

var _inlineToolbarDeleteButton = _interopRequireDefault(require("../inlineToolbarButtons/inlineToolbarDeleteButton"));

var _insertButtonIndicator = _interopRequireWildcard(require("../inlineToolbarButtons/insertButtonIndicator"));

var _dragElement = _interopRequireDefault(require("../colToolbar/dragElement"));

var _scrollContainer = require("../../utils/scrollContainer");

var _createToolbarWithTableSelection = _interopRequireDefault(require("../createToolbarWithTableSelection"));

var _getDataTableSelectionByTable = _interopRequireDefault(require("../../utils/getDataTableSelectionByTable"));

var _constants2 = require("../../../utils/constants");

var hooks = _interopRequireWildcard(require("../../../utils/hooks"));

/* eslint-disable @typescript-eslint/no-shadow */

/* eslint-disable max-lines */

/* eslint-disable react/no-find-dom-node */
const _createElement = /*#__PURE__*/React.createElement;
const {
  usePixelColsWidth,
  useRowIsSticky,
  useScrollableContainerRect,
  useTableScrollContainerWidth,
  useTableScrollContainerScrollLeft
} = hooks;
const fallbackRect = {
  left: -1,
  top: -1,
  right: -1,
  bottom: -1,
  height: -1,
  width: -1
};

const Wrapper = /*#__PURE__*/_styledComponents.default.div(["visibility:hidden;pointer-events:none;&[data-sticky=\"true\"]{position:fixed;height:", "px;overflow:hidden;z-index:", ";[data-testid=\"table-col-toolbar\"]{position:absolute;bottom:0;}}"], _constants2.STICKY_ROW_TOP_HEIGHT, _constants2.STICKY_TOOLBAR_INDEX_MAP.colToolbar);

const ColToolbarWrapper = /*#__PURE__*/_styledComponents.default.div(["position:relative;z-index:3;"]);

const ColToolbarResizer = /*#__PURE__*/_styledComponents.default.div(["position:absolute;top:0;width:7px;height:", "px;margin-left:-3px;background-color:transparent;z-index:1;cursor:col-resize;&:hover{background-color:", ";}"], props => _constants.TOOLBAR_ITEM_SIZE / props.scale, _constants.THEME.blue3);

const ColInlineToolbar = /*#__PURE__*/_styledComponents.default.div(["position:absolute;z-index:101;transition:opacity ease-in-out 0.25s;"]);

function TableColToolbar(props) {
  const {
    table,
    controller,
    tableRef,
    positionedAncestorRef,
    scrollContainer,
    zoomContainer,
    colIndicatorRef,
    isTableSelected,
    selection,
    scale,
    locale,
    isHideDeleteButton,
    isHoverCornerToolbar,
    getLastActiveTableKey,
    onContextMenu,
    onSelect,
    onColResize,
    onGetAllColsNodes,
    setIsHighlightSelection,
    hoverSelection,
    setHoverSelection
  } = props;
  const [colsWidth] = usePixelColsWidth();
  const [isSticky] = useRowIsSticky();

  const isColumnHeader = _models.default.isColumnHeader(table);

  const [contextMenuVisible, setContextMenuVisible] = React.useState(false);
  const [positionOfInsertButton, setPositionOfInsertButton] = React.useState(-1);
  const [isHoverDelete, setIsHoverDelete] = React.useState(false);
  const [resizingColData, setResizingColData] = React.useState({
    colIndex: -1,
    left: 0,
    top: 0,
    colResizerHeight: 0
  });
  const [hoverToolbarItemIndex, setHoverToolbarItemIndex] = React.useState(-1);
  const [isDragging, setIsDragging] = React.useState(false);
  const [draggingColWidth, setDraggingColWidth] = React.useState(0);
  const colToolbarRef = React.useRef(null);
  const toolbarWrapperRef = React.useRef(null);
  const resizingColDataRef = React.useRef({
    colIndex: -1,
    left: 0,
    top: 0,
    colResizerHeight: 0
  });
  const colSelectionRectRef = React.useRef(null);
  const insetBtnPosRef = React.useRef(-1);
  const draggingColResizerRef = React.useRef(null);
  const startClientXRef = React.useRef(null);
  const startPositionLeftRef = React.useRef(0);
  const originBodyCursorRef = React.useRef('');
  const deleteButtonRef = React.useRef(null);
  const insertButtonRef = React.useRef(null);
  const colsNodes = React.useRef([]);
  const deleteButtonLeftRef = React.useRef(-1);
  const dragElementRef = React.useRef(null);
  const startSelectIndexRef = React.useRef(-1);
  const getAllColsNodes = React.useCallback(() => {
    return colsNodes.current;
  }, []);
  const getColsRects = React.useCallback(() => {
    return getAllColsNodes().map(node => {
      const rect = node.getBoundingClientRect();
      return rect || fallbackRect;
    });
  }, [getAllColsNodes]);
  const isSelectWholeCol = React.useCallback(() => {
    return controller.query('isSelectWholeCol', {
      node: table
    });
  }, [controller, table]);
  const getColItemRect = React.useCallback(index => {
    const thisNode = ReactDOM.findDOMNode(colToolbarRef.current);
    const colNode = thisNode.children[index * 2];

    if (!colNode) {
      return null;
    }

    const colRect = (0, _everUtils.getBoundingRelativeRect)(colNode, zoomContainer);
    return colRect;
  }, [zoomContainer]);
  const getSelectedIndexRange = React.useCallback(() => {
    if (!selection) {
      return null;
    }

    const tableSelection = (0, _getDataTableSelectionByTable.default)(controller, table);

    if (!tableSelection) {
      return null;
    }

    const isSelectWholeTable = controller.query('isSelectWholeTable', {
      node: table
    });

    if (isSelectWholeTable) {
      return null;
    }

    const {
      startColIndex,
      endColIndex
    } = tableSelection;

    if (!table.nodes) {
      return null;
    }

    if (isSelectWholeCol()) {
      return {
        start: startColIndex,
        end: endColIndex
      };
    }

    return null;
  }, [controller, table, selection, isSelectWholeCol]);
  const getSortedSelectedRange = React.useCallback(r => {
    const selectedIndexRange = getSelectedIndexRange();
    const range = r || selectedIndexRange;

    if (!range) {
      return null;
    }

    const {
      start,
      end
    } = range;
    const min = Math.min(start, end);
    const max = Math.max(start, end);
    return {
      min,
      max
    };
  }, [getSelectedIndexRange]);
  const getColToolbarTop = React.useCallback(() => {
    if (!selection) {
      return null;
    }

    const thisNode = ReactDOM.findDOMNode(colToolbarRef.current);
    const thisRect = (0, _everUtils.getBoundingRelativeRect)(thisNode, zoomContainer);
    return {
      top: thisRect.top
    };
  }, [selection, zoomContainer]);
  const shouldHideButton = React.useCallback(relativeLeft => {
    const thisNode = ReactDOM.findDOMNode(colToolbarRef.current);

    if (!thisNode || !scrollContainer.current) {
      return undefined;
    }

    const tableRect = (0, _everUtils.getBoundingRelativeRect)(scrollContainer.current, zoomContainer);
    return relativeLeft < -26 || relativeLeft - tableRect.right > 0;
  }, [zoomContainer, scrollContainer]);
  const calcColsWidth = React.useCallback((startIndex, endIndex) => {
    if (!Array.isArray(colsWidth)) {
      return 0;
    }

    if (endIndex < startIndex) return 0;
    return colsWidth.slice(startIndex, endIndex + 1).reduce((acc, w) => {
      return acc + w;
    }, 0);
  }, [colsWidth]); // @ts-ignore

  const updateInsertButtonStyle = React.useCallback(() => {
    if (!selection || positionOfInsertButton === -1 || !toolbarWrapperRef.current || positionOfInsertButton === -1 || !Array.isArray(colsWidth)) {
      return;
    }

    let relativeLeft = -1;
    const toolbarRect = (0, _everUtils.getBoundingRelativeRect)(toolbarWrapperRef.current, zoomContainer);
    const insertButtonNode = ReactDOM.findDOMNode(insertButtonRef.current);

    if (!insertButtonNode) {
      return;
    }

    const insertButtonRect = (0, _everUtils.getBoundingRelativeRect)(insertButtonNode, zoomContainer);
    relativeLeft = calcColsWidth(0, positionOfInsertButton - 1) + toolbarRect.left;
    relativeLeft -= insertButtonRect.width / 2;
    const result = getColToolbarTop();
    if (!result) return null;
    const {
      top
    } = result;
    const insertButtonLeft = relativeLeft / scale + 1; // 1px作为修正值

    const curTop = Math.abs(top / scale - insertButtonNode.offsetHeight - _constants.DISTANCE_BETWEEN_INSERT_BUTTON_AND_TOOLBAR);
    insertButtonNode.style.top = `${curTop}px`;
    insertButtonNode.style.left = `${insertButtonLeft}px`;
    const shouldHide = shouldHideButton(relativeLeft);

    if (shouldHide) {
      insertButtonNode.style.visibility = 'hidden';
    } else {
      insertButtonNode.style.visibility = 'visible';
    }
  }, [selection, positionOfInsertButton, colsWidth, zoomContainer, calcColsWidth, getColToolbarTop, scale, shouldHideButton]);
  const setRectStyle = React.useCallback((node, startIndex, endIndex, bgColor, borderColr) => {
    if (!Array.isArray(colsWidth)) {
      return;
    }

    const left = calcColsWidth(0, startIndex - 1);
    node.style.left = `${left}px`;
    const width = calcColsWidth(startIndex, endIndex);
    node.style.border = `1px solid ${borderColr}`;
    node.style.borderBottom = 'unset';

    if (endIndex === colsWidth.length - 1) {
      node.style.borderTopRightRadius = '3px';
    } else {
      node.style.borderTopRightRadius = 'unset';
    }

    node.style.width = `${width + 1}px`;

    if (bgColor) {
      node.style.backgroundColor = bgColor;
    }
  }, [colsWidth, calcColsWidth]);
  const updateColSelectionRectStyle = React.useCallback(() => {
    const selectedIndexRange = getSelectedIndexRange();

    if (!selection || !table.data.colsWidth || isHoverCornerToolbar) {
      return;
    }

    const {
      startColIndex,
      endColIndex
    } = selection;
    const colSelectionNode = ReactDOM.findDOMNode(colSelectionRectRef.current);

    if (!colSelectionNode) {
      return;
    } // 全选表格的时候工具栏背景色也需要变化


    const isSelectWholeTable = controller.query('isSelectWholeTable', {
      node: table
    });

    if (selectedIndexRange || isSelectWholeTable) {
      const bgColor = isHoverDelete ? _constants.THEME.red1 : _constants.THEME.blue1;
      const borderColor = isHoverDelete ? _constants.THEME.red1 : _constants.THEME.blue3;
      setRectStyle(colSelectionNode, startColIndex, endColIndex, bgColor, borderColor);
    } else {
      setRectStyle(colSelectionNode, startColIndex, endColIndex, _constants.THEME.toolbarBgColor.hover, _constants.THEME.toolbarBorderColor);
    }
  }, [getSelectedIndexRange, selection, table, controller, isHoverDelete, setRectStyle, isHoverCornerToolbar]); // hover到汉堡的时候高亮工具栏

  const setItemsRectStyleByRange = React.useCallback((startColIndex, endColIndex, bgColor, borderColor) => {
    const colSelectionNode = ReactDOM.findDOMNode(colSelectionRectRef.current);

    if (!colSelectionNode) {
      return;
    }

    setRectStyle(colSelectionNode, startColIndex, endColIndex, bgColor, borderColor);
  }, [setRectStyle]);
  React.useEffect(() => {
    const colsCount = table.data?.colsWidth?.length;
    if (!colsCount) return;

    if (isHoverCornerToolbar) {
      setItemsRectStyleByRange(0, colsCount - 1, _constants.THEME.blue1, _constants.THEME.blue3);
    } else {
      if (!selection || !table.data.colsWidth) {
        setItemsRectStyleByRange(0, colsCount - 1, _constants.THEME.toolbarBgColor.default, _constants.THEME.toolbarBorderColor);
        return;
      }

      updateColSelectionRectStyle();
    }
  }, [setItemsRectStyleByRange, updateColSelectionRectStyle, selection, table.data?.colsWidth?.length, isHoverCornerToolbar, table, controller]);
  const updateIndicatorStyle = React.useCallback(() => {
    if (!colIndicatorRef.current || !selection || positionOfInsertButton === -1 || !tableRef.current || !positionedAncestorRef.current || !toolbarWrapperRef.current) {
      return;
    }

    const trueTableDOM = tableRef.current;
    const trueTableRect = (0, _everUtils.getBoundingRelativeRect)(trueTableDOM, positionedAncestorRef.current);
    const toolbarRect = (0, _everUtils.getBoundingRelativeRect)(toolbarWrapperRef.current, positionedAncestorRef.current);
    const left = positionOfInsertButton === 0 ? 0 : calcColsWidth(0, positionOfInsertButton - 1);
    const height = trueTableRect.bottom - toolbarRect.top;
    colIndicatorRef.current.style.left = `${Math.round(left / scale)}px`;
    colIndicatorRef.current.style.bottom = `${Math.round(_constants2.SCROLL_BAR_HEIGHT / scale)}px`;
    colIndicatorRef.current.style.height = `${height / scale}px`;
  }, [colIndicatorRef, selection, positionOfInsertButton, tableRef, positionedAncestorRef, calcColsWidth, scale]);
  const handleColResizing = React.useCallback(event => {
    if (!draggingColResizerRef.current) return;
    event.preventDefault();
    const relativeEvent = (0, _everUtils.getRelativeMouseEvent)(event, zoomContainer);
    const colToolbarItem = draggingColResizerRef.current.previousElementSibling;
    const colToolbarNextItem = draggingColResizerRef.current.nextElementSibling;
    if (!colToolbarItem || !colToolbarNextItem) return;
    const colToolbarItemRect = (0, _everUtils.getBoundingRelativeRect)(colToolbarItem, zoomContainer);
    let validClientX = Math.max(colToolbarItemRect.left + _constants.MIN_COL_WIDTH * scale, relativeEvent.relativeX);

    if (colToolbarNextItem && colToolbarNextItem.getAttribute('data-index') !== null) {
      const colToolbarNextItemRect = (0, _everUtils.getBoundingRelativeRect)(colToolbarNextItem, zoomContainer);
      validClientX = Math.min(colToolbarNextItemRect.left + colToolbarNextItemRect.width - _constants.MIN_COL_WIDTH * scale, validClientX);
    }

    const startClientX = startClientXRef.current;

    if (startClientX == null) {
      return;
    }

    const delta = validClientX - startClientX;
    const left = startPositionLeftRef.current + Math.round(delta / scale);
    setResizingColData({ ...resizingColDataRef.current,
      left
    });
  }, [zoomContainer, scale]);
  const hideContextMenu = React.useCallback(() => {
    setContextMenuVisible(false);
    document.removeEventListener('mousedown', hideContextMenu);
  }, []);
  const handleColResizeEnd = React.useCallback(() => {
    // Fix to https://work.aone.alibaba-inc.com/issue/38856463. draggingColResizerRef.current会存在为null的情况
    // 暂时不好定位具体原因，先做兜底处理
    if (!draggingColResizerRef.current) {
      document.removeEventListener('mousedown', hideContextMenu);
      document.removeEventListener('mousemove', handleColResizing);
      document.removeEventListener('mouseup', handleColResizeEnd);
      return;
    }

    const delta = parseInt(draggingColResizerRef.current.style.left, 10) - startPositionLeftRef.current;
    const resizingColIndex = parseInt(draggingColResizerRef.current.getAttribute('data-index'), 10);
    onColResize(resizingColIndex, delta);
    draggingColResizerRef.current.style.backgroundColor = '';
    draggingColResizerRef.current = null;
    startClientXRef.current = null;
    startPositionLeftRef.current = 0;
    document.body.style.cursor = originBodyCursorRef.current;
    originBodyCursorRef.current = '';
    setResizingColData({ ...resizingColData,
      colIndex: -1
    });
    document.removeEventListener('mousedown', hideContextMenu);
    document.removeEventListener('mousemove', handleColResizing);
    document.removeEventListener('mouseup', handleColResizeEnd);
  }, [onColResize, resizingColData, hideContextMenu, handleColResizing]);
  const handleColResizeStart = React.useCallback(event => {
    // NOTE: 不阻止冒泡，以便触发上层清空表格选区逻辑
    event.preventDefault();
    const relativeEvent = (0, _everUtils.getRelativeMouseEvent)(event, zoomContainer);
    startClientXRef.current = relativeEvent.relativeX;
    draggingColResizerRef.current = event.target;
    const resizingColIndex = parseInt(draggingColResizerRef.current.getAttribute('data-index'), 10);
    const left = parseInt(draggingColResizerRef.current.style.left, 10);
    draggingColResizerRef.current.style.backgroundColor = 'transparent';
    originBodyCursorRef.current = document.body.style.cursor;
    document.body.style.setProperty('cursor', 'col-resize', 'important');
    const table = ReactDOM.findDOMNode(tableRef.current);
    const tableRect = (0, _everUtils.getBoundingRelativeRect)(table, zoomContainer);
    const top = _constants2.REALTABLE_PADDING.top / scale;
    startPositionLeftRef.current = left;
    resizingColDataRef.current = {
      colIndex: resizingColIndex,
      left,
      top,
      colResizerHeight: (tableRect.height + _constants.TOOLBAR_ITEM_SIZE - _constants2.REALTABLE_PADDING.top) / scale
    };
    setResizingColData({
      colIndex: resizingColIndex,
      left,
      top,
      colResizerHeight: (tableRect.height + _constants.TOOLBAR_ITEM_SIZE - _constants2.REALTABLE_PADDING.top) / scale
    });
    document.addEventListener('mousemove', handleColResizing);
    document.addEventListener('mouseup', handleColResizeEnd);
  }, [handleColResizing, handleColResizeEnd, scale, tableRef, zoomContainer]);
  const handlePreventDefault = React.useCallback(event => {
    event.preventDefault();
    event.stopPropagation();
  }, []);
  const handleContextMenu = React.useCallback(event => {
    handlePreventDefault(event);
    onContextMenu(event);
    setContextMenuVisible(true);
  }, [onContextMenu, handlePreventDefault]);
  const isResizingCol = React.useCallback(() => {
    return resizingColData && resizingColData.colIndex !== -1;
  }, [resizingColData]);
  const handleMouseEnterColToolbarItem = React.useCallback(event => {
    const index = parseInt(event.target.getAttribute('data-index'), 10);
    if (isNaN(index)) return; // hover对样式的影响优先级低于选中状态

    const tableRows = table.nodes.length;

    if (tableRows) {
      // 构造hover选区
      const hoverSelection = {
        key: table.key,
        startColIndex: index,
        endColIndex: index,
        startRowIndex: 0,
        endRowIndex: tableRows - 1
      };
      setHoverSelection(hoverSelection);
    }
  }, [setHoverSelection, table.key, table.nodes.length]);
  const handleMouseOutColToolbarItem = React.useCallback(() => {
    setHoverSelection(null);
  }, [setHoverSelection]);
  const handleMouseOver = React.useCallback(e => {
    if (isDragging || isResizingCol() || !scrollContainer.current) {
      return;
    }

    const {
      clientX
    } = e;
    const scrollRect = scrollContainer.current.getBoundingClientRect();
    const horizontalPadding = 10;

    if (clientX < scrollRect.left - horizontalPadding || clientX > scrollRect.right + horizontalPadding) {
      return;
    }

    const colsRect = getColsRects();
    const index = colsRect.findIndex(rect => {
      // node.getBoundingClientRect() 可能是 undefined？
      // 这里比较奇怪，就算 node 从 DOM 中卸载，也会返回 DOMRect 只是数据都是 0
      // 先兼容
      if (!rect) {
        return false;
      }

      return clientX >= rect.left && clientX <= rect.right;
    });
    setHoverToolbarItemIndex(index);
  }, [isDragging, isResizingCol, scrollContainer, getColsRects]);
  const handleMouseOut = React.useCallback(e => {
    const insertButton = insertButtonRef.current;

    if (insertButton && insertButton.contains(e.target)) {
      return;
    }

    if (isDragging || isResizingCol()) {
      return;
    }

    setHoverToolbarItemIndex(-1);
  }, [isDragging, isResizingCol]);
  const selectCols = React.useCallback((start, end, shouldHideContextMenu = true) => {
    if (start === end) {
      startSelectIndexRef.current = start;
    }

    onSelect({
      start,
      end
    }, shouldHideContextMenu);
  }, [onSelect]);
  const shouldEnableEndDrag = React.useCallback((insertIndex, colsLength) => {
    if (insertIndex === 0 && isColumnHeader) {
      return false;
    }

    if (insertIndex > 0 && insertIndex < colsLength) {
      const maxRowIndex = table.nodes.length - 1;
      const leftColSelection = {
        startRowIndex: 0,
        endRowIndex: maxRowIndex,
        startColIndex: 0,
        endColIndex: insertIndex - 1,
        key: table.key
      };
      return controller.query('isAllSelectedCellsComplete', {
        node: table,
        tableSelection: leftColSelection
      });
    }

    return true;
  }, [table, controller, isColumnHeader]);
  const handleMultiSelectCol = React.useCallback((0, _lodash.throttle)(event => {
    if (isDragging) {
      return;
    }

    const {
      buttons
    } = event;
    const selectedIndexRange = getSelectedIndexRange();

    if (buttons !== 1 || !colToolbarRef.current || !selectedIndexRange) {
      removeMultiSelectListener();
      return;
    }

    const colsNodes = getAllColsNodes();
    const {
      left: colToolbarX
    } = colToolbarRef.current.getBoundingClientRect();
    const offsetX = event.clientX - colToolbarX;
    let endSelectedIndex = colsNodes.length - 1;
    let acc = 0;

    for (let i = 0; i < colsNodes.length; i += 1) {
      acc += colsNodes[i].getBoundingClientRect().width;

      if (acc > offsetX) {
        endSelectedIndex = i;
        break;
      }
    }

    selectCols(startSelectIndexRef.current, endSelectedIndex);
  }, 100), [isDragging, getSelectedIndexRange, selectCols]);
  const removeMultiSelectListener = React.useCallback(() => {
    document.removeEventListener('mousemove', handleMultiSelectCol);
    document.removeEventListener('mouseup', removeMultiSelectListener);
  }, [handleMultiSelectCol]);
  const showIndicatorVisible = React.useCallback(isVisible => {
    if (!colIndicatorRef.current) {
      return;
    }

    const opacity = isVisible ? '1' : '0';
    colIndicatorRef.current.style.opacity = opacity;
  }, [colIndicatorRef]);
  const setInsertButtonPos = React.useCallback(index => {
    let i = index;

    if (i === 0 && isColumnHeader) {
      i = -1;
    }

    setPositionOfInsertButton(i);
    showIndicatorVisible(i !== -1);
    insetBtnPosRef.current = i;
  }, [isColumnHeader, showIndicatorVisible]);
  const addMultiSelectListener = React.useCallback(() => {
    document.addEventListener('mousemove', handleMultiSelectCol);
    document.addEventListener('mouseup', removeMultiSelectListener);
  }, [handleMultiSelectCol, removeMultiSelectListener]);
  const moveColToIndex = React.useCallback((originIndexRange, targetIndex) => {
    const {
      min,
      max
    } = getSortedSelectedRange(originIndexRange);
    controller.run('onAction', (0, _actions.moveTableCols)(table, {
      start: min,
      end: max
    }, targetIndex));
    const startIndex = min < targetIndex ? targetIndex - (max - min + 1) : targetIndex;
    selectCols(startIndex, startIndex + max - min);
  }, [getSortedSelectedRange, controller, selectCols, table]);
  const updateDragElementPosition = React.useCallback((x, y) => {
    if (!dragElementRef.current) {
      return;
    }

    dragElementRef.current.style.left = `${x / scale}px`;
    dragElementRef.current.style.top = `${y / scale}px`;
  }, [scale]);
  const isShowColToolbar = React.useCallback(() => {
    const selectedIndexRange = getSelectedIndexRange();
    return !!selectedIndexRange;
  }, [getSelectedIndexRange]);
  const updateDraggingStyle = React.useCallback(relativeEvent => {
    const {
      clientX,
      clientY,
      relativeX,
      relativeY
    } = relativeEvent;

    const tableDOM = _everCangjie.domUtils.findDOMNode(table.key);

    if (!tableDOM) {
      return;
    }

    updateDragElementPosition(relativeX, relativeY);
    const tableRect = tableDOM.getBoundingClientRect();

    if (clientX < tableRect.left - _constants.TOOLBAR_ITEM_SIZE || clientX > tableRect.right || clientY < tableRect.top - _constants.TOOLBAR_ITEM_SIZE || clientY > tableRect.bottom) {
      setInsertButtonPos(-1);
      return;
    }

    const colsRects = getColsRects();
    let insertIndex = -1;

    for (let i = 0; i < colsRects.length; i++) {
      const colRect = colsRects[i];

      if (clientX >= colRect.left && clientX <= colRect.left + colRect.width / 2) {
        insertIndex = i;
        break;
      }

      if (clientX > colRect.left + colRect.width / 2 && clientX < colRect.right) {
        insertIndex = i + 1;
        break;
      }
    }

    const sortRange = getSortedSelectedRange();

    if (!sortRange || insertIndex >= sortRange.min && insertIndex <= sortRange.max + 1) {
      insertIndex = -1;
    }

    const shouldDragEnd = shouldEnableEndDrag(insertIndex, colsRects.length);

    if (!shouldDragEnd) {
      insertIndex = -1;
    }

    setInsertButtonPos(insertIndex);
  }, [table.key, updateDragElementPosition, getColsRects, getSortedSelectedRange, setInsertButtonPos, shouldEnableEndDrag]);
  const handleDragEnd = React.useCallback(() => {
    setIsDragging(false);
    document.removeEventListener('mouseup', handleDragEnd);

    if (insetBtnPosRef.current === -1) {
      return;
    }

    const selectedIndexRange = getSelectedIndexRange();
    moveColToIndex(selectedIndexRange, insetBtnPosRef.current);
    setInsertButtonPos(-1);
  }, [getSelectedIndexRange, moveColToIndex, setInsertButtonPos]);
  const handleDragging = React.useCallback(event => {
    const tableDOM = _everCangjie.domUtils.findDOMNodeSafely(table.key);

    if (!tableDOM || event.buttons !== 1) {
      handleDragEnd();
      document.removeEventListener('mousemove', handleDragging);
      return;
    }

    event.stopPropagation();
    const relativeEvent = (0, _everUtils.getRelativeMouseEvent)(event, zoomContainer);
    updateDraggingStyle(relativeEvent);
    (0, _scrollContainer.scrollHorizontal)(event.clientX, scrollContainer.current);
  }, [table.key, zoomContainer, updateDraggingStyle, handleDragEnd, scrollContainer]);
  const handleDragStart = React.useCallback(relativeEvent => {
    const selectedIndexRange = getSelectedIndexRange();
    const selectedIndex = selectedIndexRange.start;
    setIsDragging(true);
    setDraggingColWidth(colsWidth[selectedIndex]);
    updateDraggingStyle(relativeEvent);
    document.addEventListener('mousemove', handleDragging);
    document.addEventListener('mouseup', handleDragEnd);
  }, [colsWidth, setIsDragging, setDraggingColWidth, updateDraggingStyle, handleDragging, getSelectedIndexRange, handleDragEnd]);
  const enableDragIcon = React.useCallback(() => {
    const range = getSortedSelectedRange(); // 表头列禁止拖拽

    if (isColumnHeader && range?.min === 0) return false;
    return Boolean(range && hoverToolbarItemIndex >= range.min && hoverToolbarItemIndex <= range.max);
  }, [getSortedSelectedRange, hoverToolbarItemIndex, isColumnHeader]);
  const handleSelectCol = React.useCallback(event => {
    handlePreventDefault(event);
    const selectedIndexRange = getSelectedIndexRange();
    controller.run('onAction', (0, _actions.clickTableToolbar)(table, 'col', event.target));
    const index = parseInt(event.target.getAttribute('data-index'), 10);

    if (event.shiftKey && selectedIndexRange && startSelectIndexRef.current !== index) {
      selectCols(startSelectIndexRef.current, index);
      return;
    }

    const sortRange = getSortedSelectedRange();

    if (!sortRange || index > sortRange.max || index < sortRange.min) {
      selectCols(index, index);
      addMultiSelectListener();
      return;
    }

    const relativeEvent = (0, _everUtils.getRelativeMouseEvent)(event, zoomContainer);
    let timer;
    const isRightClick = event.buttons === 2;

    const clearTimer = () => {
      clearTimeout(timer);
      selectCols(index, index, !isRightClick);
      removeCancelDragEventListener();
    };

    const removeCancelDragEventListener = () => {
      document.removeEventListener('mousemove', clearTimer);
      document.removeEventListener('mouseup', clearTimer);
    };

    timer = window.setTimeout(() => {
      removeMultiSelectListener();
      removeCancelDragEventListener();
      handleDragStart(relativeEvent);
    }, _constants.DRAG_TRIGGER_TIME);

    if (!enableDragIcon()) {
      clearTimer();
    }

    addMultiSelectListener();
    document.addEventListener('mousemove', clearTimer);
    document.addEventListener('mouseup', clearTimer);
  }, [handlePreventDefault, getSelectedIndexRange, controller, table, getSortedSelectedRange, enableDragIcon, zoomContainer, addMultiSelectListener, selectCols, removeMultiSelectListener, handleDragStart]);
  const removeDragEventListener = React.useCallback(() => {
    document.removeEventListener('mousemove', handleDragging);
    document.removeEventListener('mouseup', handleDragEnd);
  }, [handleDragging, handleDragEnd]);
  const handleColRectUpdate = React.useCallback((index, colNode, isDelete = false) => {
    if (isDelete) {
      colsNodes.current = colsNodes.current.splice(index, 1);
    } else {
      colsNodes.current[index] = colNode;
    }

    onGetAllColsNodes(getAllColsNodes());
  }, [onGetAllColsNodes, getAllColsNodes]);
  const insertCol = React.useCallback(() => {
    const {
      colsWidth
    } = table.data;

    if (!Array.isArray(colsWidth)) {
      return;
    }

    if (positionOfInsertButton === -1) {
      return;
    }

    const colWidth = colsWidth[Math.min(positionOfInsertButton, colsWidth.length - 1)];
    controller.run('onAction', (0, _actions.insertTableCol)(table, positionOfInsertButton, Math.max(0, positionOfInsertButton - 1), colWidth));

    if (positionOfInsertButton === colsWidth.length) {
      setInsertButtonPos(positionOfInsertButton + 1);
    }
  }, [table, positionOfInsertButton, controller, setInsertButtonPos]);
  const deleteCol = React.useCallback(() => {
    controller.run('onAction', (0, _actions.deleteTableCols)(table));
  }, [controller, table]);
  const highlightSelection = React.useCallback(() => {
    setIsHighlightSelection(true);
    setIsHoverDelete(true);
  }, [setIsHighlightSelection, setIsHoverDelete]);
  const cancelHighlightSelection = React.useCallback(() => {
    setIsHighlightSelection(false);
    setIsHoverDelete(false);
  }, [setIsHighlightSelection, setIsHoverDelete]);
  const renderColToolbarItems = React.useMemo(() => {
    if (!Array.isArray(colsWidth)) {
      return null;
    }

    let left = 0;
    const children = [];
    const isSelectWholeTable = controller.query('isSelectWholeTable', {
      node: table
    });
    const indexRange = getSelectedIndexRange();
    const deleteRange = isHoverDelete ? indexRange : null;
    const selectRanges = indexRange ? [indexRange] : [];

    if (isHoverCornerToolbar || isSelectWholeTable) {
      selectRanges.push({
        start: 0,
        end: colsWidth.length - 1
      });
    } else if (hoverSelection && hoverSelection.startColIndex === hoverSelection.endColIndex) {
      selectRanges.push({
        start: hoverSelection.startColIndex,
        end: hoverSelection.endColIndex
      });
    }

    const activeRange = selection ? {
      start: selection.startColIndex,
      end: selection.endColIndex
    } : null;
    colsWidth.forEach((width, index) => {
      const resizerLeft = resizingColData.colIndex === -1 ? left + width : resizingColData.left;
      const translateY = (_insertButtonIndicator.INDICATOR_WRAPPER_WIDTH - _insertButtonIndicator.GAP_BEWTEEN_INDICATOR_TOOLBAR) / scale; // 第一个indicator如果不往右偏一点会被表格wrapper截断，因为超出了表格左侧区域

      const translateX = index === 0 ? '45%' : '55%';
      const isLastItem = index === colsWidth.length - 1;
      children.push( /*#__PURE__*/_createElement(React.Fragment, {
        key: index
      }, /*#__PURE__*/_createElement(_tableColToolbarItem.TableColToolbarItem, {
        activeRange: activeRange,
        selectRanges: selectRanges,
        deleteRange: deleteRange,
        index: index,
        scale: scale,
        onContextMenu: handleContextMenu,
        onMouseDown: handleSelectCol,
        onMouseEnter: handleMouseEnterColToolbarItem,
        onMouseOut: handleMouseOutColToolbarItem,
        onRectUpdate: handleColRectUpdate
      }, index === 0 && isColumnHeader ? null : /*#__PURE__*/_createElement(_insertButtonIndicator.default, {
        scale: scale,
        onClick: insertCol,
        style: {
          alignItems: 'start',
          transform: `translate(-${translateX}, -${translateY}px)`
        }
      }), isLastItem ? /*#__PURE__*/_createElement(_insertButtonIndicator.default, {
        scale: scale,
        onClick: insertCol,
        style: {
          alignItems: 'start',
          left: `${width}px`,
          transform: `translate(-100%, -${translateY}px)`,
          // 最后一个indicator不能超出表格区域，否则自适应的时候会产生滚动条
          justifyContent: 'flex-end'
        }
      }) : null), /*#__PURE__*/_createElement(ColToolbarResizer, {
        "data-index": index,
        "data-type": "col-resizer",
        scale: scale,
        style: {
          left: resizerLeft,
          width: index === colsWidth.length - 1 ? '3px' : ''
        },
        onMouseDown: handleColResizeStart
      })));
      left += width;
    });
    return children;
  }, [colsWidth, controller, table, getSelectedIndexRange, isHoverDelete, isHoverCornerToolbar, hoverSelection, selection, resizingColData.colIndex, resizingColData.left, scale, handleContextMenu, handleSelectCol, handleMouseEnterColToolbarItem, handleMouseOutColToolbarItem, handleColRectUpdate, isColumnHeader, insertCol, handleColResizeStart]);
  const isShowButton = React.useCallback(() => {
    return !contextMenuVisible && zoomContainer && getLastActiveTableKey() === table.key && selection;
  }, [contextMenuVisible, zoomContainer, getLastActiveTableKey, table.key, selection]); // 展示插入按钮时隐藏删除按钮

  const isShowDelete = React.useCallback(() => {
    return isShowButton() && isSelectWholeCol() && isShowColToolbar() && positionOfInsertButton === -1 && !isDragging && !isHideDeleteButton;
  }, [isShowButton, isSelectWholeCol, isShowColToolbar, positionOfInsertButton, isDragging, isHideDeleteButton]);
  const handleMouseMove = React.useCallback((0, _lodash.throttle)(event => {
    if (isDragging || isResizingCol() || !scrollContainer.current) {
      return;
    }

    if (!isTableSelected) {
      setInsertButtonPos(-1);
      return;
    }

    const colsRects = getColsRects();

    if (colsRects.length === 0) {
      return;
    }

    const {
      clientX,
      clientY
    } = event; // 鼠标位置在插入按钮区域时，不隐藏插入按钮

    if (positionOfInsertButton !== -1 && insertButtonRef.current) {
      const insertButtonNode = ReactDOM.findDOMNode(insertButtonRef.current);
      const {
        left,
        top,
        right,
        bottom
      } = insertButtonNode.getBoundingClientRect();

      if (clientX >= left && clientX <= right && clientY >= top && clientY <= bottom) {
        return;
      }
    }

    const scrollRect = scrollContainer.current.getBoundingClientRect();

    if (clientX < scrollRect.left || clientX > scrollRect.right) {
      setInsertButtonPos(-1);
      return;
    }

    let insertIndex = -1;

    for (let i = 0; i < colsRects.length; i++) {
      const colRect = colsRects[i]; // 理论上 colRect 非空，监控有报错显示 undefined，此处兼容

      if (!colRect) break;

      if (clientY < colRect.top && clientY >= colRect.top - _insertButtonIndicator.INDICATOR_WRAPPER_WIDTH) {
        if (clientX >= colRect.left - _insertButtonIndicator.INDICATOR_WRAPPER_WIDTH / 2 && clientX <= colRect.left + _insertButtonIndicator.INDICATOR_WRAPPER_WIDTH / 2) {
          insertIndex = i;
          break;
        } else if (clientX >= colRect.left + colRect.width - _insertButtonIndicator.INDICATOR_WRAPPER_WIDTH / 2 && clientX <= colRect.left + colRect.width + _insertButtonIndicator.INDICATOR_WRAPPER_WIDTH / 2) {
          insertIndex = i + 1;
          break;
        }
      }
    }

    const sortedRange = getSortedSelectedRange(); // 加号在所选行中间时，隐藏

    if (sortedRange && insertIndex > sortedRange.min && insertIndex < sortedRange.max + 1) {
      insertIndex = -1;
    }

    setInsertButtonPos(insertIndex);
  }, 200, {
    leading: true
  }), [scrollContainer, isTableSelected, positionOfInsertButton, isDragging, isResizingCol, getColsRects, getSortedSelectedRange]);
  const updateDeleteButtonStyle = React.useCallback(() => {
    if (!deleteButtonRef.current || !selection || !isShowDelete()) {
      return;
    }

    const menuNode = ReactDOM.findDOMNode(deleteButtonRef.current);
    const menuRect = (0, _everUtils.getBoundingRelativeRect)(menuNode, zoomContainer);
    const result = getColToolbarTop();

    if (!result) {
      return;
    }

    const {
      top
    } = result;
    const startColRect = getColItemRect(selection.startColIndex);
    const endColRect = getColItemRect(selection.endColIndex);

    if (!startColRect || !endColRect) {
      return;
    }

    const mid = (endColRect.right - startColRect.left) / 2;
    const containerLeft = startColRect.left;
    const relativeLeft = containerLeft + mid - menuRect.width / 2;
    menuNode.style.top = `${top / scale - menuNode.offsetHeight - _constants.DISTANCE_BETWEEN_DELETE_BUTTON_AND_TOOLBAR}px`;
    deleteButtonLeftRef.current = relativeLeft / scale;
    menuNode.style.left = `${deleteButtonLeftRef.current - 1}px`;
    const shouldHide = shouldHideButton(relativeLeft);

    if (shouldHide) {
      menuNode.style.opacity = '0';
    } else {
      menuNode.style.opacity = '1';
    }
  }, [selection, zoomContainer, scale, getColToolbarTop, shouldHideButton, getColItemRect, isShowDelete]);
  React.useLayoutEffect(() => {
    // 把样式改变放在layoutEffect中执行，防止闪烁
    if (isTableSelected) {
      _fastdom.default.measure(() => {
        updateDeleteButtonStyle();
        updateInsertButtonStyle();
        updateIndicatorStyle();
        updateColSelectionRectStyle();
      });
    }
  }, [updateDeleteButtonStyle, updateInsertButtonStyle, updateIndicatorStyle, updateColSelectionRectStyle, isTableSelected]);
  React.useEffect(() => {
    return () => {
      document.removeEventListener('mousemove', handleColResizing);
      document.removeEventListener('mouseup', handleColResizeEnd);
      document.removeEventListener('mousemove', handleMouseMove);
      removeMultiSelectListener();
      removeDragEventListener();
    };
  }, []);
  React.useEffect(() => {
    if (!isTableSelected || !Array.isArray(colsWidth)) {
      return undefined;
    }

    document.addEventListener('mousemove', handleMouseMove);

    if (contextMenuVisible) {
      document.addEventListener('mousedown', hideContextMenu);
      return () => {
        document.removeEventListener('mousedown', hideContextMenu);
        document.removeEventListener('mousemove', handleMouseMove);
      };
    }

    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
    };
  }, [isTableSelected, colsWidth, handleMouseMove, contextMenuVisible, hideContextMenu]);
  const width = (colsWidth || []).reduce((acc, w) => acc + w, 0);
  const style = {
    width: width + 1,
    // 保持和整体表格宽度一致
    height: `${Math.round(_constants.TOOLBAR_ITEM_SIZE / scale)}px`,
    borderRadius: `${Math.round(3 / scale)}px`
  };
  const [scrollRect] = useScrollableContainerRect();
  const containerWidth = useTableScrollContainerWidth();
  const tableScrollLeft = useTableScrollContainerScrollLeft();
  React.useLayoutEffect(() => {
    if (!toolbarWrapperRef.current || !isSticky) return;
    toolbarWrapperRef.current.scrollLeft = tableScrollLeft;
  }, [isSticky, tableScrollLeft]); // 在定义的函数内使用 positionOfInsertButton 需要通过ref来保证拿到的是最新值，在外部则通过 positionOfInsertButton 来获取最新值即可

  const isShowInsertButton = !isDragging && positionOfInsertButton !== -1;
  const tableHeight = isDragging && tableRef.current ? tableRef.current.offsetHeight : 0;
  const showInsert = !!isShowButton() && isShowInsertButton;
  const wrapperStyle = {};

  if (isTableSelected) {
    wrapperStyle.visibility = 'visible';
    wrapperStyle.pointerEvents = 'auto';
  }

  if (isSticky) {
    wrapperStyle.width = containerWidth;
    wrapperStyle.background = 'white';

    if (Number.isFinite(scrollRect.top)) {
      wrapperStyle.top = scrollRect.top;
    }

    if (Number.isFinite(scrollRect.left)) {
      wrapperStyle.left = scrollRect.left;
    }
  }

  return /*#__PURE__*/_createElement(Wrapper, {
    style: wrapperStyle,
    "data-sticky": isSticky,
    ref: toolbarWrapperRef,
    "data-testid": "table-col-toolbar-wrapper"
  }, /*#__PURE__*/_createElement(ColToolbarWrapper, {
    role: "toolbar",
    ref: colToolbarRef,
    style: style,
    "data-testid": "table-col-toolbar",
    onMouseOver: handleMouseOver,
    onMouseOut: handleMouseOut
  }, renderColToolbarItems, /*#__PURE__*/_createElement(_styled.ColResizer, {
    style: {
      display: resizingColData.colIndex === -1 ? 'none' : 'block',
      left: resizingColData.left,
      top: resizingColData.top,
      height: resizingColData.colResizerHeight
    }
  }), /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/_createElement(ColInlineToolbar, {
    style: {
      visibility: isShowDelete() ? 'visible' : 'hidden',
      transition: 'left ease-in-out 0.1s'
    },
    ref: deleteButtonRef,
    "data-testid": "table-col-inline-toolbar"
  }, /*#__PURE__*/_createElement(_inlineToolbarDeleteButton.default, {
    mode: "col",
    locale: locale,
    scale: scale,
    onDelete: deleteCol,
    onHighlightSelection: highlightSelection,
    onCancelHighlightSelection: cancelHighlightSelection
  })), zoomContainer), /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/_createElement(ColInlineToolbar, {
    style: {
      opacity: showInsert ? 1 : 0,
      pointerEvents: showInsert ? 'auto' : 'none'
    },
    ref: insertButtonRef,
    "data-testid": "table-col-inline-toolbar-insert"
  }, /*#__PURE__*/_createElement(_inlineToolbarInsertButton.default, {
    locale: locale,
    table: table,
    selection: selection,
    mode: "col",
    tableRef: tableRef,
    scale: scale,
    onInsert: insertCol,
    zoomContainer: zoomContainer,
    insertIndex: positionOfInsertButton,
    getAllColsNodes: getAllColsNodes,
    onShowIndicatorVisible: showIndicatorVisible
  })), zoomContainer), zoomContainer && /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/_createElement(_dragElement.default, {
    ref: dragElementRef,
    visible: isDragging,
    width: draggingColWidth,
    height: tableHeight + _constants.TOOLBAR_ITEM_SIZE
  }), zoomContainer)));
}

var _default = (0, _createToolbarWithTableSelection.default)(TableColToolbar);

exports.default = _default;
//# sourceMappingURL=index.js.map