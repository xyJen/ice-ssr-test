"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = resizeTable;

function resizeTable(originalSizes, expectTotalWidth, limits) {
  const originals = originalSizes.slice();
  const outputs = [];
  let temps = originals; // 循环次数最多跟数组长度相同
  // 最开始一个不抽，尝试按比例缩放，发现缩放后的数组中最小的那个值小于 MIN 值的
  // 将其抽出，设置成 MIN 值，放入 output 中。
  // 然后对剩余的数组，针对剩余的距离，再尝试按比例缩放，发现缩放后小于 MIN 值的再抽出
  // 如此往复，直到 output 中所有值都 >= MIN，或者缩放后没有小于 MIN 值的直接全部抽出到 output 中结束循环

  for (let i = 0; i <= originals.length; i++) {
    const outputTotal = outputs.reduce((acc, curr) => acc + (curr || 0), 0);
    const inputTotal = originals.reduce((acc, curr) => acc + (curr || 0), 0);
    const coefficient = (expectTotalWidth - outputTotal) / inputTotal;

    if (coefficient < 0) {
      break;
    }

    temps = originals.map(value => {
      if (typeof value === 'number') {
        return Math.floor(coefficient * value);
      }

      return null;
    });
    const outOfLimitIndex = temps.findIndex((v, index) => {
      return typeof v === 'number' && v < limits[index];
    });

    if (outOfLimitIndex === -1) {
      break;
    }

    outputs[outOfLimitIndex] = limits[outOfLimitIndex];
    originals[outOfLimitIndex] = null;
  }

  const resultColsWidth = originals.map((_, i) => {
    const value = outputs[i];

    if (typeof value !== 'number') {
      return Math.max(temps[i], limits[i]);
    }

    return value;
  });
  return resultColsWidth;
}
//# sourceMappingURL=resizeTable.js.map