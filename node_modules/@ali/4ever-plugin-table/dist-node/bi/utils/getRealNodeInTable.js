"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getRealNodeInTable;

var _logger = require("./logger");

function getRealNodeInTable(table, rowIndex, colIndex) {
  // @ts-ignore
  const row = table.nodes && table.nodes[rowIndex];

  if (!row) {
    return null;
  } // @ts-ignore


  let node = row.nodes && row.nodes[colIndex];

  if (!node) {
    return null;
  }

  if (node.data && node.data.hidden) {
    const maxRound = Math.max(rowIndex, colIndex);
    let found = false;

    for (let round = 1; round <= maxRound; round += 1) {
      const r = Math.max(rowIndex - round, 0);
      const c = Math.max(colIndex - round, 0);
      const rowToIterate = table.nodes[r];

      for (let i = c; i <= colIndex; i += 1) {
        // @ts-ignore
        const cellNode = rowToIterate.nodes[i];

        if (!cellNode) {
          (0, _logger.logNPEInfo)(table, {
            type: 'getRealNodeInTable',
            detail: `cellNode is ${cellNode}`,
            colIndex: i,
            rowIndex: r
          });
          return null;
        }

        const isCellHide = cellNode.data.hidden;
        const rowSpan = cellNode.data.rowSpan || 1;
        const colSpan = cellNode.data.colSpan || 1;

        if (!isCellHide && r + rowSpan - 1 >= rowIndex && i + colSpan - 1 >= colIndex) {
          node = cellNode;
          found = true;
          break;
        }
      }

      for (let i = r; i <= rowIndex; i += 1) {
        // @ts-ignore
        const cellNode = table.nodes[i].nodes[c];
        const isCellHide = cellNode.data.hidden;
        const rowSpan = cellNode.data.rowSpan || 1;
        const colSpan = cellNode.data.colSpan || 1;

        if (!isCellHide && i + rowSpan - 1 >= rowIndex && c + colSpan - 1 >= colIndex) {
          node = cellNode;
          found = true;
          break;
        }
      }

      if (found) {
        break;
      }
    }
  }

  return node;
}
//# sourceMappingURL=getRealNodeInTable.js.map