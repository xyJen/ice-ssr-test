"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = adjustSelection;

var _getRealNodeInTable = _interopRequireDefault(require("./getRealNodeInTable"));

var _getPositionOfCell = _interopRequireDefault(require("./getPositionOfCell"));

// 表格选区定义
// 选区一定是矩形，矩形根据起点与终点(起点的对角线)定义
// 如果波及到合并单元格，则该合并单元格整体都会被选中，起点/终点可能会变化，选区范围可能被影响而扩大
// 起点/终点index与视觉上实际看到的网格的index相同
// 若终点落在合并单元格，终点位置会是合并单元格本身位置加上其colSpan/rowSpan
// 通过index取终点cell可能需要getRealNode
// 未来出现通过行列工具栏选出的可穿越合并单元格的特殊选区时，方法和定义都会修改
// 本方法是表格基础方法，容错需要做好
function adjustSelection(table, {
  startRowIndex,
  startColIndex,
  endRowIndex,
  endColIndex
}) {
  const MAX_ROWS_INDEX = table.nodes.length - 1;

  if (!Array.isArray(table.data.colsWidth)) {
    return null;
  }

  const MAX_COLS_INDEX = table.data.colsWidth.length - 1;
  let adjustedStartRowIndex = startRowIndex;
  let adjustedStartColIndex = startColIndex;
  let adjustedEndRowIndex = Math.min(endRowIndex, MAX_ROWS_INDEX);
  let adjustedEndColIndex = Math.min(endColIndex, MAX_COLS_INDEX);

  while (true) {
    let minRowIndex = adjustedStartRowIndex;
    let minColIndex = adjustedStartColIndex;
    let maxRowIndex = adjustedEndRowIndex;
    let maxColIndex = adjustedEndColIndex; // 上边框辐射

    for (let i = adjustedStartColIndex; i <= adjustedEndColIndex; i++) {
      const cell = (0, _getRealNodeInTable.default)(table, adjustedStartRowIndex, i);
      const position = cell ? (0, _getPositionOfCell.default)(cell.key, table) : null;
      minRowIndex = position ? Math.min(position.rowIndex, minRowIndex) : minRowIndex;
    } // 左边框辐射


    for (let i = adjustedStartRowIndex; i <= adjustedEndRowIndex; i++) {
      const cell = (0, _getRealNodeInTable.default)(table, i, adjustedStartColIndex);
      const position = cell ? (0, _getPositionOfCell.default)(cell.key, table) : null;
      minColIndex = position ? Math.min(position.colIndex, minColIndex) : minColIndex;
    } // 下边框辐射


    for (let i = adjustedStartColIndex; i <= adjustedEndColIndex; i++) {
      const cell = (0, _getRealNodeInTable.default)(table, adjustedEndRowIndex, i);
      const position = cell ? (0, _getPositionOfCell.default)(cell.key, table) : null;
      maxRowIndex = position ? Math.max(position.rowIndex + (cell.data?.rowSpan || 1) - 1, maxRowIndex) : maxRowIndex;
      maxRowIndex = Math.min(maxRowIndex, MAX_ROWS_INDEX);
    } // 右边框辐射


    for (let i = adjustedStartRowIndex; i <= adjustedEndRowIndex; i++) {
      const cell = (0, _getRealNodeInTable.default)(table, i, adjustedEndColIndex);
      const position = cell ? (0, _getPositionOfCell.default)(cell.key, table) : null;
      maxColIndex = position ? Math.max(position.colIndex + (cell.data?.colSpan || 1) - 1, maxColIndex) : maxColIndex;
      maxColIndex = Math.min(maxColIndex, MAX_COLS_INDEX);
    } // 向外辐射一次后，跟原结果一样，说明稳定了，是最终结果


    if (adjustedStartRowIndex === minRowIndex && adjustedStartColIndex === minColIndex && adjustedEndRowIndex === maxRowIndex && adjustedEndColIndex === maxColIndex) {
      return {
        startRowIndex: minRowIndex,
        startColIndex: minColIndex,
        endRowIndex: maxRowIndex,
        endColIndex: maxColIndex,
        key: table.key
      };
    }

    adjustedStartRowIndex = minRowIndex;
    adjustedStartColIndex = minColIndex;
    adjustedEndRowIndex = maxRowIndex;
    adjustedEndColIndex = maxColIndex;
  }
}
//# sourceMappingURL=adjustSelection.js.map