{"version":3,"sources":["../../../../src/bi/utils/adjustSelection.ts"],"names":["adjustSelection","table","startRowIndex","startColIndex","endRowIndex","endColIndex","MAX_ROWS_INDEX","nodes","length","Array","isArray","data","colsWidth","MAX_COLS_INDEX","adjustedStartRowIndex","adjustedStartColIndex","adjustedEndRowIndex","Math","min","adjustedEndColIndex","minRowIndex","minColIndex","maxRowIndex","maxColIndex","i","cell","position","key","rowIndex","colIndex","max","rowSpan","colSpan"],"mappings":";;;;;;;;;AACA;;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACe,SAASA,eAAT,CACbC,KADa,EAEb;AACEC,EAAAA,aADF;AACiBC,EAAAA,aADjB;AACgCC,EAAAA,WADhC;AAC6CC,EAAAA;AAD7C,CAFa,EAKW;AACxB,QAAMC,cAAc,GAAGL,KAAK,CAACM,KAAN,CAAYC,MAAZ,GAAqB,CAA5C;;AACA,MAAI,CAACC,KAAK,CAACC,OAAN,CAAcT,KAAK,CAACU,IAAN,CAAWC,SAAzB,CAAL,EAA0C;AACxC,WAAO,IAAP;AACD;;AACD,QAAMC,cAAc,GAAGZ,KAAK,CAACU,IAAN,CAAWC,SAAX,CAAqBJ,MAArB,GAA8B,CAArD;AAEA,MAAIM,qBAAqB,GAAGZ,aAA5B;AACA,MAAIa,qBAAqB,GAAGZ,aAA5B;AACA,MAAIa,mBAAmB,GAAGC,IAAI,CAACC,GAAL,CAASd,WAAT,EAAsBE,cAAtB,CAA1B;AACA,MAAIa,mBAAmB,GAAGF,IAAI,CAACC,GAAL,CAASb,WAAT,EAAsBQ,cAAtB,CAA1B;;AAEA,SAAO,IAAP,EAAa;AACX,QAAIO,WAAW,GAAGN,qBAAlB;AACA,QAAIO,WAAW,GAAGN,qBAAlB;AACA,QAAIO,WAAW,GAAGN,mBAAlB;AACA,QAAIO,WAAW,GAAGJ,mBAAlB,CAJW,CAKX;;AACA,SAAK,IAAIK,CAAC,GAAGT,qBAAb,EAAoCS,CAAC,IAAIL,mBAAzC,EAA8DK,CAAC,EAA/D,EAAmE;AACjE,YAAMC,IAAI,GAAG,iCAAmBxB,KAAnB,EAA0Ba,qBAA1B,EAAiDU,CAAjD,CAAb;AACA,YAAME,QAAQ,GAAGD,IAAI,GAAG,gCAAkBA,IAAI,CAACE,GAAvB,EAA4B1B,KAA5B,CAAH,GAAwC,IAA7D;AACAmB,MAAAA,WAAW,GAAGM,QAAQ,GAAGT,IAAI,CAACC,GAAL,CAASQ,QAAQ,CAACE,QAAlB,EAA4BR,WAA5B,CAAH,GAA8CA,WAApE;AACD,KAVU,CAWX;;;AACA,SAAK,IAAII,CAAC,GAAGV,qBAAb,EAAoCU,CAAC,IAAIR,mBAAzC,EAA8DQ,CAAC,EAA/D,EAAmE;AACjE,YAAMC,IAAI,GAAG,iCAAmBxB,KAAnB,EAA0BuB,CAA1B,EAA6BT,qBAA7B,CAAb;AACA,YAAMW,QAAQ,GAAGD,IAAI,GAAG,gCAAkBA,IAAI,CAACE,GAAvB,EAA4B1B,KAA5B,CAAH,GAAwC,IAA7D;AACAoB,MAAAA,WAAW,GAAGK,QAAQ,GAAGT,IAAI,CAACC,GAAL,CAASQ,QAAQ,CAACG,QAAlB,EAA4BR,WAA5B,CAAH,GAA8CA,WAApE;AACD,KAhBU,CAiBX;;;AACA,SAAK,IAAIG,CAAC,GAAGT,qBAAb,EAAoCS,CAAC,IAAIL,mBAAzC,EAA8DK,CAAC,EAA/D,EAAmE;AACjE,YAAMC,IAAI,GAAG,iCAAmBxB,KAAnB,EAA0Be,mBAA1B,EAA+CQ,CAA/C,CAAb;AACA,YAAME,QAAQ,GAAGD,IAAI,GAAG,gCAAkBA,IAAI,CAACE,GAAvB,EAA4B1B,KAA5B,CAAH,GAAwC,IAA7D;AACAqB,MAAAA,WAAW,GAAGI,QAAQ,GAClBT,IAAI,CAACa,GAAL,CAASJ,QAAQ,CAACE,QAAT,IAAqBH,IAAI,CAAEd,IAAN,EAAYoB,OAAZ,IAAuB,CAA5C,IAAiD,CAA1D,EAA6DT,WAA7D,CADkB,GAElBA,WAFJ;AAGAA,MAAAA,WAAW,GAAGL,IAAI,CAACC,GAAL,CAASI,WAAT,EAAsBhB,cAAtB,CAAd;AACD,KAzBU,CA0BX;;;AACA,SAAK,IAAIkB,CAAC,GAAGV,qBAAb,EAAoCU,CAAC,IAAIR,mBAAzC,EAA8DQ,CAAC,EAA/D,EAAmE;AACjE,YAAMC,IAAI,GAAG,iCAAmBxB,KAAnB,EAA0BuB,CAA1B,EAA6BL,mBAA7B,CAAb;AACA,YAAMO,QAAQ,GAAGD,IAAI,GAAG,gCAAkBA,IAAI,CAACE,GAAvB,EAA4B1B,KAA5B,CAAH,GAAwC,IAA7D;AACAsB,MAAAA,WAAW,GAAGG,QAAQ,GAClBT,IAAI,CAACa,GAAL,CAASJ,QAAQ,CAACG,QAAT,IAAqBJ,IAAI,CAAEd,IAAN,EAAYqB,OAAZ,IAAuB,CAA5C,IAAiD,CAA1D,EAA6DT,WAA7D,CADkB,GAElBA,WAFJ;AAGAA,MAAAA,WAAW,GAAGN,IAAI,CAACC,GAAL,CAASK,WAAT,EAAsBV,cAAtB,CAAd;AACD,KAlCU,CAoCX;;;AACA,QAAIC,qBAAqB,KAAKM,WAA1B,IACCL,qBAAqB,KAAKM,WAD3B,IAECL,mBAAmB,KAAKM,WAFzB,IAGCH,mBAAmB,KAAKI,WAH7B,EAG0C;AACxC,aAAO;AACLrB,QAAAA,aAAa,EAAEkB,WADV;AAELjB,QAAAA,aAAa,EAAEkB,WAFV;AAGLjB,QAAAA,WAAW,EAAEkB,WAHR;AAILjB,QAAAA,WAAW,EAAEkB,WAJR;AAKLI,QAAAA,GAAG,EAAE1B,KAAK,CAAC0B;AALN,OAAP;AAOD;;AAEDb,IAAAA,qBAAqB,GAAGM,WAAxB;AACAL,IAAAA,qBAAqB,GAAGM,WAAxB;AACAL,IAAAA,mBAAmB,GAAGM,WAAtB;AACAH,IAAAA,mBAAmB,GAAGI,WAAtB;AACD;AACF","sourcesContent":["import Table from '../../mo/models';\nimport getRealNodeInTable from './getRealNodeInTable';\nimport getPositionOfCell from './getPositionOfCell';\nimport { ITableSelection } from '../types';\n\n// 表格选区定义\n// 选区一定是矩形，矩形根据起点与终点(起点的对角线)定义\n// 如果波及到合并单元格，则该合并单元格整体都会被选中，起点/终点可能会变化，选区范围可能被影响而扩大\n// 起点/终点index与视觉上实际看到的网格的index相同\n// 若终点落在合并单元格，终点位置会是合并单元格本身位置加上其colSpan/rowSpan\n// 通过index取终点cell可能需要getRealNode\n// 未来出现通过行列工具栏选出的可穿越合并单元格的特殊选区时，方法和定义都会修改\n\n// 本方法是表格基础方法，容错需要做好\nexport default function adjustSelection(\n  table: Table,\n  {\n    startRowIndex, startColIndex, endRowIndex, endColIndex,\n  },\n): ITableSelection | null {\n  const MAX_ROWS_INDEX = table.nodes.length - 1;\n  if (!Array.isArray(table.data.colsWidth)) {\n    return null;\n  }\n  const MAX_COLS_INDEX = table.data.colsWidth.length - 1;\n\n  let adjustedStartRowIndex = startRowIndex;\n  let adjustedStartColIndex = startColIndex;\n  let adjustedEndRowIndex = Math.min(endRowIndex, MAX_ROWS_INDEX);\n  let adjustedEndColIndex = Math.min(endColIndex, MAX_COLS_INDEX);\n\n  while (true) {\n    let minRowIndex = adjustedStartRowIndex;\n    let minColIndex = adjustedStartColIndex;\n    let maxRowIndex = adjustedEndRowIndex;\n    let maxColIndex = adjustedEndColIndex;\n    // 上边框辐射\n    for (let i = adjustedStartColIndex; i <= adjustedEndColIndex; i++) {\n      const cell = getRealNodeInTable(table, adjustedStartRowIndex, i);\n      const position = cell ? getPositionOfCell(cell.key, table) : null;\n      minRowIndex = position ? Math.min(position.rowIndex, minRowIndex) : minRowIndex;\n    }\n    // 左边框辐射\n    for (let i = adjustedStartRowIndex; i <= adjustedEndRowIndex; i++) {\n      const cell = getRealNodeInTable(table, i, adjustedStartColIndex);\n      const position = cell ? getPositionOfCell(cell.key, table) : null;\n      minColIndex = position ? Math.min(position.colIndex, minColIndex) : minColIndex;\n    }\n    // 下边框辐射\n    for (let i = adjustedStartColIndex; i <= adjustedEndColIndex; i++) {\n      const cell = getRealNodeInTable(table, adjustedEndRowIndex, i);\n      const position = cell ? getPositionOfCell(cell.key, table) : null;\n      maxRowIndex = position\n        ? Math.max(position.rowIndex + (cell!.data?.rowSpan || 1) - 1, maxRowIndex)\n        : maxRowIndex;\n      maxRowIndex = Math.min(maxRowIndex, MAX_ROWS_INDEX);\n    }\n    // 右边框辐射\n    for (let i = adjustedStartRowIndex; i <= adjustedEndRowIndex; i++) {\n      const cell = getRealNodeInTable(table, i, adjustedEndColIndex);\n      const position = cell ? getPositionOfCell(cell.key, table) : null;\n      maxColIndex = position\n        ? Math.max(position.colIndex + (cell!.data?.colSpan || 1) - 1, maxColIndex)\n        : maxColIndex;\n      maxColIndex = Math.min(maxColIndex, MAX_COLS_INDEX);\n    }\n\n    // 向外辐射一次后，跟原结果一样，说明稳定了，是最终结果\n    if (adjustedStartRowIndex === minRowIndex\n      && adjustedStartColIndex === minColIndex\n      && adjustedEndRowIndex === maxRowIndex\n      && adjustedEndColIndex === maxColIndex) {\n      return {\n        startRowIndex: minRowIndex,\n        startColIndex: minColIndex,\n        endRowIndex: maxRowIndex,\n        endColIndex: maxColIndex,\n        key: table.key,\n      };\n    }\n\n    adjustedStartRowIndex = minRowIndex;\n    adjustedStartColIndex = minColIndex;\n    adjustedEndRowIndex = maxRowIndex;\n    adjustedEndColIndex = maxColIndex;\n  }\n}\n"],"file":"adjustSelection.js"}