"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handleCangjiePaste = handleCangjiePaste;

var _uuid = require("uuid");

var _lodash = require("lodash");

var _weDesignNext = require("@ali/we-design-next");

var _everCangjie = require("@ali/4ever-cangjie");

var _models = _interopRequireDefault(require("../../mo/models"));

var _tableRow = _interopRequireDefault(require("../../mo/models/tableRow"));

var _isSelectionInTableCell = _interopRequireDefault(require("../utils/isSelectionInTableCell"));

var _getPositionOfCell = _interopRequireDefault(require("../utils/getPositionOfCell"));

var _adjustSelection = _interopRequireDefault(require("../utils/adjustSelection"));

var _types = require("../types");

var _insertRow = _interopRequireDefault(require("../commands/insertRow"));

var _insertCol = _interopRequireDefault(require("../commands/insertCol"));

var _splitCell = _interopRequireDefault(require("../commands/splitCell"));

var _selectTableSelection = _interopRequireDefault(require("../commands/selectTableSelection"));

var _actions = require("../actions");

var _constants = require("../constants");

var _selectionCommands = require("../utils/selectionCommands");

var _utils = _interopRequireDefault(require("../../utils/utils"));

var _everPluginClipboard = require("@ali/4ever-plugin-clipboard");

const {
  filterValidData,
  setSelectionByTable
} = _utils.default;
const messageKey = (0, _uuid.v4)().slice(0, 8);

function handleCangjiePaste(controller, payload, next = _lodash.noop) {
  // 处理含有表头行/列的表格
  const {
    value
  } = controller;
  const {
    fragment: nativeFragment,
    tableConfig
  } = payload;
  if (!nativeFragment) return next();
  const fragment = (0, _everPluginClipboard.normalizeFragment)(nativeFragment);
  const {
    locale = {}
  } = tableConfig || {};
  const tables = fragment.filterDescendants(_models.default.isTable);

  for (let i = 0; i < tables.length; i++) {
    const table = tables[i];

    if (_models.default.isColumnHeader(table) || _models.default.isRowHeader(table)) {
      // NOTE: 需要先执行 setTableHeaderStyle
      const {
        setTableHeaderStyle
      } = tableConfig || {};
      setTableHeaderStyle?.();
      break;
    }
  }

  const {
    document,
    startBlock,
    selection
  } = value;
  const tableSelection = controller.query('tableSelection');

  if (!fragment.nodes.length) {
    return next();
  }

  const {
    anchor,
    focus
  } = selection;
  const anchorTable = document.getClosest(anchor.key, _models.default.isTable);
  const focusTable = document.getClosest(focus.key, _models.default.isTable); // 无表格选区且 anchor、focus 不在同一个表格内时，禁止粘贴

  if (!tableSelection && selection.isExpanded) {
    if (anchorTable && focusTable && !controller.query('isTableFromSameOrigin', {
      node: anchorTable,
      tableKey: focusTable.key
    })) {
      return controller;
    }
  }

  const hasTableInFragment = hasTable(fragment);

  if (fragment.nodes.length === 1 && !isRealTable(fragment.nodes[0]) || fragment.nodes.length > 1) {
    const insertedFragment = hasTableInFragment ? removeTable(fragment) : fragment;
    /**
     * 存在表格选区时，下列情况将单元格替换为 fragment
     * 1. 粘贴板里只有一个节点，且节点不是表格
     * 2. 粘贴板里有多个节点（fragment 需要过滤表格）
     */

    if (tableSelection) {
      if (hasTableInFragment) {
        messageUnablePasteTable(locale);
      }

      const t = document.getNode(tableSelection.key);
      controller.run('onAction', (0, _actions.emptyTableSelection)(t));
      const {
        startRowIndex,
        startColIndex,
        endRowIndex,
        endColIndex
      } = tableSelection;
      const tablePath = document.getPath(t.key);
      controller.withoutNormalizing(() => {
        for (let rowIndex = startRowIndex; rowIndex <= endRowIndex; rowIndex += 1) {
          const row = t.nodes[rowIndex];
          if (!row) continue;

          for (let colIndex = startColIndex; colIndex <= endColIndex; colIndex += 1) {
            const cell = row.nodes[colIndex];
            if (!cell) continue;
            const cellPath = [...tablePath, rowIndex, colIndex];
            const newCell = controller.value.document.getNodeByPath(cellPath);
            const s = controller.value.selection;
            const newS = s.moveAnchorToStartOfNode(newCell, controller).moveFocusToEndOfNode(newCell, controller);
            controller.command(_everCangjie.Commands.select, newS).command(_everCangjie.Commands.insertFragment, insertedFragment);
          }
        }

        (0, _selectTableSelection.default)(controller, t, tableSelection);
      });
      return controller;
    } else if (anchorTable && focusTable && hasTableInFragment) {
      messageUnablePasteTable(locale);
      return controller.command(_everCangjie.Commands.insertFragment, insertedFragment);
    }
  }

  if (fragment.nodes.length > 1 || fragment.nodes[0].type !== 'table') {
    return next();
  }

  if (!tableSelection && !(0, _isSelectionInTableCell.default)(value, {
    excludeColumns: true
  })) {
    controller.command(_everCangjie.Commands.splitBlock).command(_everCangjie.Commands.moveBackward, 1);
    const t = fragment.nodes[0];
    const path = fragment.getPath(t.key);
    const adjustColsWidth = getAdjustTableColsWidth(t);
    const newFragment = fragment.setNode(path, {
      data: filterValidData({ ...(t.data || {}),
        colsWidth: adjustColsWidth
      })
    });
    return controller.command('insertFragmentByClipboard', newFragment);
  }

  let targetTable = tableSelection ? document.getNode(tableSelection.key) : document.getClosest(startBlock.key, _types.isTable);

  if (!targetTable) {
    return;
  } // 以下处理复制单个表格至表格内场景


  const targetTablePath = document.getPath(targetTable.key);
  if (!targetTablePath) return;
  const startCell = tableSelection ? document.getNodeByPath([...targetTablePath, tableSelection.startRowIndex, tableSelection.startColIndex]) : document.getClosest(startBlock.key, _types.isTableCell);
  let clipboardTable = fragment.nodes[0];

  if (tableSelection) {
    clipboardTable = adjustClipboardTableWithSelection(clipboardTable, tableSelection);
  }

  const position = (0, _getPositionOfCell.default)(startCell.key, targetTable); // 粘贴时被波及的区域解除合并单元格，否则粘贴时结构可能被破坏

  const startRowIndex = position.rowIndex;
  const startColIndex = position.colIndex;
  const endRowIndex = Math.min(position.rowIndex + clipboardTable.nodes.length - 1, targetTable.nodes.length - 1); // @ts-ignore

  const endColIndex = Math.min(position.colIndex + clipboardTable.nodes[0].nodes.length - 1, targetTable.nodes[0].nodes.length - 1);
  const area = (0, _adjustSelection.default)(targetTable, {
    startRowIndex,
    startColIndex,
    endRowIndex,
    endColIndex
  });
  (0, _splitCell.default)(controller, targetTable, area || undefined);
  targetTable = controller.value.document.getNodeByPath(targetTablePath);

  for (let rowIndex = 0; rowIndex < clipboardTable.nodes.length; rowIndex += 1) {
    const targetRowIndex = position.rowIndex + rowIndex;
    const targetRowPath = [...targetTablePath, targetRowIndex];
    let targetRow = controller.value.document.getNodeByPath(targetRowPath);

    if (!targetRow) {
      (0, _insertRow.default)(controller, targetTable.nodes[targetRowIndex - 1], 'insert-row-below'); // update target

      targetTable = controller.value.document.getNodeByPath(targetTablePath);
      targetRow = controller.value.document.getNodeByPath(targetRowPath);
    }

    const row = clipboardTable.nodes[rowIndex];

    for (let colIndex = 0; colIndex < row.nodes.length; colIndex += 1) {
      const targetColIndex = position.colIndex + colIndex;
      let targetCell = targetRow.nodes[targetColIndex];

      if (!targetCell) {
        // @ts-ignore
        // eslint-disable-next-line no-shadow
        const lastColIndex = targetTable.nodes[0].nodes.length - 1;
        const colWidth = (targetTable.data.colsWidth || [])[lastColIndex];
        (0, _insertCol.default)(controller, targetTable, targetColIndex, targetColIndex, colWidth); // update targets

        targetTable = controller.value.document.getNodeByPath(targetTablePath);
        targetRow = controller.value.document.getNodeByPath(targetRowPath); // @ts-ignore

        targetCell = targetRow.nodes[targetColIndex];
      }

      const targetCellPath = [...targetTablePath, targetRowIndex, targetColIndex];

      for (let childIndex = targetCell.nodes.length - 1; childIndex >= 0; childIndex -= 1) {
        controller.withoutNormalizing(c => {
          c.command(_everCangjie.Commands.removeNodeByPath, [...targetCellPath, childIndex]);
        });
      }

      const cell = row.nodes[colIndex];

      for (let childIndex = cell.nodes.length - 1; childIndex >= 0; childIndex -= 1) {
        controller.command(_everCangjie.Commands.insertNodeByPath, targetCellPath, 0, cell.nodes[childIndex]);
      }

      controller.command(_everCangjie.Commands.setNodeByPath, targetCellPath, {
        data: cell.data
      });
    }
  } // 恢復選區


  if (tableSelection) {
    (0, _selectTableSelection.default)(controller, targetTable, tableSelection);
    let rangeSelection = controller.value.selection;
    rangeSelection = setSelectionByTable(rangeSelection, false);
    controller.command(_everCangjie.Commands.select, rangeSelection);
  } else if (position) {
    targetTable = controller.value.document.getNodeByPath(targetTablePath);
    const {
      rowIndex,
      colIndex
    } = position;
    (0, _selectionCommands.moveToStartOfCell)(controller, targetTable, rowIndex, colIndex);
  }

  return controller;
}

function messageUnablePasteTable(locale) {
  locale?.pasteTipCannotPasteTableHere && _weDesignNext.Message.info(locale?.pasteTipCannotPasteTableHere, {
    key: messageKey
  });
}

function isRealTable(n) {
  return _models.default.isTable(n) && !n.data.sr;
}

function hasTable(fragment) {
  return !!fragment.findDescendant(isRealTable);
}

function removeTable(fragment) {
  const drops = fragment.filterDescendants(isRealTable);
  let result = fragment;
  drops.forEach(n => {
    const path = result.getPath(n.key);

    if (path) {
      result = result.removeNode(path);
    }
  });
  return result;
}

function adjustClipboardTableWithSelection(clipboardTable, selection) {
  const {
    startRowIndex,
    startColIndex,
    endRowIndex,
    endColIndex
  } = selection;
  const width = endColIndex - startColIndex + 1;
  const height = endRowIndex - startRowIndex + 1;
  return _models.default.create({
    data: clipboardTable.data,
    nodes: clipboardTable.nodes.slice(0, height).map(row => _tableRow.default.create({
      data: row.data,
      // @ts-ignore
      nodes: row.nodes.slice(0, width)
    }))
  });
}

function getAdjustTableColsWidth(table) {
  const data = table.data || {};
  let {
    colsWidth
  } = data;

  if (!Array.isArray(colsWidth)) {
    colsWidth = [];
  } // 自适应表格不做矫正


  if (_models.default.isAutofitWidth(table)) return colsWidth;
  return colsWidth.map(cw => Math.max(cw, _constants.MIN_COL_WIDTH));
}
//# sourceMappingURL=handleCangjiePaste.js.map