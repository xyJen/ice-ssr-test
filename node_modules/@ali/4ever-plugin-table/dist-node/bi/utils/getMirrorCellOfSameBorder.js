"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getMirrorCellOfSameBorder;

var _getPositionOfCell = _interopRequireDefault(require("./getPositionOfCell"));

// mirrorCell可以是hiddenCell，可能合并单元格时没有实质效果，但解除合并时会有效果
function getMirrorCellOfSameBorder(currentCell, orientation, table) {
  const position = (0, _getPositionOfCell.default)(currentCell.key, table);
  const colSpan = currentCell.data.colSpan && (currentCell.data.colSpan || 1);
  const rowSpan = currentCell.data.rowSpan && (currentCell.data.rowSpan || 1);
  let mirrorCell = null;

  if (!position) {
    return null;
  }

  const {
    rowIndex,
    colIndex
  } = position;

  if (orientation === 'left') {
    if (colIndex <= 0) {
      return null;
    }

    const targetRow = table.nodes[rowIndex];
    if (!targetRow) return null; // @ts-ignore

    mirrorCell = targetRow.nodes[colIndex - 1]; // 注释留着，暂时不用这个方法，供以后参考
    // if (mirrorCell.data.hidden) {
    //   mirrorCell = getRealNodeInTable(table, rowIndex, colIndex - 1);
    // }
  } else if (orientation === 'right') {
    // @ts-ignore
    const colSize = table.nodes[0].nodes.length;

    if (colIndex + colSpan >= colSize) {
      return null;
    }

    const targetRow = table.nodes[rowIndex];
    if (!targetRow) return null; // @ts-ignore

    mirrorCell = targetRow.nodes[colIndex + colSpan];
  } else if (orientation === 'top') {
    if (rowIndex <= 0) {
      return null;
    } // @ts-ignore


    mirrorCell = table.nodes[rowIndex - 1].nodes[colIndex]; // if (mirrorCell.data.hidden) {
    //   mirrorCell = getRealNodeInTable(table, rowIndex - 1, colIndex);
    // }
  } else if (orientation === 'bottom') {
    const rowSize = table.nodes.length;

    if (rowIndex + rowSpan >= rowSize) {
      return null;
    }

    const targetRow = table.nodes[rowIndex + rowSpan];
    if (!targetRow) return null; // @ts-ignore

    mirrorCell = targetRow.nodes[colIndex];
  } // if (mirrorCell && mirrorCell.data.hidden) {
  //   return null;
  // }


  return mirrorCell;
}
//# sourceMappingURL=getMirrorCellOfSameBorder.js.map