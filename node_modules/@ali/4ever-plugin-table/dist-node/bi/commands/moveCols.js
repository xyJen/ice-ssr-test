"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = moveCols;

var _everCangjie = require("@ali/4ever-cangjie");

var _getPositionOfCell = _interopRequireDefault(require("../utils/getPositionOfCell"));

var _getRealNodeInTable = _interopRequireDefault(require("../utils/getRealNodeInTable"));

var _setTableColsWidth = _interopRequireDefault(require("../utils/setTableColsWidth"));

const setCellData = (controller, cell, data) => {
  return controller.command(_everCangjie.Commands.setNodeByKey, cell.key, {
    data: { ...cell.data,
      ...data
    }
  });
};

function moveCols(controller, table, originIndexRange, targetIndex) {
  if (!table || !Array.isArray(table.data?.colsWidth) || !table.nodes) {
    return controller;
  }

  const {
    start,
    end
  } = originIndexRange;
  const direction = end < targetIndex ? 'forward' : 'backward';
  controller.withoutNormalizing(() => {
    const tablePath = controller.value.document.assertPath(table.key);
    table.nodes.forEach((tr, rowIndex) => {
      if (!tr.nodes) {
        return;
      }

      const trPath = tablePath.concat(rowIndex);

      for (let offset = 0; start + offset <= end; offset++) {
        const cellPath = trPath.concat(start + (direction === 'forward' ? 0 : offset));
        const index = direction === 'forward' ? targetIndex - 1 : targetIndex + offset;
        controller.command(_everCangjie.Commands.moveNodeByPath, cellPath, trPath, index);
      }

      for (let colIndex = start; colIndex <= end; colIndex++) {
        const cell = tr.nodes[colIndex];

        if (!cell) {
          return;
        }

        const {
          colSpan = 1,
          hidden
        } = cell.data;

        if (!hidden && colSpan > 1) {
          // 遇到合并单元格时，分为 2 种情况
          // 1. 合并单元格完全在移动列内，不处理
          // 2. 合并单元格被拆分为两部分，调整对应单元格 colSpan
          const colIndexOfLastOfMergedCell = colIndex + cell.data.colSpan - 1; // 处理情况 2

          if (colIndexOfLastOfMergedCell > end) {
            // 更新合并单元格（realCell）colSpan
            setCellData(controller, cell, {
              colSpan: end - colIndex + 1
            });
            const rightCellOfFirstRowOfMoveCols = tr.nodes[end + 1];
            setCellData(controller, rightCellOfFirstRowOfMoveCols, {
              colSpan: colIndexOfLastOfMergedCell - end,
              rowSpan: cell.data.rowSpan,
              hidden: false
            });
          }

          colIndex += colSpan - 1;
        } else if (hidden) {
          // 遇到 hidden 单元格时，分为 2 种情况
          // 1. 与合并单元格（realCell）不在同一行时，不处理
          // 2. 合并单元格被拆分为 2 部分，调整对应单元格 colSpan
          const realCell = (0, _getRealNodeInTable.default)(table, rowIndex, colIndex);

          if (!realCell) {
            return;
          }

          const position = (0, _getPositionOfCell.default)(realCell.key, table);
          const colIndexOfLastOfMergedCell = position.colIndex + realCell.data.colSpan - 1; // 情况 2

          if (position.rowIndex === rowIndex) {
            // 更新合并单元格右侧 hidden 单元格 colSpan
            const deltaColSpan = Math.min(colIndexOfLastOfMergedCell, end) - colIndex + 1;
            setCellData(controller, cell, {
              colSpan: deltaColSpan,
              rowSpan: realCell.data.rowSpan || 1,
              hidden: false
            }); // 更新合并单元格 colSpan

            setCellData(controller, realCell, {
              colSpan: realCell.data.colSpan - deltaColSpan
            });
          } // 当前行后面的 hidden 单元格可以跳过


          colIndex = colIndexOfLastOfMergedCell;
        }
      }
    }); // 更新 colsWidth

    const colsWidth = [...table.data.colsWidth];
    const moveColsWidth = colsWidth.slice(start, end + 1);
    const moveColsLength = end - start + 1;
    colsWidth.splice(start, moveColsLength);
    const index = start < targetIndex ? targetIndex - moveColsLength : targetIndex;
    colsWidth.splice(index, 0, ...moveColsWidth);
    (0, _setTableColsWidth.default)(controller, table, colsWidth);
  });
  return controller;
}
//# sourceMappingURL=moveCols.js.map