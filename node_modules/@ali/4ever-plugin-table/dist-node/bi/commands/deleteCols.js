"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = deleteCols;

var _everCangjie = require("@ali/4ever-cangjie");

var _models = _interopRequireDefault(require("../../mo/models"));

var _isEmptyTable = _interopRequireDefault(require("../utils/isEmptyTable"));

var _getRealNodeInTable = _interopRequireDefault(require("../utils/getRealNodeInTable"));

var _getPositionOfCell = _interopRequireDefault(require("../utils/getPositionOfCell"));

var _traverseSingleColCells = _interopRequireDefault(require("../utils/traverseSingleColCells"));

var _deleteTable = _interopRequireDefault(require("./deleteTable"));

var _utils = require("../utils");

var _logger = require("../utils/logger");

var _getDataTableSelectionByTable = _interopRequireDefault(require("../utils/getDataTableSelectionByTable"));

var _setSelectionByTable = _interopRequireDefault(require("../../utils/utils/setSelectionByTable"));

var _resizeTableToAutofitWidth = _interopRequireDefault(require("./resizeTableToAutofitWidth"));

var _toggleColHeader = _interopRequireDefault(require("./toggleColHeader"));

var _filterValidData = _interopRequireDefault(require("../../utils/utils/filterValidData"));

/* eslint-disable no-shadow */
function deleteCol(controller, table, tablePath, colIndex) {
  (0, _traverseSingleColCells.default)(table, colIndex, colIndex, (rowIndex, _, cell) => {
    if (!cell) {
      (0, _logger.logNPEInfo)(table, {
        type: 'deleteCol',
        colIndex,
        rowIndex
      });
    } // 不规则表格 cell 可能为空
    // 这里支持用户手动删除不规则的列，使表格变为规则表格


    if (!cell) {
      return;
    }

    const cellData = cell.data || {};

    if (cellData.hidden) {
      const realNode = (0, _getRealNodeInTable.default)(table, rowIndex, colIndex);

      if (!realNode) {
        return;
      }

      const position = (0, _getPositionOfCell.default)(realNode.key, table);

      if (position.rowIndex === rowIndex && position.colIndex < colIndex) {
        controller.command(_everCangjie.Commands.setNodeByPath, [...tablePath, position.rowIndex, position.colIndex], {
          data: { ...realNode.data,
            colSpan: (realNode.data.colSpan || 1) - 1
          }
        });
      }
    } else if ((cellData.colSpan || 1) > 1) {
      const inheritCellPath = [...tablePath, rowIndex, colIndex + 1];
      controller.command(_everCangjie.Commands.setNodeByPath, inheritCellPath, {
        data: { ...cellData,
          colSpan: (cellData.colSpan || 1) - 1
        }
      });
    }

    controller.withoutNormalizing(c => {
      c.command(_everCangjie.Commands.removeNodeByPath, [...tablePath, rowIndex, colIndex]);
    });
  });
}

function deleteCols(controller, table) {
  const {
    value
  } = controller;
  const {
    document,
    selection
  } = value;
  let tableSelection = (0, _getDataTableSelectionByTable.default)(controller, table);

  if (!tableSelection) {
    tableSelection = (0, _utils.createTableSelectionForFocusedCell)(value, table);
  }

  if (!tableSelection) {
    return controller;
  }

  const {
    startColIndex,
    endColIndex
  } = tableSelection || {};
  const tablePath = document.getPath(table.key);

  for (let colIndex = endColIndex; colIndex >= startColIndex; colIndex -= 1) {
    const updatedTable = controller.value.document.getNodeByPath(tablePath);
    deleteCol(controller, updatedTable, tablePath, colIndex);

    if (_models.default.isColumnHeader(updatedTable) && colIndex === 0) {
      (0, _toggleColHeader.default)(controller, updatedTable);
    }
  }

  const updatedTable = controller.value.document.getNodeByPath(tablePath);

  if ((0, _isEmptyTable.default)(updatedTable)) {
    return controller.command(_deleteTable.default, updatedTable);
  }

  const colsWidth = updatedTable.data.colsWidth || [];
  controller.command(_everCangjie.Commands.setNodeByPath, tablePath, {
    data: (0, _filterValidData.default)({ ...updatedTable.data,
      colsWidth: [...colsWidth.slice(0, startColIndex), ...colsWidth.slice(endColIndex + 1)]
    })
  });

  if (_models.default.isAutofitWidth(updatedTable)) {
    const newTable = controller.value.document.getNodeByPath(tablePath);
    (0, _resizeTableToAutofitWidth.default)(controller, newTable, updatedTable);
  }

  const latestTable = controller.value.document.getNodeByPath(tablePath);
  const colSize = latestTable.data.colsWidth.length;
  const selectedColIndex = startColIndex >= colSize ? colSize - 1 : startColIndex; // 删除列后 focus 在所删列的前一列的第一个单元格内

  for (let i = 0; i < latestTable.nodes.length; i += 1) {
    const focusCell = (0, _getRealNodeInTable.default)(latestTable, i, selectedColIndex);

    if (focusCell) {
      const s = (0, _setSelectionByTable.default)(selection, false).moveToStartOfNode(focusCell, controller);
      return controller.command(_everCangjie.Commands.select, s);
    }
  }

  return controller;
}
//# sourceMappingURL=deleteCols.js.map