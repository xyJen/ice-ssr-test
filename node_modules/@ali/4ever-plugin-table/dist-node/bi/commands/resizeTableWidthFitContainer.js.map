{"version":3,"sources":["../../../../src/bi/commands/resizeTableWidthFitContainer.ts"],"names":["resizeTableWidthFitContainer","controller","table","containerWidth","view","colsWidth","data","totalColsWidth","reduce","acc","curr"],"mappings":";;;;;;;;;AAEA;;AACA;;AAEe,SAASA,4BAAT,CAAsCC,UAAtC,EAA8DC,KAA9D,EAA4EC,cAA5E,EAAqG;AAClH,QAAM;AAAEC,IAAAA;AAAF,MAAWH,UAAjB;AACA,QAAMI,SAAS,GAAG,CAAC,IAAIH,KAAK,CAACI,IAAN,CAAWD,SAAX,IAAwB,EAA5B,CAAD,CAAlB;AACA,QAAME,cAAc,GAAGF,SAAS,CAACG,MAAV,CAAiB,CAACC,GAAD,EAAMC,IAAN,KAAgBD,GAAG,GAAGC,IAAvC,EAA8C,CAA9C,CAAvB,CAHkH,CAKlH;AACA;AACA;AACA;AACA;;AAEA,MAAI,CAACP,cAAL,EAAqB;AACnBA,IAAAA,cAAc,GAAG,0CAA4BF,UAA5B,EAAwCC,KAAxC,CAAjB;AACD;;AAED,SAAO,+BAAiBD,UAAjB,EAA6BC,KAA7B,EAAoCC,cAAc,GAAGI,cAArD,CAAP;AACD","sourcesContent":["import { Controller } from '@ali/4ever-cangjie';\nimport Table from '../../mo/models';\nimport resizeTableWidth from './resizeTableWidth';\nimport getTableMaxWidthByContainer from '../../utils/utils/getTableMaxWidthByContainer';\n\nexport default function resizeTableWidthFitContainer(controller: Controller, table: Table, containerWidth?: number) {\n  const { view } = controller;\n  const colsWidth = [...(table.data.colsWidth || [])];\n  const totalColsWidth = colsWidth.reduce((acc, curr) => (acc + curr), 0);\n\n  // 此处如果基于dataModel来寻找父节点，然后基于其宽度来进行resize会有一个问题\n  // 因为从dataModel到viewModel的映射过程不是完全一一对应的，因为在viewModel中会由于标题的存在而导致部分节点被 group 包裹\n  // 因此dataModel中离某个节点最近的父节点，在viewModel中其最近的父节点就变成了将其包裹的 group 节点\n  // 如果group节点设置了padding，就可能会导致基于dataModel找到的最近父节点宽度大于当前table的最大可视宽度，如果基于该宽度来调整table宽度\n  // 则会导致table出现滚动条。因此需要基于viewModel下来寻找table的最近父节点，因为其宽度不会包括padding的宽度，不会导致调整后出现滚动条\n\n  if (!containerWidth) {\n    containerWidth = getTableMaxWidthByContainer(controller, table);\n  }\n\n  return resizeTableWidth(controller, table, containerWidth - totalColsWidth);\n}\n"],"file":"resizeTableWidthFitContainer.js"}