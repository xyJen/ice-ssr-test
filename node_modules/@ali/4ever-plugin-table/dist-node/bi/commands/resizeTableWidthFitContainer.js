"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = resizeTableWidthFitContainer;

var _resizeTableWidth = _interopRequireDefault(require("./resizeTableWidth"));

var _getTableMaxWidthByContainer = _interopRequireDefault(require("../../utils/utils/getTableMaxWidthByContainer"));

function resizeTableWidthFitContainer(controller, table, containerWidth) {
  const {
    view
  } = controller;
  const colsWidth = [...(table.data.colsWidth || [])];
  const totalColsWidth = colsWidth.reduce((acc, curr) => acc + curr, 0); // 此处如果基于dataModel来寻找父节点，然后基于其宽度来进行resize会有一个问题
  // 因为从dataModel到viewModel的映射过程不是完全一一对应的，因为在viewModel中会由于标题的存在而导致部分节点被 group 包裹
  // 因此dataModel中离某个节点最近的父节点，在viewModel中其最近的父节点就变成了将其包裹的 group 节点
  // 如果group节点设置了padding，就可能会导致基于dataModel找到的最近父节点宽度大于当前table的最大可视宽度，如果基于该宽度来调整table宽度
  // 则会导致table出现滚动条。因此需要基于viewModel下来寻找table的最近父节点，因为其宽度不会包括padding的宽度，不会导致调整后出现滚动条

  if (!containerWidth) {
    containerWidth = (0, _getTableMaxWidthByContainer.default)(controller, table);
  }

  return (0, _resizeTableWidth.default)(controller, table, containerWidth - totalColsWidth);
}
//# sourceMappingURL=resizeTableWidthFitContainer.js.map