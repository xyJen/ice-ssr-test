"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = insertCol;

var _everCangjie = require("@ali/4ever-cangjie");

var _models = _interopRequireDefault(require("../../mo/models"));

var _createEmptyTableCell = _interopRequireDefault(require("../utils/createEmptyTableCell"));

var _getRealNodeInTable = _interopRequireDefault(require("../utils/getRealNodeInTable"));

var _getPositionOfCell = _interopRequireDefault(require("../utils/getPositionOfCell"));

var _traverseSingleColCells = _interopRequireDefault(require("../utils/traverseSingleColCells"));

var _resizeTableWidthFitContainer = _interopRequireDefault(require("./resizeTableWidthFitContainer"));

var _getVisibleCellOfCol = _interopRequireDefault(require("../utils/getVisibleCellOfCol"));

var _setTableColsWidth = _interopRequireDefault(require("../utils/setTableColsWidth"));

var _setSelectionByTable = _interopRequireDefault(require("../../utils/utils/setSelectionByTable"));

var _resizeTableToAutofitWidth = _interopRequireDefault(require("./resizeTableToAutofitWidth"));

var _getTableMaxWidthByContainer = _interopRequireDefault(require("../../utils/utils/getTableMaxWidthByContainer"));

function insertCol(controller, table, targetColIndex, triggerColIndex, colWidth, containerWidth) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const tablePath = document.getPath(table.key);
  controller.withoutNormalizing(() => {
    (0, _traverseSingleColCells.default)(table, targetColIndex, triggerColIndex, (rowIndex, finalIndex, triggerCell, originalCell) => {
      const data = {}; // triggerCell: 右键在哪个上面哪个就是triggerCell
      // originalCell: 插入后新行的index，放在之前表格取的值，就是originalCell(可能不存在)

      if (triggerCell) {
        const triggerCellData = triggerCell.data;

        if (triggerCellData && triggerCellData.bdr) {
          data.bdr = triggerCellData.bdr;
        }

        if (triggerCellData && triggerCellData.fill) {
          data.fill = triggerCellData.fill;
        }
      } // 一种策略，originalCell是插入新列位置对应的原来的节点
      // 这个节点如果处在realNode所在列后面的列(非同列)，那在这个位置上的新节点就会设置为hidden
      // 同时比较rowIndex以保证realNode的colSpan只被拓充一次


      if (originalCell && originalCell.data.hidden) {
        const realNode = (0, _getRealNodeInTable.default)(table, rowIndex, finalIndex);

        if (realNode) {
          const position = (0, _getPositionOfCell.default)(realNode.key, table);

          if (position.colIndex !== finalIndex) {
            data.hidden = true;
          }

          if (position.rowIndex === rowIndex) {
            controller.command(_everCangjie.Commands.setNodeByPath, [...tablePath, position.rowIndex, position.colIndex], {
              data: { ...realNode.data,
                colSpan: (realNode.data.colSpan || 1) + 1
              }
            });
          }
        }
      }

      controller.command(_everCangjie.Commands.insertNodeByPath, [...tablePath, rowIndex], finalIndex, (0, _createEmptyTableCell.default)(data));
    });
  });
  const colsWidth = [...table.data.colsWidth];
  const originalTotalColsWidth = colsWidth.reduce((acc, curr) => acc + curr, 0); // 未传入有效宽度则手动计算

  if (!colWidth) {
    const refColIndex = targetColIndex === colsWidth.length ? targetColIndex - 1 : targetColIndex;
    const refColWidth = colsWidth[refColIndex];
    colWidth = refColWidth;
  }

  colsWidth.splice(targetColIndex, 0, colWidth);
  const totalColsWidth = colsWidth.reduce((acc, curr) => acc + curr, 0);
  (0, _setTableColsWidth.default)(controller, table, colsWidth);

  if (_models.default.isAutofitWidth(table)) {
    const newTable = controller.value.document.getNodeByPath(tablePath);
    (0, _resizeTableToAutofitWidth.default)(controller, newTable, table, containerWidth);
  } else {
    const containerW = containerWidth || (0, _getTableMaxWidthByContainer.default)(controller, table);

    if (totalColsWidth >= containerW && originalTotalColsWidth <= containerW) {
      const updatedDoc = controller.value.document;
      const updatedTbl = updatedDoc.getNodeByPath(tablePath);
      (0, _resizeTableWidthFitContainer.default)(controller, updatedTbl, containerW);
    }
  }

  const latestTable = controller.value.document.getNodeByPath(tablePath);
  let focusCell = (0, _getVisibleCellOfCol.default)(latestTable, targetColIndex);

  if (!focusCell) {
    focusCell = (0, _getRealNodeInTable.default)(latestTable, 0, targetColIndex);
  }

  if (focusCell) {
    const s = controller.value.selection;
    return controller.command(_everCangjie.Commands.select, (0, _setSelectionByTable.default)(s, false)).command(_everCangjie.Commands.moveToStartOfNode, focusCell);
  }

  return controller;
}
//# sourceMappingURL=insertCol.js.map