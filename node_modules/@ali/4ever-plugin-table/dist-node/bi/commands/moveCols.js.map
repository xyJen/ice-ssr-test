{"version":3,"sources":["../../../../src/bi/commands/moveCols.ts"],"names":["setCellData","controller","cell","data","command","Commands","setNodeByKey","key","moveCols","table","originIndexRange","targetIndex","Array","isArray","colsWidth","nodes","start","end","direction","withoutNormalizing","tablePath","value","document","assertPath","forEach","tr","rowIndex","trPath","concat","offset","cellPath","index","moveNodeByPath","colIndex","colSpan","hidden","colIndexOfLastOfMergedCell","rightCellOfFirstRowOfMoveCols","rowSpan","realCell","position","deltaColSpan","Math","min","moveColsWidth","slice","moveColsLength","splice"],"mappings":"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","sourcesContent":["import { Controller, Commands } from '@ali/4ever-cangjie';\nimport Table from '../../mo/models';\nimport TableCell from '../../mo/models/tableCell';\nimport getPositionOfCell from '../utils/getPositionOfCell';\nimport getRealNodeInTable from '../utils/getRealNodeInTable';\nimport setTableColsWidth from '../utils/setTableColsWidth';\n\nconst setCellData = (\n  controller: Controller,\n  cell: TableCell,\n  data: TableCell['data'],\n) => {\n  return controller.command(\n    Commands.setNodeByKey,\n    cell.key,\n    {\n      data: {\n        ...cell.data,\n        ...data,\n      },\n    },\n  );\n};\n\nexport default function moveCols(\n  controller: Controller,\n  table: Table,\n  originIndexRange: {\n    start: number;\n    end: number;\n  },\n  targetIndex: number,\n) {\n  if (\n    !table ||\n    !Array.isArray(table.data?.colsWidth) ||\n    !table.nodes\n  ) {\n    return controller;\n  }\n  const { start, end } = originIndexRange;\n  const direction = end < targetIndex ? 'forward' : 'backward';\n  controller.withoutNormalizing(() => {\n    const tablePath = controller.value.document.assertPath(table.key);\n    table.nodes.forEach((tr, rowIndex) => {\n      if (!tr.nodes) {\n        return;\n      }\n      const trPath = tablePath.concat(rowIndex);\n      for (let offset = 0; start + offset <= end; offset++) {\n        const cellPath = trPath.concat(start + (direction === 'forward' ? 0 : offset));\n        const index = direction === 'forward' ? targetIndex - 1 : targetIndex + offset;\n        controller.command(\n          Commands.moveNodeByPath,\n          cellPath,\n          trPath,\n          index,\n        );\n      }\n      for (let colIndex = start; colIndex <= end; colIndex++) {\n        const cell = tr.nodes[colIndex];\n        if (!cell) {\n          return;\n        }\n        const { colSpan = 1, hidden } = cell.data;\n        if (!hidden && colSpan > 1) {\n          // 遇到合并单元格时，分为 2 种情况\n          // 1. 合并单元格完全在移动列内，不处理\n          // 2. 合并单元格被拆分为两部分，调整对应单元格 colSpan\n          const colIndexOfLastOfMergedCell = colIndex + cell.data.colSpan! - 1;\n          // 处理情况 2\n          if (colIndexOfLastOfMergedCell > end) {\n            // 更新合并单元格（realCell）colSpan\n            setCellData(\n              controller,\n              cell,\n              {\n                colSpan: end - colIndex + 1,\n              },\n            );\n            const rightCellOfFirstRowOfMoveCols = tr.nodes[end + 1];\n            setCellData(\n              controller,\n              rightCellOfFirstRowOfMoveCols,\n              {\n                colSpan: colIndexOfLastOfMergedCell - end,\n                rowSpan: cell.data.rowSpan!,\n                hidden: false,\n              },\n            );\n          }\n          colIndex += colSpan - 1;\n        } else if (hidden) {\n          // 遇到 hidden 单元格时，分为 2 种情况\n          // 1. 与合并单元格（realCell）不在同一行时，不处理\n          // 2. 合并单元格被拆分为 2 部分，调整对应单元格 colSpan\n          const realCell = getRealNodeInTable(table, rowIndex, colIndex);\n          if (!realCell) {\n            return;\n          }\n          const position = getPositionOfCell(realCell.key, table)!;\n          const colIndexOfLastOfMergedCell =\n            position.colIndex + realCell.data.colSpan! - 1;\n          // 情况 2\n          if (position.rowIndex === rowIndex) {\n            // 更新合并单元格右侧 hidden 单元格 colSpan\n            const deltaColSpan =\n              Math.min(colIndexOfLastOfMergedCell, end) - colIndex + 1;\n            setCellData(\n              controller,\n              cell,\n              {\n                colSpan: deltaColSpan,\n                rowSpan: realCell.data.rowSpan || 1,\n                hidden: false,\n              },\n            );\n            // 更新合并单元格 colSpan\n            setCellData(\n              controller,\n              realCell,\n              {\n                colSpan: realCell.data.colSpan! - deltaColSpan,\n              },\n            );\n          }\n          // 当前行后面的 hidden 单元格可以跳过\n          colIndex = colIndexOfLastOfMergedCell;\n        }\n      }\n    });\n    // 更新 colsWidth\n    const colsWidth = [...table.data.colsWidth!];\n    const moveColsWidth = colsWidth.slice(start, end + 1);\n    const moveColsLength = end - start + 1;\n    colsWidth.splice(start, moveColsLength);\n    const index = start < targetIndex ?\n      targetIndex - moveColsLength :\n      targetIndex;\n    colsWidth.splice(index, 0, ...moveColsWidth);\n    setTableColsWidth(controller, table, colsWidth);\n  });\n  return controller;\n}\n"],"file":"moveCols.js"}