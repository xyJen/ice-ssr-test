"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = insertRow;

var _everCangjie = require("@ali/4ever-cangjie");

var _createTableRow = _interopRequireDefault(require("../utils/createTableRow"));

var _getPositionOfRow = _interopRequireDefault(require("../utils/getPositionOfRow"));

var _getRealNodeInTable = _interopRequireDefault(require("../utils/getRealNodeInTable"));

var _getPositionOfCell = _interopRequireDefault(require("../utils/getPositionOfCell"));

var _traverseSingleRowCells = _interopRequireDefault(require("../utils/traverseSingleRowCells"));

var _types = require("../types");

var _getVisibleCellOfRow = _interopRequireDefault(require("../utils/getVisibleCellOfRow"));

var _setSelectionByTable = _interopRequireDefault(require("../../utils/utils/setSelectionByTable"));

/* eslint-disable no-shadow */
function insertRow(controller, tableRow, type) {
  const {
    value
  } = controller;
  const {
    document
  } = value;
  const table = document.getClosest(tableRow.key, _types.isTable);
  const tablePath = document.getPath(table.key);
  const triggerRowIndex = (0, _getPositionOfRow.default)(tableRow.key, table);
  let targetRowIndex;
  const colSize = tableRow.nodes.length;

  if (type === 'insert-row-above') {
    targetRowIndex = triggerRowIndex;
  } else if (type === 'insert-row-below') {
    targetRowIndex = triggerRowIndex + 1;
  }

  const newTableRow = (0, _createTableRow.default)(colSize, tableRow);
  controller.command(_everCangjie.Commands.insertNodeByPath, tablePath, targetRowIndex, newTableRow);
  (0, _traverseSingleRowCells.default)(table, targetRowIndex, triggerRowIndex, (_targetRowIndex, colIndex, _, originalCell) => {
    // 一种策略，originalCell是插入新行位置对应的原来的节点(可能不存在)
    // 这个节点如果处在realNode所在行的后面的行(非同行)，那在这个位置上的新节点就会设置为hidden
    // 同时比较colIndex以保证realNode的rowSpan只被拓充一次
    if (originalCell && originalCell.data.hidden) {
      const realNode = (0, _getRealNodeInTable.default)(table, _targetRowIndex, colIndex);

      if (!realNode) {
        return;
      }

      const position = (0, _getPositionOfCell.default)(realNode.key, table);

      if (position.rowIndex !== _targetRowIndex) {
        // TODO: 数据处理好再统一塞进去
        const newCell = newTableRow.nodes[colIndex];
        controller.command(_everCangjie.Commands.setNodeByPath, [...tablePath, _targetRowIndex, colIndex], {
          data: { ...newCell.data,
            hidden: true
          }
        });
      }

      if (position.colIndex === colIndex) {
        controller.command(_everCangjie.Commands.setNodeByPath, [...tablePath, position.rowIndex, position.colIndex], {
          data: { ...realNode.data,
            rowSpan: (realNode.data.rowSpan || 1) + 1
          }
        });
      }
    }
  });
  const latestTable = controller.value.document.getNodeByPath(tablePath);
  let focusCell = (0, _getVisibleCellOfRow.default)(latestTable, targetRowIndex);

  if (!focusCell) {
    focusCell = (0, _getRealNodeInTable.default)(latestTable, targetRowIndex, 0);
  }

  const s = controller.value.selection;
  return controller.command(_everCangjie.Commands.select, (0, _setSelectionByTable.default)(s, false)).command(_everCangjie.Commands.moveToStartOfNode, focusCell);
}
//# sourceMappingURL=insertRow.js.map