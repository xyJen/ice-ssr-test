"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = setTableBorder;

var _everCangjie = require("@ali/4ever-cangjie");

var _everUtils = require("@ali/4ever-utils");

var _getMirrorCellOfSameBorder = _interopRequireDefault(require("../utils/getMirrorCellOfSameBorder"));

function generateBorderInfo(tableSelection, table) {
  const result = {
    leftOutline: [],
    rightOutline: [],
    topOutline: [],
    bottomOutline: [],
    leftInline: [],
    rightInline: [],
    topInline: [],
    bottomInline: []
  };
  const {
    startRowIndex,
    endRowIndex,
    startColIndex,
    endColIndex
  } = tableSelection;

  for (let rowIndex = startRowIndex; rowIndex <= endRowIndex; rowIndex += 1) {
    const row = table.nodes[rowIndex];
    if (!row) continue; // eslint-disable-line no-continue

    for (let colIndex = startColIndex; colIndex <= endColIndex; colIndex += 1) {
      const cell = row.nodes[colIndex];
      if (!cell) continue; // eslint-disable-line no-continue

      if (cell.data.hidden) continue;
      const colSpan = cell.data.colSpan || 1;
      const rowSpan = cell.data.rowSpan || 1;

      if (colIndex === startColIndex) {
        result.leftOutline.push(cell.key);
      } else {
        result.leftInline.push(cell.key);
      }

      if (colIndex + colSpan === endColIndex + 1) {
        result.rightOutline.push(cell.key);
      } else {
        result.rightInline.push(cell.key);
      }

      if (rowIndex === startRowIndex) {
        result.topOutline.push(cell.key);
      } else {
        result.topInline.push(cell.key);
      }

      if (rowIndex + rowSpan === endRowIndex + 1) {
        result.bottomOutline.push(cell.key);
      } else {
        result.bottomInline.push(cell.key);
      }
    }
  }

  return result;
}

const mirrorObj = {
  left: 'right',
  right: 'left',
  top: 'bottom',
  bottom: 'top'
};
const defaultBdr = {
  left: null,
  right: null,
  top: null,
  bottom: null
};

function setBorderData(controller, cell, key, options) {
  const {
    orientation,
    isIncluded,
    val,
    sz,
    color
  } = options;
  const oldBdr = cell.data.bdr || {};
  const newBdr = { ...oldBdr,
    [orientation]: isIncluded ? {
      color,
      sz,
      val
    } : null
  };

  if (!(0, _everUtils.isEqualWithDefault)(oldBdr, newBdr, defaultBdr)) {
    controller.command(_everCangjie.Commands.setNodeByKey, cell.key, {
      data: { ...cell.data,
        bdr: newBdr
      }
    });
  }
}

function setTableBorder(controller, table, selection, borderSetType, color, sz, val) {
  if (!selection) {
    return controller;
  }

  const borderInfo = generateBorderInfo(selection, table); // all, outline, inside, left, top, right, bottom, innerHorizontal, innerVertical,

  const filterObj = {
    none: [],
    all: ['leftOutline', 'rightOutline', 'topOutline', 'bottomOutline', 'leftInline', 'rightInline', 'topInline', 'bottomInline'],
    outer: ['leftOutline', 'rightOutline', 'topOutline', 'bottomOutline'],
    inner: ['leftInline', 'rightInline', 'topInline', 'bottomInline'],
    left: ['leftOutline'],
    top: ['topOutline'],
    right: ['rightOutline'],
    bottom: ['bottomOutline'],
    horizon: ['topInline', 'bottomInline'],
    vertical: ['leftInline', 'rightInline']
  };
  Object.keys(borderInfo).forEach(type => {
    const keysByType = borderInfo[type];
    const matched = type.match(/(\w+)([A-Z]\w+)/);

    if (!matched) {
      return;
    }

    const orientation = matched[1];
    const inlineOrOutline = matched[2].toLowerCase();
    const mirrorOrientation = mirrorObj[orientation];
    const isOutlineIncluded = inlineOrOutline === 'outline' && filterObj[borderSetType].includes(`${orientation}Outline`);
    const isInlineIncluded = inlineOrOutline === 'inline' && filterObj[borderSetType].includes(`${orientation}Inline`);
    const isIncluded = isOutlineIncluded || isInlineIncluded;
    keysByType.forEach(key => {
      const tableCell = controller.value.document.getNode(key);
      const updatedTable = controller.value.document.getNode(table.key); // none比较特殊，是清空效果，其他的都是叠加效果

      if (isIncluded || borderSetType === 'none') {
        setBorderData(controller, tableCell, key, {
          color,
          sz,
          val,
          orientation,
          isIncluded
        });
      }

      if ((isOutlineIncluded || borderSetType === 'none') && inlineOrOutline === 'outline') {
        const mirrorCell = (0, _getMirrorCellOfSameBorder.default)(tableCell, orientation, updatedTable);

        if (mirrorCell) {
          setBorderData(controller, mirrorCell, mirrorCell.key, {
            color,
            sz,
            val,
            orientation: mirrorOrientation,
            isIncluded: isOutlineIncluded
          });
        }
      }
    });
  });
  return controller;
}
//# sourceMappingURL=setTableBorder.js.map