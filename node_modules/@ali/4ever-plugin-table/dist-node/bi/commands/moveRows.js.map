{"version":3,"sources":["../../../../src/bi/commands/moveRows.ts"],"names":["setCellData","controller","cell","data","command","Commands","setNodeByKey","key","moveRows","table","originIndexRange","targetIndex","Array","isArray","colsWidth","nodes","start","end","withoutNormalizing","i","index","originTr","moveNodeByKey","maxColsLength","length","colIndex","rowIndex","row","rowSpan","hidden","rowIndexOfLastOfMergedCell","belowCellOfCurrentColOfMoveRows","colSpan","realCell","position","deltaRowSpan","Math","min"],"mappings":"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","sourcesContent":["import { Controller, Commands } from '@ali/4ever-cangjie';\nimport Table from '../../mo/models';\nimport TableCell from '../../mo/models/tableCell';\nimport getPositionOfCell from '../utils/getPositionOfCell';\nimport getRealNodeInTable from '../utils/getRealNodeInTable';\n\nconst setCellData = (\n  controller: Controller,\n  cell: TableCell,\n  data: TableCell['data'],\n) => {\n  return controller.command(\n    Commands.setNodeByKey,\n    cell.key,\n    {\n      data: {\n        ...cell.data,\n        ...data,\n      },\n    },\n  );\n};\n\nexport default function moveRows(\n  controller: Controller,\n  table: Table,\n  originIndexRange: {\n    start: number;\n    end: number;\n  },\n  targetIndex: number,\n) {\n  if (\n    !table ||\n    !Array.isArray(table.data?.colsWidth) ||\n    !table.nodes\n  ) {\n    return controller;\n  }\n  const { start, end } = originIndexRange;\n  controller.withoutNormalizing(() => {\n    for (let i = start; i <= end; i++) {\n      const index = i < targetIndex ?\n        targetIndex - 1 :\n        targetIndex + i - start;\n      const originTr = table.nodes[i];\n      if (!originTr) {\n        return;\n      }\n      controller.command(\n        Commands.moveNodeByKey,\n        originTr.key,\n        table.key,\n        index,\n      );\n    }\n\n    const maxColsLength = table.data.colsWidth!.length;\n    for (let colIndex = 0; colIndex < maxColsLength; colIndex++) {\n      for (let rowIndex = start; rowIndex <= end; rowIndex++) {\n        const row = table.nodes[rowIndex];\n        if (!row.nodes) {\n          return;\n        }\n        const cell = row.nodes[colIndex];\n        // 兼容不规则表格\n        if (!cell) {\n          continue;\n        }\n        const { rowSpan = 1, hidden } = cell.data;\n        if (!hidden && rowSpan > 1) {\n          // 遇到合并单元格时，分为 2 种情况\n          // 1. 合并单元格完全在移动行内，不处理\n          // 2. 合并单元格被拆分为两部分，调整对应单元格 rowSpan\n          const rowIndexOfLastOfMergedCell = rowIndex + cell.data.rowSpan! - 1;\n          // 处理情况 2\n          if (rowIndexOfLastOfMergedCell > end) {\n            // 更新合并单元格（realCell）colSpan\n            setCellData(\n              controller,\n              cell,\n              {\n                rowSpan: end - rowIndex + 1,\n              },\n            );\n            const belowCellOfCurrentColOfMoveRows = table.nodes[end + 1].nodes[colIndex];\n            setCellData(\n              controller,\n              belowCellOfCurrentColOfMoveRows,\n              {\n                rowSpan: rowIndexOfLastOfMergedCell - end,\n                colSpan: cell.data.colSpan!,\n                hidden: false,\n              },\n            );\n          }\n          rowIndex += rowSpan - 1;\n        } else if (hidden) {\n          // 遇到 hidden 单元格时，分为 2 种情况\n          // 1. 与合并单元格（realCell）不在同一列时，不处理\n          // 2. 合并单元格被拆分为 2 部分，调整对应单元格 rowSpan\n          const realCell = getRealNodeInTable(table, rowIndex, colIndex);\n          if (!realCell) {\n            return;\n          }\n          const position = getPositionOfCell(realCell.key, table)!;\n          const rowIndexOfLastOfMergedCell =\n            position.rowIndex + realCell.data.rowSpan! - 1;\n          // 情况 2\n          if (position.colIndex === colIndex) {\n            // 更新合并单元格右侧 hidden 单元格 colSpan\n            const deltaRowSpan =\n              Math.min(rowIndexOfLastOfMergedCell, end) - rowIndex + 1;\n            setCellData(\n              controller,\n              cell,\n              {\n                rowSpan: deltaRowSpan,\n                colSpan: realCell.data.colSpan || 1,\n                hidden: false,\n              },\n            );\n            // 更新合并单元格 rowSpan\n            setCellData(\n              controller,\n              realCell,\n              {\n                rowSpan: realCell.data.rowSpan! - deltaRowSpan,\n              },\n            );\n          }\n          // 当前行后面的 hidden 单元格可以跳过\n          rowIndex = rowIndexOfLastOfMergedCell;\n        }\n      }\n    }\n  });\n  return controller;\n}\n"],"file":"moveRows.js"}