"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = moveRows;

var _everCangjie = require("@ali/4ever-cangjie");

var _getPositionOfCell = _interopRequireDefault(require("../utils/getPositionOfCell"));

var _getRealNodeInTable = _interopRequireDefault(require("../utils/getRealNodeInTable"));

const setCellData = (controller, cell, data) => {
  return controller.command(_everCangjie.Commands.setNodeByKey, cell.key, {
    data: { ...cell.data,
      ...data
    }
  });
};

function moveRows(controller, table, originIndexRange, targetIndex) {
  if (!table || !Array.isArray(table.data?.colsWidth) || !table.nodes) {
    return controller;
  }

  const {
    start,
    end
  } = originIndexRange;
  controller.withoutNormalizing(() => {
    for (let i = start; i <= end; i++) {
      const index = i < targetIndex ? targetIndex - 1 : targetIndex + i - start;
      const originTr = table.nodes[i];

      if (!originTr) {
        return;
      }

      controller.command(_everCangjie.Commands.moveNodeByKey, originTr.key, table.key, index);
    }

    const maxColsLength = table.data.colsWidth.length;

    for (let colIndex = 0; colIndex < maxColsLength; colIndex++) {
      for (let rowIndex = start; rowIndex <= end; rowIndex++) {
        const row = table.nodes[rowIndex];

        if (!row.nodes) {
          return;
        }

        const cell = row.nodes[colIndex]; // 兼容不规则表格

        if (!cell) {
          continue;
        }

        const {
          rowSpan = 1,
          hidden
        } = cell.data;

        if (!hidden && rowSpan > 1) {
          // 遇到合并单元格时，分为 2 种情况
          // 1. 合并单元格完全在移动行内，不处理
          // 2. 合并单元格被拆分为两部分，调整对应单元格 rowSpan
          const rowIndexOfLastOfMergedCell = rowIndex + cell.data.rowSpan - 1; // 处理情况 2

          if (rowIndexOfLastOfMergedCell > end) {
            // 更新合并单元格（realCell）colSpan
            setCellData(controller, cell, {
              rowSpan: end - rowIndex + 1
            });
            const belowCellOfCurrentColOfMoveRows = table.nodes[end + 1].nodes[colIndex];
            setCellData(controller, belowCellOfCurrentColOfMoveRows, {
              rowSpan: rowIndexOfLastOfMergedCell - end,
              colSpan: cell.data.colSpan,
              hidden: false
            });
          }

          rowIndex += rowSpan - 1;
        } else if (hidden) {
          // 遇到 hidden 单元格时，分为 2 种情况
          // 1. 与合并单元格（realCell）不在同一列时，不处理
          // 2. 合并单元格被拆分为 2 部分，调整对应单元格 rowSpan
          const realCell = (0, _getRealNodeInTable.default)(table, rowIndex, colIndex);

          if (!realCell) {
            return;
          }

          const position = (0, _getPositionOfCell.default)(realCell.key, table);
          const rowIndexOfLastOfMergedCell = position.rowIndex + realCell.data.rowSpan - 1; // 情况 2

          if (position.colIndex === colIndex) {
            // 更新合并单元格右侧 hidden 单元格 colSpan
            const deltaRowSpan = Math.min(rowIndexOfLastOfMergedCell, end) - rowIndex + 1;
            setCellData(controller, cell, {
              rowSpan: deltaRowSpan,
              colSpan: realCell.data.colSpan || 1,
              hidden: false
            }); // 更新合并单元格 rowSpan

            setCellData(controller, realCell, {
              rowSpan: realCell.data.rowSpan - deltaRowSpan
            });
          } // 当前行后面的 hidden 单元格可以跳过


          rowIndex = rowIndexOfLastOfMergedCell;
        }
      }
    }
  });
  return controller;
}
//# sourceMappingURL=moveRows.js.map