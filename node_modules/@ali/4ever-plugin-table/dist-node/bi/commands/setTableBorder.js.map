{"version":3,"sources":["../../../../src/bi/commands/setTableBorder.ts"],"names":["generateBorderInfo","tableSelection","table","result","leftOutline","rightOutline","topOutline","bottomOutline","leftInline","rightInline","topInline","bottomInline","startRowIndex","endRowIndex","startColIndex","endColIndex","rowIndex","row","nodes","colIndex","cell","data","hidden","colSpan","rowSpan","push","key","mirrorObj","left","right","top","bottom","defaultBdr","setBorderData","controller","options","orientation","isIncluded","val","sz","color","oldBdr","bdr","newBdr","command","Commands","setNodeByKey","setTableBorder","selection","borderSetType","borderInfo","filterObj","none","all","outer","inner","horizon","vertical","Object","keys","forEach","type","keysByType","matched","match","inlineOrOutline","toLowerCase","mirrorOrientation","isOutlineIncluded","includes","isInlineIncluded","tableCell","value","document","getNode","updatedTable","mirrorCell"],"mappings":"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","sourcesContent":["import { Controller, Block, Commands, MoInterfaces } from '@ali/4ever-cangjie';\nimport Table from '../../mo/models';\nimport { isEqualWithDefault } from '@ali/4ever-utils';\nimport { ITableSelection } from '../types';\nimport getMirrorCellOfSameBorder from '../utils/getMirrorCellOfSameBorder';\n\nfunction generateBorderInfo(tableSelection: ITableSelection, table: Table) {\n  const result: Record<string, string[]> = {\n    leftOutline: [],\n    rightOutline: [],\n    topOutline: [],\n    bottomOutline: [],\n    leftInline: [],\n    rightInline: [],\n    topInline: [],\n    bottomInline: [],\n  };\n  const { startRowIndex, endRowIndex, startColIndex, endColIndex } = tableSelection;\n  for (let rowIndex = startRowIndex; rowIndex <= endRowIndex; rowIndex += 1) {\n    const row = table.nodes[rowIndex];\n    if (!row) continue; // eslint-disable-line no-continue\n\n    for (let colIndex = startColIndex; colIndex <= endColIndex; colIndex += 1) {\n      const cell = row.nodes[colIndex];\n      if (!cell) continue; // eslint-disable-line no-continue\n      if (cell.data.hidden) continue;\n\n      const colSpan = cell.data.colSpan || 1;\n      const rowSpan = cell.data.rowSpan || 1;\n\n      if (colIndex === startColIndex) {\n        result.leftOutline.push(cell.key);\n      } else {\n        result.leftInline.push(cell.key);\n      }\n      if (colIndex + colSpan === endColIndex + 1) {\n        result.rightOutline.push(cell.key);\n      } else {\n        result.rightInline.push(cell.key);\n      }\n      if (rowIndex === startRowIndex) {\n        result.topOutline.push(cell.key);\n      } else {\n        result.topInline.push(cell.key);\n      }\n      if (rowIndex + rowSpan === endRowIndex + 1) {\n        result.bottomOutline.push(cell.key);\n      } else {\n        result.bottomInline.push(cell.key);\n      }\n    }\n  }\n  return result;\n}\n\nconst mirrorObj = {\n  left: 'right',\n  right: 'left',\n  top: 'bottom',\n  bottom: 'top',\n};\n\nconst defaultBdr = {\n  left: null,\n  right: null,\n  top: null,\n  bottom: null,\n};\n\ntype Border = MoInterfaces.Border.Border;\ntype BorderProperties = MoInterfaces.Border.BorderProperties;\ninterface SetBorderDataOption extends Pick<BorderProperties, 'val' | 'sz' | 'color'> {\n  isIncluded: boolean;\n  orientation: keyof Border;\n}\n\nfunction setBorderData(controller: Controller, cell: Block, key: string, options: SetBorderDataOption) {\n  const { orientation, isIncluded, val, sz, color } = options;\n  const oldBdr = cell.data.bdr || {};\n  const newBdr = {\n    ...oldBdr,\n    [orientation]: isIncluded ? { color, sz, val } : null,\n  };\n  if (!isEqualWithDefault(oldBdr, newBdr, defaultBdr)) {\n    controller.command(Commands.setNodeByKey, cell.key, {\n      data: {\n        ...cell.data,\n        bdr: newBdr,\n      },\n    });\n  }\n}\n\nexport default function setTableBorder(controller: Controller, table: Table, selection: ITableSelection, borderSetType, color, sz, val) {\n  if (!selection) {\n    return controller;\n  }\n\n  const borderInfo = generateBorderInfo(selection, table);\n\n  // all, outline, inside, left, top, right, bottom, innerHorizontal, innerVertical,\n  const filterObj = {\n    none: [],\n    all: ['leftOutline', 'rightOutline', 'topOutline', 'bottomOutline', 'leftInline', 'rightInline', 'topInline', 'bottomInline'],\n    outer: ['leftOutline', 'rightOutline', 'topOutline', 'bottomOutline'],\n    inner: ['leftInline', 'rightInline', 'topInline', 'bottomInline'],\n    left: ['leftOutline'],\n    top: ['topOutline'],\n    right: ['rightOutline'],\n    bottom: ['bottomOutline'],\n    horizon: ['topInline', 'bottomInline'],\n    vertical: ['leftInline', 'rightInline'],\n  };\n  Object.keys(borderInfo).forEach((type) => {\n    const keysByType = borderInfo[type];\n    const matched = type.match(/(\\w+)([A-Z]\\w+)/);\n    if (!matched) {\n      return;\n    }\n    const orientation = matched[1] as keyof Border;\n    const inlineOrOutline = matched[2].toLowerCase();\n    const mirrorOrientation = mirrorObj[orientation] as keyof Border;\n\n    const isOutlineIncluded = inlineOrOutline === 'outline' && filterObj[borderSetType].includes(`${orientation}Outline`);\n    const isInlineIncluded = inlineOrOutline === 'inline' && filterObj[borderSetType].includes(`${orientation}Inline`);\n    const isIncluded = isOutlineIncluded || isInlineIncluded;\n    keysByType.forEach((key) => {\n      const tableCell = controller.value.document.getNode(key) as Block;\n      const updatedTable = controller.value.document.getNode(table.key) as Block;\n      // none比较特殊，是清空效果，其他的都是叠加效果\n      if (isIncluded || borderSetType === 'none') {\n        setBorderData(controller, tableCell, key, { color, sz, val, orientation, isIncluded });\n      }\n\n      if ((isOutlineIncluded || borderSetType === 'none') && inlineOrOutline === 'outline') {\n        const mirrorCell = getMirrorCellOfSameBorder(tableCell, orientation, updatedTable);\n        if (mirrorCell) {\n          setBorderData(\n            controller,\n            mirrorCell,\n            mirrorCell.key,\n            { color, sz, val, orientation: mirrorOrientation, isIncluded: isOutlineIncluded },\n          );\n        }\n      }\n    });\n  });\n\n  return controller;\n}\n"],"file":"setTableBorder.js"}