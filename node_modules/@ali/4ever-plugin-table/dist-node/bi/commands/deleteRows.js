"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = deleteRows;

var _everCangjie = require("@ali/4ever-cangjie");

var _isEmptyTable = _interopRequireDefault(require("../utils/isEmptyTable"));

var _getRealNodeInTable = _interopRequireDefault(require("../utils/getRealNodeInTable"));

var _getPositionOfCell = _interopRequireDefault(require("../utils/getPositionOfCell"));

var _traverseSingleRowCells = _interopRequireDefault(require("../utils/traverseSingleRowCells"));

var _deleteTable = _interopRequireDefault(require("./deleteTable"));

var _utils = require("../utils");

var _getDataTableSelectionByTable = _interopRequireDefault(require("../utils/getDataTableSelectionByTable"));

var _setSelectionByTable = _interopRequireDefault(require("../../utils/utils/setSelectionByTable"));

/* eslint-disable no-shadow */
function deleteRow(controller, tablePath, rowIndex) {
  const table = controller.value.document.getNodeByPath(tablePath);
  (0, _traverseSingleRowCells.default)(table, rowIndex, rowIndex, (_, colIndex, cell) => {
    if (cell.data?.hidden) {
      const realNode = (0, _getRealNodeInTable.default)(table, rowIndex, colIndex);

      if (!realNode) {
        return;
      }

      const position = (0, _getPositionOfCell.default)(realNode.key, table);

      if (position.colIndex === colIndex && position.rowIndex < rowIndex) {
        controller.command(_everCangjie.Commands.setNodeByPath, [...tablePath, position.rowIndex, position.colIndex], {
          data: { ...realNode.data,
            rowSpan: (realNode.data.rowSpan || 1) - 1
          }
        });
      }
    } else if ((cell.data?.rowSpan || 1) > 1) {
      const inheritCellPath = [...tablePath, rowIndex + 1, colIndex];
      const nextRow = table.nodes[rowIndex + 1]; // 不规整表格可能不存在下一行

      if (nextRow) {
        controller.command(_everCangjie.Commands.setNodeByPath, inheritCellPath, {
          data: { ...cell.data,
            rowSpan: (cell.data.rowSpan || 1) - 1
          }
        });
      }
    }
  });
  controller.withoutNormalizing(() => {
    controller.command(_everCangjie.Commands.removeNodeByPath, [...tablePath, rowIndex]);
  });
}

function deleteRows(controller, table) {
  const {
    value
  } = controller;
  const {
    document,
    selection
  } = value;
  let tableSelection = null;
  const queryTbSelection = (0, _getDataTableSelectionByTable.default)(controller, table);

  if (queryTbSelection) {
    tableSelection = queryTbSelection;
  } else {
    tableSelection = (0, _utils.createTableSelectionForFocusedCell)(value, table);
  }

  if (!tableSelection) {
    return controller;
  }

  const {
    startRowIndex,
    endRowIndex
  } = tableSelection;
  const tablePath = document.getPath(table.key);

  for (let rowIndex = endRowIndex; rowIndex >= startRowIndex; rowIndex -= 1) {
    deleteRow(controller, tablePath, rowIndex);
  }

  const updatedTable = controller.value.document.getNodeByPath(tablePath);

  if ((0, _isEmptyTable.default)(updatedTable)) {
    controller.command(_deleteTable.default, updatedTable);
  } else {
    const rowSize = updatedTable.nodes.length;
    const selectedRowIndex = startRowIndex >= rowSize ? rowSize - 1 : startRowIndex;
    const focusCell = (0, _getRealNodeInTable.default)(updatedTable, selectedRowIndex, 0);

    if (focusCell) {
      const s = (0, _setSelectionByTable.default)(selection, false).moveToStartOfNode(focusCell, controller);
      return controller.command(_everCangjie.Commands.select, s);
    }
  }

  return controller;
}
//# sourceMappingURL=deleteRows.js.map