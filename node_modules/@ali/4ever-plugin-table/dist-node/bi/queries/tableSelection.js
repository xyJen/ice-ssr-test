"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = tableSelection;

var _models = _interopRequireDefault(require("../../mo/models"));

var _tableCell = _interopRequireDefault(require("../../mo/models/tableCell"));

var _utils = require("../utils");

var _isTableFromSameOrigin = _interopRequireDefault(require("./isTableFromSameOrigin"));

const TABLE_SELECTION_CACHE = new WeakMap();

function setCache(key, value) {
  TABLE_SELECTION_CACHE.set(key, value);
}

function tableSelection(controller) {
  const {
    value
  } = controller;

  if (TABLE_SELECTION_CACHE.has(value)) {
    return TABLE_SELECTION_CACHE.get(value);
  }

  const {
    document,
    selection
  } = value;
  const {
    anchor,
    focus,
    data
  } = selection;
  const {
    isByTable
  } = data;
  const anchorCell = document.getClosest(anchor.key, _tableCell.default.isTableCell);

  if (!anchorCell) {
    setCache(value, null);
    return null;
  }

  const anchorTable = document.getClosest(anchorCell.key, _models.default.isTable);
  const focusCell = document.getClosest(focus.key, _tableCell.default.isTableCell);

  if (!focusCell || !isByTable && anchorCell.key === focusCell.key) {
    setCache(value, null);
    return null;
  }

  const focusTable = document.getClosest(focusCell.key, _models.default.isTable); // 处理从嵌套表格拖动到外层表格的情况

  if (!(0, _isTableFromSameOrigin.default)(controller, {
    node: anchorTable,
    tableKey: focusTable.key
  })) {
    setCache(value, null);
    return null;
  }

  const startPosition = (0, _utils.getPositionOfCell)(anchorCell.key, anchorTable);
  const endPosition = (0, _utils.getPositionOfCell)(focusCell.key, anchorTable);

  if (!startPosition || !endPosition) {
    return null;
  }

  const minRowIndex = Math.min(startPosition.rowIndex, endPosition.rowIndex);
  const maxRowIndex = Math.max(startPosition.rowIndex, endPosition.rowIndex);
  const minColIndex = Math.min(startPosition.colIndex, endPosition.colIndex);
  const maxColIndex = Math.max(startPosition.colIndex, endPosition.colIndex);
  const result = {
    startRowIndex: minRowIndex,
    endRowIndex: maxRowIndex,
    startColIndex: minColIndex,
    endColIndex: maxColIndex,
    key: anchorTable.key
  };
  const tbSelection = isByTable !== true ? (0, _utils.adjustSelection)(focusTable, result) : result;
  TABLE_SELECTION_CACHE.set(value, tbSelection);
  return tbSelection;
}
//# sourceMappingURL=tableSelection.js.map