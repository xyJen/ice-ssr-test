"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = onEmptyDelete;

var _everCangjie = require("@ali/4ever-cangjie");

var _tableCell = _interopRequireDefault(require("../../mo/models/tableCell"));

// 当前是否处于一个empty block, 无任何text
const isInEmptyBlock = block => {
  return block && block.text === '' && block.nodes.length === 1;
};
/** 如果触发了仓颉默认删除（包括word，line和paragraph）事件的逻辑则需要在table插件处进行拦截处理，走table自身逻辑
 * （背景：当仓颉判断当是前处于一个empty block下执行删除操作时，会通过removeNodeByKey移除该节点）
 * 因此在表格中执行删除操作时分以下几种情况
 * 1. 选中的表格为多个，不做事件拦截
 * 2. 只选中一个表格且表格内容为空，当前插件不对表格做任何处理，但需要对键盘事件进行拦截，防止cangjie通用默认处理行为影响表格逻辑
 * 3. 表格内容非空，不做事件拦截
 * 具体逻辑在 cangjie > src > commands > delete > deleteBackwardAtRange
 */


function onEmptyDelete(controller, next) {
  const {
    value
  } = controller;
  const {
    selection,
    document,
    startBlock
  } = value;
  const startCell = startBlock ? document.getClosest(startBlock.key, _tableCell.default.isTableCell) : null;
  const {
    anchor
  } = selection;
  const block = document.getClosestBlock(anchor.key); // 如果当前只选中一个表格且其为空block，仓颉默认的删除操作会把该节点直接删除，则需要阻止仓颉默认删除行为

  if (startCell && selection.isCollapsed && startCell.nodes.length === 1 && startCell.nodes[0] === block && isInEmptyBlock(block)) {
    // 如果表格中只存在一个空任务列表节点也会走到此逻辑，此时需要用一个空的paragraph来替代删除逻辑
    if (block.data && block.data.list) {
      controller.command(_everCangjie.Commands.replaceNodeByKey, block.key, _everCangjie.Block.create('paragraph')).command(_everCangjie.Commands.moveForward, 1);
    }

    return controller;
  } // 其余情况，执行仓颉的默认逻辑


  return next();
}
//# sourceMappingURL=onEmptyDelete.js.map