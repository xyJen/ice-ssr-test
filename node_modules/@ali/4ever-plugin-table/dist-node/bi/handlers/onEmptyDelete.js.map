{"version":3,"sources":["../../../../src/bi/handlers/onEmptyDelete.ts"],"names":["isInEmptyBlock","block","text","nodes","length","onEmptyDelete","controller","next","value","selection","document","startBlock","startCell","getClosest","key","TableCell","isTableCell","anchor","getClosestBlock","isCollapsed","data","list","command","Commands","replaceNodeByKey","Block","create","moveForward"],"mappings":";;;;;;;;;AAAA;;AACA;;AAEA;AACA,MAAMA,cAAc,GAAIC,KAAD,IAAkB;AACvC,SAAOA,KAAK,IACVA,KAAK,CAACC,IAAN,KAAe,EADV,IAELD,KAAK,CAACE,KAAN,CAAYC,MAAZ,KAAuB,CAFzB;AAGD,CAJD;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACe,SAASC,aAAT,CAAuBC,UAAvB,EAA+CC,IAA/C,EAAqD;AAClE,QAAM;AAAEC,IAAAA;AAAF,MAAYF,UAAlB;AACA,QAAM;AAAEG,IAAAA,SAAF;AAAaC,IAAAA,QAAb;AAAuBC,IAAAA;AAAvB,MAAsCH,KAA5C;AACA,QAAMI,SAAS,GAAGD,UAAU,GAC1BD,QAAQ,CAACG,UAAT,CAAoBF,UAAU,CAACG,GAA/B,EAAoCC,mBAAUC,WAA9C,CAD0B,GAE1B,IAFF;AAGA,QAAM;AAAEC,IAAAA;AAAF,MAAaR,SAAnB;AACA,QAAMR,KAAK,GAAGS,QAAQ,CAACQ,eAAT,CAAyBD,MAAM,CAACH,GAAhC,CAAd,CAPkE,CAQlE;;AACA,MACEF,SAAS,IACTH,SAAS,CAACU,WADV,IAEAP,SAAS,CAACT,KAAV,CAAgBC,MAAhB,KAA2B,CAF3B,IAGAQ,SAAS,CAACT,KAAV,CAAgB,CAAhB,MAAuBF,KAHvB,IAIAD,cAAc,CAACC,KAAD,CALhB,EAME;AACE;AACA,QAAIA,KAAK,CAACmB,IAAN,IAAcnB,KAAK,CAACmB,IAAN,CAAWC,IAA7B,EAAmC;AACjCf,MAAAA,UAAU,CAACgB,OAAX,CAAmBC,sBAASC,gBAA5B,EAA8CvB,KAAK,CAACa,GAApD,EAAyDW,mBAAMC,MAAN,CAAa,WAAb,CAAzD,EAAoFJ,OAApF,CAA4FC,sBAASI,WAArG,EAAkH,CAAlH;AACD;;AACD,WAAOrB,UAAP;AACD,GArB+D,CAsBlE;;;AACA,SAAOC,IAAI,EAAX;AACD","sourcesContent":["import { Controller, Block, Commands } from '@ali/4ever-cangjie';\nimport TableCell from '../../mo/models/tableCell';\n\n// 当前是否处于一个empty block, 无任何text\nconst isInEmptyBlock = (block: Block) => {\n  return block &&\n    block.text === '' &&\n    block.nodes.length === 1\n};\n\n/** 如果触发了仓颉默认删除（包括word，line和paragraph）事件的逻辑则需要在table插件处进行拦截处理，走table自身逻辑\n * （背景：当仓颉判断当是前处于一个empty block下执行删除操作时，会通过removeNodeByKey移除该节点）\n * 因此在表格中执行删除操作时分以下几种情况\n * 1. 选中的表格为多个，不做事件拦截\n * 2. 只选中一个表格且表格内容为空，当前插件不对表格做任何处理，但需要对键盘事件进行拦截，防止cangjie通用默认处理行为影响表格逻辑\n * 3. 表格内容非空，不做事件拦截\n * 具体逻辑在 cangjie > src > commands > delete > deleteBackwardAtRange\n */\nexport default function onEmptyDelete(controller: Controller, next) {\n  const { value } = controller;\n  const { selection, document, startBlock } = value;\n  const startCell = startBlock ?\n    document.getClosest(startBlock.key, TableCell.isTableCell) as TableCell :\n    null;\n  const { anchor } = selection;\n  const block = document.getClosestBlock(anchor.key);\n  // 如果当前只选中一个表格且其为空block，仓颉默认的删除操作会把该节点直接删除，则需要阻止仓颉默认删除行为\n  if (\n    startCell &&\n    selection.isCollapsed &&\n    startCell.nodes.length === 1 &&\n    startCell.nodes[0] === block &&\n    isInEmptyBlock(block)\n  ) {\n      // 如果表格中只存在一个空任务列表节点也会走到此逻辑，此时需要用一个空的paragraph来替代删除逻辑\n      if (block.data && block.data.list) {\n        controller.command(Commands.replaceNodeByKey, block.key, Block.create('paragraph')).command(Commands.moveForward, 1);\n      }\n      return controller;\n    }\n  // 其余情况，执行仓颉的默认逻辑\n  return next();\n}\n"],"file":"onEmptyDelete.js"}