"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _fastdom = _interopRequireDefault(require("fastdom"));

var _constants = require("../constants");

/**
 * 创建一个scroller的dom
 */
// 滚动条高度
const THUMB_HEIGH = 6;
const TEST_ID = 'table-horizontal-scrollbar';
/**
 * 滚动条显示模式：
 *  - always：强制常驻
 *  - default：默认只在需要的时候展示
 */

var ScrollMode;

(function (ScrollMode) {
  ScrollMode["always"] = "always";
  ScrollMode["default"] = "default";
})(ScrollMode || (ScrollMode = {}));

class Scroller {
  /**
   * 表格滚动容器
   */

  /**
   * 滚动条宽度是否占满，占满则不显示滚动条
   */

  /**
   * 滚动条显示模式：默认只在需要的时候展示
   */

  /**
   * 需要添加的滚动条dom
   */

  /**
   * 需要添加的滚动条杆dom
   */

  /**
   * 需要添加的滚动条滑块dom
   */

  /**
   * 滚动时检查是否需要隐藏或者展示滚动条
   */

  /**
   * 销毁用于同步点击滚动条移动表格的事件监听器
   */

  /**
   * 监听目标表格dom变化的observer
   */

  /**
   * 滚动条挂载容器
   */

  /**
   * @param targetTableWrapperEl 表格滚动容器
   * @param getBottom 获取滚动条到页面底部的距离
   * @param mountDom 滚动条挂载容器
   * @param mode 滚动条显示模式：默认只在需要的时候展示
   */

  /** 是否需要重新设置bottom */

  /** 当前bottom */
  constructor(targetTableWrapperEl, getBottom, mountDom, mode = ScrollMode.default) {
    this.targetTableWrapperEl = void 0;
    this.fullwidth = void 0;
    this.mode = void 0;
    this.scrollBar = void 0;
    this.bar = void 0;
    this.thumb = void 0;
    this.checkIfScrollVisible = void 0;
    this.handleTableWrapperScroll = void 0;
    this.syncDestoryHandler = void 0;
    this.tableElObserver = void 0;
    this.mountDom = void 0;
    this.getBottom = void 0;
    this.needResetBottom = void 0;
    this.currentBottom = void 0;

    if (!targetTableWrapperEl) {
      throw new Error('need have table element');
    }

    this.targetTableWrapperEl = targetTableWrapperEl;
    this.fullwidth = false;
    this.mode = mode;
    this.mountDom = mountDom || document.body;
    this.getBottom = getBottom;
    this.needResetBottom = !!getBottom; // 如果传了getBottom则说明需要对bottom进行重置操作

    /**
     * 添加滚动条dom节点
     */

    const footerHeight = getBottom ? getBottom() : 0;
    const scroller = document.createElement('div');
    scroller.setAttribute('data-testid', TEST_ID);
    scroller.style.height = `${THUMB_HEIGH}px`;
    scroller.style.position = 'fixed';
    scroller.style.bottom = `${footerHeight}px`;
    this.currentBottom = footerHeight; // z-index 要高于内容区域 以及 右侧分屏面板的 z-index

    scroller.style.zIndex = '200';
    scroller.style.opacity = '0';
    this.scrollBar = scroller;
    this.resetScroller();
    const bar = document.createElement('div');
    bar.style.height = '100%';
    this.bar = bar;
    scroller.appendChild(bar);
    const thumb = document.createElement('div');
    thumb.style.height = '100%';
    thumb.style.backgroundColor = 'rgb(205, 205, 210)';
    thumb.style.borderRadius = '5px';
    bar.appendChild(thumb);
    this.thumb = thumb;

    try {
      this.mountDom.appendChild(this.scrollBar);
    } catch (e) {
      document.body.appendChild(this.scrollBar);
    }
    /**
     * 初始化配置
     */


    const instance = this;
    this.checkIfScrollVisible = (0, _lodash.throttle)(() => {
      _fastdom.default.measure(() => {
        const viewHeight = window.innerHeight || document.documentElement.clientHeight; // 当前可视区域超出表格最下方或者最上方时，隐藏

        const {
          top,
          bottom
        } = this.targetTableWrapperEl.getBoundingClientRect(); // 当表格上方已经处于视口边缘一定距离阈值内时，不必再显示滚动条

        if (bottom <= viewHeight || top >= viewHeight - THUMB_HEIGH * 2 - _constants.TOOLBAR_ITEM_SIZE) {
          instance.hideScroller();
        } else {
          // 需要重新设置一次当前宽度
          instance.resetBar(false);
          instance.resetScroller(); // 显示当前的bar

          instance.showScroller();
        }
      });
    }, 1000 / 60);
    document.addEventListener('scroll', this.checkIfScrollVisible, true); // 全局判断是否需要显示scroller

    this.handleTableWrapperScroll = (0, _lodash.throttle)(() => {
      _fastdom.default.measure(() => {
        instance.resetThumbPosition();
      });
    }, 1000 / 60); // 自动同步,table => scroller

    targetTableWrapperEl.addEventListener('scroll', this.handleTableWrapperScroll, true); // 自动同步 scroller => table

    this.syncDestoryHandler = this.initScrollSyncHandler(); // 监听table的dom变化，自动重新设置

    this.tableElObserver = new MutationObserver(() => {
      setTimeout(() => {
        _fastdom.default.measure(() => {
          instance.resetBar();
          instance.resetScroller();
          instance.resetThumbPosition();
          instance.checkIfScrollVisible();
        });
      });
    });
    this.tableElObserver.observe(targetTableWrapperEl, {
      childList: true,
      subtree: true,
      // Todo: @muyu 这里不确定只观察父节点变更是否会有bug，因此子节点变化也一并观察，可能会对性能有影响。
      attributes: true,
      attributeFilter: ['style'] // 只关注目标dom节点的style变化

    }); // bar宽度自动重制

    setTimeout(() => {
      _fastdom.default.measure(() => {
        instance.resetBar();
        instance.resetScroller();
        instance.resetThumbPosition();
        instance.checkIfScrollVisible();
        scroller.style.opacity = '1';
      });
    }, 500);
  }
  /**
   * 自动设置Bar
   * @param {boolean} changeScrollerVisible 是否开启自动设置滚动条显示与否
   */


  resetBar(changeScrollerVisible = true) {
    const {
      targetTableWrapperEl
    } = this;
    const widthPercentage = targetTableWrapperEl.clientWidth * 100 / targetTableWrapperEl.scrollWidth;
    const thumbWidth = Math.min(widthPercentage, 100);
    this.thumb.style.width = `${thumbWidth}%`;
    this.fullwidth = thumbWidth >= 100;

    if (changeScrollerVisible) {
      if (this.fullwidth) {
        this.hideScroller();
      } else {
        this.checkIfScrollVisible();
      }
    }
  }

  resetThumbPosition() {
    // 通过transform来模拟滑块滚动
    this.thumb.style.transform = `translateX(${this.moveX}%)`;
  } // 调整滚动条位置以及宽度


  resetScroller() {
    const {
      targetTableWrapperEl,
      scrollBar
    } = this;
    const boundingClientRect = targetTableWrapperEl.getBoundingClientRect(); // 文档Footer的高度是固定的，缩放只针对Content区域，因此只需要获取其高度并设置一次bottom即可

    if (this.needResetBottom) {
      // 但是要考虑window.innerHeight 变化的场景
      const footerHeight = this.getBottom();
      const isBottomChange = footerHeight !== this.currentBottom;

      if (isBottomChange) {
        const bottom = footerHeight || 0; // 文档由于底部Footer也是fixed，因此bottom不能设置为0，只能动态获取Footer的高度来设置bottom

        scrollBar.style.bottom = `${bottom}px`;
        this.currentBottom = bottom;
      }
    }

    scrollBar.style.left = `${boundingClientRect.left}px`;
    scrollBar.style.width = `${boundingClientRect.width}px`;
  } // 滑块位移计算


  get moveX() {
    const {
      targetTableWrapperEl
    } = this;
    return targetTableWrapperEl.scrollLeft * 100 / targetTableWrapperEl.clientWidth;
  }
  /**
   * 让scroller的拖动行为和table的同步
   */


  initScrollSyncHandler() {
    let cursorDown = false;
    let tempClientX = 0;
    let rate = 1;
    const {
      thumb,
      targetTableWrapperEl,
      bar
    } = this;

    function getRate() {
      // 计算一下变换比例，拖拽走的是具体数字，但是这个实际上应该是按照比例变的
      return bar.offsetWidth / thumb.offsetWidth;
    }

    const mouseMoveDocumentHandler = (0, _lodash.throttle)(e => {
      // 拖动的时候如果已经松开鼠标则不处理
      // cursorDown 是拖拽开启和结束的标识
      if (cursorDown === false) {
        return;
      }

      const {
        clientX
      } = e;
      const offset = clientX - tempClientX;
      const originTempClientX = tempClientX;
      tempClientX = clientX;
      const tempScrollleft = targetTableWrapperEl.scrollLeft;
      targetTableWrapperEl.scrollLeft += offset * rate;

      if (tempScrollleft === targetTableWrapperEl.scrollLeft) {
        tempClientX = originTempClientX;
      }
    }, 1000 / 60);

    function mouseUpDocumentHandler() {
      cursorDown = false;
      document.removeEventListener('mousemove', mouseMoveDocumentHandler);
      document.removeEventListener('mouseup', mouseUpDocumentHandler);
      document.onselectstart = null;
    }
    /**
     * 拖拽处理
     */


    function startDrag(e) {
      e.stopImmediatePropagation();
      cursorDown = true;
      document.addEventListener('mousemove', mouseMoveDocumentHandler);
      document.addEventListener('mouseup', mouseUpDocumentHandler);

      document.onselectstart = () => false;
    }

    function handleThumbMouseDown(e) {
      // 右键点击以及ctrl+click事件不处理
      if (e.ctrlKey || e.button === 2) {
        return;
      }

      const {
        clientX
      } = e;
      tempClientX = clientX;
      rate = getRate();
      startDrag(e);
    }

    thumb.addEventListener('mousedown', handleThumbMouseDown);
    /**
     * 点击槽快速移动
     */

    function handleBarClick(e) {
      const {
        target
      } = e;

      if (target !== bar) {
        return;
      }

      rate = getRate();
      const {
        clientX
      } = e;
      let offset = 0;
      const thumbPosition = thumb.getBoundingClientRect();

      if (thumbPosition.left >= clientX) {
        offset = clientX - thumbPosition.left;
      } else {
        offset = clientX - thumbPosition.left - thumbPosition.width;
      }

      const targetScrollLeft = targetTableWrapperEl.scrollLeft + offset * rate;
      targetTableWrapperEl.scrollTo({
        left: targetScrollLeft,
        behavior: 'smooth'
      });
    }

    bar.addEventListener('click', handleBarClick);
    return function () {
      thumb.removeEventListener('mousedown', handleThumbMouseDown);
      bar.removeEventListener('click', handleBarClick);
      document.removeEventListener('mouseup', mouseUpDocumentHandler);
      document.removeEventListener('mousemove', mouseMoveDocumentHandler);
    };
  }
  /**
   * 显示整体
   */


  showScroller() {
    if (!this.fullwidth) {
      this.scrollBar.style.display = 'initial';
    }
  }
  /**
   * 隐藏整体
   */


  hideScroller() {
    if (this.mode === ScrollMode.always) {
      this.scrollBar.style.display = 'initial';
    } else {
      this.scrollBar.style.display = 'none';
    }
  }
  /**
  * 添加事件监听
  */


  addEventListener() {
    this.mountDom?.addEventListener('scroll', this.checkIfScrollVisible);
    this.targetTableWrapperEl.addEventListener('scroll', this.handleTableWrapperScroll);
  }
  /**
   * 移除事件监听
   */


  removeEventListener() {
    this.mountDom?.removeEventListener('scroll', this.checkIfScrollVisible);
    this.targetTableWrapperEl.removeEventListener('scroll', this.handleTableWrapperScroll);
  }
  /**
   * 销毁实例：
   * - 取消observer监听
   * - 监听器注销
   * - 滚动条dom移除
   */


  destroy() {
    this.tableElObserver.disconnect();
    this.removeEventListener();
    this.syncDestoryHandler();
    this.thumb.parentNode?.removeChild(this.thumb);
    this.bar.parentNode?.removeChild(this.bar);
    this.scrollBar.parentNode?.removeChild(this.scrollBar);
  }

}

exports.default = Scroller;
//# sourceMappingURL=horizontalScroll.js.map