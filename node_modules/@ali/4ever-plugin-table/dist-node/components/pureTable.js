"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _styledComponents = _interopRequireDefault(require("styled-components"));

var _fastDeepEqual = _interopRequireDefault(require("fast-deep-equal"));

var _fastdom = _interopRequireDefault(require("fastdom"));

var _everCangjie = require("@ali/4ever-cangjie");

var _models = _interopRequireDefault(require("../mo/models"));

var _tableCell = _interopRequireDefault(require("../mo/models/tableCell"));

var _constants = require("../utils/constants");

var _colsWidthConverter = require("../utils/utils/colsWidthConverter");

var _selectionTrigger = _interopRequireDefault(require("../utils/utils/selectionTrigger"));

var _setSelectionByTable = _interopRequireDefault(require("../utils/utils/setSelectionByTable"));

var _hooks = require("../utils/hooks");

const _createElement = /*#__PURE__*/_react.default.createElement;
const {
  findDOMNodeSafely
} = _everCangjie.domUtils;
const DELTA = 8;

const RealTable = /*#__PURE__*/_styledComponents.default.table(["position:relative;table-layout:fixed;border-collapse:collapse;border:1px solid ", ";"], _constants.DEFAULT_BORDER_COLOR);

const contains = (root, node) => {
  if (node) {
    const found = root.findDescendant(child => child.key === node.key);

    if (found) {
      return true;
    }
  }

  return false;
};

const PureTable = /*#__PURE__*/(0, _react.forwardRef)((props, fwdRef) => {
  const {
    children,
    left,
    node,
    isMobile,
    controller,
    forceRenderPercentColWidthForAutoFit
  } = props;
  const [colsWidth] = (0, _hooks.usePixelColsWidth)();
  const isValidColsWidth = colsWidth.length > 0;

  const isAutofit = _models.default.isAutofitWidth(node);

  const timerRef = _react.default.useRef();

  const [isSticky] = (0, _hooks.useRowIsSticky)();

  const ref = _react.default.useRef(null);

  _react.default.useEffect(() => {
    if (typeof fwdRef === 'function') {
      fwdRef(ref.current);
    } else if (fwdRef) {
      fwdRef.current = ref.current;
    }
  }, [ref, fwdRef]);

  const style = _react.default.useMemo(() => {
    let tableWidth;

    if (isAutofit && forceRenderPercentColWidthForAutoFit) {
      tableWidth = '100%';
    } else if (isAutofit && isMobile) {
      tableWidth = _constants.DEFAULT_TOTAL_WIDTH_FOR_AUTOFIT;
    } else if (isValidColsWidth) {
      tableWidth = colsWidth?.reduce((sum, w) => sum + w, 0);
    } else if (isAutofit) {
      tableWidth = '100%';
    } else {
      tableWidth = (node.data?.colsWidth || []).reduce((sum, w) => sum + w, 0);
    }

    return {
      width: tableWidth,
      left: `${left || 0}px`,
      border: isSticky ? `1px solid ${_constants.DEFAULT_BORDER_COLOR}` : 'unset',
      borderTopWidth: isSticky ? '0' : 'unset'
    };
  }, [isAutofit, forceRenderPercentColWidthForAutoFit, isMobile, isValidColsWidth, left, isSticky, colsWidth, node.data?.colsWidth]);

  const renderColsWidth = _react.default.useMemo(() => {
    if (isAutofit && forceRenderPercentColWidthForAutoFit) {
      return (0, _colsWidthConverter.convertFromPercentToPixel)(node, 100).map(w => `${w}%`);
    }

    if (isAutofit && isMobile) {
      return (0, _colsWidthConverter.convertFromPercentToPixel)(node, _constants.DEFAULT_TOTAL_WIDTH_FOR_AUTOFIT);
    }

    if (isValidColsWidth) {
      return colsWidth;
    }

    if (isAutofit) {
      return (0, _colsWidthConverter.convertFromPercentToPixel)(node, 100).map(w => `${w}%`);
    }

    return node.data?.colsWidth || [];
  }, [isAutofit, forceRenderPercentColWidthForAutoFit, isMobile, isValidColsWidth, node, colsWidth]);

  const prevRenderColsWidth = _react.default.useRef([]); // @ts-ignore


  _react.default.useEffect(() => {
    if (!isAutofit || (0, _fastDeepEqual.default)(prevRenderColsWidth.current, renderColsWidth)) return () => {};
    prevRenderColsWidth.current = renderColsWidth;
    const {
      selection,
      document
    } = controller.value;
    const selectionNode = selection.getClosestNode(document); // 不能用 node.contains(xxx)，始终为 false

    if (selectionNode && contains(node, selectionNode)) {
      controller.setScrollType('maintain');
      controller.command(_everCangjie.Commands.select, selection.merge({
        data: { ...selection.data,
          r: Math.random()
        }
      }));
      clearTimeout(timerRef.current);
      timerRef.current = setTimeout(() => {
        controller.setScrollType('toSelection');
      });
      return () => {
        clearTimeout(timerRef.current);
        timerRef.current = setTimeout(() => {
          controller.setScrollType('toSelection');
        });
      };
    }
  }, [renderColsWidth, controller, node, isAutofit]);

  _react.default.useEffect(() => {
    return () => {
      clearTimeout(timerRef.current);
      controller.setScrollType('toSelection');
    };
  });

  const handleMouseMove = e => {
    if (!ref.current) return;
    const {
      clientX,
      clientY
    } = e;

    const trigger = _selectionTrigger.default.get();

    if (trigger === 'selecting') {
      const tableSelection = controller.query('tableSelection');

      if (tableSelection) {
        return;
      }

      const {
        selection,
        document
      } = controller.value;
      const {
        anchor,
        focus
      } = selection.convertToTextPoints(document);
      const startTd = document.getClosest(anchor.key, _tableCell.default.isTableCell);
      const endTd = document.getClosest(focus.key, _tableCell.default.isTableCell);
      if (!startTd || !endTd || startTd.key !== endTd.key || startTd.data.hidden) return;
      const tdDOM = findDOMNodeSafely(startTd?.key, ref.current);
      if (!tdDOM) return;

      _fastdom.default.measure(() => {
        const tdRect = tdDOM.getBoundingClientRect();
        const {
          left: l,
          right,
          top,
          bottom
        } = tdRect;
        if (tdRect.height === 0) return;
        const isInCellEdge = !(clientX > l + DELTA && clientX < right - DELTA && clientY > top + DELTA && clientY < bottom - DELTA);

        if (isInCellEdge) {
          controller.run('onCangjieSelect', (0, _everCangjie.CangjieSelectEvent)({
            selection: (0, _setSelectionByTable.default)(selection, -1),
            trigger
          }));
        }
      });
    }
  };

  const handleMouseUp = () => {
    ref.current?.removeEventListener('mousemove', handleMouseMove);
  };

  const handleMouseLeave = () => {
    ref.current?.removeEventListener('mousemove', handleMouseMove);
    ref.current?.removeEventListener('mouseup', handleMouseUp);
    ref.current?.removeEventListener('mouseleave', handleMouseLeave);
  };

  const handleMouseDown = () => {
    ref.current?.addEventListener('mousemove', handleMouseMove);
    ref.current?.addEventListener('mouseup', handleMouseUp);
    ref.current?.addEventListener('mouseleave', handleMouseLeave);
  };

  return /*#__PURE__*/_createElement(RealTable, {
    ref: ref,
    style: style,
    onMouseDown: handleMouseDown
  }, /*#__PURE__*/_createElement("colgroup", null, renderColsWidth?.map((colWidth, i) => /*#__PURE__*/_createElement("col", {
    key: i,
    width: colWidth
  }))), /*#__PURE__*/_createElement("tbody", null, children));
});
var _default = PureTable;
exports.default = _default;
//# sourceMappingURL=pureTable.js.map