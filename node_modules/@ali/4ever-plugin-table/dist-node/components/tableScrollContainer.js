"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Wrapper = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _react = _interopRequireWildcard(require("react"));

var _styledComponents = _interopRequireDefault(require("styled-components"));

var _lodash = require("lodash");

var _fastDeepEqual = _interopRequireDefault(require("fast-deep-equal"));

var _everCangjie = require("@ali/4ever-cangjie");

var _models = _interopRequireDefault(require("../mo/models"));

var _tableCell = _interopRequireDefault(require("../mo/models/tableCell"));

var _constants = require("../utils/constants");

var _horizontalScroll = _interopRequireDefault(require("../utils/utils/horizontalScroll"));

var _everPluginDraggable = require("@ali/4ever-plugin-draggable");

var _hooks = require("../utils/hooks");

var _colsWidthConverter = require("../utils/utils/colsWidthConverter");

var _getPositionOfCell = _interopRequireDefault(require("../utils/utils/getPositionOfCell"));

var _useSelectionStatus = require("../utils/hooks/useSelectionStatus");

var _everUtils = require("@ali/4ever-utils");

var _useResizeObserver = _interopRequireDefault(require("../utils/utils/useResizeObserver"));

var _visibleUtil = require("../utils/utils/visibleUtil");

const _createElement = /*#__PURE__*/_react.default.createElement;

const Wrapper = /*#__PURE__*/_styledComponents.default.div(["overflow-x:scroll;overflow-y:auto;position:relative;::-webkit-scrollbar{width:", "px;height:", "px;}:hover::-webkit-scrollbar-thumb{background:rgba(0,0,0,0.12);border-radius:5px;border:1px solid transparent;background-clip:content-box;}:hover::-webkit-scrollbar-thumb:hover{background:rgba(0,0,0,0.20);border-radius:5px;border:1px solid transparent;background-clip:content-box;}", ""], _constants.SCROLL_BAR_HEIGHT, _constants.SCROLL_BAR_HEIGHT, p => p.hideScrollBar ? `
    ::-webkit-scrollbar {
      display: none;
    }
    ::-webkit-scrollbar-thumb {
      display: none;
    }
  ` : '');

exports.Wrapper = Wrapper;

const TableScrollContainer = /*#__PURE__*/_react.default.forwardRef((props, forRef) => {
  const {
    children,
    table,
    controller,
    isMobile,
    onMouseEnter = _lodash.noop,
    onMouseMove = _lodash.noop,
    onScroll,
    disableHorizontalScrollbar,
    hideScrollBar,
    ...rest
  } = props;
  const scrollableContainer = (0, _everCangjie.useScrollableContainer)();
  const zoomContainer = (0, _everCangjie.useZoomContainer)();
  const zoom = (0, _everCangjie.useZoom)();
  const horizontalScrollRef = (0, _react.useRef)(null);
  const ref = (0, _react.useRef)(null);
  const [width, setWidth] = (0, _react.useState)(0);
  const [scrollLeft, setScrollLeft] = (0, _react.useState)(0);
  const widthRef = (0, _react.useRef)(width);
  const intersectionObRef = (0, _react.useRef)(null);
  (0, _react.useEffect)(() => {
    if (!disableHorizontalScrollbar && scrollableContainer && !isMobile && ref.current) {
      const callback = function (entries) {
        const isVisible = entries[0].intersectionRatio > 0;

        _visibleUtil.visibleUtil.setVisible(table.key, isVisible);

        if (!isVisible) {
          horizontalScrollRef.current?.removeEventListener();
        } else if (horizontalScrollRef.current) {
          // fix: https://work.aone.alibaba-inc.com/issue/44551345
          horizontalScrollRef.current?.addEventListener();
        } else if (ref.current) {
          const getFootBottom = () => {
            const isWindow = scrollableContainer.window;
            const scrollContainerBottom = isWindow ? window.innerHeight : scrollableContainer.getBoundingClientRect().bottom;
            const footerHeight = Math.ceil(window.innerHeight - scrollContainerBottom);
            return Math.max(footerHeight, 0);
          };

          horizontalScrollRef.current = new _horizontalScroll.default(ref.current, getFootBottom, scrollableContainer);
        }
      };

      intersectionObRef.current = new IntersectionObserver(callback);
      intersectionObRef.current.observe(ref.current);
      return () => {
        if (ref.current) {
          intersectionObRef.current?.unobserve(ref.current);
        }
      };
    }

    return undefined;
  }, [scrollableContainer, isMobile, disableHorizontalScrollbar, table.key]);
  (0, _react.useEffect)(() => {
    if (typeof forRef === 'function') {
      forRef(ref.current);
    } else if (forRef) {
      forRef.current = ref.current;
    }
  }, [ref, forRef]);
  const handleScroll = (0, _lodash.throttle)(e => {
    onScroll && onScroll(e);
    const left = ref.current?.scrollLeft;

    if (Number.isFinite(left) && scrollLeft !== left) {
      setScrollLeft(left);
    }
  });

  const [colsWidthByPixel, setColsWidthByPixel] = _react.default.useState([]);

  const [pixelColsWidth, setPixelColsWidth] = (0, _hooks.usePixelColsWidth)();

  const prevPixelColsWidth = _react.default.useRef([]);

  _react.default.useEffect(() => {
    const newPixelColsWidth = _models.default.isAutofitWidth(table) ? colsWidthByPixel : table.data.colsWidth;

    if (!(0, _fastDeepEqual.default)(newPixelColsWidth, prevPixelColsWidth.current)) {
      setPixelColsWidth(newPixelColsWidth || []);
      prevPixelColsWidth.current = newPixelColsWidth || [];
    }
  }, [colsWidthByPixel, setPixelColsWidth, table]);

  const prevColsWidth = _react.default.useRef([]); // table 变化时


  _react.default.useEffect(() => {
    if (!_models.default.isAutofitWidth(table) || !widthRef.current) return;
    let totalWidth = widthRef.current / zoom - 2;

    if (isMobile) {
      totalWidth = _constants.DEFAULT_TOTAL_WIDTH_FOR_AUTOFIT;
    }

    const pxlColsWidth = (0, _colsWidthConverter.convertFromPercentToPixel)(table, totalWidth);
    setColsWidthByPixel(pxlColsWidth);
  }, [table, isMobile, zoom]);

  const totalColsWidth = (pixelColsWidth || []).reduce((acc, cw) => acc + cw, 0);

  const prevTotalColsWidth = _react.default.useRef(0);

  const resizeObserverCallback = _react.default.useCallback(rect => {
    // table 开启 prune display: none 时，宽度是 0
    if (rect.width === 0) return;
    const actualWith = rect.width;

    if (widthRef.current !== actualWith || prevTotalColsWidth.current !== totalColsWidth) {
      setWidth(Number.isFinite(totalColsWidth) ? Math.min(actualWith, totalColsWidth + 1) : actualWith);
      widthRef.current = actualWith;
      prevTotalColsWidth.current = totalColsWidth;

      if (_models.default.isAutofitWidth(table)) {
        prevColsWidth.current = table.data.colsWidth;
        let totalWidth = actualWith / zoom - 2;

        if (isMobile) {
          totalWidth = _constants.DEFAULT_TOTAL_WIDTH_FOR_AUTOFIT;
        }

        const pxlColsWidth = (0, _colsWidthConverter.convertFromPercentToPixel)(table, totalWidth);
        setColsWidthByPixel(pxlColsWidth);
      }
    }
  }, [isMobile, table, totalColsWidth, zoom]);

  (0, _useResizeObserver.default)(ref.current, resizeObserverCallback);

  const prevPosition = _react.default.useRef(null);

  const handleScrollIntoView = _react.default.useCallback(focusPosition => {
    // horizontal
    if (focusPosition?.colIndex !== undefined && pixelColsWidth) {
      const index = focusPosition.colIndex;
      let targetColRightBorder = pixelColsWidth.slice(0, index + 1).reduce((sum, colWidth) => sum + colWidth, 0);
      const targetColLeftBorder = targetColRightBorder - pixelColsWidth[index];
      targetColRightBorder = index === pixelColsWidth.length - 1 ? targetColRightBorder + _constants.QUICK_INSERT_BUTTON_WIDTH_HEIGHT : targetColRightBorder;
      window.requestAnimationFrame(() => {
        if (!ref.current) {
          return;
        }

        const realTableWrapperRect = (0, _everUtils.getBoundingRelativeRect)(ref.current, zoomContainer);
        const {
          scrollLeft: sl
        } = ref.current;

        if (pixelColsWidth[index] <= realTableWrapperRect.width && (sl > targetColLeftBorder || sl + realTableWrapperRect.width < targetColRightBorder)) {
          const finalScrollLeft = targetColRightBorder - realTableWrapperRect.width;
          ref.current.scrollLeft = finalScrollLeft;
        }
      });
    } else {// vertical
      // TODO: 向下插入一行后，新增行可能会超出可见区域
    }
  }, [pixelColsWidth, zoomContainer]);

  const shouldUpdateTable = _react.default.useCallback(({
    isPendingSelected,
    range
  }) => {
    // 在表格内的光标位置变化
    if (range.isCollapsed && isPendingSelected) {
      const focusCell = controller.value.document.getClosest(range.focus.key, _tableCell.default.isTableCell);

      if (!focusCell) {
        return;
      } // 检查所属单元格位置是否发生变化，若变化则按需横向滚动进视区


      const position = (0, _getPositionOfCell.default)(focusCell.key, table);

      if (position && (prevPosition.current?.colIndex !== position.colIndex || prevPosition.current?.rowIndex !== position.rowIndex)) {
        prevPosition.current = position;
        handleScrollIntoView(position);
      }
    }
  }, [controller, table, handleScrollIntoView]);

  (0, _useSelectionStatus.useSelectionStatus)(controller, table, shouldUpdateTable, []);
  return /*#__PURE__*/_createElement(Wrapper, (0, _extends2.default)({}, rest, {
    onMouseEnter: onMouseEnter,
    onMouseMove: onMouseMove,
    onScroll: handleScroll,
    ref: ref,
    hideScrollBar: hideScrollBar
  }, _everPluginDraggable.SCROLLABLE_ATTRIBUTE), /*#__PURE__*/_createElement(_hooks.TableScrollContainerContext.Provider, {
    value: ref.current
  }, /*#__PURE__*/_createElement(_hooks.TableScrollContainerWidthContext.Provider, {
    value: width
  }, /*#__PURE__*/_createElement(_hooks.TableScrollContainerScrollLeftContext.Provider, {
    value: scrollLeft
  }, children))), /*#__PURE__*/_createElement(_everCangjie.SelectionSlot, {
    layerFor: table.key
  }));
});

var _default = TableScrollContainer;
exports.default = _default;
//# sourceMappingURL=tableScrollContainer.js.map