"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var React = _interopRequireWildcard(require("react"));

var _styledComponents = _interopRequireDefault(require("styled-components"));

var _lodash = require("lodash");

var _everCangjie = require("@ali/4ever-cangjie");

var _constants = require("../utils/constants");

var _hooks = require("../utils/hooks");

var _useResizeObserver = _interopRequireDefault(require("../utils/utils/useResizeObserver"));

var _shouldRowSticky = _interopRequireDefault(require("../utils/utils/shouldRowSticky"));

const _createElement = /*#__PURE__*/React.createElement;
const BORDER_BOTTOM_WIDTH = 1;
const STICKY_MARGIN_LEFT = -1;

const TR = /*#__PURE__*/_styledComponents.default.tr(["&[data-sticky=\"true\"]{border-bottom:", "px solid ", ";margin-left:", "px;z-index:", ";background:white;box-shadow:rgb(17 31 44 / 10%) 0px 6px 4px -4px;overscroll-behavior-x:none;td{border-width:1px 0 0 1px;margin-right:-1px;&:last-of-type{border-right:1px solid ", ";}}}"], BORDER_BOTTOM_WIDTH, _constants.DEFAULT_BORDER_COLOR, STICKY_MARGIN_LEFT, _constants.STICKY_TOOLBAR_INDEX_MAP.stickyRow, _constants.DEFAULT_BORDER_COLOR);

const TableRow = ({
  attributes,
  node,
  children,
  controller,
  parent
}) => {
  const {
    readOnly
  } = controller;
  const rowDOMRef = React.useRef(null);
  const height = node.data.h || _constants.MIN_ROW_HEIGHT;
  const scrollContainer = (0, _everCangjie.useScrollableContainer)();
  const [top, setTop] = React.useState(0);
  const [, forceUpdate] = React.useReducer(c => c + 1, 0);
  const renderHeightRef = React.useRef(0);
  const prevRelativeLeftRef = React.useRef(0);
  const [clientHeight, setClientHeight] = React.useState(0);
  const isTableSelected = (0, _hooks.useTableIsSelected)();
  const zoom = (0, _everCangjie.useZoom)();
  const [colsWidth] = (0, _hooks.usePixelColsWidth)() || [];
  const scrollContainerWidth = (0, _hooks.useTableScrollContainerWidth)();
  const tableScrollLeft = (0, _hooks.useTableScrollContainerScrollLeft)();
  const [isRowSticky, setIsSticky] = (0, _hooks.useRowIsSticky)();
  const [, forceUpdateTableSelection] = (0, _hooks.useUpdateTableSelectionContext)();
  const [, updateRowClientHeight] = (0, _hooks.useRowsClientHeight)();
  const [scrollRect, setScrollableContainerRect] = (0, _hooks.useScrollableContainerRect)();
  const tableScrollContainer = (0, _hooks.useTableScrollContainer)();
  const shouldSticky = React.useMemo(() => {
    return (0, _shouldRowSticky.default)(node, parent) && scrollContainer instanceof HTMLElement;
  }, [node, scrollContainer, parent]);
  const isSticky = shouldSticky && isRowSticky;
  const topOffset = isTableSelected ? _constants.STICKY_ROW_TOP_HEIGHT : 0;
  React.useEffect(() => {
    setTop(scrollRect.top + topOffset);
  }, [scrollRect.top, topOffset]);
  const shouldObserve = !readOnly || shouldSticky;
  const updateRowRenderHeight = React.useCallback(rect => {
    // table display: none 时高度为 0
    if (rect.height === 0) return;
    const stickyHeight = rect.height - BORDER_BOTTOM_WIDTH;
    const actualHeight = isSticky ? stickyHeight : rect.height;

    if (renderHeightRef.current !== actualHeight) {
      renderHeightRef.current = actualHeight;
      updateRowClientHeight(node.key, actualHeight);
      setClientHeight(actualHeight);
    }
  }, [node, updateRowClientHeight, isSticky]);
  (0, _useResizeObserver.default)(shouldObserve ? rowDOMRef.current : null, updateRowRenderHeight);
  const prevZoomRef = React.useRef(zoom); // 触发缩放 resizeObserver 无法监听到变化

  React.useEffect(() => {
    if (!rowDOMRef.current || prevZoomRef.current === zoom) return;
    prevZoomRef.current = zoom;
    const rect = rowDOMRef.current.getBoundingClientRect();
    updateRowRenderHeight(rect);
  }, [zoom, updateRowRenderHeight]);
  const setTablePaddingTop = React.useCallback(paddingTop => {
    const tableDOM = rowDOMRef.current?.parentElement?.parentElement;
    if (!tableDOM?.parentElement) return; // NOTE: 不能设置 marginTop，会导致文档意外滚动

    tableDOM.parentElement.style.paddingTop = paddingTop;
  }, []); // 组件销毁重置状态

  React.useEffect(() => {
    return () => {
      updateRowClientHeight(node.key, null);
      setIsSticky(false);
      setTablePaddingTop('0px');
    };
  }, []);
  React.useLayoutEffect(() => {
    if (!rowDOMRef.current || !shouldSticky) return; // IMPORTANT: 需要同时对首行设置 fixed 和对 table 父节点设置 paddingTop
    // 通过 DOM 操作来保障同时生效，避免文档跳动

    const rowPosition = isSticky ? 'fixed' : '';
    rowDOMRef.current.style.position = rowPosition;
    const toolbarSpace = readOnly ? 0 : _constants.TOOLBAR_ITEM_SIZE;
    const paddingTop = isSticky ? `${clientHeight + toolbarSpace}px` : '0px';
    setTablePaddingTop(paddingTop);
  }, [isSticky, clientHeight, setTablePaddingTop, shouldSticky, readOnly]);
  const style = React.useMemo(() => {
    if (!isSticky) {
      return {
        height
      };
    }

    const gridTemplateColumns = [];
    node.nodes.forEach((n, i) => {
      const {
        colSpan = 1,
        hidden
      } = n.data || {};
      if (hidden) return;

      if (colSpan === 1) {
        gridTemplateColumns.push(colsWidth[i]);
      } else {
        const colWidth = colsWidth.slice(i, i + colSpan).reduce((acc, w) => acc + w, 0);
        gridTemplateColumns.push(colWidth);
      }
    });
    return {
      minHeight: height,
      top,
      // 通过 grid 模拟 table 布局
      display: 'grid',
      gridAutoFlow: 'column',
      gridTemplateColumns: gridTemplateColumns.map(c => `${c}px`).join(' '),
      width: scrollContainerWidth,
      overflowX: 'hidden',
      left: Number.isFinite(scrollRect.left) ? scrollRect.left - STICKY_MARGIN_LEFT : 'unset'
    };
  }, [colsWidth, height, isSticky, node, scrollContainerWidth, top, scrollRect.left]);
  React.useLayoutEffect(() => {
    if (isSticky && rowDOMRef.current) {
      rowDOMRef.current.scrollLeft = tableScrollLeft;
    }
  }, [tableScrollLeft, isSticky]);
  React.useLayoutEffect(() => {
    forceUpdateTableSelection();
  }, [isSticky, forceUpdateTableSelection]);
  const updateIsSticky = React.useCallback(() => {
    const tableDOM = rowDOMRef.current?.parentElement?.parentElement;
    if (!tableDOM || !tableScrollContainer) return;
    const tableScrollRect = tableScrollContainer.getBoundingClientRect();
    const containerRect = scrollContainer.getBoundingClientRect();
    const tableRect = tableDOM.getBoundingClientRect(); // height 为 0 说明是 display none 状态

    if (!rowDOMRef.current || tableRect.height === 0) {
      setIsSticky(false);
      return;
    }

    const rowRect = rowDOMRef.current.getBoundingClientRect();
    const {
      height: scrollHeight
    } = scrollContainer.getBoundingClientRect();

    if (isSticky === false && (rowRect.height > tableRect.height / 2 || rowRect.height > scrollHeight / 3)) {
      return;
    }

    if (tableRect.bottom < containerRect.top + rowRect.height + topOffset) {
      setIsSticky(false);
      return;
    }

    const topSpace = isSticky ? rowRect.height : 0;

    if (tableRect.top - topSpace - topOffset > containerRect.top) {
      setIsSticky(false);
      return;
    }

    const relativeLeft = tableScrollRect.left - rowRect.left;

    if (prevRelativeLeftRef.current !== relativeLeft) {
      prevRelativeLeftRef.current = relativeLeft;
      setScrollableContainerRect(r => ({ ...r,
        left: tableScrollRect.left
      }));
    }

    setIsSticky(true);
    forceUpdateTableSelection();
  }, [forceUpdateTableSelection, isSticky, scrollContainer, setIsSticky, topOffset, tableScrollLeft, tableScrollContainer]);
  React.useEffect(() => {
    if (!shouldSticky) return () => {}; // NOTE: 不要设置 delay，可能会导致异常

    const handleScroll = (0, _lodash.throttle)(() => {
      updateIsSticky();
    });
    scrollContainer.addEventListener('scroll', handleScroll);
    window.addEventListener('resize', handleScroll);
    return () => {
      scrollContainer.removeEventListener('scroll', handleScroll);
      window.removeEventListener('resize', handleScroll);
    };
  }, [updateIsSticky, scrollContainer, shouldSticky]);
  const stickyContext = React.useMemo(() => {
    return [shouldSticky && isSticky, _lodash.noop];
  }, [shouldSticky, isSticky]);
  return /*#__PURE__*/_createElement(TR, (0, _extends2.default)({}, attributes, {
    ref: n => {
      if (n) {
        if (!rowDOMRef.current) forceUpdate();
        rowDOMRef.current = n;
      }
    },
    style: style,
    "data-sticky": isSticky
  }), /*#__PURE__*/_createElement(_hooks.RowIsStickyContext.Provider, {
    value: stickyContext
  }, children()));
};

var _default = TableRow;
exports.default = _default;
//# sourceMappingURL=tableRow.js.map