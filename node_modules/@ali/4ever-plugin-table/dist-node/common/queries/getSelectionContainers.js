"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getSelectionContainers;
exports.getAllTables = void 0;

var _everCangjie = require("@ali/4ever-cangjie");

var _models = _interopRequireDefault(require("../../mo/models"));

var _tableCell = _interopRequireDefault(require("../../mo/models/tableCell"));

var _tableRow = _interopRequireDefault(require("../../mo/models/tableRow"));

var _lodash = require("lodash");

const isRealTable = node => _models.default.isTable(node) && !node.data.sr; // 排除分栏


const getAllTables = (0, _lodash.memoize)(root => {
  // 根据类型定义和传参进行理论分析，这里不会有 NPE 问题，但监控上报了且尝试复现未果
  // 这里先做个防御，并进一步收集信息供分析
  // Ref: https://aone.alibaba-inc.com/v2/project/995011/bug/45757203
  if (!root || !root.filterDescendants) {
    console.warn('Unexpected NPE: not valid Document type', root);
    return [];
  }

  return root.filterDescendants(isRealTable);
});
exports.getAllTables = getAllTables;

function getSelectionContainers(controller, {
  selection: originSelection,
  defaultWrapper,
  document: doc
}) {
  const document = doc || controller.value.document;

  if (!document) {
    console.warn(`getSelectionContainers[Table]: document is ${document}`);
    return new Map();
  }

  const tables = getAllTables(document);
  const {
    start,
    end
  } = originSelection.sort(document);
  const startPath = document.getPath(start.key);
  const endPath = document.getPath(end.key);
  const res = new Map();

  if (!startPath || !endPath) {
    return res;
  }

  let afterTablePoint = null;
  let beforeTablePoint = null;
  tables.forEach(table => {
    const tablePath = document.getPath(table.key);

    if (!tablePath) {
      return;
    }

    const startClosestAncestorTable = document.getClosestByPath(startPath, isRealTable);
    const endClosestAncestorTable = document.getClosestByPath(endPath, isRealTable);
    const isStartInTable = startClosestAncestorTable === table;
    const isEndInTable = endClosestAncestorTable === table; // 选区完全在 table 里

    if (isStartInTable && isEndInTable) {
      const startClosestRow = document.getClosestByPath(startPath, _tableRow.default.isTableRow);
      const startClosestCell = document.getClosestByPath(startPath, _tableCell.default.isTableCell);
      const endClosestCell = document.getClosestByPath(endPath, _tableCell.default.isTableCell);
      let wrapper;

      if (startClosestCell && startClosestCell.key === endClosestCell?.key && _tableRow.default.isHeader(startClosestRow)) {
        wrapper = _everCangjie.domUtils.findSelectionSlot(startClosestCell.key);
      } else {
        wrapper = _everCangjie.domUtils.findSelectionSlot(table.key);
      }

      if (wrapper) {
        res.set(originSelection, {
          wrapper,
          originSelection
        });
      }

      return;
    } // expanded 选区部分在 table 里


    if (isStartInTable || isEndInTable) {
      const firstText = table.getFirstText();
      const lastText = table.getLastText();

      if (!firstText || !lastText && isStartInTable) {
        return;
      }

      const [newStart, newEnd] = isStartInTable ? [start, _everCangjie.TextPoint.create({
        key: lastText.key,
        offset: lastText.text.length
      })] : [_everCangjie.TextPoint.create({
        key: firstText.key,
        offset: 0
      }), end];

      if (isStartInTable) {
        const nextText = document.getNextText(lastText.key);
        afterTablePoint = nextText && _everCangjie.TextPoint.create({
          key: nextText.key,
          offset: 0
        });
      } else {
        const prevText = document.getPreviousText(firstText.key);
        beforeTablePoint = prevText && _everCangjie.TextPoint.create({
          key: prevText.key,
          offset: prevText.text.length
        });
      }

      const wrapper = _everCangjie.domUtils.findSelectionSlot(table.key);

      if (!wrapper) {
        return;
      }

      res.set(_everCangjie.Selection.create({
        anchor: newStart,
        focus: newEnd
      }), {
        wrapper,
        originSelection
      });
    }
  });

  if (afterTablePoint || beforeTablePoint) {
    const restSelection = _everCangjie.Selection.create({
      anchor: afterTablePoint || start,
      focus: beforeTablePoint || end
    });

    res.set(restSelection, {
      wrapper: defaultWrapper,
      originSelection
    });
  }

  return res;
}
//# sourceMappingURL=getSelectionContainers.js.map