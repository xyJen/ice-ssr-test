"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var React = _interopRequireWildcard(require("react"));

var _resizeObserverPolyfill = _interopRequireDefault(require("resize-observer-polyfill"));

var _models = _interopRequireDefault(require("../../mo/models"));

var _constants = _interopRequireDefault(require("../../utils/constants"));

var _hooks = require("../../utils/hooks");

var _actions = require("../../utils/actions");

var _tableContextContainer = _interopRequireDefault(require("../../components/tableContextContainer"));

var _tableScrollContainer = _interopRequireDefault(require("../../components/tableScrollContainer"));

var _pureTable = _interopRequireDefault(require("../../components/pureTable"));

const _createElement = /*#__PURE__*/React.createElement;
const {
  DEFAULT_TOTAL_WIDTH_FOR_AUTOFIT
} = _constants.default;
const CommonTable = /*#__PURE__*/React.forwardRef((props, forwardRef) => {
  const {
    node,
    children,
    attributes = {},
    config = {},
    controller,
    isMobile,
    ...rest
  } = props;
  const wrapperRef = React.useRef(null);
  const ref = React.useRef(null);
  const wrapperWidthRef = React.useRef(0);
  const observerRef = React.useRef();
  const [pixelColsWidth, setPixelColsWidth] = React.useState([]);
  const pixelColsWidthValue = React.useMemo(() => {
    return [pixelColsWidth, setPixelColsWidth];
  }, [pixelColsWidth]);
  React.useEffect(() => {
    if (typeof forwardRef === 'function') {
      forwardRef(ref.current);
    } else if (forwardRef) {
      forwardRef.current = ref.current;
    }
  }, [ref, forwardRef]);
  React.useEffect(() => {
    const containerWidth = isMobile ? DEFAULT_TOTAL_WIDTH_FOR_AUTOFIT : undefined;
    controller.run('onAction', (0, _actions.adjustColsWidth)(node, containerWidth));
  });

  const isAutofit = _models.default.isAutofitWidth(node);

  React.useEffect(() => {
    if (isMobile || !isAutofit || !wrapperRef.current) return () => {};
    observerRef.current = new _resizeObserverPolyfill.default(list => {
      const {
        contentRect
      } = list[0]; // table 开启 prune display: none 时，宽度是 0

      if (contentRect.width === 0 || contentRect.width === wrapperWidthRef.current) return;
      wrapperWidthRef.current = contentRect.width;
      controller.run('onAction', (0, _actions.adjustColsWidth)(node));
    });
    const wrapperNode = wrapperRef.current;
    observerRef.current.observe(wrapperNode);
    return () => {
      if (wrapperNode) {
        observerRef.current?.unobserve(wrapperNode);
      }
    };
  }, [node, isMobile, controller, isAutofit]);
  React.useEffect(() => {
    return () => {
      if (observerRef.current) {
        observerRef.current.disconnect();
      }
    };
  }, []);
  const scrollContainerRef = React.useRef(null);
  const {
    onScroll: configOnScroll
  } = config;
  const onScroll = React.useCallback(() => {
    if (configOnScroll && scrollContainerRef.current) {
      configOnScroll(scrollContainerRef.current, node);
    }
  }, [node, configOnScroll]);
  const {
    percentOfScrollLeft
  } = node.data || {};
  React.useEffect(() => {
    const frameId = window.requestAnimationFrame(() => {
      const scrollContainer = scrollContainerRef.current;

      if (!scrollContainer || !ref.current) {
        return;
      }

      if (typeof percentOfScrollLeft === 'number') {
        const containerWidth = scrollContainer.offsetWidth;
        const tableWidth = ref.current.offsetWidth;
        const totalScroll = tableWidth - containerWidth;
        scrollContainer.scrollTo({
          left: percentOfScrollLeft * totalScroll,
          behavior: 'smooth'
        });
      }
    });
    return () => {
      window.cancelAnimationFrame(frameId);
    };
  }, [percentOfScrollLeft]);
  return /*#__PURE__*/_createElement(_hooks.PixelColsWidthContext.Provider, {
    value: pixelColsWidthValue
  }, /*#__PURE__*/_createElement(_tableScrollContainer.default, (0, _extends2.default)({}, rest, {
    controller: controller,
    onScroll: onScroll,
    table: node,
    ref: scrollContainerRef,
    isMobile: isMobile
  }), /*#__PURE__*/_createElement("div", (0, _extends2.default)({}, attributes, {
    ref: wrapperRef
  }), /*#__PURE__*/_createElement(_pureTable.default, {
    ref: forwardRef,
    node: node,
    controller: controller,
    isMobile: isMobile,
    readonly: true,
    forceRenderPercentColWidthForAutoFit: config.forceRenderPercentColWidthForAutoFit?.()
  }, children()))));
});

const PCTable = props => {
  const {
    controller,
    node,
    config = {}
  } = props;
  const {
    enableHeaderSticky
  } = config;
  return /*#__PURE__*/_createElement(_tableContextContainer.default, {
    controller: controller,
    table: node,
    enableHeaderSticky: enableHeaderSticky
  }, /*#__PURE__*/_createElement(CommonTable, props));
};

const Table = props => {
  const {
    isMobile
  } = props;

  if (isMobile) {
    return /*#__PURE__*/_createElement(CommonTable, props);
  }

  return /*#__PURE__*/_createElement(PCTable, props);
};

var _default = Table;
exports.default = _default;
//# sourceMappingURL=table.js.map