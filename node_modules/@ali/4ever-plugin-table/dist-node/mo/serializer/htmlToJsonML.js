"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = htmlToJsoML;

var _everUtils = require("@ali/4ever-utils");

var _lodash = require("lodash");

var _everCangjie = require("@ali/4ever-cangjie");

var _constants = require("./constants");

var _types = require("./types");

function createEmptyTableCell(hidden = false) {
  return ['tc', {
    hidden,
    colSpan: 1,
    rowSpan: 1
  }, (0, _everCangjie.createEmptyParagraph)()];
}

function normalizeTrAttrs(attrs) {
  const normalizedAttrs = {}; // 如果 style 存在则解析 style

  if (typeof attrs.style === 'string') {
    const style = attrs.styleObj; // 行高

    if (style.height) {
      const px = (0, _everUtils.parseCSSAbsoluteLength)(style.height, 'px');
      normalizedAttrs.h = parseFloat(px);
    }
  }

  return normalizedAttrs;
}

function normalizeTcAttrs(attrs, element) {
  const normalizedAttrs = {
    // 默认值
    rowSpan: typeof attrs.rowspan === 'number' ? attrs.rowspan : parseInt(attrs.rowspan, 10) || 1,
    colSpan: typeof attrs.colspan === 'number' ? attrs.colspan : parseInt(attrs.colspan, 10) || 1
  };
  const computedStyle = element ? window.getComputedStyle(element) : {}; // 如果 style 存在则解析 style

  if (typeof attrs.style === 'string' || !(0, _lodash.isEmpty)(computedStyle)) {
    const getStyle = name => {
      return computedStyle[name] || attrs?.style?.[name];
    }; // 隐藏的单元格


    if (getStyle('display') === 'none') {
      normalizedAttrs.hidden = true;
    } // 单元格宽度


    if (attrs.width && (0, _everUtils.isCSSAbsoluteLength)(getStyle('width'))) {
      normalizedAttrs.width = (0, _everUtils.parseCSSAbsoluteLength)(attrs.width, 'px');
    } // 单元格填充色


    if (getStyle('background')) {
      const parsed = (0, _everUtils.praseCSSBackground)(getStyle('background'));
      normalizedAttrs.fill = parsed.backgroundColor;
    }

    if (getStyle('backgroundColor')) {
      normalizedAttrs.fill = getStyle('backgroundColor');
    } // 单元格垂直对齐方式


    if (attrs.valign) {
      normalizedAttrs.vAlign = attrs.valign;
    } // 边框


    if (getStyle('border')) {
      const parsed = (0, _everUtils.cssBorderParse)(getStyle('border'));

      if (parsed && parsed.style !== 'none') {
        ['top', 'right', 'bottom', 'left'].forEach(side => {
          normalizedAttrs.bdr = { ...normalizedAttrs.bdr,
            [side]: (0, _everUtils.convertBorderToData)(parsed)
          };
        });
      }
    } // 解析不同位置的边框


    ['left', 'right', 'top', 'bottom'].forEach(type => {
      const capType = `border${type[0].toUpperCase()}${type.slice(1)}`;

      if (getStyle(capType)) {
        const parsed = (0, _everUtils.cssBorderParse)(getStyle(capType));

        if (parsed) {
          if (parsed.style === 'none') {
            delete normalizedAttrs.bdr?.[type];
          } else {
            normalizedAttrs.bdr = { ...normalizedAttrs.bdr,
              [type]: (0, _everUtils.convertBorderToData)(parsed)
            };
          }
        }
      }
    });
  }

  return normalizedAttrs;
}
/**
 * 修补 table cell 的数据格式
 * @param table
 */


function normalizeTableCells(table) {
  const rows = (0, _everUtils.getChildren)(table);
  rows.forEach(row => {
    const cells = (0, _everUtils.getChildren)(row);
    cells.forEach(cell => {
      const attrs = (0, _everUtils.getAttributes)(cell); // 当前 td 不消费 width 数据

      if (attrs && attrs.width) {
        delete attrs.width;
      }
    });
  });
}

/**
 * 将 table ASL 序列化成输出格式，方便做矩阵算法
 * @param table
 */
function jsonMLToTableStructure(table) {
  const rows = (0, _everUtils.getChildren)(table);
  const tableAttrs = (0, _everUtils.getAttributes)(table);
  const tableStructure = rows.map(row => {
    const cells = (0, _everUtils.getChildren)(row);
    const rowAttrs = (0, _everUtils.getAttributes)(row);
    const rowStructure = cells.map(cell => {
      const cellAttrs = (0, _everUtils.getAttributes)(cell);
      let rowSpan = 1;
      let colSpan = 1;

      if (cellAttrs) {
        if (typeof cellAttrs.rowSpan === 'number') {
          rowSpan = cellAttrs.rowSpan;
        }

        if (typeof cellAttrs.colSpan === 'number') {
          colSpan = cellAttrs.colSpan;
        }
      }

      return {
        rowSpan,
        colSpan,
        value: cell
      };
    });
    rowStructure.attributes = rowAttrs;
    return rowStructure;
  });
  tableStructure.attributes = tableAttrs;
  return tableStructure;
}
/**
 * 将表格矩阵还原为 ASL
 * @param tableStructure
 */


function tableStructureToJsonML(tableStructure) {
  const rows = tableStructure.map(rowStructure => {
    const cells = rowStructure.map(cell => cell.value);
    const attrs = rowStructure.attributes;
    const row = attrs ? [_types.TableTag.Tr, attrs, ...cells] : [_types.TableTag.Tr, ...cells];
    return row;
  });
  const tableAttrs = tableStructure.attributes;
  const table = tableAttrs ? [_types.TableTag.Table, tableAttrs, ...rows] : [_types.TableTag.Table, ...rows];
  return table;
}

function createEmptyCellStructure(hidden = false) {
  return {
    rowSpan: 1,
    colSpan: 1,
    value: createEmptyTableCell(hidden)
  };
}
/**
 * 订正表格的单元格结构
 * 1. 补齐 span 的单元格跨度空缺
 * 2. 订正不规整的行列
 * @param table
 */


function normalizeTableStructure(table) {
  // 第一步，填补 span 的单元格
  for (let i = 0; i < table.length; i++) {
    const row = table[i];

    for (let j = 0; j < row.length; j++) {
      const cell = row[j]; // 如果在当前行中列跨度大于 1，则在当前坐标之后 +1 填充单元格

      if (cell.colSpan > 1) {
        // 由于第一个单元格已经占 1 位，所以要 -1
        const fillCells = Array(cell.colSpan - 1).fill(true).map(createEmptyCellStructure);
        row.splice(j + 1, 0, ...fillCells);
      }
    }
  }

  for (let i = 0; i < table.length; i++) {
    const row = table[i];

    for (let j = 0; j < row.length; j++) {
      const cell = row[j]; // 如果行的跨度大于 1，则需要在下面的行中填充单元格

      if (cell.rowSpan > 1) {
        for (let k = i + 1, end = i + cell.rowSpan; k < end; k++) {
          let fillRow = table[k]; // 可能会出现一种情况，表格的行不够填充了，则这里要追加行

          if (!fillRow) {
            fillRow = Array(j).fill(false).map(createEmptyCellStructure);
            table[k] = fillRow;
          }

          const fillCells = Array(cell.colSpan).fill(true).map(createEmptyCellStructure);
          fillRow.splice(j, 0, ...fillCells);
        }
      }
    }
  } // 第二步，填补不规整的行


  const maxColSize = table.reduce((size, row) => Math.max(size, row.length), -Infinity);
  table.forEach(row => {
    const offset = maxColSize - row.length;

    if (offset > 0) {
      row.push(...Array(offset).fill(false).map(createEmptyCellStructure));
    }
  });
}

function normalizeTableSpan(table) {
  const tableStructure = jsonMLToTableStructure(table);
  normalizeTableStructure(tableStructure);
  return tableStructureToJsonML(tableStructure);
}

function normalizeTable(table) {
  // 订正单元格
  table = normalizeTableSpan(table);
  const rows = (0, _everUtils.getChildren)(table); // 空表格

  if (rows.length <= 0) {
    return table;
  }

  const firstRow = rows[0];
  const cells = (0, _everUtils.getChildren)(firstRow);
  const colsCount = cells.length;
  const tableAttrs = (0, _everUtils.getAttributes)(table); // 如果 table 的 colsWidth 缺失，则需要进行计算

  if (tableAttrs.colsWidth.length !== colsCount) {
    // 计算第一行的 td width 数据
    const colsWidth = cells.map(cell => {
      const tableCellAttrs = (0, _everUtils.getAttributes)(cell);
      return parseInt(tableCellAttrs.width || '0', 10);
    }).filter(width => width > 0); // 如果列宽的数量与列数相等，则认为是合法数据

    if (colsWidth.length === colsCount) {
      tableAttrs.colsWidth = colsWidth;
    } else {
      // 注意这个值可能需要优化，纸张在不同的模式下宽度都不同，考虑到自适应的问题，目前暂时设一个较少的值
      const colWidth = Math.floor(_constants.DEFAULT_PAGE_WIDTH / colsCount);
      tableAttrs.colsWidth = Array(colsCount).fill(colWidth);
    }
  } // 单元格数据合法化


  normalizeTableCells(table);
  return table;
}

function flatAppendTr(state, node) {
  const tagName = (0, _everUtils.getTagName)(node);
  const attrs = (0, _everUtils.getAttributes)(node);
  const chlidren = (0, _everUtils.getChildren)(node);
  let current = attrs ? [tagName, attrs] : [tagName];
  chlidren.forEach(child => {
    const childTagName = (0, _everUtils.getTagName)(child); // tr 内嵌 tr，则把嵌套的 tr 打平

    if (childTagName === tagName) {
      if ((0, _everUtils.getChildren)(current).length) {
        state.append(current);
      }

      state.append(child);
      current = attrs ? [tagName, attrs] : [tagName];
      return;
    } // 不支持 tr 内嵌套单元格以外数据类型


    if (childTagName !== 'tc') return;
    current.push(child);
  }); // 有些tr虽然没有child，但是属于合并单元格的一项，不可直接摒弃

  state.append(current);
}

function htmlToJsoML() {
  return {
    name: 'table',
    onOpenTag: (state, name, rawAttrs) => {
      if (name === 'col') {
        const table = state.closest('table');

        if (table && (0, _everUtils.isNumeric)(rawAttrs.width)) {
          const tableAttrs = (0, _everUtils.getAttributes)(table);
          tableAttrs.colsWidth.push(parseInt(rawAttrs.width, 10));
        }

        return true;
      }

      if (name === 'td' || name === 'th') {
        name = 'tc'; // eslint-disable-line no-param-reassign
      }

      if (!_constants.tagToType[name]) return false;
      const element = state.currentDom; // 创建节点

      const node = [name];
      state.push(node);

      switch (name) {
        case _types.TableTag.Table:
          {
            node.push({
              colsWidth: []
            });
            break;
          }

        case _types.TableTag.Tr:
          {
            const attrs = normalizeTrAttrs(rawAttrs);
            node.push(attrs);
            break;
          }

        case _types.TableTag.Tc:
          {
            const attrs = normalizeTcAttrs(rawAttrs, element);
            node.push(attrs);
            break;
          }

        default:
          return true;
      }

      return true;
    },
    onCloseTag: (state, name) => {
      if (name === 'td' || name === 'th') {
        name = _types.TableTag.Tc;
      }

      if (!_constants.tagToType[name]) return false;
      const node = state.pop();
      const tagName = (0, _everUtils.getTagName)(node);

      switch (tagName) {
        case _types.TableTag.Table:
          {
            const table = normalizeTable(node); // 只接受非空表格

            if ((0, _everUtils.getChildren)(table).length > 0) {
              state.append(table);
            }

            return true;
          }

        case _types.TableTag.Tr:
          {
            flatAppendTr(state, node);
            return true;
          }

        case _types.TableTag.Tc:
          {
            // 空单元格
            if ((0, _everUtils.getChildren)(node).length === 0) {
              node.push((0, _everCangjie.createEmptyParagraph)());
            }

            const attrs = (0, _everUtils.getAttributes)(node);

            if (attrs.width) {
              const width = parseFloat((0, _everUtils.parseCSSAbsoluteLength)(attrs.width, 'px')); // 如果是 0 宽单元格则丢弃

              if (width === 0) {
                return true;
              }
            } else if (attrs.hidden) {
              // 隐藏的单元这里不解析，在表格的 normalize 中会自行填充空缺的单元格
              return true;
            }

            state.append(node);
            return true;
          }

        default:
          return false;
      }
    }
  };
}
//# sourceMappingURL=htmlToJsonML.js.map