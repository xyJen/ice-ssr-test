"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _utils = require("./utils");

// table cell replacement logic.
function cell(content, node) {
  const index = Array.prototype.indexOf.call(node.parentNode?.childNodes, node);
  let prefix = ' ';
  if (index === 0) prefix = '| ';
  return prefix + content + ' |';
} //  table cell rules.


const tableCell = {
  filter: ['th', 'td'],
  replacement: function (content, node) {
    const cellContent = content.replace(/\n+/g, ' ');
    return cell(cellContent, node);
  }
}; //  table row rules.

const tableRow = {
  filter: 'tr',
  replacement: function (content, node) {
    let borderCells = '';
    const alignMap = {
      left: ':--',
      right: '--:',
      center: ':-:'
    };

    if ((0, _utils.isHeadingRow)(node)) {
      for (let i = 0; i < node.children.length; i++) {
        let border = '---';
        const align = (node.children[i].getAttribute('align') || '').toLowerCase();
        if (align) border = alignMap[align] || border;
        borderCells += cell(border, node.children[i]);
      }
    }

    return '\n' + content + (borderCells ? '\n' + borderCells : '');
  }
}; //  table rules.

const table = {
  filter: function (node) {
    if (!(0, _utils.isTable)(node)) {
      return false;
    }

    if ((0, _utils.isHeadingRow)(node.rows[0])) {
      (0, _utils.normalizeTable)(node);
      return false;
    }

    return true;
  },
  replacement: function (content) {
    content = content.replace('\n\n', '\n');
    return content;
  }
}; //  table selection rules.

const tableSection = {
  filter: ['thead', 'tbody', 'tfoot'],
  replacement: function (content) {
    return content;
  }
};
var _default = {
  tableCell,
  tableRow,
  table,
  tableSection
};
exports.default = _default;
//# sourceMappingURL=rules.js.map