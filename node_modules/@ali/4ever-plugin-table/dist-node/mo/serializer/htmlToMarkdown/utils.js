"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizeTable = normalizeTable;
exports.isTable = isTable;
exports.isHeadingRow = isHeadingRow;

function excuteByTimes(fn, times) {
  for (let i = 0; i < times; i++) {
    fn();
  }
} // 拆分 table 已合并的单元格


function normalizeTable(table) {
  const colgroup = table.getElementsByTagName('colgroup')[0];
  const colsNum = colgroup.children.length;
  const rows = Array.from(table.rows); // 处理 colSpan 合并的单元格

  rows.forEach(row => {
    for (let i = 0; i < colsNum; i++) {
      const cell = row.children[i];

      if (!cell || !(cell.colSpan > 1)) {
        continue;
      }

      const nextCell = cell.nextElementSibling;

      const correctTable = () => {
        const td = document.createElement('td');

        if (nextCell) {
          row.insertBefore(td, nextCell);
        } else {
          row.appendChild(td);
        }
      };

      excuteByTimes(correctTable, cell.colSpan - 1);
    }
  }); // 处理 rowSpan 合并的单元格

  for (let i = 0; i < colsNum; i++) {
    let range = 0;

    for (const [index, row] of rows.entries()) {
      const cell = row.children[i];

      if (!cell) {
        continue;
      }

      if (index < range) {
        // 补上单元格
        const td = document.createElement('td');
        row.insertBefore(td, cell);

        if (index === range - 1) {
          range = 0;
        }

        continue;
      }

      if (cell.rowSpan > 1) {
        range = index + cell.rowSpan;
      }
    }
  }
}

function isTable(node) {
  return node.nodeName === 'TABLE';
}

function isHeadingRow(tr) {
  const parentNode = tr.parentNode;
  return parentNode?.nodeName === 'THEAD' || parentNode?.firstChild === tr && parentNode.nodeName === 'TBODY';
}
//# sourceMappingURL=utils.js.map