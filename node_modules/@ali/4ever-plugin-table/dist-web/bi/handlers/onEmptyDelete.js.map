{"version":3,"sources":["../../../../src/bi/handlers/onEmptyDelete.ts"],"names":["Block","Commands","TableCell","isInEmptyBlock","block","text","nodes","length","onEmptyDelete","controller","next","value","selection","document","startBlock","startCell","getClosest","key","isTableCell","anchor","getClosestBlock","isCollapsed","data","list","command","replaceNodeByKey","create","moveForward"],"mappings":"AAAA,SAAqBA,KAArB,EAA4BC,QAA5B,QAA4C,oBAA5C;AACA,OAAOC,SAAP,kC,CAEA;;AACA,IAAMC,cAAc,GAAG,SAAjBA,cAAiB,CAACC,KAAD,EAAkB;AACvC,SAAOA,KAAK,IACVA,KAAK,CAACC,IAAN,KAAe,EADV,IAELD,KAAK,CAACE,KAAN,CAAYC,MAAZ,KAAuB,CAFzB;AAGD,CAJD;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,eAAe,SAASC,aAAT,CAAuBC,UAAvB,EAA+CC,IAA/C,EAAqD;AAAA,MAC1DC,KAD0D,GAChDF,UADgD,CAC1DE,KAD0D;AAAA,MAE1DC,SAF0D,GAEtBD,KAFsB,CAE1DC,SAF0D;AAAA,MAE/CC,QAF+C,GAEtBF,KAFsB,CAE/CE,QAF+C;AAAA,MAErCC,UAFqC,GAEtBH,KAFsB,CAErCG,UAFqC;AAGlE,MAAMC,SAAS,GAAGD,UAAU,GAC1BD,QAAQ,CAACG,UAAT,CAAoBF,UAAU,CAACG,GAA/B,EAAoCf,SAAS,CAACgB,WAA9C,CAD0B,GAE1B,IAFF;AAHkE,MAM1DC,MAN0D,GAM/CP,SAN+C,CAM1DO,MAN0D;AAOlE,MAAMf,KAAK,GAAGS,QAAQ,CAACO,eAAT,CAAyBD,MAAM,CAACF,GAAhC,CAAd,CAPkE,CAQlE;;AACA,MACEF,SAAS,IACTH,SAAS,CAACS,WADV,IAEAN,SAAS,CAACT,KAAV,CAAgBC,MAAhB,KAA2B,CAF3B,IAGAQ,SAAS,CAACT,KAAV,CAAgB,CAAhB,MAAuBF,KAHvB,IAIAD,cAAc,CAACC,KAAD,CALhB,EAME;AACE;AACA,QAAIA,KAAK,CAACkB,IAAN,IAAclB,KAAK,CAACkB,IAAN,CAAWC,IAA7B,EAAmC;AACjCd,MAAAA,UAAU,CAACe,OAAX,CAAmBvB,QAAQ,CAACwB,gBAA5B,EAA8CrB,KAAK,CAACa,GAApD,EAAyDjB,KAAK,CAAC0B,MAAN,CAAa,WAAb,CAAzD,EAAoFF,OAApF,CAA4FvB,QAAQ,CAAC0B,WAArG,EAAkH,CAAlH;AACD;;AACD,WAAOlB,UAAP;AACD,GArB+D,CAsBlE;;;AACA,SAAOC,IAAI,EAAX;AACD","sourcesContent":["import { Controller, Block, Commands } from '@ali/4ever-cangjie';\nimport TableCell from '../../mo/models/tableCell';\n\n// 当前是否处于一个empty block, 无任何text\nconst isInEmptyBlock = (block: Block) => {\n  return block &&\n    block.text === '' &&\n    block.nodes.length === 1\n};\n\n/** 如果触发了仓颉默认删除（包括word，line和paragraph）事件的逻辑则需要在table插件处进行拦截处理，走table自身逻辑\n * （背景：当仓颉判断当是前处于一个empty block下执行删除操作时，会通过removeNodeByKey移除该节点）\n * 因此在表格中执行删除操作时分以下几种情况\n * 1. 选中的表格为多个，不做事件拦截\n * 2. 只选中一个表格且表格内容为空，当前插件不对表格做任何处理，但需要对键盘事件进行拦截，防止cangjie通用默认处理行为影响表格逻辑\n * 3. 表格内容非空，不做事件拦截\n * 具体逻辑在 cangjie > src > commands > delete > deleteBackwardAtRange\n */\nexport default function onEmptyDelete(controller: Controller, next) {\n  const { value } = controller;\n  const { selection, document, startBlock } = value;\n  const startCell = startBlock ?\n    document.getClosest(startBlock.key, TableCell.isTableCell) as TableCell :\n    null;\n  const { anchor } = selection;\n  const block = document.getClosestBlock(anchor.key);\n  // 如果当前只选中一个表格且其为空block，仓颉默认的删除操作会把该节点直接删除，则需要阻止仓颉默认删除行为\n  if (\n    startCell &&\n    selection.isCollapsed &&\n    startCell.nodes.length === 1 &&\n    startCell.nodes[0] === block &&\n    isInEmptyBlock(block)\n  ) {\n      // 如果表格中只存在一个空任务列表节点也会走到此逻辑，此时需要用一个空的paragraph来替代删除逻辑\n      if (block.data && block.data.list) {\n        controller.command(Commands.replaceNodeByKey, block.key, Block.create('paragraph')).command(Commands.moveForward, 1);\n      }\n      return controller;\n    }\n  // 其余情况，执行仓颉的默认逻辑\n  return next();\n}\n"],"file":"onEmptyDelete.js"}