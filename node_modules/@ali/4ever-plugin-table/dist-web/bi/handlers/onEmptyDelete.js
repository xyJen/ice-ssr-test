import { Block, Commands } from '@ali/4ever-cangjie';
import TableCell from "../../mo/models/tableCell"; // 当前是否处于一个empty block, 无任何text

var isInEmptyBlock = function isInEmptyBlock(block) {
  return block && block.text === '' && block.nodes.length === 1;
};
/** 如果触发了仓颉默认删除（包括word，line和paragraph）事件的逻辑则需要在table插件处进行拦截处理，走table自身逻辑
 * （背景：当仓颉判断当是前处于一个empty block下执行删除操作时，会通过removeNodeByKey移除该节点）
 * 因此在表格中执行删除操作时分以下几种情况
 * 1. 选中的表格为多个，不做事件拦截
 * 2. 只选中一个表格且表格内容为空，当前插件不对表格做任何处理，但需要对键盘事件进行拦截，防止cangjie通用默认处理行为影响表格逻辑
 * 3. 表格内容非空，不做事件拦截
 * 具体逻辑在 cangjie > src > commands > delete > deleteBackwardAtRange
 */


export default function onEmptyDelete(controller, next) {
  var value = controller.value;
  var selection = value.selection,
      document = value.document,
      startBlock = value.startBlock;
  var startCell = startBlock ? document.getClosest(startBlock.key, TableCell.isTableCell) : null;
  var anchor = selection.anchor;
  var block = document.getClosestBlock(anchor.key); // 如果当前只选中一个表格且其为空block，仓颉默认的删除操作会把该节点直接删除，则需要阻止仓颉默认删除行为

  if (startCell && selection.isCollapsed && startCell.nodes.length === 1 && startCell.nodes[0] === block && isInEmptyBlock(block)) {
    // 如果表格中只存在一个空任务列表节点也会走到此逻辑，此时需要用一个空的paragraph来替代删除逻辑
    if (block.data && block.data.list) {
      controller.command(Commands.replaceNodeByKey, block.key, Block.create('paragraph')).command(Commands.moveForward, 1);
    }

    return controller;
  } // 其余情况，执行仓颉的默认逻辑


  return next();
}
//# sourceMappingURL=onEmptyDelete.js.map