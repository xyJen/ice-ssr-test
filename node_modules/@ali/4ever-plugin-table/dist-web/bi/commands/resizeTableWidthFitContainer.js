import resizeTableWidth from "./resizeTableWidth";
import getTableMaxWidthByContainer from "../../utils/utils/getTableMaxWidthByContainer";
export default function resizeTableWidthFitContainer(controller, table, containerWidth) {
  var view = controller.view;
  var colsWidth = [].concat(table.data.colsWidth || []);
  var totalColsWidth = colsWidth.reduce(function (acc, curr) {
    return acc + curr;
  }, 0); // 此处如果基于dataModel来寻找父节点，然后基于其宽度来进行resize会有一个问题
  // 因为从dataModel到viewModel的映射过程不是完全一一对应的，因为在viewModel中会由于标题的存在而导致部分节点被 group 包裹
  // 因此dataModel中离某个节点最近的父节点，在viewModel中其最近的父节点就变成了将其包裹的 group 节点
  // 如果group节点设置了padding，就可能会导致基于dataModel找到的最近父节点宽度大于当前table的最大可视宽度，如果基于该宽度来调整table宽度
  // 则会导致table出现滚动条。因此需要基于viewModel下来寻找table的最近父节点，因为其宽度不会包括padding的宽度，不会导致调整后出现滚动条

  if (!containerWidth) {
    containerWidth = getTableMaxWidthByContainer(controller, table);
  }

  return resizeTableWidth(controller, table, containerWidth - totalColsWidth);
}
//# sourceMappingURL=resizeTableWidthFitContainer.js.map