import _extends from "@babel/runtime/helpers/extends";
import { Commands } from '@ali/4ever-cangjie';
import getPositionOfCell from "../utils/getPositionOfCell";
import getRealNodeInTable from "../utils/getRealNodeInTable";
import setTableColsWidth from "../utils/setTableColsWidth";

var setCellData = function setCellData(controller, cell, data) {
  return controller.command(Commands.setNodeByKey, cell.key, {
    data: _extends({}, cell.data, data)
  });
};

export default function moveCols(controller, table, originIndexRange, targetIndex) {
  var _table$data;

  if (!table || !Array.isArray((_table$data = table.data) == null ? void 0 : _table$data.colsWidth) || !table.nodes) {
    return controller;
  }

  var start = originIndexRange.start,
      end = originIndexRange.end;
  var direction = end < targetIndex ? 'forward' : 'backward';
  controller.withoutNormalizing(function () {
    var tablePath = controller.value.document.assertPath(table.key);
    table.nodes.forEach(function (tr, rowIndex) {
      if (!tr.nodes) {
        return;
      }

      var trPath = tablePath.concat(rowIndex);

      for (var offset = 0; start + offset <= end; offset++) {
        var cellPath = trPath.concat(start + (direction === 'forward' ? 0 : offset));

        var _index = direction === 'forward' ? targetIndex - 1 : targetIndex + offset;

        controller.command(Commands.moveNodeByPath, cellPath, trPath, _index);
      }

      for (var colIndex = start; colIndex <= end; colIndex++) {
        var cell = tr.nodes[colIndex];

        if (!cell) {
          return;
        }

        var _cell$data = cell.data,
            _cell$data$colSpan = _cell$data.colSpan,
            colSpan = _cell$data$colSpan === void 0 ? 1 : _cell$data$colSpan,
            hidden = _cell$data.hidden;

        if (!hidden && colSpan > 1) {
          // 遇到合并单元格时，分为 2 种情况
          // 1. 合并单元格完全在移动列内，不处理
          // 2. 合并单元格被拆分为两部分，调整对应单元格 colSpan
          var colIndexOfLastOfMergedCell = colIndex + cell.data.colSpan - 1; // 处理情况 2

          if (colIndexOfLastOfMergedCell > end) {
            // 更新合并单元格（realCell）colSpan
            setCellData(controller, cell, {
              colSpan: end - colIndex + 1
            });
            var rightCellOfFirstRowOfMoveCols = tr.nodes[end + 1];
            setCellData(controller, rightCellOfFirstRowOfMoveCols, {
              colSpan: colIndexOfLastOfMergedCell - end,
              rowSpan: cell.data.rowSpan,
              hidden: false
            });
          }

          colIndex += colSpan - 1;
        } else if (hidden) {
          // 遇到 hidden 单元格时，分为 2 种情况
          // 1. 与合并单元格（realCell）不在同一行时，不处理
          // 2. 合并单元格被拆分为 2 部分，调整对应单元格 colSpan
          var realCell = getRealNodeInTable(table, rowIndex, colIndex);

          if (!realCell) {
            return;
          }

          var position = getPositionOfCell(realCell.key, table);

          var _colIndexOfLastOfMergedCell = position.colIndex + realCell.data.colSpan - 1; // 情况 2


          if (position.rowIndex === rowIndex) {
            // 更新合并单元格右侧 hidden 单元格 colSpan
            var deltaColSpan = Math.min(_colIndexOfLastOfMergedCell, end) - colIndex + 1;
            setCellData(controller, cell, {
              colSpan: deltaColSpan,
              rowSpan: realCell.data.rowSpan || 1,
              hidden: false
            }); // 更新合并单元格 colSpan

            setCellData(controller, realCell, {
              colSpan: realCell.data.colSpan - deltaColSpan
            });
          } // 当前行后面的 hidden 单元格可以跳过


          colIndex = _colIndexOfLastOfMergedCell;
        }
      }
    }); // 更新 colsWidth

    var colsWidth = [].concat(table.data.colsWidth);
    var moveColsWidth = colsWidth.slice(start, end + 1);
    var moveColsLength = end - start + 1;
    colsWidth.splice(start, moveColsLength);
    var index = start < targetIndex ? targetIndex - moveColsLength : targetIndex;
    colsWidth.splice.apply(colsWidth, [index, 0].concat(moveColsWidth));
    setTableColsWidth(controller, table, colsWidth);
  });
  return controller;
}
//# sourceMappingURL=moveCols.js.map