{"version":3,"sources":["../../../../src/bi/commands/resizeTableWidthFitContainer.ts"],"names":["resizeTableWidth","getTableMaxWidthByContainer","resizeTableWidthFitContainer","controller","table","containerWidth","view","colsWidth","data","totalColsWidth","reduce","acc","curr"],"mappings":"AAEA,OAAOA,gBAAP;AACA,OAAOC,2BAAP;AAEA,eAAe,SAASC,4BAAT,CAAsCC,UAAtC,EAA8DC,KAA9D,EAA4EC,cAA5E,EAAqG;AAAA,MAC1GC,IAD0G,GACjGH,UADiG,CAC1GG,IAD0G;AAElH,MAAMC,SAAS,aAAQH,KAAK,CAACI,IAAN,CAAWD,SAAX,IAAwB,EAAhC,CAAf;AACA,MAAME,cAAc,GAAGF,SAAS,CAACG,MAAV,CAAiB,UAACC,GAAD,EAAMC,IAAN;AAAA,WAAgBD,GAAG,GAAGC,IAAtB;AAAA,GAAjB,EAA8C,CAA9C,CAAvB,CAHkH,CAKlH;AACA;AACA;AACA;AACA;;AAEA,MAAI,CAACP,cAAL,EAAqB;AACnBA,IAAAA,cAAc,GAAGJ,2BAA2B,CAACE,UAAD,EAAaC,KAAb,CAA5C;AACD;;AAED,SAAOJ,gBAAgB,CAACG,UAAD,EAAaC,KAAb,EAAoBC,cAAc,GAAGI,cAArC,CAAvB;AACD","sourcesContent":["import { Controller } from '@ali/4ever-cangjie';\nimport Table from '../../mo/models';\nimport resizeTableWidth from './resizeTableWidth';\nimport getTableMaxWidthByContainer from '../../utils/utils/getTableMaxWidthByContainer';\n\nexport default function resizeTableWidthFitContainer(controller: Controller, table: Table, containerWidth?: number) {\n  const { view } = controller;\n  const colsWidth = [...(table.data.colsWidth || [])];\n  const totalColsWidth = colsWidth.reduce((acc, curr) => (acc + curr), 0);\n\n  // 此处如果基于dataModel来寻找父节点，然后基于其宽度来进行resize会有一个问题\n  // 因为从dataModel到viewModel的映射过程不是完全一一对应的，因为在viewModel中会由于标题的存在而导致部分节点被 group 包裹\n  // 因此dataModel中离某个节点最近的父节点，在viewModel中其最近的父节点就变成了将其包裹的 group 节点\n  // 如果group节点设置了padding，就可能会导致基于dataModel找到的最近父节点宽度大于当前table的最大可视宽度，如果基于该宽度来调整table宽度\n  // 则会导致table出现滚动条。因此需要基于viewModel下来寻找table的最近父节点，因为其宽度不会包括padding的宽度，不会导致调整后出现滚动条\n\n  if (!containerWidth) {\n    containerWidth = getTableMaxWidthByContainer(controller, table);\n  }\n\n  return resizeTableWidth(controller, table, containerWidth - totalColsWidth);\n}\n"],"file":"resizeTableWidthFitContainer.js"}