import _extends from "@babel/runtime/helpers/extends";
import { Commands } from '@ali/4ever-cangjie';
import getPositionOfCell from "../utils/getPositionOfCell";
import getRealNodeInTable from "../utils/getRealNodeInTable";

var setCellData = function setCellData(controller, cell, data) {
  return controller.command(Commands.setNodeByKey, cell.key, {
    data: _extends({}, cell.data, data)
  });
};

export default function moveRows(controller, table, originIndexRange, targetIndex) {
  var _table$data;

  if (!table || !Array.isArray((_table$data = table.data) == null ? void 0 : _table$data.colsWidth) || !table.nodes) {
    return controller;
  }

  var start = originIndexRange.start,
      end = originIndexRange.end;
  controller.withoutNormalizing(function () {
    for (var i = start; i <= end; i++) {
      var index = i < targetIndex ? targetIndex - 1 : targetIndex + i - start;
      var originTr = table.nodes[i];

      if (!originTr) {
        return;
      }

      controller.command(Commands.moveNodeByKey, originTr.key, table.key, index);
    }

    var maxColsLength = table.data.colsWidth.length;

    for (var colIndex = 0; colIndex < maxColsLength; colIndex++) {
      for (var rowIndex = start; rowIndex <= end; rowIndex++) {
        var row = table.nodes[rowIndex];

        if (!row.nodes) {
          return;
        }

        var cell = row.nodes[colIndex]; // 兼容不规则表格

        if (!cell) {
          continue;
        }

        var _cell$data = cell.data,
            _cell$data$rowSpan = _cell$data.rowSpan,
            rowSpan = _cell$data$rowSpan === void 0 ? 1 : _cell$data$rowSpan,
            hidden = _cell$data.hidden;

        if (!hidden && rowSpan > 1) {
          // 遇到合并单元格时，分为 2 种情况
          // 1. 合并单元格完全在移动行内，不处理
          // 2. 合并单元格被拆分为两部分，调整对应单元格 rowSpan
          var rowIndexOfLastOfMergedCell = rowIndex + cell.data.rowSpan - 1; // 处理情况 2

          if (rowIndexOfLastOfMergedCell > end) {
            // 更新合并单元格（realCell）colSpan
            setCellData(controller, cell, {
              rowSpan: end - rowIndex + 1
            });
            var belowCellOfCurrentColOfMoveRows = table.nodes[end + 1].nodes[colIndex];
            setCellData(controller, belowCellOfCurrentColOfMoveRows, {
              rowSpan: rowIndexOfLastOfMergedCell - end,
              colSpan: cell.data.colSpan,
              hidden: false
            });
          }

          rowIndex += rowSpan - 1;
        } else if (hidden) {
          // 遇到 hidden 单元格时，分为 2 种情况
          // 1. 与合并单元格（realCell）不在同一列时，不处理
          // 2. 合并单元格被拆分为 2 部分，调整对应单元格 rowSpan
          var realCell = getRealNodeInTable(table, rowIndex, colIndex);

          if (!realCell) {
            return;
          }

          var position = getPositionOfCell(realCell.key, table);

          var _rowIndexOfLastOfMergedCell = position.rowIndex + realCell.data.rowSpan - 1; // 情况 2


          if (position.colIndex === colIndex) {
            // 更新合并单元格右侧 hidden 单元格 colSpan
            var deltaRowSpan = Math.min(_rowIndexOfLastOfMergedCell, end) - rowIndex + 1;
            setCellData(controller, cell, {
              rowSpan: deltaRowSpan,
              colSpan: realCell.data.colSpan || 1,
              hidden: false
            }); // 更新合并单元格 rowSpan

            setCellData(controller, realCell, {
              rowSpan: realCell.data.rowSpan - deltaRowSpan
            });
          } // 当前行后面的 hidden 单元格可以跳过


          rowIndex = _rowIndexOfLastOfMergedCell;
        }
      }
    }
  });
  return controller;
}
//# sourceMappingURL=moveRows.js.map