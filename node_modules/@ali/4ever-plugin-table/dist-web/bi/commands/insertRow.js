import _extends from "@babel/runtime/helpers/extends";

/* eslint-disable no-shadow */
import { Commands } from '@ali/4ever-cangjie';
import createTableRow from "../utils/createTableRow";
import getPositionOfRow from "../utils/getPositionOfRow";
import getRealNodeInTable from "../utils/getRealNodeInTable";
import getPositionOfCell from "../utils/getPositionOfCell";
import traverseSingleRowCells from "../utils/traverseSingleRowCells";
import { isTable } from "../types";
import getVisibleCellOfRow from "../utils/getVisibleCellOfRow";
import setSelectionByTable from "../../utils/utils/setSelectionByTable";
export default function insertRow(controller, tableRow, type) {
  var value = controller.value;
  var document = value.document;
  var table = document.getClosest(tableRow.key, isTable);
  var tablePath = document.getPath(table.key);
  var triggerRowIndex = getPositionOfRow(tableRow.key, table);
  var targetRowIndex;
  var colSize = tableRow.nodes.length;

  if (type === 'insert-row-above') {
    targetRowIndex = triggerRowIndex;
  } else if (type === 'insert-row-below') {
    targetRowIndex = triggerRowIndex + 1;
  }

  var newTableRow = createTableRow(colSize, tableRow);
  controller.command(Commands.insertNodeByPath, tablePath, targetRowIndex, newTableRow);
  traverseSingleRowCells(table, targetRowIndex, triggerRowIndex, function (_targetRowIndex, colIndex, _, originalCell) {
    // 一种策略，originalCell是插入新行位置对应的原来的节点(可能不存在)
    // 这个节点如果处在realNode所在行的后面的行(非同行)，那在这个位置上的新节点就会设置为hidden
    // 同时比较colIndex以保证realNode的rowSpan只被拓充一次
    if (originalCell && originalCell.data.hidden) {
      var realNode = getRealNodeInTable(table, _targetRowIndex, colIndex);

      if (!realNode) {
        return;
      }

      var position = getPositionOfCell(realNode.key, table);

      if (position.rowIndex !== _targetRowIndex) {
        // TODO: 数据处理好再统一塞进去
        var newCell = newTableRow.nodes[colIndex];
        controller.command(Commands.setNodeByPath, [].concat(tablePath, [_targetRowIndex, colIndex]), {
          data: _extends({}, newCell.data, {
            hidden: true
          })
        });
      }

      if (position.colIndex === colIndex) {
        controller.command(Commands.setNodeByPath, [].concat(tablePath, [position.rowIndex, position.colIndex]), {
          data: _extends({}, realNode.data, {
            rowSpan: (realNode.data.rowSpan || 1) + 1
          })
        });
      }
    }
  });
  var latestTable = controller.value.document.getNodeByPath(tablePath);
  var focusCell = getVisibleCellOfRow(latestTable, targetRowIndex);

  if (!focusCell) {
    focusCell = getRealNodeInTable(latestTable, targetRowIndex, 0);
  }

  var s = controller.value.selection;
  return controller.command(Commands.select, setSelectionByTable(s, false)).command(Commands.moveToStartOfNode, focusCell);
}
//# sourceMappingURL=insertRow.js.map