{"version":3,"sources":["../../../../src/bi/commands/moveRows.ts"],"names":["Commands","getPositionOfCell","getRealNodeInTable","setCellData","controller","cell","data","command","setNodeByKey","key","moveRows","table","originIndexRange","targetIndex","Array","isArray","colsWidth","nodes","start","end","withoutNormalizing","i","index","originTr","moveNodeByKey","maxColsLength","length","colIndex","rowIndex","row","rowSpan","hidden","rowIndexOfLastOfMergedCell","belowCellOfCurrentColOfMoveRows","colSpan","realCell","position","deltaRowSpan","Math","min"],"mappings":"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","sourcesContent":["import { Controller, Commands } from '@ali/4ever-cangjie';\nimport Table from '../../mo/models';\nimport TableCell from '../../mo/models/tableCell';\nimport getPositionOfCell from '../utils/getPositionOfCell';\nimport getRealNodeInTable from '../utils/getRealNodeInTable';\n\nconst setCellData = (\n  controller: Controller,\n  cell: TableCell,\n  data: TableCell['data'],\n) => {\n  return controller.command(\n    Commands.setNodeByKey,\n    cell.key,\n    {\n      data: {\n        ...cell.data,\n        ...data,\n      },\n    },\n  );\n};\n\nexport default function moveRows(\n  controller: Controller,\n  table: Table,\n  originIndexRange: {\n    start: number;\n    end: number;\n  },\n  targetIndex: number,\n) {\n  if (\n    !table ||\n    !Array.isArray(table.data?.colsWidth) ||\n    !table.nodes\n  ) {\n    return controller;\n  }\n  const { start, end } = originIndexRange;\n  controller.withoutNormalizing(() => {\n    for (let i = start; i <= end; i++) {\n      const index = i < targetIndex ?\n        targetIndex - 1 :\n        targetIndex + i - start;\n      const originTr = table.nodes[i];\n      if (!originTr) {\n        return;\n      }\n      controller.command(\n        Commands.moveNodeByKey,\n        originTr.key,\n        table.key,\n        index,\n      );\n    }\n\n    const maxColsLength = table.data.colsWidth!.length;\n    for (let colIndex = 0; colIndex < maxColsLength; colIndex++) {\n      for (let rowIndex = start; rowIndex <= end; rowIndex++) {\n        const row = table.nodes[rowIndex];\n        if (!row.nodes) {\n          return;\n        }\n        const cell = row.nodes[colIndex];\n        // 兼容不规则表格\n        if (!cell) {\n          continue;\n        }\n        const { rowSpan = 1, hidden } = cell.data;\n        if (!hidden && rowSpan > 1) {\n          // 遇到合并单元格时，分为 2 种情况\n          // 1. 合并单元格完全在移动行内，不处理\n          // 2. 合并单元格被拆分为两部分，调整对应单元格 rowSpan\n          const rowIndexOfLastOfMergedCell = rowIndex + cell.data.rowSpan! - 1;\n          // 处理情况 2\n          if (rowIndexOfLastOfMergedCell > end) {\n            // 更新合并单元格（realCell）colSpan\n            setCellData(\n              controller,\n              cell,\n              {\n                rowSpan: end - rowIndex + 1,\n              },\n            );\n            const belowCellOfCurrentColOfMoveRows = table.nodes[end + 1].nodes[colIndex];\n            setCellData(\n              controller,\n              belowCellOfCurrentColOfMoveRows,\n              {\n                rowSpan: rowIndexOfLastOfMergedCell - end,\n                colSpan: cell.data.colSpan!,\n                hidden: false,\n              },\n            );\n          }\n          rowIndex += rowSpan - 1;\n        } else if (hidden) {\n          // 遇到 hidden 单元格时，分为 2 种情况\n          // 1. 与合并单元格（realCell）不在同一列时，不处理\n          // 2. 合并单元格被拆分为 2 部分，调整对应单元格 rowSpan\n          const realCell = getRealNodeInTable(table, rowIndex, colIndex);\n          if (!realCell) {\n            return;\n          }\n          const position = getPositionOfCell(realCell.key, table)!;\n          const rowIndexOfLastOfMergedCell =\n            position.rowIndex + realCell.data.rowSpan! - 1;\n          // 情况 2\n          if (position.colIndex === colIndex) {\n            // 更新合并单元格右侧 hidden 单元格 colSpan\n            const deltaRowSpan =\n              Math.min(rowIndexOfLastOfMergedCell, end) - rowIndex + 1;\n            setCellData(\n              controller,\n              cell,\n              {\n                rowSpan: deltaRowSpan,\n                colSpan: realCell.data.colSpan || 1,\n                hidden: false,\n              },\n            );\n            // 更新合并单元格 rowSpan\n            setCellData(\n              controller,\n              realCell,\n              {\n                rowSpan: realCell.data.rowSpan! - deltaRowSpan,\n              },\n            );\n          }\n          // 当前行后面的 hidden 单元格可以跳过\n          rowIndex = rowIndexOfLastOfMergedCell;\n        }\n      }\n    }\n  });\n  return controller;\n}\n"],"file":"moveRows.js"}