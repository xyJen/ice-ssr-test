import _extends from "@babel/runtime/helpers/extends";
import { Commands } from '@ali/4ever-cangjie';
import { isEqualWithDefault } from '@ali/4ever-utils';
import getMirrorCellOfSameBorder from "../utils/getMirrorCellOfSameBorder";

function generateBorderInfo(tableSelection, table) {
  var result = {
    leftOutline: [],
    rightOutline: [],
    topOutline: [],
    bottomOutline: [],
    leftInline: [],
    rightInline: [],
    topInline: [],
    bottomInline: []
  };
  var startRowIndex = tableSelection.startRowIndex,
      endRowIndex = tableSelection.endRowIndex,
      startColIndex = tableSelection.startColIndex,
      endColIndex = tableSelection.endColIndex;

  for (var rowIndex = startRowIndex; rowIndex <= endRowIndex; rowIndex += 1) {
    var row = table.nodes[rowIndex];
    if (!row) continue; // eslint-disable-line no-continue

    for (var colIndex = startColIndex; colIndex <= endColIndex; colIndex += 1) {
      var cell = row.nodes[colIndex];
      if (!cell) continue; // eslint-disable-line no-continue

      if (cell.data.hidden) continue;
      var colSpan = cell.data.colSpan || 1;
      var rowSpan = cell.data.rowSpan || 1;

      if (colIndex === startColIndex) {
        result.leftOutline.push(cell.key);
      } else {
        result.leftInline.push(cell.key);
      }

      if (colIndex + colSpan === endColIndex + 1) {
        result.rightOutline.push(cell.key);
      } else {
        result.rightInline.push(cell.key);
      }

      if (rowIndex === startRowIndex) {
        result.topOutline.push(cell.key);
      } else {
        result.topInline.push(cell.key);
      }

      if (rowIndex + rowSpan === endRowIndex + 1) {
        result.bottomOutline.push(cell.key);
      } else {
        result.bottomInline.push(cell.key);
      }
    }
  }

  return result;
}

var mirrorObj = {
  left: 'right',
  right: 'left',
  top: 'bottom',
  bottom: 'top'
};
var defaultBdr = {
  left: null,
  right: null,
  top: null,
  bottom: null
};

function setBorderData(controller, cell, key, options) {
  var _extends2;

  var orientation = options.orientation,
      isIncluded = options.isIncluded,
      val = options.val,
      sz = options.sz,
      color = options.color;
  var oldBdr = cell.data.bdr || {};

  var newBdr = _extends({}, oldBdr, (_extends2 = {}, _extends2[orientation] = isIncluded ? {
    color: color,
    sz: sz,
    val: val
  } : null, _extends2));

  if (!isEqualWithDefault(oldBdr, newBdr, defaultBdr)) {
    controller.command(Commands.setNodeByKey, cell.key, {
      data: _extends({}, cell.data, {
        bdr: newBdr
      })
    });
  }
}

export default function setTableBorder(controller, table, selection, borderSetType, color, sz, val) {
  if (!selection) {
    return controller;
  }

  var borderInfo = generateBorderInfo(selection, table); // all, outline, inside, left, top, right, bottom, innerHorizontal, innerVertical,

  var filterObj = {
    none: [],
    all: ['leftOutline', 'rightOutline', 'topOutline', 'bottomOutline', 'leftInline', 'rightInline', 'topInline', 'bottomInline'],
    outer: ['leftOutline', 'rightOutline', 'topOutline', 'bottomOutline'],
    inner: ['leftInline', 'rightInline', 'topInline', 'bottomInline'],
    left: ['leftOutline'],
    top: ['topOutline'],
    right: ['rightOutline'],
    bottom: ['bottomOutline'],
    horizon: ['topInline', 'bottomInline'],
    vertical: ['leftInline', 'rightInline']
  };
  Object.keys(borderInfo).forEach(function (type) {
    var keysByType = borderInfo[type];
    var matched = type.match(/(\w+)([A-Z]\w+)/);

    if (!matched) {
      return;
    }

    var orientation = matched[1];
    var inlineOrOutline = matched[2].toLowerCase();
    var mirrorOrientation = mirrorObj[orientation];
    var isOutlineIncluded = inlineOrOutline === 'outline' && filterObj[borderSetType].includes(orientation + "Outline");
    var isInlineIncluded = inlineOrOutline === 'inline' && filterObj[borderSetType].includes(orientation + "Inline");
    var isIncluded = isOutlineIncluded || isInlineIncluded;
    keysByType.forEach(function (key) {
      var tableCell = controller.value.document.getNode(key);
      var updatedTable = controller.value.document.getNode(table.key); // none比较特殊，是清空效果，其他的都是叠加效果

      if (isIncluded || borderSetType === 'none') {
        setBorderData(controller, tableCell, key, {
          color: color,
          sz: sz,
          val: val,
          orientation: orientation,
          isIncluded: isIncluded
        });
      }

      if ((isOutlineIncluded || borderSetType === 'none') && inlineOrOutline === 'outline') {
        var mirrorCell = getMirrorCellOfSameBorder(tableCell, orientation, updatedTable);

        if (mirrorCell) {
          setBorderData(controller, mirrorCell, mirrorCell.key, {
            color: color,
            sz: sz,
            val: val,
            orientation: mirrorOrientation,
            isIncluded: isOutlineIncluded
          });
        }
      }
    });
  });
  return controller;
}
//# sourceMappingURL=setTableBorder.js.map