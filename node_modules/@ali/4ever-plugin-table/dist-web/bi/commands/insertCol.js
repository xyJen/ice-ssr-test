import _extends from "@babel/runtime/helpers/extends";
import { Commands } from '@ali/4ever-cangjie';
import Table from "../../mo/models";
import createEmptyTableCell from "../utils/createEmptyTableCell";
import getRealNodeInTable from "../utils/getRealNodeInTable";
import getPositionOfCell from "../utils/getPositionOfCell";
import traverseSingleColCells from "../utils/traverseSingleColCells";
import resizeTableWidthFitContainer from "./resizeTableWidthFitContainer";
import getVisibleCellOfCol from "../utils/getVisibleCellOfCol";
import setTableColsWidth from "../utils/setTableColsWidth";
import setSelectionByTable from "../../utils/utils/setSelectionByTable";
import resizeTableToAutofitWidth from "./resizeTableToAutofitWidth";
import getTableMaxWidthByContainer from "../../utils/utils/getTableMaxWidthByContainer";
export default function insertCol(controller, table, targetColIndex, triggerColIndex, colWidth, containerWidth) {
  var value = controller.value;
  var document = value.document;
  var tablePath = document.getPath(table.key);
  controller.withoutNormalizing(function () {
    traverseSingleColCells(table, targetColIndex, triggerColIndex, function (rowIndex, finalIndex, triggerCell, originalCell) {
      var data = {}; // triggerCell: 右键在哪个上面哪个就是triggerCell
      // originalCell: 插入后新行的index，放在之前表格取的值，就是originalCell(可能不存在)

      if (triggerCell) {
        var triggerCellData = triggerCell.data;

        if (triggerCellData && triggerCellData.bdr) {
          data.bdr = triggerCellData.bdr;
        }

        if (triggerCellData && triggerCellData.fill) {
          data.fill = triggerCellData.fill;
        }
      } // 一种策略，originalCell是插入新列位置对应的原来的节点
      // 这个节点如果处在realNode所在列后面的列(非同列)，那在这个位置上的新节点就会设置为hidden
      // 同时比较rowIndex以保证realNode的colSpan只被拓充一次


      if (originalCell && originalCell.data.hidden) {
        var realNode = getRealNodeInTable(table, rowIndex, finalIndex);

        if (realNode) {
          var position = getPositionOfCell(realNode.key, table);

          if (position.colIndex !== finalIndex) {
            data.hidden = true;
          }

          if (position.rowIndex === rowIndex) {
            controller.command(Commands.setNodeByPath, [].concat(tablePath, [position.rowIndex, position.colIndex]), {
              data: _extends({}, realNode.data, {
                colSpan: (realNode.data.colSpan || 1) + 1
              })
            });
          }
        }
      }

      controller.command(Commands.insertNodeByPath, [].concat(tablePath, [rowIndex]), finalIndex, createEmptyTableCell(data));
    });
  });
  var colsWidth = [].concat(table.data.colsWidth);
  var originalTotalColsWidth = colsWidth.reduce(function (acc, curr) {
    return acc + curr;
  }, 0); // 未传入有效宽度则手动计算

  if (!colWidth) {
    var refColIndex = targetColIndex === colsWidth.length ? targetColIndex - 1 : targetColIndex;
    var refColWidth = colsWidth[refColIndex];
    colWidth = refColWidth;
  }

  colsWidth.splice(targetColIndex, 0, colWidth);
  var totalColsWidth = colsWidth.reduce(function (acc, curr) {
    return acc + curr;
  }, 0);
  setTableColsWidth(controller, table, colsWidth);

  if (Table.isAutofitWidth(table)) {
    var newTable = controller.value.document.getNodeByPath(tablePath);
    resizeTableToAutofitWidth(controller, newTable, table, containerWidth);
  } else {
    var containerW = containerWidth || getTableMaxWidthByContainer(controller, table);

    if (totalColsWidth >= containerW && originalTotalColsWidth <= containerW) {
      var updatedDoc = controller.value.document;
      var updatedTbl = updatedDoc.getNodeByPath(tablePath);
      resizeTableWidthFitContainer(controller, updatedTbl, containerW);
    }
  }

  var latestTable = controller.value.document.getNodeByPath(tablePath);
  var focusCell = getVisibleCellOfCol(latestTable, targetColIndex);

  if (!focusCell) {
    focusCell = getRealNodeInTable(latestTable, 0, targetColIndex);
  }

  if (focusCell) {
    var s = controller.value.selection;
    return controller.command(Commands.select, setSelectionByTable(s, false)).command(Commands.moveToStartOfNode, focusCell);
  }

  return controller;
}
//# sourceMappingURL=insertCol.js.map