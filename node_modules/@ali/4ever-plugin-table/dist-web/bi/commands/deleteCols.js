import _extends from "@babel/runtime/helpers/extends";

/* eslint-disable no-shadow */
import { Commands } from '@ali/4ever-cangjie';
import Table from "../../mo/models";
import isEmptyTable from "../utils/isEmptyTable";
import getRealNodeInTable from "../utils/getRealNodeInTable";
import getPositionOfCell from "../utils/getPositionOfCell";
import traverseSingleColCells from "../utils/traverseSingleColCells";
import deleteTable from "./deleteTable";
import { createTableSelectionForFocusedCell } from "../utils";
import { logNPEInfo } from "../utils/logger";
import getDataTableSelectionByTable from "../utils/getDataTableSelectionByTable";
import setSelectionByTable from "../../utils/utils/setSelectionByTable";
import resizeTableToAutofitWidth from "./resizeTableToAutofitWidth";
import toggleColHeader from "./toggleColHeader";
import filterValidData from "../../utils/utils/filterValidData";

function deleteCol(controller, table, tablePath, colIndex) {
  traverseSingleColCells(table, colIndex, colIndex, function (rowIndex, _, cell) {
    if (!cell) {
      logNPEInfo(table, {
        type: 'deleteCol',
        colIndex: colIndex,
        rowIndex: rowIndex
      });
    } // 不规则表格 cell 可能为空
    // 这里支持用户手动删除不规则的列，使表格变为规则表格


    if (!cell) {
      return;
    }

    var cellData = cell.data || {};

    if (cellData.hidden) {
      var realNode = getRealNodeInTable(table, rowIndex, colIndex);

      if (!realNode) {
        return;
      }

      var position = getPositionOfCell(realNode.key, table);

      if (position.rowIndex === rowIndex && position.colIndex < colIndex) {
        controller.command(Commands.setNodeByPath, [].concat(tablePath, [position.rowIndex, position.colIndex]), {
          data: _extends({}, realNode.data, {
            colSpan: (realNode.data.colSpan || 1) - 1
          })
        });
      }
    } else if ((cellData.colSpan || 1) > 1) {
      var inheritCellPath = [].concat(tablePath, [rowIndex, colIndex + 1]);
      controller.command(Commands.setNodeByPath, inheritCellPath, {
        data: _extends({}, cellData, {
          colSpan: (cellData.colSpan || 1) - 1
        })
      });
    }

    controller.withoutNormalizing(function (c) {
      c.command(Commands.removeNodeByPath, [].concat(tablePath, [rowIndex, colIndex]));
    });
  });
}

export default function deleteCols(controller, table) {
  var value = controller.value;
  var document = value.document,
      selection = value.selection;
  var tableSelection = getDataTableSelectionByTable(controller, table);

  if (!tableSelection) {
    tableSelection = createTableSelectionForFocusedCell(value, table);
  }

  if (!tableSelection) {
    return controller;
  }

  var _ref = tableSelection || {},
      startColIndex = _ref.startColIndex,
      endColIndex = _ref.endColIndex;

  var tablePath = document.getPath(table.key);

  for (var colIndex = endColIndex; colIndex >= startColIndex; colIndex -= 1) {
    var _updatedTable = controller.value.document.getNodeByPath(tablePath);

    deleteCol(controller, _updatedTable, tablePath, colIndex);

    if (Table.isColumnHeader(_updatedTable) && colIndex === 0) {
      toggleColHeader(controller, _updatedTable);
    }
  }

  var updatedTable = controller.value.document.getNodeByPath(tablePath);

  if (isEmptyTable(updatedTable)) {
    return controller.command(deleteTable, updatedTable);
  }

  var colsWidth = updatedTable.data.colsWidth || [];
  controller.command(Commands.setNodeByPath, tablePath, {
    data: filterValidData(_extends({}, updatedTable.data, {
      colsWidth: [].concat(colsWidth.slice(0, startColIndex), colsWidth.slice(endColIndex + 1))
    }))
  });

  if (Table.isAutofitWidth(updatedTable)) {
    var newTable = controller.value.document.getNodeByPath(tablePath);
    resizeTableToAutofitWidth(controller, newTable, updatedTable);
  }

  var latestTable = controller.value.document.getNodeByPath(tablePath);
  var colSize = latestTable.data.colsWidth.length;
  var selectedColIndex = startColIndex >= colSize ? colSize - 1 : startColIndex; // 删除列后 focus 在所删列的前一列的第一个单元格内

  for (var i = 0; i < latestTable.nodes.length; i += 1) {
    var focusCell = getRealNodeInTable(latestTable, i, selectedColIndex);

    if (focusCell) {
      var s = setSelectionByTable(selection, false).moveToStartOfNode(focusCell, controller);
      return controller.command(Commands.select, s);
    }
  }

  return controller;
}
//# sourceMappingURL=deleteCols.js.map