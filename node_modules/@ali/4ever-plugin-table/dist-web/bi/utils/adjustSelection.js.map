{"version":3,"sources":["../../../../src/bi/utils/adjustSelection.ts"],"names":["getRealNodeInTable","getPositionOfCell","adjustSelection","table","startRowIndex","startColIndex","endRowIndex","endColIndex","MAX_ROWS_INDEX","nodes","length","Array","isArray","data","colsWidth","MAX_COLS_INDEX","adjustedStartRowIndex","adjustedStartColIndex","adjustedEndRowIndex","Math","min","adjustedEndColIndex","minRowIndex","minColIndex","maxRowIndex","maxColIndex","i","cell","position","key","rowIndex","colIndex","max","rowSpan","colSpan"],"mappings":"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","sourcesContent":["import Table from '../../mo/models';\nimport getRealNodeInTable from './getRealNodeInTable';\nimport getPositionOfCell from './getPositionOfCell';\nimport { ITableSelection } from '../types';\n\n// 表格选区定义\n// 选区一定是矩形，矩形根据起点与终点(起点的对角线)定义\n// 如果波及到合并单元格，则该合并单元格整体都会被选中，起点/终点可能会变化，选区范围可能被影响而扩大\n// 起点/终点index与视觉上实际看到的网格的index相同\n// 若终点落在合并单元格，终点位置会是合并单元格本身位置加上其colSpan/rowSpan\n// 通过index取终点cell可能需要getRealNode\n// 未来出现通过行列工具栏选出的可穿越合并单元格的特殊选区时，方法和定义都会修改\n\n// 本方法是表格基础方法，容错需要做好\nexport default function adjustSelection(\n  table: Table,\n  {\n    startRowIndex, startColIndex, endRowIndex, endColIndex,\n  },\n): ITableSelection | null {\n  const MAX_ROWS_INDEX = table.nodes.length - 1;\n  if (!Array.isArray(table.data.colsWidth)) {\n    return null;\n  }\n  const MAX_COLS_INDEX = table.data.colsWidth.length - 1;\n\n  let adjustedStartRowIndex = startRowIndex;\n  let adjustedStartColIndex = startColIndex;\n  let adjustedEndRowIndex = Math.min(endRowIndex, MAX_ROWS_INDEX);\n  let adjustedEndColIndex = Math.min(endColIndex, MAX_COLS_INDEX);\n\n  while (true) {\n    let minRowIndex = adjustedStartRowIndex;\n    let minColIndex = adjustedStartColIndex;\n    let maxRowIndex = adjustedEndRowIndex;\n    let maxColIndex = adjustedEndColIndex;\n    // 上边框辐射\n    for (let i = adjustedStartColIndex; i <= adjustedEndColIndex; i++) {\n      const cell = getRealNodeInTable(table, adjustedStartRowIndex, i);\n      const position = cell ? getPositionOfCell(cell.key, table) : null;\n      minRowIndex = position ? Math.min(position.rowIndex, minRowIndex) : minRowIndex;\n    }\n    // 左边框辐射\n    for (let i = adjustedStartRowIndex; i <= adjustedEndRowIndex; i++) {\n      const cell = getRealNodeInTable(table, i, adjustedStartColIndex);\n      const position = cell ? getPositionOfCell(cell.key, table) : null;\n      minColIndex = position ? Math.min(position.colIndex, minColIndex) : minColIndex;\n    }\n    // 下边框辐射\n    for (let i = adjustedStartColIndex; i <= adjustedEndColIndex; i++) {\n      const cell = getRealNodeInTable(table, adjustedEndRowIndex, i);\n      const position = cell ? getPositionOfCell(cell.key, table) : null;\n      maxRowIndex = position\n        ? Math.max(position.rowIndex + (cell!.data?.rowSpan || 1) - 1, maxRowIndex)\n        : maxRowIndex;\n      maxRowIndex = Math.min(maxRowIndex, MAX_ROWS_INDEX);\n    }\n    // 右边框辐射\n    for (let i = adjustedStartRowIndex; i <= adjustedEndRowIndex; i++) {\n      const cell = getRealNodeInTable(table, i, adjustedEndColIndex);\n      const position = cell ? getPositionOfCell(cell.key, table) : null;\n      maxColIndex = position\n        ? Math.max(position.colIndex + (cell!.data?.colSpan || 1) - 1, maxColIndex)\n        : maxColIndex;\n      maxColIndex = Math.min(maxColIndex, MAX_COLS_INDEX);\n    }\n\n    // 向外辐射一次后，跟原结果一样，说明稳定了，是最终结果\n    if (adjustedStartRowIndex === minRowIndex\n      && adjustedStartColIndex === minColIndex\n      && adjustedEndRowIndex === maxRowIndex\n      && adjustedEndColIndex === maxColIndex) {\n      return {\n        startRowIndex: minRowIndex,\n        startColIndex: minColIndex,\n        endRowIndex: maxRowIndex,\n        endColIndex: maxColIndex,\n        key: table.key,\n      };\n    }\n\n    adjustedStartRowIndex = minRowIndex;\n    adjustedStartColIndex = minColIndex;\n    adjustedEndRowIndex = maxRowIndex;\n    adjustedEndColIndex = maxColIndex;\n  }\n}\n"],"file":"adjustSelection.js"}