{"version":3,"sources":["../../../../src/bi/utils/resizeTable.ts"],"names":["resizeTable","originalSizes","expectTotalWidth","limits","originals","slice","outputs","temps","i","outputTotal","reduce","acc","curr","inputTotal","coefficient","map","value","Math","floor","outOfLimitIndex","findIndex","v","index","length","resultColsWidth","_","max"],"mappings":"AAAA,eAAe,SAASA,WAAT,CACbC,aADa,EAEbC,gBAFa,EAGbC,MAHa,EAIb;AACA,MAAMC,SAAS,GAAGH,aAAa,CAACI,KAAd,EAAlB;AACA,MAAMC,OAAiB,GAAG,EAA1B;AACA,MAAIC,KAA2B,GAAGH,SAAlC,CAHA,CAKA;AACA;AACA;AACA;AACA;;AATA,6BAUSI,CAVT;AAWE,QAAMC,WAAW,GAAGH,OAAO,CAACI,MAAR,CAAe,UAACC,GAAD,EAAMC,IAAN;AAAA,aAAgBD,GAAG,IAAIC,IAAI,IAAI,CAAZ,CAAnB;AAAA,KAAf,EAAmD,CAAnD,CAApB;AACA,QAAMC,UAAU,GAAGT,SAAS,CAACM,MAAV,CACjB,UAACC,GAAD,EAAMC,IAAN;AAAA,aAAgBD,GAAG,IAAKC,IAAI,IAAI,CAAb,CAAnB;AAAA,KADiB,EACoB,CADpB,CAAnB;AAGA,QAAME,WAAW,GAAG,CAACZ,gBAAgB,GAAGO,WAApB,IAAmCI,UAAvD;;AACA,QAAIC,WAAW,GAAG,CAAlB,EAAqB;AACnB;AACD;;AACDP,IAAAA,KAAK,GAAGH,SAAS,CAACW,GAAV,CAAc,UAACC,KAAD,EAAW;AAC/B,UAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7B,eAAOC,IAAI,CAACC,KAAL,CAAWJ,WAAW,GAAGE,KAAzB,CAAP;AACD;;AACD,aAAO,IAAP;AACD,KALO,CAAR;AAMA,QAAMG,eAAe,GAAGZ,KAAK,CAACa,SAAN,CAAgB,UAACC,CAAD,EAAIC,KAAJ,EAAc;AACpD,aAAO,OAAOD,CAAP,KAAa,QAAb,IAAyBA,CAAC,GAAGlB,MAAM,CAACmB,KAAD,CAA1C;AACD,KAFuB,CAAxB;;AAGA,QAAIH,eAAe,KAAK,CAAC,CAAzB,EAA4B;AAC1B;AACD;;AACDb,IAAAA,OAAO,CAACa,eAAD,CAAP,GAA2BhB,MAAM,CAACgB,eAAD,CAAjC;AACAf,IAAAA,SAAS,CAACe,eAAD,CAAT,GAA6B,IAA7B;AAhCF;;AAUA,OAAK,IAAIX,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIJ,SAAS,CAACmB,MAA/B,EAAuCf,CAAC,EAAxC,EAA4C;AAAA,qBAAnCA,CAAmC;;AAAA,0BAmBxC;AAIH;;AAED,MAAMgB,eAAe,GAAGpB,SAAS,CAACW,GAAV,CAAc,UAACU,CAAD,EAAIjB,CAAJ,EAAU;AAC9C,QAAMQ,KAAK,GAAGV,OAAO,CAACE,CAAD,CAArB;;AACA,QAAI,OAAOQ,KAAP,KAAiB,QAArB,EAA+B;AAC7B,aAAOC,IAAI,CAACS,GAAL,CAASnB,KAAK,CAACC,CAAD,CAAd,EAAoBL,MAAM,CAACK,CAAD,CAA1B,CAAP;AACD;;AACD,WAAOQ,KAAP;AACD,GANuB,CAAxB;AAQA,SAAOQ,eAAP;AACD","sourcesContent":["export default function resizeTable(\n  originalSizes: Array<number | null>,\n  expectTotalWidth: number,\n  limits: number[],\n) {\n  const originals = originalSizes.slice();\n  const outputs: number[] = [];\n  let temps: Array<number | null> = originals;\n\n  // 循环次数最多跟数组长度相同\n  // 最开始一个不抽，尝试按比例缩放，发现缩放后的数组中最小的那个值小于 MIN 值的\n  // 将其抽出，设置成 MIN 值，放入 output 中。\n  // 然后对剩余的数组，针对剩余的距离，再尝试按比例缩放，发现缩放后小于 MIN 值的再抽出\n  // 如此往复，直到 output 中所有值都 >= MIN，或者缩放后没有小于 MIN 值的直接全部抽出到 output 中结束循环\n  for (let i = 0; i <= originals.length; i++) {\n    const outputTotal = outputs.reduce((acc, curr) => (acc + (curr || 0)), 0);\n    const inputTotal = originals.reduce(\n      (acc, curr) => (acc! + (curr || 0)), 0,\n    ) as number;\n    const coefficient = (expectTotalWidth - outputTotal) / inputTotal;\n    if (coefficient < 0) {\n      break;\n    }\n    temps = originals.map((value) => {\n      if (typeof value === 'number') {\n        return Math.floor(coefficient * value);\n      }\n      return null;\n    });\n    const outOfLimitIndex = temps.findIndex((v, index) => {\n      return typeof v === 'number' && v < limits[index];\n    });\n    if (outOfLimitIndex === -1) {\n      break;\n    }\n    outputs[outOfLimitIndex] = limits[outOfLimitIndex];\n    originals[outOfLimitIndex] = null;\n  }\n\n  const resultColsWidth = originals.map((_, i) => {\n    const value = outputs[i];\n    if (typeof value !== 'number') {\n      return Math.max(temps[i]!, limits[i]);\n    }\n    return value;\n  });\n\n  return resultColsWidth;\n}\n"],"file":"resizeTable.js"}