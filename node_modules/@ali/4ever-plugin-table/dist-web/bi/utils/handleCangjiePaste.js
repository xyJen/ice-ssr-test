import _extends from "@babel/runtime/helpers/extends";
import { v4 as uuid } from 'uuid';
import { noop } from 'lodash-es';
import { Message } from '@ali/we-design-next';
import { Commands } from '@ali/4ever-cangjie';
import Table from "../../mo/models";
import TableRow from "../../mo/models/tableRow";
import isSelectionInTableCell from "../utils/isSelectionInTableCell";
import getPositionOfCell from "../utils/getPositionOfCell";
import adjustSelection from "../utils/adjustSelection";
import { isTable, isTableCell } from "../types";
import insertRow from "../commands/insertRow";
import insertCol from "../commands/insertCol";
import splitCell from "../commands/splitCell";
import selectTableSelection from "../commands/selectTableSelection";
import { emptyTableSelection } from "../actions";
import { MIN_COL_WIDTH } from "../constants";
import { moveToStartOfCell } from "../utils/selectionCommands";
import utils from "../../utils/utils";
import { normalizeFragment } from '@ali/4ever-plugin-clipboard';
var filterValidData = utils.filterValidData,
    setSelectionByTable = utils.setSelectionByTable;
var messageKey = uuid().slice(0, 8);
export function handleCangjiePaste(controller, payload, next) {
  if (next === void 0) {
    next = noop;
  }

  // 处理含有表头行/列的表格
  var value = controller.value;
  var nativeFragment = payload.fragment,
      tableConfig = payload.tableConfig;
  if (!nativeFragment) return next();
  var fragment = normalizeFragment(nativeFragment);

  var _ref = tableConfig || {},
      _ref$locale = _ref.locale,
      locale = _ref$locale === void 0 ? {} : _ref$locale;

  var tables = fragment.filterDescendants(Table.isTable);

  for (var i = 0; i < tables.length; i++) {
    var table = tables[i];

    if (Table.isColumnHeader(table) || Table.isRowHeader(table)) {
      // NOTE: 需要先执行 setTableHeaderStyle
      var _ref2 = tableConfig || {},
          setTableHeaderStyle = _ref2.setTableHeaderStyle;

      setTableHeaderStyle == null ? void 0 : setTableHeaderStyle();
      break;
    }
  }

  var document = value.document,
      startBlock = value.startBlock,
      selection = value.selection;
  var tableSelection = controller.query('tableSelection');

  if (!fragment.nodes.length) {
    return next();
  }

  var anchor = selection.anchor,
      focus = selection.focus;
  var anchorTable = document.getClosest(anchor.key, Table.isTable);
  var focusTable = document.getClosest(focus.key, Table.isTable); // 无表格选区且 anchor、focus 不在同一个表格内时，禁止粘贴

  if (!tableSelection && selection.isExpanded) {
    if (anchorTable && focusTable && !controller.query('isTableFromSameOrigin', {
      node: anchorTable,
      tableKey: focusTable.key
    })) {
      return controller;
    }
  }

  var hasTableInFragment = hasTable(fragment);

  if (fragment.nodes.length === 1 && !isRealTable(fragment.nodes[0]) || fragment.nodes.length > 1) {
    var insertedFragment = hasTableInFragment ? removeTable(fragment) : fragment;
    /**
     * 存在表格选区时，下列情况将单元格替换为 fragment
     * 1. 粘贴板里只有一个节点，且节点不是表格
     * 2. 粘贴板里有多个节点（fragment 需要过滤表格）
     */

    if (tableSelection) {
      if (hasTableInFragment) {
        messageUnablePasteTable(locale);
      }

      var t = document.getNode(tableSelection.key);
      controller.run('onAction', emptyTableSelection(t));
      var _startRowIndex = tableSelection.startRowIndex,
          _startColIndex = tableSelection.startColIndex,
          _endRowIndex = tableSelection.endRowIndex,
          _endColIndex = tableSelection.endColIndex;
      var tablePath = document.getPath(t.key);
      controller.withoutNormalizing(function () {
        for (var rowIndex = _startRowIndex; rowIndex <= _endRowIndex; rowIndex += 1) {
          var row = t.nodes[rowIndex];
          if (!row) continue;

          for (var colIndex = _startColIndex; colIndex <= _endColIndex; colIndex += 1) {
            var cell = row.nodes[colIndex];
            if (!cell) continue;
            var cellPath = [].concat(tablePath, [rowIndex, colIndex]);
            var newCell = controller.value.document.getNodeByPath(cellPath);
            var s = controller.value.selection;
            var newS = s.moveAnchorToStartOfNode(newCell, controller).moveFocusToEndOfNode(newCell, controller);
            controller.command(Commands.select, newS).command(Commands.insertFragment, insertedFragment);
          }
        }

        selectTableSelection(controller, t, tableSelection);
      });
      return controller;
    } else if (anchorTable && focusTable && hasTableInFragment) {
      messageUnablePasteTable(locale);
      return controller.command(Commands.insertFragment, insertedFragment);
    }
  }

  if (fragment.nodes.length > 1 || fragment.nodes[0].type !== 'table') {
    return next();
  }

  if (!tableSelection && !isSelectionInTableCell(value, {
    excludeColumns: true
  })) {
    controller.command(Commands.splitBlock).command(Commands.moveBackward, 1);
    var _t = fragment.nodes[0];
    var path = fragment.getPath(_t.key);
    var adjustColsWidth = getAdjustTableColsWidth(_t);
    var newFragment = fragment.setNode(path, {
      data: filterValidData(_extends({}, _t.data || {}, {
        colsWidth: adjustColsWidth
      }))
    });
    return controller.command('insertFragmentByClipboard', newFragment);
  }

  var targetTable = tableSelection ? document.getNode(tableSelection.key) : document.getClosest(startBlock.key, isTable);

  if (!targetTable) {
    return;
  } // 以下处理复制单个表格至表格内场景


  var targetTablePath = document.getPath(targetTable.key);
  if (!targetTablePath) return;
  var startCell = tableSelection ? document.getNodeByPath([].concat(targetTablePath, [tableSelection.startRowIndex, tableSelection.startColIndex])) : document.getClosest(startBlock.key, isTableCell);
  var clipboardTable = fragment.nodes[0];

  if (tableSelection) {
    clipboardTable = adjustClipboardTableWithSelection(clipboardTable, tableSelection);
  }

  var position = getPositionOfCell(startCell.key, targetTable); // 粘贴时被波及的区域解除合并单元格，否则粘贴时结构可能被破坏

  var startRowIndex = position.rowIndex;
  var startColIndex = position.colIndex;
  var endRowIndex = Math.min(position.rowIndex + clipboardTable.nodes.length - 1, targetTable.nodes.length - 1); // @ts-ignore

  var endColIndex = Math.min(position.colIndex + clipboardTable.nodes[0].nodes.length - 1, targetTable.nodes[0].nodes.length - 1);
  var area = adjustSelection(targetTable, {
    startRowIndex: startRowIndex,
    startColIndex: startColIndex,
    endRowIndex: endRowIndex,
    endColIndex: endColIndex
  });
  splitCell(controller, targetTable, area || undefined);
  targetTable = controller.value.document.getNodeByPath(targetTablePath);

  for (var rowIndex = 0; rowIndex < clipboardTable.nodes.length; rowIndex += 1) {
    var targetRowIndex = position.rowIndex + rowIndex;
    var targetRowPath = [].concat(targetTablePath, [targetRowIndex]);
    var targetRow = controller.value.document.getNodeByPath(targetRowPath);

    if (!targetRow) {
      insertRow(controller, targetTable.nodes[targetRowIndex - 1], 'insert-row-below'); // update target

      targetTable = controller.value.document.getNodeByPath(targetTablePath);
      targetRow = controller.value.document.getNodeByPath(targetRowPath);
    }

    var row = clipboardTable.nodes[rowIndex];

    var _loop = function _loop(colIndex) {
      var targetColIndex = position.colIndex + colIndex;
      var targetCell = targetRow.nodes[targetColIndex];

      if (!targetCell) {
        // @ts-ignore
        // eslint-disable-next-line no-shadow
        var lastColIndex = targetTable.nodes[0].nodes.length - 1;
        var colWidth = (targetTable.data.colsWidth || [])[lastColIndex];
        insertCol(controller, targetTable, targetColIndex, targetColIndex, colWidth); // update targets

        targetTable = controller.value.document.getNodeByPath(targetTablePath);
        targetRow = controller.value.document.getNodeByPath(targetRowPath); // @ts-ignore

        targetCell = targetRow.nodes[targetColIndex];
      }

      var targetCellPath = [].concat(targetTablePath, [targetRowIndex, targetColIndex]);

      var _loop2 = function _loop2(childIndex) {
        controller.withoutNormalizing(function (c) {
          c.command(Commands.removeNodeByPath, [].concat(targetCellPath, [childIndex]));
        });
      };

      for (var childIndex = targetCell.nodes.length - 1; childIndex >= 0; childIndex -= 1) {
        _loop2(childIndex);
      }

      var cell = row.nodes[colIndex];

      for (var _childIndex = cell.nodes.length - 1; _childIndex >= 0; _childIndex -= 1) {
        controller.command(Commands.insertNodeByPath, targetCellPath, 0, cell.nodes[_childIndex]);
      }

      controller.command(Commands.setNodeByPath, targetCellPath, {
        data: cell.data
      });
    };

    for (var colIndex = 0; colIndex < row.nodes.length; colIndex += 1) {
      _loop(colIndex);
    }
  } // 恢復選區


  if (tableSelection) {
    selectTableSelection(controller, targetTable, tableSelection);
    var rangeSelection = controller.value.selection;
    rangeSelection = setSelectionByTable(rangeSelection, false);
    controller.command(Commands.select, rangeSelection);
  } else if (position) {
    targetTable = controller.value.document.getNodeByPath(targetTablePath);
    var _rowIndex = position.rowIndex,
        _colIndex = position.colIndex;
    moveToStartOfCell(controller, targetTable, _rowIndex, _colIndex);
  }

  return controller;
}

function messageUnablePasteTable(locale) {
  (locale == null ? void 0 : locale.pasteTipCannotPasteTableHere) && Message.info(locale == null ? void 0 : locale.pasteTipCannotPasteTableHere, {
    key: messageKey
  });
}

function isRealTable(n) {
  return Table.isTable(n) && !n.data.sr;
}

function hasTable(fragment) {
  return !!fragment.findDescendant(isRealTable);
}

function removeTable(fragment) {
  var drops = fragment.filterDescendants(isRealTable);
  var result = fragment;
  drops.forEach(function (n) {
    var path = result.getPath(n.key);

    if (path) {
      result = result.removeNode(path);
    }
  });
  return result;
}

function adjustClipboardTableWithSelection(clipboardTable, selection) {
  var startRowIndex = selection.startRowIndex,
      startColIndex = selection.startColIndex,
      endRowIndex = selection.endRowIndex,
      endColIndex = selection.endColIndex;
  var width = endColIndex - startColIndex + 1;
  var height = endRowIndex - startRowIndex + 1;
  return Table.create({
    data: clipboardTable.data,
    nodes: clipboardTable.nodes.slice(0, height).map(function (row) {
      return TableRow.create({
        data: row.data,
        // @ts-ignore
        nodes: row.nodes.slice(0, width)
      });
    })
  });
}

function getAdjustTableColsWidth(table) {
  var data = table.data || {};
  var colsWidth = data.colsWidth;

  if (!Array.isArray(colsWidth)) {
    colsWidth = [];
  } // 自适应表格不做矫正


  if (Table.isAutofitWidth(table)) return colsWidth;
  return colsWidth.map(function (cw) {
    return Math.max(cw, MIN_COL_WIDTH);
  });
}
//# sourceMappingURL=handleCangjiePaste.js.map