import getRealNodeInTable from "./getRealNodeInTable";
import getPositionOfCell from "./getPositionOfCell";
// 表格选区定义
// 选区一定是矩形，矩形根据起点与终点(起点的对角线)定义
// 如果波及到合并单元格，则该合并单元格整体都会被选中，起点/终点可能会变化，选区范围可能被影响而扩大
// 起点/终点index与视觉上实际看到的网格的index相同
// 若终点落在合并单元格，终点位置会是合并单元格本身位置加上其colSpan/rowSpan
// 通过index取终点cell可能需要getRealNode
// 未来出现通过行列工具栏选出的可穿越合并单元格的特殊选区时，方法和定义都会修改
// 本方法是表格基础方法，容错需要做好
export default function adjustSelection(table, _ref) {
  var startRowIndex = _ref.startRowIndex,
      startColIndex = _ref.startColIndex,
      endRowIndex = _ref.endRowIndex,
      endColIndex = _ref.endColIndex;
  var MAX_ROWS_INDEX = table.nodes.length - 1;

  if (!Array.isArray(table.data.colsWidth)) {
    return null;
  }

  var MAX_COLS_INDEX = table.data.colsWidth.length - 1;
  var adjustedStartRowIndex = startRowIndex;
  var adjustedStartColIndex = startColIndex;
  var adjustedEndRowIndex = Math.min(endRowIndex, MAX_ROWS_INDEX);
  var adjustedEndColIndex = Math.min(endColIndex, MAX_COLS_INDEX);

  while (true) {
    var minRowIndex = adjustedStartRowIndex;
    var minColIndex = adjustedStartColIndex;
    var maxRowIndex = adjustedEndRowIndex;
    var maxColIndex = adjustedEndColIndex; // 上边框辐射

    for (var i = adjustedStartColIndex; i <= adjustedEndColIndex; i++) {
      var cell = getRealNodeInTable(table, adjustedStartRowIndex, i);
      var position = cell ? getPositionOfCell(cell.key, table) : null;
      minRowIndex = position ? Math.min(position.rowIndex, minRowIndex) : minRowIndex;
    } // 左边框辐射


    for (var _i = adjustedStartRowIndex; _i <= adjustedEndRowIndex; _i++) {
      var _cell = getRealNodeInTable(table, _i, adjustedStartColIndex);

      var _position = _cell ? getPositionOfCell(_cell.key, table) : null;

      minColIndex = _position ? Math.min(_position.colIndex, minColIndex) : minColIndex;
    } // 下边框辐射


    for (var _i2 = adjustedStartColIndex; _i2 <= adjustedEndColIndex; _i2++) {
      var _data;

      var _cell2 = getRealNodeInTable(table, adjustedEndRowIndex, _i2);

      var _position2 = _cell2 ? getPositionOfCell(_cell2.key, table) : null;

      maxRowIndex = _position2 ? Math.max(_position2.rowIndex + (((_data = _cell2.data) == null ? void 0 : _data.rowSpan) || 1) - 1, maxRowIndex) : maxRowIndex;
      maxRowIndex = Math.min(maxRowIndex, MAX_ROWS_INDEX);
    } // 右边框辐射


    for (var _i3 = adjustedStartRowIndex; _i3 <= adjustedEndRowIndex; _i3++) {
      var _data2;

      var _cell3 = getRealNodeInTable(table, _i3, adjustedEndColIndex);

      var _position3 = _cell3 ? getPositionOfCell(_cell3.key, table) : null;

      maxColIndex = _position3 ? Math.max(_position3.colIndex + (((_data2 = _cell3.data) == null ? void 0 : _data2.colSpan) || 1) - 1, maxColIndex) : maxColIndex;
      maxColIndex = Math.min(maxColIndex, MAX_COLS_INDEX);
    } // 向外辐射一次后，跟原结果一样，说明稳定了，是最终结果


    if (adjustedStartRowIndex === minRowIndex && adjustedStartColIndex === minColIndex && adjustedEndRowIndex === maxRowIndex && adjustedEndColIndex === maxColIndex) {
      return {
        startRowIndex: minRowIndex,
        startColIndex: minColIndex,
        endRowIndex: maxRowIndex,
        endColIndex: maxColIndex,
        key: table.key
      };
    }

    adjustedStartRowIndex = minRowIndex;
    adjustedStartColIndex = minColIndex;
    adjustedEndRowIndex = maxRowIndex;
    adjustedEndColIndex = maxColIndex;
  }
}
//# sourceMappingURL=adjustSelection.js.map