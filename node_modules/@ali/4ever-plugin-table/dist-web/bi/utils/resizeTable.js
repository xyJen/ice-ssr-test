export default function resizeTable(originalSizes, expectTotalWidth, limits) {
  var originals = originalSizes.slice();
  var outputs = [];
  var temps = originals; // 循环次数最多跟数组长度相同
  // 最开始一个不抽，尝试按比例缩放，发现缩放后的数组中最小的那个值小于 MIN 值的
  // 将其抽出，设置成 MIN 值，放入 output 中。
  // 然后对剩余的数组，针对剩余的距离，再尝试按比例缩放，发现缩放后小于 MIN 值的再抽出
  // 如此往复，直到 output 中所有值都 >= MIN，或者缩放后没有小于 MIN 值的直接全部抽出到 output 中结束循环

  var _loop = function _loop(i) {
    var outputTotal = outputs.reduce(function (acc, curr) {
      return acc + (curr || 0);
    }, 0);
    var inputTotal = originals.reduce(function (acc, curr) {
      return acc + (curr || 0);
    }, 0);
    var coefficient = (expectTotalWidth - outputTotal) / inputTotal;

    if (coefficient < 0) {
      return "break";
    }

    temps = originals.map(function (value) {
      if (typeof value === 'number') {
        return Math.floor(coefficient * value);
      }

      return null;
    });
    var outOfLimitIndex = temps.findIndex(function (v, index) {
      return typeof v === 'number' && v < limits[index];
    });

    if (outOfLimitIndex === -1) {
      return "break";
    }

    outputs[outOfLimitIndex] = limits[outOfLimitIndex];
    originals[outOfLimitIndex] = null;
  };

  for (var i = 0; i <= originals.length; i++) {
    var _ret = _loop(i);

    if (_ret === "break") break;
  }

  var resultColsWidth = originals.map(function (_, i) {
    var value = outputs[i];

    if (typeof value !== 'number') {
      return Math.max(temps[i], limits[i]);
    }

    return value;
  });
  return resultColsWidth;
}
//# sourceMappingURL=resizeTable.js.map