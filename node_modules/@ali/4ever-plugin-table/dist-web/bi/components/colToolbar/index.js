import _extends from "@babel/runtime/helpers/extends";

/* eslint-disable @typescript-eslint/no-shadow */

/* eslint-disable max-lines */

/* eslint-disable react/no-find-dom-node */
import * as React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import * as ReactDOM from 'react-dom';
import styled from 'styled-components';
import { throttle } from 'lodash-es';
import fastdom from 'fastdom';
import { domUtils } from '@ali/4ever-cangjie';
import Table from "../../../mo/models";
import { getBoundingRelativeRect, getRelativeMouseEvent } from '@ali/4ever-utils';
import { DISTANCE_BETWEEN_DELETE_BUTTON_AND_TOOLBAR, DISTANCE_BETWEEN_INSERT_BUTTON_AND_TOOLBAR, DRAG_TRIGGER_TIME, MIN_COL_WIDTH, THEME, TOOLBAR_ITEM_SIZE } from "../../constants";
import { TableColToolbarItem } from "./tableColToolbarItem";
import { ColResizer } from "../styled";
import { clickTableToolbar, deleteTableCols, insertTableCol, moveTableCols } from "../../actions";
import InlineToolbarInsertButton from "../inlineToolbarButtons/inlineToolbarInsertButton";
import InlineToolbarDeleteButton from "../inlineToolbarButtons/inlineToolbarDeleteButton";
import InsertButtonIndicator, { GAP_BEWTEEN_INDICATOR_TOOLBAR, INDICATOR_WRAPPER_WIDTH } from "../inlineToolbarButtons/insertButtonIndicator";
import DragElement from "../colToolbar/dragElement";
import { scrollHorizontal } from "../../utils/scrollContainer";
import createToolbarWithTableSeletion from "../createToolbarWithTableSelection";
import getDataTableSelectionByTable from "../../utils/getDataTableSelectionByTable";
import { REALTABLE_PADDING, SCROLL_BAR_HEIGHT, STICKY_ROW_TOP_HEIGHT, STICKY_TOOLBAR_INDEX_MAP } from "../../../utils/constants";
import * as hooks from "../../../utils/hooks";
var usePixelColsWidth = hooks.usePixelColsWidth,
    useRowIsSticky = hooks.useRowIsSticky,
    useScrollableContainerRect = hooks.useScrollableContainerRect,
    useTableScrollContainerWidth = hooks.useTableScrollContainerWidth,
    useTableScrollContainerScrollLeft = hooks.useTableScrollContainerScrollLeft;
var fallbackRect = {
  left: -1,
  top: -1,
  right: -1,
  bottom: -1,
  height: -1,
  width: -1
};
var Wrapper = /*#__PURE__*/styled.div(["visibility:hidden;pointer-events:none;&[data-sticky=\"true\"]{position:fixed;height:", "px;overflow:hidden;z-index:", ";[data-testid=\"table-col-toolbar\"]{position:absolute;bottom:0;}}"], STICKY_ROW_TOP_HEIGHT, STICKY_TOOLBAR_INDEX_MAP.colToolbar);
var ColToolbarWrapper = /*#__PURE__*/styled.div(["position:relative;z-index:3;"]);
var ColToolbarResizer = /*#__PURE__*/styled.div(["position:absolute;top:0;width:7px;height:", "px;margin-left:-3px;background-color:transparent;z-index:1;cursor:col-resize;&:hover{background-color:", ";}"], function (props) {
  return TOOLBAR_ITEM_SIZE / props.scale;
}, THEME.blue3);
var ColInlineToolbar = /*#__PURE__*/styled.div(["position:absolute;z-index:101;transition:opacity ease-in-out 0.25s;"]);

function TableColToolbar(props) {
  var _table$data2, _table$data2$colsWidt;

  var table = props.table,
      controller = props.controller,
      tableRef = props.tableRef,
      positionedAncestorRef = props.positionedAncestorRef,
      scrollContainer = props.scrollContainer,
      zoomContainer = props.zoomContainer,
      colIndicatorRef = props.colIndicatorRef,
      isTableSelected = props.isTableSelected,
      selection = props.selection,
      scale = props.scale,
      locale = props.locale,
      isHideDeleteButton = props.isHideDeleteButton,
      isHoverCornerToolbar = props.isHoverCornerToolbar,
      getLastActiveTableKey = props.getLastActiveTableKey,
      onContextMenu = props.onContextMenu,
      onSelect = props.onSelect,
      onColResize = props.onColResize,
      onGetAllColsNodes = props.onGetAllColsNodes,
      setIsHighlightSelection = props.setIsHighlightSelection,
      hoverSelection = props.hoverSelection,
      setHoverSelection = props.setHoverSelection;

  var _usePixelColsWidth = usePixelColsWidth(),
      colsWidth = _usePixelColsWidth[0];

  var _useRowIsSticky = useRowIsSticky(),
      isSticky = _useRowIsSticky[0];

  var isColumnHeader = Table.isColumnHeader(table);

  var _React$useState = React.useState(false),
      contextMenuVisible = _React$useState[0],
      setContextMenuVisible = _React$useState[1];

  var _React$useState2 = React.useState(-1),
      positionOfInsertButton = _React$useState2[0],
      setPositionOfInsertButton = _React$useState2[1];

  var _React$useState3 = React.useState(false),
      isHoverDelete = _React$useState3[0],
      setIsHoverDelete = _React$useState3[1];

  var _React$useState4 = React.useState({
    colIndex: -1,
    left: 0,
    top: 0,
    colResizerHeight: 0
  }),
      resizingColData = _React$useState4[0],
      setResizingColData = _React$useState4[1];

  var _React$useState5 = React.useState(-1),
      hoverToolbarItemIndex = _React$useState5[0],
      setHoverToolbarItemIndex = _React$useState5[1];

  var _React$useState6 = React.useState(false),
      isDragging = _React$useState6[0],
      setIsDragging = _React$useState6[1];

  var _React$useState7 = React.useState(0),
      draggingColWidth = _React$useState7[0],
      setDraggingColWidth = _React$useState7[1];

  var colToolbarRef = React.useRef(null);
  var toolbarWrapperRef = React.useRef(null);
  var resizingColDataRef = React.useRef({
    colIndex: -1,
    left: 0,
    top: 0,
    colResizerHeight: 0
  });
  var colSelectionRectRef = React.useRef(null);
  var insetBtnPosRef = React.useRef(-1);
  var draggingColResizerRef = React.useRef(null);
  var startClientXRef = React.useRef(null);
  var startPositionLeftRef = React.useRef(0);
  var originBodyCursorRef = React.useRef('');
  var deleteButtonRef = React.useRef(null);
  var insertButtonRef = React.useRef(null);
  var colsNodes = React.useRef([]);
  var deleteButtonLeftRef = React.useRef(-1);
  var dragElementRef = React.useRef(null);
  var startSelectIndexRef = React.useRef(-1);
  var getAllColsNodes = React.useCallback(function () {
    return colsNodes.current;
  }, []);
  var getColsRects = React.useCallback(function () {
    return getAllColsNodes().map(function (node) {
      var rect = node.getBoundingClientRect();
      return rect || fallbackRect;
    });
  }, [getAllColsNodes]);
  var isSelectWholeCol = React.useCallback(function () {
    return controller.query('isSelectWholeCol', {
      node: table
    });
  }, [controller, table]);
  var getColItemRect = React.useCallback(function (index) {
    var thisNode = ReactDOM.findDOMNode(colToolbarRef.current);
    var colNode = thisNode.children[index * 2];

    if (!colNode) {
      return null;
    }

    var colRect = getBoundingRelativeRect(colNode, zoomContainer);
    return colRect;
  }, [zoomContainer]);
  var getSelectedIndexRange = React.useCallback(function () {
    if (!selection) {
      return null;
    }

    var tableSelection = getDataTableSelectionByTable(controller, table);

    if (!tableSelection) {
      return null;
    }

    var isSelectWholeTable = controller.query('isSelectWholeTable', {
      node: table
    });

    if (isSelectWholeTable) {
      return null;
    }

    var _ref = tableSelection,
        startColIndex = _ref.startColIndex,
        endColIndex = _ref.endColIndex;

    if (!table.nodes) {
      return null;
    }

    if (isSelectWholeCol()) {
      return {
        start: startColIndex,
        end: endColIndex
      };
    }

    return null;
  }, [controller, table, selection, isSelectWholeCol]);
  var getSortedSelectedRange = React.useCallback(function (r) {
    var selectedIndexRange = getSelectedIndexRange();
    var range = r || selectedIndexRange;

    if (!range) {
      return null;
    }

    var start = range.start,
        end = range.end;
    var min = Math.min(start, end);
    var max = Math.max(start, end);
    return {
      min: min,
      max: max
    };
  }, [getSelectedIndexRange]);
  var getColToolbarTop = React.useCallback(function () {
    if (!selection) {
      return null;
    }

    var thisNode = ReactDOM.findDOMNode(colToolbarRef.current);
    var thisRect = getBoundingRelativeRect(thisNode, zoomContainer);
    return {
      top: thisRect.top
    };
  }, [selection, zoomContainer]);
  var shouldHideButton = React.useCallback(function (relativeLeft) {
    var thisNode = ReactDOM.findDOMNode(colToolbarRef.current);

    if (!thisNode || !scrollContainer.current) {
      return undefined;
    }

    var tableRect = getBoundingRelativeRect(scrollContainer.current, zoomContainer);
    return relativeLeft < -26 || relativeLeft - tableRect.right > 0;
  }, [zoomContainer, scrollContainer]);
  var calcColsWidth = React.useCallback(function (startIndex, endIndex) {
    if (!Array.isArray(colsWidth)) {
      return 0;
    }

    if (endIndex < startIndex) return 0;
    return colsWidth.slice(startIndex, endIndex + 1).reduce(function (acc, w) {
      return acc + w;
    }, 0);
  }, [colsWidth]); // @ts-ignore

  var updateInsertButtonStyle = React.useCallback(function () {
    if (!selection || positionOfInsertButton === -1 || !toolbarWrapperRef.current || positionOfInsertButton === -1 || !Array.isArray(colsWidth)) {
      return;
    }

    var relativeLeft = -1;
    var toolbarRect = getBoundingRelativeRect(toolbarWrapperRef.current, zoomContainer);
    var insertButtonNode = ReactDOM.findDOMNode(insertButtonRef.current);

    if (!insertButtonNode) {
      return;
    }

    var insertButtonRect = getBoundingRelativeRect(insertButtonNode, zoomContainer);
    relativeLeft = calcColsWidth(0, positionOfInsertButton - 1) + toolbarRect.left;
    relativeLeft -= insertButtonRect.width / 2;
    var result = getColToolbarTop();
    if (!result) return null;
    var top = result.top;
    var insertButtonLeft = relativeLeft / scale + 1; // 1px作为修正值

    var curTop = Math.abs(top / scale - insertButtonNode.offsetHeight - DISTANCE_BETWEEN_INSERT_BUTTON_AND_TOOLBAR);
    insertButtonNode.style.top = curTop + "px";
    insertButtonNode.style.left = insertButtonLeft + "px";
    var shouldHide = shouldHideButton(relativeLeft);

    if (shouldHide) {
      insertButtonNode.style.visibility = 'hidden';
    } else {
      insertButtonNode.style.visibility = 'visible';
    }
  }, [selection, positionOfInsertButton, colsWidth, zoomContainer, calcColsWidth, getColToolbarTop, scale, shouldHideButton]);
  var setRectStyle = React.useCallback(function (node, startIndex, endIndex, bgColor, borderColr) {
    if (!Array.isArray(colsWidth)) {
      return;
    }

    var left = calcColsWidth(0, startIndex - 1);
    node.style.left = left + "px";
    var width = calcColsWidth(startIndex, endIndex);
    node.style.border = "1px solid " + borderColr;
    node.style.borderBottom = 'unset';

    if (endIndex === colsWidth.length - 1) {
      node.style.borderTopRightRadius = '3px';
    } else {
      node.style.borderTopRightRadius = 'unset';
    }

    node.style.width = width + 1 + "px";

    if (bgColor) {
      node.style.backgroundColor = bgColor;
    }
  }, [colsWidth, calcColsWidth]);
  var updateColSelectionRectStyle = React.useCallback(function () {
    var selectedIndexRange = getSelectedIndexRange();

    if (!selection || !table.data.colsWidth || isHoverCornerToolbar) {
      return;
    }

    var startColIndex = selection.startColIndex,
        endColIndex = selection.endColIndex;
    var colSelectionNode = ReactDOM.findDOMNode(colSelectionRectRef.current);

    if (!colSelectionNode) {
      return;
    } // 全选表格的时候工具栏背景色也需要变化


    var isSelectWholeTable = controller.query('isSelectWholeTable', {
      node: table
    });

    if (selectedIndexRange || isSelectWholeTable) {
      var bgColor = isHoverDelete ? THEME.red1 : THEME.blue1;
      var borderColor = isHoverDelete ? THEME.red1 : THEME.blue3;
      setRectStyle(colSelectionNode, startColIndex, endColIndex, bgColor, borderColor);
    } else {
      setRectStyle(colSelectionNode, startColIndex, endColIndex, THEME.toolbarBgColor.hover, THEME.toolbarBorderColor);
    }
  }, [getSelectedIndexRange, selection, table, controller, isHoverDelete, setRectStyle, isHoverCornerToolbar]); // hover到汉堡的时候高亮工具栏

  var setItemsRectStyleByRange = React.useCallback(function (startColIndex, endColIndex, bgColor, borderColor) {
    var colSelectionNode = ReactDOM.findDOMNode(colSelectionRectRef.current);

    if (!colSelectionNode) {
      return;
    }

    setRectStyle(colSelectionNode, startColIndex, endColIndex, bgColor, borderColor);
  }, [setRectStyle]);
  React.useEffect(function () {
    var _table$data, _table$data$colsWidth;

    var colsCount = (_table$data = table.data) == null ? void 0 : (_table$data$colsWidth = _table$data.colsWidth) == null ? void 0 : _table$data$colsWidth.length;
    if (!colsCount) return;

    if (isHoverCornerToolbar) {
      setItemsRectStyleByRange(0, colsCount - 1, THEME.blue1, THEME.blue3);
    } else {
      if (!selection || !table.data.colsWidth) {
        setItemsRectStyleByRange(0, colsCount - 1, THEME.toolbarBgColor["default"], THEME.toolbarBorderColor);
        return;
      }

      updateColSelectionRectStyle();
    }
  }, [setItemsRectStyleByRange, updateColSelectionRectStyle, selection, (_table$data2 = table.data) == null ? void 0 : (_table$data2$colsWidt = _table$data2.colsWidth) == null ? void 0 : _table$data2$colsWidt.length, isHoverCornerToolbar, table, controller]);
  var updateIndicatorStyle = React.useCallback(function () {
    if (!colIndicatorRef.current || !selection || positionOfInsertButton === -1 || !tableRef.current || !positionedAncestorRef.current || !toolbarWrapperRef.current) {
      return;
    }

    var trueTableDOM = tableRef.current;
    var trueTableRect = getBoundingRelativeRect(trueTableDOM, positionedAncestorRef.current);
    var toolbarRect = getBoundingRelativeRect(toolbarWrapperRef.current, positionedAncestorRef.current);
    var left = positionOfInsertButton === 0 ? 0 : calcColsWidth(0, positionOfInsertButton - 1);
    var height = trueTableRect.bottom - toolbarRect.top;
    colIndicatorRef.current.style.left = Math.round(left / scale) + "px";
    colIndicatorRef.current.style.bottom = Math.round(SCROLL_BAR_HEIGHT / scale) + "px";
    colIndicatorRef.current.style.height = height / scale + "px";
  }, [colIndicatorRef, selection, positionOfInsertButton, tableRef, positionedAncestorRef, calcColsWidth, scale]);
  var handleColResizing = React.useCallback(function (event) {
    if (!draggingColResizerRef.current) return;
    event.preventDefault();
    var relativeEvent = getRelativeMouseEvent(event, zoomContainer);
    var colToolbarItem = draggingColResizerRef.current.previousElementSibling;
    var colToolbarNextItem = draggingColResizerRef.current.nextElementSibling;
    if (!colToolbarItem || !colToolbarNextItem) return;
    var colToolbarItemRect = getBoundingRelativeRect(colToolbarItem, zoomContainer);
    var validClientX = Math.max(colToolbarItemRect.left + MIN_COL_WIDTH * scale, relativeEvent.relativeX);

    if (colToolbarNextItem && colToolbarNextItem.getAttribute('data-index') !== null) {
      var colToolbarNextItemRect = getBoundingRelativeRect(colToolbarNextItem, zoomContainer);
      validClientX = Math.min(colToolbarNextItemRect.left + colToolbarNextItemRect.width - MIN_COL_WIDTH * scale, validClientX);
    }

    var startClientX = startClientXRef.current;

    if (startClientX == null) {
      return;
    }

    var delta = validClientX - startClientX;
    var left = startPositionLeftRef.current + Math.round(delta / scale);
    setResizingColData(_extends({}, resizingColDataRef.current, {
      left: left
    }));
  }, [zoomContainer, scale]);
  var hideContextMenu = React.useCallback(function () {
    setContextMenuVisible(false);
    document.removeEventListener('mousedown', hideContextMenu);
  }, []);
  var handleColResizeEnd = React.useCallback(function () {
    // Fix to https://work.aone.alibaba-inc.com/issue/38856463. draggingColResizerRef.current会存在为null的情况
    // 暂时不好定位具体原因，先做兜底处理
    if (!draggingColResizerRef.current) {
      document.removeEventListener('mousedown', hideContextMenu);
      document.removeEventListener('mousemove', handleColResizing);
      document.removeEventListener('mouseup', handleColResizeEnd);
      return;
    }

    var delta = parseInt(draggingColResizerRef.current.style.left, 10) - startPositionLeftRef.current;
    var resizingColIndex = parseInt(draggingColResizerRef.current.getAttribute('data-index'), 10);
    onColResize(resizingColIndex, delta);
    draggingColResizerRef.current.style.backgroundColor = '';
    draggingColResizerRef.current = null;
    startClientXRef.current = null;
    startPositionLeftRef.current = 0;
    document.body.style.cursor = originBodyCursorRef.current;
    originBodyCursorRef.current = '';
    setResizingColData(_extends({}, resizingColData, {
      colIndex: -1
    }));
    document.removeEventListener('mousedown', hideContextMenu);
    document.removeEventListener('mousemove', handleColResizing);
    document.removeEventListener('mouseup', handleColResizeEnd);
  }, [onColResize, resizingColData, hideContextMenu, handleColResizing]);
  var handleColResizeStart = React.useCallback(function (event) {
    // NOTE: 不阻止冒泡，以便触发上层清空表格选区逻辑
    event.preventDefault();
    var relativeEvent = getRelativeMouseEvent(event, zoomContainer);
    startClientXRef.current = relativeEvent.relativeX;
    draggingColResizerRef.current = event.target;
    var resizingColIndex = parseInt(draggingColResizerRef.current.getAttribute('data-index'), 10);
    var left = parseInt(draggingColResizerRef.current.style.left, 10);
    draggingColResizerRef.current.style.backgroundColor = 'transparent';
    originBodyCursorRef.current = document.body.style.cursor;
    document.body.style.setProperty('cursor', 'col-resize', 'important');
    var table = ReactDOM.findDOMNode(tableRef.current);
    var tableRect = getBoundingRelativeRect(table, zoomContainer);
    var top = REALTABLE_PADDING.top / scale;
    startPositionLeftRef.current = left;
    resizingColDataRef.current = {
      colIndex: resizingColIndex,
      left: left,
      top: top,
      colResizerHeight: (tableRect.height + TOOLBAR_ITEM_SIZE - REALTABLE_PADDING.top) / scale
    };
    setResizingColData({
      colIndex: resizingColIndex,
      left: left,
      top: top,
      colResizerHeight: (tableRect.height + TOOLBAR_ITEM_SIZE - REALTABLE_PADDING.top) / scale
    });
    document.addEventListener('mousemove', handleColResizing);
    document.addEventListener('mouseup', handleColResizeEnd);
  }, [handleColResizing, handleColResizeEnd, scale, tableRef, zoomContainer]);
  var handlePreventDefault = React.useCallback(function (event) {
    event.preventDefault();
    event.stopPropagation();
  }, []);
  var handleContextMenu = React.useCallback(function (event) {
    handlePreventDefault(event);
    onContextMenu(event);
    setContextMenuVisible(true);
  }, [onContextMenu, handlePreventDefault]);
  var isResizingCol = React.useCallback(function () {
    return resizingColData && resizingColData.colIndex !== -1;
  }, [resizingColData]);
  var handleMouseEnterColToolbarItem = React.useCallback(function (event) {
    var index = parseInt(event.target.getAttribute('data-index'), 10);
    if (isNaN(index)) return; // hover对样式的影响优先级低于选中状态

    var tableRows = table.nodes.length;

    if (tableRows) {
      // 构造hover选区
      var _hoverSelection = {
        key: table.key,
        startColIndex: index,
        endColIndex: index,
        startRowIndex: 0,
        endRowIndex: tableRows - 1
      };
      setHoverSelection(_hoverSelection);
    }
  }, [setHoverSelection, table.key, table.nodes.length]);
  var handleMouseOutColToolbarItem = React.useCallback(function () {
    setHoverSelection(null);
  }, [setHoverSelection]);
  var handleMouseOver = React.useCallback(function (e) {
    if (isDragging || isResizingCol() || !scrollContainer.current) {
      return;
    }

    var clientX = e.clientX;
    var scrollRect = scrollContainer.current.getBoundingClientRect();
    var horizontalPadding = 10;

    if (clientX < scrollRect.left - horizontalPadding || clientX > scrollRect.right + horizontalPadding) {
      return;
    }

    var colsRect = getColsRects();
    var index = colsRect.findIndex(function (rect) {
      // node.getBoundingClientRect() 可能是 undefined？
      // 这里比较奇怪，就算 node 从 DOM 中卸载，也会返回 DOMRect 只是数据都是 0
      // 先兼容
      if (!rect) {
        return false;
      }

      return clientX >= rect.left && clientX <= rect.right;
    });
    setHoverToolbarItemIndex(index);
  }, [isDragging, isResizingCol, scrollContainer, getColsRects]);
  var handleMouseOut = React.useCallback(function (e) {
    var insertButton = insertButtonRef.current;

    if (insertButton && insertButton.contains(e.target)) {
      return;
    }

    if (isDragging || isResizingCol()) {
      return;
    }

    setHoverToolbarItemIndex(-1);
  }, [isDragging, isResizingCol]);
  var selectCols = React.useCallback(function (start, end, shouldHideContextMenu) {
    if (shouldHideContextMenu === void 0) {
      shouldHideContextMenu = true;
    }

    if (start === end) {
      startSelectIndexRef.current = start;
    }

    onSelect({
      start: start,
      end: end
    }, shouldHideContextMenu);
  }, [onSelect]);
  var shouldEnableEndDrag = React.useCallback(function (insertIndex, colsLength) {
    if (insertIndex === 0 && isColumnHeader) {
      return false;
    }

    if (insertIndex > 0 && insertIndex < colsLength) {
      var maxRowIndex = table.nodes.length - 1;
      var leftColSelection = {
        startRowIndex: 0,
        endRowIndex: maxRowIndex,
        startColIndex: 0,
        endColIndex: insertIndex - 1,
        key: table.key
      };
      return controller.query('isAllSelectedCellsComplete', {
        node: table,
        tableSelection: leftColSelection
      });
    }

    return true;
  }, [table, controller, isColumnHeader]);
  var handleMultiSelectCol = React.useCallback(throttle(function (event) {
    if (isDragging) {
      return;
    }

    var buttons = event.buttons;
    var selectedIndexRange = getSelectedIndexRange();

    if (buttons !== 1 || !colToolbarRef.current || !selectedIndexRange) {
      removeMultiSelectListener();
      return;
    }

    var colsNodes = getAllColsNodes();

    var _ref2 = colToolbarRef.current.getBoundingClientRect(),
        colToolbarX = _ref2.left;

    var offsetX = event.clientX - colToolbarX;
    var endSelectedIndex = colsNodes.length - 1;
    var acc = 0;

    for (var i = 0; i < colsNodes.length; i += 1) {
      acc += colsNodes[i].getBoundingClientRect().width;

      if (acc > offsetX) {
        endSelectedIndex = i;
        break;
      }
    }

    selectCols(startSelectIndexRef.current, endSelectedIndex);
  }, 100), [isDragging, getSelectedIndexRange, selectCols]);
  var removeMultiSelectListener = React.useCallback(function () {
    document.removeEventListener('mousemove', handleMultiSelectCol);
    document.removeEventListener('mouseup', removeMultiSelectListener);
  }, [handleMultiSelectCol]);
  var showIndicatorVisible = React.useCallback(function (isVisible) {
    if (!colIndicatorRef.current) {
      return;
    }

    var opacity = isVisible ? '1' : '0';
    colIndicatorRef.current.style.opacity = opacity;
  }, [colIndicatorRef]);
  var setInsertButtonPos = React.useCallback(function (index) {
    var i = index;

    if (i === 0 && isColumnHeader) {
      i = -1;
    }

    setPositionOfInsertButton(i);
    showIndicatorVisible(i !== -1);
    insetBtnPosRef.current = i;
  }, [isColumnHeader, showIndicatorVisible]);
  var addMultiSelectListener = React.useCallback(function () {
    document.addEventListener('mousemove', handleMultiSelectCol);
    document.addEventListener('mouseup', removeMultiSelectListener);
  }, [handleMultiSelectCol, removeMultiSelectListener]);
  var moveColToIndex = React.useCallback(function (originIndexRange, targetIndex) {
    var _ref3 = getSortedSelectedRange(originIndexRange),
        min = _ref3.min,
        max = _ref3.max;

    controller.run('onAction', moveTableCols(table, {
      start: min,
      end: max
    }, targetIndex));
    var startIndex = min < targetIndex ? targetIndex - (max - min + 1) : targetIndex;
    selectCols(startIndex, startIndex + max - min);
  }, [getSortedSelectedRange, controller, selectCols, table]);
  var updateDragElementPosition = React.useCallback(function (x, y) {
    if (!dragElementRef.current) {
      return;
    }

    dragElementRef.current.style.left = x / scale + "px";
    dragElementRef.current.style.top = y / scale + "px";
  }, [scale]);
  var isShowColToolbar = React.useCallback(function () {
    var selectedIndexRange = getSelectedIndexRange();
    return !!selectedIndexRange;
  }, [getSelectedIndexRange]);
  var updateDraggingStyle = React.useCallback(function (relativeEvent) {
    var clientX = relativeEvent.clientX,
        clientY = relativeEvent.clientY,
        relativeX = relativeEvent.relativeX,
        relativeY = relativeEvent.relativeY;
    var tableDOM = domUtils.findDOMNode(table.key);

    if (!tableDOM) {
      return;
    }

    updateDragElementPosition(relativeX, relativeY);
    var tableRect = tableDOM.getBoundingClientRect();

    if (clientX < tableRect.left - TOOLBAR_ITEM_SIZE || clientX > tableRect.right || clientY < tableRect.top - TOOLBAR_ITEM_SIZE || clientY > tableRect.bottom) {
      setInsertButtonPos(-1);
      return;
    }

    var colsRects = getColsRects();
    var insertIndex = -1;

    for (var i = 0; i < colsRects.length; i++) {
      var colRect = colsRects[i];

      if (clientX >= colRect.left && clientX <= colRect.left + colRect.width / 2) {
        insertIndex = i;
        break;
      }

      if (clientX > colRect.left + colRect.width / 2 && clientX < colRect.right) {
        insertIndex = i + 1;
        break;
      }
    }

    var sortRange = getSortedSelectedRange();

    if (!sortRange || insertIndex >= sortRange.min && insertIndex <= sortRange.max + 1) {
      insertIndex = -1;
    }

    var shouldDragEnd = shouldEnableEndDrag(insertIndex, colsRects.length);

    if (!shouldDragEnd) {
      insertIndex = -1;
    }

    setInsertButtonPos(insertIndex);
  }, [table.key, updateDragElementPosition, getColsRects, getSortedSelectedRange, setInsertButtonPos, shouldEnableEndDrag]);
  var handleDragEnd = React.useCallback(function () {
    setIsDragging(false);
    document.removeEventListener('mouseup', handleDragEnd);

    if (insetBtnPosRef.current === -1) {
      return;
    }

    var selectedIndexRange = getSelectedIndexRange();
    moveColToIndex(selectedIndexRange, insetBtnPosRef.current);
    setInsertButtonPos(-1);
  }, [getSelectedIndexRange, moveColToIndex, setInsertButtonPos]);
  var handleDragging = React.useCallback(function (event) {
    var tableDOM = domUtils.findDOMNodeSafely(table.key);

    if (!tableDOM || event.buttons !== 1) {
      handleDragEnd();
      document.removeEventListener('mousemove', handleDragging);
      return;
    }

    event.stopPropagation();
    var relativeEvent = getRelativeMouseEvent(event, zoomContainer);
    updateDraggingStyle(relativeEvent);
    scrollHorizontal(event.clientX, scrollContainer.current);
  }, [table.key, zoomContainer, updateDraggingStyle, handleDragEnd, scrollContainer]);
  var handleDragStart = React.useCallback(function (relativeEvent) {
    var selectedIndexRange = getSelectedIndexRange();
    var selectedIndex = selectedIndexRange.start;
    setIsDragging(true);
    setDraggingColWidth(colsWidth[selectedIndex]);
    updateDraggingStyle(relativeEvent);
    document.addEventListener('mousemove', handleDragging);
    document.addEventListener('mouseup', handleDragEnd);
  }, [colsWidth, setIsDragging, setDraggingColWidth, updateDraggingStyle, handleDragging, getSelectedIndexRange, handleDragEnd]);
  var enableDragIcon = React.useCallback(function () {
    var range = getSortedSelectedRange(); // 表头列禁止拖拽

    if (isColumnHeader && (range == null ? void 0 : range.min) === 0) return false;
    return Boolean(range && hoverToolbarItemIndex >= range.min && hoverToolbarItemIndex <= range.max);
  }, [getSortedSelectedRange, hoverToolbarItemIndex, isColumnHeader]);
  var handleSelectCol = React.useCallback(function (event) {
    handlePreventDefault(event);
    var selectedIndexRange = getSelectedIndexRange();
    controller.run('onAction', clickTableToolbar(table, 'col', event.target));
    var index = parseInt(event.target.getAttribute('data-index'), 10);

    if (event.shiftKey && selectedIndexRange && startSelectIndexRef.current !== index) {
      selectCols(startSelectIndexRef.current, index);
      return;
    }

    var sortRange = getSortedSelectedRange();

    if (!sortRange || index > sortRange.max || index < sortRange.min) {
      selectCols(index, index);
      addMultiSelectListener();
      return;
    }

    var relativeEvent = getRelativeMouseEvent(event, zoomContainer);
    var timer;
    var isRightClick = event.buttons === 2;

    var clearTimer = function clearTimer() {
      clearTimeout(timer);
      selectCols(index, index, !isRightClick);
      removeCancelDragEventListener();
    };

    var removeCancelDragEventListener = function removeCancelDragEventListener() {
      document.removeEventListener('mousemove', clearTimer);
      document.removeEventListener('mouseup', clearTimer);
    };

    timer = window.setTimeout(function () {
      removeMultiSelectListener();
      removeCancelDragEventListener();
      handleDragStart(relativeEvent);
    }, DRAG_TRIGGER_TIME);

    if (!enableDragIcon()) {
      clearTimer();
    }

    addMultiSelectListener();
    document.addEventListener('mousemove', clearTimer);
    document.addEventListener('mouseup', clearTimer);
  }, [handlePreventDefault, getSelectedIndexRange, controller, table, getSortedSelectedRange, enableDragIcon, zoomContainer, addMultiSelectListener, selectCols, removeMultiSelectListener, handleDragStart]);
  var removeDragEventListener = React.useCallback(function () {
    document.removeEventListener('mousemove', handleDragging);
    document.removeEventListener('mouseup', handleDragEnd);
  }, [handleDragging, handleDragEnd]);
  var handleColRectUpdate = React.useCallback(function (index, colNode, isDelete) {
    if (isDelete === void 0) {
      isDelete = false;
    }

    if (isDelete) {
      colsNodes.current = colsNodes.current.splice(index, 1);
    } else {
      colsNodes.current[index] = colNode;
    }

    onGetAllColsNodes(getAllColsNodes());
  }, [onGetAllColsNodes, getAllColsNodes]);
  var insertCol = React.useCallback(function () {
    var colsWidth = table.data.colsWidth;

    if (!Array.isArray(colsWidth)) {
      return;
    }

    if (positionOfInsertButton === -1) {
      return;
    }

    var colWidth = colsWidth[Math.min(positionOfInsertButton, colsWidth.length - 1)];
    controller.run('onAction', insertTableCol(table, positionOfInsertButton, Math.max(0, positionOfInsertButton - 1), colWidth));

    if (positionOfInsertButton === colsWidth.length) {
      setInsertButtonPos(positionOfInsertButton + 1);
    }
  }, [table, positionOfInsertButton, controller, setInsertButtonPos]);
  var deleteCol = React.useCallback(function () {
    controller.run('onAction', deleteTableCols(table));
  }, [controller, table]);
  var highlightSelection = React.useCallback(function () {
    setIsHighlightSelection(true);
    setIsHoverDelete(true);
  }, [setIsHighlightSelection, setIsHoverDelete]);
  var cancelHighlightSelection = React.useCallback(function () {
    setIsHighlightSelection(false);
    setIsHoverDelete(false);
  }, [setIsHighlightSelection, setIsHoverDelete]);
  var renderColToolbarItems = React.useMemo(function () {
    if (!Array.isArray(colsWidth)) {
      return null;
    }

    var left = 0;
    var children = [];
    var isSelectWholeTable = controller.query('isSelectWholeTable', {
      node: table
    });
    var indexRange = getSelectedIndexRange();
    var deleteRange = isHoverDelete ? indexRange : null;
    var selectRanges = indexRange ? [indexRange] : [];

    if (isHoverCornerToolbar || isSelectWholeTable) {
      selectRanges.push({
        start: 0,
        end: colsWidth.length - 1
      });
    } else if (hoverSelection && hoverSelection.startColIndex === hoverSelection.endColIndex) {
      selectRanges.push({
        start: hoverSelection.startColIndex,
        end: hoverSelection.endColIndex
      });
    }

    var activeRange = selection ? {
      start: selection.startColIndex,
      end: selection.endColIndex
    } : null;
    colsWidth.forEach(function (width, index) {
      var resizerLeft = resizingColData.colIndex === -1 ? left + width : resizingColData.left;
      var translateY = (INDICATOR_WRAPPER_WIDTH - GAP_BEWTEEN_INDICATOR_TOOLBAR) / scale; // 第一个indicator如果不往右偏一点会被表格wrapper截断，因为超出了表格左侧区域

      var translateX = index === 0 ? '45%' : '55%';
      var isLastItem = index === colsWidth.length - 1;
      children.push( /*#__PURE__*/_createElement(React.Fragment, {
        key: index
      }, /*#__PURE__*/_createElement(TableColToolbarItem, {
        activeRange: activeRange,
        selectRanges: selectRanges,
        deleteRange: deleteRange,
        index: index,
        scale: scale,
        onContextMenu: handleContextMenu,
        onMouseDown: handleSelectCol,
        onMouseEnter: handleMouseEnterColToolbarItem,
        onMouseOut: handleMouseOutColToolbarItem,
        onRectUpdate: handleColRectUpdate
      }, index === 0 && isColumnHeader ? null : /*#__PURE__*/_createElement(InsertButtonIndicator, {
        scale: scale,
        onClick: insertCol,
        style: {
          alignItems: 'start',
          transform: "translate(-" + translateX + ", -" + translateY + "px)"
        }
      }), isLastItem ? /*#__PURE__*/_createElement(InsertButtonIndicator, {
        scale: scale,
        onClick: insertCol,
        style: {
          alignItems: 'start',
          left: width + "px",
          transform: "translate(-100%, -" + translateY + "px)",
          // 最后一个indicator不能超出表格区域，否则自适应的时候会产生滚动条
          justifyContent: 'flex-end'
        }
      }) : null), /*#__PURE__*/_createElement(ColToolbarResizer, {
        "data-index": index,
        "data-type": "col-resizer",
        scale: scale,
        style: {
          left: resizerLeft,
          width: index === colsWidth.length - 1 ? '3px' : ''
        },
        onMouseDown: handleColResizeStart
      })));
      left += width;
    });
    return children;
  }, [colsWidth, controller, table, getSelectedIndexRange, isHoverDelete, isHoverCornerToolbar, hoverSelection, selection, resizingColData.colIndex, resizingColData.left, scale, handleContextMenu, handleSelectCol, handleMouseEnterColToolbarItem, handleMouseOutColToolbarItem, handleColRectUpdate, isColumnHeader, insertCol, handleColResizeStart]);
  var isShowButton = React.useCallback(function () {
    return !contextMenuVisible && zoomContainer && getLastActiveTableKey() === table.key && selection;
  }, [contextMenuVisible, zoomContainer, getLastActiveTableKey, table.key, selection]); // 展示插入按钮时隐藏删除按钮

  var isShowDelete = React.useCallback(function () {
    return isShowButton() && isSelectWholeCol() && isShowColToolbar() && positionOfInsertButton === -1 && !isDragging && !isHideDeleteButton;
  }, [isShowButton, isSelectWholeCol, isShowColToolbar, positionOfInsertButton, isDragging, isHideDeleteButton]);
  var handleMouseMove = React.useCallback(throttle(function (event) {
    if (isDragging || isResizingCol() || !scrollContainer.current) {
      return;
    }

    if (!isTableSelected) {
      setInsertButtonPos(-1);
      return;
    }

    var colsRects = getColsRects();

    if (colsRects.length === 0) {
      return;
    }

    var clientX = event.clientX,
        clientY = event.clientY; // 鼠标位置在插入按钮区域时，不隐藏插入按钮

    if (positionOfInsertButton !== -1 && insertButtonRef.current) {
      var insertButtonNode = ReactDOM.findDOMNode(insertButtonRef.current);

      var _insertButtonNode$get = insertButtonNode.getBoundingClientRect(),
          left = _insertButtonNode$get.left,
          top = _insertButtonNode$get.top,
          right = _insertButtonNode$get.right,
          bottom = _insertButtonNode$get.bottom;

      if (clientX >= left && clientX <= right && clientY >= top && clientY <= bottom) {
        return;
      }
    }

    var scrollRect = scrollContainer.current.getBoundingClientRect();

    if (clientX < scrollRect.left || clientX > scrollRect.right) {
      setInsertButtonPos(-1);
      return;
    }

    var insertIndex = -1;

    for (var i = 0; i < colsRects.length; i++) {
      var colRect = colsRects[i]; // 理论上 colRect 非空，监控有报错显示 undefined，此处兼容

      if (!colRect) break;

      if (clientY < colRect.top && clientY >= colRect.top - INDICATOR_WRAPPER_WIDTH) {
        if (clientX >= colRect.left - INDICATOR_WRAPPER_WIDTH / 2 && clientX <= colRect.left + INDICATOR_WRAPPER_WIDTH / 2) {
          insertIndex = i;
          break;
        } else if (clientX >= colRect.left + colRect.width - INDICATOR_WRAPPER_WIDTH / 2 && clientX <= colRect.left + colRect.width + INDICATOR_WRAPPER_WIDTH / 2) {
          insertIndex = i + 1;
          break;
        }
      }
    }

    var sortedRange = getSortedSelectedRange(); // 加号在所选行中间时，隐藏

    if (sortedRange && insertIndex > sortedRange.min && insertIndex < sortedRange.max + 1) {
      insertIndex = -1;
    }

    setInsertButtonPos(insertIndex);
  }, 200, {
    leading: true
  }), [scrollContainer, isTableSelected, positionOfInsertButton, isDragging, isResizingCol, getColsRects, getSortedSelectedRange]);
  var updateDeleteButtonStyle = React.useCallback(function () {
    if (!deleteButtonRef.current || !selection || !isShowDelete()) {
      return;
    }

    var menuNode = ReactDOM.findDOMNode(deleteButtonRef.current);
    var menuRect = getBoundingRelativeRect(menuNode, zoomContainer);
    var result = getColToolbarTop();

    if (!result) {
      return;
    }

    var top = result.top;
    var startColRect = getColItemRect(selection.startColIndex);
    var endColRect = getColItemRect(selection.endColIndex);

    if (!startColRect || !endColRect) {
      return;
    }

    var mid = (endColRect.right - startColRect.left) / 2;
    var containerLeft = startColRect.left;
    var relativeLeft = containerLeft + mid - menuRect.width / 2;
    menuNode.style.top = top / scale - menuNode.offsetHeight - DISTANCE_BETWEEN_DELETE_BUTTON_AND_TOOLBAR + "px";
    deleteButtonLeftRef.current = relativeLeft / scale;
    menuNode.style.left = deleteButtonLeftRef.current - 1 + "px";
    var shouldHide = shouldHideButton(relativeLeft);

    if (shouldHide) {
      menuNode.style.opacity = '0';
    } else {
      menuNode.style.opacity = '1';
    }
  }, [selection, zoomContainer, scale, getColToolbarTop, shouldHideButton, getColItemRect, isShowDelete]);
  React.useLayoutEffect(function () {
    // 把样式改变放在layoutEffect中执行，防止闪烁
    if (isTableSelected) {
      fastdom.measure(function () {
        updateDeleteButtonStyle();
        updateInsertButtonStyle();
        updateIndicatorStyle();
        updateColSelectionRectStyle();
      });
    }
  }, [updateDeleteButtonStyle, updateInsertButtonStyle, updateIndicatorStyle, updateColSelectionRectStyle, isTableSelected]);
  React.useEffect(function () {
    return function () {
      document.removeEventListener('mousemove', handleColResizing);
      document.removeEventListener('mouseup', handleColResizeEnd);
      document.removeEventListener('mousemove', handleMouseMove);
      removeMultiSelectListener();
      removeDragEventListener();
    };
  }, []);
  React.useEffect(function () {
    if (!isTableSelected || !Array.isArray(colsWidth)) {
      return undefined;
    }

    document.addEventListener('mousemove', handleMouseMove);

    if (contextMenuVisible) {
      document.addEventListener('mousedown', hideContextMenu);
      return function () {
        document.removeEventListener('mousedown', hideContextMenu);
        document.removeEventListener('mousemove', handleMouseMove);
      };
    }

    return function () {
      document.removeEventListener('mousemove', handleMouseMove);
    };
  }, [isTableSelected, colsWidth, handleMouseMove, contextMenuVisible, hideContextMenu]);
  var width = (colsWidth || []).reduce(function (acc, w) {
    return acc + w;
  }, 0);
  var style = {
    width: width + 1,
    // 保持和整体表格宽度一致
    height: Math.round(TOOLBAR_ITEM_SIZE / scale) + "px",
    borderRadius: Math.round(3 / scale) + "px"
  };

  var _useScrollableContain = useScrollableContainerRect(),
      scrollRect = _useScrollableContain[0];

  var containerWidth = useTableScrollContainerWidth();
  var tableScrollLeft = useTableScrollContainerScrollLeft();
  React.useLayoutEffect(function () {
    if (!toolbarWrapperRef.current || !isSticky) return;
    toolbarWrapperRef.current.scrollLeft = tableScrollLeft;
  }, [isSticky, tableScrollLeft]); // 在定义的函数内使用 positionOfInsertButton 需要通过ref来保证拿到的是最新值，在外部则通过 positionOfInsertButton 来获取最新值即可

  var isShowInsertButton = !isDragging && positionOfInsertButton !== -1;
  var tableHeight = isDragging && tableRef.current ? tableRef.current.offsetHeight : 0;
  var showInsert = !!isShowButton() && isShowInsertButton;
  var wrapperStyle = {};

  if (isTableSelected) {
    wrapperStyle.visibility = 'visible';
    wrapperStyle.pointerEvents = 'auto';
  }

  if (isSticky) {
    wrapperStyle.width = containerWidth;
    wrapperStyle.background = 'white';

    if (Number.isFinite(scrollRect.top)) {
      wrapperStyle.top = scrollRect.top;
    }

    if (Number.isFinite(scrollRect.left)) {
      wrapperStyle.left = scrollRect.left;
    }
  }

  return /*#__PURE__*/_createElement(Wrapper, {
    style: wrapperStyle,
    "data-sticky": isSticky,
    ref: toolbarWrapperRef,
    "data-testid": "table-col-toolbar-wrapper"
  }, /*#__PURE__*/_createElement(ColToolbarWrapper, {
    role: "toolbar",
    ref: colToolbarRef,
    style: style,
    "data-testid": "table-col-toolbar",
    onMouseOver: handleMouseOver,
    onMouseOut: handleMouseOut
  }, renderColToolbarItems, /*#__PURE__*/_createElement(ColResizer, {
    style: {
      display: resizingColData.colIndex === -1 ? 'none' : 'block',
      left: resizingColData.left,
      top: resizingColData.top,
      height: resizingColData.colResizerHeight
    }
  }), /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/_createElement(ColInlineToolbar, {
    style: {
      visibility: isShowDelete() ? 'visible' : 'hidden',
      transition: 'left ease-in-out 0.1s'
    },
    ref: deleteButtonRef,
    "data-testid": "table-col-inline-toolbar"
  }, /*#__PURE__*/_createElement(InlineToolbarDeleteButton, {
    mode: "col",
    locale: locale,
    scale: scale,
    onDelete: deleteCol,
    onHighlightSelection: highlightSelection,
    onCancelHighlightSelection: cancelHighlightSelection
  })), zoomContainer), /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/_createElement(ColInlineToolbar, {
    style: {
      opacity: showInsert ? 1 : 0,
      pointerEvents: showInsert ? 'auto' : 'none'
    },
    ref: insertButtonRef,
    "data-testid": "table-col-inline-toolbar-insert"
  }, /*#__PURE__*/_createElement(InlineToolbarInsertButton, {
    locale: locale,
    table: table,
    selection: selection,
    mode: "col",
    tableRef: tableRef,
    scale: scale,
    onInsert: insertCol,
    zoomContainer: zoomContainer,
    insertIndex: positionOfInsertButton,
    getAllColsNodes: getAllColsNodes,
    onShowIndicatorVisible: showIndicatorVisible
  })), zoomContainer), zoomContainer && /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/_createElement(DragElement, {
    ref: dragElementRef,
    visible: isDragging,
    width: draggingColWidth,
    height: tableHeight + TOOLBAR_ITEM_SIZE
  }), zoomContainer)));
}

export default createToolbarWithTableSeletion(TableColToolbar);
//# sourceMappingURL=index.js.map