import _extends from "@babel/runtime/helpers/extends";
import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";

/* eslint-disable max-lines */

/* eslint-disable react/no-find-dom-node */
import * as React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import * as ReactDOM from 'react-dom';
import { throttle } from 'lodash-es';
import fastdom from 'fastdom';
import { useZoom, useZoomContainer, useScrollableContainer } from '@ali/4ever-cangjie';
import { actions } from '@ali/4ever-plugin-pc-contex-menu';
import { getClosestContainerBlock, getInnerWidth, getBoundingRelativeRect, getRelativeMouseEvent } from '@ali/4ever-utils';
import { resizeTableWidth, resizeTableWidthFitContainer, resizeTableHeight, resizeTableColWidth, setTableRowHeight, deleteTable, selectTableCols, selectTableRows, selectTable, scrollTable, adjustColsWidth } from "../actions";
import getPositionOfCell from "../utils/getPositionOfCell";
import { MIN_COL_WIDTH, MIN_ROW_HEIGHT, DETECT_DELTA, TOOLBAR_ITEM_SIZE } from "../constants";
import createTableSelectionForFocusedCell from "../utils/createTableSelectionForFocusedCell";
import TableCornerToolbar from "./cornerToolbar";
import TableColToolbar from "./colToolbar";
import TableRowToolbar from "./rowToolbar";
import TableResizeController from "./tableResizeController";
import { ColResizer, RowResizer, ColIndicator, RowIndicator, Wrapper, TableLeftSideShadow, TableRightSideShadow } from "./styled";
import { logNPEInfo } from "../utils/logger";
import TableWithSelection from "./tableWithSelection";
import CornerButton from "./cornerButton";
import { useSelectionStatus } from "../../utils/hooks/useSelectionStatus";
import { REALTABLE_PADDING } from "../../utils/constants";
import TableScrollContainer from "../../components/tableScrollContainer";
import { TableIsSelectedContext } from "../../utils/hooks/useTableIsSelected";
import utils from "../../utils/utils";
import { PixelColsWidthContext } from "../../utils/hooks/usePixelColsWidth";
import TableContextContainer from "../../components/tableContextContainer";
import { ContextContainer } from "./contextContainer";
var getTableIsSelected = utils.getTableIsSelected,
    visibleUtil = utils.visibleUtil;

function getColIndex(cell, border, table) {
  var cellKey = cell.getAttribute('data-cangjie-key');
  var position = getPositionOfCell(cellKey, table);
  var colIndex = position && position.colIndex;

  if (!(typeof colIndex === 'number' && colIndex >= 0)) {
    return null;
  }

  return border === 'left' ? colIndex - 1 : colIndex + (parseInt(cell.getAttribute('colspan'), 10) || 1) - 1;
}

function getRowKey(cell, border) {
  var row = cell.parentElement;

  if (!row) {
    return null;
  }

  var rowElements = Array.from(row.parentElement.children);
  var rowIndex = rowElements.indexOf(row);
  var adjustedRowIndex = border === 'top' ? rowIndex - 1 : rowIndex;
  var adjustedRow = rowElements[adjustedRowIndex];

  if (adjustedRow) {
    return adjustedRow.getAttribute('data-cangjie-key');
  }

  return null;
}

function getPrevVisibleCell(cell) {
  var prevVisibleCell = cell.previousElementSibling;

  while (prevVisibleCell && prevVisibleCell.style.display === 'none') {
    prevVisibleCell = prevVisibleCell.previousElementSibling;
  }

  return prevVisibleCell;
}

function getNextVisibleCell(cell) {
  var nextVisibleCell = cell.nextElementSibling;

  while (nextVisibleCell && nextVisibleCell.style.display === 'none') {
    nextVisibleCell = nextVisibleCell.nextElementSibling;
  }

  return nextVisibleCell;
}

var lastActiveTableKey = null;
var closeContextMenu = actions.closeContextMenu;

function getLastActiveTableKey() {
  return lastActiveTableKey;
}

var Table = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Table, _React$Component);

  function Table(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.colResizeable = false;
    _this.rowResizeable = false;
    _this.resizingColIndex = null;
    _this.resizingRowKey = null;
    _this.resizingColCell = null;
    _this.resizingColNextCell = null;
    _this.resizingRow = null;
    _this.startTableX = null;
    _this.startTableY = null;
    _this.wrapperRef = /*#__PURE__*/React.createRef();
    _this.realTableWrapperRef = /*#__PURE__*/React.createRef();
    _this.tableRef = /*#__PURE__*/React.createRef();
    _this.colResizerRef = /*#__PURE__*/React.createRef();
    _this.rowResizerRef = /*#__PURE__*/React.createRef();
    _this.colIndicatorRef = /*#__PURE__*/React.createRef();
    _this.rowIndicatorRef = /*#__PURE__*/React.createRef();
    _this.tableResizeControllerRef = /*#__PURE__*/React.createRef();
    _this.tableResizeControlLinesRef = /*#__PURE__*/React.createRef();
    _this.tableLeftShadowRef = /*#__PURE__*/React.createRef();
    _this.tableRightShadowRef = /*#__PURE__*/React.createRef();
    _this.lastEndCellKey = null;
    _this.tableSelection = null;
    _this.colsNodes = [];
    _this.updateShadowRafId = null;
    _this.tableCursorStyle = null;
    _this.isResizingTable = false;

    _this.closeContextMenu = function () {
      var controller = _this.props.controller;
      controller.run('onAction', closeContextMenu());
    };

    _this.getContainerWidth = function () {
      var _this$props = _this.props,
          controller = _this$props.controller,
          node = _this$props.node;
      var value = controller.value;
      var containerBlock = getClosestContainerBlock(value, node);
      var containerWidth = getInnerWidth(containerBlock);
      return containerWidth;
    };

    _this.handleMouseEnter = function () {
      if (!_this.realTableWrapperRef.current) return;
      _this.tableCursorStyle = _this.realTableWrapperRef.current.style.cursor;
    };

    _this.handleMouseMove = function (event) {
      var zoomContainer = _this.props.zoomContainer;
      var relativeEvent = getRelativeMouseEvent(event, zoomContainer);

      if (_this.startTableX || // 正在调整列宽
      _this.startTableY || _this.isInNestedTable(event)) {
        return;
      }

      var targetCell = event.target.closest('td');
      var prevCursor = _this.tableCursorStyle;

      if (!targetCell) {
        return;
      }

      var targetCellRect = getBoundingRelativeRect(targetCell, zoomContainer);
      var deltaToLeft = relativeEvent.relativeX - targetCellRect.left;
      var deltaToRight = targetCellRect.right - relativeEvent.relativeX;
      var deltaToTop = relativeEvent.relativeY - targetCellRect.top;
      var deltaToBottom = targetCellRect.bottom - relativeEvent.relativeY; // DETECT_DELTA不加成scale比较合理

      if (deltaToLeft <= DETECT_DELTA) {
        if (!targetCell.previousElementSibling) {
          _this.colResizeable = false;
          targetCell.style.cursor = prevCursor;
        } else {
          _this.colResizeable = 'left';
          _this.rowResizeable = false;
          targetCell.style.cursor = 'col-resize';
        }
      } else if (deltaToRight <= DETECT_DELTA) {
        _this.colResizeable = 'right';
        _this.rowResizeable = false;
        targetCell.style.cursor = 'col-resize';
      } else if (deltaToTop <= 4) {
        if (!targetCell.parentElement.previousElementSibling) {
          _this.rowResizeable = false;
          targetCell.style.cursor = prevCursor;
        } else {
          _this.rowResizeable = 'top';
          _this.colResizeable = false;
          targetCell.style.cursor = 'row-resize';
        }
      } else if (deltaToBottom <= DETECT_DELTA) {
        _this.rowResizeable = 'bottom';
        _this.colResizeable = false;
        targetCell.style.cursor = 'row-resize';
      } else {
        _this.rowResizeable = false;
        _this.colResizeable = false; // 单元格的鼠标默认样式

        targetCell.style.cursor = prevCursor;
      }
    };

    _this.handleMouseDown = function (event) {
      var node = _this.props.node;
      lastActiveTableKey = node.key; // 右键 mouseDown 不处理

      if (_this.isInNestedTable(event) || event.buttons === 2) {
        return;
      }

      if (_this.colResizeable) {
        _this.handleColResizeStart(event);
      } else if (_this.rowResizeable) {
        _this.handleRowResizeStart(event);
      }
    };

    _this.handleTableResizeStart = function (event) {
      var _this$props2 = _this.props,
          scale = _this$props2.scale,
          zoomContainer = _this$props2.zoomContainer;
      event.preventDefault();
      event.stopPropagation();
      var relativeEvent = getRelativeMouseEvent(event, zoomContainer);
      var realTableWrapper = ReactDOM.findDOMNode(_this.realTableWrapperRef.current);
      var realTableWrapperRect = getBoundingRelativeRect(realTableWrapper, zoomContainer);
      _this.startTableX = Math.round((relativeEvent.relativeX - realTableWrapperRect.left) / scale);
      _this.startTableY = Math.round((relativeEvent.relativeY - realTableWrapperRect.top) / scale);

      if (_this.tableResizeControlLinesRef.current) {
        _this.tableResizeControlLinesRef.current.style.display = 'block';
      }

      _this.isResizingTable = true;
      document.addEventListener('mousemove', _this.handleTableResizing);
      document.addEventListener('mouseup', _this.handleTableResizeEnd);
    };

    _this.handleTableResizing = function (event) {
      var _this$props3 = _this.props,
          scale = _this$props3.scale,
          zoomContainer = _this$props3.zoomContainer;
      if (!zoomContainer) return;
      event.preventDefault();
      event.stopPropagation();
      var relativeEvent = getRelativeMouseEvent(event, zoomContainer);
      var realTableWrapper = _this.realTableWrapperRef.current;
      if (!realTableWrapper || !_this.tableRef.current || !_this.tableResizeControllerRef.current) return;
      var realTableWrapperRect = getBoundingRelativeRect(realTableWrapper, zoomContainer);
      var table = _this.tableRef.current;
      var tableRect = getBoundingRelativeRect(table, zoomContainer);
      var tableResizeController = _this.tableResizeControllerRef.current;
      var currentTableX = Math.max(MIN_COL_WIDTH, Math.round((relativeEvent.relativeX - realTableWrapperRect.left) / scale));
      var currentTableY = Math.max(MIN_ROW_HEIGHT, Math.round((relativeEvent.relativeY - tableRect.top) / scale));
      tableResizeController.style.left = currentTableX + "px";
      tableResizeController.style.top = currentTableY + Math.round((tableRect.top - realTableWrapperRect.top) / scale) + "px";
    };

    _this.handleTableResizeEnd = function (event) {
      _this.isResizingTable = false;
      event.preventDefault();
      event.stopPropagation();
      var _this$props4 = _this.props,
          controller = _this$props4.controller,
          node = _this$props4.node,
          zoomContainer = _this$props4.zoomContainer,
          scale = _this$props4.scale;
      var rowsHeight = controller.query('getAllRowsHeight', {
        node: node
      });
      var relativeEvent = getRelativeMouseEvent(event, zoomContainer);
      var realTableWrapper = _this.realTableWrapperRef.current;

      if (!realTableWrapper) {
        return;
      }

      var realTableWrapperRect = getBoundingRelativeRect(realTableWrapper, zoomContainer);

      var deltaX = Math.round((relativeEvent.relativeX - realTableWrapperRect.left) / scale) - _this.startTableX;

      var deltaY = Math.round((relativeEvent.relativeY - realTableWrapperRect.top) / scale) - _this.startTableY;

      _this.startTableX = null;
      _this.startTableY = null;

      if (_this.tableResizeControlLinesRef.current) {
        _this.tableResizeControlLinesRef.current.style.display = 'none';
      }

      document.removeEventListener('mousemove', _this.handleTableResizing);
      document.removeEventListener('mouseup', _this.handleTableResizeEnd);
      var maxTableWidth = controller.query('maxTableWidth', {
        node: node
      });
      controller.run('onAction', resizeTableWidth(node, deltaX, maxTableWidth));
      controller.run('onAction', resizeTableHeight(node, rowsHeight, deltaY));

      _this.updateShadowState();
    };

    _this.handleColResizeStart = function (event) {
      var _this$props5 = _this.props,
          scale = _this$props5.scale,
          zoomContainer = _this$props5.zoomContainer,
          node = _this$props5.node;
      var relativeEvent = getRelativeMouseEvent(event, zoomContainer);
      event.preventDefault();
      var targetCell = event.target.closest('td');

      if (!targetCell) {
        return;
      } // @ts-ignore


      _this.resizingColIndex = getColIndex(targetCell, _this.colResizeable, node);

      if (typeof _this.resizingColIndex !== 'number') {
        return;
      }

      _this.resizingColCell = _this.colResizeable === 'left' ? getPrevVisibleCell(targetCell) : targetCell;
      _this.resizingColNextCell = _this.colResizeable === 'left' ? targetCell : getNextVisibleCell(targetCell);
      var realTableWrapper = ReactDOM.findDOMNode(_this.realTableWrapperRef.current);
      var realTableWrapperRect = getBoundingRelativeRect(realTableWrapper, zoomContainer);
      var table = ReactDOM.findDOMNode(_this.tableRef.current);
      var tableRect = getBoundingRelativeRect(table, zoomContainer);
      var firstRowDOM = table.querySelector('tr');
      if (!firstRowDOM) return;
      var firstRowRect = getBoundingRelativeRect(firstRowDOM, zoomContainer);
      _this.startTableX = relativeEvent.relativeX - realTableWrapperRect.left;
      var colResizer = ReactDOM.findDOMNode(_this.colResizerRef.current);
      colResizer.style.display = 'block';
      colResizer.style.height = Math.round(tableRect.bottom - firstRowRect.top) / scale + (_this.isSelected() ? TOOLBAR_ITEM_SIZE / scale : 0) + "px";
      colResizer.style.left = Math.round(_this.startTableX / scale) + "px";
      document.addEventListener('mousemove', _this.handleColResizing);
      document.addEventListener('mouseup', _this.handleColResizeEnd);
    };

    _this.handleColResizing = function (event) {
      var _this$props6 = _this.props,
          node = _this$props6.node,
          colsWidth = _this$props6.colsWidth;
      var _this$props7 = _this.props,
          scale = _this$props7.scale,
          zoomContainer = _this$props7.zoomContainer;
      if (!zoomContainer) return;
      var relativeEvent = getRelativeMouseEvent(event, zoomContainer);
      event.preventDefault();
      var realTableWrapper = _this.realTableWrapperRef.current;
      var colResizer = _this.colResizerRef.current; // Fix: 找不到节点

      if (!realTableWrapper || !colResizer || !_this.resizingColCell) return;
      var realTableWrapperRect = getBoundingRelativeRect(realTableWrapper, zoomContainer);
      var resizingColCellRect = getBoundingRelativeRect(_this.resizingColCell, zoomContainer);
      var resizingColCellRectLeft = resizingColCellRect.left;
      var resizingColCellIndex = _this.resizingColIndex - parseInt(_this.resizingColCell.getAttribute('colspan'), 10) + 1;

      if (!node.data.colsWidth) {
        logNPEInfo(node, {
          type: "node.data.colsWidth is " + node.data.colsWidth,
          nodeData: node.data
        });
        return;
      }

      var fixedColWidth = (colsWidth || []).slice(resizingColCellIndex, _this.resizingColIndex).reduce(function (sum, colWidth) {
        return sum + colWidth;
      }, 0);
      var validLeftLimit = resizingColCellRectLeft + fixedColWidth * scale + MIN_COL_WIDTH * scale;
      var totalWidth = (colsWidth || []).reduce(function (sum, colWidth) {
        return sum + colWidth;
      }, 0);
      var validRightLimit = Infinity;

      if (_this.resizingColNextCell && totalWidth <= _this.getContainerWidth() - 2) {
        var resizingColNextCellRect = getBoundingRelativeRect(_this.resizingColNextCell, zoomContainer);
        var resizingColNextCellRectLeft = resizingColNextCellRect.left;
        var resizingColNextCellIndex = resizingColCellIndex + parseInt(_this.resizingColCell.getAttribute('colspan'), 10);
        validRightLimit = resizingColNextCellRectLeft + (colsWidth[resizingColNextCellIndex] - MIN_COL_WIDTH) * scale;
      }

      var validClientX = Math.max(validLeftLimit, relativeEvent.relativeX);
      validClientX = Math.min(validRightLimit, validClientX);
      colResizer.style.left = Math.round((validClientX - realTableWrapperRect.left) / scale) + "px";
    };

    _this.handleColResizeEnd = function () {
      var scale = _this.props.scale;
      var colResizer = ReactDOM.findDOMNode(_this.colResizerRef.current);

      if (!colResizer) {
        return;
      }

      var delta = parseInt(colResizer.style.left, 10) - Math.round(_this.startTableX / scale);

      if (!isNaN(delta)) {
        _this.handleColResize(_this.resizingColIndex, delta);
      }

      document.removeEventListener('mousemove', _this.handleColResizing);
      document.removeEventListener('mouseup', _this.handleColResizeEnd);
      colResizer.style.display = 'none';
      colResizer.style.left = '';
      _this.resizingColIndex = null;
      _this.resizingColCell = null;
      _this.resizingColNextCell = null;
      _this.startTableX = null;
    };

    _this.handleColResize = function (resizeColIndex, delta) {
      var _this$props8 = _this.props,
          controller = _this$props8.controller,
          node = _this$props8.node;
      controller.run('onAction', resizeTableColWidth({
        node: node,
        colIndex: resizeColIndex,
        delta: delta
      }));

      _this.updateShadowState();
    };

    _this.handleRowResizeStart = function (event) {
      var _this$props9 = _this.props,
          scale = _this$props9.scale,
          zoomContainer = _this$props9.zoomContainer,
          isSelected = _this$props9.isSelected;
      var relativeEvent = getRelativeMouseEvent(event, zoomContainer);
      event.preventDefault();
      var targetCell = event.target.closest('td');

      if (!targetCell) {
        return;
      }

      var resizingRowKey = getRowKey(targetCell, _this.rowResizeable);

      if (!resizingRowKey) {
        return;
      }

      _this.resizingRowKey = resizingRowKey;
      _this.resizingRow = _this.rowResizeable === 'top' ? targetCell.parentElement.previousElementSibling : targetCell.parentElement;
      var realTableWrapper = ReactDOM.findDOMNode(_this.realTableWrapperRef.current);
      var realTableWrapperRect = getBoundingRelativeRect(realTableWrapper, zoomContainer);
      var table = ReactDOM.findDOMNode(_this.tableRef.current);
      var tableRect = getBoundingRelativeRect(table, zoomContainer);
      _this.startTableY = relativeEvent.relativeY - realTableWrapperRect.top;
      var rowResizer = ReactDOM.findDOMNode(_this.rowResizerRef.current);
      rowResizer.style.display = 'block';
      rowResizer.style.marginTop = '-1px';
      var tableWidth = Math.min(tableRect.width, realTableWrapperRect.width);
      rowResizer.style.width = Math.round((tableWidth + (isSelected ? TOOLBAR_ITEM_SIZE : 0)) / scale) + "px";
      rowResizer.style.top = Math.round(_this.startTableY / scale) + "px";
      document.addEventListener('mousemove', _this.handleRowResizing);
      document.addEventListener('mouseup', _this.handleRowResizeEnd);
    };

    _this.handleRowResizing = function (event) {
      var _this$props10 = _this.props,
          scale = _this$props10.scale,
          zoomContainer = _this$props10.zoomContainer;
      var relativeEvent = getRelativeMouseEvent(event, zoomContainer);
      event.preventDefault();
      var realTableWrapper = ReactDOM.findDOMNode(_this.realTableWrapperRef.current);
      var rowResizer = ReactDOM.findDOMNode(_this.rowResizerRef.current); // Fix: 找不到节点

      if (!realTableWrapper || !rowResizer || !_this.resizingRow) return;
      var realTableWrapperRect = getBoundingRelativeRect(realTableWrapper, zoomContainer);
      var resizingColRectTop = getBoundingRelativeRect(_this.resizingRow, zoomContainer).top;
      var validTopLimit = resizingColRectTop + MIN_ROW_HEIGHT * scale;
      var validClientY = Math.max(validTopLimit, relativeEvent.relativeY);
      rowResizer.style.top = Math.round((validClientY - realTableWrapperRect.top) / scale) + "px";
    };

    _this.handleRowResizeEnd = function () {
      var scale = _this.props.scale;
      var rowResizer = ReactDOM.findDOMNode(_this.rowResizerRef.current);

      if (!rowResizer) {
        return;
      }

      var delta = parseInt(rowResizer.style.top, 10) - Math.round(_this.startTableY / scale);

      if (!isNaN(delta)) {
        _this.handleRowResize(_this.resizingRowKey, delta);
      }

      document.removeEventListener('mousemove', _this.handleRowResizing);
      document.removeEventListener('mouseup', _this.handleRowResizeEnd);
      rowResizer.style.display = 'none';
      rowResizer.style.top = '';
      _this.resizingRowKey = null;
      _this.resizingRow = null;
      _this.startTableY = null;
    };

    _this.handleRowResize = function (resizingRowKey, delta) {
      var controller = _this.props.controller;
      var tableRow = controller.value.document.getNode(resizingRowKey); // 协同者可能删除 row

      if (!tableRow) return;
      var originalHeight = controller.query('getRowsHeight', {
        node: tableRow
      });
      controller.run('onAction', setTableRowHeight(tableRow, originalHeight + delta));
    };

    _this.handleSelectRow = function (selectedRowRange, shouldHideContextMenu) {
      if (shouldHideContextMenu === void 0) {
        shouldHideContextMenu = true;
      }

      var _this$props11 = _this.props,
          controller = _this$props11.controller,
          node = _this$props11.node; // selections不止一个的情况，交给pi处理

      lastActiveTableKey = node.key;
      var start = selectedRowRange.start,
          end = selectedRowRange.end;
      controller.run('onAction', selectTableRows(node, start, end));

      if (shouldHideContextMenu) {
        _this.closeContextMenu();
      }
    };

    _this.handleSelectCol = function (selectedColRange, shouldHideContextMenu) {
      if (shouldHideContextMenu === void 0) {
        shouldHideContextMenu = true;
      }

      var _this$props12 = _this.props,
          controller = _this$props12.controller,
          node = _this$props12.node; // selections不止一个的情况，交给pi处理

      lastActiveTableKey = node.key;
      var start = selectedColRange.start,
          end = selectedColRange.end;
      controller.run('onAction', selectTableCols(node, start, end));

      if (shouldHideContextMenu) {
        _this.closeContextMenu();
      }
    };

    _this.handleSelectCorner = function () {
      var _this$props13 = _this.props,
          controller = _this$props13.controller,
          node = _this$props13.node; // selections不止一个的情况，交给pi处理

      lastActiveTableKey = node.key;
      controller.run('onAction', selectTable(node));

      _this.closeContextMenu();
    };

    _this.updateShadowStyleCallback = function (visible) {
      if (!visible) return;
      var _this$props14 = _this.props,
          scale = _this$props14.scale,
          zoomContainer = _this$props14.zoomContainer,
          dataTable = _this$props14.node;
      visibleUtil.unregisterVisibleChange(dataTable.key, _this.updateShadowStyleCallback);
      var table = ReactDOM.findDOMNode(_this.tableRef.current);

      if (!table) {
        return;
      }

      var tableRect = getBoundingRelativeRect(table, zoomContainer);
      var tableLeftShadow = ReactDOM.findDOMNode(_this.tableLeftShadowRef.current);
      var tableRightShadow = ReactDOM.findDOMNode(_this.tableRightShadowRef.current);
      var height = Math.round(tableRect.height / scale) + "px";

      if (tableLeftShadow) {
        tableLeftShadow.style.height = height;
      }

      if (tableRightShadow) {
        tableRightShadow.style.height = height;
      }
    };

    _this.updateShadowStyle = function () {
      var node = _this.props.node;

      if (visibleUtil.getVisible(node.key)) {
        _this.updateShadowStyleCallback(true);
      } else {
        visibleUtil.unregisterVisibleChange(node.key, _this.updateShadowStyleCallback);
        visibleUtil.registerVisibleChange(node.key, _this.updateShadowStyleCallback);
      }
    };

    _this.updateScrollLeft = function () {
      var node = _this.props.node;

      var _ref = node.data || {},
          percentOfScrollLeft = _ref.percentOfScrollLeft;

      var scrollContainer = _this.realTableWrapperRef.current;

      if (!scrollContainer || !_this.tableRef.current) {
        return;
      }

      if (typeof percentOfScrollLeft === 'number') {
        var containerWidth = scrollContainer.offsetWidth;
        var tableWidth = _this.tableRef.current.offsetWidth;
        var totalScroll = tableWidth - containerWidth;
        scrollContainer.scrollTo({
          left: percentOfScrollLeft * totalScroll,
          behavior: 'smooth'
        });
      }
    };

    _this.updateTableResizeController = function () {
      var _this$props15 = _this.props,
          controller = _this$props15.controller,
          scale = _this$props15.scale,
          zoomContainer = _this$props15.zoomContainer;

      if (!_this.isSelected() || !zoomContainer) {
        return;
      }

      var tableDOM = ReactDOM.findDOMNode(_this.tableRef.current);
      var realTableWrapper = ReactDOM.findDOMNode(_this.realTableWrapperRef.current);
      var tableResizeController = ReactDOM.findDOMNode(_this.tableResizeControllerRef.current);

      if (!tableResizeController || !tableDOM || !realTableWrapper) {
        return;
      }

      var tableRect = getBoundingRelativeRect(tableDOM, zoomContainer);
      var realTableWrapperRect = getBoundingRelativeRect(realTableWrapper, zoomContainer);

      if (!controller.query('isTableSupportResize')) {
        tableResizeController.style.display = 'none';
        return;
      } // 可能出现小数的偏差，容错


      if (tableRect.right <= realTableWrapperRect.right + 1) {
        tableResizeController.style.display = '';
        tableResizeController.style.left = Math.round((tableRect.right - realTableWrapperRect.left) / scale) + "px";
        tableResizeController.style.top = Math.round((tableRect.bottom - realTableWrapperRect.top) / scale) + "px";
      } else {
        tableResizeController.style.display = 'none';
      }
    };

    _this.updateOnRender = throttle(function () {
      _this.updateTableResizeController();

      _this.updateShadowStyle();
    });

    _this.handleTableToolbarContextMenu = function (event) {
      event.preventDefault();
      var controller = _this.props.controller;
      controller.run('onContextMenu', event);
    };

    _this.handleMenuEvent = function (type) {
      var _this$props16 = _this.props,
          controller = _this$props16.controller,
          node = _this$props16.node;

      var selection = _this.getTableSelection();

      if (!selection) {
        selection = createTableSelectionForFocusedCell(controller.value, node);
      }

      if (type === 'delete-table') {
        controller.run('onAction', deleteTable(node));
      } else if (type === 'table-width-fit-container') {
        controller.run('onAction', resizeTableWidthFitContainer(node));
      }
    };

    _this.updateShadowState = function () {
      // 文档模型更新后，DOM 不会立刻更新，所以需要等待 DOM 更新后再计算阴影的状态
      if (_this.updateShadowRafId !== null) {
        window.cancelAnimationFrame(_this.updateShadowRafId);
      }

      _this.updateShadowRafId = window.requestAnimationFrame(function () {
        fastdom.measure(function () {
          var table = ReactDOM.findDOMNode(_this.tableRef.current);
          var realTableWrapper = ReactDOM.findDOMNode(_this.realTableWrapperRef.current);

          if (!table || !realTableWrapper) {
            return;
          }

          var zoomContainer = _this.props.zoomContainer;
          var tableRect = getBoundingRelativeRect(table, zoomContainer);
          var realTableWrapperRect = getBoundingRelativeRect(realTableWrapper, zoomContainer);
          var shouldShowTableLeftShadow = realTableWrapper.scrollLeft > 0;
          var scrollableContentWidth = tableRect.width;
          var shouldShowTableRightShadow = scrollableContentWidth - realTableWrapper.scrollLeft > realTableWrapperRect.width;
          var _this$state = _this.state,
              prevLeft = _this$state.shouldShowTableLeftShadow,
              prevRight = _this$state.shouldShowTableRightShadow;

          if (prevLeft !== shouldShowTableLeftShadow || prevRight !== shouldShowTableRightShadow) {
            _this.setState({
              shouldShowTableLeftShadow: shouldShowTableLeftShadow,
              shouldShowTableRightShadow: shouldShowTableRightShadow
            });
          }
        });
      });
    };

    _this.handleTableScroll = throttle(function () {
      var _this$props17 = _this.props,
          controller = _this$props17.controller,
          node = _this$props17.node,
          tableConfig = _this$props17.tableConfig;
      var table = ReactDOM.findDOMNode(_this.tableRef.current);

      if (!table || !_this.realTableWrapperRef.current) {
        return;
      }

      controller.run('onAction', scrollTable(_this.realTableWrapperRef.current));

      if (tableConfig != null && tableConfig.onScroll) {
        tableConfig.onScroll(_this.realTableWrapperRef.current, node);
      }

      _this.updateShadowState();
    });

    _this.getTableSelection = function () {
      var _this$props18 = _this.props,
          controller = _this$props18.controller,
          node = _this$props18.node;
      var tblSelections = controller.query('viewTableSelections');

      if (!tblSelections) {
        return null;
      }

      var curTableSelection = tblSelections.find(function (ts) {
        return ts.key === node.key;
      });

      if (!curTableSelection) {
        return null;
      }

      return curTableSelection;
    };

    _this.getTableLeftMaxBorder = function (table) {
      return table.nodes.reduce(function (acc, row) {
        if (!row.nodes) {
          return acc;
        }

        var firstCell = row.nodes[0];

        if (firstCell && firstCell.data && !firstCell.data.hidden && firstCell.data.bdr && firstCell.data.bdr.left && firstCell.data.bdr.left.sz > acc) {
          return firstCell.data.bdr.left.sz;
        }

        return acc;
      }, 1);
    };

    _this.getAllColsNodes = function (colsNodes) {
      _this.colsNodes = colsNodes;
    };

    _this.handleSetIsHighlightSelection = function (isHighlight) {
      _this.setState({
        isSelectionHighlight: isHighlight
      });
    };

    _this.handleSetHoverSelection = function (sel) {
      _this.setState({
        hoverSelection: sel
      });
    };

    _this.isShowCornerToolbar = function () {
      var tableConfig = _this.props.tableConfig;
      return !(tableConfig != null && tableConfig.hideCornerButton != null && tableConfig.hideCornerButton());
    };

    _this.handleMouseEnterTable = function () {
      // 调整表格宽高时，会频繁触发 mouseenter 和 mouseleave
      // 所以调整期间不更新 isHoverTable
      if (_this.isResizingTable) return;

      _this.setState({
        isHoverTable: true
      });
    };

    _this.handleMouseLeaveTable = function () {
      if (_this.isResizingTable) return;

      _this.setState({
        isHoverTable: false
      });
    };

    _this.setWholeTableHoverSelection = function () {
      var _this$props$node$data, _this$props$node$data2, _this$props$node;

      var cols = (_this$props$node$data = _this.props.node.data) == null ? void 0 : (_this$props$node$data2 = _this$props$node$data.colsWidth) == null ? void 0 : _this$props$node$data2.length;
      var rows = (_this$props$node = _this.props.node) == null ? void 0 : _this$props$node.nodes.length;

      if (!cols || !rows) {
        _this.handleSetHoverSelection(null);

        return;
      }

      _this.handleSetHoverSelection({
        key: _this.props.node.key,
        endColIndex: cols - 1,
        endRowIndex: rows - 1,
        startColIndex: 0,
        startRowIndex: 0
      });
    };

    _this.removeWholeTableHoverSelection = function () {
      _this.handleSetHoverSelection(null);
    };

    _this.handleMouseEnterCornerToolbar = function () {
      _this.setWholeTableHoverSelection();

      _this.setState({
        isHoverCornerToolbar: true
      });
    };

    _this.handleMouseLeaveCornerToolbar = function () {
      _this.removeWholeTableHoverSelection();

      _this.setState({
        isHoverCornerToolbar: false
      });
    };

    _this.state = {
      shouldShowTableLeftShadow: false,
      shouldShowTableRightShadow: false,
      isSelectionHighlight: false,
      hoverSelection: null,
      isHoverTable: false,
      isHoverCornerToolbar: false
    };
    return _this;
  }

  var _proto = Table.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.updateOnRender();
    this.updateShadowState();
    this.updateScrollLeft();
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _this2 = this;

    fastdom.measure(function () {
      var _node$data, _prevNode$data;

      var _this2$props = _this2.props,
          node = _this2$props.node,
          isSelected = _this2$props.isSelected;

      _this2.updateOnRender();

      var prevNode = prevProps.node,
          prevIsSelected = prevProps.isSelected;

      if (isSelected !== prevIsSelected || (node.data.colsWidth || []).length !== (prevNode.data.colsWidth || []).length) {
        _this2.handleTableScroll();
      }

      if (((_node$data = node.data) == null ? void 0 : _node$data.percentOfScrollLeft) !== ((_prevNode$data = prevNode.data) == null ? void 0 : _prevNode$data.percentOfScrollLeft)) {
        _this2.updateScrollLeft();
      }
    });
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.handleTableScroll.cancel();
    this.updateOnRender.cancel();

    if (this.updateShadowRafId !== null) {
      window.cancelAnimationFrame(this.updateShadowRafId);
    }

    document.removeEventListener('mousemove', this.handleColResizing);
    document.removeEventListener('mouseup', this.handleColResizeEnd);
    document.removeEventListener('mousemove', this.handleRowResizing);
    document.removeEventListener('mouseup', this.handleRowResizeEnd);
    document.removeEventListener('mousemove', this.handleTableResizing);
    document.removeEventListener('mouseup', this.handleTableResizeEnd);
  };

  _proto.isInNestedTable = function isInNestedTable(event) {
    var table = event.target.closest('table');
    return table !== ReactDOM.findDOMNode(this.tableRef.current);
  };

  _proto.isSelected = function isSelected() {
    var isSelected = this.props.isSelected;
    return isSelected || Boolean(this.getTableSelection());
  };

  _proto.render = function render() {
    var _this$props19 = this.props,
        controller = _this$props19.controller,
        node = _this$props19.node,
        children = _this$props19.children,
        locale = _this$props19.locale,
        _this$props19$scale = _this$props19.scale,
        scale = _this$props19$scale === void 0 ? 1 : _this$props19$scale,
        zoomContainer = _this$props19.zoomContainer,
        scrollableContainer = _this$props19.scrollableContainer,
        _this$props19$tableCo = _this$props19.tableConfig,
        tableConfig = _this$props19$tableCo === void 0 ? {} : _this$props19$tableCo,
        draggableConfig = _this$props19.draggableConfig,
        visible = _this$props19.visible;
    var _tableConfig$hideDele = tableConfig.hideDeleteButton,
        hideDeleteButton = _tableConfig$hideDele === void 0 ? false : _tableConfig$hideDele,
        _tableConfig$hideWidt = tableConfig.hideWidthFitButton,
        hideWidthFitButton = _tableConfig$hideWidt === void 0 ? false : _tableConfig$hideWidt,
        enableAutofitWidth = tableConfig.enableAutofitWidth,
        enableHeader = tableConfig.enableHeader,
        setTableHeaderStyle = tableConfig.setTableHeaderStyle;
    var _this$state2 = this.state,
        shouldShowTableLeftShadow = _this$state2.shouldShowTableLeftShadow,
        shouldShowTableRightShadow = _this$state2.shouldShowTableRightShadow,
        isSelectionHighlight = _this$state2.isSelectionHighlight,
        hoverSelection = _this$state2.hoverSelection,
        isHoverCornerToolbar = _this$state2.isHoverCornerToolbar;
    var leftOffset = Math.floor(this.getTableLeftMaxBorder(node) / 2);
    var isSelected = this.isSelected();
    var isSelectWholeTable = controller.query('isSelectWholeTable', {
      node: node
    });
    var isHideDeleteButton = typeof hideDeleteButton === 'function' ? hideDeleteButton() : hideDeleteButton;
    var style = {};

    if (visible === false) {
      style.display = 'none';
    }

    return /*#__PURE__*/_createElement(Wrapper, {
      ref: this.wrapperRef,
      onClick: function onClick() {
        // onClick 多覆盖了悬浮工具栏onMouseDown被拦截的情况
        lastActiveTableKey = node.key;
      },
      onMouseDown: this.handleMouseDown,
      onMouseEnter: this.handleMouseEnterTable,
      onMouseLeave: this.handleMouseLeaveTable,
      style: style,
      "data-type": "table"
    }, /*#__PURE__*/_createElement(TableIsSelectedContext.Provider, {
      value: isSelected
    }, /*#__PURE__*/_createElement(TableScrollContainer, {
      className: "real-table-wrapper",
      table: node,
      controller: controller,
      ref: this.realTableWrapperRef,
      onMouseEnter: this.handleMouseEnter,
      onMouseMove: this.handleMouseMove,
      onScroll: this.handleTableScroll,
      disableHorizontalScrollbar: tableConfig == null ? void 0 : tableConfig.disableHorizontalScrollbar // note: 解决左border因滚动表格overflow auto被遮挡的问题
      ,
      style: {
        marginLeft: -leftOffset,
        paddingLeft: leftOffset,
        // 设置 paddingTop、marginTop 保证列工具栏「点」不会被 overflow hidden
        paddingTop: REALTABLE_PADDING.top / scale,
        marginTop: -REALTABLE_PADDING.top / scale,
        paddingBottom: REALTABLE_PADDING.bottom // 由于选中后表格边框有1px边距，因此不加bottom会产生滚动条

      }
    }, /*#__PURE__*/_createElement(TableColToolbar, {
      locale: locale,
      controller: controller,
      table: node,
      tableRef: this.tableRef,
      positionedAncestorRef: this.realTableWrapperRef,
      scrollContainer: this.realTableWrapperRef,
      colIndicatorRef: this.colIndicatorRef,
      isTableSelected: isSelected,
      onContextMenu: this.handleTableToolbarContextMenu,
      onSelect: this.handleSelectCol,
      onColResize: this.handleColResize,
      onGetAllColsNodes: this.getAllColsNodes,
      zoomContainer: zoomContainer,
      getLastActiveTableKey: getLastActiveTableKey,
      scale: scale,
      setIsHighlightSelection: this.handleSetIsHighlightSelection,
      hoverSelection: hoverSelection,
      setHoverSelection: this.handleSetHoverSelection,
      isHideDeleteButton: isHideDeleteButton,
      isHoverCornerToolbar: isHoverCornerToolbar
    }), /*#__PURE__*/_createElement(TableWithSelection, {
      ref: this.tableRef,
      node: node,
      controller: controller,
      left: -leftOffset,
      scale: scale,
      tableSelection: this.getTableSelection(),
      getTableSelection: this.getTableSelection,
      hoverSelection: hoverSelection,
      isSelectionHighlight: isSelectionHighlight
    }, children())), /*#__PURE__*/_createElement(TableResizeController, {
      visible: isSelected,
      onMouseDown: this.handleTableResizeStart,
      ref: {
        // @ts-ignore
        tableResizeControllerRef: this.tableResizeControllerRef,
        tableResizeControlLinesRef: this.tableResizeControlLinesRef
      }
    }), /*#__PURE__*/_createElement(ColResizer, {
      ref: this.colResizerRef
    }), /*#__PURE__*/_createElement(RowResizer, {
      ref: this.rowResizerRef,
      style: {
        left: isSelected ? -TOOLBAR_ITEM_SIZE / scale : 0
      }
    }), /*#__PURE__*/_createElement(ColIndicator, {
      ref: this.colIndicatorRef,
      isTableSelected: isSelected,
      "data-testid": "table-col-indicator",
      scale: scale
    }), /*#__PURE__*/_createElement(RowIndicator, {
      ref: this.rowIndicatorRef,
      isTableSelected: isSelected,
      "data-testid": "table-row-indicator"
    }), /*#__PURE__*/_createElement(TableLeftSideShadow, {
      ref: this.tableLeftShadowRef,
      scale: scale,
      style: {
        display: shouldShowTableLeftShadow ? 'block' : 'none'
      }
    }), /*#__PURE__*/_createElement(TableRightSideShadow, {
      ref: this.tableRightShadowRef,
      scale: scale,
      style: {
        display: shouldShowTableRightShadow ? 'block' : 'none'
      }
    }), /*#__PURE__*/_createElement(TableRowToolbar, {
      locale: locale,
      isSelected: isSelected,
      controller: controller,
      table: node,
      tableRef: this.tableRef,
      offsetParentRef: this.wrapperRef,
      realTableWrapperRef: this.realTableWrapperRef,
      rowIndicatorRef: this.rowIndicatorRef,
      isSelectWholeTable: isSelectWholeTable,
      onContextMenu: this.handleTableToolbarContextMenu,
      onSelect: this.handleSelectRow,
      onRowResize: this.handleRowResize,
      zoomContainer: zoomContainer,
      getLastActiveTableKey: getLastActiveTableKey,
      scale: scale,
      setIsHighlightSelection: this.handleSetIsHighlightSelection,
      setHoverSelection: this.handleSetHoverSelection,
      hoverSelection: hoverSelection,
      scrollableContainer: scrollableContainer,
      isHideDeleteButton: isHideDeleteButton,
      isHoverCornerToolbar: isHoverCornerToolbar
    }), this.isShowCornerToolbar() && /*#__PURE__*/_createElement(TableCornerToolbar, {
      locale: locale,
      visible: this.isSelected() || this.state.isHoverTable,
      controller: controller,
      realTableWrapperRef: this.realTableWrapperRef,
      table: node,
      isSelectWholeTable: !!isSelectWholeTable,
      onSelect: this.handleSelectCorner,
      onMouseEnter: this.handleMouseEnterCornerToolbar,
      onMouseLeave: this.handleMouseLeaveCornerToolbar,
      onToolbarEvent: this.handleMenuEvent,
      zoomContainer: zoomContainer,
      getLastActiveTableKey: getLastActiveTableKey,
      scale: scale,
      setIsHighlightSelection: this.handleSetIsHighlightSelection,
      hideWidthFitButton: hideWidthFitButton,
      draggableConfig: draggableConfig,
      enableAutofitWidth: enableAutofitWidth,
      enableHeader: enableHeader,
      setTableHeaderStyle: setTableHeaderStyle
    }), /*#__PURE__*/_createElement(CornerButton, {
      scale: scale,
      isSelected: isSelected,
      onClick: this.handleSelectCorner,
      active: isSelectWholeTable || isHoverCornerToolbar,
      onMouseEnter: this.handleMouseEnterCornerToolbar,
      onMouseLeave: this.handleMouseLeaveCornerToolbar,
      hoverSelection: !!hoverSelection
    })));
  };

  return Table;
}(React.Component);

var Container = function Container(props) {
  var scrollableContainer = useScrollableContainer();
  var zoomContainer = useZoomContainer() || window.document.body;
  var scale = useZoom();
  var controller = props.controller,
      node = props.node,
      visible = props.visible;

  var _React$useState = React.useState(false),
      pendingSelectedWhole = _React$useState[0],
      setPendingSelectedWhole = _React$useState[1]; // 当仓颉pendingEnable开启的时候通过监听selectionData$的变化来实时确定是否需要更新table
  // 避免等待500ms的防抖延时后再更新
  // pendingEnable为false的情况下，useSelectionStatus注册的回调函数不会执行，因为此时渲染更新是实时的


  var _React$useState2 = React.useState(false),
      realSelected = _React$useState2[0],
      setRealSelected = _React$useState2[1];

  var _React$useReducer = React.useReducer(function (c) {
    return !c;
  }, false),
      forceUpdate = _React$useReducer[1];

  React.useEffect(function () {
    var newTable = controller.value.document.getNode(node.key);
    if (!newTable) return;
    setRealSelected(getTableIsSelected(newTable, controller));
  }, [node, controller.value.selection, controller]);
  var shouldUpdateTable = React.useCallback(function (_ref2) {
    var isPendingSelected = _ref2.isPendingSelected,
        isSelectWholeTable = _ref2.isSelectWholeTable;
    setRealSelected(isPendingSelected);
    setPendingSelectedWhole(isSelectWholeTable);

    if (controller.hasHots()) {
      forceUpdate();
    }
  }, [controller, node]);
  useSelectionStatus(controller, node, shouldUpdateTable, []);
  React.useEffect(function () {
    controller.run('onAction', adjustColsWidth(node));
  });
  var memoProps = React.useMemo(function () {
    return _extends({}, props, {
      isSelected: realSelected,
      isSelectWholeTable: pendingSelectedWhole
    });
  }, [props, realSelected, pendingSelectedWhole]);
  return /*#__PURE__*/_createElement(ContextContainer, {
    isSelected: realSelected
  }, /*#__PURE__*/_createElement(PixelColsWidthContext.Consumer, null, function (_ref3) {
    var pixelColsWidth = _ref3[0];
    return /*#__PURE__*/_createElement(Table, _extends({}, memoProps, {
      scrollableContainer: scrollableContainer,
      zoomContainer: zoomContainer,
      scale: scale || 1,
      colsWidth: pixelColsWidth,
      visible: visible
    }));
  }));
};

export default (function (props) {
  var controller = props.controller,
      node = props.node,
      _props$tableConfig = props.tableConfig,
      tableConfig = _props$tableConfig === void 0 ? {} : _props$tableConfig;
  var enableHeaderSticky = tableConfig.enableHeaderSticky;
  return /*#__PURE__*/_createElement(TableContextContainer, {
    controller: controller,
    table: node,
    enableHeaderSticky: enableHeaderSticky
  }, /*#__PURE__*/_createElement(Container, props));
});
//# sourceMappingURL=table.js.map