function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/* eslint-disable @typescript-eslint/no-shadow */

/* eslint-disable max-lines */

/* eslint-disable react/no-find-dom-node */
import React, { useEffect, useLayoutEffect } from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import equal from 'fast-deep-equal';
import * as ReactDOM from 'react-dom';
import styled from 'styled-components';
import { throttle } from 'lodash-es';
import fastdom from 'fastdom';
import logger from '@ali/4ever-logger';
import Table from "../../../mo/models";
import { domUtils, useHotsAtTheStartOfNextFrame } from '@ali/4ever-cangjie';
import { getBoundingRelativeRect, getRelativeMouseEvent } from '@ali/4ever-utils';
import { HOVER_SHOW_INSERT_DELTA, DISTANCE_BETWEEN_INSERT_BUTTON_AND_TOOLBAR, DRAG_TRIGGER_TIME, DISTANCE_BETWEEN_DELETE_BUTTON_AND_TOOLBAR } from "../../constants";
import { RowResizer } from "../styled";
import { logNPEInfo } from "../../utils/logger";
import getAllRowsDomRect from "../../queries/getAllRowsDomRect";
import { clickTableToolbar, deleteTableRows, insertTableRow, moveTableRows } from "../../actions";
import InlineToolbarInsertButton from "../inlineToolbarButtons/inlineToolbarInsertButton";
import InlineToolbarDeleteButton from "../inlineToolbarButtons/inlineToolbarDeleteButton";
import InsertButtonIndicator, { INDICATOR_WRAPPER_WIDTH } from "../inlineToolbarButtons/insertButtonIndicator";
import DragElement from "./dragElement";
import RowToolbarItem from "./rowToolbarItem";
import { scrollVerticalContainer } from "../../utils/scrollContainer";
import createToolbarWithTableSeletion from "../createToolbarWithTableSelection";
import getDataTableSelectionByTable from "../../utils/getDataTableSelectionByTable";
import { getSelectedRowRangeFromTableSelection } from "../../utils/getSelectedRangeFromTableSelection";
import hasIntersectionObserver from "../../utils/hasIntersectionObserver";
import constants from "../../../utils/constants";
import * as hooks from "../../../utils/hooks";
var usePixelColsWidth = hooks.usePixelColsWidth,
    useRowsClientHeight = hooks.useRowsClientHeight,
    useRowIsSticky = hooks.useRowIsSticky,
    useScrollableContainerRect = hooks.useScrollableContainerRect;
var REALTABLE_PADDING = constants.REALTABLE_PADDING,
    TOOLBAR_ITEM_SIZE = constants.TOOLBAR_ITEM_SIZE,
    MIN_ROW_HEIGHT = constants.MIN_ROW_HEIGHT,
    STICKY_ROW_TOP_HEIGHT = constants.STICKY_ROW_TOP_HEIGHT,
    STICKY_TOOLBAR_INDEX_MAP = constants.STICKY_TOOLBAR_INDEX_MAP;
var RowToolbarWrapper = /*#__PURE__*/styled.div(["display:", ";position:absolute;left:", "px;box-sizing:border-box;width:", "px;padding-left:", "px;z-index:", ";top:", "px;"], function (_ref) {
  var visible = _ref.visible;
  return visible ? 'block' : 'none';
}, function (props) {
  return -(TOOLBAR_ITEM_SIZE + HOVER_SHOW_INSERT_DELTA) / props.scale;
}, function (props) {
  return (TOOLBAR_ITEM_SIZE + 1 + HOVER_SHOW_INSERT_DELTA) / props.scale;
}, function (props) {
  return HOVER_SHOW_INSERT_DELTA / props.scale;
}, STICKY_TOOLBAR_INDEX_MAP.rowToolbar, function (p) {
  return (REALTABLE_PADDING.top + TOOLBAR_ITEM_SIZE) / p.scale;
});
var RowInlineToolbar = /*#__PURE__*/styled.div(["position:absolute;z-index:100;opacity:", ";transition:opacity ease-in 0.25s;pointer-events:", ";"], function (p) {
  return p.isShow ? 1 : 0;
}, function (p) {
  return p.isShow ? 'auto' : 'none';
});
var RowToolbarResizer = /*#__PURE__*/styled.div(["position:absolute;bottom:-4px;right:-1px;height:7px;width:", "px;background-color:transparent;z-index:1;cursor:row-resize;&:hover{background-color:#3296FA;}"], function (props) {
  return (TOOLBAR_ITEM_SIZE + 1) / props.scale;
});

var TableRowToolbar = function TableRowToolbar(props) {
  var _table$data2, _table$data2$colsWidt;

  var table = props.table,
      isSelected = props.isSelected,
      controller = props.controller,
      zoomContainer = props.zoomContainer,
      scale = props.scale,
      tableRef = props.tableRef,
      offsetParentRef = props.offsetParentRef,
      realTableWrapperRef = props.realTableWrapperRef,
      rowIndicatorRef = props.rowIndicatorRef,
      selection = props.selection,
      hoverSelection = props.hoverSelection,
      scrollableContainer = props.scrollableContainer,
      onContextMenu = props.onContextMenu,
      onSelect = props.onSelect,
      onRowResize = props.onRowResize,
      setIsHighlightSelection = props.setIsHighlightSelection,
      setHoverSelection = props.setHoverSelection,
      getLastActiveTableKey = props.getLastActiveTableKey,
      locale = props.locale,
      isHideDeleteButton = props.isHideDeleteButton,
      isHoverCornerToolbar = props.isHoverCornerToolbar;

  var _usePixelColsWidth = usePixelColsWidth(),
      colsWidth = _usePixelColsWidth[0];

  var isRowHeader = Table.isRowHeader(table);

  var _useRowIsSticky = useRowIsSticky(),
      isSticky = _useRowIsSticky[0];

  var _useScrollableContain = useScrollableContainerRect(),
      scrollRect = _useScrollableContain[0];

  var _useRowsClientHeight = useRowsClientHeight(),
      rowsClientHeight = _useRowsClientHeight[0];

  var rowsHeight = React.useMemo(function () {
    return table.nodes.map(function (row) {
      return rowsClientHeight[row.key] || 0;
    });
  }, [rowsClientHeight, table.nodes]);

  var _React$useState = React.useState(false),
      contextMenuVisible = _React$useState[0],
      setContextMenuVisible = _React$useState[1];

  var _React$useState2 = React.useState(-1),
      positionOfInsertButton = _React$useState2[0],
      setInsetBtnPos = _React$useState2[1];

  var _React$useState3 = React.useState(false),
      isHoverDelete = _React$useState3[0],
      setIsHoverDelete = _React$useState3[1];

  var _React$useState4 = React.useState(-1),
      hoverToolbarItemIndex = _React$useState4[0],
      setHoverToolbarItemIndex = _React$useState4[1];

  var _React$useState5 = React.useState(false),
      isDragging = _React$useState5[0],
      setIsDragging = _React$useState5[1];

  var _React$useState6 = React.useState(0),
      draggingRowHeight = _React$useState6[0],
      setDraggingRowHeight = _React$useState6[1];

  var deleteButtonRef = React.useRef(null);
  var rowToolbarRef = React.useRef(null);
  var insertButtonRef = React.useRef(null);
  var draggingRowResizer = React.useRef(null);
  var startPositionTop = React.useRef(null);
  var startClientY = React.useRef(null);
  var originBodyCursor = React.useRef('');
  var rowResizerRef = React.useRef(null);
  var deleteButtonTop = React.useRef(-1); // 当前 viewTable 下的所有行的 DOMRect
  // 不是 dataTable

  var rowsRect = React.useRef([]);
  var isResizingRowFlag = React.useRef(false);
  var dragElementRef = React.useRef(null);
  var dataInsertIndex = React.useRef(-1);
  var startSelectIndex = React.useRef(-1);
  var selectedIndexRange = React.useRef(null);
  var intersectionObRef = React.useRef(null);
  var observerTargets = React.useRef(null);
  var isInitObserver = React.useRef(false); // intersectionOb是否已经监听，避免多次重复监听

  var initObserver = React.useCallback(function () {
    intersectionObRef.current = new IntersectionObserver(function (changes) {
      for (var _iterator = _createForOfIteratorHelperLoose(changes), _step; !(_step = _iterator()).done;) {
        var change = _step.value;

        if (change.intersectionRatio <= 0) {
          change.target.style.visibility = 'hidden';
        } else {
          change.target.style.visibility = 'inherit';
        }
      }
    }, {
      threshold: [0, 1]
    });
    observerTargets.current = document.querySelectorAll('[data-ob="true"]');
    observerTargets.current.forEach(function (target) {
      intersectionObRef.current.observe(target);
    });
  }, []);
  var detachObserver = React.useCallback(function () {
    if (observerTargets.current && intersectionObRef.current) {
      observerTargets.current.forEach(function (target) {
        intersectionObRef.current.unobserve(target);
      });
      intersectionObRef.current.disconnect();
    }
  }, []);
  useEffect(function () {
    if (hasIntersectionObserver && isSelected && !isInitObserver.current) {
      // 监听后标记为true，避免重复执行
      isInitObserver.current = true;
      initObserver();
    }
  }, [initObserver, isSelected]);
  var getRowIndexByClientY = React.useCallback(function (clientY) {
    var index = controller.query('getRowIndexByClientY', {
      node: table,
      clientY: clientY
    });
    return index === null ? -1 : index;
  }, [controller, table]);
  var calcRowsHeight = React.useCallback(function (startIndex, endIndex) {
    var end = endIndex === undefined ? endIndex : endIndex + 1;
    return rowsHeight.slice(startIndex, end).reduce(function (totalHeight, h) {
      return totalHeight + h;
    }, 0);
  }, [rowsHeight]);
  var updateInsertButtonStyle = React.useCallback(function () {
    if (positionOfInsertButton === -1 || !insertButtonRef.current || !selection) {
      return;
    }

    var insertButtonNode = insertButtonRef.current;
    var bottom = calcRowsHeight(positionOfInsertButton);
    var menuRect = getBoundingRelativeRect(insertButtonNode, zoomContainer);
    var right = DISTANCE_BETWEEN_INSERT_BUTTON_AND_TOOLBAR + TOOLBAR_ITEM_SIZE;
    var insertButtonTop = (bottom - menuRect.height / 2) / scale;
    var style = {
      position: 'absolute',
      right: 'unset',
      top: 'unset',
      transform: 'unset',
      bottom: 'unset',
      left: 'unset'
    };

    if (isSticky && (positionOfInsertButton === 0 || positionOfInsertButton === 1)) {
      style.position = 'fixed';
      style.right = 'unset';
      var top = scrollRect.top + STICKY_ROW_TOP_HEIGHT - menuRect.height / 2;
      var rowHeight = positionOfInsertButton === 0 ? 0 : rowsHeight[0];
      style.top = top + rowHeight + "px";

      if (Number.isFinite(scrollRect.left)) {
        style.left = scrollRect.left + "px";
      }

      style.transform = 'translateX(calc(-100% - 2px))';
    } else {
      style.bottom = Math.round(insertButtonTop) + "px";
      style.right = Math.round(right / scale) + "px";
    }

    Object.entries(style).forEach(function (_ref2) {
      var k = _ref2[0],
          v = _ref2[1];
      insertButtonNode.style[k] = v;
    });
  }, [positionOfInsertButton, selection, calcRowsHeight, zoomContainer, scale, isSticky, scrollRect, rowsHeight]);
  var updateIndicatorStyle = React.useCallback(function () {
    if (!selection || !rowIndicatorRef.current || positionOfInsertButton === -1) {
      return;
    }

    try {
      var targetRow = table.nodes[Math.min(positionOfInsertButton, table.nodes.length - 1)]; // Fix to https://work.aone.alibaba-inc.com/issue/38856463. targetRow会存在拿不到的情况，未能复现早值班问题，暂时不好定位具体原因
      // 先做兜底处理,可能跟协同场景下的一些特殊操作有关?

      if (!(targetRow != null && targetRow.key)) {
        return;
      }

      var rowDOM = domUtils.findDOMNode(targetRow.key);
      var tableDOM = domUtils.findDOMNode(table.key);
      var trueTableDOM = tableRef.current;
      var rowRect = getBoundingRelativeRect(rowDOM, offsetParentRef.current);
      var tableRect = getBoundingRelativeRect(tableDOM, zoomContainer);
      var trueTableRect = getBoundingRelativeRect(trueTableDOM, zoomContainer);
      var width = Math.min(tableRect.width, trueTableRect.width) + TOOLBAR_ITEM_SIZE;
      rowIndicatorRef.current.style.width = Math.round(width / scale) + "px";
      rowIndicatorRef.current.style.transform = "translateX(" + -TOOLBAR_ITEM_SIZE / scale + "px)";
      var relativeTop = rowRect.top;

      if (positionOfInsertButton === table.nodes.length) {
        relativeTop = rowRect.bottom;
      }

      if (isSticky && (positionOfInsertButton === 0 || positionOfInsertButton === 1)) {
        var top = scrollRect.top + STICKY_ROW_TOP_HEIGHT;
        var rowHeight = positionOfInsertButton === 0 ? 0 : rowsHeight[0];
        rowIndicatorRef.current.style.top = top + rowHeight + "px";
        rowIndicatorRef.current.style.position = 'fixed';
      } else {
        rowIndicatorRef.current.style.top = Math.round(relativeTop / scale) + "px";
        rowIndicatorRef.current.style.position = 'absolute';
      }
    } catch (e) {
      logger.info({
        type: 'updateIndicatorStyle',
        info: JSON.stringify(e)
      });
    }
  }, [selection, rowIndicatorRef, positionOfInsertButton, table.nodes, table.key, tableRef, offsetParentRef, zoomContainer, scale, isSticky, scrollRect.top, rowsHeight]);
  var getDataSelectedIndexRange = React.useCallback(function () {
    var tableSelection = getDataTableSelectionByTable(controller, table);
    return getSelectedRowRangeFromTableSelection({
      controller: controller,
      table: table,
      tableSelection: tableSelection
    });
  }, [controller, table]);
  var getSelectedIndexRange = React.useCallback(function () {
    var tableSelection = getDataTableSelectionByTable(controller, table);
    return getSelectedRowRangeFromTableSelection({
      controller: controller,
      table: table,
      tableSelection: tableSelection
    });
  }, [controller, table]);
  var getSortedSelectedRange = React.useCallback(function (r) {
    var range = r || getSelectedIndexRange();

    if (!range) {
      return null;
    }

    var start = range.start,
        end = range.end;
    var min = Math.min(start, end);
    var max = Math.max(start, end);
    return {
      min: min,
      max: max
    };
  }, [getSelectedIndexRange]);
  var updateToolbarStyle = React.useCallback(function () {
    updateInsertButtonStyle();
    updateIndicatorStyle();
  }, [updateInsertButtonStyle, updateIndicatorStyle]);
  var updateDeleteButtonStyle = React.useCallback(function () {
    var _thisNode$children$se, _thisNode$children$se2;

    if (!deleteButtonRef.current || !selection) {
      return;
    }

    deleteButtonRef.current.style.display = 'block';
    var thisNode = ReactDOM.findDOMNode(rowToolbarRef.current);
    var targetStartNode = (_thisNode$children$se = thisNode.children[selection.startRowIndex]) == null ? void 0 : _thisNode$children$se.children[0];
    var targetEndNode = (_thisNode$children$se2 = thisNode.children[selection.endRowIndex]) == null ? void 0 : _thisNode$children$se2.children[0]; // TODO: targetEndNode/targetStartNode 为空根因待排查
    // 添加日志定位

    if (!targetEndNode || !targetStartNode) {
      logNPEInfo(table, {
        selection: selection,
        message: (targetEndNode ? 'targetStartNode' : 'targetEndNode') + " is undefined \n"
      });
      return;
    }

    var menuNode = ReactDOM.findDOMNode(deleteButtonRef.current);
    var targetStartRect = getBoundingRelativeRect(targetStartNode, zoomContainer);
    var targetEndRect = getBoundingRelativeRect(targetEndNode, zoomContainer);
    var menuRect = getBoundingRelativeRect(menuNode, zoomContainer);
    var mid = (targetEndRect.bottom - targetStartRect.top) / 2;
    var relativeTop = targetStartRect.top + mid - menuRect.height / 2;
    var left = targetStartRect.left - menuRect.width - DISTANCE_BETWEEN_DELETE_BUTTON_AND_TOOLBAR;
    deleteButtonTop.current = relativeTop / scale;
    menuNode.style.top = deleteButtonTop.current + "px";
    menuNode.style.left = left / scale + "px";
  }, [selection, zoomContainer, table, scale]);
  var handlePreventDefault = React.useCallback(function (event) {
    event.preventDefault();
    event.stopPropagation();
  }, []);
  var showIndicatorVisible = React.useCallback(function (isVisible) {
    if (!rowIndicatorRef.current) {
      return;
    }

    var opacity = isVisible ? '1' : '0';
    rowIndicatorRef.current.style.opacity = opacity;
  }, [rowIndicatorRef]); // 根据鼠标位置判断是否出现插入按钮

  var handleMouseMove = React.useCallback(throttle(function (event) {
    // event 应该是非空的，但是有监控有报错显示为空
    // https://aone.alibaba-inc.com/v2/project/995011/bug/43391898
    if (!rowToolbarRef.current || isResizingRowFlag.current || isDragging || !event) {
      return;
    }

    var clientX = event.clientX,
        clientY = event.clientY; // 鼠标位置在插入按钮区域时，不隐藏插入按钮

    if (positionOfInsertButton !== -1 && insertButtonRef.current) {
      var insertButtonNode = ReactDOM.findDOMNode(insertButtonRef.current);

      var _insertButtonNode$get = insertButtonNode.getBoundingClientRect(),
          _left = _insertButtonNode$get.left,
          _top = _insertButtonNode$get.top,
          _right = _insertButtonNode$get.right,
          _bottom = _insertButtonNode$get.bottom;

      if (clientX >= _left && clientX <= _right && clientY >= _top && clientY <= _bottom) {
        return;
      }
    }

    var toolbarRect = rowToolbarRef.current.getBoundingClientRect();
    var left = toolbarRect.left,
        top = toolbarRect.top,
        right = toolbarRect.right,
        bottom = toolbarRect.bottom; // 鼠标位置不在 toolbar 区域内时，不显示插入按钮

    if (clientX < left || clientX > right || clientY < top - INDICATOR_WRAPPER_WIDTH / 2 || clientY > bottom + INDICATOR_WRAPPER_WIDTH / 2) {
      showIndicatorVisible(false);
      setPositionOfInsertButton(-1);
    }
  }, 200, {
    leading: true
  }), [isDragging, positionOfInsertButton, showIndicatorVisible, getDataSelectedIndexRange]);
  var setPositionOfInsertButton = React.useCallback(function (index) {
    var i = index;

    if (isRowHeader && i === 0) {
      i = -1;
    }

    setInsetBtnPos(i);
    dataInsertIndex.current = i;
  }, [isRowHeader]);
  var handleMouseOverRowToolbarItem = React.useCallback(function (event) {
    var _table$data, _table$data$colsWidth;

    if (isResizingRowFlag.current) return; // 如果不是ToolbarItem触发的则不处理

    var isToolbarItem = event.target.getAttribute('data-ob');
    if (!isToolbarItem) return;
    var index = parseInt(event.target.getAttribute('data-index'), 10);
    if (isNaN(index)) return;
    var tableCols = (_table$data = table.data) == null ? void 0 : (_table$data$colsWidth = _table$data.colsWidth) == null ? void 0 : _table$data$colsWidth.length;

    if (tableCols) {
      // 构造hover选区
      var _hoverSelection = {
        key: table.key,
        startColIndex: 0,
        endColIndex: tableCols - 1,
        startRowIndex: index,
        endRowIndex: index
      };
      setHoverSelection(_hoverSelection); // hover的时候不显示插入按钮

      showIndicatorVisible(false);
      setPositionOfInsertButton(-1);
    }
  }, [setHoverSelection, setPositionOfInsertButton, showIndicatorVisible, (_table$data2 = table.data) == null ? void 0 : (_table$data2$colsWidt = _table$data2.colsWidth) == null ? void 0 : _table$data2$colsWidt.length, table.key]);
  var handleMouseOutRowToolbarItem = React.useCallback(function (e) {
    // 如果不是ToolbarItem触发的则不处理
    var isToolbarItem = e.target.getAttribute('data-ob');
    if (!isToolbarItem) return;
    setHoverSelection(null);
  }, [setHoverSelection]);
  var hideContextMenu = React.useCallback(function () {
    setContextMenuVisible(false);
    document.removeEventListener('mousedown', hideContextMenu);
  }, []);
  var selectRows = React.useCallback(function (start, end, shouldHideContextMenu) {
    if (shouldHideContextMenu === void 0) {
      shouldHideContextMenu = true;
    }

    if (start === end) {
      startSelectIndex.current = start;
    }

    selectedIndexRange.current = {
      start: start,
      end: end
    };
    onSelect({
      start: start,
      end: end
    }, shouldHideContextMenu);
  }, [onSelect]);
  var shouldEnableEndDrag = React.useCallback(function (insertIndex, rowsLength) {
    if (insertIndex === 0 && isRowHeader) return false;

    if (insertIndex > 0 && insertIndex < rowsLength) {
      var maxColIndex = table.data.colsWidth.length - 1;
      var aboveRowSelection = {
        startRowIndex: 0,
        endRowIndex: insertIndex - 1,
        startColIndex: 0,
        endColIndex: maxColIndex,
        key: table.key
      };
      return controller.query('isAllSelectedCellsComplete', {
        node: table,
        tableSelection: aboveRowSelection
      });
    }

    return true;
  }, [table, controller, isRowHeader]);
  var handleMultiSelectRow = React.useCallback(throttle(function (event) {
    if (isDragging) {
      return;
    }

    var selectedIndexRange = getDataSelectedIndexRange();
    var buttons = event.buttons; // 协同下，rowToolbar 可能不存在

    if (buttons !== 1 || !rowToolbarRef.current || !selectedIndexRange) {
      removeMultiSelectListener();
      return;
    }

    var endSelectedIndex = getRowIndexByClientY(event.clientY);

    if (deleteButtonRef.current) {
      deleteButtonRef.current.style.transition = 'top ease-out 0.1s';
    }

    scrollVerticalContainer(event.clientY, scrollableContainer);
    selectRows(startSelectIndex.current, endSelectedIndex);
  }, 100), [isDragging, getDataSelectedIndexRange, getRowIndexByClientY, selectRows]);
  var moveRowToIndex = React.useCallback(function (originIndexRange, targetIndex) {
    var _ref3 = getSortedSelectedRange(originIndexRange),
        min = _ref3.min,
        max = _ref3.max;

    controller.run('onAction', moveTableRows(table, {
      start: min,
      end: max
    }, targetIndex));
    var startIndex = min < targetIndex ? targetIndex - (max - min + 1) : targetIndex;
    selectRows(startIndex, startIndex + max - min);
  }, [controller, table, getSortedSelectedRange, selectRows]);
  var updateDragElementPosition = React.useCallback(function (x, y) {
    if (!dragElementRef.current) {
      return;
    }

    dragElementRef.current.style.left = x / scale + "px";
    dragElementRef.current.style.top = y / scale + "px";
  }, [scale]);
  var calcInsertIndexByRowsRects = React.useCallback(function (clientY, rects) {
    var rowsRects = rects;

    if (!rowsRects) {
      rowsRects = controller.query('getAllRowsDomRect', {
        node: table
      });
    }

    var insertIndex = -1;

    for (var i = 0; i < rowsRects.length; i++) {
      var rowRect = rowsRects[i];

      if (!rowRect) {
        continue;
      }

      if (clientY >= rowRect.top && clientY <= rowRect.top + rowRect.height / 2) {
        insertIndex = i;
        break;
      }

      if (clientY > rowRect.top + rowRect.height / 2 && clientY < rowRect.bottom) {
        insertIndex = i + 1;
        break;
      }
    }

    return insertIndex;
  }, [controller, table]);
  var updateDraggingStyle = React.useCallback(function (relativeEvent) {
    var clientX = relativeEvent.clientX,
        clientY = relativeEvent.clientY,
        relativeX = relativeEvent.relativeX,
        relativeY = relativeEvent.relativeY;
    var tableDOM = domUtils.findDOMNode(table.key);

    if (!tableDOM) {
      return;
    }

    updateDragElementPosition(relativeX, relativeY);
    var tableRect = tableDOM.getBoundingClientRect();

    if (clientX < tableRect.left - TOOLBAR_ITEM_SIZE || clientX > tableRect.right || clientY < tableRect.top - TOOLBAR_ITEM_SIZE || clientY > tableRect.bottom) {
      showIndicatorVisible(false);
      setPositionOfInsertButton(-1);
      return;
    }

    scrollVerticalContainer(clientY, scrollableContainer); // 先根据 dataModel 计算应该插入行的 index 判断是否可以插入
    // 再根据 viewModel 计算行插入指示器渲染的位置

    var insertIndex = calcInsertIndexByRowsRects(clientY);
    var sortedRange = getSortedSelectedRange();

    if (!sortedRange) {
      return;
    }

    var min = sortedRange.min,
        max = sortedRange.max;

    if (insertIndex >= min && insertIndex <= max + 1) {
      insertIndex = -1;
    }

    var dataRowNodes = controller.query('getAllRowsNodes', {
      node: table
    });
    if (!dataRowNodes) return;
    var shouldDragEnd = shouldEnableEndDrag(insertIndex, dataRowNodes.length);

    if (!shouldDragEnd) {
      insertIndex = -1;
    }

    var dataInsertIndexTemp = insertIndex;

    if (insertIndex !== -1) {
      insertIndex = calcInsertIndexByRowsRects(clientY, rowsRect.current);
    }

    showIndicatorVisible(insertIndex !== -1);
    setPositionOfInsertButton(insertIndex);
    dataInsertIndex.current = dataInsertIndexTemp;
  }, [table, controller, scrollableContainer, updateDragElementPosition, showIndicatorVisible, shouldEnableEndDrag, calcInsertIndexByRowsRects, getSortedSelectedRange, setPositionOfInsertButton]);
  var handleDragging = React.useCallback(function (event) {
    var tableDOM = domUtils.findDOMNode(table.key);

    if (!tableDOM || event.buttons !== 1) {
      handleDragEnd();
      return;
    }

    event.stopPropagation();
    var relativeEvent = getRelativeMouseEvent(event, zoomContainer);
    updateDraggingStyle(relativeEvent);
  }, [table, zoomContainer, updateDraggingStyle]);
  var handleDragEnd = React.useCallback(function () {
    setIsDragging(false);
    showIndicatorVisible(false); // Tip: 为避免循环依赖问题，所以这里没有调用removeDragEventListener函数

    document.removeEventListener('mousemove', handleDragging);
    document.removeEventListener('mouseup', handleDragEnd);

    if (dataInsertIndex.current === -1) {
      return;
    }

    var selectedIndexRange = getDataSelectedIndexRange();
    moveRowToIndex(selectedIndexRange, dataInsertIndex.current);
    setPositionOfInsertButton(-1);
  }, [showIndicatorVisible, handleDragging, getDataSelectedIndexRange, moveRowToIndex, setPositionOfInsertButton]);
  var handleDragStart = React.useCallback(function (relativeEvent, rowHeight) {
    setIsDragging(true);
    setDraggingRowHeight(rowHeight);
    updateDraggingStyle(relativeEvent);
    document.addEventListener('mousemove', handleDragging);
    document.addEventListener('mouseup', handleDragEnd);
  }, [updateDraggingStyle, handleDragging, handleDragEnd]);
  var removeDragEventListener = React.useCallback(function () {
    document.removeEventListener('mousemove', handleDragging);
    document.removeEventListener('mouseup', handleDragEnd);
  }, [handleDragging, handleDragEnd]);
  var removeMultiSelectListener = React.useCallback(function () {
    if (deleteButtonRef.current) {
      deleteButtonRef.current.style.transition = 'none';
    }

    document.removeEventListener('mousemove', handleMultiSelectRow);
    document.removeEventListener('mouseup', removeMultiSelectListener);
  }, [handleMultiSelectRow]);
  var addMultiSelectListener = React.useCallback(function () {
    document.addEventListener('mousemove', handleMultiSelectRow);
    document.addEventListener('mouseup', removeMultiSelectListener);
  }, [handleMultiSelectRow, removeMultiSelectListener]);
  var enableDragIcon = React.useCallback(function () {
    var tbs = getSelectedRowRangeFromTableSelection({
      controller: controller,
      table: table,
      tableSelection: selection
    });
    var range = getSortedSelectedRange(tbs); // 禁止拖拽表头行

    if (isRowHeader && (range == null ? void 0 : range.min) === 0) return false;
    return Boolean(range && hoverToolbarItemIndex >= range.min && hoverToolbarItemIndex <= range.max);
  }, [controller, table, selection, getSortedSelectedRange, isRowHeader, hoverToolbarItemIndex]);
  var handleSelectRow = React.useCallback(function (event) {
    handlePreventDefault(event);
    var index = getRowIndexByClientY(event.clientY);
    var sortRange = getDataSelectedIndexRange();
    controller.run('onAction', clickTableToolbar(table, 'row', event.target)); // shift 键多选行

    var selectedIndexRange = getDataSelectedIndexRange();

    if (event.shiftKey && selectedIndexRange && startSelectIndex.current !== index) {
      var start = startSelectIndex.current; // 这里为单测兼容 startSelectIndex.current 为 -1 的情况
      // 正常用户操作不会有此类问题

      if (start === -1) {
        start = selectedIndexRange.start;
      }

      selectRows(start, index);
      return;
    } // 直接选中行


    if (!sortRange || index > sortRange.end || index < sortRange.start) {
      selectRows(index, index);
      addMultiSelectListener();
      return;
    }

    var relativeEvent = getRelativeMouseEvent(event, zoomContainer);
    var timer;
    var isRightClick = event.buttons === 2;

    var clearTimer = function clearTimer() {
      clearTimeout(timer);
      selectRows(index, index, !isRightClick);
      removeCancelDragEventListener();
    };

    var removeCancelDragEventListener = function removeCancelDragEventListener() {
      document.removeEventListener('mousemove', clearTimer);
      document.removeEventListener('mouseup', clearTimer);
    };

    var rowHeight = event.target.getBoundingClientRect().height;
    timer = window.setTimeout(function () {
      removeMultiSelectListener();
      handleDragStart(relativeEvent, rowHeight);
      removeCancelDragEventListener();
    }, DRAG_TRIGGER_TIME);

    if (!enableDragIcon()) {
      clearTimer();
    }

    addMultiSelectListener();
    document.addEventListener('mousemove', clearTimer);
    document.addEventListener('mouseup', clearTimer);
  }, [controller, table, zoomContainer, handlePreventDefault, getRowIndexByClientY, getDataSelectedIndexRange, selectRows, addMultiSelectListener, handleDragStart, removeMultiSelectListener, enableDragIcon]);
  var handleRowResizing = React.useCallback(function (event) {
    if (!draggingRowResizer.current || !zoomContainer) {
      return;
    }

    event.preventDefault();
    var relativeEvent = getRelativeMouseEvent(event, zoomContainer);
    var rowToolbarItem = draggingRowResizer.current.parentElement;

    if (!rowToolbarItem) {
      return;
    }

    var rowToolbarItemRect = getBoundingRelativeRect(rowToolbarItem, zoomContainer);
    var validClientY = Math.max(rowToolbarItemRect.top + MIN_ROW_HEIGHT * scale, relativeEvent.relativeY);
    var delta = validClientY - startClientY.current;
    var top = Math.round(startPositionTop.current + delta / scale) + "px";
    var colResizer = ReactDOM.findDOMNode(rowResizerRef.current);

    if (!colResizer) {
      return;
    }

    colResizer.style.top = top;
    draggingRowResizer.current.style.top = top;
  }, [zoomContainer, scale]); // @ts-ignore

  var handleRowResizeEnd = React.useCallback(function () {
    isResizingRowFlag.current = false;

    if (!draggingRowResizer.current || !startPositionTop.current) {
      return;
    }

    var delta = parseInt(draggingRowResizer.current.style.top, 10) - Math.round(startPositionTop.current);
    var resizingRowIndex = parseInt(draggingRowResizer.current.getAttribute('data-index'), 10);
    var resizingRowKey = table.nodes[resizingRowIndex].key; // @ts-ignore

    onRowResize(resizingRowKey, delta);
    draggingRowResizer.current.style.backgroundColor = '';
    draggingRowResizer.current.style.top = '';
    draggingRowResizer.current = null;
    startPositionTop.current = null;
    startClientY.current = null;
    document.body.style.cursor = originBodyCursor.current;
    originBodyCursor.current = '';
    var rowResizer = ReactDOM.findDOMNode(rowResizerRef.current);

    if (!rowResizer) {
      return null;
    }

    rowResizer.style.display = 'none';
    document.removeEventListener('mousemove', handleRowResizing);
    document.removeEventListener('mouseup', handleRowResizeEnd);
  }, [onRowResize, table, handleRowResizing]);
  var handleRowResizeStart = React.useCallback(function (event) {
    if (!rowToolbarRef.current) return;
    isResizingRowFlag.current = true;
    event.preventDefault();
    event.stopPropagation();
    var relativeEvent = getRelativeMouseEvent(event, zoomContainer);
    startClientY.current = relativeEvent.relativeY;
    draggingRowResizer.current = event.target;
    var resizerRect = getBoundingRelativeRect(draggingRowResizer.current, rowToolbarRef.current);
    startPositionTop.current = (resizerRect.top + resizerRect.height / 2) / scale;
    draggingRowResizer.current.style.backgroundColor = 'transparent';
    originBodyCursor.current = document.body.style.cursor;
    document.body.style.setProperty('cursor', 'row-resize', 'important');
    var table = ReactDOM.findDOMNode(tableRef.current);
    var tableRect = getBoundingRelativeRect(table, zoomContainer);

    if (!realTableWrapperRef.current) {
      return;
    }

    var realTableWrapperRect = realTableWrapperRef.current.getBoundingClientRect(); // eslint-disable-next-line react/no-find-dom-node

    var rowResizer = ReactDOM.findDOMNode(rowResizerRef.current);
    rowResizer.style.display = 'block';
    rowResizer.style.top = startPositionTop.current + "px";
    var tableWidth = Math.min(tableRect.width, realTableWrapperRect.width);
    rowResizer.style.width = Math.round(tableWidth / scale) + "px";
    rowResizer.style.left = (TOOLBAR_ITEM_SIZE + HOVER_SHOW_INSERT_DELTA) / scale + "px";
    document.addEventListener('mousemove', handleRowResizing);
    document.addEventListener('mouseup', handleRowResizeEnd);
  }, [zoomContainer, scale, realTableWrapperRef, tableRef, handleRowResizing, handleRowResizeEnd]);
  var deleteRow = React.useCallback(function () {
    controller.run('onAction', deleteTableRows(table));
  }, [table, controller]);
  var insertRow = React.useCallback(function () {
    var rowsLength = table.nodes.length;
    var targetRow = table.nodes[Math.min(positionOfInsertButton, rowsLength - 1)];
    var type = positionOfInsertButton === rowsLength ? 'insert-row-below' : 'insert-row-above'; // 理论上 targetRow 一定存在，添加 log 定位问题

    if (!targetRow) {
      logNPEInfo(table, {
        type: "insertRow targetRow is undefined " + targetRow,
        positionOfInsertButton: positionOfInsertButton,
        rowsLength: rowsLength
      });
      return;
    }

    controller.run('onAction', insertTableRow(targetRow, type));
  }, [positionOfInsertButton, controller, table]);
  var highlightSelection = React.useCallback(function () {
    setIsHighlightSelection(true);
    setIsHoverDelete(true);
  }, [setIsHighlightSelection]);
  var cancelHighlightSelection = React.useCallback(function () {
    setIsHighlightSelection(false);
    setIsHoverDelete(false);
  }, [setIsHighlightSelection]);
  var handleMouseOver = React.useCallback(function (e) {
    var _rowToolbarRef$curren;

    var targetDom = e.target || e.srcElement;
    var isInsideRowToolbar = targetDom ? ((_rowToolbarRef$curren = rowToolbarRef.current) == null ? void 0 : _rowToolbarRef$curren.contains(targetDom)) || false : false;
    setCanInsertBtnShow(isInsideRowToolbar); // 通过mouseMove去模拟mouseOver，通过判断e.targte是否为目标dom的子元素或者自身即可

    if (isResizingRowFlag.current || isDragging || !rowToolbarRef.current || !isInsideRowToolbar) {
      return;
    }

    var clientY = e.clientY;
    var toolbarTop = rowToolbarRef.current.getBoundingClientRect().top;
    var relativeY = clientY - toolbarTop;
    var totalHeight = 0;
    var index = rowsHeight.findIndex(function (height) {
      if (relativeY >= totalHeight && relativeY <= totalHeight + height) {
        return true;
      }

      totalHeight += height;
      return false;
    });

    if (index === 0 && isRowHeader) {
      setHoverToolbarItemIndex(-1);
    } else {
      setHoverToolbarItemIndex(index);
    }
  }, [isDragging, rowsHeight, isRowHeader]);

  var _React$useState7 = React.useState(true),
      canInsertBtnShow = _React$useState7[0],
      setCanInsertBtnShow = _React$useState7[1]; // 这里通过mouseMove去动态感知全选按钮是否hover到，以此来确定是否需要展示插入行按钮


  React.useEffect(function () {
    if (isSelected) {
      document.addEventListener('mousemove', handleMouseOver, true);
      return function () {
        document.removeEventListener('mousemove', handleMouseOver, true);
      };
    }

    return undefined;
  }, [handleMouseOver, isSelected]);
  var handleMouseOut = React.useCallback(function () {
    if (isResizingRowFlag.current || isDragging) {
      return;
    }

    setHoverToolbarItemIndex(-1);
  }, [isDragging]);
  var handleMouseEnterIndicator = React.useCallback(function (insertIndex) {
    setPositionOfInsertButton(insertIndex);
    showIndicatorVisible(insertIndex !== -1);
  }, [setPositionOfInsertButton, showIndicatorVisible]);
  var handleContextMenu = React.useCallback(function (event) {
    handlePreventDefault(event);
    onContextMenu(event);
    setContextMenuVisible(true);
  }, [handlePreventDefault, onContextMenu, setContextMenuVisible]);
  var renderRowToolbarItems = React.useMemo(function () {
    var rowsCount = table.nodes.length;
    var children = [];
    var isSelectWholeTable = controller.query('isSelectWholeTable', {
      node: table
    });
    var indexRange = getSelectedIndexRange();
    var deleteRange = isHoverDelete ? indexRange : null;
    var selectRanges = indexRange ? [indexRange] : [];

    if (isHoverCornerToolbar || isSelectWholeTable) {
      selectRanges.push({
        start: 0,
        end: rowsCount - 1
      });
    } else if (hoverSelection && hoverSelection.startRowIndex === hoverSelection.endRowIndex) {
      selectRanges.push({
        start: hoverSelection.startRowIndex,
        end: hoverSelection.endRowIndex
      });
    }

    var activeRange = selection ? {
      start: selection.startRowIndex,
      end: selection.endRowIndex
    } : null;

    var getInsertButtonIndicator = function getInsertButtonIndicator(i, isFirst) {
      var indicatorStyle = {
        position: 'absolute',
        right: 8 / scale
      };

      if (isFirst) {
        indicatorStyle.top = 0;
        indicatorStyle.transform = 'translateY(-50%)';
      } else {
        indicatorStyle.bottom = 0;
        indicatorStyle.transform = 'translateY(50%)';
      }

      return /*#__PURE__*/_createElement(InsertButtonIndicator, {
        key: i,
        "data-index": i,
        scale: scale,
        onClick: insertRow,
        onMouseEnter: handleMouseEnterIndicator,
        style: indicatorStyle
      });
    };

    for (var i = 0; i < rowsCount; i += 1) {
      children.push( /*#__PURE__*/_createElement(RowToolbarItem, {
        key: table.nodes[i].key,
        index: i,
        width: TOOLBAR_ITEM_SIZE,
        table: table,
        deleteRange: deleteRange,
        selectRanges: selectRanges,
        activeRange: activeRange,
        isSticky: isSticky,
        scale: scale,
        rowHeight: rowsHeight[i],
        onMouseOut: handleMouseOutRowToolbarItem,
        onMouseOver: handleMouseOverRowToolbarItem,
        onMouseDown: handleSelectRow,
        onContextMenu: handleContextMenu,
        onClick: handlePreventDefault
      }, i === 0 && !isRowHeader ? getInsertButtonIndicator(i, true) : null, getInsertButtonIndicator(i + 1), /*#__PURE__*/_createElement(RowToolbarResizer, {
        "data-index": i,
        onMouseDown: handleRowResizeStart,
        scale: scale,
        "data-testid": "table-row-toolbar-resizer"
      })));
    }

    return children;
  }, [table, controller, getSelectedIndexRange, isHoverDelete, isHoverCornerToolbar, hoverSelection, selection, scale, insertRow, handleMouseEnterIndicator, isSticky, rowsHeight, handleMouseOutRowToolbarItem, handleMouseOverRowToolbarItem, handleSelectRow, handleContextMenu, handlePreventDefault, isRowHeader, handleRowResizeStart]);
  var isShowButton = React.useCallback(function () {
    return !contextMenuVisible && zoomContainer && getLastActiveTableKey() === table.key && selection;
  }, [contextMenuVisible, zoomContainer, getLastActiveTableKey, table.key, selection]); // 展示插入按钮时隐藏删除按钮

  var isShowDelete = React.useCallback(function () {
    var selectedIndexRange = getSelectedIndexRange();
    return Boolean(isShowButton() && selectedIndexRange && positionOfInsertButton === -1 && !isDragging && !isHideDeleteButton);
  }, [getSelectedIndexRange, isShowButton, positionOfInsertButton, isDragging, isHideDeleteButton]);
  var preTableRef = React.useRef(); // 缓存行高变化，由于表格的行高是基于table和controller进行计算，因此只需要在table和controller更新时判断是否需要更新缓存即可
  // 由于行高信息取决于table-row节点的data属性和table-cell节点的data属性，因此只需要判断当前table.nodes跟上次的table.nodes是否相同即可

  React.useLayoutEffect(function () {
    if (!isSelected && !isHoverCornerToolbar) return;
    fastdom.measure(function () {
      if (!equal(preTableRef.current, table.nodes)) {
        preTableRef.current = table.nodes;
        rowsRect.current = getAllRowsDomRect(controller, {
          node: table
        });
      }
    });
  }, [controller, table, table.nodes, isSelected, isHoverCornerToolbar]);
  var colsWidthRef = React.useRef(table.data.colsWidth);
  var scaleRef = React.useRef(scale); // scale 变化的时候也需要重新计算行高信息

  React.useLayoutEffect(function () {
    if (!isSelected) return;
    fastdom.measure(function () {
      if (scaleRef.current !== scale || !equal(colsWidth, colsWidthRef.current)) {
        rowsRect.current = getAllRowsDomRect(controller, {
          node: table
        });
        scaleRef.current = scale;
        colsWidthRef.current = colsWidth;
      }
    }); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [scale, colsWidth, isSelected]);
  useLayoutEffect(function () {
    if (!isSelected) return;
    fastdom.measure(function () {
      updateToolbarStyle();
      updateDeleteButtonStyle();
    });
  }, [updateDeleteButtonStyle, updateToolbarStyle, isSelected]);
  useEffect(function () {
    document.addEventListener('mousemove', handleMouseMove);
    return function () {
      document.removeEventListener('mousemove', handleMouseMove);
    };
  }, [handleMouseMove]); // componentWillUnmount

  useEffect(function () {
    return function () {
      document.removeEventListener('mousemove', handleRowResizing);
      document.removeEventListener('mouseup', handleRowResizeEnd);
      removeMultiSelectListener();
      removeDragEventListener();
      detachObserver(); // 移除监听
    };
  }, []);
  useEffect(function () {
    if (contextMenuVisible) {
      document.addEventListener('mousedown', hideContextMenu);
      return function () {
        document.removeEventListener('mousedown', hideContextMenu);
      };
    }

    return undefined;
  }, [contextMenuVisible, hideContextMenu]);
  var onHotsNextFrame = React.useCallback(function (hots) {
    // PERF: 非当前表格热区不处理
    if (hots.some(function (hot) {
      return table.key === hot.node.key || table.hasNode(hot.node.key);
    })) {
      rowsRect.current = getAllRowsDomRect(controller, {
        node: table
      });
    }
  }, [controller, table]);
  useHotsAtTheStartOfNextFrame(controller, onHotsNextFrame);
  var tableWidth = colsWidth.reduce(function (sum, width) {
    return sum + width;
  }, 0); // 表格全选按钮和insertBtn不能并存

  var isShowInsertButton = !isDragging && positionOfInsertButton !== -1 && canInsertBtnShow;
  var isRowInlineToolbarShow = Boolean(isShowButton() && isShowInsertButton);

  if (!isRowInlineToolbarShow) {
    showIndicatorVisible(false);
  }

  var style = {
    display: isSelected ? 'block' : 'none',
    paddingTop: isSticky ? rowsHeight[0] + 1 : 0
  };
  return /*#__PURE__*/_createElement(RowToolbarWrapper, {
    style: style,
    role: "toolbar",
    "data-testid": "table-row-toolbar",
    scale: scale,
    ref: rowToolbarRef,
    onMouseOut: handleMouseOut
  }, renderRowToolbarItems, /*#__PURE__*/_createElement(RowResizer, {
    ref: rowResizerRef
  }), /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/_createElement(RowInlineToolbar, {
    isShow: isShowDelete(),
    ref: deleteButtonRef,
    "data-testid": "table-row-inline-toolbar"
  }, /*#__PURE__*/_createElement(InlineToolbarDeleteButton, {
    scale: scale,
    mode: "row",
    locale: locale,
    onDelete: deleteRow,
    onHighlightSelection: highlightSelection,
    onCancelHighlightSelection: cancelHighlightSelection
  })), zoomContainer), /*#__PURE__*/_createElement(RowInlineToolbar, {
    ref: insertButtonRef,
    "data-testid": "table-row-inline-toolbar-insert",
    isShow: isRowInlineToolbarShow,
    onMouseMove: handlePreventDefault
  }, /*#__PURE__*/_createElement(InlineToolbarInsertButton, {
    locale: locale,
    table: table,
    rowIndicatorRef: rowIndicatorRef,
    selection: selection,
    mode: "row",
    tableRef: tableRef,
    scale: scale,
    onInsert: insertRow,
    zoomContainer: zoomContainer,
    insertIndex: positionOfInsertButton,
    onShowIndicatorVisible: showIndicatorVisible
  })), zoomContainer && /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/_createElement(DragElement, {
    ref: dragElementRef,
    visible: isDragging,
    height: draggingRowHeight,
    width: tableWidth + TOOLBAR_ITEM_SIZE
  }), zoomContainer));
};

export default createToolbarWithTableSeletion(TableRowToolbar);
//# sourceMappingURL=index.js.map