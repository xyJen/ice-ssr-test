import _extends from "@babel/runtime/helpers/extends";
import { getTagName, getAttributes, getChildren, cssBorderParse, convertBorderToData, praseCSSBackground, parseCSSAbsoluteLength, isNumeric, isCSSAbsoluteLength } from '@ali/4ever-utils';
import { isEmpty } from 'lodash-es';
import { createEmptyParagraph } from '@ali/4ever-cangjie';
import { tagToType, DEFAULT_PAGE_WIDTH } from "./constants";
import { TableTag } from "./types";

function createEmptyTableCell(hidden) {
  if (hidden === void 0) {
    hidden = false;
  }

  return ['tc', {
    hidden: hidden,
    colSpan: 1,
    rowSpan: 1
  }, createEmptyParagraph()];
}

function normalizeTrAttrs(attrs) {
  var normalizedAttrs = {}; // 如果 style 存在则解析 style

  if (typeof attrs.style === 'string') {
    var style = attrs.styleObj; // 行高

    if (style.height) {
      var px = parseCSSAbsoluteLength(style.height, 'px');
      normalizedAttrs.h = parseFloat(px);
    }
  }

  return normalizedAttrs;
}

function normalizeTcAttrs(attrs, element) {
  var normalizedAttrs = {
    // 默认值
    rowSpan: typeof attrs.rowspan === 'number' ? attrs.rowspan : parseInt(attrs.rowspan, 10) || 1,
    colSpan: typeof attrs.colspan === 'number' ? attrs.colspan : parseInt(attrs.colspan, 10) || 1
  };
  var computedStyle = element ? window.getComputedStyle(element) : {}; // 如果 style 存在则解析 style

  if (typeof attrs.style === 'string' || !isEmpty(computedStyle)) {
    var getStyle = function getStyle(name) {
      var _attrs$style;

      return computedStyle[name] || (attrs == null ? void 0 : (_attrs$style = attrs.style) == null ? void 0 : _attrs$style[name]);
    }; // 隐藏的单元格


    if (getStyle('display') === 'none') {
      normalizedAttrs.hidden = true;
    } // 单元格宽度


    if (attrs.width && isCSSAbsoluteLength(getStyle('width'))) {
      normalizedAttrs.width = parseCSSAbsoluteLength(attrs.width, 'px');
    } // 单元格填充色


    if (getStyle('background')) {
      var parsed = praseCSSBackground(getStyle('background'));
      normalizedAttrs.fill = parsed.backgroundColor;
    }

    if (getStyle('backgroundColor')) {
      normalizedAttrs.fill = getStyle('backgroundColor');
    } // 单元格垂直对齐方式


    if (attrs.valign) {
      normalizedAttrs.vAlign = attrs.valign;
    } // 边框


    if (getStyle('border')) {
      var _parsed = cssBorderParse(getStyle('border'));

      if (_parsed && _parsed.style !== 'none') {
        ['top', 'right', 'bottom', 'left'].forEach(function (side) {
          var _extends2;

          normalizedAttrs.bdr = _extends({}, normalizedAttrs.bdr, (_extends2 = {}, _extends2[side] = convertBorderToData(_parsed), _extends2));
        });
      }
    } // 解析不同位置的边框


    ['left', 'right', 'top', 'bottom'].forEach(function (type) {
      var capType = "border" + type[0].toUpperCase() + type.slice(1);

      if (getStyle(capType)) {
        var _parsed2 = cssBorderParse(getStyle(capType));

        if (_parsed2) {
          if (_parsed2.style === 'none') {
            var _normalizedAttrs$bdr;

            (_normalizedAttrs$bdr = normalizedAttrs.bdr) == null ? true : delete _normalizedAttrs$bdr[type];
          } else {
            var _extends3;

            normalizedAttrs.bdr = _extends({}, normalizedAttrs.bdr, (_extends3 = {}, _extends3[type] = convertBorderToData(_parsed2), _extends3));
          }
        }
      }
    });
  }

  return normalizedAttrs;
}
/**
 * 修补 table cell 的数据格式
 * @param table
 */


function normalizeTableCells(table) {
  var rows = getChildren(table);
  rows.forEach(function (row) {
    var cells = getChildren(row);
    cells.forEach(function (cell) {
      var attrs = getAttributes(cell); // 当前 td 不消费 width 数据

      if (attrs && attrs.width) {
        delete attrs.width;
      }
    });
  });
}

/**
 * 将 table ASL 序列化成输出格式，方便做矩阵算法
 * @param table
 */
function jsonMLToTableStructure(table) {
  var rows = getChildren(table);
  var tableAttrs = getAttributes(table);
  var tableStructure = rows.map(function (row) {
    var cells = getChildren(row);
    var rowAttrs = getAttributes(row);
    var rowStructure = cells.map(function (cell) {
      var cellAttrs = getAttributes(cell);
      var rowSpan = 1;
      var colSpan = 1;

      if (cellAttrs) {
        if (typeof cellAttrs.rowSpan === 'number') {
          rowSpan = cellAttrs.rowSpan;
        }

        if (typeof cellAttrs.colSpan === 'number') {
          colSpan = cellAttrs.colSpan;
        }
      }

      return {
        rowSpan: rowSpan,
        colSpan: colSpan,
        value: cell
      };
    });
    rowStructure.attributes = rowAttrs;
    return rowStructure;
  });
  tableStructure.attributes = tableAttrs;
  return tableStructure;
}
/**
 * 将表格矩阵还原为 ASL
 * @param tableStructure
 */


function tableStructureToJsonML(tableStructure) {
  var rows = tableStructure.map(function (rowStructure) {
    var cells = rowStructure.map(function (cell) {
      return cell.value;
    });
    var attrs = rowStructure.attributes;
    var row = attrs ? [TableTag.Tr, attrs].concat(cells) : [TableTag.Tr].concat(cells);
    return row;
  });
  var tableAttrs = tableStructure.attributes;
  var table = tableAttrs ? [TableTag.Table, tableAttrs].concat(rows) : [TableTag.Table].concat(rows);
  return table;
}

function createEmptyCellStructure(hidden) {
  if (hidden === void 0) {
    hidden = false;
  }

  return {
    rowSpan: 1,
    colSpan: 1,
    value: createEmptyTableCell(hidden)
  };
}
/**
 * 订正表格的单元格结构
 * 1. 补齐 span 的单元格跨度空缺
 * 2. 订正不规整的行列
 * @param table
 */


function normalizeTableStructure(table) {
  // 第一步，填补 span 的单元格
  for (var i = 0; i < table.length; i++) {
    var row = table[i];

    for (var j = 0; j < row.length; j++) {
      var cell = row[j]; // 如果在当前行中列跨度大于 1，则在当前坐标之后 +1 填充单元格

      if (cell.colSpan > 1) {
        // 由于第一个单元格已经占 1 位，所以要 -1
        var fillCells = Array(cell.colSpan - 1).fill(true).map(createEmptyCellStructure);
        row.splice.apply(row, [j + 1, 0].concat(fillCells));
      }
    }
  }

  for (var _i = 0; _i < table.length; _i++) {
    var _row = table[_i];

    for (var _j = 0; _j < _row.length; _j++) {
      var _cell = _row[_j]; // 如果行的跨度大于 1，则需要在下面的行中填充单元格

      if (_cell.rowSpan > 1) {
        for (var k = _i + 1, end = _i + _cell.rowSpan; k < end; k++) {
          var _fillRow;

          var fillRow = table[k]; // 可能会出现一种情况，表格的行不够填充了，则这里要追加行

          if (!fillRow) {
            fillRow = Array(_j).fill(false).map(createEmptyCellStructure);
            table[k] = fillRow;
          }

          var _fillCells = Array(_cell.colSpan).fill(true).map(createEmptyCellStructure);

          (_fillRow = fillRow).splice.apply(_fillRow, [_j, 0].concat(_fillCells));
        }
      }
    }
  } // 第二步，填补不规整的行


  var maxColSize = table.reduce(function (size, row) {
    return Math.max(size, row.length);
  }, -Infinity);
  table.forEach(function (row) {
    var offset = maxColSize - row.length;

    if (offset > 0) {
      row.push.apply(row, Array(offset).fill(false).map(createEmptyCellStructure));
    }
  });
}

function normalizeTableSpan(table) {
  var tableStructure = jsonMLToTableStructure(table);
  normalizeTableStructure(tableStructure);
  return tableStructureToJsonML(tableStructure);
}

function normalizeTable(table) {
  // 订正单元格
  table = normalizeTableSpan(table);
  var rows = getChildren(table); // 空表格

  if (rows.length <= 0) {
    return table;
  }

  var firstRow = rows[0];
  var cells = getChildren(firstRow);
  var colsCount = cells.length;
  var tableAttrs = getAttributes(table); // 如果 table 的 colsWidth 缺失，则需要进行计算

  if (tableAttrs.colsWidth.length !== colsCount) {
    // 计算第一行的 td width 数据
    var colsWidth = cells.map(function (cell) {
      var tableCellAttrs = getAttributes(cell);
      return parseInt(tableCellAttrs.width || '0', 10);
    }).filter(function (width) {
      return width > 0;
    }); // 如果列宽的数量与列数相等，则认为是合法数据

    if (colsWidth.length === colsCount) {
      tableAttrs.colsWidth = colsWidth;
    } else {
      // 注意这个值可能需要优化，纸张在不同的模式下宽度都不同，考虑到自适应的问题，目前暂时设一个较少的值
      var colWidth = Math.floor(DEFAULT_PAGE_WIDTH / colsCount);
      tableAttrs.colsWidth = Array(colsCount).fill(colWidth);
    }
  } // 单元格数据合法化


  normalizeTableCells(table);
  return table;
}

function flatAppendTr(state, node) {
  var tagName = getTagName(node);
  var attrs = getAttributes(node);
  var chlidren = getChildren(node);
  var current = attrs ? [tagName, attrs] : [tagName];
  chlidren.forEach(function (child) {
    var childTagName = getTagName(child); // tr 内嵌 tr，则把嵌套的 tr 打平

    if (childTagName === tagName) {
      if (getChildren(current).length) {
        state.append(current);
      }

      state.append(child);
      current = attrs ? [tagName, attrs] : [tagName];
      return;
    } // 不支持 tr 内嵌套单元格以外数据类型


    if (childTagName !== 'tc') return;
    current.push(child);
  }); // 有些tr虽然没有child，但是属于合并单元格的一项，不可直接摒弃

  state.append(current);
}

export default function htmlToJsoML() {
  return {
    name: 'table',
    onOpenTag: function onOpenTag(state, name, rawAttrs) {
      if (name === 'col') {
        var table = state.closest('table');

        if (table && isNumeric(rawAttrs.width)) {
          var tableAttrs = getAttributes(table);
          tableAttrs.colsWidth.push(parseInt(rawAttrs.width, 10));
        }

        return true;
      }

      if (name === 'td' || name === 'th') {
        name = 'tc'; // eslint-disable-line no-param-reassign
      }

      if (!tagToType[name]) return false;
      var element = state.currentDom; // 创建节点

      var node = [name];
      state.push(node);

      switch (name) {
        case TableTag.Table:
          {
            node.push({
              colsWidth: []
            });
            break;
          }

        case TableTag.Tr:
          {
            var attrs = normalizeTrAttrs(rawAttrs);
            node.push(attrs);
            break;
          }

        case TableTag.Tc:
          {
            var _attrs = normalizeTcAttrs(rawAttrs, element);

            node.push(_attrs);
            break;
          }

        default:
          return true;
      }

      return true;
    },
    onCloseTag: function onCloseTag(state, name) {
      if (name === 'td' || name === 'th') {
        name = TableTag.Tc;
      }

      if (!tagToType[name]) return false;
      var node = state.pop();
      var tagName = getTagName(node);

      switch (tagName) {
        case TableTag.Table:
          {
            var table = normalizeTable(node); // 只接受非空表格

            if (getChildren(table).length > 0) {
              state.append(table);
            }

            return true;
          }

        case TableTag.Tr:
          {
            flatAppendTr(state, node);
            return true;
          }

        case TableTag.Tc:
          {
            // 空单元格
            if (getChildren(node).length === 0) {
              node.push(createEmptyParagraph());
            }

            var attrs = getAttributes(node);

            if (attrs.width) {
              var width = parseFloat(parseCSSAbsoluteLength(attrs.width, 'px')); // 如果是 0 宽单元格则丢弃

              if (width === 0) {
                return true;
              }
            } else if (attrs.hidden) {
              // 隐藏的单元这里不解析，在表格的 normalize 中会自行填充空缺的单元格
              return true;
            }

            state.append(node);
            return true;
          }

        default:
          return false;
      }
    }
  };
}
//# sourceMappingURL=htmlToJsonML.js.map