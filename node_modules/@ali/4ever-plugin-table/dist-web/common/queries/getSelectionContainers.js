import { Selection, domUtils, TextPoint } from '@ali/4ever-cangjie';
import Table from "../../mo/models";
import TableCell from "../../mo/models/tableCell";
import TableRow from "../../mo/models/tableRow";
import { memoize } from 'lodash-es';

var isRealTable = function isRealTable(node) {
  return Table.isTable(node) && !node.data.sr;
}; // 排除分栏


export var getAllTables = memoize(function (root) {
  // 根据类型定义和传参进行理论分析，这里不会有 NPE 问题，但监控上报了且尝试复现未果
  // 这里先做个防御，并进一步收集信息供分析
  // Ref: https://aone.alibaba-inc.com/v2/project/995011/bug/45757203
  if (!root || !root.filterDescendants) {
    console.warn('Unexpected NPE: not valid Document type', root);
    return [];
  }

  return root.filterDescendants(isRealTable);
});
export default function getSelectionContainers(controller, _ref) {
  var originSelection = _ref.selection,
      defaultWrapper = _ref.defaultWrapper,
      doc = _ref.document;
  var document = doc || controller.value.document;

  if (!document) {
    console.warn("getSelectionContainers[Table]: document is " + document);
    return new Map();
  }

  var tables = getAllTables(document);

  var _originSelection$sort = originSelection.sort(document),
      start = _originSelection$sort.start,
      end = _originSelection$sort.end;

  var startPath = document.getPath(start.key);
  var endPath = document.getPath(end.key);
  var res = new Map();

  if (!startPath || !endPath) {
    return res;
  }

  var afterTablePoint = null;
  var beforeTablePoint = null;
  tables.forEach(function (table) {
    var tablePath = document.getPath(table.key);

    if (!tablePath) {
      return;
    }

    var startClosestAncestorTable = document.getClosestByPath(startPath, isRealTable);
    var endClosestAncestorTable = document.getClosestByPath(endPath, isRealTable);
    var isStartInTable = startClosestAncestorTable === table;
    var isEndInTable = endClosestAncestorTable === table; // 选区完全在 table 里

    if (isStartInTable && isEndInTable) {
      var startClosestRow = document.getClosestByPath(startPath, TableRow.isTableRow);
      var startClosestCell = document.getClosestByPath(startPath, TableCell.isTableCell);
      var endClosestCell = document.getClosestByPath(endPath, TableCell.isTableCell);
      var wrapper;

      if (startClosestCell && startClosestCell.key === (endClosestCell == null ? void 0 : endClosestCell.key) && TableRow.isHeader(startClosestRow)) {
        wrapper = domUtils.findSelectionSlot(startClosestCell.key);
      } else {
        wrapper = domUtils.findSelectionSlot(table.key);
      }

      if (wrapper) {
        res.set(originSelection, {
          wrapper: wrapper,
          originSelection: originSelection
        });
      }

      return;
    } // expanded 选区部分在 table 里


    if (isStartInTable || isEndInTable) {
      var firstText = table.getFirstText();
      var lastText = table.getLastText();

      if (!firstText || !lastText && isStartInTable) {
        return;
      }

      var _ref2 = isStartInTable ? [start, TextPoint.create({
        key: lastText.key,
        offset: lastText.text.length
      })] : [TextPoint.create({
        key: firstText.key,
        offset: 0
      }), end],
          newStart = _ref2[0],
          newEnd = _ref2[1];

      if (isStartInTable) {
        var nextText = document.getNextText(lastText.key);
        afterTablePoint = nextText && TextPoint.create({
          key: nextText.key,
          offset: 0
        });
      } else {
        var prevText = document.getPreviousText(firstText.key);
        beforeTablePoint = prevText && TextPoint.create({
          key: prevText.key,
          offset: prevText.text.length
        });
      }

      var _wrapper = domUtils.findSelectionSlot(table.key);

      if (!_wrapper) {
        return;
      }

      res.set(Selection.create({
        anchor: newStart,
        focus: newEnd
      }), {
        wrapper: _wrapper,
        originSelection: originSelection
      });
    }
  });

  if (afterTablePoint || beforeTablePoint) {
    var restSelection = Selection.create({
      anchor: afterTablePoint || start,
      focus: beforeTablePoint || end
    });
    res.set(restSelection, {
      wrapper: defaultWrapper,
      originSelection: originSelection
    });
  }

  return res;
}
//# sourceMappingURL=getSelectionContainers.js.map