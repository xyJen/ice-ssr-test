import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
import React, { useEffect, useRef, useState } from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import styled from 'styled-components';
import { noop, throttle } from 'lodash-es';
import equal from 'fast-deep-equal';
import { SelectionSlot, useZoomContainer, useZoom, useScrollableContainer } from '@ali/4ever-cangjie';
import Table from "../mo/models";
import TableCell from "../mo/models/tableCell";
import { QUICK_INSERT_BUTTON_WIDTH_HEIGHT, SCROLL_BAR_HEIGHT, DEFAULT_TOTAL_WIDTH_FOR_AUTOFIT } from "../utils/constants";
import HorizontalScroll from "../utils/utils/horizontalScroll";
import { SCROLLABLE_ATTRIBUTE } from '@ali/4ever-plugin-draggable';
import { TableScrollContainerContext, TableScrollContainerWidthContext, TableScrollContainerScrollLeftContext, usePixelColsWidth } from "../utils/hooks";
import { convertFromPercentToPixel } from "../utils/utils/colsWidthConverter";
import getPositionOfCell from "../utils/utils/getPositionOfCell";
import { useSelectionStatus } from "../utils/hooks/useSelectionStatus";
import { getBoundingRelativeRect } from '@ali/4ever-utils';
import useResizeObserver from "../utils/utils/useResizeObserver";
import { visibleUtil } from "../utils/utils/visibleUtil";
export var Wrapper = /*#__PURE__*/styled.div(["overflow-x:scroll;overflow-y:auto;position:relative;::-webkit-scrollbar{width:", "px;height:", "px;}:hover::-webkit-scrollbar-thumb{background:rgba(0,0,0,0.12);border-radius:5px;border:1px solid transparent;background-clip:content-box;}:hover::-webkit-scrollbar-thumb:hover{background:rgba(0,0,0,0.20);border-radius:5px;border:1px solid transparent;background-clip:content-box;}", ""], SCROLL_BAR_HEIGHT, SCROLL_BAR_HEIGHT, function (p) {
  return p.hideScrollBar ? "\n    ::-webkit-scrollbar {\n      display: none;\n    }\n    ::-webkit-scrollbar-thumb {\n      display: none;\n    }\n  " : '';
});
var TableScrollContainer = /*#__PURE__*/React.forwardRef(function (props, forRef) {
  var children = props.children,
      table = props.table,
      controller = props.controller,
      isMobile = props.isMobile,
      _props$onMouseEnter = props.onMouseEnter,
      onMouseEnter = _props$onMouseEnter === void 0 ? noop : _props$onMouseEnter,
      _props$onMouseMove = props.onMouseMove,
      onMouseMove = _props$onMouseMove === void 0 ? noop : _props$onMouseMove,
      onScroll = props.onScroll,
      disableHorizontalScrollbar = props.disableHorizontalScrollbar,
      hideScrollBar = props.hideScrollBar,
      rest = _objectWithoutPropertiesLoose(props, ["children", "table", "controller", "isMobile", "onMouseEnter", "onMouseMove", "onScroll", "disableHorizontalScrollbar", "hideScrollBar"]);

  var scrollableContainer = useScrollableContainer();
  var zoomContainer = useZoomContainer();
  var zoom = useZoom();
  var horizontalScrollRef = useRef(null);
  var ref = useRef(null);

  var _useState = useState(0),
      width = _useState[0],
      setWidth = _useState[1];

  var _useState2 = useState(0),
      scrollLeft = _useState2[0],
      setScrollLeft = _useState2[1];

  var widthRef = useRef(width);
  var intersectionObRef = useRef(null);
  useEffect(function () {
    if (!disableHorizontalScrollbar && scrollableContainer && !isMobile && ref.current) {
      var callback = function callback(entries) {
        var isVisible = entries[0].intersectionRatio > 0;
        visibleUtil.setVisible(table.key, isVisible);

        if (!isVisible) {
          var _horizontalScrollRef$;

          (_horizontalScrollRef$ = horizontalScrollRef.current) == null ? void 0 : _horizontalScrollRef$.removeEventListener();
        } else if (horizontalScrollRef.current) {
          var _horizontalScrollRef$2;

          // fix: https://work.aone.alibaba-inc.com/issue/44551345
          (_horizontalScrollRef$2 = horizontalScrollRef.current) == null ? void 0 : _horizontalScrollRef$2.addEventListener();
        } else if (ref.current) {
          var getFootBottom = function getFootBottom() {
            var isWindow = scrollableContainer.window;
            var scrollContainerBottom = isWindow ? window.innerHeight : scrollableContainer.getBoundingClientRect().bottom;
            var footerHeight = Math.ceil(window.innerHeight - scrollContainerBottom);
            return Math.max(footerHeight, 0);
          };

          horizontalScrollRef.current = new HorizontalScroll(ref.current, getFootBottom, scrollableContainer);
        }
      };

      intersectionObRef.current = new IntersectionObserver(callback);
      intersectionObRef.current.observe(ref.current);
      return function () {
        if (ref.current) {
          var _intersectionObRef$cu;

          (_intersectionObRef$cu = intersectionObRef.current) == null ? void 0 : _intersectionObRef$cu.unobserve(ref.current);
        }
      };
    }

    return undefined;
  }, [scrollableContainer, isMobile, disableHorizontalScrollbar, table.key]);
  useEffect(function () {
    if (typeof forRef === 'function') {
      forRef(ref.current);
    } else if (forRef) {
      forRef.current = ref.current;
    }
  }, [ref, forRef]);
  var handleScroll = throttle(function (e) {
    var _ref$current;

    onScroll && onScroll(e);
    var left = (_ref$current = ref.current) == null ? void 0 : _ref$current.scrollLeft;

    if (Number.isFinite(left) && scrollLeft !== left) {
      setScrollLeft(left);
    }
  });

  var _React$useState = React.useState([]),
      colsWidthByPixel = _React$useState[0],
      setColsWidthByPixel = _React$useState[1];

  var _usePixelColsWidth = usePixelColsWidth(),
      pixelColsWidth = _usePixelColsWidth[0],
      setPixelColsWidth = _usePixelColsWidth[1];

  var prevPixelColsWidth = React.useRef([]);
  React.useEffect(function () {
    var newPixelColsWidth = Table.isAutofitWidth(table) ? colsWidthByPixel : table.data.colsWidth;

    if (!equal(newPixelColsWidth, prevPixelColsWidth.current)) {
      setPixelColsWidth(newPixelColsWidth || []);
      prevPixelColsWidth.current = newPixelColsWidth || [];
    }
  }, [colsWidthByPixel, setPixelColsWidth, table]);
  var prevColsWidth = React.useRef([]); // table 变化时

  React.useEffect(function () {
    if (!Table.isAutofitWidth(table) || !widthRef.current) return;
    var totalWidth = widthRef.current / zoom - 2;

    if (isMobile) {
      totalWidth = DEFAULT_TOTAL_WIDTH_FOR_AUTOFIT;
    }

    var pxlColsWidth = convertFromPercentToPixel(table, totalWidth);
    setColsWidthByPixel(pxlColsWidth);
  }, [table, isMobile, zoom]);
  var totalColsWidth = (pixelColsWidth || []).reduce(function (acc, cw) {
    return acc + cw;
  }, 0);
  var prevTotalColsWidth = React.useRef(0);
  var resizeObserverCallback = React.useCallback(function (rect) {
    // table 开启 prune display: none 时，宽度是 0
    if (rect.width === 0) return;
    var actualWith = rect.width;

    if (widthRef.current !== actualWith || prevTotalColsWidth.current !== totalColsWidth) {
      setWidth(Number.isFinite(totalColsWidth) ? Math.min(actualWith, totalColsWidth + 1) : actualWith);
      widthRef.current = actualWith;
      prevTotalColsWidth.current = totalColsWidth;

      if (Table.isAutofitWidth(table)) {
        prevColsWidth.current = table.data.colsWidth;
        var totalWidth = actualWith / zoom - 2;

        if (isMobile) {
          totalWidth = DEFAULT_TOTAL_WIDTH_FOR_AUTOFIT;
        }

        var pxlColsWidth = convertFromPercentToPixel(table, totalWidth);
        setColsWidthByPixel(pxlColsWidth);
      }
    }
  }, [isMobile, table, totalColsWidth, zoom]);
  useResizeObserver(ref.current, resizeObserverCallback);
  var prevPosition = React.useRef(null);
  var handleScrollIntoView = React.useCallback(function (focusPosition) {
    // horizontal
    if ((focusPosition == null ? void 0 : focusPosition.colIndex) !== undefined && pixelColsWidth) {
      var index = focusPosition.colIndex;
      var targetColRightBorder = pixelColsWidth.slice(0, index + 1).reduce(function (sum, colWidth) {
        return sum + colWidth;
      }, 0);
      var targetColLeftBorder = targetColRightBorder - pixelColsWidth[index];
      targetColRightBorder = index === pixelColsWidth.length - 1 ? targetColRightBorder + QUICK_INSERT_BUTTON_WIDTH_HEIGHT : targetColRightBorder;
      window.requestAnimationFrame(function () {
        if (!ref.current) {
          return;
        }

        var realTableWrapperRect = getBoundingRelativeRect(ref.current, zoomContainer);
        var sl = ref.current.scrollLeft;

        if (pixelColsWidth[index] <= realTableWrapperRect.width && (sl > targetColLeftBorder || sl + realTableWrapperRect.width < targetColRightBorder)) {
          var finalScrollLeft = targetColRightBorder - realTableWrapperRect.width;
          ref.current.scrollLeft = finalScrollLeft;
        }
      });
    } else {// vertical
      // TODO: 向下插入一行后，新增行可能会超出可见区域
    }
  }, [pixelColsWidth, zoomContainer]);
  var shouldUpdateTable = React.useCallback(function (_ref) {
    var isPendingSelected = _ref.isPendingSelected,
        range = _ref.range;

    // 在表格内的光标位置变化
    if (range.isCollapsed && isPendingSelected) {
      var _prevPosition$current, _prevPosition$current2;

      var focusCell = controller.value.document.getClosest(range.focus.key, TableCell.isTableCell);

      if (!focusCell) {
        return;
      } // 检查所属单元格位置是否发生变化，若变化则按需横向滚动进视区


      var position = getPositionOfCell(focusCell.key, table);

      if (position && (((_prevPosition$current = prevPosition.current) == null ? void 0 : _prevPosition$current.colIndex) !== position.colIndex || ((_prevPosition$current2 = prevPosition.current) == null ? void 0 : _prevPosition$current2.rowIndex) !== position.rowIndex)) {
        prevPosition.current = position;
        handleScrollIntoView(position);
      }
    }
  }, [controller, table, handleScrollIntoView]);
  useSelectionStatus(controller, table, shouldUpdateTable, []);
  return /*#__PURE__*/_createElement(Wrapper, _extends({}, rest, {
    onMouseEnter: onMouseEnter,
    onMouseMove: onMouseMove,
    onScroll: handleScroll,
    ref: ref,
    hideScrollBar: hideScrollBar
  }, SCROLLABLE_ATTRIBUTE), /*#__PURE__*/_createElement(TableScrollContainerContext.Provider, {
    value: ref.current
  }, /*#__PURE__*/_createElement(TableScrollContainerWidthContext.Provider, {
    value: width
  }, /*#__PURE__*/_createElement(TableScrollContainerScrollLeftContext.Provider, {
    value: scrollLeft
  }, children))), /*#__PURE__*/_createElement(SelectionSlot, {
    layerFor: table.key
  }));
});
export default TableScrollContainer;
//# sourceMappingURL=tableScrollContainer.js.map