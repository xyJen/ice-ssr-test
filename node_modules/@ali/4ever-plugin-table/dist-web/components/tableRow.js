import _extends from "@babel/runtime/helpers/extends";
import * as React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import styled from 'styled-components';
import { noop, throttle } from 'lodash-es';
import { useZoom, useScrollableContainer } from '@ali/4ever-cangjie';
import { DEFAULT_BORDER_COLOR, MIN_ROW_HEIGHT, STICKY_ROW_TOP_HEIGHT, STICKY_TOOLBAR_INDEX_MAP, TOOLBAR_ITEM_SIZE } from "../utils/constants";
import { usePixelColsWidth, useTableScrollContainerWidth, useTableScrollContainerScrollLeft, useScrollableContainerRect, RowIsStickyContext, useUpdateTableSelectionContext, useTableIsSelected, useRowIsSticky, useRowsClientHeight, useTableScrollContainer } from "../utils/hooks";
import useResizeObserver from "../utils/utils/useResizeObserver";
import shouldRowSticky from "../utils/utils/shouldRowSticky";
var BORDER_BOTTOM_WIDTH = 1;
var STICKY_MARGIN_LEFT = -1;
var TR = /*#__PURE__*/styled.tr(["&[data-sticky=\"true\"]{border-bottom:", "px solid ", ";margin-left:", "px;z-index:", ";background:white;box-shadow:rgb(17 31 44 / 10%) 0px 6px 4px -4px;overscroll-behavior-x:none;td{border-width:1px 0 0 1px;margin-right:-1px;&:last-of-type{border-right:1px solid ", ";}}}"], BORDER_BOTTOM_WIDTH, DEFAULT_BORDER_COLOR, STICKY_MARGIN_LEFT, STICKY_TOOLBAR_INDEX_MAP.stickyRow, DEFAULT_BORDER_COLOR);

var TableRow = function TableRow(_ref) {
  var attributes = _ref.attributes,
      node = _ref.node,
      children = _ref.children,
      controller = _ref.controller,
      parent = _ref.parent;
  var readOnly = controller.readOnly;
  var rowDOMRef = React.useRef(null);
  var height = node.data.h || MIN_ROW_HEIGHT;
  var scrollContainer = useScrollableContainer();

  var _React$useState = React.useState(0),
      top = _React$useState[0],
      setTop = _React$useState[1];

  var _React$useReducer = React.useReducer(function (c) {
    return c + 1;
  }, 0),
      forceUpdate = _React$useReducer[1];

  var renderHeightRef = React.useRef(0);
  var prevRelativeLeftRef = React.useRef(0);

  var _React$useState2 = React.useState(0),
      clientHeight = _React$useState2[0],
      setClientHeight = _React$useState2[1];

  var isTableSelected = useTableIsSelected();
  var zoom = useZoom();

  var _ref2 = usePixelColsWidth() || [],
      colsWidth = _ref2[0];

  var scrollContainerWidth = useTableScrollContainerWidth();
  var tableScrollLeft = useTableScrollContainerScrollLeft();

  var _useRowIsSticky = useRowIsSticky(),
      isRowSticky = _useRowIsSticky[0],
      setIsSticky = _useRowIsSticky[1];

  var _useUpdateTableSelect = useUpdateTableSelectionContext(),
      forceUpdateTableSelection = _useUpdateTableSelect[1];

  var _useRowsClientHeight = useRowsClientHeight(),
      updateRowClientHeight = _useRowsClientHeight[1];

  var _useScrollableContain = useScrollableContainerRect(),
      scrollRect = _useScrollableContain[0],
      setScrollableContainerRect = _useScrollableContain[1];

  var tableScrollContainer = useTableScrollContainer();
  var shouldSticky = React.useMemo(function () {
    return shouldRowSticky(node, parent) && scrollContainer instanceof HTMLElement;
  }, [node, scrollContainer, parent]);
  var isSticky = shouldSticky && isRowSticky;
  var topOffset = isTableSelected ? STICKY_ROW_TOP_HEIGHT : 0;
  React.useEffect(function () {
    setTop(scrollRect.top + topOffset);
  }, [scrollRect.top, topOffset]);
  var shouldObserve = !readOnly || shouldSticky;
  var updateRowRenderHeight = React.useCallback(function (rect) {
    // table display: none 时高度为 0
    if (rect.height === 0) return;
    var stickyHeight = rect.height - BORDER_BOTTOM_WIDTH;
    var actualHeight = isSticky ? stickyHeight : rect.height;

    if (renderHeightRef.current !== actualHeight) {
      renderHeightRef.current = actualHeight;
      updateRowClientHeight(node.key, actualHeight);
      setClientHeight(actualHeight);
    }
  }, [node, updateRowClientHeight, isSticky]);
  useResizeObserver(shouldObserve ? rowDOMRef.current : null, updateRowRenderHeight);
  var prevZoomRef = React.useRef(zoom); // 触发缩放 resizeObserver 无法监听到变化

  React.useEffect(function () {
    if (!rowDOMRef.current || prevZoomRef.current === zoom) return;
    prevZoomRef.current = zoom;
    var rect = rowDOMRef.current.getBoundingClientRect();
    updateRowRenderHeight(rect);
  }, [zoom, updateRowRenderHeight]);
  var setTablePaddingTop = React.useCallback(function (paddingTop) {
    var _rowDOMRef$current, _rowDOMRef$current$pa;

    var tableDOM = (_rowDOMRef$current = rowDOMRef.current) == null ? void 0 : (_rowDOMRef$current$pa = _rowDOMRef$current.parentElement) == null ? void 0 : _rowDOMRef$current$pa.parentElement;
    if (!(tableDOM != null && tableDOM.parentElement)) return; // NOTE: 不能设置 marginTop，会导致文档意外滚动

    tableDOM.parentElement.style.paddingTop = paddingTop;
  }, []); // 组件销毁重置状态

  React.useEffect(function () {
    return function () {
      updateRowClientHeight(node.key, null);
      setIsSticky(false);
      setTablePaddingTop('0px');
    };
  }, []);
  React.useLayoutEffect(function () {
    if (!rowDOMRef.current || !shouldSticky) return; // IMPORTANT: 需要同时对首行设置 fixed 和对 table 父节点设置 paddingTop
    // 通过 DOM 操作来保障同时生效，避免文档跳动

    var rowPosition = isSticky ? 'fixed' : '';
    rowDOMRef.current.style.position = rowPosition;
    var toolbarSpace = readOnly ? 0 : TOOLBAR_ITEM_SIZE;
    var paddingTop = isSticky ? clientHeight + toolbarSpace + "px" : '0px';
    setTablePaddingTop(paddingTop);
  }, [isSticky, clientHeight, setTablePaddingTop, shouldSticky, readOnly]);
  var style = React.useMemo(function () {
    if (!isSticky) {
      return {
        height: height
      };
    }

    var gridTemplateColumns = [];
    node.nodes.forEach(function (n, i) {
      var _ref3 = n.data || {},
          _ref3$colSpan = _ref3.colSpan,
          colSpan = _ref3$colSpan === void 0 ? 1 : _ref3$colSpan,
          hidden = _ref3.hidden;

      if (hidden) return;

      if (colSpan === 1) {
        gridTemplateColumns.push(colsWidth[i]);
      } else {
        var colWidth = colsWidth.slice(i, i + colSpan).reduce(function (acc, w) {
          return acc + w;
        }, 0);
        gridTemplateColumns.push(colWidth);
      }
    });
    return {
      minHeight: height,
      top: top,
      // 通过 grid 模拟 table 布局
      display: 'grid',
      gridAutoFlow: 'column',
      gridTemplateColumns: gridTemplateColumns.map(function (c) {
        return c + "px";
      }).join(' '),
      width: scrollContainerWidth,
      overflowX: 'hidden',
      left: Number.isFinite(scrollRect.left) ? scrollRect.left - STICKY_MARGIN_LEFT : 'unset'
    };
  }, [colsWidth, height, isSticky, node, scrollContainerWidth, top, scrollRect.left]);
  React.useLayoutEffect(function () {
    if (isSticky && rowDOMRef.current) {
      rowDOMRef.current.scrollLeft = tableScrollLeft;
    }
  }, [tableScrollLeft, isSticky]);
  React.useLayoutEffect(function () {
    forceUpdateTableSelection();
  }, [isSticky, forceUpdateTableSelection]);
  var updateIsSticky = React.useCallback(function () {
    var _rowDOMRef$current2, _rowDOMRef$current2$p;

    var tableDOM = (_rowDOMRef$current2 = rowDOMRef.current) == null ? void 0 : (_rowDOMRef$current2$p = _rowDOMRef$current2.parentElement) == null ? void 0 : _rowDOMRef$current2$p.parentElement;
    if (!tableDOM || !tableScrollContainer) return;
    var tableScrollRect = tableScrollContainer.getBoundingClientRect();
    var containerRect = scrollContainer.getBoundingClientRect();
    var tableRect = tableDOM.getBoundingClientRect(); // height 为 0 说明是 display none 状态

    if (!rowDOMRef.current || tableRect.height === 0) {
      setIsSticky(false);
      return;
    }

    var rowRect = rowDOMRef.current.getBoundingClientRect();

    var _getBoundingClientRec = scrollContainer.getBoundingClientRect(),
        scrollHeight = _getBoundingClientRec.height;

    if (isSticky === false && (rowRect.height > tableRect.height / 2 || rowRect.height > scrollHeight / 3)) {
      return;
    }

    if (tableRect.bottom < containerRect.top + rowRect.height + topOffset) {
      setIsSticky(false);
      return;
    }

    var topSpace = isSticky ? rowRect.height : 0;

    if (tableRect.top - topSpace - topOffset > containerRect.top) {
      setIsSticky(false);
      return;
    }

    var relativeLeft = tableScrollRect.left - rowRect.left;

    if (prevRelativeLeftRef.current !== relativeLeft) {
      prevRelativeLeftRef.current = relativeLeft;
      setScrollableContainerRect(function (r) {
        return _extends({}, r, {
          left: tableScrollRect.left
        });
      });
    }

    setIsSticky(true);
    forceUpdateTableSelection();
  }, [forceUpdateTableSelection, isSticky, scrollContainer, setIsSticky, topOffset, tableScrollLeft, tableScrollContainer]);
  React.useEffect(function () {
    if (!shouldSticky) return function () {}; // NOTE: 不要设置 delay，可能会导致异常

    var handleScroll = throttle(function () {
      updateIsSticky();
    });
    scrollContainer.addEventListener('scroll', handleScroll);
    window.addEventListener('resize', handleScroll);
    return function () {
      scrollContainer.removeEventListener('scroll', handleScroll);
      window.removeEventListener('resize', handleScroll);
    };
  }, [updateIsSticky, scrollContainer, shouldSticky]);
  var stickyContext = React.useMemo(function () {
    return [shouldSticky && isSticky, noop];
  }, [shouldSticky, isSticky]);
  return /*#__PURE__*/_createElement(TR, _extends({}, attributes, {
    ref: function ref(n) {
      if (n) {
        if (!rowDOMRef.current) forceUpdate();
        rowDOMRef.current = n;
      }
    },
    style: style,
    "data-sticky": isSticky
  }), /*#__PURE__*/_createElement(RowIsStickyContext.Provider, {
    value: stickyContext
  }, children()));
};

export default TableRow;
//# sourceMappingURL=tableRow.js.map