import _extends from "@babel/runtime/helpers/extends";
import * as React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import styled, { css } from 'styled-components';
import { useStyle, SelectionSlot } from '@ali/4ever-cangjie';
import TableRow from "../mo/models/tableRow";
import { bdrToStyle, bdrToPaddingStyle, transformThemeObjToCssString, theme, blockMarginStyleInContainer } from '@ali/4ever-utils';
import getPositionOfCell from "../utils/utils/getPositionOfCell";
import isTable from "../utils/utils/isTable";
import { setTableMinColsWidthData } from "../utils/actions";
import { usePixelColsWidth, useRowIsSticky } from "../utils/hooks";
import getTabelCellFill from "../utils/utils/getTableCellFill";
import { ContainerWidthResizeContext } from "./ContainerWidthResizeContext";
import { DEFAULT_BORDER_COLOR } from "../utils/constants";
var tableCellStyle = theme['table-cell'];
var Td = /*#__PURE__*/styled.td(["", " border-width:1px;border-style:solid;border-color:", ";overflow:hidden;overflow-wrap:break-word;word-wrap:break-word;", ""], transformThemeObjToCssString(tableCellStyle), DEFAULT_BORDER_COLOR, css(["", ""], blockMarginStyleInContainer));
var DefaultPadding = {
  left: tableCellStyle['padding-left'],
  right: tableCellStyle['padding-right'],
  top: tableCellStyle['padding-top'],
  bottom: tableCellStyle['padding-bottom']
};

var vAlignToGridVAlign = function vAlignToGridVAlign(vAlign) {
  var defaultAlign = 'center';
  var map = {
    top: 'flex-start',
    middle: defaultAlign,
    bottom: 'flex-end'
  };
  return vAlign ? map[vAlign] : defaultAlign;
};

var Cell = function Cell(props) {
  var _useRowIsSticky = useRowIsSticky(),
      isSticky = _useRowIsSticky[0];

  var node = props.node,
      attributes = props.attributes,
      children = props.children,
      fill = props.fill,
      parent = props.parent;

  var _ref = node.data || {},
      vAlign = _ref.vAlign,
      bdr = _ref.bdr,
      hidden = _ref.hidden,
      _ref$rowSpan = _ref.rowSpan,
      rowSpan = _ref$rowSpan === void 0 ? 1 : _ref$rowSpan,
      cSpan = _ref.colSpan,
      cellMar = _ref.cellMar;

  var colSpan = parseInt(String(cSpan), 10) || 1;
  var style = React.useMemo(function () {
    var result = {};

    if (hidden) {
      result.display = 'none';
    } else if (isSticky) {
      // 设置 grid，保障在首行吸顶时，cell 的 vAlign 样式正常
      result.display = 'flex';
      result.flexDirection = 'column';
    }

    if (fill) {
      result.backgroundColor = fill;
    } // 首行吸顶时采用 grid 布局，verticalAlign 在 grid 布局中不生效，改为 justifyContent


    if (isSticky) {
      result.justifyContent = vAlignToGridVAlign(vAlign);
    } else if (vAlign) {
      result.verticalAlign = vAlign;
    }

    var padding = _extends({}, DefaultPadding);

    if (cellMar) {
      ['left', 'right', 'top', 'bottom'].forEach(function (orient) {
        var _cellMar$orient;

        if (typeof ((_cellMar$orient = cellMar[orient]) == null ? void 0 : _cellMar$orient.w) === 'number') {
          var _cellMar$orient2;

          padding[orient] = (_cellMar$orient2 = cellMar[orient]) == null ? void 0 : _cellMar$orient2.w;
        }
      });
    }

    if (typeof bdr === 'object') {
      result = _extends({}, result, bdrToStyle(bdr), bdrToPaddingStyle(bdr, padding));
    }

    return result;
  }, [hidden, isSticky, fill, vAlign, cellMar, bdr]);
  var isHeader = TableRow.isTableRow(parent) && TableRow.isHeader(parent);
  return /*#__PURE__*/_createElement(Td, _extends({}, attributes, {
    "data-type": "table-cell",
    rowSpan: rowSpan || 1,
    colSpan: colSpan,
    style: style,
    "data-container-block": true
  }), children(), isHeader && /*#__PURE__*/_createElement(SelectionSlot, {
    layerFor: node.key
  }));
};

var TableCell = function TableCell(props) {
  var node = props.node,
      controller = props.controller;

  var _ref2 = node.data || {},
      cSpan = _ref2.colSpan;

  var colSpan = parseInt(String(cSpan), 10) || 1;
  var document = controller.value.document;
  var table = document.getClosest(node.key, isTable);
  var docStyle = useStyle();
  var fill = getTabelCellFill(node, table, docStyle);
  var position = getPositionOfCell(node.key, table) || {}; // @ts-ignore

  var colIndex = position.colIndex,
      rowIndex = position.rowIndex;

  var _usePixelColsWidth = usePixelColsWidth(),
      colsWidth = _usePixelColsWidth[0];

  var width = React.useMemo(function () {
    var result = 0;

    if (typeof colIndex !== 'number') {
      return result;
    }

    if (Array.isArray(colsWidth)) {
      result = colsWidth.slice(colIndex, colIndex + colSpan).reduce(function (acc, v) {
        return acc + v;
      }, 0);
    }

    return result;
  }, [colsWidth, colIndex, colSpan]);
  var didMount = React.useRef(false);
  var resetTableMinColsWidth = React.useCallback(function () {
    node.forEachDescendant(function (n) {
      var colWidth = controller.query('getMinTableColWidth', {
        node: n
      });

      if (typeof colWidth === 'number' && width < colWidth) {
        var _setTableMinColsWidth;

        controller.run('onAction', setTableMinColsWidthData((_setTableMinColsWidth = {}, _setTableMinColsWidth[n.key] = colWidth, _setTableMinColsWidth)));
      }
    });
  }, [node]);
  React.useEffect(function () {
    // didMount 时不处理
    if (!didMount.current) {
      didMount.current = true;
      return;
    }

    resetTableMinColsWidth();
  }, [resetTableMinColsWidth]);
  var calcMinTableColWidth = React.useCallback(function () {
    if (!table || rowIndex !== 0) {
      return;
    }

    var res = controller.query('calcMinTableColWidth', {
      node: table,
      colIndex: colIndex
    });

    var _ref3 = res || {},
        key = _ref3.key,
        minColWidth = _ref3.width;

    if (key && typeof minColWidth === 'number' && width < minColWidth) {
      var _setTableMinColsWidth2;

      controller.run('onAction', setTableMinColsWidthData((_setTableMinColsWidth2 = {}, _setTableMinColsWidth2[key] = minColWidth, _setTableMinColsWidth2)));
    } // perf
    // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [width]);
  React.useEffect(calcMinTableColWidth, [calcMinTableColWidth]);
  return /*#__PURE__*/_createElement(ContainerWidthResizeContext.Provider, {
    value: width
  }, /*#__PURE__*/_createElement(Cell, _extends({}, props, {
    fill: fill
  })));
};

export default TableCell;
//# sourceMappingURL=tableCell.js.map