"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var React = _interopRequireWildcard(require("react"));

var _isHotkey = require("is-hotkey");

var _everCangjie = require("@ali/4ever-cangjie");

var _actions = require("../actions");

var _CodeInlineToolbar = _interopRequireDefault(require("./CodeInlineToolbar"));

var _everComponent = require("@ali/4ever-component");

var _store = require("../store");

var _CodeGlobalStyle = _interopRequireDefault(require("./CodeGlobalStyle"));

var _languages = require("../../utils/constants/languages");

var _themes = require("../../utils/constants/themes");

var _utils = _interopRequireDefault(require("../../components/Codemirror/utils"));

var _dimension = require("../../utils/constants/dimension");

var _LazyCodemirror = require("../../components/LazyCodemirror");

/* eslint-disable react/destructuring-assignment */
const _createElement = /*#__PURE__*/React.createElement;
const isFindHotKey = (0, _isHotkey.isKeyHotkey)('mod+f');
const {
  IS_FIREFOX
} = _everCangjie.environment;

function isAtStartOfCodeEditor(cm) {
  const cursor = cm.getCursor();
  return cursor.line === 0 && cursor.ch === 0;
}

const Pass = 'CodeMirror.Pass';

var _ref = /*#__PURE__*/_createElement(_CodeGlobalStyle.default, null);

const CodeEditor = props => {
  const {
    locale,
    controller,
    node,
    onSave = () => {},
    cursorPos = 'end',
    isSelected
  } = props;
  const {
    data
  } = node;
  const zoomContainer = (0, _everCangjie.useZoomContainer)() || document.body;
  const disableInlineToolbar = controller.query('hasHoverToolbar', 'code');
  const {
    id,
    syntax = _languages.DEFAULT_LANGUAGE,
    theme = _themes.DEFAULT_THEME,
    height,
    wrap = false,
    collabSelections = {}
  } = data;
  const cmRef = React.useRef(null);
  const wrapperRef = React.useRef(null);
  const controllerRef = React.useRef(controller);
  const nodeRef = React.useRef(node);
  const [isResizing, setIsResizing] = React.useState(false);
  const [draggingHeight, setDraggingHeight] = React.useState(() => (0, _utils.default)(node));
  const [lineHeight, setLineHeight] = React.useState(0);
  const scale = 1.0;
  const focus = React.useCallback(() => {
    (0, _store.setFocusState)(id, true);
    controllerRef.current.run('onAction', (0, _actions.focusToCodeEditor)(nodeRef.current));
  }, []);
  const backToTextEditor = React.useCallback(direction => {
    controllerRef.current.run('onAction', (0, _actions.focusToTextEditor)(nodeRef.current, direction));
    return undefined;
  }, []);
  const removeCodeEditor = React.useCallback(cm => {
    if (isAtStartOfCodeEditor(cm) && !cm.getValue().length) {
      controllerRef.current.run('onAction', (0, _actions.removeCode)(nodeRef.current));
      return undefined;
    }

    return Pass;
  }, []); // undo、redo

  const onHistory = React.useCallback(type => {
    controller.dispatch(type === 'undo' ? 'undo' : 'redo');
  }, [controller]);
  const options = React.useMemo(() => ({
    cursorBlinkRate: 530,
    extraKeys: {
      Backspace: removeCodeEditor,
      Left: cm => {
        if (isAtStartOfCodeEditor(cm)) {
          return backToTextEditor('left');
        }

        return Pass;
      },
      Up: cm => {
        if (cm.getCursor().line === 0) {
          return backToTextEditor('up');
        }

        return Pass;
      },
      Esc: () => backToTextEditor(),
      'Ctrl-S': () => {
        onSave();
      },
      'Cmd-S': () => {
        onSave();
      },
      'Ctrl-Z': () => {
        onHistory('undo');
      },
      'Shift-Ctrl-Z': () => {
        onHistory('redo');
      },
      'Cmd-Z': () => {
        onHistory('undo');
      },
      'Shift-Cmd-Z': () => {
        onHistory('redo');
      }
    }
  }), [backToTextEditor, removeCodeEditor, onSave, onHistory]);

  const isNullOrUndefined = dragHeight => {
    return dragHeight === null || dragHeight === undefined;
  };

  const setSize = React.useCallback(() => {
    if (isNullOrUndefined(height)) {
      const codeHeight = (0, _utils.default)(node);
      setDraggingHeight(codeHeight);
    }
  }, [height, node]);
  const handleBlur = React.useCallback(() => {
    (0, _store.setFocusState)(id, false);
    controllerRef.current.run('onAction', (0, _actions.blurCode)());
  }, []);
  const handleDidMount = React.useCallback(cm => {
    cmRef.current = cm; // 防止文档打开时，focus 到代码块

    const position = (0, _store.getFocusState)(id);

    if (position) {
      cm.focus();

      if (position !== true) {
        cm.setCursor(position);
      }

      focus();
    }

    setSize();
    const dragHeight = isNullOrUndefined(height) ? (0, _utils.default)(node) : height;
    setDraggingHeight(dragHeight);
    setLineHeight(cm.defaultTextHeight());
    cm.refresh();
  }, [id, setSize, height, focus]);
  const handleChange = React.useCallback((_editor, _changes, patches) => {
    controllerRef.current.run('onAction', (0, _actions.changeCode)({
      patches,
      node: nodeRef.current
    }));
  }, []);
  const handleGutterClick = React.useCallback((cm, line, gutter, event) => {
    event.preventDefault();
    event.stopPropagation();

    if (!cm.hasFocus()) {
      cm.focus();
    }

    cm.setCursor({
      line,
      ch: 0
    });
  }, []);
  const handleResize = React.useCallback((_, size) => {
    setDraggingHeight(size.height);
  }, []);
  const handleResizeStart = React.useCallback(() => {
    setIsResizing(true);
  }, []);
  const handleResizeStop = React.useCallback((_, size) => {
    setIsResizing(false);
    cmRef.current.focus();
    controllerRef.current.run('onAction', (0, _actions.changeCodeData)(nodeRef.current, {
      height: size.height
    }));
  }, []);
  const handleKeyDown = React.useCallback((_, event) => {
    /**
     * 对于部分组合键输入，执行stopPropagation后只是阻止往上冒泡，但并不会阻止浏览器默认行为，除非执行preventDefault。
     * 这里不做stopPropagation处理，交由外层查找替换插件来处理。
     */
    if (isFindHotKey(event)) {
      return;
    }

    event.stopPropagation();
  }, []); // 禁用右键菜单，防止弹出 cangjie menu

  const handleContextMenu = React.useCallback((cm, event) => {
    // @ts-ignore codemirror event
    event.codemirrorIgnore = true; // 默认代码块 contextmenu 拦截的话，会 blur，通过 delayingBlurEvent 标记阻拦这一行为。

    cm.state.delayingBlurEvent = false;
    event.preventDefault();
    event.stopPropagation();
  }, []);
  const handleResizeClick = React.useCallback(event => {
    event.stopPropagation();
  }, []);
  React.useEffect(() => {
    if (cmRef.current) {
      cmRef.current.refresh();
    }
  }, [scale]);
  React.useLayoutEffect(() => {
    if (!isNullOrUndefined(height)) {
      setDraggingHeight(height);
    }
  }, [height]);
  React.useEffect(() => {
    nodeRef.current = node;
    controllerRef.current = controller;
  }, [node, controller]);
  React.useEffect(() => {
    return () => {
      // 代码块无论何时被删除时，更新 focusCode ，解决新建代码块后光标在代码块里，再 undo focusCode 不更新的 bug
      controllerRef.current.run('onAction', (0, _actions.blurCode)());
      if (!cmRef.current || !cmRef.current.hasFocus()) return;
      const position = cmRef.current.getCursor();
      (0, _store.setFocusState)(id, position);
    };
  }, []); // 光标位置

  React.useEffect(() => {
    if (!cmRef.current?.hasFocus()) {
      return;
    }

    if (cursorPos === 'start') {
      cmRef.current?.execCommand('goDocStart');
    } else if (cursorPos === 'end') {
      cmRef.current?.execCommand('goDocEnd');
    } else {
      cmRef.current?.setCursor(cursorPos);
    }
  }, [cursorPos]); // node 变化时，重新计算高度

  React.useEffect(() => {
    if (cmRef.current) {
      setSize();
    }
  }, [node, setSize]);
  const widthRange = React.useMemo(() => [0, Infinity], []);
  const heightRange = React.useMemo(() => [lineHeight + _dimension.HEIGHT_PADDING, _dimension.MAX_HEIGHT], [lineHeight]);
  const isCodeFocused = isSelected && controller.value.selection.isCollapsed;
  const showResize = isResizing || isCodeFocused; // 解决从弹性变为 fixed 时，不出现 scrollBar 的问题。只有从弹性变为 fixed 才触发

  const autoHeight = isNullOrUndefined(height) && draggingHeight < _dimension.MAX_HEIGHT && !isResizing;
  const didMount = React.useRef(false);
  React.useEffect(() => {
    if (!didMount.current) {
      didMount.current = true;
      return;
    }

    if (!autoHeight) {
      cmRef.current?.refresh();
    }
  }, [autoHeight]); // FIREFOX 下，不进行放缩

  const commonStyle = {
    maxHeight: `${_dimension.MAX_HEIGHT}px`,
    // cm 未渲染时设置最小高度防止懒加载过程中高度剧烈抖动
    minHeight: cmRef.current ? undefined : draggingHeight
  };
  const resizableStyle = IS_FIREFOX ? {
    transform: `scale(${1.0 / scale})`,
    transformOrigin: 'top left',
    width: `${100 * scale}%`,
    ...commonStyle
  } : { ...commonStyle
  };
  const enableBorderHighlight = controller.query('enableBorderHighlight');
  return /*#__PURE__*/_createElement(_everComponent.Resizable, {
    innerRef: wrapperRef,
    axis: "y",
    width: Infinity,
    height: Math.min(draggingHeight || 0, _dimension.MAX_HEIGHT),
    widthRange: widthRange,
    heightRange: heightRange,
    onResize: handleResize,
    onResizeStart: handleResizeStart,
    onResizeStop: handleResizeStop,
    onClick: handleResizeClick,
    visible: showResize,
    style: resizableStyle,
    speed: IS_FIREFOX ? 1.0 : 1.0 / scale,
    zoomContainer: zoomContainer,
    handleStyle: theme === 'dracula' ? {
      color: 'rgba(255, 255, 255, 0.4)',
      backgroundColor: '#111F2C'
    } : {},
    autoHeight: autoHeight,
    isActive: isCodeFocused,
    enableBorderHighlight: enableBorderHighlight
  }, _ref, !disableInlineToolbar && isCodeFocused ? /*#__PURE__*/_createElement(_CodeInlineToolbar.default, {
    controller: controller,
    node: node,
    locale: locale,
    triggerNode: wrapperRef.current,
    focusedCodeKey: node.key
  }) : null, /*#__PURE__*/_createElement(_LazyCodemirror.CodeMirrorLazy, {
    value: node.text,
    options: options,
    syntax: syntax,
    theme: theme,
    wrap: wrap,
    onEditorMount: handleDidMount,
    onChanges: handleChange,
    onFocus: focus,
    onBlur: handleBlur,
    onGutterClick: handleGutterClick,
    onKeyDown: handleKeyDown,
    onContextMenu: handleContextMenu,
    scale: scale,
    collabSelections: collabSelections,
    placeholder: locale.placeholder,
    controller: controller,
    node: node
  }));
};

var _default = CodeEditor;
exports.default = _default;
//# sourceMappingURL=CodeEditor.js.map