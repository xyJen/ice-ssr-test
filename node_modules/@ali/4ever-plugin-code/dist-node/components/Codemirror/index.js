"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var React = _interopRequireWildcard(require("react"));

var _codemirror = _interopRequireDefault(require("codemirror"));

require("codemirror/addon/scroll/simplescrollbars.js");

require("codemirror/addon/edit/closebrackets.js");

require("codemirror/addon/display/placeholder.js");

require("codemirror/addon/search/searchcursor.js");

var _lodash = require("lodash");

var _everCangjie = require("@ali/4ever-cangjie");

var _everLogger = _interopRequireDefault(require("@ali/4ever-logger"));

var _styled = require("./styled");

var _diffMatch = require("./diffMatch");

var _languages = require("../../utils/constants/languages");

var _languageLoader = require("./languageLoader");

/* eslint-disable no-unused-expressions */
const _createElement = /*#__PURE__*/React.createElement;
const BASE_OPTIONS = {
  lineNumbers: true,
  tabSize: 2,
  scrollbarStyle: 'overlay',
  autoCloseBrackets: true,
  undoDepth: 0
};

const useEventEffect = (editor, eventName, callback) => {
  const callbackRef = React.useRef(callback);
  React.useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);
  React.useEffect(() => {
    if (editor) {
      const handleEvent = (...params) => {
        callbackRef.current(...params);
      };

      editor.on(eventName, handleEvent);
      return () => editor.off(eventName, handleEvent);
    }

    return () => {};
  }, [eventName, editor]);
};

const VALUE_UPDATE_BY_PROPS_CHANGE = '__VALUE_UPDATE_BY_PROPS_CHANGE__';
let prevSelectedIndex = -1;
let prevFindText = '';
const FIND_NAME = 'find-and-replace';
const FIND_SELECTED_NAME = 'find-and-replace-selected';
const COLLAB_SELECTION_NAME = 'collab-selection';
const CodeMirror = /*#__PURE__*/React.forwardRef((props, forwardRef) => {
  const {
    value,
    onEditorMount = _lodash.noop,
    className = '',
    options,
    syntax,
    theme,
    wrap = false,
    scale = 1.0,
    style,
    onChanges = _lodash.noop,
    onBlur = _lodash.noop,
    onFocus = _lodash.noop,
    onGutterClick = _lodash.noop,
    onMouseDown = _lodash.noop,
    onDBClick = _lodash.noop,
    onTouchStart = _lodash.noop,
    onKeyDown = _lodash.noop,
    onContextMenu = _lodash.noop,
    onCopy = _lodash.noop,
    onBeforeSelectionChange = _lodash.noop,
    collabSelections,
    placeholder,
    print = false,
    controller,
    node
  } = props;
  const ref = React.useRef(null);
  const [editor, setEditor] = React.useState(null); // 用于标记当前是否由 onChange 触发导致 value 变化(非受控 => 受控)，此时 value 应该与 editor value 一致，防御性目的，防止无限循环

  const isLocalChange = React.useRef(false);
  React.useEffect(() => {
    if (editor === null) {
      const instance = (0, _codemirror.default)(ref.current, { ...BASE_OPTIONS,
        ...options,
        fixedGutter: false,
        value,
        // force not use textarea due to zoom mode
        inputStyle: options?.readOnly ? 'contenteditable' : 'textarea',
        placeholder,
        viewportMargin: print ? Infinity : 10,
        readOnly: options?.readOnly ? 'nocursor' : false
      }); // 阻止移动端的事件冒泡到 slate-editor

      onEditorMount(instance);
      setEditor(instance);
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [onEditorMount, editor, value, print]);
  React.useEffect(() => {
    if (typeof forwardRef === 'function') {
      forwardRef(ref.current);
    } else if (forwardRef) {
      forwardRef.current = ref.current;
    }
  }, [ref, forwardRef]);
  const onEditorBlur = React.useCallback((cm, evt) => {
    onBeforeSelectionChange(cm, {
      ranges: [],
      origin: 'blur'
    });
    onBlur(cm, evt);
  }, [onBlur, onBeforeSelectionChange]);
  const onEditorChanges = React.useCallback((e, changes) => {
    const isValueUpdatedByProps = changes.every(change => change.origin === VALUE_UPDATE_BY_PROPS_CHANGE);

    if (isValueUpdatedByProps) {
      return;
    }

    isLocalChange.current = true;
    const patches = (0, _diffMatch.diffsToPatchs)(value, e.getValue());
    onChanges(e, changes, patches);
  }, [value, onChanges]);
  const zoom = (0, _everCangjie.useZoom)();
  useEventEffect(editor, 'changes', onEditorChanges);
  useEventEffect(editor, 'focus', onFocus);
  useEventEffect(editor, 'blur', onEditorBlur);
  useEventEffect(editor, 'gutterClick', onGutterClick);
  useEventEffect(editor, 'mousedown', onMouseDown);
  useEventEffect(editor, 'dblclick', onDBClick);
  useEventEffect(editor, 'touchstart', onTouchStart);
  useEventEffect(editor, 'keydown', onKeyDown);
  useEventEffect(editor, 'contextmenu', onContextMenu);
  useEventEffect(editor, 'copy', onCopy);
  useEventEffect(editor, 'beforeSelectionChange', onBeforeSelectionChange); // init

  React.useLayoutEffect(() => {
    if (editor) {
      const oldValue = editor.getValue();

      if (isLocalChange.current) {
        isLocalChange.current = false; // 防御措施，理论上不会走这段逻辑

        if (value !== oldValue) {
          console.error('EditorChange 转化为文字 Op 有逻辑缺陷，请检查');

          _everLogger.default.sum('CodeInvalidChangeToOp');

          return;
        }
      }

      if (value !== oldValue) {
        const patches = (0, _diffMatch.diffsToPatchs)(oldValue, value);

        for (const patch of patches) {
          const isInsert = patch.type === 'insert';
          const from = editor.posFromIndex(patch.offset);
          const to = isInsert ? undefined : editor.posFromIndex(patch.offset + patch.value.length);
          const replacement = isInsert ? patch.value : '';
          editor.replaceRange(replacement, from, to, VALUE_UPDATE_BY_PROPS_CHANGE);
        }
      }
    }
  }, [value, editor]); // when zoom change, update fresh height

  React.useEffect(() => {
    editor?.refresh(); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [zoom]);
  const languages = React.useMemo(() => (0, _languages.createCodeLanguages)(), []); // model 里有的 syntax 是不标准的(比如语雀拷贝)，这里先做一层处理

  const newSyntax = React.useMemo(() => {
    const s = `${syntax}`.toLowerCase();
    const match = languages.find(lang => [lang.key.toLowerCase(), lang.title.toLowerCase(), ...(lang.alias?.map(a => a.toLowerCase()) || [])].includes(s));
    return match?.key || syntax;
  }, [syntax, languages]); // language mode 为异步加载，通过 ref 标记当前的 syntax

  const curSyntaxRef = React.useRef(newSyntax);
  curSyntaxRef.current = newSyntax;
  React.useEffect(() => {
    (0, _languageLoader.loadLanguageMode)(newSyntax).then(l => {
      if (l === curSyntaxRef.current) {
        editor?.setOption('mode', newSyntax);
      }
    }).catch(() => {});
  }, [newSyntax, editor]); // 避免闪烁

  React.useLayoutEffect(() => {
    editor && editor.setOption('theme', theme);
  }, [theme, editor]);
  const clearMarkHasClassNames = React.useCallback(classNames => {
    editor?.getAllMarks().forEach(marker => {
      // @ts-ignore codemirror type error
      if (classNames.includes(marker.className)) {
        marker.clear();
      }
    });
  }, [editor]);
  React.useEffect(() => {
    editor && editor.setOption('lineWrapping', wrap || print);
  }, [wrap, editor, print]); // collabSelections 变化时，重新绘制协同 selection

  React.useEffect(() => {
    clearMarkHasClassNames([COLLAB_SELECTION_NAME]); // eslint-disable-next-line guard-for-in

    for (const uid in collabSelections) {
      const selection = collabSelections[uid];

      for (const range of selection.ranges) {
        editor?.markText(range.anchor, range.head, {
          className: 'collab-selection'
        });
      }
    }
  }, [collabSelections, editor]); // 设置查找替换高亮

  React.useEffect(() => {
    if (!editor || !controller) {
      return;
    }

    const {
      findText = '',
      findAndReplaceVisible
    } = controller.value.data;

    if (!findAndReplaceVisible) {
      clearMarkHasClassNames([FIND_NAME, FIND_SELECTED_NAME]);
      return;
    }

    if (findText !== prevFindText) {
      prevSelectedIndex = -1;
    }

    const {
      decorations,
      document
    } = controller.query('getDataValue') || controller.value;
    const selfDecorations = decorations.filter(d => {
      const {
        key
      } = d.start;
      const closestBlock = document.getClosestBlock(key);
      return closestBlock?.key === node?.key;
    });
    clearMarkHasClassNames([FIND_NAME, FIND_SELECTED_NAME]);
    const selectedIndex = selfDecorations.findIndex(({
      mark
    }) => mark.data.selected); // @ts-ignore searchcursor.js 注入了该方法

    const searchCursor = editor.getSearchCursor(findText, {
      line: 0,
      ch: 0
    }, true);
    let index = 0;
    let targetPosition = null;

    while (searchCursor.findNext()) {
      const selected = index === selectedIndex;
      const from = searchCursor.from();
      const to = searchCursor.to(); // eslint-disable-next-line @typescript-eslint/no-shadow

      const className = selected ? FIND_SELECTED_NAME : FIND_NAME;
      editor.markText(from, to, {
        className
      });

      if (selected) {
        targetPosition = {
          line: from.line,
          ch: to.ch
        };
      }

      index++;
    }

    if (targetPosition && prevSelectedIndex !== selectedIndex) {
      editor.setCursor(targetPosition);
    }

    prevSelectedIndex = selectedIndex;
    prevFindText = findText;
  }, [clearMarkHasClassNames, controller, editor, node]);
  return /*#__PURE__*/_createElement(_styled.Wrapper, {
    style: style,
    print: print,
    theme: theme,
    className: !_everCangjie.environment.IS_FIREFOX ? `scaled ${className}` : className,
    ref: ref,
    scale: scale,
    zoom: zoom,
    readOnly: options?.readOnly
  });
});

var _default = /*#__PURE__*/React.memo(CodeMirror);

exports.default = _default;
//# sourceMappingURL=index.js.map