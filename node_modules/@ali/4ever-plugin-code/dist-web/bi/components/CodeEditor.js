import _extends from "@babel/runtime/helpers/extends";

/* eslint-disable react/destructuring-assignment */
import * as React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import { isKeyHotkey } from 'is-hotkey';
import { environment, useZoomContainer } from '@ali/4ever-cangjie';
import { changeCode, focusToCodeEditor, focusToTextEditor, removeCode, changeCodeData, blurCode } from "../actions";
import CodeInlineToolbar from "./CodeInlineToolbar";
import { Resizable } from '@ali/4ever-component';
import { getFocusState, setFocusState } from "../store";
import CodeGlobalStyle from "./CodeGlobalStyle";
import { DEFAULT_LANGUAGE } from "../../utils/constants/languages";
import { DEFAULT_THEME } from "../../utils/constants/themes";
import getCodeHeight from "../../components/Codemirror/utils";
import { HEIGHT_PADDING, MAX_HEIGHT } from "../../utils/constants/dimension";
import { CodeMirrorLazy } from "../../components/LazyCodemirror";
var isFindHotKey = isKeyHotkey('mod+f');
var IS_FIREFOX = environment.IS_FIREFOX;

function isAtStartOfCodeEditor(cm) {
  var cursor = cm.getCursor();
  return cursor.line === 0 && cursor.ch === 0;
}

var Pass = 'CodeMirror.Pass';

var _ref = /*#__PURE__*/_createElement(CodeGlobalStyle, null);

var CodeEditor = function CodeEditor(props) {
  var locale = props.locale,
      controller = props.controller,
      node = props.node,
      _props$onSave = props.onSave,
      onSave = _props$onSave === void 0 ? function () {} : _props$onSave,
      _props$cursorPos = props.cursorPos,
      cursorPos = _props$cursorPos === void 0 ? 'end' : _props$cursorPos,
      isSelected = props.isSelected;
  var data = node.data;
  var zoomContainer = useZoomContainer() || document.body;
  var disableInlineToolbar = controller.query('hasHoverToolbar', 'code');
  var id = data.id,
      _data$syntax = data.syntax,
      syntax = _data$syntax === void 0 ? DEFAULT_LANGUAGE : _data$syntax,
      _data$theme = data.theme,
      theme = _data$theme === void 0 ? DEFAULT_THEME : _data$theme,
      height = data.height,
      _data$wrap = data.wrap,
      wrap = _data$wrap === void 0 ? false : _data$wrap,
      _data$collabSelection = data.collabSelections,
      collabSelections = _data$collabSelection === void 0 ? {} : _data$collabSelection;
  var cmRef = React.useRef(null);
  var wrapperRef = React.useRef(null);
  var controllerRef = React.useRef(controller);
  var nodeRef = React.useRef(node);

  var _React$useState = React.useState(false),
      isResizing = _React$useState[0],
      setIsResizing = _React$useState[1];

  var _React$useState2 = React.useState(function () {
    return getCodeHeight(node);
  }),
      draggingHeight = _React$useState2[0],
      setDraggingHeight = _React$useState2[1];

  var _React$useState3 = React.useState(0),
      lineHeight = _React$useState3[0],
      setLineHeight = _React$useState3[1];

  var scale = 1.0;
  var focus = React.useCallback(function () {
    setFocusState(id, true);
    controllerRef.current.run('onAction', focusToCodeEditor(nodeRef.current));
  }, []);
  var backToTextEditor = React.useCallback(function (direction) {
    controllerRef.current.run('onAction', focusToTextEditor(nodeRef.current, direction));
    return undefined;
  }, []);
  var removeCodeEditor = React.useCallback(function (cm) {
    if (isAtStartOfCodeEditor(cm) && !cm.getValue().length) {
      controllerRef.current.run('onAction', removeCode(nodeRef.current));
      return undefined;
    }

    return Pass;
  }, []); // undo、redo

  var onHistory = React.useCallback(function (type) {
    controller.dispatch(type === 'undo' ? 'undo' : 'redo');
  }, [controller]);
  var options = React.useMemo(function () {
    return {
      cursorBlinkRate: 530,
      extraKeys: {
        Backspace: removeCodeEditor,
        Left: function Left(cm) {
          if (isAtStartOfCodeEditor(cm)) {
            return backToTextEditor('left');
          }

          return Pass;
        },
        Up: function Up(cm) {
          if (cm.getCursor().line === 0) {
            return backToTextEditor('up');
          }

          return Pass;
        },
        Esc: function Esc() {
          return backToTextEditor();
        },
        'Ctrl-S': function CtrlS() {
          onSave();
        },
        'Cmd-S': function CmdS() {
          onSave();
        },
        'Ctrl-Z': function CtrlZ() {
          onHistory('undo');
        },
        'Shift-Ctrl-Z': function ShiftCtrlZ() {
          onHistory('redo');
        },
        'Cmd-Z': function CmdZ() {
          onHistory('undo');
        },
        'Shift-Cmd-Z': function ShiftCmdZ() {
          onHistory('redo');
        }
      }
    };
  }, [backToTextEditor, removeCodeEditor, onSave, onHistory]);

  var isNullOrUndefined = function isNullOrUndefined(dragHeight) {
    return dragHeight === null || dragHeight === undefined;
  };

  var setSize = React.useCallback(function () {
    if (isNullOrUndefined(height)) {
      var codeHeight = getCodeHeight(node);
      setDraggingHeight(codeHeight);
    }
  }, [height, node]);
  var handleBlur = React.useCallback(function () {
    setFocusState(id, false);
    controllerRef.current.run('onAction', blurCode());
  }, []);
  var handleDidMount = React.useCallback(function (cm) {
    cmRef.current = cm; // 防止文档打开时，focus 到代码块

    var position = getFocusState(id);

    if (position) {
      cm.focus();

      if (position !== true) {
        cm.setCursor(position);
      }

      focus();
    }

    setSize();
    var dragHeight = isNullOrUndefined(height) ? getCodeHeight(node) : height;
    setDraggingHeight(dragHeight);
    setLineHeight(cm.defaultTextHeight());
    cm.refresh();
  }, [id, setSize, height, focus]);
  var handleChange = React.useCallback(function (_editor, _changes, patches) {
    controllerRef.current.run('onAction', changeCode({
      patches: patches,
      node: nodeRef.current
    }));
  }, []);
  var handleGutterClick = React.useCallback(function (cm, line, gutter, event) {
    event.preventDefault();
    event.stopPropagation();

    if (!cm.hasFocus()) {
      cm.focus();
    }

    cm.setCursor({
      line: line,
      ch: 0
    });
  }, []);
  var handleResize = React.useCallback(function (_, size) {
    setDraggingHeight(size.height);
  }, []);
  var handleResizeStart = React.useCallback(function () {
    setIsResizing(true);
  }, []);
  var handleResizeStop = React.useCallback(function (_, size) {
    setIsResizing(false);
    cmRef.current.focus();
    controllerRef.current.run('onAction', changeCodeData(nodeRef.current, {
      height: size.height
    }));
  }, []);
  var handleKeyDown = React.useCallback(function (_, event) {
    /**
     * 对于部分组合键输入，执行stopPropagation后只是阻止往上冒泡，但并不会阻止浏览器默认行为，除非执行preventDefault。
     * 这里不做stopPropagation处理，交由外层查找替换插件来处理。
     */
    if (isFindHotKey(event)) {
      return;
    }

    event.stopPropagation();
  }, []); // 禁用右键菜单，防止弹出 cangjie menu

  var handleContextMenu = React.useCallback(function (cm, event) {
    // @ts-ignore codemirror event
    event.codemirrorIgnore = true; // 默认代码块 contextmenu 拦截的话，会 blur，通过 delayingBlurEvent 标记阻拦这一行为。

    cm.state.delayingBlurEvent = false;
    event.preventDefault();
    event.stopPropagation();
  }, []);
  var handleResizeClick = React.useCallback(function (event) {
    event.stopPropagation();
  }, []);
  React.useEffect(function () {
    if (cmRef.current) {
      cmRef.current.refresh();
    }
  }, [scale]);
  React.useLayoutEffect(function () {
    if (!isNullOrUndefined(height)) {
      setDraggingHeight(height);
    }
  }, [height]);
  React.useEffect(function () {
    nodeRef.current = node;
    controllerRef.current = controller;
  }, [node, controller]);
  React.useEffect(function () {
    return function () {
      // 代码块无论何时被删除时，更新 focusCode ，解决新建代码块后光标在代码块里，再 undo focusCode 不更新的 bug
      controllerRef.current.run('onAction', blurCode());
      if (!cmRef.current || !cmRef.current.hasFocus()) return;
      var position = cmRef.current.getCursor();
      setFocusState(id, position);
    };
  }, []); // 光标位置

  React.useEffect(function () {
    var _cmRef$current;

    if (!((_cmRef$current = cmRef.current) != null && _cmRef$current.hasFocus())) {
      return;
    }

    if (cursorPos === 'start') {
      var _cmRef$current2;

      (_cmRef$current2 = cmRef.current) == null ? void 0 : _cmRef$current2.execCommand('goDocStart');
    } else if (cursorPos === 'end') {
      var _cmRef$current3;

      (_cmRef$current3 = cmRef.current) == null ? void 0 : _cmRef$current3.execCommand('goDocEnd');
    } else {
      var _cmRef$current4;

      (_cmRef$current4 = cmRef.current) == null ? void 0 : _cmRef$current4.setCursor(cursorPos);
    }
  }, [cursorPos]); // node 变化时，重新计算高度

  React.useEffect(function () {
    if (cmRef.current) {
      setSize();
    }
  }, [node, setSize]);
  var widthRange = React.useMemo(function () {
    return [0, Infinity];
  }, []);
  var heightRange = React.useMemo(function () {
    return [lineHeight + HEIGHT_PADDING, MAX_HEIGHT];
  }, [lineHeight]);
  var isCodeFocused = isSelected && controller.value.selection.isCollapsed;
  var showResize = isResizing || isCodeFocused; // 解决从弹性变为 fixed 时，不出现 scrollBar 的问题。只有从弹性变为 fixed 才触发

  var autoHeight = isNullOrUndefined(height) && draggingHeight < MAX_HEIGHT && !isResizing;
  var didMount = React.useRef(false);
  React.useEffect(function () {
    if (!didMount.current) {
      didMount.current = true;
      return;
    }

    if (!autoHeight) {
      var _cmRef$current5;

      (_cmRef$current5 = cmRef.current) == null ? void 0 : _cmRef$current5.refresh();
    }
  }, [autoHeight]); // FIREFOX 下，不进行放缩

  var commonStyle = {
    maxHeight: MAX_HEIGHT + "px",
    // cm 未渲染时设置最小高度防止懒加载过程中高度剧烈抖动
    minHeight: cmRef.current ? undefined : draggingHeight
  };
  var resizableStyle = IS_FIREFOX ? _extends({
    transform: "scale(" + 1.0 / scale + ")",
    transformOrigin: 'top left',
    width: 100 * scale + "%"
  }, commonStyle) : _extends({}, commonStyle);
  var enableBorderHighlight = controller.query('enableBorderHighlight');
  return /*#__PURE__*/_createElement(Resizable, {
    innerRef: wrapperRef,
    axis: "y",
    width: Infinity,
    height: Math.min(draggingHeight || 0, MAX_HEIGHT),
    widthRange: widthRange,
    heightRange: heightRange,
    onResize: handleResize,
    onResizeStart: handleResizeStart,
    onResizeStop: handleResizeStop,
    onClick: handleResizeClick,
    visible: showResize,
    style: resizableStyle,
    speed: IS_FIREFOX ? 1.0 : 1.0 / scale,
    zoomContainer: zoomContainer,
    handleStyle: theme === 'dracula' ? {
      color: 'rgba(255, 255, 255, 0.4)',
      backgroundColor: '#111F2C'
    } : {},
    autoHeight: autoHeight,
    isActive: isCodeFocused,
    enableBorderHighlight: enableBorderHighlight
  }, _ref, !disableInlineToolbar && isCodeFocused ? /*#__PURE__*/_createElement(CodeInlineToolbar, {
    controller: controller,
    node: node,
    locale: locale,
    triggerNode: wrapperRef.current,
    focusedCodeKey: node.key
  }) : null, /*#__PURE__*/_createElement(CodeMirrorLazy, {
    value: node.text,
    options: options,
    syntax: syntax,
    theme: theme,
    wrap: wrap,
    onEditorMount: handleDidMount,
    onChanges: handleChange,
    onFocus: focus,
    onBlur: handleBlur,
    onGutterClick: handleGutterClick,
    onKeyDown: handleKeyDown,
    onContextMenu: handleContextMenu,
    scale: scale,
    collabSelections: collabSelections,
    placeholder: locale.placeholder,
    controller: controller,
    node: node
  }));
};

export default CodeEditor;
//# sourceMappingURL=CodeEditor.js.map