import React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import styled from 'styled-components';
import { Select, Tooltip } from '@ali/we-design-next';
import { constants } from '@ali/4ever-cangjie';
import { HoverToolbarHooks } from '@ali/4ever-component';
import { createCodeLanguages, DEFAULT_LANGUAGE } from "../../../utils/constants/languages";
import getCurrentCode from "../../queries/getCurrentCode";
import ToolbarLanguageSelectOld from "../LanguageSelect";
import { changeCodeData } from "../../actions";
var Selector = constants.Selector;
var WrapSelect = /*#__PURE__*/styled(Select)(["& .wdn-select-normal,&  .wdn-select-input{height:28px;background:transparent;&:hover{background:rgba(25,31,37,0.08)};}input{background:transparent;}span:not(.wdn-toolbar-select-value){margin:0;svg{transition:transform 500ms;transform:rotate(0deg);width:8px;height:8px;}}width:110px;"]);
export var ToolbarLanguageSelect = function ToolbarLanguageSelect(props) {
  var _code$data;

  var onOverlayVisibleChange = props.onOverlayVisibleChange,
      controller = props.controller,
      focusedCodeKey = props.focusedCodeKey,
      locale = props.locale;
  var getContainer = HoverToolbarHooks.useGetContainer();

  var _HoverToolbarHooks$us = HoverToolbarHooks.usePopoverVisible('code.language', onOverlayVisibleChange),
      isOverlayVisible = _HoverToolbarHooks$us[0],
      setOverlayVisible = _HoverToolbarHooks$us[1];

  var code = getCurrentCode(controller.value, focusedCodeKey);

  var _React$useState = React.useState((code == null ? void 0 : (_code$data = code.data) == null ? void 0 : _code$data.syntax) || DEFAULT_LANGUAGE),
      currentValue = _React$useState[0],
      setValue = _React$useState[1]; // const list = React.useMemo(() => createCodeLanguages(), []);


  var handleChange = React.useCallback(function (syntax) {
    var codeBlock = getCurrentCode(controller.value, focusedCodeKey);

    if (codeBlock) {
      setValue(syntax);
      controller.run('onAction', changeCodeData(codeBlock, {
        syntax: syntax
      }));
    }
  }, [controller, focusedCodeKey, setValue]);
  var languages = React.useMemo(function () {
    return createCodeLanguages();
  }, []);
  var filterOptions = React.useCallback(function (search, option) {
    var _props;

    return ("" + ((_props = option.props) == null ? void 0 : _props.children)).toLowerCase().includes(search.toLowerCase());
  }, []);
  var inputTriggerText = React.useCallback(function (value) {
    var _languages$find;

    var lang = ((_languages$find = languages.find(function (l) {
      return l.key === value;
    })) == null ? void 0 : _languages$find.title) || value;
    return lang;
  }, [languages]);
  return /*#__PURE__*/_createElement(Tooltip, {
    title: locale.languageTitle,
    placement: "bottom",
    getContainer: getContainer
  }, /*#__PURE__*/_createElement(ToolbarLanguageSelectOld, {
    locale: locale,
    value: code ? code.data.syntax : DEFAULT_LANGUAGE,
    onChange: handleChange,
    tip: locale.languageTitle,
    showArrow: true,
    style: {
      width: '110px'
    },
    filterOption: filterOptions,
    inputTriggerText: inputTriggerText,
    visible: isOverlayVisible,
    onVisibleChange: setOverlayVisible
  }));
};
//# sourceMappingURL=ToolbarLanguageSelect.js.map