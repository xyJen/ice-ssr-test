'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _defineProperty = _interopDefault(require('@babel/runtime/helpers/defineProperty'));

const IS_IOS = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent) // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
// @ts-ignore
&& !window.MSStream;
const IS_BROWSER = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';
const IS_SAFARI = typeof navigator !== 'undefined' && navigator.vendor === 'Apple Computer, Inc.';
const MIME_TYPES = {
  HTML: 'text/html',
  TEXT: 'text/plain'
}; // match \s string.

const NONEMPTY_REG = /^\s+$/;

function createHiddenTextarea() {
  const isRTL = document.documentElement.getAttribute('dir') === 'rtl';
  const fakeElem = document.createElement(IS_IOS ? 'div' : 'textarea');

  if (IS_IOS) {
    fakeElem.setAttribute('style', '-webkit-user-select: text !important');
  } // Prevent zooming on iOS


  fakeElem.style.fontSize = '12pt'; // Reset box model

  fakeElem.style.border = '0';
  fakeElem.style.padding = '0';
  fakeElem.style.margin = '0'; // Move element out of screen horizontally

  fakeElem.style.position = 'absolute';
  fakeElem.style[isRTL ? 'right' : 'left'] = '-9999px'; // Move element to the same position vertically

  const yPosition = window.pageYOffset || document.documentElement.scrollTop;
  fakeElem.style.top = `${yPosition}px`;
  return fakeElem;
}

function select(element) {
  let selectedText;

  if (IS_IOS || element instanceof HTMLDivElement) {
    /**
     *  兼容至 ios 10 以上
     *  https://stackoverflow.com/questions/34045777/copy-to-clipboard-using-javascript-in-ios
     * */
    const selection = window.getSelection();
    const range = document.createRange(); // There must be html content to trigger copy event.

    if (!element.innerHTML) {
      element.innerHTML = '<div>123</div>';
    }

    range.selectNodeContents(element); // eslint-disable-next-line no-unused-expressions

    selection?.removeAllRanges(); // eslint-disable-next-line no-unused-expressions

    selection?.addRange(range);
    return '';
  }

  if (element.nodeName === 'SELECT') {
    element.focus();
    selectedText = element.value;
  } else if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {
    const isReadOnly = element.hasAttribute('readonly');

    if (!isReadOnly) {
      element.setAttribute('readonly', '');
    }

    if ('select' in element) {
      element.select();
    }

    if ('setSelectionRange' in element) {
      // eslint-disable-next-line no-unused-expressions
      element?.setSelectionRange(0, element.value.length);
    }

    if (!isReadOnly) {
      element.removeAttribute('readonly');
    }

    selectedText = element.value;
  } else {
    if (element.hasAttribute('contenteditable')) {
      element.focus();
    }

    const selection = window.getSelection();
    const range = document.createRange();
    range.selectNodeContents(element); // eslint-disable-next-line no-unused-expressions

    selection?.removeAllRanges(); // eslint-disable-next-line no-unused-expressions

    selection?.addRange(range);
    selectedText = selection?.toString();
  }

  return selectedText || '';
}

let canvas;
let ctx;
/**
 * @description Clear canvas memory.
 */

function clearCanvas() {
  if (canvas) {
    canvas.width = 0;
    canvas.height = 0;
  }
}
/**
 * @description Only support image type.
 */


function isFileMimeType(mimeType) {
  return /^(image)\//.test(mimeType);
}
/**
 * @description Transform media url to blob
 */

function urlToBlob(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.setAttribute('crossOrigin', 'anonymous');

    img.onload = () => {
      if (!canvas || !ctx) {
        canvas = document.createElement('canvas');
        ctx = canvas.getContext('2d');
      }

      canvas.width = img.naturalWidth;
      canvas.height = img.naturalHeight;

      if (ctx) {
        ctx.drawImage(img, 0, 0);
        canvas.toBlob(blob => {
          if (blob) {
            resolve(blob);
          }

          clearCanvas();
        }, 'image/png');
      } else {
        reject(new Error("canvas.getContext('2d') return null"));
        clearCanvas();
      }
    };

    img.onerror = e => {
      reject(e);
      clearCanvas();
    };

    img.src = url;
  });
}

async function fileDataToBlob(fileData) {
  if (fileData instanceof Blob) {
    return Promise.resolve(fileData);
  }

  const blob = await urlToBlob(fileData);
  return blob;
}
/**
 * @description Support for multiple ClipboardItems is not implemented.
 * @see https://source.chromium.org/chromium/chromium/src/+/master:ui/base/clipboard/scoped_clipboard_writer.cc;l=22?q=~ScopedClipboardWriter
 */


async function asyncClipboardDataToBlob(writeData) {
  const result = {};

  for await (const key of Object.keys(writeData)) {
    if (isFileMimeType(key)) {
      // DOMException: Type image/jpeg not supported on write.
      result['image/png'] = await fileDataToBlob(writeData[key]);
    } else if ([MIME_TYPES.HTML, MIME_TYPES.TEXT].includes(key)) {
      result[key] = new Blob([writeData[key]], {
        type: key
      });
    } else {
      console.warn('Support for multiple ClipboardItems is not implemented.(details: https://source.chromium.org/chromium/chromium/src/+/master:ui/base/clipboard/scoped_clipboard_writer.cc;l=22?q=~ScopedClipboardWriter)');
    }
  }

  return result;
}
/**
 * @description Compatible with safari.
 * @see https://stackoverflow.com/questions/66312944/javascript-clipboard-api-write-does-not-work-in-safari
 */


function syncClipboardDataToBlob(writeData) {
  const result = {};

  for (const key of Object.keys(writeData)) {
    if (isFileMimeType(key)) {
      // DOMException: Type image/jpeg not supported on write.
      result['image/png'] = fileDataToBlob(writeData[key]);
    } else if ([MIME_TYPES.HTML, MIME_TYPES.TEXT].includes(key)) {
      result[key] = new Blob([writeData[key]], {
        type: key
      });
    } else {
      console.warn('Support for multiple ClipboardItems is not implemented.(details: https://source.chromium.org/chromium/chromium/src/+/master:ui/base/clipboard/scoped_clipboard_writer.cc;l=22?q=~ScopedClipboardWriter)');
    }
  }

  return result;
}

const isInValidData = data => !data || NONEMPTY_REG.test(data);
function isSupportWriteFile() {
  const nav = window.navigator; // eslint-disable-next-line no-param-reassign

  const ClipboardItem = window?.ClipboardItem;
  return nav?.clipboard?.write && !ClipboardItem;
}
/**
 * @param {WriteData} writeData
 * @return {*}  {Promise<any>}
 * @description Write file data(allow blob or url) to clipboard.
 */

async function writeFileToClipboard(writeData) {
  try {
    const nav = window.navigator; // eslint-disable-next-line no-param-reassign

    const ClipboardItem = window?.ClipboardItem;

    if (!nav?.clipboard?.write || !ClipboardItem) {
      return Promise.reject(new Error('Your browser does not support navigator.clipboard.write method.'));
    }

    if (IS_SAFARI) {
      const result = await nav.clipboard.write([new ClipboardItem(syncClipboardDataToBlob(writeData))]);
      return Promise.resolve(result);
    }

    const blobData = await asyncClipboardDataToBlob(writeData);
    const result = await nav.clipboard.write([new ClipboardItem(blobData)]);
    return Promise.resolve(result);
  } catch (err) {
    return Promise.reject(err);
  }
}

/**
 * Cannot run on the server.
 */

let _commonManager = null;
/**
 * Inner class which performs selection from either `text` or `target`
 * properties and then executes copy or cut operations.
 */

class ClipboardManager {
  /**
   * Create a common manager, write data to clipboard directly without new object.
   */

  /**
   * @param {Object} options
   */
  constructor(options = {}) {
    _defineProperty(this, "action", 'copy');

    _defineProperty(this, "fakeElem", createHiddenTextarea());

    _defineProperty(this, "container", document.body);

    _defineProperty(this, "text", ' ');

    _defineProperty(this, "copyText", () => {
      let succeeded;

      try {
        succeeded = window.document.execCommand(this.action);
      } catch (err) {
        succeeded = false;
      }

      const cbResult = {
        succeeded,
        action: this.action,
        text: this.text
      };
      return cbResult;
    });

    _defineProperty(this, "createOnAction", data => {
      const {
        action
      } = this;

      const onAction = e => {
        e.preventDefault();
        const dataEntries = Object.entries(data);
        dataEntries.forEach(item => {
          const [mimeType, content] = item;

          if (!isFileMimeType(mimeType) && typeof content === 'string') {
            const text = isInValidData(content) ? ' ' : content;

            if (mimeType === MIME_TYPES.TEXT) {
              this.text = text;
            }

            e.clipboardData.setData(mimeType, text);
          }
        }); // @ts-ignore

        this.fakeElem.removeEventListener(action, onAction);
        this.destroy();
      };

      return onAction;
    });

    _defineProperty(this, "selectFake", data => {
      if (!(this.fakeElem instanceof HTMLDivElement)) {
        this.fakeElem.value = data[MIME_TYPES.TEXT] || '';
      } else {
        this.fakeElem.innerHTML = data[MIME_TYPES.HTML] || '';
      }

      this.container.appendChild(this.fakeElem);
      this.fakeElem.focus();
      select(this.fakeElem);
    });

    _defineProperty(this, "writeFile", (data, result) => {
      const {
        activeElement
      } = window.document;
      return new Promise((resolve, reject) => {
        if (!isSupportWriteFile()) {
          this.writeDataWithoutFile(data);
        }

        const selection = window.getSelection();
        const range = document.createRange();
        this.selectFake(data);
        writeFileToClipboard(data).then(resolve, error => {
          console.warn(error);
          return result.succeeded ? resolve(result) : reject(result);
        }).finally(() => {
          if (selection) {
            selection.addRange(range);
          }

          this.destroy();

          if (activeElement instanceof HTMLTextAreaElement || activeElement instanceof HTMLInputElement) {
            activeElement.blur();
            activeElement.focus();
          }
        });
      });
    });

    _defineProperty(this, "writeDataWithoutFile", data => {
      const onCopy = this.createOnAction(data);

      if (!IS_IOS) {
        // TODO copy failed in ios version lower than 13 if prevent default event.
        // @ts-ignore
        this.fakeElem.addEventListener(this.action, onCopy);
      }

      const copyDataByExecCommand = () => {
        this.selectFake(data);
        const copyResult = this.copyText();
        this.destroy();
        return copyResult;
      };

      return copyDataByExecCommand();
    });

    _defineProperty(this, "write", (data, async = true) => {
      const result = this.writeDataWithoutFile(data); // set media data

      if (Object.keys(data).some(isFileMimeType)) {
        return this.writeFile(data, result);
      }

      if (async) {
        return new Promise((resolve, reject) => {
          if (result.succeeded) {
            return resolve(result);
          }

          return reject(result);
        });
      }

      return result;
    });

    _defineProperty(this, "writeText", (clipText, async = true) => {
      this.text = clipText;
      this.selectFake({
        [MIME_TYPES.TEXT]: clipText
      });
      const result = this.copyText();
      this.destroy();

      if (async) {
        return new Promise((resolve, reject) => {
          if (result.succeeded) {
            return resolve(result);
          }

          return reject(result);
        });
      }

      return result;
    });

    _defineProperty(this, "destroy", () => {
      this.fakeElem.remove();
    });

    if (options.action) {
      this.action = options.action;
    }

    if (options.container instanceof HTMLElement) {
      this.container = options.container;
    }

    if (options.target) {
      this.fakeElem = options.target;
    }
  }
  /**
   * Executes the copy operation based on the current selection.
   */


}

_defineProperty(ClipboardManager, "create", () => {
  if (!IS_BROWSER) {
    return null;
  }

  if (!_commonManager) {
    _commonManager = new ClipboardManager();
  }

  return _commonManager;
});

exports.MIME_TYPES = MIME_TYPES;
exports.default = ClipboardManager;
//# sourceMappingURL=index.js.map
