import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';
import _regeneratorRuntime from '@babel/runtime/regenerator';

var IS_IOS = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent) // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
// @ts-ignore
&& !window.MSStream;
var IS_BROWSER = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';
var IS_SAFARI = typeof navigator !== 'undefined' && navigator.vendor === 'Apple Computer, Inc.';
var MIME_TYPES = {
  HTML: 'text/html',
  TEXT: 'text/plain'
}; // match \s string.

var NONEMPTY_REG = /^\s+$/;

function createHiddenTextarea() {
  var isRTL = document.documentElement.getAttribute('dir') === 'rtl';
  var fakeElem = document.createElement(IS_IOS ? 'div' : 'textarea');

  if (IS_IOS) {
    fakeElem.setAttribute('style', '-webkit-user-select: text !important');
  } // Prevent zooming on iOS


  fakeElem.style.fontSize = '12pt'; // Reset box model

  fakeElem.style.border = '0';
  fakeElem.style.padding = '0';
  fakeElem.style.margin = '0'; // Move element out of screen horizontally

  fakeElem.style.position = 'absolute';
  fakeElem.style[isRTL ? 'right' : 'left'] = '-9999px'; // Move element to the same position vertically

  var yPosition = window.pageYOffset || document.documentElement.scrollTop;
  fakeElem.style.top = yPosition + "px";
  return fakeElem;
}

function select(element) {
  var selectedText;

  if (IS_IOS || element instanceof HTMLDivElement) {
    /**
     *  兼容至 ios 10 以上
     *  https://stackoverflow.com/questions/34045777/copy-to-clipboard-using-javascript-in-ios
     * */
    var selection = window.getSelection();
    var range = document.createRange(); // There must be html content to trigger copy event.

    if (!element.innerHTML) {
      element.innerHTML = '<div>123</div>';
    }

    range.selectNodeContents(element); // eslint-disable-next-line no-unused-expressions

    selection == null ? void 0 : selection.removeAllRanges(); // eslint-disable-next-line no-unused-expressions

    selection == null ? void 0 : selection.addRange(range);
    return '';
  }

  if (element.nodeName === 'SELECT') {
    element.focus();
    selectedText = element.value;
  } else if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {
    var isReadOnly = element.hasAttribute('readonly');

    if (!isReadOnly) {
      element.setAttribute('readonly', '');
    }

    if ('select' in element) {
      element.select();
    }

    if ('setSelectionRange' in element) {
      // eslint-disable-next-line no-unused-expressions
      element == null ? void 0 : element.setSelectionRange(0, element.value.length);
    }

    if (!isReadOnly) {
      element.removeAttribute('readonly');
    }

    selectedText = element.value;
  } else {
    if (element.hasAttribute('contenteditable')) {
      element.focus();
    }

    var _selection = window.getSelection();

    var _range = document.createRange();

    _range.selectNodeContents(element); // eslint-disable-next-line no-unused-expressions


    _selection == null ? void 0 : _selection.removeAllRanges(); // eslint-disable-next-line no-unused-expressions

    _selection == null ? void 0 : _selection.addRange(_range);
    selectedText = _selection == null ? void 0 : _selection.toString();
  }

  return selectedText || '';
}

function _asyncIterator(iterable) { var method, async, sync, retry = 2; for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = "@@asyncIterator", sync = "@@iterator"; } throw new TypeError("Object is not async iterable"); }

function AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function AsyncFromSyncIterator(s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, "return": function _return(value) { var ret = this.s["return"]; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, "throw": function _throw(value) { var thr = this.s["return"]; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); }
var canvas;
var ctx;
/**
 * @description Clear canvas memory.
 */

function clearCanvas() {
  if (canvas) {
    canvas.width = 0;
    canvas.height = 0;
  }
}
/**
 * @description Only support image type.
 */


function isFileMimeType(mimeType) {
  return /^(image)\//.test(mimeType);
}
/**
 * @description Transform media url to blob
 */

function urlToBlob(url) {
  return new Promise(function (resolve, reject) {
    var img = new Image();
    img.setAttribute('crossOrigin', 'anonymous');

    img.onload = function () {
      if (!canvas || !ctx) {
        canvas = document.createElement('canvas');
        ctx = canvas.getContext('2d');
      }

      canvas.width = img.naturalWidth;
      canvas.height = img.naturalHeight;

      if (ctx) {
        ctx.drawImage(img, 0, 0);
        canvas.toBlob(function (blob) {
          if (blob) {
            resolve(blob);
          }

          clearCanvas();
        }, 'image/png');
      } else {
        reject(new Error("canvas.getContext('2d') return null"));
        clearCanvas();
      }
    };

    img.onerror = function (e) {
      reject(e);
      clearCanvas();
    };

    img.src = url;
  });
}

function fileDataToBlob(_x) {
  return _fileDataToBlob.apply(this, arguments);
}
/**
 * @description Support for multiple ClipboardItems is not implemented.
 * @see https://source.chromium.org/chromium/chromium/src/+/master:ui/base/clipboard/scoped_clipboard_writer.cc;l=22?q=~ScopedClipboardWriter
 */


function _fileDataToBlob() {
  _fileDataToBlob = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(fileData) {
    var blob;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(fileData instanceof Blob)) {
              _context.next = 2;
              break;
            }

            return _context.abrupt("return", Promise.resolve(fileData));

          case 2:
            _context.next = 4;
            return urlToBlob(fileData);

          case 4:
            blob = _context.sent;
            return _context.abrupt("return", blob);

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _fileDataToBlob.apply(this, arguments);
}

function asyncClipboardDataToBlob(_x2) {
  return _asyncClipboardDataToBlob.apply(this, arguments);
}
/**
 * @description Compatible with safari.
 * @see https://stackoverflow.com/questions/66312944/javascript-clipboard-api-write-does-not-work-in-safari
 */


function _asyncClipboardDataToBlob() {
  _asyncClipboardDataToBlob = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(writeData) {
    var result, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, key;

    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            result = {};
            _iteratorAbruptCompletion = false;
            _didIteratorError = false;
            _context2.prev = 3;
            _iterator = _asyncIterator(Object.keys(writeData));

          case 5:
            _context2.next = 7;
            return _iterator.next();

          case 7:
            if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {
              _context2.next = 19;
              break;
            }

            key = _step.value;

            if (!isFileMimeType(key)) {
              _context2.next = 15;
              break;
            }

            _context2.next = 12;
            return fileDataToBlob(writeData[key]);

          case 12:
            result['image/png'] = _context2.sent;
            _context2.next = 16;
            break;

          case 15:
            if ([MIME_TYPES.HTML, MIME_TYPES.TEXT].includes(key)) {
              result[key] = new Blob([writeData[key]], {
                type: key
              });
            } else {
              console.warn('Support for multiple ClipboardItems is not implemented.(details: https://source.chromium.org/chromium/chromium/src/+/master:ui/base/clipboard/scoped_clipboard_writer.cc;l=22?q=~ScopedClipboardWriter)');
            }

          case 16:
            _iteratorAbruptCompletion = false;
            _context2.next = 5;
            break;

          case 19:
            _context2.next = 25;
            break;

          case 21:
            _context2.prev = 21;
            _context2.t0 = _context2["catch"](3);
            _didIteratorError = true;
            _iteratorError = _context2.t0;

          case 25:
            _context2.prev = 25;
            _context2.prev = 26;

            if (!(_iteratorAbruptCompletion && _iterator["return"] != null)) {
              _context2.next = 30;
              break;
            }

            _context2.next = 30;
            return _iterator["return"]();

          case 30:
            _context2.prev = 30;

            if (!_didIteratorError) {
              _context2.next = 33;
              break;
            }

            throw _iteratorError;

          case 33:
            return _context2.finish(30);

          case 34:
            return _context2.finish(25);

          case 35:
            return _context2.abrupt("return", result);

          case 36:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[3, 21, 25, 35], [26,, 30, 34]]);
  }));
  return _asyncClipboardDataToBlob.apply(this, arguments);
}

function syncClipboardDataToBlob(writeData) {
  var result = {};

  for (var _i = 0, _Object$keys = Object.keys(writeData); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];

    if (isFileMimeType(key)) {
      // DOMException: Type image/jpeg not supported on write.
      result['image/png'] = fileDataToBlob(writeData[key]);
    } else if ([MIME_TYPES.HTML, MIME_TYPES.TEXT].includes(key)) {
      result[key] = new Blob([writeData[key]], {
        type: key
      });
    } else {
      console.warn('Support for multiple ClipboardItems is not implemented.(details: https://source.chromium.org/chromium/chromium/src/+/master:ui/base/clipboard/scoped_clipboard_writer.cc;l=22?q=~ScopedClipboardWriter)');
    }
  }

  return result;
}

var isInValidData = function isInValidData(data) {
  return !data || NONEMPTY_REG.test(data);
};
function isSupportWriteFile() {
  var _window, _nav$clipboard;

  var nav = window.navigator; // eslint-disable-next-line no-param-reassign

  var ClipboardItem = (_window = window) == null ? void 0 : _window.ClipboardItem;
  return (nav == null ? void 0 : (_nav$clipboard = nav.clipboard) == null ? void 0 : _nav$clipboard.write) && !ClipboardItem;
}
/**
 * @param {WriteData} writeData
 * @return {*}  {Promise<any>}
 * @description Write file data(allow blob or url) to clipboard.
 */

function writeFileToClipboard(_x3) {
  return _writeFileToClipboard.apply(this, arguments);
}

function _writeFileToClipboard() {
  _writeFileToClipboard = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(writeData) {
    var _window2, _nav$clipboard2, nav, ClipboardItem, _result, blobData, result;

    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            nav = window.navigator; // eslint-disable-next-line no-param-reassign

            ClipboardItem = (_window2 = window) == null ? void 0 : _window2.ClipboardItem;

            if (!(!(nav != null && (_nav$clipboard2 = nav.clipboard) != null && _nav$clipboard2.write) || !ClipboardItem)) {
              _context3.next = 5;
              break;
            }

            return _context3.abrupt("return", Promise.reject(new Error('Your browser does not support navigator.clipboard.write method.')));

          case 5:
            if (!IS_SAFARI) {
              _context3.next = 10;
              break;
            }

            _context3.next = 8;
            return nav.clipboard.write([new ClipboardItem(syncClipboardDataToBlob(writeData))]);

          case 8:
            _result = _context3.sent;
            return _context3.abrupt("return", Promise.resolve(_result));

          case 10:
            _context3.next = 12;
            return asyncClipboardDataToBlob(writeData);

          case 12:
            blobData = _context3.sent;
            _context3.next = 15;
            return nav.clipboard.write([new ClipboardItem(blobData)]);

          case 15:
            result = _context3.sent;
            return _context3.abrupt("return", Promise.resolve(result));

          case 19:
            _context3.prev = 19;
            _context3.t0 = _context3["catch"](0);
            return _context3.abrupt("return", Promise.reject(_context3.t0));

          case 22:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[0, 19]]);
  }));
  return _writeFileToClipboard.apply(this, arguments);
}

/**
 * Cannot run on the server.
 */

var _commonManager = null;
/**
 * Inner class which performs selection from either `text` or `target`
 * properties and then executes copy or cut operations.
 */

var ClipboardManager =
/**
 * Create a common manager, write data to clipboard directly without new object.
 */

/**
 * @param {Object} options
 */
function ClipboardManager(options) {
  var _this = this;

  if (options === void 0) {
    options = {};
  }

  _defineProperty(this, "action", 'copy');

  _defineProperty(this, "fakeElem", createHiddenTextarea());

  _defineProperty(this, "container", document.body);

  _defineProperty(this, "text", ' ');

  _defineProperty(this, "copyText", function () {
    var succeeded;

    try {
      succeeded = window.document.execCommand(_this.action);
    } catch (err) {
      succeeded = false;
    }

    var cbResult = {
      succeeded: succeeded,
      action: _this.action,
      text: _this.text
    };
    return cbResult;
  });

  _defineProperty(this, "createOnAction", function (data) {
    var action = _this.action;

    var onAction = function onAction(e) {
      e.preventDefault();
      var dataEntries = Object.entries(data);
      dataEntries.forEach(function (item) {
        var mimeType = item[0],
            content = item[1];

        if (!isFileMimeType(mimeType) && typeof content === 'string') {
          var text = isInValidData(content) ? ' ' : content;

          if (mimeType === MIME_TYPES.TEXT) {
            _this.text = text;
          }

          e.clipboardData.setData(mimeType, text);
        }
      }); // @ts-ignore

      _this.fakeElem.removeEventListener(action, onAction);

      _this.destroy();
    };

    return onAction;
  });

  _defineProperty(this, "selectFake", function (data) {
    if (!(_this.fakeElem instanceof HTMLDivElement)) {
      _this.fakeElem.value = data[MIME_TYPES.TEXT] || '';
    } else {
      _this.fakeElem.innerHTML = data[MIME_TYPES.HTML] || '';
    }

    _this.container.appendChild(_this.fakeElem);

    _this.fakeElem.focus();

    select(_this.fakeElem);
  });

  _defineProperty(this, "writeFile", function (data, result) {
    var activeElement = window.document.activeElement;
    return new Promise(function (resolve, reject) {
      if (!isSupportWriteFile()) {
        _this.writeDataWithoutFile(data);
      }

      var selection = window.getSelection();
      var range = document.createRange();

      _this.selectFake(data);

      writeFileToClipboard(data).then(resolve, function (error) {
        console.warn(error);
        return result.succeeded ? resolve(result) : reject(result);
      })["finally"](function () {
        if (selection) {
          selection.addRange(range);
        }

        _this.destroy();

        if (activeElement instanceof HTMLTextAreaElement || activeElement instanceof HTMLInputElement) {
          activeElement.blur();
          activeElement.focus();
        }
      });
    });
  });

  _defineProperty(this, "writeDataWithoutFile", function (data) {
    var onCopy = _this.createOnAction(data);

    if (!IS_IOS) {
      // TODO copy failed in ios version lower than 13 if prevent default event.
      // @ts-ignore
      _this.fakeElem.addEventListener(_this.action, onCopy);
    }

    var copyDataByExecCommand = function copyDataByExecCommand() {
      _this.selectFake(data);

      var copyResult = _this.copyText();

      _this.destroy();

      return copyResult;
    };

    return copyDataByExecCommand();
  });

  _defineProperty(this, "write", function (data, async) {
    if (async === void 0) {
      async = true;
    }

    var result = _this.writeDataWithoutFile(data); // set media data


    if (Object.keys(data).some(isFileMimeType)) {
      return _this.writeFile(data, result);
    }

    if (async) {
      return new Promise(function (resolve, reject) {
        if (result.succeeded) {
          return resolve(result);
        }

        return reject(result);
      });
    }

    return result;
  });

  _defineProperty(this, "writeText", function (clipText, async) {
    var _this$selectFake;

    if (async === void 0) {
      async = true;
    }

    _this.text = clipText;

    _this.selectFake((_this$selectFake = {}, _this$selectFake[MIME_TYPES.TEXT] = clipText, _this$selectFake));

    var result = _this.copyText();

    _this.destroy();

    if (async) {
      return new Promise(function (resolve, reject) {
        if (result.succeeded) {
          return resolve(result);
        }

        return reject(result);
      });
    }

    return result;
  });

  _defineProperty(this, "destroy", function () {
    _this.fakeElem.remove();
  });

  if (options.action) {
    this.action = options.action;
  }

  if (options.container instanceof HTMLElement) {
    this.container = options.container;
  }

  if (options.target) {
    this.fakeElem = options.target;
  }
}
/**
 * Executes the copy operation based on the current selection.
 */
;

_defineProperty(ClipboardManager, "create", function () {
  if (!IS_BROWSER) {
    return null;
  }

  if (!_commonManager) {
    _commonManager = new ClipboardManager();
  }

  return _commonManager;
});

export default ClipboardManager;
export { MIME_TYPES };
//# sourceMappingURL=index.js.map
