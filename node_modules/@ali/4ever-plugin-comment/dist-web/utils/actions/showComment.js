import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import { domUtils, environment, createPerfLazyRenderPlugin } from '@ali/4ever-cangjie';
import { getActiveId } from "../queries";
import { setActiveId } from "../actions";
import { SCROLL_HEIGHT_PERCENT } from "../constants";
import { findDOMNodeByVoidKey } from "../utils/findDOMNodeByVoidKey";
import { ViewMark } from "../models";
var IS_MOBILE = environment.IS_MOBILE,
    IS_IPAD = environment.IS_IPAD;
var TOP_SPACE = IS_MOBILE && !IS_IPAD ? 20 : 100;
var BOTTOM_SPACE = 100;
var findDOMNode = domUtils.findDOMNode,
    getScrollableContainerInfo = domUtils.getScrollableContainerInfo,
    findScrollableContainer = domUtils.findScrollableContainer;

function scrollToSelectionTop(_x) {
  return _scrollToSelectionTop.apply(this, arguments);
}

function _scrollToSelectionTop() {
  _scrollToSelectionTop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(options) {
    var contentId, key, content, controller, scroller, heightPercent, bottomAlign, topExtraOffset, domNode, targetRect, _domNode$closest, _getScrollableContain, isWindow, scrollerTop, yOffset, viewportHeight, alignY, targetOffsetTop, y, inView, topSpace;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            contentId = options.contentId, key = options.key, content = options.content, controller = options.controller, scroller = options.scroller, heightPercent = options.heightPercent, bottomAlign = options.bottomAlign, topExtraOffset = options.topExtraOffset;

            if (!key) {
              _context.next = 4;
              break;
            }

            _context.next = 4;
            return domUtils.scrollToNodeByKey(key, controller, true);

          case 4:
            domNode = findDOMNodeByVoidKey(contentId, content) || content.querySelector("[data-comment=\"" + contentId + "\"]");

            if (domNode) {
              _context.next = 7;
              break;
            }

            return _context.abrupt("return");

          case 7:
            createPerfLazyRenderPlugin.showPrunedElements(domNode);
            targetRect = domNode.getBoundingClientRect();

            if (targetRect && targetRect.height < 1) {
              targetRect = (_domNode$closest = domNode.closest('[data-foldable]')) == null ? void 0 : _domNode$closest.getBoundingClientRect();
            }

            if (targetRect) {
              _context.next = 12;
              break;
            }

            return _context.abrupt("return");

          case 12:
            _getScrollableContain = getScrollableContainerInfo(scroller), isWindow = _getScrollableContain.isWindow, scrollerTop = _getScrollableContain.scrollerTop, yOffset = _getScrollableContain.yOffset;
            viewportHeight = IS_MOBILE && !IS_IPAD ? BOTTOM_SPACE : Math.max(window.innerHeight * heightPercent, BOTTOM_SPACE);
            alignY = bottomAlign ? targetRect.bottom : targetRect.top; // isInview: yOffset < targetOffsetTop < yOffset + viewportHeight
            // move: targetOffsetTop <= finalY <= targetOffsetTop + viewportHeight

            targetOffsetTop = alignY + yOffset - scrollerTop;
            y = yOffset;
            inView = true;
            topSpace = TOP_SPACE + topExtraOffset;

            if (targetOffsetTop < yOffset + topSpace) {
              // selection above viewport
              y = targetOffsetTop - topSpace;
              inView = false;
            } else if (targetOffsetTop > yOffset + viewportHeight) {
              // selection below viewport
              y = targetOffsetTop - viewportHeight;
              inView = false;
            }

            if (!inView) {
              _context.next = 22;
              break;
            }

            return _context.abrupt("return");

          case 22:
            if (isWindow) {
              window.scrollTo(window.scrollX, y);
            } else {
              // eslint-disable-next-line no-param-reassign
              scroller.scrollTop = y;
            }

          case 23:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _scrollToSelectionTop.apply(this, arguments);
}

function updateComment(_x2, _x3, _x4, _x5) {
  return _updateComment.apply(this, arguments);
}

function _updateComment() {
  _updateComment = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(controller, contentId, options, configs) {
    var oldId, skipScroll, _decoration$start, _controller$value, document, decorations, content, _ref, _ref$heightPercent, heightPercent, topExtraOffset, decoration, key;

    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            oldId = getActiveId(controller);

            if (oldId !== contentId) {
              controller.run('onAction', setActiveId(contentId, !(options != null && options.skipAutoFocus)));
            }

            skipScroll = oldId === contentId && !(options != null && options.alwaysScroll);

            if (!(options != null && options.skipScroll || !contentId || skipScroll)) {
              _context2.next = 5;
              break;
            }

            return _context2.abrupt("return");

          case 5:
            _context2.prev = 5;
            _controller$value = controller.value, document = _controller$value.document, decorations = _controller$value.decorations; // eslint-disable-next-line react/no-find-dom-node

            content = findDOMNode(document.key);

            if (content) {
              _context2.next = 10;
              break;
            }

            return _context2.abrupt("return");

          case 10:
            _ref = options || {}, _ref$heightPercent = _ref.heightPercent, heightPercent = _ref$heightPercent === void 0 ? SCROLL_HEIGHT_PERCENT : _ref$heightPercent;
            topExtraOffset = (configs == null ? void 0 : configs.scrollTopExtraOffset) || 0;
            decoration = decorations.find(function (d) {
              return ViewMark.isViewMark(d.mark) && d.mark.data.contentId === contentId;
            });
            key = decoration == null ? void 0 : (_decoration$start = decoration.start) == null ? void 0 : _decoration$start.key;
            scrollToSelectionTop({
              contentId: contentId,
              key: key,
              controller: controller,
              content: content,
              scroller: controller.scrollableContainer,
              heightPercent: heightPercent,
              topExtraOffset: topExtraOffset,
              bottomAlign: (configs == null ? void 0 : configs.scrollByBottomAlign) && configs.scrollByBottomAlign()
            });
            _context2.next = 19;
            break;

          case 17:
            _context2.prev = 17;
            _context2.t0 = _context2["catch"](5);

          case 19:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[5, 17]]);
  }));
  return _updateComment.apply(this, arguments);
}

var cachedMap = {}; //  避免频繁设置，导致的闪烁问题

export default (function (controller, contentId, options, config) {
  var doUpdate = function doUpdate() {
    return updateComment(controller, contentId, options, config);
  };

  var oldId = getActiveId(controller);

  if (oldId && cachedMap[oldId]) {
    window.clearTimeout(cachedMap[oldId]);
  }

  if (contentId && cachedMap[contentId]) {
    window.clearTimeout(cachedMap[contentId]);
  } // 如果有一个是 undefined


  var key = contentId || oldId;

  if (key && (!oldId || !contentId)) {
    // timeout 出于性能考虑，模拟 debounce 效果；这里后续是数据改动，无需清除
    var timer = window.setTimeout(doUpdate, 100);
    cachedMap[key] = timer;
  } else {
    doUpdate();
  }
});
//# sourceMappingURL=showComment.js.map