import { TextPoint, Queries, domUtils } from '@ali/4ever-cangjie'; // Block 元素顶部的偏移，主要处理 border-radius 情况。

var BLOCK_TOP_OFFSET = 6; // sidebar POPUP 时的偏移。

var BLOCK_TOP_OFFSET_POPUP = -1; // 大于此值，会视为 Block 元素，定位到右上角；否则视为 Inline 元素，定位到光标中间

var SAMPLE_BLOCK_HEIGHT = 41;

/**
 * 光标位置处理。由于 void 节点内的光标无法定位，尝试获取前一个位置
 */
function corretCaretPoint(controller, point) {
  var _document$getParent;

  var document = controller.value.document;

  if (document.getClosestVoid(point.key, controller) || ((_document$getParent = document.getParent(point.key)) == null ? void 0 : _document$getParent.type) === 'code') {
    return controller.query(Queries.pointAtDistance, point, -1);
  }

  return point;
}
/**
 * 根据 key 获取 document 下面的一级节点
 */


function getRootBlock(document, pointKey) {
  var path = document.getPath(pointKey);
  var firstPath = path && path.slice(0, 1);
  var firstRoot = firstPath != null && firstPath.length ? document.getNodeByPath(firstPath) : null;
  return firstRoot;
}
/**
 * 根据 top 坐标，获取对应的分行（row）
 */


function findRow(params) {
  var docTop = params.docTop,
      top = params.top,
      pointKey = params.pointKey,
      document = params.document,
      allRows = params.allRows,
      container = params.container;
  var firstRoot = getRootBlock(document, pointKey);

  if (!firstRoot) {
    return undefined;
  }

  var rootKey = firstRoot.key;
  var cachedRows = allRows[rootKey];

  if (!cachedRows) {
    var domNode = domUtils.findDOMNodeSafely(firstRoot.key, container);
    var newRows = domNode && domUtils.splitRows(domNode);

    if (!newRows || !newRows.length) {
      return undefined;
    }

    var _domNode$getBoundingC = domNode.getBoundingClientRect(),
        clientTop = _domNode$getBoundingC.top,
        height = _domNode$getBoundingC.height;

    newRows.forEach(function (r) {
      // eslint-disable-next-line no-param-reassign
      r.top -= clientTop;
    });
    cachedRows = {
      top: clientTop - docTop,
      height: height,
      points: [],
      rows: newRows
    };
    allRows[rootKey] = cachedRows;
  }

  var _cachedRows = cachedRows,
      rows = _cachedRows.rows,
      blockTop = _cachedRows.top;
  var targetTop = top - blockTop;

  for (var index = 0; index < rows.length; index++) {
    var _row = rows[index];

    if (_row.top + _row.height > targetTop) {
      return {
        row: _row,
        cachedRows: cachedRows
      };
    }
  }

  var row = rows[rows.length - 1];
  return {
    row: row,
    cachedRows: cachedRows
  };
}

/**
 * 根据一个 point，获取对应的分行（row）、相对于 document 的 offsetTop
 */
export function getRowTopFromPoint(params) {
  var controller = params.controller,
      paramPoint = params.paramPoint,
      isFromPopup = params.isFromPopup,
      docTop = params.docTop,
      container = params.container,
      allRows = params.allRows;
  var document = controller.value.document;
  var blockTopOffset = isFromPopup ? BLOCK_TOP_OFFSET_POPUP : BLOCK_TOP_OFFSET;
  var targetPoint = paramPoint;

  if (!targetPoint || !document.getNode(targetPoint.key)) {
    return undefined;
  } // 0. 处理折叠逻辑等特殊场景，修正 point


  var block = document.getClosestBlock(targetPoint.key);
  var foldBlocks = block && controller.query('getHeadingAncestors', block);
  var firstFoldBlock = foldBlocks && foldBlocks.find(function (b) {
    return controller.userData.get(b, 'fold');
  });
  var firstFoldText = firstFoldBlock == null ? void 0 : firstFoldBlock.getFirstText(); // 气泡形式，如果被折叠，就直接藏起来

  if (!isFromPopup && firstFoldText) {
    return undefined;
  } // 非气泡形式，如果被折叠，就找到折叠的段落


  if (firstFoldText) {
    targetPoint = TextPoint.create({
      key: firstFoldText.key,
      offset: 0
    });
  }

  var point = corretCaretPoint(controller, targetPoint); // 1. 这里开始正式分行计算，获取 point 的 key

  var pointCacheKey = point.viewKey; // 1.1 先查有没有缓存，有的话， 就不需要计算了

  var firstRoot = getRootBlock(document, point.key);

  if (firstRoot) {
    var _cachedRows2 = firstRoot && allRows[firstRoot.key];

    var cachedPoint = _cachedRows2 == null ? void 0 : _cachedRows2.points.find(function (p) {
      return p.key === pointCacheKey;
    });

    if (_cachedRows2 && cachedPoint) {
      var caretTop = cachedPoint.caretTop,
          _row2 = cachedPoint.row;

      var _rowTop = _cachedRows2.top + _row2.top;

      return [Math.round(_rowTop), Math.round(caretTop)];
    }
  } // 2. 没有缓存，开始获取高度


  var caretPosition = domUtils.findCaretPosition(point);
  var caretClientTop = caretPosition == null ? void 0 : caretPosition.clientTop;

  if (typeof caretClientTop !== 'number') {
    return undefined;
  } // 3. 计算分行（row）


  var result = findRow({
    top: caretClientTop - docTop,
    docTop: docTop,
    pointKey: point.key,
    document: document,
    container: container,
    allRows: allRows
  });

  if (!result) {
    return undefined;
  }

  var row = result.row,
      cachedRows = result.cachedRows;
  var rowHeight = row.height,
      rowOffsetTop = row.top;
  var rowTop = cachedRows.top + rowOffsetTop; // case 1：分行
  // case 2：整个 void block

  var top = rowHeight <= SAMPLE_BLOCK_HEIGHT ? caretClientTop - docTop : rowTop + blockTopOffset; // 4. 存到缓存里

  cachedRows.points.push({
    key: pointCacheKey,
    caretTop: Math.round(top),
    row: row
  });
  return [Math.round(rowTop), Math.round(top)];
}
//# sourceMappingURL=getRowTopFromPoint.js.map