import _extends from "@babel/runtime/helpers/extends";
import { Commands, Selection } from '@ali/4ever-cangjie';
import equal from 'fast-deep-equal';
import { DataMark, ViewMark } from "../models/marks";
import { marksToDecorations } from "../utils/marksToDecorations";
import { deserialize } from "../utils/readonlySerializer";
var lastUpdatedDocMap = new WeakMap();
export default function setComments(controller, comments) {
  var _controller$value = controller.value,
      document = _controller$value.document,
      data = _controller$value.data;
  var prevData = data._commentsCachedData;
  var isSameCommentsData = equal(comments, prevData); // skipped seting same comments

  if (!isSameCommentsData) {
    controller.setData(_extends({}, data, {
      _commentsCachedData: comments
    }));
  }

  var newDecs = [];
  comments.forEach(function (comment) {
    if (!comment.position) {
      return;
    }

    var decoration = deserialize(comment, document);
    decoration && newDecs.push(decoration);
  });
  var updatedDecos = marksToDecorations(controller);

  if (!equal(updatedDecos, controller.value.decorations)) {
    controller.setDecorations(updatedDecos);
  }

  var decorations = controller.value.decorations;
  newDecs = newDecs.filter(function (dec) {
    var mark = dec.mark;

    if (decorations.find(function (d) {
      return ViewMark.isViewMark(d.mark) && d.mark.data.contentId === mark.data.contentId;
    })) {
      return false;
    }

    return true;
  });

  if (!newDecs.length) {
    return controller.flush();
  }

  var prevDoc = lastUpdatedDocMap.get(controller);
  /**
   * 自上次更新后，comments 和 document 均无变化，就不需要在继续了。
   *
   * 这里是保障，万一 addMark 不生效，会导致无限循环的问题：
   * addMark -> document change -> setComments -> addMark
   */

  if (isSameCommentsData && prevDoc === document) {
    return controller.flush();
  }

  newDecs.forEach(function (dec) {
    var mark = dec.mark;
    var anchor = dec.start;
    var focus = dec.end;
    var contentId = mark.data.contentId;
    var dataMark = DataMark.create({
      contentId: contentId
    });
    var range = Selection.create({
      anchor: anchor,
      focus: focus
    });
    var isValid = Selection.isValidRangeSelection(document, range);

    if (!isValid) {
      return;
    }

    if (range.isCollapsed) {
      var node = document.getNode(anchor.key);
      /**
       * 如果 Text 节点非空，decorations 校验会过滤掉。
       */

      if (node != null && node.text) {
        /**
         * 对 Code 的特殊处理。
         * TODO：Code 插件重构后，移除这里。
         */
        var parent = document.getParent(anchor.key);

        if (node.isText() && parent != null && parent.isBlock() && parent.type === 'code') {
          controller.command(Commands.addMarkByKey, node.key, 0, node.text.length, dataMark);
        }
      } else {
        controller.command(Commands.addMarkByKey, anchor.key, 0, 0, dataMark);
      }
    } else {
      controller.command(Commands.addMarkAtRange, range, dataMark);
    }
  });
  lastUpdatedDocMap.set(controller, controller.value.document);
  return controller.setDecorations(marksToDecorations(controller)).flush();
}
//# sourceMappingURL=setComments.js.map