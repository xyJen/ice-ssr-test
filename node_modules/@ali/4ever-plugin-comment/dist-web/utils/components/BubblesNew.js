import * as React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import styled from 'styled-components';
import { debounce } from 'lodash-es';
import { useZoomContainer, useZoom, TextPoint, Selection, domUtils, constants, environment } from '@ali/4ever-cangjie';
import { ViewMark } from "../models/marks";
import { findCommentPostion } from "../utils/findCommentPostion";
import { CommentAddButton, CommentBubble } from "./floatButton";
import { useDocSize } from "../hooks/useDocSize";
import hoverCapture from "../utils/hoverCapture";
import blockHoverEvent from "../utils/blockHoverEvent";
import { BUTTON_SIZE } from "../utils/constants";
var BubblesWrapper = /*#__PURE__*/styled.div(["position:absolute;top:0;"]);
var SPACE_TO_DOC = environment.IS_MOBILE ? -2 : 2;
var EFFECT_DEBOUNCE_TIME = 300;

function getSelectionFromBlock(block, controller) {
  var fakePoint = TextPoint.create({
    key: '0',
    offset: 0
  });
  var emptySelection = Selection.create({
    anchor: fakePoint,
    focus: fakePoint
  });
  var newRange = emptySelection.moveToRangeOfNode(block, controller).flip();
  return Selection.create(newRange.convertToTextPoints(controller.value.document)).set('data', {
    isFromTable: block.type === 'table'
  });
}
/**
 * cangjie-content 和 document 的 rect 不同步。
 *
 * 由于计算是基于 document、渲染是在 content 里面，这里设置一下差值。
 */


function useRightSpace(controller, rightSpaceId) {
  var _React$useState = React.useState(0),
      space = _React$useState[0],
      setSapce = _React$useState[1];

  React.useEffect(function () {
    var document = controller.value.document; // eslint-disable-next-line react/no-find-dom-node

    var docNode = domUtils.findDOMNodeSafely(document.key);
    var contentNode = docNode == null ? void 0 : docNode.closest("[" + constants.Selector.content + "]");

    if (!docNode || !contentNode) {
      return;
    }

    var _docNode$getBoundingC = docNode.getBoundingClientRect(),
        docRight = _docNode$getBoundingC.right;

    var _contentNode$getBound = contentNode.getBoundingClientRect(),
        contentRight = _contentNode$getBound.right;

    var rightSpace = Math.max(0, contentRight - docRight);
    setSapce(rightSpace);
  }, [controller, rightSpaceId]);
  return space;
}

function BubblesNew(_ref) {
  var configs = _ref.configs,
      controller = _ref.controller;

  var _ref2 = configs || {},
      disableRangeAdd = _ref2.disableRangeAdd,
      onBubbleClick = _ref2.onBubbleClick;

  var container = useZoomContainer();

  var _React$useState2 = React.useState([]),
      bubbles = _React$useState2[0],
      setBubbles = _React$useState2[1];

  var ref = React.useRef(null);

  var _React$useState3 = React.useState(undefined),
      hoverBlock = _React$useState3[0],
      setHoverBlock = _React$useState3[1];

  var handleHover = React.useCallback(function (_ref3) {
    var block = _ref3.block;

    if (hoverBlock !== block) {
      setHoverBlock(block);
    }
  }, [hoverBlock]);
  React.useEffect(function () {
    hoverCapture.on(handleHover);
    return function () {
      return hoverCapture.off(handleHover);
    };
  }, [handleHover]);
  var _controller$value = controller.value,
      decorations = _controller$value.decorations,
      document = _controller$value.document,
      selection = _controller$value.selection;
  var updatePosition = React.useCallback(function () {
    var _ref$current;

    var commentDecorations = decorations.filter(function (d) {
      return ViewMark.isViewMark(d.mark);
    });
    var hasHardSelection = (selection == null ? void 0 : selection.isExpanded) || selection && document.getClosestVoid(selection.anchor.key, controller) && controller.value.isFocused;
    var range;

    if (hasHardSelection && !disableRangeAdd) {
      range = selection;
    } else if (hoverBlock && selection.isCollapsed) {
      range = getSelectionFromBlock(hoverBlock, controller);
    }

    var rowItems = findCommentPostion({
      controller: controller,
      decorations: commentDecorations,
      selection: range,
      container: container || undefined,
      isFromPopup: false
    });

    var _ref4 = ((_ref$current = ref.current) == null ? void 0 : _ref$current.getBoundingClientRect()) || {},
        _ref4$top = _ref4.top,
        refTop = _ref4$top === void 0 ? 0 : _ref4$top; // eslint-disable-next-line react/no-find-dom-node


    var documentNode = domUtils.findDOMNodeSafely(document.key);

    if (!documentNode) {
      return;
    }

    var _documentNode$getBoun = documentNode.getBoundingClientRect(),
        docTop = _documentNode$getBoun.top;

    rowItems.forEach(function (item) {
      // 如果存在 hover 选区、并且还有其他的气泡，就把选区去除掉
      if (item && !hasHardSelection && item.selection && item.decorations.length > 0) {
        item.selection = undefined;
      }
    });
    var newBubbles = rowItems.reduce(function (array, item) {
      var isMultiple = item.decorations.length > 1;
      var decoration = item.decorations[0];
      var top = item.top + docTop - refTop + BUTTON_SIZE / 2;
      var isAdd = Boolean(item.selection);
      var newRange = isAdd && range ? {
        range: range,
        isHard: Boolean(hasHardSelection)
      } : undefined;
      var count = 1;
      var contentId = '';

      if (decoration) {
        var mark = decoration.mark;
        var _mark$data = mark.data;
        contentId = _mark$data.contentId;
        count = _mark$data.count;
      }

      array.push({
        top: top,
        isMultiple: isMultiple,
        count: count,
        newRange: newRange,
        contentId: contentId
      });
      return array;
    }, []);
    setBubbles(newBubbles);
  }, [decorations, selection, document, controller, disableRangeAdd, hoverBlock, container]);

  var _React$useReducer = React.useReducer(function (s) {
    return s + 1;
  }, 0),
      rightSpaceId = _React$useReducer[0],
      updateRightSpace = _React$useReducer[1];

  var tryUpdateRightSpace = React.useCallback(function (isWidthChanged) {
    if (isWidthChanged) {
      updateRightSpace();
    }
  }, []);
  useDocSize(ref, updatePosition);
  useDocSize(ref, tryUpdateRightSpace);
  React.useEffect(function () {
    var debouncedFunc = debounce(updatePosition, EFFECT_DEBOUNCE_TIME);
    debouncedFunc();
    return function () {
      debouncedFunc.cancel();
    };
  }, [updatePosition]);
  var handleHovered = React.useCallback(function (isHover) {
    if (hoverBlock) {
      blockHoverEvent.trigger({
        block: hoverBlock,
        isHover: isHover
      });
    }
  }, [hoverBlock]);
  var rightSpace = useRightSpace(controller, rightSpaceId);
  var zoom = useZoom();
  var wrapperStyle = React.useMemo(function () {
    return {
      right: (rightSpace - BUTTON_SIZE - SPACE_TO_DOC) / zoom + "px"
    };
  }, [rightSpace, zoom]);
  return /*#__PURE__*/_createElement(BubblesWrapper, {
    "data-comment-bubblesnew": true,
    ref: ref,
    style: wrapperStyle
  }, bubbles.map(function (bubble) {
    var newRange = bubble.newRange,
        contentId = bubble.contentId,
        isMultiple = bubble.isMultiple,
        count = bubble.count,
        top = bubble.top;

    if (newRange && !environment.IS_MOBILE) {
      var _configs$locale;

      return /*#__PURE__*/_createElement(CommentAddButton, {
        key: contentId,
        controller: controller,
        range: newRange.range,
        onHover: newRange.isHard ? undefined : handleHovered,
        top: top / zoom,
        tips: configs == null ? void 0 : (_configs$locale = configs.locale) == null ? void 0 : _configs$locale.addComment
      });
    }

    if (!newRange) {
      var _configs$locale2;

      return /*#__PURE__*/_createElement(CommentBubble, {
        key: contentId,
        controller: controller,
        isMultiple: isMultiple,
        count: count,
        contentId: contentId,
        showInline: configs == null ? void 0 : configs.showInline,
        tips: configs == null ? void 0 : (_configs$locale2 = configs.locale) == null ? void 0 : _configs$locale2.showComent,
        top: Math.round(top / zoom),
        onBubbleClick: onBubbleClick
      });
    }

    return null;
  }));
}

export default BubblesNew;
//# sourceMappingURL=BubblesNew.js.map