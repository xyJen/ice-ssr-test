import React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import { Controller, useZoomContainer } from '@ali/4ever-cangjie';
import { ViewMark } from "../models/marks";
import getComments from "../queries/getComments";
import getSiblings from "../queries/getSiblings";
import { cancelComment, hideComment, showComment } from "../actions";
import { findDOMNodeByVoidKey } from "../utils/findDOMNodeByVoidKey";
export default function CommentInlinePanel(props) {
  var _configs$locale;

  var configs = props.configs,
      onAdd = props.onAdd,
      onDelete = props.onDelete,
      enableAutoBlur = props.enableAutoBlur,
      contentId = props.contentId;
  var controller = Controller.useController();
  var container = useZoomContainer() || window.document.body;

  var _React$useState = React.useState(),
      position = _React$useState[0],
      setPosition = _React$useState[1];

  var comments = getComments(controller);
  var item = comments.find(function (c) {
    return c.contentId === contentId;
  });
  var decorations = controller.value.decorations;
  var decoration = decorations.find(function (d) {
    return ViewMark.isViewMark(d.mark) && d.mark.data.contentId === contentId;
  });
  var mark = decoration == null ? void 0 : decoration.mark;

  var _ref = (mark == null ? void 0 : mark.data) || {},
      isNew = _ref.isNew,
      summary = _ref.summary,
      rp = _ref.position;

  React.useEffect(function () {
    var voidNode = findDOMNodeByVoidKey(contentId, container);
    var dom = container.querySelector("[data-comment='" + contentId + "']");
    var voidRect = voidNode == null ? void 0 : voidNode.getBoundingClientRect();
    var rects = voidRect ? [voidRect] : Array.from((dom == null ? void 0 : dom.getClientRects()) || []);
    var rect = rects[rects.length - 1];

    if (!rect) {
      return;
    }

    var parent = container.getBoundingClientRect();
    var top = rect.bottom - parent.top;
    var left = rect.left + rect.width / 2 - parent.left;
    setPosition({
      top: top,
      left: left,
      width: parent.width,
      rects: rects,
      parentRect: parent
    });
  }, [contentId, container, controller.value.decorations]);

  var _controller$query = controller.query(getSiblings),
      prev = _controller$query.prev,
      next = _controller$query.next;

  var navigateToPrev = React.useCallback(function () {
    if (prev) {
      controller.run('onAction', showComment(prev));
    }
  }, [controller, prev]);
  var navigateToNext = React.useCallback(function () {
    if (next) {
      controller.run('onAction', showComment(next));
    }
  }, [controller, next]);
  var cancelPopup = React.useCallback(function () {
    controller.run('onAction', hideComment());
    controller.run('onAction', cancelComment());
  }, [controller]);

  if (!item && !decoration) {
    return null;
  }

  var readonlyPosition = '';

  if (isNew) {
    readonlyPosition = controller.readOnly ? rp : undefined;
  }

  var summaryText = summary || (item == null ? void 0 : item.summary) || (configs == null ? void 0 : (_configs$locale = configs.locale) == null ? void 0 : _configs$locale.comment) || '';
  var renderProps = {
    contentId: contentId,
    isActive: true,
    isAutoFocus: false,
    isNew: Boolean(isNew),
    summary: summaryText,
    readonlyPosition: readonlyPosition,
    onAdd: onAdd,
    onDelete: onDelete,
    prev: prev,
    next: next,
    navigateToPrev: navigateToPrev,
    navigateToNext: navigateToNext,
    cancelPopup: cancelPopup,
    position: position
  };
  var children = (configs == null ? void 0 : configs.renderCustomPopup) && configs.renderCustomPopup(renderProps);
  return /*#__PURE__*/_createElement(React.Fragment, null, children);
}
//# sourceMappingURL=CommentInlinePanel.js.map