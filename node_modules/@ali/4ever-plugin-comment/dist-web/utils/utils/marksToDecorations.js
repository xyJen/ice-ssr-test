import _extends from "@babel/runtime/helpers/extends";
import { TextPoint, Decoration, Path } from '@ali/4ever-cangjie';
import { DataMark, ViewMark } from "../models/marks";
import { getActiveId } from "../queries";
import getComments from "../queries/getComments";
/**
 * DataMark -> ViewMark
 */

export function marksToDecorations(controller) {
  var comments = getComments(controller);
  var _controller$value = controller.value,
      decorations = _controller$value.decorations,
      document = _controller$value.document;
  var activeContentId = getActiveId(controller); // 先过滤掉所有的 ViewMark

  var otherDecorations = decorations.filter(function (d) {
    return !ViewMark.isViewMark(d.mark);
  });
  var texts = document.getTexts();
  var newDecs = decorations.filter(function (d) {
    if (ViewMark.isViewMark(d.mark) && d.mark.data.isNew) {
      var newcid = d.mark.data.contentId;
      return !comments.find(function (c) {
        return c.contentId === newcid;
      });
    }

    return false;
  });
  var readOnlyDecs = decorations.filter(function (d) {
    return ViewMark.isViewMark(d.mark) && d.mark.data.isReadonly;
  });
  newDecs = newDecs.concat(readOnlyDecs);
  newDecs = newDecs.map(function (d) {
    var mark = d.mark;
    var isActive = activeContentId === mark.data.contentId;
    return d.set('mark', ViewMark.create(_extends({}, mark.data, {
      isActive: isActive
    })));
  }); // 遍历每一个 mark，然后构建新的 View Decoration

  texts.forEach(function (text) {
    var offset = 0;
    text.leaves.forEach(function (leave) {
      leave.marks.forEach(function (m) {
        if (DataMark.isDataMark(m)) {
          var contentId = m.data.contentId;
          var item = comments.find(function (c) {
            return c.contentId === contentId;
          });

          if (!item) {
            return;
          }

          var oldDec = newDecs.find(function (dec) {
            return dec.mark.data.contentId === contentId;
          }); // 如果这个 text 和 oldDec 的跨越太多（超过一个 block），就忽略掉

          if (oldDec) {
            var prevBlock = document.getClosestBlock(oldDec.end.key);
            var prevSucceedingBlock = document.getNextBlock(oldDec.end.key);
            var closestBlock = document.getClosestBlock(text.key);

            if (closestBlock !== prevBlock && closestBlock !== prevSucceedingBlock) {
              return;
            }
          }

          var start = (oldDec == null ? void 0 : oldDec.start) || TextPoint.create({
            key: text.key,
            offset: offset
          });
          var end = TextPoint.create({
            key: text.key,
            offset: offset + leave.text.length
          });
          var count = item.count,
              summary = item.summary;
          var newDec = Decoration.create({
            start: start,
            end: end,
            mark: (oldDec == null ? void 0 : oldDec.mark) || ViewMark.create({
              contentId: contentId,
              count: count,
              summary: summary,
              isActive: contentId === activeContentId
            })
          });

          if (oldDec) {
            newDecs = newDecs.map(function (d) {
              return d !== oldDec ? d : newDec;
            });
          } else {
            newDecs.push(newDec);
          }
        }
      });
      offset += leave.text.length;
    });
  });
  newDecs = newDecs.sort(function (a, b) {
    var pa = document.getPath(a.start.key);
    var pb = document.getPath(b.start.key);

    if (!pa || !pb) {
      return 0;
    }

    if (Path.isBefore(pa, pb)) {
      return -1;
    }

    if (Path.isAfter(pa, pb)) {
      return 1;
    }

    return a.start.offset < b.start.offset ? -1 : 1;
  });
  return [].concat(otherDecorations, newDecs);
}
//# sourceMappingURL=marksToDecorations.js.map