import React from 'react';
import { debounce } from 'lodash-es';
import fastdom from 'fastdom';
import { constants } from '@ali/4ever-cangjie';
import ResizeObserver from 'resize-observer-polyfill';
var DEBOUNCE_TIME = 300;
var docs = new WeakMap();
var CONTENT = "[" + constants.Selector.content + "]";
var EDITABLE = "[" + constants.Selector.editable + "]";
/**
 * size change, 触发 callback
 */

var handleSizeChange = function handleSizeChange(doc) {
  return function () {
    var doUpdate = function doUpdate(isWidthChanged, isHeightChanged) {
      var callbacks = doc.callbacks;

      try {
        // 移动端由于键盘弹起，可能会导致迅速的切换。
        // 这里 callback 使用了 findDOMNode，报错的话需要 ignore 掉
        callbacks.forEach(function (c) {
          return c(isWidthChanged, isHeightChanged);
        });
      } catch (error) {
        console.error(error);
      }
    };

    fastdom.measure(function () {
      var docNode = doc.docNode,
          prevHeight = doc.prevHeight,
          prevWidth = doc.prevWidth;

      var _docNode$getBoundingC = docNode.getBoundingClientRect(),
          width = _docNode$getBoundingC.width,
          height = _docNode$getBoundingC.height;

      var _ref = [Math.round(width), Math.round(height)],
          w = _ref[0],
          h = _ref[1];
      var isWidthChanged = prevWidth !== w;
      var isHeightChanged = prevHeight !== h;

      if (isWidthChanged || isHeightChanged) {
        // timeout 出于性能考虑，避免再 measure 期间调用更新
        setTimeout(function () {
          doUpdate(isWidthChanged, isHeightChanged);
        }, 0);
      }

      doc.prevWidth = w;
      doc.prevHeight = h;
    });
  };
};
/**
 * DOM 元素被移除的回调
 */


function onElementRemoved(element, onDetachCallback) {
  var observer = new MutationObserver(debounce(function () {
    var isDetached = function isDetached(el) {
      return !el.closest('html');
    };

    if (isDetached(element)) {
      observer.disconnect();
      onDetachCallback();
    }
  }, DEBOUNCE_TIME));
  observer.observe(element, {
    childList: true,
    subtree: true
  });
}

function addObserver(node, callback) {
  var _node$parentElement;

  var contentNode = (node == null ? void 0 : node.closest(CONTENT)) || (node == null ? void 0 : (_node$parentElement = node.parentElement) == null ? void 0 : _node$parentElement.querySelector(CONTENT));
  var docNode = contentNode == null ? void 0 : contentNode.querySelector(EDITABLE);

  if (!docNode) {
    return undefined;
  }

  var doc = docs.get(docNode);

  if (doc) {
    doc.callbacks.push(callback);
    return doc;
  }

  var callbacks = [callback];
  var newObj = {
    callbacks: callbacks,
    docNode: docNode
  };
  var changeCallback = handleSizeChange(newObj);
  var observer = new ResizeObserver(debounce(changeCallback, DEBOUNCE_TIME));
  observer.observe(docNode);
  onElementRemoved(docNode, function () {
    newObj.callbacks = [];
    observer.disconnect();
    docs["delete"](docNode);
  });
  changeCallback();
  docs.set(docNode, newObj);
  return newObj;
}

function removeObserver(doc, callback) {
  if (!doc) {
    return;
  }

  doc.callbacks = doc.callbacks.filter(function (c) {
    return c !== callback;
  });
}

export function useDocSize(nodeRef, callback) {
  React.useEffect(function () {
    var doc = addObserver(nodeRef.current, callback);
    return function () {
      removeObserver(doc, callback);
    };
  }, [callback, nodeRef]);
}
//# sourceMappingURL=useDocSize.js.map