"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _everCangjie = require("@ali/4ever-cangjie");

var _queries = require("../queries");

var _actions = require("../actions");

var _constants = require("../constants");

var _findDOMNodeByVoidKey = require("../utils/findDOMNodeByVoidKey");

var _models = require("../models");

const {
  IS_MOBILE,
  IS_IPAD
} = _everCangjie.environment;
const TOP_SPACE = IS_MOBILE && !IS_IPAD ? 20 : 100;
const BOTTOM_SPACE = 100;
const {
  findDOMNode,
  getScrollableContainerInfo,
  findScrollableContainer
} = _everCangjie.domUtils;

async function scrollToSelectionTop(options) {
  const {
    contentId,
    key,
    content,
    controller,
    scroller,
    heightPercent,
    bottomAlign,
    topExtraOffset
  } = options;

  if (key) {
    await _everCangjie.domUtils.scrollToNodeByKey(key, controller, true);
  }

  const domNode = (0, _findDOMNodeByVoidKey.findDOMNodeByVoidKey)(contentId, content) || content.querySelector(`[data-comment="${contentId}"]`);

  if (!domNode) {
    return;
  }

  _everCangjie.createPerfLazyRenderPlugin.showPrunedElements(domNode);

  let targetRect = domNode.getBoundingClientRect();

  if (targetRect && targetRect.height < 1) {
    targetRect = domNode.closest('[data-foldable]')?.getBoundingClientRect();
  }

  if (!targetRect) {
    return;
  }

  const {
    isWindow,
    scrollerTop,
    yOffset
  } = getScrollableContainerInfo(scroller);
  const viewportHeight = IS_MOBILE && !IS_IPAD ? BOTTOM_SPACE : Math.max(window.innerHeight * heightPercent, BOTTOM_SPACE);
  const alignY = bottomAlign ? targetRect.bottom : targetRect.top; // isInview: yOffset < targetOffsetTop < yOffset + viewportHeight
  // move: targetOffsetTop <= finalY <= targetOffsetTop + viewportHeight

  const targetOffsetTop = alignY + yOffset - scrollerTop;
  let y = yOffset;
  let inView = true;
  const topSpace = TOP_SPACE + topExtraOffset;

  if (targetOffsetTop < yOffset + topSpace) {
    // selection above viewport
    y = targetOffsetTop - topSpace;
    inView = false;
  } else if (targetOffsetTop > yOffset + viewportHeight) {
    // selection below viewport
    y = targetOffsetTop - viewportHeight;
    inView = false;
  }

  if (inView) {
    return;
  }

  if (isWindow) {
    window.scrollTo(window.scrollX, y);
  } else {
    // eslint-disable-next-line no-param-reassign
    scroller.scrollTop = y;
  }
}

async function updateComment(controller, contentId, options, configs) {
  const oldId = (0, _queries.getActiveId)(controller);

  if (oldId !== contentId) {
    controller.run('onAction', (0, _actions.setActiveId)(contentId, !options?.skipAutoFocus));
  }

  const skipScroll = oldId === contentId && !options?.alwaysScroll;

  if (options?.skipScroll || !contentId || skipScroll) {
    return;
  }

  try {
    const {
      document,
      decorations
    } = controller.value; // eslint-disable-next-line react/no-find-dom-node

    const content = findDOMNode(document.key);

    if (!content) {
      return;
    }

    const {
      heightPercent = _constants.SCROLL_HEIGHT_PERCENT
    } = options || {};
    const topExtraOffset = configs?.scrollTopExtraOffset || 0;
    const decoration = decorations.find(d => _models.ViewMark.isViewMark(d.mark) && d.mark.data.contentId === contentId);
    const key = decoration?.start?.key;
    scrollToSelectionTop({
      contentId,
      key,
      controller,
      content: content,
      scroller: controller.scrollableContainer,
      heightPercent,
      topExtraOffset,
      bottomAlign: configs?.scrollByBottomAlign && configs.scrollByBottomAlign()
    });
  } catch (error) {// ignore
  }
}

const cachedMap = {}; //  避免频繁设置，导致的闪烁问题

var _default = (controller, contentId, options, config) => {
  const doUpdate = () => updateComment(controller, contentId, options, config);

  const oldId = (0, _queries.getActiveId)(controller);

  if (oldId && cachedMap[oldId]) {
    window.clearTimeout(cachedMap[oldId]);
  }

  if (contentId && cachedMap[contentId]) {
    window.clearTimeout(cachedMap[contentId]);
  } // 如果有一个是 undefined


  const key = contentId || oldId;

  if (key && (!oldId || !contentId)) {
    // timeout 出于性能考虑，模拟 debounce 效果；这里后续是数据改动，无需清除
    const timer = window.setTimeout(doUpdate, 100);
    cachedMap[key] = timer;
  } else {
    doUpdate();
  }
};

exports.default = _default;
//# sourceMappingURL=showComment.js.map