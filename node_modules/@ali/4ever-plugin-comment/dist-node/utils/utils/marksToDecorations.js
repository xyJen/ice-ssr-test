"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.marksToDecorations = marksToDecorations;

var _everCangjie = require("@ali/4ever-cangjie");

var _marks = require("../models/marks");

var _queries = require("../queries");

var _getComments = _interopRequireDefault(require("../queries/getComments"));

/**
 * DataMark -> ViewMark
 */
function marksToDecorations(controller) {
  const comments = (0, _getComments.default)(controller);
  const {
    decorations,
    document
  } = controller.value;
  const activeContentId = (0, _queries.getActiveId)(controller); // 先过滤掉所有的 ViewMark

  const otherDecorations = decorations.filter(d => !_marks.ViewMark.isViewMark(d.mark));
  const texts = document.getTexts();
  let newDecs = decorations.filter(d => {
    if (_marks.ViewMark.isViewMark(d.mark) && d.mark.data.isNew) {
      const newcid = d.mark.data.contentId;
      return !comments.find(c => c.contentId === newcid);
    }

    return false;
  });
  const readOnlyDecs = decorations.filter(d => _marks.ViewMark.isViewMark(d.mark) && d.mark.data.isReadonly);
  newDecs = newDecs.concat(readOnlyDecs);
  newDecs = newDecs.map(d => {
    const mark = d.mark;
    const isActive = activeContentId === mark.data.contentId;
    return d.set('mark', _marks.ViewMark.create({ ...mark.data,
      isActive
    }));
  }); // 遍历每一个 mark，然后构建新的 View Decoration

  texts.forEach(text => {
    let offset = 0;
    text.leaves.forEach(leave => {
      leave.marks.forEach(m => {
        if (_marks.DataMark.isDataMark(m)) {
          const {
            contentId
          } = m.data;
          const item = comments.find(c => c.contentId === contentId);

          if (!item) {
            return;
          }

          const oldDec = newDecs.find(dec => dec.mark.data.contentId === contentId); // 如果这个 text 和 oldDec 的跨越太多（超过一个 block），就忽略掉

          if (oldDec) {
            const prevBlock = document.getClosestBlock(oldDec.end.key);
            const prevSucceedingBlock = document.getNextBlock(oldDec.end.key);
            const closestBlock = document.getClosestBlock(text.key);

            if (closestBlock !== prevBlock && closestBlock !== prevSucceedingBlock) {
              return;
            }
          }

          const start = oldDec?.start || _everCangjie.TextPoint.create({
            key: text.key,
            offset
          });

          const end = _everCangjie.TextPoint.create({
            key: text.key,
            offset: offset + leave.text.length
          });

          const {
            count,
            summary
          } = item;

          const newDec = _everCangjie.Decoration.create({
            start,
            end,
            mark: oldDec?.mark || _marks.ViewMark.create({
              contentId,
              count,
              summary,
              isActive: contentId === activeContentId
            })
          });

          if (oldDec) {
            newDecs = newDecs.map(d => {
              return d !== oldDec ? d : newDec;
            });
          } else {
            newDecs.push(newDec);
          }
        }
      });
      offset += leave.text.length;
    });
  });
  newDecs = newDecs.sort((a, b) => {
    const pa = document.getPath(a.start.key);
    const pb = document.getPath(b.start.key);

    if (!pa || !pb) {
      return 0;
    }

    if (_everCangjie.Path.isBefore(pa, pb)) {
      return -1;
    }

    if (_everCangjie.Path.isAfter(pa, pb)) {
      return 1;
    }

    return a.start.offset < b.start.offset ? -1 : 1;
  });
  return [...otherDecorations, ...newDecs];
}
//# sourceMappingURL=marksToDecorations.js.map