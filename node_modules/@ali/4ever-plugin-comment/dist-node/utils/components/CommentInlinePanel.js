"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = CommentInlinePanel;

var _react = _interopRequireDefault(require("react"));

var _everCangjie = require("@ali/4ever-cangjie");

var _marks = require("../models/marks");

var _getComments = _interopRequireDefault(require("../queries/getComments"));

var _getSiblings = _interopRequireDefault(require("../queries/getSiblings"));

var _actions = require("../actions");

var _findDOMNodeByVoidKey = require("../utils/findDOMNodeByVoidKey");

const _createElement = /*#__PURE__*/_react.default.createElement;

function CommentInlinePanel(props) {
  const {
    configs,
    onAdd,
    onDelete,
    enableAutoBlur,
    contentId
  } = props;

  const controller = _everCangjie.Controller.useController();

  const container = (0, _everCangjie.useZoomContainer)() || window.document.body;

  const [position, setPosition] = _react.default.useState();

  const comments = (0, _getComments.default)(controller);
  const item = comments.find(c => c.contentId === contentId);
  const {
    decorations
  } = controller.value;
  const decoration = decorations.find(d => _marks.ViewMark.isViewMark(d.mark) && d.mark.data.contentId === contentId);
  const mark = decoration?.mark;
  const {
    isNew,
    summary,
    position: rp
  } = mark?.data || {};

  _react.default.useEffect(() => {
    const voidNode = (0, _findDOMNodeByVoidKey.findDOMNodeByVoidKey)(contentId, container);
    const dom = container.querySelector(`[data-comment='${contentId}']`);
    const voidRect = voidNode?.getBoundingClientRect();
    const rects = voidRect ? [voidRect] : Array.from(dom?.getClientRects() || []);
    const rect = rects[rects.length - 1];

    if (!rect) {
      return;
    }

    const parent = container.getBoundingClientRect();
    const top = rect.bottom - parent.top;
    const left = rect.left + rect.width / 2 - parent.left;
    setPosition({
      top,
      left,
      width: parent.width,
      rects,
      parentRect: parent
    });
  }, [contentId, container, controller.value.decorations]);

  const {
    prev,
    next
  } = controller.query(_getSiblings.default);

  const navigateToPrev = _react.default.useCallback(() => {
    if (prev) {
      controller.run('onAction', (0, _actions.showComment)(prev));
    }
  }, [controller, prev]);

  const navigateToNext = _react.default.useCallback(() => {
    if (next) {
      controller.run('onAction', (0, _actions.showComment)(next));
    }
  }, [controller, next]);

  const cancelPopup = _react.default.useCallback(() => {
    controller.run('onAction', (0, _actions.hideComment)());
    controller.run('onAction', (0, _actions.cancelComment)());
  }, [controller]);

  if (!item && !decoration) {
    return null;
  }

  let readonlyPosition = '';

  if (isNew) {
    readonlyPosition = controller.readOnly ? rp : undefined;
  }

  const summaryText = summary || item?.summary || configs?.locale?.comment || '';
  const renderProps = {
    contentId,
    isActive: true,
    isAutoFocus: false,
    isNew: Boolean(isNew),
    summary: summaryText,
    readonlyPosition,
    onAdd,
    onDelete,
    prev,
    next,
    navigateToPrev,
    navigateToNext,
    cancelPopup,
    position
  };
  const children = configs?.renderCustomPopup && configs.renderCustomPopup(renderProps);
  return /*#__PURE__*/_createElement(_react.default.Fragment, null, children);
}
//# sourceMappingURL=CommentInlinePanel.js.map