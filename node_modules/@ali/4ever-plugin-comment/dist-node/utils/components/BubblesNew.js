"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var React = _interopRequireWildcard(require("react"));

var _styledComponents = _interopRequireDefault(require("styled-components"));

var _lodash = require("lodash");

var _everCangjie = require("@ali/4ever-cangjie");

var _marks = require("../models/marks");

var _findCommentPostion = require("../utils/findCommentPostion");

var _floatButton = require("./floatButton");

var _useDocSize = require("../hooks/useDocSize");

var _hoverCapture = _interopRequireDefault(require("../utils/hoverCapture"));

var _blockHoverEvent = _interopRequireDefault(require("../utils/blockHoverEvent"));

var _constants = require("../utils/constants");

const _createElement = /*#__PURE__*/React.createElement;

const BubblesWrapper = /*#__PURE__*/_styledComponents.default.div(["position:absolute;top:0;"]);

const SPACE_TO_DOC = _everCangjie.environment.IS_MOBILE ? -2 : 2;
const EFFECT_DEBOUNCE_TIME = 300;

function getSelectionFromBlock(block, controller) {
  const fakePoint = _everCangjie.TextPoint.create({
    key: '0',
    offset: 0
  });

  const emptySelection = _everCangjie.Selection.create({
    anchor: fakePoint,
    focus: fakePoint
  });

  const newRange = emptySelection.moveToRangeOfNode(block, controller).flip();
  return _everCangjie.Selection.create(newRange.convertToTextPoints(controller.value.document)).set('data', {
    isFromTable: block.type === 'table'
  });
}
/**
 * cangjie-content 和 document 的 rect 不同步。
 *
 * 由于计算是基于 document、渲染是在 content 里面，这里设置一下差值。
 */


function useRightSpace(controller, rightSpaceId) {
  const [space, setSapce] = React.useState(0);
  React.useEffect(() => {
    const {
      document
    } = controller.value; // eslint-disable-next-line react/no-find-dom-node

    const docNode = _everCangjie.domUtils.findDOMNodeSafely(document.key);

    const contentNode = docNode?.closest(`[${_everCangjie.constants.Selector.content}]`);

    if (!docNode || !contentNode) {
      return;
    }

    const {
      right: docRight
    } = docNode.getBoundingClientRect();
    const {
      right: contentRight
    } = contentNode.getBoundingClientRect();
    const rightSpace = Math.max(0, contentRight - docRight);
    setSapce(rightSpace);
  }, [controller, rightSpaceId]);
  return space;
}

function BubblesNew({
  configs,
  controller
}) {
  const {
    disableRangeAdd,
    onBubbleClick
  } = configs || {};
  const container = (0, _everCangjie.useZoomContainer)();
  const [bubbles, setBubbles] = React.useState([]);
  const ref = React.useRef(null);
  const [hoverBlock, setHoverBlock] = React.useState(undefined);
  const handleHover = React.useCallback(({
    block
  }) => {
    if (hoverBlock !== block) {
      setHoverBlock(block);
    }
  }, [hoverBlock]);
  React.useEffect(() => {
    _hoverCapture.default.on(handleHover);

    return () => _hoverCapture.default.off(handleHover);
  }, [handleHover]);
  const {
    decorations,
    document,
    selection
  } = controller.value;
  const updatePosition = React.useCallback(() => {
    const commentDecorations = decorations.filter(d => {
      return _marks.ViewMark.isViewMark(d.mark);
    });
    const hasHardSelection = selection?.isExpanded || selection && document.getClosestVoid(selection.anchor.key, controller) && controller.value.isFocused;
    let range;

    if (hasHardSelection && !disableRangeAdd) {
      range = selection;
    } else if (hoverBlock && selection.isCollapsed) {
      range = getSelectionFromBlock(hoverBlock, controller);
    }

    const rowItems = (0, _findCommentPostion.findCommentPostion)({
      controller,
      decorations: commentDecorations,
      selection: range,
      container: container || undefined,
      isFromPopup: false
    });
    const {
      top: refTop = 0
    } = ref.current?.getBoundingClientRect() || {}; // eslint-disable-next-line react/no-find-dom-node

    const documentNode = _everCangjie.domUtils.findDOMNodeSafely(document.key);

    if (!documentNode) {
      return;
    }

    const {
      top: docTop
    } = documentNode.getBoundingClientRect();
    rowItems.forEach(item => {
      // 如果存在 hover 选区、并且还有其他的气泡，就把选区去除掉
      if (item && !hasHardSelection && item.selection && item.decorations.length > 0) {
        item.selection = undefined;
      }
    });
    const newBubbles = rowItems.reduce((array, item) => {
      const isMultiple = item.decorations.length > 1;
      const decoration = item.decorations[0];
      const top = item.top + docTop - refTop + _constants.BUTTON_SIZE / 2;
      const isAdd = Boolean(item.selection);
      const newRange = isAdd && range ? {
        range,
        isHard: Boolean(hasHardSelection)
      } : undefined;
      let count = 1;
      let contentId = '';

      if (decoration) {
        const mark = decoration.mark;
        ({
          contentId,
          count
        } = mark.data);
      }

      array.push({
        top,
        isMultiple,
        count,
        newRange,
        contentId
      });
      return array;
    }, []);
    setBubbles(newBubbles);
  }, [decorations, selection, document, controller, disableRangeAdd, hoverBlock, container]);
  const [rightSpaceId, updateRightSpace] = React.useReducer(s => s + 1, 0);
  const tryUpdateRightSpace = React.useCallback(isWidthChanged => {
    if (isWidthChanged) {
      updateRightSpace();
    }
  }, []);
  (0, _useDocSize.useDocSize)(ref, updatePosition);
  (0, _useDocSize.useDocSize)(ref, tryUpdateRightSpace);
  React.useEffect(() => {
    const debouncedFunc = (0, _lodash.debounce)(updatePosition, EFFECT_DEBOUNCE_TIME);
    debouncedFunc();
    return () => {
      debouncedFunc.cancel();
    };
  }, [updatePosition]);
  const handleHovered = React.useCallback(isHover => {
    if (hoverBlock) {
      _blockHoverEvent.default.trigger({
        block: hoverBlock,
        isHover
      });
    }
  }, [hoverBlock]);
  const rightSpace = useRightSpace(controller, rightSpaceId);
  const zoom = (0, _everCangjie.useZoom)();
  const wrapperStyle = React.useMemo(() => ({
    right: `${(rightSpace - _constants.BUTTON_SIZE - SPACE_TO_DOC) / zoom}px`
  }), [rightSpace, zoom]);
  return /*#__PURE__*/_createElement(BubblesWrapper, {
    "data-comment-bubblesnew": true,
    ref: ref,
    style: wrapperStyle
  }, bubbles.map(bubble => {
    const {
      newRange,
      contentId,
      isMultiple,
      count,
      top
    } = bubble;

    if (newRange && !_everCangjie.environment.IS_MOBILE) {
      return /*#__PURE__*/_createElement(_floatButton.CommentAddButton, {
        key: contentId,
        controller: controller,
        range: newRange.range,
        onHover: newRange.isHard ? undefined : handleHovered,
        top: top / zoom,
        tips: configs?.locale?.addComment
      });
    }

    if (!newRange) {
      return /*#__PURE__*/_createElement(_floatButton.CommentBubble, {
        key: contentId,
        controller: controller,
        isMultiple: isMultiple,
        count: count,
        contentId: contentId,
        showInline: configs?.showInline,
        tips: configs?.locale?.showComent,
        top: Math.round(top / zoom),
        onBubbleClick: onBubbleClick
      });
    }

    return null;
  }));
}

var _default = BubblesNew;
exports.default = _default;
//# sourceMappingURL=BubblesNew.js.map