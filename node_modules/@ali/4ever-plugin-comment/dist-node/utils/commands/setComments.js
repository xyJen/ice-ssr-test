"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = setComments;

var _everCangjie = require("@ali/4ever-cangjie");

var _fastDeepEqual = _interopRequireDefault(require("fast-deep-equal"));

var _marks = require("../models/marks");

var _marksToDecorations = require("../utils/marksToDecorations");

var _readonlySerializer = require("../utils/readonlySerializer");

const lastUpdatedDocMap = new WeakMap();

function setComments(controller, comments) {
  const {
    document,
    data
  } = controller.value;
  const {
    _commentsCachedData: prevData
  } = data;
  const isSameCommentsData = (0, _fastDeepEqual.default)(comments, prevData); // skipped seting same comments

  if (!isSameCommentsData) {
    controller.setData({ ...data,
      _commentsCachedData: comments
    });
  }

  let newDecs = [];
  comments.forEach(comment => {
    if (!comment.position) {
      return;
    }

    const decoration = (0, _readonlySerializer.deserialize)(comment, document);
    decoration && newDecs.push(decoration);
  });
  const updatedDecos = (0, _marksToDecorations.marksToDecorations)(controller);

  if (!(0, _fastDeepEqual.default)(updatedDecos, controller.value.decorations)) {
    controller.setDecorations(updatedDecos);
  }

  const {
    decorations
  } = controller.value;
  newDecs = newDecs.filter(dec => {
    const mark = dec.mark;

    if (decorations.find(d => _marks.ViewMark.isViewMark(d.mark) && d.mark.data.contentId === mark.data.contentId)) {
      return false;
    }

    return true;
  });

  if (!newDecs.length) {
    return controller.flush();
  }

  const prevDoc = lastUpdatedDocMap.get(controller);
  /**
   * 自上次更新后，comments 和 document 均无变化，就不需要在继续了。
   *
   * 这里是保障，万一 addMark 不生效，会导致无限循环的问题：
   * addMark -> document change -> setComments -> addMark
   */

  if (isSameCommentsData && prevDoc === document) {
    return controller.flush();
  }

  newDecs.forEach(dec => {
    const mark = dec.mark;
    const anchor = dec.start;
    const focus = dec.end;
    const {
      contentId
    } = mark.data;

    const dataMark = _marks.DataMark.create({
      contentId
    });

    const range = _everCangjie.Selection.create({
      anchor,
      focus
    });

    const isValid = _everCangjie.Selection.isValidRangeSelection(document, range);

    if (!isValid) {
      return;
    }

    if (range.isCollapsed) {
      const node = document.getNode(anchor.key);
      /**
       * 如果 Text 节点非空，decorations 校验会过滤掉。
       */

      if (node?.text) {
        /**
         * 对 Code 的特殊处理。
         * TODO：Code 插件重构后，移除这里。
         */
        const parent = document.getParent(anchor.key);

        if (node.isText() && parent?.isBlock() && parent.type === 'code') {
          controller.command(_everCangjie.Commands.addMarkByKey, node.key, 0, node.text.length, dataMark);
        }
      } else {
        controller.command(_everCangjie.Commands.addMarkByKey, anchor.key, 0, 0, dataMark);
      }
    } else {
      controller.command(_everCangjie.Commands.addMarkAtRange, range, dataMark);
    }
  });
  lastUpdatedDocMap.set(controller, controller.value.document);
  return controller.setDecorations((0, _marksToDecorations.marksToDecorations)(controller)).flush();
}
//# sourceMappingURL=setComments.js.map