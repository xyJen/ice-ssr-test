"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getRowTopFromPoint = getRowTopFromPoint;

var _everCangjie = require("@ali/4ever-cangjie");

// Block 元素顶部的偏移，主要处理 border-radius 情况。
const BLOCK_TOP_OFFSET = 6; // sidebar POPUP 时的偏移。

const BLOCK_TOP_OFFSET_POPUP = -1; // 大于此值，会视为 Block 元素，定位到右上角；否则视为 Inline 元素，定位到光标中间

const SAMPLE_BLOCK_HEIGHT = 41;

/**
 * 光标位置处理。由于 void 节点内的光标无法定位，尝试获取前一个位置
 */
function corretCaretPoint(controller, point) {
  const {
    document
  } = controller.value;

  if (document.getClosestVoid(point.key, controller) || document.getParent(point.key)?.type === 'code') {
    return controller.query(_everCangjie.Queries.pointAtDistance, point, -1);
  }

  return point;
}
/**
 * 根据 key 获取 document 下面的一级节点
 */


function getRootBlock(document, pointKey) {
  const path = document.getPath(pointKey);
  const firstPath = path && path.slice(0, 1);
  const firstRoot = firstPath?.length ? document.getNodeByPath(firstPath) : null;
  return firstRoot;
}
/**
 * 根据 top 坐标，获取对应的分行（row）
 */


function findRow(params) {
  const {
    docTop,
    top,
    pointKey,
    document,
    allRows,
    container
  } = params;
  const firstRoot = getRootBlock(document, pointKey);

  if (!firstRoot) {
    return undefined;
  }

  const {
    key: rootKey
  } = firstRoot;
  let cachedRows = allRows[rootKey];

  if (!cachedRows) {
    const domNode = _everCangjie.domUtils.findDOMNodeSafely(firstRoot.key, container);

    const newRows = domNode && _everCangjie.domUtils.splitRows(domNode);

    if (!newRows || !newRows.length) {
      return undefined;
    }

    const {
      top: clientTop,
      height
    } = domNode.getBoundingClientRect();
    newRows.forEach(r => {
      // eslint-disable-next-line no-param-reassign
      r.top -= clientTop;
    });
    cachedRows = {
      top: clientTop - docTop,
      height,
      points: [],
      rows: newRows
    };
    allRows[rootKey] = cachedRows;
  }

  const {
    rows,
    top: blockTop
  } = cachedRows;
  const targetTop = top - blockTop;

  for (let index = 0; index < rows.length; index++) {
    const row = rows[index];

    if (row.top + row.height > targetTop) {
      return {
        row,
        cachedRows
      };
    }
  }

  const row = rows[rows.length - 1];
  return {
    row,
    cachedRows
  };
}

/**
 * 根据一个 point，获取对应的分行（row）、相对于 document 的 offsetTop
 */
function getRowTopFromPoint(params) {
  const {
    controller,
    paramPoint,
    isFromPopup,
    docTop,
    container,
    allRows
  } = params;
  const {
    document
  } = controller.value;
  const blockTopOffset = isFromPopup ? BLOCK_TOP_OFFSET_POPUP : BLOCK_TOP_OFFSET;
  let targetPoint = paramPoint;

  if (!targetPoint || !document.getNode(targetPoint.key)) {
    return undefined;
  } // 0. 处理折叠逻辑等特殊场景，修正 point


  const block = document.getClosestBlock(targetPoint.key);
  const foldBlocks = block && controller.query('getHeadingAncestors', block);
  const firstFoldBlock = foldBlocks && foldBlocks.find(b => controller.userData.get(b, 'fold'));
  const firstFoldText = firstFoldBlock?.getFirstText(); // 气泡形式，如果被折叠，就直接藏起来

  if (!isFromPopup && firstFoldText) {
    return undefined;
  } // 非气泡形式，如果被折叠，就找到折叠的段落


  if (firstFoldText) {
    targetPoint = _everCangjie.TextPoint.create({
      key: firstFoldText.key,
      offset: 0
    });
  }

  const point = corretCaretPoint(controller, targetPoint); // 1. 这里开始正式分行计算，获取 point 的 key

  const pointCacheKey = point.viewKey; // 1.1 先查有没有缓存，有的话， 就不需要计算了

  const firstRoot = getRootBlock(document, point.key);

  if (firstRoot) {
    const cachedRows = firstRoot && allRows[firstRoot.key];
    const cachedPoint = cachedRows?.points.find(p => p.key === pointCacheKey);

    if (cachedRows && cachedPoint) {
      const {
        caretTop,
        row
      } = cachedPoint;
      const rowTop = cachedRows.top + row.top;
      return [Math.round(rowTop), Math.round(caretTop)];
    }
  } // 2. 没有缓存，开始获取高度


  const caretPosition = _everCangjie.domUtils.findCaretPosition(point);

  const caretClientTop = caretPosition?.clientTop;

  if (typeof caretClientTop !== 'number') {
    return undefined;
  } // 3. 计算分行（row）


  const result = findRow({
    top: caretClientTop - docTop,
    docTop,
    pointKey: point.key,
    document,
    container,
    allRows
  });

  if (!result) {
    return undefined;
  }

  const {
    row,
    cachedRows
  } = result;
  const {
    height: rowHeight,
    top: rowOffsetTop
  } = row;
  const rowTop = cachedRows.top + rowOffsetTop; // case 1：分行
  // case 2：整个 void block

  const top = rowHeight <= SAMPLE_BLOCK_HEIGHT ? caretClientTop - docTop : rowTop + blockTopOffset; // 4. 存到缓存里

  cachedRows.points.push({
    key: pointCacheKey,
    caretTop: Math.round(top),
    row
  });
  return [Math.round(rowTop), Math.round(top)];
}
//# sourceMappingURL=getRowTopFromPoint.js.map