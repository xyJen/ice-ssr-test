"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useDocSize = useDocSize;

var _react = _interopRequireDefault(require("react"));

var _lodash = require("lodash");

var _fastdom = _interopRequireDefault(require("fastdom"));

var _everCangjie = require("@ali/4ever-cangjie");

var _resizeObserverPolyfill = _interopRequireDefault(require("resize-observer-polyfill"));

const DEBOUNCE_TIME = 300;
const docs = new WeakMap();
const CONTENT = `[${_everCangjie.constants.Selector.content}]`;
const EDITABLE = `[${_everCangjie.constants.Selector.editable}]`;
/**
 * size change, 触发 callback
 */

const handleSizeChange = doc => () => {
  const doUpdate = (isWidthChanged, isHeightChanged) => {
    const {
      callbacks
    } = doc;

    try {
      // 移动端由于键盘弹起，可能会导致迅速的切换。
      // 这里 callback 使用了 findDOMNode，报错的话需要 ignore 掉
      callbacks.forEach(c => c(isWidthChanged, isHeightChanged));
    } catch (error) {
      console.error(error);
    }
  };

  _fastdom.default.measure(() => {
    const {
      docNode,
      prevHeight,
      prevWidth
    } = doc;
    const {
      width,
      height
    } = docNode.getBoundingClientRect();
    const [w, h] = [Math.round(width), Math.round(height)];
    const isWidthChanged = prevWidth !== w;
    const isHeightChanged = prevHeight !== h;

    if (isWidthChanged || isHeightChanged) {
      // timeout 出于性能考虑，避免再 measure 期间调用更新
      setTimeout(() => {
        doUpdate(isWidthChanged, isHeightChanged);
      }, 0);
    }

    doc.prevWidth = w;
    doc.prevHeight = h;
  });
};
/**
 * DOM 元素被移除的回调
 */


function onElementRemoved(element, onDetachCallback) {
  const observer = new MutationObserver((0, _lodash.debounce)(() => {
    const isDetached = el => !el.closest('html');

    if (isDetached(element)) {
      observer.disconnect();
      onDetachCallback();
    }
  }, DEBOUNCE_TIME));
  observer.observe(element, {
    childList: true,
    subtree: true
  });
}

function addObserver(node, callback) {
  const contentNode = node?.closest(CONTENT) || node?.parentElement?.querySelector(CONTENT);
  const docNode = contentNode?.querySelector(EDITABLE);

  if (!docNode) {
    return undefined;
  }

  const doc = docs.get(docNode);

  if (doc) {
    doc.callbacks.push(callback);
    return doc;
  }

  const callbacks = [callback];
  const newObj = {
    callbacks,
    docNode
  };
  const changeCallback = handleSizeChange(newObj);
  const observer = new _resizeObserverPolyfill.default((0, _lodash.debounce)(changeCallback, DEBOUNCE_TIME));
  observer.observe(docNode);
  onElementRemoved(docNode, () => {
    newObj.callbacks = [];
    observer.disconnect();
    docs.delete(docNode);
  });
  changeCallback();
  docs.set(docNode, newObj);
  return newObj;
}

function removeObserver(doc, callback) {
  if (!doc) {
    return;
  }

  doc.callbacks = doc.callbacks.filter(c => c !== callback);
}

function useDocSize(nodeRef, callback) {
  _react.default.useEffect(() => {
    const doc = addObserver(nodeRef.current, callback);
    return () => {
      removeObserver(doc, callback);
    };
  }, [callback, nodeRef]);
}
//# sourceMappingURL=useDocSize.js.map