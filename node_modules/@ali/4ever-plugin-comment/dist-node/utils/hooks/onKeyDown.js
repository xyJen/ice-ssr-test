"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _everCangjie = require("@ali/4ever-cangjie");

var _isHotkey = require("is-hotkey");

var _actions = require("../actions");

var _marks = require("../models/marks");

var _hoverCapture = _interopRequireDefault(require("../utils/hoverCapture"));

const isCommentHotkey = (0, _isHotkey.isKeyHotkey)('mod+shift+m');
const isBackspaceHotKey = (0, _isHotkey.isKeyHotkey)('backspace');
const isEnterHotKey = (0, _isHotkey.isKeyHotkey)('enter');
/**
 * 在新行中，过滤掉评论标记。
 *
 * 目前 mark 和底层耦合很深，无法在新行、输入时，过滤掉 mark。这里在插件手动过滤。
 */

function filterCommentMarkInNewLine(controller) {
  const {
    focusBlock,
    selection
  } = controller.value; // 用户按 Enter 键后，我们在一个新行

  if (selection.isCollapsed && focusBlock && !focusBlock.text && _everCangjie.Text.isText(focusBlock.nodes[0])) {
    const text = focusBlock.nodes[0];
    const leave = text.leaves.length === 1 ? text.leaves[0] : null;
    const mark = leave?.marks.find(m => _marks.DataMark.isDataMark(m));

    if (leave && mark) {
      const newLeave = leave.set('marks', leave.marks.filter(m => m !== mark));
      const newText = text.set('leaves', [newLeave]);
      const {
        key
      } = newText;
      const offset = 0;

      const newSelection = _everCangjie.Selection.create({
        anchor: _everCangjie.TextPoint.create({
          key,
          offset
        }),
        focus: _everCangjie.TextPoint.create({
          key,
          offset
        })
      });

      controller.command(_everCangjie.Commands.replaceNodeByKey, text.key, newText).command(_everCangjie.Commands.select, newSelection);
    }
  }
}

var _default = configs => {
  return function onKeyDown(event, controller, next) {
    if (configs?.isDisabled && configs.isDisabled()) {
      return next();
    }

    const {
      value
    } = controller;
    const {
      selection
    } = value;

    if (selection.isCollapsed && isEnterHotKey(event)) {
      const res = next();
      filterCommentMarkInNewLine(controller);
      return res;
    }

    if (isBackspaceHotKey(event)) {
      _hoverCapture.default.trigger();
    }

    if (selection.isCollapsed || !isCommentHotkey(event)) return next();
    event.preventDefault();
    controller.run('onAction', {
      type: _actions.ACTION_COMMENT_CLICK
    });
  };
};

exports.default = _default;
//# sourceMappingURL=onKeyDown.js.map