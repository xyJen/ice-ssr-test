"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Modal = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _react = _interopRequireWildcard(require("react"));
var _reactDom = _interopRequireDefault(require("react-dom"));
var _resizeObserverPolyfill = _interopRequireDefault(require("resize-observer-polyfill"));
var _button = require("../../basic/button");
var _iconButton = require("../../basic/icon-button");
var _ModalFooter = require("./ModalFooter");
var _ModalHeader = require("./ModalHeader");
var _styled = require("./styled");
var _icon = require("../../basic/icon");
var _locale = require("../../locale");
var _consts = require("../../common/consts");
var _common = require("../../common");
var _IconClose;
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const _createElement = /*#__PURE__*/_react.default.createElement;
const Modal = /*#__PURE__*/_react.default.memo( /*#__PURE__*/_react.default.forwardRef((props, fRef) => {
  const {
    title,
    footer,
    header,
    content,
    visible,
    onConfirm,
    onCancel,
    onClose,
    mask,
    dragMove: dragable,
    defaultPlacement = 'center',
    getContainer = () => document.body,
    ...rest
  } = props;
  const ref = (0, _react.useRef)(null);
  const headerRef = (0, _react.useRef)(null);
  (0, _react.useEffect)(() => {
    if (visible && ref.current) {
      const aligner = createAligner(ref.current, defaultPlacement);
      if (typeof dragable === 'object') {
        aligner.setAdditionalConstraint(dragable.constraint);
      }
      const dragger = dragable && headerRef.current ? createDragger(headerRef.current, aligner.getOffset, aligner.setOffset) : null;
      return () => {
        aligner.destroy();
        dragger && dragger.destroy();
      };
    }
  }, [visible, !!dragable]);
  (0, _react.useEffect)(() => {
    if (onClose) {
      const fn = e => {
        if (e.keyCode === _consts.KEY_CODES.ESC) {
          onClose();
        }
      };
      document.addEventListener('keydown', fn);
      return () => {
        document.removeEventListener('keydown', fn);
      };
    }
  }, [onClose]);
  const t = (0, _locale.useTranslate)();
  return visible ? /*#__PURE__*/_reactDom.default.createPortal( /*#__PURE__*/_createElement(_styled.MoadlRoot, null, mask ? /*#__PURE__*/_createElement(_styled.ModalMask, {
    isTransparent: mask === 'transparent'
  }) : null, /*#__PURE__*/_createElement(_styled.ModalContainer, (0, _extends2.default)({}, (0, _common.mergeRestProps)(rest, 'wdn-modal'), {
    ref: (0, _common.mergeRef)(fRef, ref)
  }), (0, _common.renderReactNode)(header, /*#__PURE__*/_createElement(_ModalHeader.ModalHeader, {
    ref: headerRef
  }, /*#__PURE__*/_createElement(_styled.ModalHeaderTitle, {
    move: !!dragable
  }, title), /*#__PURE__*/_createElement(_iconButton.IconButton, {
    icon: _IconClose || (_IconClose = /*#__PURE__*/_createElement(_icon.IconClose, null)),
    onClick: onClose,
    style: {
      marginBottom: 16
    }
  })), undefined), /*#__PURE__*/_createElement(_styled.ModalContent, null, content), (0, _common.renderReactNode)(footer, /*#__PURE__*/_createElement(_ModalFooter.ModalFooter, {
    cancel: /*#__PURE__*/_createElement(_button.Button, {
      onClick: onCancel
    }, t('wdn_cancel')),
    confirm: /*#__PURE__*/_createElement(_button.Button, {
      type: "primary",
      onClick: onConfirm
    }, t('wdn_ok'))
  }), undefined))), getContainer()) : null;
}));
exports.Modal = Modal;
const createAligner = (ele, placement) => {
  const offsets = [0, 0];
  let isAutoAlign = true;
  let isStickingRight = false;
  let isStickingBottom = false;
  const placementAligner = (start, end) => {
    const per = s => {
      const r = s.match(/^(\d+)%$/);
      if (r && r[1]) {
        const n = parseInt(r[1]);
        if (n >= 0 && n <= 100) {
          return n / 100;
        }
      }
      return 0;
    };
    let [x, rx, px, prx] = [null, null, null, null];
    if (typeof start === 'number') {
      x = start;
    } else if (typeof start === 'string') {
      px = per(start);
    } else if (typeof end === 'number') {
      rx = end;
    } else if (typeof end === 'string') {
      prx = per(end);
    } else {
      // start is undefined, and end is undefined
      px = 0.5;
    }
    return (clientSize, winSize) => {
      if (x !== null) {
        return x;
      } else if (rx !== null) {
        return winSize - rx - clientSize;
      } else if (px !== null) {
        return Math.floor(winSize * px - clientSize / 2);
      } else if (prx !== null) {
        return Math.ceil(winSize - winSize * prx - clientSize / 2);
      } else {
        return Math.floor(winSize * 0.5 - clientSize / 2);
      }
    };
  };
  const alignX = placement === 'center' ? placementAligner('50%') : placementAligner(placement.left, placement.right);
  const alignY = placement === 'center' ? placementAligner('50%') : placementAligner(placement.top, placement.bottom);

  /**
   * 将线段 [start, size] 限制在区间 [min, max] 中, 返回新线段的 start。
   */
  const constraint = (start, size, min, max) => {
    if (max <= min) {
      return min;
    }
    if (start < min) {
      return min;
    }
    if (start + size > max) {
      return max - size;
    }
    return start;
  };
  let additionConstraint = v => [v.left, v.top];
  const align = () => {
    const [width, height] = [ele.clientWidth, ele.clientHeight];
    const [winWidth, winHeight] = [document.documentElement.clientWidth, document.documentElement.clientHeight];
    const ax = isAutoAlign ? alignX(width, winWidth) : isStickingRight ? winWidth - width : offsets[0];
    const ay = isAutoAlign ? alignY(height, winHeight) : isStickingBottom ? winHeight - height : offsets[1];
    const cx = constraint(ax, width, 0, winWidth);
    const cy = constraint(ay, height, 0, winHeight);
    const [tx, ty] = additionConstraint({
      left: cx,
      width,
      top: cy,
      height
    });
    if (tx + width >= winWidth - 1) {
      isStickingRight = true;
    }
    if (ty + height >= winHeight - 1) {
      isStickingBottom = true;
    }
    offsets[0] = tx;
    offsets[1] = ty;
    ele.style.transform = `translate(${tx}px, ${ty}px)`;
  };
  const eleResizeObserver = new _resizeObserverPolyfill.default(align);
  eleResizeObserver.observe(ele);
  const winResizeObserver = new _resizeObserverPolyfill.default(align);
  winResizeObserver.observe(document.documentElement);
  return {
    getOffset: () => {
      return [...offsets];
    },
    setOffset: source => {
      isAutoAlign = false;
      offsets[0] = source[0];
      offsets[1] = source[1];
      isStickingRight = false;
      isStickingBottom = false;
      align();
    },
    setAdditionalConstraint: fn => {
      additionConstraint = v => {
        const r = fn();
        return [constraint(v.left, v.width, r.left, r.left + r.width), constraint(v.top, v.height, r.top, r.top + r.height)];
      };
    },
    destroy: () => {
      eleResizeObserver.disconnect();
      winResizeObserver.disconnect();
    }
  };
};
const createDragger = (ele, getOffset, setOffset) => {
  let isDragging = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let dragStartOffset = getOffset();
  const dragMove = e => {
    if (isDragging && dragStartOffset !== null) {
      const dx = e.pageX - dragStartX;
      const dy = e.pageY - dragStartY;
      setOffset([dragStartOffset[0] + dx, dragStartOffset[1] + dy]);
    }
  };
  const dragStart = e => {
    if (isDragging) {
      return;
    }
    dragStartX = e.pageX;
    dragStartY = e.pageY;
    dragStartOffset = getOffset();
    isDragging = true;
    document.addEventListener('mousemove', dragMove);
    document.addEventListener('mouseup', dragEnd);
  };
  const dragEnd = e => {
    isDragging = false;
    dragStartOffset = null;
    document.removeEventListener('mousemove', dragMove);
    document.removeEventListener('mouseup', dragEnd);
  };
  const attach = () => {
    ele.addEventListener('mousedown', dragStart);
  };
  const detach = () => {
    ele.removeEventListener('mousedown', dragStart);
    document.removeEventListener('mousemove', dragMove);
    document.removeEventListener('mouseup', dragEnd);
  };
  attach();
  return {
    destroy: detach
  };
};
//# sourceMappingURL=Modal.js.map