"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TabsBar = void 0;
var _react = _interopRequireDefault(require("react"));
var _styledComponents = _interopRequireDefault(require("styled-components"));
var _resizeObserverPolyfill = _interopRequireDefault(require("resize-observer-polyfill"));
var _lodash = require("lodash");
var _icon = require("../../basic/icon");
var _TabsBarTab = require("./TabsBarTab");
var _common = require("../../common");
var _button = require("../../basic/button");
var _popover = require("../popover");
var _menu = require("../menu");
var _styled = require("./styled");
var _constants = require("./constants");
var _Button;
const _createElement = /*#__PURE__*/_react.default.createElement;
const TabsNav = /*#__PURE__*/_styledComponents.default.div(["display:flex;position:relative;overflow:hidden;flex:none;&::after{content:'';position:absolute;height:1px;left:0px;right:0px;bottom:0px;background:rgba(126,134,142,0.16);}"]);
const TabsNavWrap = /*#__PURE__*/_styledComponents.default.div(["position:relative;display:inline-block;display:flex;flex:auto;align-self:stretch;overflow:hidden;white-space:nowrap;transform:translate(0);"]);
const TabsNavList = /*#__PURE__*/_styledComponents.default.div(["position:relative;display:flex;"]);
const TabsNavOperationWrapper = /*#__PURE__*/_styledComponents.default.div(["display:flex;position:relative;align-items:center;align-self:stretch;padding-left:10px;padding-bottom:3px;background:", ";&.tabs-can-scroll-to-left::after{left:-30px;top:0px;bottom:0px;width:30px;content:\"\";position:absolute;pointer-events:none;transition:opacity 0.3s ease 0s;box-shadow:rgb(0 0 0 / 8%) -10px 0px 8px -8px inset;}"], _common.COLORS.WHITE);
const btnStyle = {
  border: 'none',
  padding: 0,
  height: 28,
  width: 28,
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center'
};
const operaIconStyle = {
  fontSize: 20
};
const TabsBar = props => {
  var _tabs$;
  const {
    activeKey: activeKeyProp,
    defaultActiveKey,
    onActiveTabChange,
    tabs,
    animated
  } = props;
  const [isOperaBoxVisible, setOperaBoxVisible] = _react.default.useState(false);
  const [activeKey, setActiveKey] = (0, _common.useDefaultProp)(defaultActiveKey || ((_tabs$ = tabs[0]) === null || _tabs$ === void 0 ? void 0 : _tabs$.key), activeKeyProp, onActiveTabChange);
  const navRef = _react.default.useRef(null);
  const navWrapRef = _react.default.useRef(null);
  const navListRef = _react.default.useRef(null);
  const scrollOffsetRef = _react.default.useRef(0);
  const lastWheelDirectionRef = _react.default.useRef('');
  const inkBarRef = _react.default.useRef(null);
  const operaWrapRef = _react.default.useRef(null);
  const [isMorePopoverVisible, setMorePopoverVisible] = _react.default.useState(false);
  const tabRefs = _react.default.useRef({});
  const navWidthRef = _react.default.useRef(0);
  const navWrapWidthRef = _react.default.useRef(0);
  const navListWidthRef = _react.default.useRef(0);
  const activeKeyRef = _react.default.useRef(activeKey);
  activeKeyRef.current = activeKey;
  const onTabRef = _react.default.useCallback((key, elem) => {
    tabRefs.current[key] = elem;
  }, []);
  const updateWidth = _react.default.useCallback(() => {
    var _navRef$current, _navListRef$current, _navWrapRef$current;
    navWidthRef.current = ((_navRef$current = navRef.current) === null || _navRef$current === void 0 ? void 0 : _navRef$current.offsetWidth) || 0;
    navListWidthRef.current = ((_navListRef$current = navListRef.current) === null || _navListRef$current === void 0 ? void 0 : _navListRef$current.offsetWidth) || 0;
    navWrapWidthRef.current = ((_navWrapRef$current = navWrapRef.current) === null || _navWrapRef$current === void 0 ? void 0 : _navWrapRef$current.offsetWidth) || 0;
  }, []);
  const updateScrollOffset = _react.default.useCallback(newScroll => {
    if (!navListRef.current) return;
    scrollOffsetRef.current = newScroll;
    navListRef.current.style.left = newScroll + 'px';
    if (operaWrapRef.current) {
      const canScrollToLeft = scrollOffsetRef.current > navWrapWidthRef.current - navListWidthRef.current;
      if (canScrollToLeft) {
        operaWrapRef.current.classList.add('tabs-can-scroll-to-left');
      } else {
        operaWrapRef.current.classList.remove('tabs-can-scroll-to-left');
      }
    }
  }, []);
  _react.default.useEffect(() => {
    updateWidth();
  }, []);
  const updateInk = _react.default.useCallback(() => {
    if (!inkBarRef.current) return;
    const activeTab = tabRefs.current[activeKeyRef.current];
    if (!activeTab) {
      inkBarRef.current.style.left = '0px';
      inkBarRef.current.style.width = '0px';
    } else {
      var _tabRefs$current$acti;
      const activeTabWrapper = activeTab.parentElement;
      const newOffset = activeTabWrapper.offsetLeft;
      inkBarRef.current.style.left = newOffset + 'px';
      const newWidth = ((_tabRefs$current$acti = tabRefs.current[activeKeyRef.current]) === null || _tabRefs$current$acti === void 0 ? void 0 : _tabRefs$current$acti.offsetWidth) || 0;
      inkBarRef.current.style.width = newWidth + 'px';
    }
  }, []);
  const initScrollOffset = _react.default.useCallback(() => {
    const activeTab = tabRefs.current[activeKeyRef.current];
    if (!navListRef.current || !navWrapRef.current || !activeKeyRef.current || !activeTab) {
      return;
    }
    const navWrapWidth = navWrapWidthRef.current || navWrapRef.current.offsetWidth;
    const navListWidth = navListWidthRef.current || navListRef.current.offsetWidth;
    const currentOffset = parseFloat(navListRef.current.style.left);
    const activeTabWrapper = activeTab.parentElement;
    const startOffset = activeTabWrapper.offsetLeft;
    const activeTabWidth = activeTab.offsetWidth || 0;
    const minOffset = Math.min(0, Math.max(navWrapWidth - navListWidth, -startOffset));
    let maxOffset = navWrapWidth - (startOffset + activeTabWidth + _constants.TAB_MARGIN);
    maxOffset = Math.min(0, Math.max(navWrapWidth - navListWidth, maxOffset));
    if (currentOffset >= minOffset && currentOffset <= maxOffset) {
      return;
    }
    if (Math.abs(minOffset - currentOffset) > Math.abs(maxOffset - currentOffset)) {
      updateScrollOffset(maxOffset);
    } else {
      updateScrollOffset(minOffset);
    }
  }, []);
  _react.default.useEffect(() => {
    updateInk();
    initScrollOffset();
  }, [activeKey]);
  _react.default.useEffect(() => {
    const handleResize = (0, _lodash.debounce)(() => {
      updateWidth();
      updateInk();
      initScrollOffset();
      setOperaBoxVisible(navListWidthRef.current > navWidthRef.current);
    }, 200);
    const resizeObserver = new _resizeObserverPolyfill.default(handleResize);
    // tab 内容变化也需要更新 ink 和 滚动偏移量
    tabs.forEach(tab => {
      const {
        key
      } = tab;
      const elem = tabRefs.current[key];
      elem && resizeObserver.observe(elem);
    });
    navRef.current && resizeObserver.observe(navRef.current);
    navWrapRef.current && resizeObserver.observe(navWrapRef.current);
    return () => {
      resizeObserver.disconnect();
    };
  }, [tabs]);
  const handleWheel = _react.default.useCallback(e => {
    // 滚动时收起更多菜单
    setMorePopoverVisible(false);
    if (!navWrapRef.current || !navListRef.current) {
      return;
    }
    const navWrapWidth = navWrapWidthRef.current || navWrapRef.current.offsetWidth;
    const navListWidth = navListWidthRef.current || navListRef.current.offsetWidth;
    if (navWrapWidth >= navListWidth) {
      return false;
    }
    const {
      deltaX,
      deltaY
    } = e;
    // Convert both to x & y since wheel only happened on PC
    let mixed = 0;
    const absX = Math.abs(deltaX);
    const absY = Math.abs(deltaY);
    if (absX === absY) {
      mixed = lastWheelDirectionRef.current === 'x' ? deltaX : deltaY;
    } else if (absX > absY) {
      mixed = deltaX;
      lastWheelDirectionRef.current = 'x';
    } else {
      mixed = deltaY;
      lastWheelDirectionRef.current = 'y';
    }
    const minOffset = navWrapWidth - navListWidth;
    const maxOffset = 0;
    const newOffset = Math.min(Math.max(-mixed + scrollOffsetRef.current, minOffset), maxOffset);
    updateScrollOffset(newOffset);
    e.preventDefault();
  }, []);
  _react.default.useEffect(() => {
    if (navWrapRef.current) {
      navWrapRef.current.addEventListener('wheel', handleWheel);
    }
    return () => {
      if (navWrapRef.current) {
        navWrapRef.current.removeEventListener('wheel', handleWheel);
      }
    };
  }, [handleWheel]);
  const moreMenuItems = _react.default.useMemo(() => {
    if (!isOperaBoxVisible || !isMorePopoverVisible || !navWrapRef.current) {
      return [];
    }
    const navWrapWidth = navWrapWidthRef.current || navWrapRef.current.offsetWidth;
    const visibleStartOffset = -scrollOffsetRef.current;
    const visibleEndOffset = visibleStartOffset + navWrapWidth;
    const items = [];
    let startOffset = 0;
    tabs.forEach((tab, index) => {
      const width = tabRefs.current[tab.key].offsetWidth;
      const endOffset = startOffset + width;
      if (!(startOffset >= visibleStartOffset && endOffset <= visibleEndOffset)) {
        const {
          prefix,
          title,
          disabled,
          key
        } = tabs[index];
        items.push({
          key,
          title,
          prefix,
          disabled,
          selected: activeKey === key
        });
      }
      startOffset = endOffset + _constants.TAB_MARGIN;
    });
    return items;
  }, [isOperaBoxVisible, isMorePopoverVisible, tabs, activeKey]);
  const handleSelectMoreMenu = _react.default.useCallback(path => {
    const selectedKey = path.at(-1);
    selectedKey && setActiveKey(selectedKey);
    setMorePopoverVisible(false);
  }, []);
  return /*#__PURE__*/_createElement(TabsNav, {
    ref: navRef,
    className: "wdn-tabs-nav"
  }, /*#__PURE__*/_createElement(TabsNavWrap, {
    ref: navWrapRef
  }, /*#__PURE__*/_createElement(TabsNavList, {
    ref: navListRef
  }, tabs.map(tab => {
    const {
      key,
      onClose,
      title,
      disabled,
      prefix
    } = tab;
    return /*#__PURE__*/_createElement(_TabsBarTab.TabsBarTab, {
      key: key,
      tabKey: key,
      onClose: onClose,
      title: title,
      prefix: prefix,
      disabled: disabled,
      onClick: setActiveKey,
      activeKey: activeKey,
      onRef: onTabRef
    });
  }), /*#__PURE__*/_createElement(_styled.TabsInkBar, {
    ref: inkBarRef,
    animated: animated,
    className: "wdn-tabs-ink-bar"
  }))), isOperaBoxVisible ? /*#__PURE__*/_createElement(TabsNavOperationWrapper, {
    ref: operaWrapRef
  }, /*#__PURE__*/_createElement(_popover.Popover, {
    content: /*#__PURE__*/_createElement(_menu.Menu, {
      items: moreMenuItems,
      onSelect: handleSelectMoreMenu
    }),
    placement: "bottomLeft",
    trigger: "click",
    visible: isMorePopoverVisible,
    onVisibleChange: setMorePopoverVisible
  }, _Button || (_Button = /*#__PURE__*/_createElement(_button.Button, {
    icon: /*#__PURE__*/_createElement(_icon.IconMore, {
      style: operaIconStyle
    }),
    style: btnStyle
  })))) : null);
};
exports.TabsBar = TabsBar;
//# sourceMappingURL=TabsBar.js.map