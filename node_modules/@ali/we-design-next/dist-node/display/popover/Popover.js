"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Popover = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _react = _interopRequireWildcard(require("react"));
var _reactDom = _interopRequireDefault(require("react-dom"));
var _common = require("../../common");
var _align = require("./align");
var _styled = require("./styled");
var _resizeObserverPolyfill = _interopRequireDefault(require("resize-observer-polyfill"));
var _div;
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const _createElement = /*#__PURE__*/_react.default.createElement;
const DEFAULT_PROPS = {
  placement: 'bottom',
  placementOffset: [0, 0],
  getContainer: () => document.body
};
const contains = (container, target) => {
  let ele = target;
  while (ele !== null) {
    if (ele === container) {
      return true;
    }
    ele = ele.parentElement;
  }
  return false;
};
const Popover = /*#__PURE__*/_react.default.memo(props => {
  const {
    visible: _visible,
    trigger,
    content = _div || (_div = /*#__PURE__*/_createElement("div", null)),
    children,
    getContainer = DEFAULT_PROPS.getContainer,
    onVisibleChange,
    placement = DEFAULT_PROPS.placement,
    placementOffset = DEFAULT_PROPS.placementOffset,
    animation,
    keepAlign,
    keepMounted,
    resize,
    ...rest
  } = props;
  if (! /*#__PURE__*/(0, _react.isValidElement)(children)) {
    return null;
  }
  const [visible, _setVisible] = (0, _common.useDefaultProp)(false, _visible, onVisibleChange);
  const setVisible = (0, _common.useEventCallback)(e => _setVisible(e));
  const visibleController = (0, _react.useMemo)(() => {
    let timeoutId = null;
    const open = () => {
      cancel();
      setVisible(true);
    };
    const close = () => {
      if (timeoutId === null) {
        timeoutId = setTimeout(() => {
          timeoutId = null;
          isHoveringContent.current === false && setVisible(false);
        }, 150);
      }
    };
    const cancel = () => {
      if (timeoutId !== null) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
    };
    const closeImmediately = () => {
      cancel();
      setVisible(false);
    };
    return {
      open,
      close,
      closeImmediately
    };
  }, []);
  const isHoveringContent = (0, _react.useRef)(false);
  const triggerEvents = (0, _react.useMemo)(() => {
    if (trigger === 'hover') {
      return {
        onMouseEnter: visibleController.open,
        onMouseLeave: visibleController.closeImmediately
      };
    } else if (trigger === 'mouse-enter') {
      return {
        onMouseEnter: visibleController.open,
        onMouseLeave: visibleController.close
      };
    } else if (trigger === 'click') {
      return {
        onClick: visibleController.open
      };
    } else {
      return {};
    }
  }, [trigger, visibleController]);

  // 监听 document mousedown 事件，触发时关闭 Popover（除非事件在 content 或 trigger 内部触发）
  (0, _react.useEffect)(() => {
    if (visible) {
      const hide = e => {
        if (contentRef.current && triggerRef.current && e.target && !contains(contentRef.current, e.target) && !contains(triggerRef.current, e.target)) {
          visibleController.closeImmediately();
        }
      };
      // 为什么要 raf 后再监听：因为当前也许正处在一次 click 事件中
      const timerId = requestAnimationFrame(() => {
        document.addEventListener('mousedown', hide);
      });
      return () => {
        window.cancelAnimationFrame(timerId);
        document.removeEventListener('mousedown', hide);
      };
    }
  }, [visibleController, visible]);

  // 打开 Popover 后，立刻对齐 content 和 trigger
  (0, _react.useEffect)(() => {
    if (visible === true && contentRef.current && triggerRef.current) {
      (0, _align.align)(contentRef.current, triggerRef.current, placement, placementOffset);
    }
  }, [visible]);

  // 如果开启了 keepAlign：打开 Popover 后，监听窗口 resize 事件，触发时重新对齐 content 和 trigger
  // 注意：如果开启了 animation，首次重新对齐时需要移除 content 上的动画相关 classname
  (0, _react.useEffect)(() => {
    if (visible && keepAlign && contentRef.current && triggerRef.current) {
      // ResizeObserver.observe 会直接触发一次 callback，此时不需要 reAlign
      let flag = false;
      const reAlign = () => {
        if (flag && contentRef.current && triggerRef.current) {
          if (animation) {
            const regRes = contentRef.current.className.match(/wds-popover-animation-[\w-]+/);
            if (regRes && regRes[0]) {
              contentRef.current.className = contentRef.current.className.replace(regRes[0], '');
            }
          }
          (0, _align.align)(contentRef.current, triggerRef.current, placement, placementOffset);
        }
      };
      const resizeObserver = new _resizeObserverPolyfill.default(reAlign);
      resizeObserver.observe(document.body);
      const setFlagTimeoutId = setTimeout(() => flag = true, 100);
      return () => {
        resizeObserver.disconnect();
        clearTimeout(setFlagTimeoutId);
      };
    }
  }, [visible, keepAlign, animation]);
  const triggerRef = (0, _react.useRef)(null);
  const contentRef = (0, _react.useRef)(null);
  const ref = (0, _common.mergeRef)(children.ref, triggerRef);
  return /*#__PURE__*/_createElement(_react.default.Fragment, null, (0, _common.cloneReactNode)(children, {
    ref,
    ...triggerEvents
  }), visible || keepMounted ? /*#__PURE__*/_reactDom.default.createPortal( /*#__PURE__*/_createElement(_styled.ContentWrap, (0, _extends2.default)({
    hidden: !keepMounted ? false : !visible,
    onMouseEnter: trigger === 'mouse-enter' ? () => {
      isHoveringContent.current = true;
    } : undefined,
    onMouseLeave: trigger === 'mouse-enter' ? () => {
      isHoveringContent.current = false;
      visibleController.close();
    } : undefined,
    ref: contentRef
  }, (0, _common.mergeRestProps)(rest, (0, _common.mergeClassName)('wdn-popover', animation ? `wds-popover-animation-${placement}` : ''))), content), getContainer() || document.body) : null);
});
exports.Popover = Popover;
//# sourceMappingURL=Popover.js.map