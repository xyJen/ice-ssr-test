"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MenuItem = exports.Menu = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _react = _interopRequireWildcard(require("react"));
var _icon = require("../../basic/icon");
var _list = require("../../basic/list");
var _nested = require("../../basic/list/nested");
var _styled = require("./styled");
var _popover = require("../popover");
var _common = require("../../common");
var _lodash = require("lodash");
var _IconArrowRight;
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const _createElement = /*#__PURE__*/_react.default.createElement;
const hasSubMenu = it => {
  return 'subMenu' in it && !!it.subMenu;
};
const hasAsyncSubMenu = it => {
  return hasSubMenu(it) && typeof it.subMenu === 'function';
};
const hasSyncSubMenu = it => {
  return hasSubMenu(it) && Array.isArray(it.subMenu);
};
const Menu = /*#__PURE__*/(0, _react.memo)( /*#__PURE__*/(0, _react.forwardRef)((props, ref) => {
  const {
    path: _path,
    onPathChange,
    onSelect = _lodash.noop,
    items = [],
    renderItem,
    keyboard = true,
    ...rest
  } = props;
  const flattenItems = (0, _react.useMemo)(() => (0, _nested.flattenNested)(items), [items]);
  const [path, setPath] = (0, _common.useDefaultProp)([], _path, onPathChange);

  // 存储异步菜单项数据
  const [smiState, smiDispatch] = (0, _react.useReducer)((state, action) => {
    const [key, items] = action;
    return {
      ...state,
      [key]: items
    };
  }, {});
  const wrapRef = (0, _react.useRef)(null);
  const [focusTargetId, focusTarget, focusOwner] = (0, _common.useFocusTarget)(wrapRef);

  // 根据列表中的当前激活项变化，设置 path
  // 注意：当通过鼠标悬浮到具有子菜单的菜单项时，自动展开子菜单
  const onActiveChange = (k, op) => {
    const it = flattenItems.find(it => it.key === k);
    if (it) {
      if (hasSubMenu(it)) {
        if (op.from === 'mouse') {
          setPath([it.key, undefined]);
        } else {
          setPath([it.key]);
        }
      } else {
        setPath([it.key]);
      }
    } else {
      if (path.length === 1) {
        setPath([undefined]);
      }
    }
  };

  // 键盘方向键控制子菜单的打开关闭
  // 如果当前菜单叶子级：
  //    按下 Right 键：如果当前项有子菜单，则打开
  //    按下 Enter 键：如果当前项有子菜单，则打开
  // 如果当前菜单次叶子级（即从叶子级开始向上追溯的第二级）：
  //    按下 Left 键：收起当前子菜单
  const onKeydownLeaf = e => {
    const kbKey = e.key.toLowerCase();
    const isArrowRight = kbKey === 'arrowright' || e.keyCode === _common.KEY_CODES.RIGHT;
    const isEnter = kbKey === 'enter' || e.keyCode === _common.KEY_CODES.ENTER;
    const curItem = flattenItems.find(it => it.key === path[0]);
    if (isArrowRight || isEnter) {
      if (hasSubMenu(curItem)) {
        const subMenuItems = curItem.subMenu === undefined ? undefined : typeof curItem.subMenu === 'function' ? smiState[curItem.key] : curItem.subMenu;
        if (subMenuItems) {
          const subFlattenItems = (0, _nested.flattenNested)(subMenuItems).filter(_nested.isNormalized).filter(_nested.isEnabled);
          if (subFlattenItems.length > 0) {
            const rightKey = subFlattenItems[0].key;
            focusTarget(() => {
              setPath([path[0], rightKey]);
            });
            e.stopPropagation();
            return;
          }
        } else {
          focusTarget(() => {
            setPath([path[0], undefined]);
          });
          e.stopPropagation();
          return;
        }
      }
    }
  };
  const onKeydownSecondaryLeaf = e => {
    const isArrowLeft = e.key.toLowerCase() === 'arrowleft' || e.keyCode === 37;
    if (isArrowLeft) {
      focusOwner(() => {
        setPath([path[0]]);
      });
      e.stopPropagation();
    }
  };
  const onKeydown = keyboard ? path.filter(Boolean).length === 1 /** isLeaf */ ? onKeydownLeaf : path.filter(Boolean).length === 2 /** isSecondaryLeaf */ ? onKeydownSecondaryLeaf : undefined : undefined;
  const subMenuRef = (0, _react.useRef)(null);

  // 自定义列表项渲染
  const renderListItem = ({
    key
  }) => /* 以下 arrow function 不是一个 React 组件 */
  /* eslint-disable react/display-name */
  sourceNode => {
    const item = flattenItems.find(it => it.key === key);
    if (item && (0, _nested.isNormalized)(item)) {
      const itemHasSubMenu = hasSubMenu(item);
      const targetItemChildren = item.description ? /*#__PURE__*/_createElement(_react.default.Fragment, null, /*#__PURE__*/_createElement(_styled.MenuItemTitleDescription, null, item.title), /*#__PURE__*/_createElement(_styled.MenuItemDescription, {
        disabled: !!item.disabled
      }, item.description)) : sourceNode.props.children;
      const toCloned = {
        children: targetItemChildren,
        suffix: itemHasSubMenu ? _IconArrowRight || (_IconArrowRight = /*#__PURE__*/_createElement(_icon.IconArrowRight, {
          size: 16
        })) : item.suffix
      };
      if (toCloned.suffix === undefined) {
        delete toCloned.suffix;
      }
      const targetItemWithChildren = /*#__PURE__*/(0, _react.cloneElement)(sourceNode, toCloned);
      const targetNode = (0, _common.renderReactNode)(renderItem, targetItemWithChildren, {
        key
      });
      if (itemHasSubMenu) {
        const isExpaned = path[0] === item.key && path.length > 1;
        if (isExpaned) {
          const subItems = hasSyncSubMenu(item) ? item.subMenu : smiState[item.key];

          // 对于正在加载的子菜单，subItems 为 undefined

          if (subItems) {
            return /*#__PURE__*/_createElement(_popover.Popover, {
              animation: true,
              visible: true,
              onVisibleChange: v => {
                if (v === false) {
                  setPath([path[0]]);
                }
              },
              placement: "rightTop",
              placementOffset: [-2, -5],
              getContainer: () => wrapRef.current || document.body,
              content: /*#__PURE__*/_createElement(Menu, (0, _extends2.default)({
                ref: subMenuRef,
                path: path.slice(1),
                onPathChange: p => {
                  setPath([item.key, ...p]);
                },
                items: subItems,
                onSelect: path => onSelect([item.key, ...path]),
                renderItem: renderItem
              }, rest, {
                id: focusTargetId
              }))
            }, /*#__PURE__*/(0, _react.isValidElement)(targetNode) ? /*#__PURE__*/(0, _react.cloneElement)(targetNode, {
              onMouseLeave: e => {
                const t = 10;
                const {
                  clientX: x,
                  clientY: y
                } = e;
                const subMenu = subMenuRef.current;
                if (subMenu) {
                  const subMenuRect = subMenu.getBoundingClientRect();
                  if (x < subMenuRect.right + t && x > subMenuRect.left - t && y < subMenuRect.bottom + t && y > subMenuRect.top - t) {
                    return;
                  }
                }
                setPath([undefined]);
              }
            }) : targetNode);
          } else {
            return targetNode;
          }
        } else {
          return targetNode;
        }
      } else {
        return targetNode;
      }
    } else {
      return null;
    }
  };
  /* eslint-enable react/display-name */

  // 根据菜单 path 变化，尝试发起异步子菜单数据获取
  const key = path[0];
  (0, _react.useEffect)(() => {
    if (typeof key === 'string') {
      const item = flattenItems.find(it => it.key === key);
      if (item && hasAsyncSubMenu(item) && smiState[key] === undefined) {
        item.subMenu().then(e => {
          smiDispatch([key, e]);
        });
      }
    }
  }, [flattenItems, key, smiState]);
  return /*#__PURE__*/_createElement(_list.List, (0, _extends2.default)({
    items: items,
    active: path[0] || null,
    onActiveChange: onActiveChange,
    onSelect: k => onSelect([k]),
    onKeyDown: onKeydown,
    renderItem: renderListItem,
    keyboard: keyboard
  }, (0, _common.mergeRestProps)(rest, 'wdn-menu'), {
    ref: (0, _common.mergeRef)(ref, wrapRef)
  }));
}));
exports.Menu = Menu;
Menu.displayName = 'Menu';
const MenuItem = _list.List.Item;
exports.MenuItem = MenuItem;
//# sourceMappingURL=Menu.js.map