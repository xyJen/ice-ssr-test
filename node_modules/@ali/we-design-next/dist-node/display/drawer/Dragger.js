"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Dragger = void 0;
var _utils = require("./utils");
const SCROLL_THRESHOLD = 5;
class Dragger {
  constructor(params) {
    this.startTouch = null;
    this.translateY = 0;
    this.drawerHeight = 0;
    this.getDrawer = void 0;
    this.getBg = void 0;
    this.getDraggable = void 0;
    this.getRoot = void 0;
    this.scrollDirection = 'notScroll';
    this.status = 'none';
    this.onTouchStart = e => {
      var _this$getRoot, _this$getRoot2;
      e.stopPropagation();
      const {
        changedTouches
      } = e;
      const {
        length
      } = changedTouches;
      if (length > 1) {
        return;
      }
      this.startTouch = changedTouches[0];
      this.translateY = 0;
      (_this$getRoot = this.getRoot()) === null || _this$getRoot === void 0 ? void 0 : _this$getRoot.addEventListener('touchmove', this.onTouchMove, {
        passive: false
      });
      (_this$getRoot2 = this.getRoot()) === null || _this$getRoot2 === void 0 ? void 0 : _this$getRoot2.addEventListener('touchend', this.onTouchEnd);
    };
    this.touchEnd = curTranslateY => {
      const drawer = this.getDrawer();
      const bg = this.getBg();
      if (!drawer || !bg || !(this.status === 'dragging')) {
        return;
      }
      const realTranslateY = curTranslateY || this.translateY;
      const height = this.drawerHeight || (drawer === null || drawer === void 0 ? void 0 : drawer.clientHeight) || 0;
      if (realTranslateY > height * 0.25) {
        drawer.style.transform = `translateY(${height}px)`;
        drawer.style.transition = 'transform 0.2s';
        bg.style.opacity = '0';
        bg.style.transition = 'opacity 0.6s';
        this.translateY = height;
      } else {
        drawer.style.transform = 'translateY(0px)';
        drawer.style.transition = 'transform 0.2s';
        bg.style.opacity = '1';
        bg.style.transition = 'none';
        this.translateY = 0;
      }
      this.startTouch = null;
    };
    this.formatTransformY = transformY => {
      var _this$getDrawer;
      const maxTransformY = this.drawerHeight || ((_this$getDrawer = this.getDrawer()) === null || _this$getDrawer === void 0 ? void 0 : _this$getDrawer.clientHeight) || 0;
      return Math.min(maxTransformY, Math.max(0, transformY));
    };
    this.isScrollable = (target, direction, delta) => {
      if (!target) return false;
      const root = this.getRoot();
      if (root === target) {
        return false;
      }
      if (direction === 'horizontal') {
        const {
          scrollWidth,
          clientWidth,
          scrollLeft
        } = target;
        if (scrollWidth > clientWidth) {
          const {
            overflowX,
            overflow
          } = getComputedStyle(target);
          if (overflowX === 'scroll' || overflowX === 'auto' || overflow === 'scroll' || overflow === 'auto') {
            if (delta > 0 && scrollLeft > 0 || delta < 0 && target.scrollTop + clientWidth < scrollWidth) {
              return true;
            }
          }
        }
      } else {
        const {
          scrollHeight,
          clientHeight,
          scrollTop
        } = target;
        if (scrollHeight > clientHeight) {
          const {
            overflowY,
            overflow
          } = getComputedStyle(target);
          if (overflowY === 'scroll' || overflowY === 'auto' || overflow === 'scroll' || overflow === 'auto') {
            if (delta > 0 && scrollTop > 0 || delta < 0 && target.scrollTop + clientHeight < scrollHeight) {
              return true;
            }
          }
        }
      }
      return this.isScrollable(target.parentElement, direction, delta);
    };
    this.onTouchMove = e => {
      var _this$startTouch;
      const {
        changedTouches
      } = e;
      const touch = (0, _utils.getStartTouch)(changedTouches, (_this$startTouch = this.startTouch) === null || _this$startTouch === void 0 ? void 0 : _this$startTouch.identifier);
      if (!touch) {
        (0, _utils.blockEvent)(e);
        this.touchEnd();
      } else {
        const {
          clientY,
          clientX
        } = touch;
        const {
          target,
          clientX: startTouchX,
          clientY: startTouchY
        } = this.startTouch;
        const moveX = clientX - startTouchX;
        const moveY = clientY - startTouchY;
        if (this.status === 'none' && Math.max(Math.abs(moveX), Math.abs(moveY)) > SCROLL_THRESHOLD) {
          const direction = Math.abs(moveX) > Math.abs(moveY) ? 'horizontal' : 'vertical';
          const delta = direction === 'horizontal' ? moveX : moveY;
          const canScroll = this.isScrollable(target, direction, delta);
          this.scrollDirection = direction;
          if (canScroll) {
            this.status = 'scrolling';
            e.stopPropagation();
          } else if (direction === 'vertical') {
            this.status = 'dragging';
            (0, _utils.blockEvent)(e);
          } else {
            (0, _utils.blockEvent)(e);
          }
        } else if (this.status === 'scrolling') {
          e.stopPropagation();
        } else if (this.status === 'dragging') {
          (0, _utils.blockEvent)(e);
          this.translateY = this.formatTransformY(moveY);
          const drawer = this.getDrawer();
          if (drawer) {
            drawer.style.transform = `translateY(${this.translateY}px)`;
            drawer.style.transition = 'none';
          }
        } else {
          (0, _utils.blockEvent)(e);
        }
      }
    };
    this.onTouchEnd = e => {
      var _this$startTouch2, _this$getRoot3, _this$getRoot4;
      e.stopPropagation();
      const {
        changedTouches
      } = e;
      const touch = (0, _utils.getStartTouch)(changedTouches, (_this$startTouch2 = this.startTouch) === null || _this$startTouch2 === void 0 ? void 0 : _this$startTouch2.identifier);
      if (!touch) {
        this.touchEnd();
      } else {
        this.translateY = this.formatTransformY(touch.clientY - this.startTouch.clientY);
        this.touchEnd(this.translateY);
      }
      (_this$getRoot3 = this.getRoot()) === null || _this$getRoot3 === void 0 ? void 0 : _this$getRoot3.removeEventListener('touchmove', this.onTouchMove);
      (_this$getRoot4 = this.getRoot()) === null || _this$getRoot4 === void 0 ? void 0 : _this$getRoot4.removeEventListener('touchend', this.onTouchEnd);
      this.scrollDirection = 'notScroll';
      this.status = 'none';
    };
    this.slideOut = () => {
      const drawer = this.getDrawer();
      const bg = this.getBg();
      if (!drawer || !bg) {
        return;
      }
      const newTranslateY = this.drawerHeight || drawer.clientHeight || 0;
      drawer.style.transform = `translateY(${newTranslateY}px)`;
      drawer.style.transition = 'transform 0.4s';
      bg.style.opacity = '0';
      bg.style.transition = 'opacity 0.4s';
    };
    this.slideIn = () => {
      const drawer = this.getDrawer();
      const bg = this.getBg();
      if (!drawer || !bg) {
        return;
      }
      this.drawerHeight = drawer.clientHeight || 0;
      bg.style.transition = 'opacity 0.2s';
      bg.style.opacity = '1';
      drawer.style.transition = 'transform 0.2s';
      drawer.style.transform = 'translateY(0)';
    };
    this.enableDrag = () => {
      const draggable = this.getDraggable();
      if (draggable) {
        draggable.addEventListener('touchstart', this.onTouchStart);
      }
    };
    this.disableDrag = () => {
      var _this$getDraggable;
      const draggable = (_this$getDraggable = this.getDraggable) === null || _this$getDraggable === void 0 ? void 0 : _this$getDraggable.call(this);
      if (draggable) {
        draggable.removeEventListener('touchstart', this.onTouchStart);
      }
    };
    this.getDrawer = params.getDrawer;
    this.getBg = params.getBg;
    this.getDraggable = params.getDraggable;
    this.getRoot = params.getRoot;
  }
}
exports.Dragger = Dragger;
//# sourceMappingURL=Dragger.js.map