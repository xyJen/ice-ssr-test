"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MultiSelect = exports.LEFT_PADDING = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _react = _interopRequireWildcard(require("react"));
var _resizeObserverPolyfill = _interopRequireDefault(require("resize-observer-polyfill"));
var _popover = require("../../display/popover");
var _common = require("../../common");
var _index = require("../../index");
var _nested = require("../../basic/list/nested");
var _input = require("../../form/input");
var _Tag = require("./Tag");
var _styled = require("./styled");
var _ClearIcon, _IconSelected, _DisableMask;
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const _createElement = /*#__PURE__*/_react.default.createElement;
const ITEM_WIDTH = 10; // 用来限制渲染的节点，避免性能问题
const MIN_INPUT_WIDTH = 40;
const LEFT_PADDING = 4;
exports.LEFT_PADDING = LEFT_PADDING;
const DEFAULT_OPTISON = [];
const MultiSelect = /*#__PURE__*/_react.default.memo( /*#__PURE__*/_react.default.forwardRef((props, ref) => {
  const {
    value: outValue,
    defaultValue = [],
    options = DEFAULT_OPTISON,
    onChange,
    visible: outVisible,
    defaultVisible = false,
    onVisibleChange,
    disabled,
    size = 'normal',
    getContainer,
    placeholder,
    error,
    inputValue: outInputValue,
    onInputValueChange,
    renderTag,
    renderTagMore,
    children,
    ...rest
  } = props;
  const flattenOptions = (0, _react.useMemo)(() => (0, _nested.flattenNested)(options, k => ({
    key: k,
    title: k
  })), [options]);
  const [value, setValue] = (0, _common.useDefaultProp)(defaultValue, outValue, onChange);
  const [visible, setVisible] = (0, _common.useDefaultProp)(defaultVisible, outVisible, onVisibleChange);
  const [inputValue, setInputValue] = (0, _common.useDefaultProp)('', outInputValue, onInputValueChange);
  const [containerWidth, setContainerWidth] = (0, _react.useState)(0);
  const [itemWidths, setItemWidths] = (0, _react.useState)(new Map());
  const [restWidth, setRestWidth] = (0, _react.useState)(0);
  const [inputWidth, setInputWidth] = (0, _react.useState)(0);
  const [displayCount, setDisplayCount] = (0, _react.useState)(0);
  const [restReady, setRestReady] = (0, _react.useState)(false);
  const myRef = (0, _react.useRef)(null);
  const [mouseInInput, setMouseInInput] = (0, _react.useState)(false);
  const [active, setActive] = (0, _react.useState)(null);
  const outerRef = (0, _react.useRef)(null);
  const [focusTargetId, focusTarget, focusOwner] = (0, _common.useFocusTarget)(outerRef);
  const mergedDisplayCount = (0, _react.useMemo)(() => {
    if (displayCount === null) {
      return Number.MAX_SAFE_INTEGER;
    }
    return displayCount || 0;
  }, [displayCount, containerWidth]);
  (0, _react.useEffect)(() => {
    if (!myRef.current) {
      return;
    }
    const calcContainerWidth = entries => {
      const entry = entries[0];
      if (!entry) {
        return;
      }
      const {
        width
      } = entry.contentRect;
      if (width === 0) {
        return;
      }
      setContainerWidth(width);
    };
    const eleResizeObserver = new _resizeObserverPolyfill.default(calcContainerWidth);
    eleResizeObserver.observe(myRef.current);
    return () => {
      eleResizeObserver.disconnect();
    };
  }, []);
  const registerSize = (key, width) => {
    setItemWidths(origin => {
      const clone = new Map(origin);
      if (width === null) {
        clone.delete(key);
      } else {
        clone.set(key, width);
      }
      return clone;
    });
  };
  const registerTagMoreSize = (_, width) => {
    setRestWidth(width);
  };
  const registerInputSize = (_, width) => {
    setInputWidth(width);
  };
  const updateDisplayCount = (count, notReady) => {
    setDisplayCount(count);
    if (!notReady) {
      setRestReady(count < value.length - 1);
    }
  };
  const displayOptions = (0, _react.useMemo)(() => {
    return flattenOptions.filter(op => value.includes(op.key)).map(op => {
      var _op$title;
      return 'title' in op ? {
        value: op.key,
        label: ((_op$title = op.title) === null || _op$title === void 0 ? void 0 : _op$title.toString()) || ''
      } : {
        value: op.key,
        label: op.key
      };
    });
  }, [options, value]);
  const mergedData = (0, _react.useMemo)(() => {
    return displayOptions.slice(0, Math.min(value.length, containerWidth / ITEM_WIDTH));
  }, [displayOptions, containerWidth]);
  (0, _react.useLayoutEffect)(() => {
    if (containerWidth && restWidth && mergedData) {
      let totalWidth = MIN_INPUT_WIDTH + LEFT_PADDING;
      const len = mergedData.length;
      const lastIndex = len - 1;
      if (!value.length) {
        updateDisplayCount(0);
        return;
      }
      for (let i = 0; i < len; i += 1) {
        const currentItemWidth = itemWidths.get(mergedData[i].value);

        // 如果数据没ready，break
        if (currentItemWidth === undefined) {
          updateDisplayCount(i - 1, true);
          break;
        }
        totalWidth += currentItemWidth;
        if (
        // 只有一个的话，totalWidth就是最后的宽度
        lastIndex === 0 && totalWidth <= containerWidth ||
        // 最后两个宽度将会是最后宽度
        i === lastIndex - 1 && totalWidth + itemWidths.get(mergedData[lastIndex].value) <= containerWidth) {
          updateDisplayCount(lastIndex);
          break;
        } else if (totalWidth + restWidth > containerWidth) {
          updateDisplayCount(i - 1);
          break;
        }
      }
    }
  }, [containerWidth, itemWidths, restWidth, inputWidth, mergedData]);
  const onOptionClick = (0, _react.useCallback)(curKey => {
    const newValue = [...value];
    const curKeyIndex = newValue.indexOf(curKey);
    if (curKeyIndex !== -1) {
      newValue.splice(curKeyIndex, 1);
    } else {
      newValue.push(curKey);
    }
    setValue(newValue);
  }, [value, setValue]);
  const updateValueByInputValue = (0, _react.useCallback)(() => {
    if (!inputValue) {
      return;
    }
    const result1 = flattenOptions.find(op => {
      var _op$title2;
      return 'title' in op && !op.disabled && ((_op$title2 = op.title) === null || _op$title2 === void 0 ? void 0 : _op$title2.toString().includes(inputValue));
    });
    const result = result1 && 'title' in result1 ? result1.key : undefined;
    if (!result) {
      return;
    }
    const newValue = [...value];
    const index = newValue.indexOf(result);
    if (index !== -1) {
      newValue.splice(index, 1);
    } else {
      newValue.push(result);
    }
    setInputValue('');
    setValue(newValue);
  }, [options, inputValue, value, setValue, setInputValue]);
  const handleEsc = (0, _react.useCallback)(() => {
    focusOwner(() => {
      setActive(null);
      setVisible(false);
    });
  }, [setVisible]);
  const handleKeyDown = (0, _react.useCallback)(e => {
    switch (e.which) {
      case _common.KEY_CODES.DELETE:
      case _common.KEY_CODES.BACKSPACE:
        if (inputValue === '' && value.length) {
          const newValue = [...value];
          newValue.pop();
          setValue(newValue);
        }
        break;
      case _common.KEY_CODES.ENTER:
        !visible && setVisible(true);
        updateValueByInputValue();
        e.nativeEvent.stopImmediatePropagation();
        break;
      case _common.KEY_CODES.DOWN:
        if (active === null) {
          const fn = () => {
            setVisible(true);
            const firstKey = flattenOptions.filter(o => !('disabled' in o && !!o.disabled))[0].key;
            if (firstKey) {
              setActive(firstKey);
            }
          };
          focusTarget(fn);
        }
        break;
      case _common.KEY_CODES.ESC:
        handleEsc();
        break;
      default:
        break;
    }
  }, [updateValueByInputValue, value, inputValue, setValue, active, setVisible, options, handleEsc]);
  const handleInputValueChange = (0, _react.useCallback)(e => {
    setInputValue(e.target.value);
  }, [setInputValue]);
  const onTagClose = (0, _react.useCallback)((e, key) => {
    e.stopPropagation();
    e.nativeEvent.stopImmediatePropagation();
    const newValue = [...value];
    const index = newValue.indexOf(key);
    if (index !== -1) {
      newValue.splice(index, 1);
    }
    setValue(newValue);
  }, [value, setValue]);
  const onArrowClick = (0, _react.useCallback)(e => {
    // TODO: 点击箭头收起下拉菜单
    // TODO: (依赖menu) 自定义节点内容时的hover样式、点击自定义节点将所选项、key放到div和input
    // if (visible) {
    // ref?.current?.blur();
    // }
  }, [visible]);
  const onMouseEnter = (0, _react.useCallback)(e => {
    !disabled && setMouseInInput(true);
  }, [disabled]);
  const onMouseLeave = (0, _react.useCallback)(e => {
    setMouseInInput(false);
  }, []);
  const handleClear = (0, _react.useCallback)(e => {
    // TODO: 如果选项有closable为false的，怎么处理
    e.stopPropagation();
    e.nativeEvent.stopImmediatePropagation();
    setValue([]);
    setInputValue('');
  }, [setValue, setInputValue]);
  let tagsNode;
  let restNode;
  if (value.length) {
    tagsNode = mergedData.map((item, index) => /*#__PURE__*/_createElement(_Tag.Item, {
      key: item.value,
      order: index,
      itemKey: item.value,
      registerSize: registerSize,
      display: index <= mergedDisplayCount
    }, /*#__PURE__*/_createElement(_Tag.Tag, {
      value: item.value,
      label: item.label,
      closable: true,
      size: size,
      onClose: e => onTagClose(e, item.value)
    })));
    const omittedOptions = displayOptions.slice(mergedDisplayCount + 1);
    const displayRest = restReady && !!omittedOptions.length;
    restNode = /*#__PURE__*/_createElement(_Tag.Item, {
      order: displayRest ? mergedDisplayCount : Number.MAX_SAFE_INTEGER,
      registerSize: registerTagMoreSize,
      display: displayRest
    }, /*#__PURE__*/_createElement(_Tag.TagMore, {
      omittedTags: omittedOptions,
      size: size
    }));
  }
  let suffixNode = /*#__PURE__*/_createElement(_styled.SuffixWrap, {
    onClick: onArrowClick
  }, !disabled && visible ? /*#__PURE__*/_createElement(_styled.ArrowUp, {
    disabled: disabled
  }) : /*#__PURE__*/_createElement(_styled.ArrowDown, {
    disabled: disabled
  }));
  if (value.length && mouseInInput) {
    suffixNode = /*#__PURE__*/_createElement(_styled.SuffixWrap, {
      onClick: handleClear
    }, _ClearIcon || (_ClearIcon = /*#__PURE__*/_createElement(_styled.ClearIcon, null)));
  }
  return /*#__PURE__*/_createElement(_popover.Popover, {
    placement: "bottomLeft",
    placementOffset: [4, 0],
    animation: true,
    content: /*#__PURE__*/_createElement(_styled.OverlayWrap, {
      style: {
        minWidth: containerWidth
      }
    }, /*#__PURE__*/_createElement(_index.List, (0, _extends2.default)({
      id: focusTargetId,
      items: options,
      onSelect: onOptionClick,
      active: active,
      onActiveChange: e => {
        setActive(e);
      },
      renderItem: ({
        key
      }) => p => {
        return value.includes(key) ? /*#__PURE__*/_react.default.cloneElement(p, {
          suffix: _IconSelected || (_IconSelected = /*#__PURE__*/_createElement(_index.IconSelected, null))
        }) : p;
      },
      style: {
        minWidth: 'auto'
      }
    }, (0, _common.proxyRestProps)(rest, 'list')))),
    visible: !disabled && visible,
    trigger: "click",
    onVisibleChange: e => {
      if (e) {
        !visible && setVisible(e);
      } else {
        visible && setVisible(e);
        setActive(null);
      }
    },
    getContainer: getContainer || (() => outerRef.current || document.body),
    onKeyDown: e => {
      e.which === _common.KEY_CODES.ESC && handleEsc();
    }
  }, /*#__PURE__*/_createElement(_styled.MultiSelectInputWrap, (0, _extends2.default)({
    tabIndex: -1,
    ref: outerRef,
    onKeyDown: handleKeyDown,
    error: error,
    disabled: disabled,
    size: size,
    visible: !disabled && visible,
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave
  }, (0, _common.mergeRestProps)(rest, 'wdn-multi-select')), /*#__PURE__*/_createElement(_styled.OverflowWrap, {
    ref: myRef
  }, tagsNode, restNode, /*#__PURE__*/_createElement(_Tag.Item, {
    order: mergedDisplayCount,
    registerSize: registerInputSize,
    display: true,
    style: {
      flexGrow: 1
    }
  }, /*#__PURE__*/_createElement(_input.Input, {
    ref: ref,
    className: "input",
    bordered: false,
    size: size,
    value: inputValue,
    disabled: !!disabled,
    placeholder: !value.length ? placeholder : undefined,
    onBlur: updateValueByInputValue,
    onChange: handleInputValueChange,
    suffix: suffixNode
  }))), disabled && (_DisableMask || (_DisableMask = /*#__PURE__*/_createElement(_styled.DisableMask, null))), error && /*#__PURE__*/_createElement(_styled.ErrorTip, null, error)));
}));
exports.MultiSelect = MultiSelect;
//# sourceMappingURL=MultiSelect.js.map