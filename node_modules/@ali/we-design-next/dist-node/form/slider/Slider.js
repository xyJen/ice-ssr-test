"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Slider = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _react = _interopRequireWildcard(require("react"));
var _styled = require("./styled");
var _common = require("../../common");
var _SliderLine = require("./SliderLine");
var _SliderPoint = require("./SliderPoint");
var _SliderMarks = require("./SliderMarks");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const _createElement = /*#__PURE__*/_react.default.createElement;
const Slider = /*#__PURE__*/(0, _react.memo)(props => {
  const {
    disable = false,
    attachToMarksOnly = false,
    range = false,
    marks = [],
    max = 100,
    min = 0,
    step = 1,
    value,
    defaultValue,
    onChange,
    formatter = value => `${value}`,
    point,
    mark,
    line,
    tip,
    ...rest
  } = props;
  const defaultStart = (0, _react.useMemo)(() => {
    if (!range) return min;
    return (defaultValue === null || defaultValue === void 0 ? void 0 : defaultValue[0]) ?? min;
  }, [range, defaultValue, min]);
  const defaultEnd = (0, _react.useMemo)(() => {
    if (range) return (defaultValue === null || defaultValue === void 0 ? void 0 : defaultValue[1]) ?? min;
    return defaultValue ?? min;
  }, [range, defaultValue, min]);
  const propsStart = (0, _react.useMemo)(() => {
    if (!range) return min;
    return value === null || value === void 0 ? void 0 : value[0];
  }, [value, range]);
  const propsEnd = (0, _react.useMemo)(() => {
    if (range) return value === null || value === void 0 ? void 0 : value[1];
    return value;
  }, [value, range]);
  const [start, setStart] = (0, _common.useDefaultProp)(defaultStart, propsStart, () => {});
  const [end, setEnd] = (0, _common.useDefaultProp)(defaultEnd, propsEnd, () => {});
  const sliderRef = (0, _react.useRef)(null);
  const moveStart = (0, _react.useRef)(false);
  const [isMove, setIsMove] = (0, _react.useState)(false);
  const sliderLength = (0, _react.useMemo)(() => max - min, [max, min]);
  // 计算移动距离
  const calculateDistance = (0, _react.useCallback)(e => {
    var _sliderRef$current;
    if (!sliderRef.current) return min;
    const {
      clientX: x
    } = e;
    const rect = (_sliderRef$current = sliderRef.current) === null || _sliderRef$current === void 0 ? void 0 : _sliderRef$current.getBoundingClientRect();
    const {
      left: sliderLeft,
      right: sliderRight
    } = rect || {};
    let result = 0;
    if (sliderLeft && sliderRight) {
      if (x <= sliderLeft) {
        result = min;
      } else if (x >= sliderRight) {
        result = max;
      } else {
        let tmpValue = 0;
        let dist = Number.MAX_SAFE_INTEGER;
        if (!attachToMarksOnly) {
          const spanWidth = (sliderRight - sliderLeft) / ((max - min) / step);
          const order = Math.round((x - sliderLeft) / spanWidth);
          dist = Math.abs(spanWidth * order + sliderLeft - x);
          tmpValue = order * step;
        }
        marks.forEach(mark => {
          const newDist = Math.abs(mark / (max - min) * (sliderRight - sliderLeft) + sliderLeft - x);
          if (newDist < dist) {
            dist = newDist;
            tmpValue = mark;
          }
        });
        result = tmpValue;
      }
    }
    if (!Number.isInteger(result)) {
      result = Number(result.toFixed(6));
    }
    return result;
  }, [attachToMarksOnly, marks, max, min, step]);
  const handleChange = (0, _react.useCallback)(point => {
    const [sValue = 0, eValue = 0] = moveStart.current ? [point, end] : [start, point];
    const rangeValue = sValue > eValue ? [eValue, sValue] : [sValue, eValue];
    onChange === null || onChange === void 0 ? void 0 : onChange(range ? rangeValue : point);
  }, [onChange, range, start, end]);
  const handleMouseMove = (0, _react.useCallback)(e => {
    const result = calculateDistance(e);
    if (moveStart.current) {
      setStart(result);
    } else {
      setEnd(result);
    }
    handleChange(result);
  }, [calculateDistance, handleChange]);
  const handleClickOnMark = (0, _react.useCallback)(mark => {
    if (disable) return;
    const isNearToStart = Math.abs(mark - (start ?? min)) < Math.abs((end ?? max) - mark);
    if (range && isNearToStart) {
      moveStart.current = true;
      setStart(mark);
    } else {
      moveStart.current = false;
      setEnd(mark);
    }
    handleChange(mark);
  }, [disable, handleChange, start, end, range, min, max]);
  const renderSliderMarks = (0, _react.useMemo)(() => {
    const marksProps = {
      marks,
      handleClickOnMark,
      sliderLength,
      disable
    };
    return (0, _common.renderReactNode)(mark, /*#__PURE__*/_createElement(_SliderMarks.SliderMarks, marksProps), undefined);
  }, [marks, handleClickOnMark, sliderLength, mark, disable]);
  const handleMouseDownOnPoint = (0, _react.useCallback)(() => {
    if (!disable) {
      setIsMove(true);
      document.addEventListener('mouseup', () => {
        document.removeEventListener('mousemove', handleMouseMove);
        setIsMove(false);
      });
      document.addEventListener('mousemove', handleMouseMove);
    }
  }, [disable, handleMouseMove]);
  const renderStartPoint = (0, _react.useMemo)(() => {
    if (!range) return null;
    const pointProps = {
      range,
      handleMouseDownOnPoint,
      point: start,
      sliderLength,
      isMove,
      formatter,
      moveStart,
      isStart: true,
      disable,
      tip
    };
    return (0, _common.renderReactNode)(point, /*#__PURE__*/_createElement(_SliderPoint.SliderPoint, pointProps), undefined);
  }, [range, handleMouseDownOnPoint, start, sliderLength, isMove, formatter, point, disable, tip]);
  const renderEndPoint = (0, _react.useMemo)(() => {
    const pointProps = {
      handleMouseDownOnPoint,
      point: end,
      sliderLength,
      isMove,
      formatter,
      moveStart,
      isStart: false,
      disable,
      tip
    };
    return (0, _common.renderReactNode)(point, /*#__PURE__*/_createElement(_SliderPoint.SliderPoint, pointProps), undefined);
  }, [handleMouseDownOnPoint, end, sliderLength, isMove, formatter, point, disable, tip]);
  const renderSliderLine = (0, _react.useMemo)(() => {
    const lineProps = {
      start,
      end,
      sliderLength,
      disable
    };
    return (0, _common.renderReactNode)(line, /*#__PURE__*/_createElement(_SliderLine.SliderLine, lineProps), undefined);
  }, [start, end, sliderLength, disable, line]);
  return /*#__PURE__*/_createElement(_styled.SliderContainer, (0, _extends2.default)({
    ref: sliderRef,
    isMove: isMove
  }, (0, _common.mergeRestProps)(rest, 'wdn-slider')), renderSliderLine, renderSliderMarks, renderStartPoint, renderEndPoint);
});
exports.Slider = Slider;
//# sourceMappingURL=Slider.js.map