"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ColorSquare = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _react = _interopRequireWildcard(require("react"));
var _tinycolor = _interopRequireDefault(require("tinycolor2"));
var _common = require("../../common");
var _styled = require("./styled");
var _mergeRestProps = require("../../common/react/mergeRestProps");
var _isWhite = require("./isWhite");
var _path;
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const _createElement = /*#__PURE__*/_react.default.createElement;
/**
 * 获取对比色，即：色块选中时打勾的颜色，要和色块本身的背景色形成反差
 */
const getContrastingColor = color => {
  // 颜色对象（包含多种颜色空间的类型）

  if (!color) {
    return _common.COLORS.WHITE;
  }
  const toColorObj = (colorStr, oldHue) => {
    const tinyColor = (0, _tinycolor.default)(colorStr);
    const hsl = tinyColor.toHsl();
    const hsv = tinyColor.toHsv();
    const rgb = tinyColor.toRgb();
    const hex = tinyColor.toHex();
    if (hsl.s === 0) {
      hsl.h = oldHue || 0;
      hsv.h = oldHue || 0;
    }
    const transparent = hex === '000000' && rgb.a === 0;
    return {
      hsl,
      hex: transparent ? 'transparent' : `#${hex}`,
      rgb,
      hsv,
      source: colorStr
    };
  };
  const colorObj = toColorObj(color);
  if (colorObj.hex === 'transparent') {
    return 'rgba(0,0,0,0.4)';
  } else {
    const yiq = (colorObj.rgb.r * 299 + colorObj.rgb.g * 587 + colorObj.rgb.b * 114) / 1000;
    return yiq >= 210 ? '#8C8C8C' : _common.COLORS.WHITE;
  }
};
const ColorSquare = /*#__PURE__*/_react.default.memo(props => {
  const {
    color,
    active,
    mode = 'text',
    ...rest
  } = props;
  if (color === null) {
    return /*#__PURE__*/_createElement(_styled.NullColorSquareWrap, (0, _mergeRestProps.mergeRestProps)(rest, 'wdn-color-square', {
      background: _common.COLORS.WHITE
    }));
  } else {
    const textAColor = (0, _react.useMemo)(() => getContrastingColor(color), [color]);
    return /*#__PURE__*/_createElement(_styled.ColorSquareWrap, (0, _extends2.default)({
      color: color,
      alwaysShowBorder: (0, _isWhite.isWhite)(color)
    }, (0, _mergeRestProps.mergeRestProps)(rest, 'wdn-color-square', {
      background: color
    })), active ? /*#__PURE__*/_createElement("svg", {
      width: "14",
      height: "10",
      viewBox: "0 0 16 12",
      fill: "none"
    }, _path || (_path = /*#__PURE__*/_createElement("path", {
      d: "M13.965 2.15533L5.63499 10.485L1.46999 6.32034",
      stroke: textAColor,
      strokeOpacity: "0.6",
      strokeWidth: "2.38",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }))) : mode === 'text' ? /*#__PURE__*/_createElement(_styled.ColorTextA, {
      className: "_wdn-color-picker-text-a",
      style: {
        color: textAColor
      }
    }, "A") : null);
  }
});
exports.ColorSquare = ColorSquare;
//# sourceMappingURL=ColorSquare.js.map