"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Guidance = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _react = _interopRequireWildcard(require("react"));
var _lodash = require("lodash");
var _reactDom = _interopRequireDefault(require("react-dom"));
var _button = require("../../basic/button");
var _text = require("../../basic/text");
var _modal = require("../../display/modal");
var _icon = require("../../basic/icon");
var _iconButton = require("../../basic/icon-button");
var _style = require("./style");
var _carousel = require("./carousel");
var _MapAnchor = require("./MapAnchor");
var _align = require("../../display/popover/align");
var _guidePanel = require("../../office/guide-panel");
var _locale = require("../../locale");
var _common = require("../../common");
var _resizeObserverPolyfill = _interopRequireDefault(require("resize-observer-polyfill"));
var _IconClose;
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const _createElement = /*#__PURE__*/_react.default.createElement;
const MODAL_FIXED_PLACEMENT = {
  right: 12,
  bottom: 48
};
const MODAL_FIXED_STYLE = {
  padding: 12,
  minWidth: 0,
  zIndex: 99998,
  background: _common.COLORS.WHITE,
  borderRadius: 8
};
const GuideModalFixed = props => {
  const {
    guides = [],
    onAction,
    onCurrentChange = _lodash.noop,
    onClose
  } = props;
  const [currentIndex, setCurrentIndex] = (0, _react.useState)(0);
  const clamp = (v, min, max) => v < min ? min : v > max ? max : v;
  const onChange = i => {
    setCurrentIndex(i);
    onCurrentChange(guides[i].key);
  };
  const next = () => {
    const i = clamp(currentIndex + 1, 0, guides.length - 1);
    onChange(i);
  };
  const prev = () => {
    const i = clamp(currentIndex - 1, 0, guides.length - 1);
    onChange(i);
  };
  const currentGuide = guides[currentIndex];
  const t = (0, _locale.useTranslate)();
  return guides.length !== 0 ? /*#__PURE__*/_createElement(_modal.Modal, {
    defaultPlacement: MODAL_FIXED_PLACEMENT,
    style: MODAL_FIXED_STYLE,
    header: null,
    footer: null,
    content: /*#__PURE__*/_createElement(_react.default.Fragment, null, /*#__PURE__*/_createElement(_style.GuidanceTitle, null, /*#__PURE__*/_createElement("span", {
      style: {
        flexGrow: 1
      }
    }, guides[currentIndex].title), /*#__PURE__*/_createElement(_iconButton.IconButton, {
      className: "wdn-close-btn",
      icon: _IconClose || (_IconClose = /*#__PURE__*/_createElement(_icon.IconClose, null)),
      onClick: onClose
    })), /*#__PURE__*/_createElement(_carousel.Carousel, {
      itemWidth: 256,
      currentItemIndex: currentIndex,
      onChange: onChange,
      autoPlay: true,
      autoPlayTime: 8000,
      showCarouselDots: false
    }, guides.map(({
      description,
      image,
      key
    }) => /*#__PURE__*/_createElement(_guidePanel.GuidePanel, {
      key: key,
      style: {
        width: 256,
        padding: 0
      },
      description: description,
      image: image
    }))), /*#__PURE__*/_createElement("div", {
      style: {
        display: 'flex',
        flexDirection: 'row',
        marginTop: 10,
        alignItems: 'center'
      }
    }, guides.length > 1 ? /*#__PURE__*/_createElement(_react.default.Fragment, null, /*#__PURE__*/_createElement(_icon.IconArrowLeft, {
      onClick: prev,
      style: currentIndex === 0 ? {
        color: _common.COLORS.LIGHT.LEVEL4_BASE_COLOR,
        cursor: 'disabled'
      } : undefined
    }), /*#__PURE__*/_createElement(_text.TextSub, {
      style: {
        padding: '0 2px'
      }
    }, currentIndex + 1, "/", guides.length), /*#__PURE__*/_createElement(_icon.IconArrowRight, {
      onClick: next,
      style: currentIndex === guides.length - 1 ? {
        color: _common.COLORS.LIGHT.LEVEL4_BASE_COLOR,
        cursor: 'disabled'
      } : undefined
    })) : null, /*#__PURE__*/_createElement("div", {
      style: {
        flexGrow: 1
      }
    }), /*#__PURE__*/_createElement(_button.Button, {
      type: "primary",
      size: "small",
      onClick: () => onAction && onAction(currentGuide.key)
    }, t('wdn_guidance_action')))),
    visible: true
  }) : null;
};
const normalizePlacement = p => {
  if (p === undefined) {
    return ['bottom', [0, 0]];
  }
  if (typeof p === 'string') {
    return [p, [0, 0]];
  }
  const [dir, offset] = p;
  if (typeof offset === 'number') {
    return [dir, [offset, 0]];
  } else {
    return [dir, offset];
  }
};
const isPromise = p => 'then' in p && typeof p.then === 'function';
const MODAL_FOLLOWING_PLACEMENT = {
  left: 0,
  top: 0
};
const MODAL_FOLLOWING_STYLE = {
  transform: 'none',
  left: -9999,
  top: -9999,
  padding: 0,
  minWidth: 0,
  zIndex: 99998,
  background: _common.COLORS.WHITE,
  borderRadius: 8
};
const GuideModalFollowing = props => {
  const [currentIndex, setCurrentIndex] = (0, _react.useState)(0);
  const {
    guides = [],
    onCurrentChange = _lodash.noop,
    onClose
  } = props;
  const clamp = (v, min, max) => v < min ? min : v > max ? max : v;
  const [isPerformNext, setIsPerformNext] = (0, _react.useState)(false);
  const next = async () => {
    const i = clamp(currentIndex + 1, 0, guides.length - 1);
    const {
      anchor,
      placement
    } = guides[i];
    const [dir, offset] = normalizePlacement(placement);
    const anchorTarget = anchor();
    const anchorTargetIsPromise = isPromise(anchorTarget);
    if (anchorTargetIsPromise) {
      setIsPerformNext(true);
    }
    const anchorRes = anchorTargetIsPromise ? await anchorTarget : anchorTarget;
    const [anchorEle, anchoreOffset] = Array.isArray(anchorRes) ? anchorRes : [anchorRes, [0, 0]];
    if (anchorEle) {
      setCurrentIndex(i);
      setIsPerformNext(false);
      onCurrentChange(i);
      if (mRef.current) {
        update(mRef.current, anchorEle, dir, offset, anchoreOffset);
      }
    }
  };
  const observeRef = (0, _react.useRef)(false);
  (0, _react.useEffect)(() => {
    return () => {
      observeRef.current && observeRef.current.disconnect();
    };
  }, []);
  const update = (ele, target, placement, offset, anchoreOffset) => {
    requestAnimationFrame(() => {
      const doUpdate = () => {
        (0, _align.align)(ele, target, placement, [5 + offset[0], offset[1]]);
        const {
          left,
          top,
          width,
          height
        } = target.getBoundingClientRect();
        _MapAnchor.MapAnchor.place(left + width / 2 + anchoreOffset[0], top + height / 2 + anchoreOffset[1]);
      };
      observeRef.current && observeRef.current.disconnect();
      observeRef.current = new _resizeObserverPolyfill.default(doUpdate);
      observeRef.current.observe(document.body);
      doUpdate();
    });
  };
  (0, _react.useEffect)(() => {
    if (mRef.current && currentIndex === 0) {
      const fn = async () => {
        const {
          anchor,
          placement
        } = guides[0];
        const [dir, offset] = normalizePlacement(placement);
        const anchorTarget = anchor();
        const anchorRes = isPromise(anchorTarget) ? await anchorTarget : anchorTarget;
        const [anchorEle, anchoreOffset] = Array.isArray(anchorRes) ? anchorRes : [anchorRes, [0, 0]];
        if (mRef.current) {
          update(mRef.current, anchorEle, dir, offset, anchoreOffset);
        }
      };
      fn();
    }
  }, []);
  const handleClose = () => {
    _MapAnchor.MapAnchor.remove();
    onClose && onClose();
  };
  const mRef = (0, _react.useRef)(null);
  const guide = guides[currentIndex];
  const t = (0, _locale.useTranslate)();
  return guides.length !== 0 && guide ? /*#__PURE__*/_createElement(_modal.Modal, {
    ref: mRef,
    defaultPlacement: MODAL_FOLLOWING_PLACEMENT,
    header: null,
    style: MODAL_FOLLOWING_STYLE,
    content: /*#__PURE__*/_createElement(_react.default.Fragment, null, /*#__PURE__*/_createElement(_guidePanel.GuidePanel, {
      title: guide.title,
      description: guide.description,
      image: guide.image,
      style: {
        width: 200
      }
    }), /*#__PURE__*/_createElement(_style.GuidanceFooter, null, currentIndex !== guides.length - 1 ? /*#__PURE__*/_createElement(_text.TextSub, {
      onClick: handleClose
    }, `${t('wdn_skip')} (${currentIndex + 1}/${guides.length})`) : null, /*#__PURE__*/_createElement("div", {
      style: {
        flexGrow: 1
      }
    }), currentIndex === guides.length - 1 ? /*#__PURE__*/_createElement(_button.Button, {
      type: "primary",
      size: "small",
      onClick: handleClose
    }, t('wdn_isee')) : /*#__PURE__*/_createElement(_button.Button, {
      type: "primary",
      size: "small",
      disabled: isPerformNext,
      onClick: next
    }, t('wdn_next_step')))),
    footer: null,
    visible: true
  }) : null;
};
const open = opt => {
  const container = ensureContainer();
  const fn = _locale.globalLang.lang ? c => /*#__PURE__*/_createElement(_locale.LocaleContext.Provider, {
    value: _locale.globalLang.lang,
    children: c
  }) : c => c;
  if (opt.type === 'fixed') {
    const {
      type,
      onClose,
      ...rest
    } = opt;
    _reactDom.default.render(fn( /*#__PURE__*/_createElement(GuideModalFixed, (0, _extends2.default)({}, rest, {
      onClose: () => {
        close();
        opt.onClose && opt.onClose();
      }
    }))), container);
  } else if (opt.type === 'following') {
    const {
      type,
      onClose,
      ...rest
    } = opt;
    _reactDom.default.render(fn( /*#__PURE__*/_createElement(GuideModalFollowing, (0, _extends2.default)({}, rest, {
      onClose: () => {
        close();
        opt.onClose && opt.onClose();
      }
    }))), container);
  }
  return {
    container
  };
};
const close = () => {
  _reactDom.default.unmountComponentAtNode(ensureContainer());
};
const ensureContainer = () => {
  const id = 'wdn-guidance-root';
  const divEle = document.querySelector(`div#${id}`);
  if (!divEle) {
    const ele = document.createElement('div');
    ele.id = id;
    ele.style.position = 'absolute';
    ele.style.width = '100%';
    ele.style.top = '0px';
    ele.style.left = '0px';
    document.body.appendChild(ele);
  }
  ;
  return document.querySelector(`div#${id}`);
};
const Guidance = {
  open,
  close
};
exports.Guidance = Guidance;
//# sourceMappingURL=Guidance.js.map