"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Filename = void 0;
var _react = _interopRequireWildcard(require("react"));
var _tooltip = require("../../display/tooltip");
var _styled = require("./styled");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const _createElement = /*#__PURE__*/_react.default.createElement;
const mirrorOffsetWidth = 6;
const inputOffsetHeight = 6;
const inputOffsetWidth = 10;
const minWidth = 2;
const maxLength = 32;
const isSafari = window.navigator.userAgent.includes('Safari') && !window.navigator.userAgent.includes('Chrome');
const Filename = /*#__PURE__*/(0, _react.memo)(props => {
  const {
    filename: fileName,
    renameAble,
    onRename,
    maxWidth = -1,
    ...rest
  } = props;
  const inputRef = (0, _react.useRef)(null);
  const readerRef = (0, _react.useRef)(null);
  const mirrorRef = (0, _react.useRef)(null);
  const [newFileName, setFileName] = (0, _react.useState)('');
  const [isFocused, setFocus] = (0, _react.useState)(false);
  const [isComposing, setIsComposing] = (0, _react.useState)(false);
  const [illeaguePost, setIlleaguePost] = (0, _react.useState)(false);
  const resizeNameInput = (0, _react.useCallback)(() => {
    if (!mirrorRef.current) {
      return;
    }
    const {
      width = 0,
      height
    } = mirrorRef.current.getBoundingClientRect();
    const mirrorWidth = Math.ceil(width);
    if (renameAble) {
      if (inputRef.current) {
        let inputWidth = mirrorWidth + inputOffsetWidth - mirrorOffsetWidth;
        if (isSafari) {
          inputWidth = mirrorWidth + inputOffsetWidth;
          inputRef.current.style.height = `${height + inputOffsetHeight}px`;
        }
        inputRef.current.style.width = `${maxWidth === -1 ? Math.max(inputWidth, minWidth) : Math.min(Math.max(inputWidth, minWidth), maxWidth - inputOffsetWidth)}px`;
        if (readerRef.current) {
          readerRef.current.style.width = `${maxWidth === -1 ? Math.max(inputWidth, minWidth) : Math.min(Math.max(inputWidth, minWidth), maxWidth - mirrorOffsetWidth)}px`;
        }
      }
    } else if (readerRef.current) {
      readerRef.current.style.width = `${maxWidth === -1 ? Math.max(mirrorWidth, minWidth) : Math.min(Math.max(mirrorWidth, minWidth), maxWidth - mirrorOffsetWidth)}px`;
    }
  }, [renameAble, isSafari, minWidth, maxWidth]);
  (0, _react.useEffect)(() => {
    setFileName(fileName);
    resizeNameInput();
  }, [fileName, resizeNameInput]);
  (0, _react.useEffect)(() => {
    resizeNameInput();
  }, [resizeNameInput, newFileName]);
  const handleMouseLeave = (0, _react.useCallback)(() => {
    if (!isFocused && (inputRef === null || inputRef === void 0 ? void 0 : inputRef.current) instanceof HTMLInputElement) {
      const {
        width
      } = inputRef.current.getBoundingClientRect();
      inputRef.current.style.width = `${width}px`;
      inputRef.current.scrollLeft = 0;
      resizeNameInput();
    }
  }, [isFocused, resizeNameInput]);
  const onChangeName = (0, _react.useCallback)(e => {
    const {
      value
    } = e.target;
    setFileName(value);
  }, []);
  /* 响应编辑输入框失焦 */
  const handleBlur = (0, _react.useCallback)(() => {
    var _inputRef$current, _inputRef$current$val;
    setIlleaguePost(false);
    const trimFileName = inputRef === null || inputRef === void 0 ? void 0 : (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : (_inputRef$current$val = _inputRef$current.value) === null || _inputRef$current$val === void 0 ? void 0 : _inputRef$current$val.trim().substring(0, maxLength);
    if (trimFileName && (trimFileName === null || trimFileName === void 0 ? void 0 : trimFileName.length) > 0) {
      setFileName(trimFileName);
      setFocus(false);
      onRename(trimFileName);
    } else {
      setFileName(fileName);
      setFocus(false);
    }
  }, [fileName, maxLength, onRename]);

  // 文件名超限时给出警告
  const alertNameLength = (0, _react.useCallback)(() => {
    if (!illeaguePost && newFileName && newFileName.length > maxLength) {
      setIlleaguePost(true);
    }
  }, [illeaguePost, maxLength, newFileName]);

  // 聚焦时，选中文本
  const handleFocus = (0, _react.useCallback)(() => {
    setFocus(true);
  }, []);
  const handleEnterKey = (0, _react.useCallback)(e => {
    const input = inputRef.current;
    switch (e.key) {
      case 'Escape':
        if (input) {
          input.value = fileName || '';
        }
        !isComposing && (input === null || input === void 0 ? void 0 : input.blur());
        break;
      case 'Enter':
        setIlleaguePost(false);
        !isComposing && (input === null || input === void 0 ? void 0 : input.blur());
        break;
      default:
        break;
    }
  }, [isComposing, fileName]);
  const handleTextAreaComposition = (0, _react.useCallback)(e => {
    if (e.type === 'compositionstart') {
      setIsComposing(true);
    }
    if (e.type === 'compositionend') {
      setIsComposing(false);
      setIlleaguePost(false);
    }
  }, []);
  const mirrorText = (0, _react.useMemo)(() => (newFileName || '').replace(/\s/g, '\u00A0'), [newFileName]);
  return /*#__PURE__*/_createElement(_styled.TitleBar, rest, renameAble ? /*#__PURE__*/_createElement(_tooltip.Tooltip, {
    title: '重命名'
  }, /*#__PURE__*/_createElement(_styled.TitleInput, {
    ref: inputRef,
    value: newFileName,
    title: newFileName,
    onChange: onChangeName,
    onBlur: handleBlur,
    onFocus: handleFocus,
    onKeyDown: handleEnterKey,
    onKeyUp: alertNameLength,
    maxLength: maxLength,
    isFocused: isFocused,
    onMouseLeave: handleMouseLeave,
    onCompositionStart: handleTextAreaComposition,
    onCompositionEnd: handleTextAreaComposition
  })) : /*#__PURE__*/_createElement(_styled.TitleName, {
    ref: readerRef,
    title: fileName
  }, fileName), /*#__PURE__*/_createElement(_styled.TitleMirror, {
    ref: mirrorRef
  }, mirrorText));
});
exports.Filename = Filename;
//# sourceMappingURL=rename.js.map