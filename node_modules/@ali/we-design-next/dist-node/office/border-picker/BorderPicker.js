"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BorderPicker = void 0;
var _react = _interopRequireWildcard(require("react"));
var _common = require("../../common");
var _text = require("../../basic/text");
var _select = require("../../form/select");
var _popover = require("../../display/popover");
var _colorPicker = require("../../form/color-picker");
var _icon = require("../../basic/icon");
var _styled = require("./styled");
var _presets = require("./presets");
var _locale = require("../../locale");
var _Divider, _IconBorderNone, _Select$Option;
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const _createElement = /*#__PURE__*/_react.default.createElement;
const BORDER_LAYOUTES = [['outer', /*#__PURE__*/_createElement(_icon.IconBorderOuter, null)], ['inner', /*#__PURE__*/_createElement(_icon.IconBorderInner, null)], ['all', /*#__PURE__*/_createElement(_icon.IconBorderAll, null)], ['left', /*#__PURE__*/_createElement(_icon.IconBorderLeft, null)], ['vertical', /*#__PURE__*/_createElement(_icon.IconBorderInnerVertical, null)], ['right', /*#__PURE__*/_createElement(_icon.IconBorderRight, null)], ['top', /*#__PURE__*/_createElement(_icon.IconBorderTop, null)], ['horizon', /*#__PURE__*/_createElement(_icon.IconBorderInnerHorizon, null)], ['bottom', /*#__PURE__*/_createElement(_icon.IconBorderBottom, null)]];
const DEFAULT_BORDER = {
  layout: 'all',
  color: '#000000',
  style: 'Thin'
};
const BorderPicker = /*#__PURE__*/_react.default.memo(props => {
  const {
    defaultBorder = DEFAULT_BORDER,
    border: _border,
    onBorderChange,
    preset = _presets.DEFAULT_PRESET
  } = props;
  const [border, setBorder] = (0, _common.useDefaultProp)(defaultBorder, _border, onBorderChange);
  const t = (0, _locale.useTranslate)();
  return /*#__PURE__*/_createElement(_styled.BorderPickerWrapper, null, /*#__PURE__*/_createElement(_styled.BorderPickerMain, null, /*#__PURE__*/_createElement(BorderPickerLayout, {
    color: border.color,
    layout: border.layout,
    onChange: layout => setBorder({
      ...border,
      layout
    })
  }), /*#__PURE__*/_createElement("div", {
    style: {
      marginLeft: 16,
      marginTop: 0
    }
  }, /*#__PURE__*/_createElement(BorderPickerColor, {
    color: border.color,
    onChange: color => setBorder({
      ...border,
      color
    })
  }), /*#__PURE__*/_createElement(BorderPickerStyle, {
    color: border.color,
    preset: preset,
    style: border.style,
    onChange: style => {
      setBorder({
        ...border,
        style
      });
    }
  }))), _Divider || (_Divider = /*#__PURE__*/_createElement(_common.Divider, null)), /*#__PURE__*/_createElement(_styled.BorderPickerFooter, {
    onClick: () => setBorder({
      ...border,
      layout: 'none'
    })
  }, _IconBorderNone || (_IconBorderNone = /*#__PURE__*/_createElement(_icon.IconBorderNone, null)), /*#__PURE__*/_createElement(_text.Text, {
    style: {
      flexGrow: 1,
      marginLeft: 8
    }
  }, t('wdn_border_picker_no_border'))));
});
exports.BorderPicker = BorderPicker;
const BorderPickerLayout = /*#__PURE__*/_react.default.memo(props => {
  const {
    color,
    layout,
    onChange
  } = props;
  return /*#__PURE__*/_createElement(_styled.BorderPickerLayoutWrapper, {
    style: {
      color: color
    }
  }, BORDER_LAYOUTES.map(([key, icon]) => /*#__PURE__*/_createElement(_styled.BorderPickerLayoutIconWrapper, {
    onClick: () => onChange(key),
    active: key === layout
  }, /*#__PURE__*/_react.default.cloneElement(icon, {
    size: 20
  }))));
});
const BorderPickerColor = /*#__PURE__*/_react.default.memo(props => {
  const {
    color,
    onChange
  } = props;
  const [visible, setVisible] = (0, _react.useState)(false);
  const t = (0, _locale.useTranslate)();
  const ref = (0, _react.useRef)(null);
  return /*#__PURE__*/_createElement(_styled.BorderPickerColorWrap, {
    ref: ref
  }, /*#__PURE__*/_createElement(_text.TextInline, {
    style: {
      marginRight: 8
    }
  }, t('wdn_color')), /*#__PURE__*/_createElement(_popover.Popover, {
    trigger: "click",
    placement: "bottomLeft",
    onVisibleChange: setVisible,
    visible: visible,
    getContainer: () => ref.current || document.body,
    content: /*#__PURE__*/_createElement(_colorPicker.ColorPicker, {
      autoColor: "#000000",
      color: color,
      onColorChange: e => {
        e && onChange(e);
        setVisible(false);
      }
    })
  }, /*#__PURE__*/_createElement(_styled.BorderPickerColorButton, null, /*#__PURE__*/_createElement(_styled.BorderPickerColorRect, {
    style: {
      backgroundColor: color
    }
  }))));
});
const BorderPickerStyle = /*#__PURE__*/_react.default.memo(props => {
  const {
    color,
    style,
    preset,
    onChange
  } = props;
  const t = (0, _locale.useTranslate)();
  return /*#__PURE__*/_createElement(_styled.BorderPickerStyleWrap, null, /*#__PURE__*/_createElement(_text.TextInline, {
    style: {
      marginRight: 8
    }
  }, t('wdn_border_picker_line_type')), /*#__PURE__*/_createElement(_select.Select, {
    size: "small",
    value: style,
    options: preset.map(it => it.key),
    renderOption: op => {
      const border = preset.find(p => p.key === op.key);
      if (border) {
        return /*#__PURE__*/_createElement(_select.Select.Option, {
          children: /*#__PURE__*/_createElement(BorderStyleDisplay, {
            color: color,
            style: border.style
          })
        });
      } else {
        return _Select$Option || (_Select$Option = /*#__PURE__*/_createElement(_select.Select.Option, null));
      }
    },
    renderValue: ({
      key
    }) => {
      const border = preset.find(p => p.key === key);
      if (border) {
        return /*#__PURE__*/_createElement(BorderStyleDisplay, {
          color: color,
          style: border.style
        });
      } else {
        return null;
      }
    },
    onChange: e => onChange(e)
  }));
});
const BorderStyleDisplay = /*#__PURE__*/_react.default.memo(props => {
  const {
    color,
    style
  } = props;
  const lineStyle = (params, color) => {
    const linearGradientSteps = (units, colors, makeUpForRepeat, start = 0) => {
      let currenPosition = start;
      let res = '';
      const maxIndex = units.length - 1;
      if (makeUpForRepeat && start > 0) {
        res += `transparent 0px, transparent ${start}px,`;
      }
      for (let i = 0; i < maxIndex; i++) {
        const nextPosition = currenPosition + units[i];
        res += `${colors[i]} ${currenPosition}px, ${colors[i]} ${nextPosition}px,`;
        currenPosition = nextPosition;
      }
      const endPosition = currenPosition + units[maxIndex];
      res += `${colors[maxIndex]} ${currenPosition}px, ${colors[maxIndex]} ${endPosition}px`;
      return [res, endPosition];
    };
    const {
      units,
      width: size = 1,
      inclination: angle
    } = params;
    const [indent, repeatFrom] = [0, 0];
    const colors = [color, _common.COLORS.WHITE];
    const direction = angle ? `${angle}deg` : 'to right';
    const style = {};
    style.height = size;
    if (units.length === 0 || colors.length === 0) {
      return style;
    }
    if (units.length === 1) {
      style.backgroundColor = colors[0];
      return style;
    }
    let renderColors = colors.concat();
    while (renderColors.length < units.length) {
      renderColors = renderColors.concat(renderColors);
    }
    const startColors = renderColors.slice(0, repeatFrom);
    const repeatColors = renderColors.slice(repeatFrom);
    const startUnits = units.slice(0, repeatFrom);
    const repeatUnits = units.slice(repeatFrom);
    let startLinear = '';
    let repeatLinear = '';
    let repeatStartPosition = indent;
    if (startUnits.length !== 0) {
      const [steps, endPosition] = linearGradientSteps(startUnits, startColors, true, indent);
      startLinear = `linear-gradient(${direction},${steps})`;
      repeatStartPosition = endPosition;
    }
    if (repeatUnits.length !== 0) {
      const [steps] = linearGradientSteps(repeatUnits, repeatColors, false, repeatStartPosition);
      repeatLinear = `repeating-linear-gradient(${direction},${steps})`;
    }
    const both = startLinear && repeatLinear;
    const linear = both ? `${startLinear}, ${repeatLinear}` : `${startLinear} ${repeatLinear}`;
    style.backgroundImage = linear;
    return style;
  };
  const segs = 'length' in style ? style : [style];
  return /*#__PURE__*/_createElement(_react.default.Fragment, null, segs.map(seg => seg ? /*#__PURE__*/_createElement("div", {
    style: {
      width: 50,
      minWidth: '60px',
      height: 16,
      ...lineStyle(seg, color)
    }
  }) : /*#__PURE__*/_createElement("div", {
    style: {
      width: 50,
      height: 2
    }
  })));
});
//# sourceMappingURL=BorderPicker.js.map