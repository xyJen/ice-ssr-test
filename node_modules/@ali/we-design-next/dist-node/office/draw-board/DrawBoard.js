"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrawBoard = void 0;
var _react = _interopRequireWildcard(require("react"));
var _lodash = require("lodash");
var _styled = require("./styled");
var _useEventCallback = require("../../common/react/useEventCallback");
var _mergeRestProps = require("../../common/react/mergeRestProps");
var _isMobile = require("../../common/env/isMobile");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const _createElement = /*#__PURE__*/_react.default.createElement;
// 获取 canvas 最小有效图像
const getCroppedImage = (canvas, vCanvas, padding = 0) => {
  const getLeftBorder = (data, width, height) => {
    for (let i = 0; i < width; i++) {
      for (let j = 0; j < height; j++) {
        const index = j * width + i;
        const hasColor = data[index * 4 + 3] > 0;
        if (hasColor) {
          return i + 1;
        }
      }
    }
    return 0;
  };
  const getRightBorder = (data, width, height) => {
    for (let i = width - 1; i >= 0; i--) {
      for (let j = 0; j < height; j++) {
        const index = j * width + i;
        const hasColor = data[index * 4 + 3] > 0;
        if (hasColor) {
          return i + 1;
        }
      }
    }
    return 0;
  };
  const getTopBorder = (data, width, height) => {
    for (let i = 0; i < height; i++) {
      for (let j = 0; j < width; j++) {
        const index = i * width + j;
        const hasColor = data[index * 4 + 3] > 0;
        if (hasColor) {
          return i + 1;
        }
      }
    }
    return 0;
  };
  const getBottomBorder = (imageData, width, height) => {
    for (let i = height - 1; i >= 0; i--) {
      for (let j = 0; j < width; j++) {
        const index = i * width + j;
        const hasColor = imageData[index * 4 + 3] > 0;
        if (hasColor) {
          return i + 1;
        }
      }
    }
    return 0;
  };
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;
  const {
    data
  } = ctx.getImageData(0, 0, width, height);
  const fns = [getLeftBorder, getRightBorder, getTopBorder, getBottomBorder];
  const [left, right, top, bottom] = fns.map(fn => fn(data, width, height));
  const w = right - left + 1;
  const h = bottom - top + 1;
  const newImageData = ctx.getImageData(left, top, w, h);
  vCanvas.width = w + padding * 2;
  vCanvas.height = h + padding * 2;
  const vCtx = vCanvas.getContext('2d');
  vCtx.putImageData(newImageData, padding, padding);
  const dataUrl = vCanvas.toDataURL('image/png', 1);
  return {
    dataUrl,
    width: vCanvas.width,
    height: vCanvas.height
  };
};
const BOARD_WIDTH = 500;
const BOARD_HEIGHT = 309;
const PAINT_COLOR = '#000000';
const LINE_CAP = 'round';
const DPR = window.devicePixelRatio;
const MAX_UNDO_STEP = 10;
const DrawBoard = /*#__PURE__*/_react.default.memo( /*#__PURE__*/_react.default.forwardRef((props, ref) => {
  const {
    width = BOARD_WIDTH,
    height = BOARD_HEIGHT,
    paintColor = PAINT_COLOR,
    backgroundColor,
    placeholder,
    onPaint,
    ...rest
  } = props;
  const [hasStartedPainting, setHasStartedPainting] = (0, _react.useState)(false);
  const canvasRef = (0, _react.useRef)(null);
  const controllerRef = (0, _react.useRef)({
    undo: _lodash.noop,
    redo: _lodash.noop,
    clear: _lodash.noop,
    destroy: _lodash.noop,
    exportToImage: () => null
  });
  (0, _react.useEffect)(() => {
    if (canvasRef.current) {
      const ele = canvasRef.current;
      const fn = () => {
        setHasStartedPainting(true);
        ele.removeEventListener('pointerdown', fn);
      };
      ele.addEventListener('pointerdown', fn);
    }
  }, [canvasRef.current]);
  const onChangeFnsRef = (0, _react.useRef)([]);
  const onPaintCallback = (0, _useEventCallback.useEventCallback)(() => onPaint && onPaint());
  (0, _react.useEffect)(() => {
    if (canvasRef.current) {
      const ele = canvasRef.current;
      ele.style.width = width + 'px';
      ele.style.height = height + 'px';
      ele.width = Math.floor(width * DPR);
      ele.height = Math.floor(height * DPR);
      const controller = createController(canvasRef.current, opt => {
        for (const fn of onChangeFnsRef.current) {
          fn(opt);
        }
        onPaintCallback();
      }, {
        paintColor,
        backgroundColor
      });
      controllerRef.current = controller;
      return () => {
        onChangeFnsRef.current = [];
        controller.destroy();
      };
    }
  }, []);
  (0, _react.useImperativeHandle)(ref, () => ({
    onChange: fn => {
      onChangeFnsRef.current.push(fn);
      return () => {
        const i = onChangeFnsRef.current.indexOf(fn);
        if (i !== -1) {
          onChangeFnsRef.current.splice(i, 1);
        }
      };
    },
    undo: () => controllerRef.current.undo(),
    redo: () => controllerRef.current.redo(),
    clear: () => controllerRef.current.clear(),
    exportToImage: controllerRef.current.exportToImage
  }));
  return /*#__PURE__*/_createElement(_styled.BoardWrapper, (0, _mergeRestProps.mergeRestProps)(rest, 'wdn-drawboard', {
    width,
    height
  }), !hasStartedPainting && placeholder ? /*#__PURE__*/_createElement(_styled.BoardPlaceholderWrapper, {
    style: {
      width,
      height
    }
  }, /*#__PURE__*/_createElement(_styled.BoardPlaceholder, null, placeholder)) : null, /*#__PURE__*/_createElement(_styled.Canvas, {
    style: {
      backgroundColor
    },
    ref: canvasRef
  }));
}));
exports.DrawBoard = DrawBoard;
const createController = (canvas, onChange, options) => {
  const {
    paintColor,
    backgroundColor
  } = options;
  const ctx = canvas.getContext('2d');
  ctx.scale(DPR, DPR);
  ctx.lineCap = LINE_CAP;
  ctx.strokeStyle = paintColor;
  if (backgroundColor) {
    ctx.fillStyle = backgroundColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
  let isPainting = false;
  let points = [];
  let lastSpeed = 0;
  let lastLineWidth = 5;
  let undoStack = [];
  let redoStack = [];
  const vCanvas = document.createElement('canvas');
  const change = () => onChange({
    undoAble: undoStack.length > 1,
    redoAble: redoStack.length > 0,
    clearAble: undoStack[undoStack.length - 1] !== null
  });
  const toPoint = event => {
    const e = 'clientX' in event ? event : event.touches[0];
    const {
      left,
      top
    } = canvas.getBoundingClientRect();
    return {
      x: e.clientX - left,
      y: e.clientY - top,
      t: Date.now()
    };
  };
  const clear = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (backgroundColor) {
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
  };
  const snapshot = () => {
    return ctx.getImageData(0, 0, canvas.width, canvas.height);
  };
  const restoreSnapshot = imageData => {
    if (imageData === null) {
      clear();
    } else {
      clear();
      ctx.putImageData(imageData, 0, 0);
    }
  };
  const handleStart = event => {
    isPainting = true;
    points.push(toPoint(event));
  };
  const draw = () => {
    if (points.length < 3) {
      return;
    }
    const getMidPoint = (p1, p2) => {
      return {
        x: (p1.x + p2.x) / 2,
        y: (p1.y + p2.y) / 2,
        t: (p1.t + p2.t) / 2
      };
    };
    const getTransferredSpeed = (startPoint, endPoint) => {
      const {
        x: x1,
        y: y1,
        t: t1
      } = startPoint;
      const {
        x: x2,
        y: y2,
        t: t2
      } = endPoint;
      const trueSpeed = (Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)) / (t2 - t1);
      const transferredSpeed = 0.7 * trueSpeed + (1 - 0.7) * lastSpeed;
      lastSpeed = transferredSpeed;
      return transferredSpeed;
    };
    const getLineWidthBySpeed = speed => {
      const currLineWidth = Math.max(5 - speed, 2);
      const transferredLineWidth = (lastLineWidth + currLineWidth) / 2;
      lastLineWidth = transferredLineWidth;
      return transferredLineWidth;
    };
    const [p1, p2, p3] = points;
    const startPoint = getMidPoint(p1, p2);
    const endPoint = getMidPoint(p2, p3);
    const {
      x: x2,
      y: y2
    } = p2;
    if (startPoint.x === endPoint.x && startPoint.y === endPoint.y) return;
    const speed = getTransferredSpeed(startPoint, endPoint);
    const currentLineWidth = getLineWidthBySpeed(speed);
    ctx.lineWidth = currentLineWidth;
    ctx.beginPath();
    ctx.moveTo(startPoint.x, startPoint.y);

    // p2 作为控制点, p1 与 p2 的中点作为起始点, p2 与 p3 的中点作为终止点
    ctx.quadraticCurveTo(x2, y2, endPoint.x, endPoint.y);
    ctx.stroke();
    ctx.closePath();
  };
  const handleMove = event => {
    // 解决移动端滚动穿透问题
    event.preventDefault();
    if (isPainting) {
      if (points.length === 3) {
        points.shift();
      }
      points.push(toPoint(event));
      draw();
    }
  };
  const handleEnd = () => {
    if (isPainting) {
      isPainting = false;
      points = [];
      lastSpeed = 0;
      lastLineWidth = 5;
      const sh = snapshot();
      if (sh) {
        while (undoStack.length > MAX_UNDO_STEP) {
          undoStack.shift();
        }
        undoStack.push(sh);
        redoStack = [];
        change();
      }
    }
  };
  const attachHandlers = () => {
    if (_isMobile.isIOS) {
      attachHandlersWithTouch();
    } else {
      attachHandlersWithPointer();
    }
  };
  const attachHandlersWithTouch = () => {
    canvas.addEventListener('touchstart', handleStart);
    canvas.addEventListener('touchmove', handleMove);
    canvas.addEventListener('touchend', handleEnd);
    canvas.addEventListener('touchcancel', handleEnd);
  };
  const attachHandlersWithPointer = () => {
    canvas.addEventListener('pointerdown', handleStart);
    canvas.addEventListener('pointermove', handleMove);
    canvas.addEventListener('pointerup', handleEnd);
    canvas.addEventListener('pointercancel', handleEnd);
  };
  const detachHandlers = () => {
    if (_isMobile.isIOS) {
      detachHandlersWithTouch();
    } else {
      detachHandlersWithPointer();
    }
  };
  const detachHandlersWithTouch = () => {
    canvas.removeEventListener('touchstart', handleStart);
    canvas.removeEventListener('touchmove', handleMove);
    canvas.removeEventListener('touchend', handleEnd);
    canvas.removeEventListener('touchcancel', handleEnd);
  };
  const detachHandlersWithPointer = () => {
    canvas.removeEventListener('pointerdown', handleStart);
    canvas.removeEventListener('pointermove', handleMove);
    canvas.removeEventListener('pointerup', handleEnd);
    canvas.removeEventListener('pointercancel', handleEnd);
  };
  attachHandlers();
  undoStack.push(null);
  return {
    undo: () => {
      if (undoStack.length > 1) {
        const sp = undoStack.pop();
        redoStack.push(sp);
        restoreSnapshot(undoStack[undoStack.length - 1]);
        change();
      }
    },
    redo: () => {
      if (redoStack.length > 0) {
        const sp = redoStack.pop();
        restoreSnapshot(sp);
        undoStack.push(sp);
        change();
      }
    },
    clear: () => {
      clear();
      undoStack.push(null);
      redoStack = [];
      change();
    },
    exportToImage: (type = 'dataUrl', options) => {
      if (!canvas) return null;
      if (type === 'dataUrl') {
        const {
          cropPadding
        } = options || {};
        if (cropPadding) {
          return getCroppedImage(canvas, vCanvas, cropPadding);
        }
        return {
          dataUrl: canvas.toDataURL('image/png', 1),
          width: canvas.width,
          height: canvas.height
        };
      }
      return null;
    },
    destroy: () => {
      detachHandlers();
    }
  };
};
//# sourceMappingURL=DrawBoard.js.map