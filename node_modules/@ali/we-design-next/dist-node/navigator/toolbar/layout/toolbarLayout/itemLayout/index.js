"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SingLineItemLayoutContent = exports.SingLineItemLayout = exports.DoubleLineItemLayout = void 0;
var _react = _interopRequireWildcard(require("react"));
var _lodash = require("lodash");
var _contexts = require("../../contexts");
var _style = require("./style");
var _resizeObserverPolyfill = _interopRequireDefault(require("resize-observer-polyfill"));
var _splitItemByLength = require("./splitItemByLength");
var _BaseIconButton = require("../../../baseItem/iconButton/BaseIconButton");
var _icon = require("../../../../../basic/icon");
var _popover = require("../../../../../display/popover");
var _constants = require("../constants");
var _locale = require("../../../../../locale");
var _IconMore;
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const _createElement = /*#__PURE__*/_react.default.createElement;
const noopElements = [];
const overLayStyle = {
  padding: 4,
  width: 'max-content',
  borderRadius: 4
};
const useSplitItems = (items, splitFun, fold, onLayoutRender) => {
  const ref = (0, _react.useRef)(null);
  const [itemNodes, setItemNodes] = (0, _react.useState)(!_constants.IS_NODE && fold ? undefined : items);
  const [resetNodes, setResetNodes] = (0, _react.useState)(undefined);
  const flagRef = (0, _react.useRef)({
    width: 0
  });
  const {
    setToolbarWidth
  } = (0, _react.useContext)(_contexts.ToolbarContext);
  (0, _react.useEffect)(() => {
    if (!fold) {
      setItemNodes(items);
      return;
    }
    const dom = ref.current;
    if (!dom) {
      return;
    }
    const domClientWidth = _constants.IS_NODE || _constants.IS_UITEST ? _constants.TOOLBAR_WIDTH_FOR_UITEST : dom.clientWidth;
    setToolbarWidth(domClientWidth);
    const [currentItems, resetItems] = splitFun(items, domClientWidth);
    flagRef.current.width = domClientWidth;
    setItemNodes(currentItems);
    setResetNodes(resetItems);
    const resizeHandle = (0, _lodash.throttle)(() => {
      var _ref$current;
      const currentWidth = (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.clientWidth;
      if (!currentWidth) {
        return;
      }
      if (currentWidth === flagRef.current.width) {
        return;
      }
      flagRef.current.width = currentWidth;
      setToolbarWidth(currentWidth);
      const [currentItems, resetItems] = splitFun(items, currentWidth);
      setItemNodes(currentItems);
      setResetNodes(resetItems);
      setTimeout(onLayoutRender, 0);
    }, 0);
    const resizeObserver = new _resizeObserverPolyfill.default(() => {
      resizeHandle();
    });
    resizeObserver.observe(ref.current);
    return () => {
      resizeHandle.cancel();
      resizeObserver.disconnect();
    };
  }, [items, setToolbarWidth]);
  (0, _react.useEffect)(() => {
    if (onLayoutRender !== _lodash.noop && itemNodes) {
      onLayoutRender();
    }
  }, [itemNodes, resetNodes]);
  return [ref, itemNodes, resetNodes];
};
const MoreBtn = /*#__PURE__*/_react.default.memo(props => {
  const t = (0, _locale.useTranslate)();
  const [visible, setVisible] = (0, _react.useState)(false);
  const visibleRef = (0, _react.useRef)(false);
  visibleRef.current = visible;
  (0, _react.useEffect)(() => {
    const resizeObserver = new _resizeObserverPolyfill.default(() => {
      setVisible(false);
    });
    resizeObserver.observe(document.body);
    return () => {
      resizeObserver.disconnect();
    };
  }, []);
  const onClick = (0, _react.useCallback)((0, _lodash.throttle)(() => {
    setVisible(!visibleRef.current);
  }, 500, {
    trailing: false
  }), []);
  return /*#__PURE__*/_createElement(_popover.Popover, {
    content: props.content,
    placement: "bottomRight",
    visible: visible,
    onVisibleChange: setVisible,
    animation: true
  }, /*#__PURE__*/_createElement("div", {
    className: "wdn-toolbar-more"
  }, /*#__PURE__*/_createElement(_BaseIconButton.BaseIconButton, {
    onClick: onClick,
    active: visible,
    icon: _IconMore || (_IconMore = /*#__PURE__*/_createElement(_icon.IconMore, null)),
    title: t('wdn_more'),
    size: props.size
  })));
});
function renderSingleLineGroupItems(items) {
  const res = [];
  for (let i = 0; i < items.length; i++) {
    const group = items[i];
    if (group === 'divider') {
      continue;
    }
    res.push( /*#__PURE__*/_createElement("div", {
      className: items[i + 1] === 'divider' ? 'wdn-toolbar-group divider' : 'wdn-toolbar-group'
    }, group));
  }
  return res;
}
const SingLineItemLayoutContent = /*#__PURE__*/_react.default.memo(props => {
  const {
    items,
    align,
    autoFold,
    onLayoutRender,
    background
  } = props;
  const [ref, itemNodes, resetNodes] = useSplitItems(items, _splitItemByLength.splitSingleLineItemByLength, autoFold, onLayoutRender);
  const nodes = itemNodes && renderSingleLineGroupItems(itemNodes);
  const restItems = resetNodes && renderSingleLineGroupItems(resetNodes);
  const overLayWrapperStyle = (0, _react.useMemo)(() => {
    return background ? {
      ...overLayStyle,
      background
    } : overLayStyle;
  }, [background]);
  return /*#__PURE__*/_createElement(_style.SingleLineWrapper, {
    className: `${align} toolbar-left single`,
    ref: ref
  }, nodes, restItems && /*#__PURE__*/_createElement(MoreBtn, {
    size: "normal",
    content: /*#__PURE__*/_createElement(_style.SingleLineWrapper, {
      style: overLayWrapperStyle
    }, restItems)
  }));
});
exports.SingLineItemLayoutContent = SingLineItemLayoutContent;
const SingLineItemLayout = /*#__PURE__*/_react.default.memo(props => {
  return /*#__PURE__*/_createElement(_contexts.ToolbarContextProvider, {
    mode: "singleLine"
  }, /*#__PURE__*/_createElement(SingLineItemLayoutContent, props));
});
exports.SingLineItemLayout = SingLineItemLayout;
function renderDoubleLineGroupItems(items) {
  const res = [];
  for (let i = 0; i < items.length; i++) {
    const group = items[i];
    if (group === 'divider') {
      continue;
    }
    const isBeforeWithDivider = items[i + 1] === 'divider';
    if (Array.isArray(group[0])) {
      res.push( /*#__PURE__*/_createElement("div", {
        className: isBeforeWithDivider ? 'wdn-toolbar-row-group divider' : 'wdn-toolbar-row-group'
      }, /*#__PURE__*/_createElement(_contexts.DoubleLineRowContext.Provider, {
        value: true
      }, /*#__PURE__*/_createElement("div", {
        className: "wdn-toolbar-row"
      }, group[0]), /*#__PURE__*/_createElement("div", {
        className: "wdn-toolbar-row"
      }, group[1]))));
    } else {
      res.push( /*#__PURE__*/_createElement("div", {
        className: isBeforeWithDivider ? 'wdn-toolbar-group divider' : 'wdn-toolbar-group'
      }, group));
    }
  }
  return res;
}
const DoubleLineItemLayoutContent = props => {
  const {
    items,
    align,
    autoFold,
    onLayoutRender,
    background
  } = props;
  const [ref, itemNodes, resetNodes] = useSplitItems(items, _splitItemByLength.splitDoubleLineItemByLength, autoFold, onLayoutRender);
  const nodes = itemNodes && renderDoubleLineGroupItems(itemNodes);
  const resetItems = resetNodes && renderDoubleLineGroupItems(resetNodes);
  const overLayWrapperStyle = (0, _react.useMemo)(() => {
    return background ? {
      ...overLayStyle,
      background
    } : overLayStyle;
  }, [background]);
  return /*#__PURE__*/_createElement(_style.DoubleLineWrapper, {
    className: `${align} toolbar-left double`,
    ref: ref
  }, nodes, resetNodes && /*#__PURE__*/_createElement(MoreBtn, {
    size: "large",
    content: /*#__PURE__*/_createElement(_style.DoubleLineWrapper, {
      style: overLayWrapperStyle
    }, resetItems)
  }));
};
const DoubleLineItemLayout = /*#__PURE__*/_react.default.memo(props => {
  return /*#__PURE__*/_createElement(_contexts.ToolbarContextProvider, {
    mode: "doubleLine"
  }, /*#__PURE__*/_createElement(DoubleLineItemLayoutContent, props));
});
exports.DoubleLineItemLayout = DoubleLineItemLayout;
//# sourceMappingURL=index.js.map