"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.splitDoubleLineItemByLength = splitDoubleLineItemByLength;
exports.splitSingleLineItemByLength = splitSingleLineItemByLength;
const presetItems = new Set(['iconSelect', 'textSelect', 'splitButton', 'iconMenu', 'iconButton']);
const noLargeItems = new Set(['iconSelect', 'textSelect', 'splitButton']);
const safeDit = 40;
const itemGroupPadding = 6;
const itemMargin_d = 6;
const itemMargin_s = 4;
const itemSize = {
  iconButton: {
    large: 36 + 9,
    normal: 28,
    small: 24
  },
  iconMenu: {
    large: 48,
    normal: 36,
    small: 36
  },
  splitButton: {
    large: 0,
    normal: 37,
    small: 37
  },
  iconSelect: {
    large: 0,
    normal: 37,
    small: 37
  },
  textSelect: {
    large: 0,
    normal: 100,
    small: 100
  }
};
function getSlotWidth(item, size, toolbarWidth) {
  let slotWidth;
  if (typeof item.props.width === 'function') {
    const mode = size === 'normal' ? 'singleLine' : 'doubleLine';
    slotWidth = item.props.width({
      mode,
      toolbarWidth: toolbarWidth
    });
  } else {
    slotWidth = item.props.width;
  }
  return Number(slotWidth) || 0;
}
function getItemLength(item, size, context) {
  const typeDisplay = item.type.displayName;
  let displayName = typeDisplay === 'toolbarSlot' ? item.props.display : typeDisplay;
  const presetItemWidth = itemSize[displayName] && itemSize[displayName][size] || 0;
  if (presetItems.has(displayName)) {
    // splitButton textSelect iconSelect 逻辑特殊
    if (noLargeItems.has(displayName)) {
      // splitButton textSelect iconSelect 在双行占两行情况下不显示
      if (size === 'large') {
        return 0;
      }
      // splitButton 和 双行模式下iconSelect 和 双行模式下 取一个最大值
      if (displayName === 'splitButton' || displayName === 'iconSelect' && size === 'small') {
        return Math.max(presetItemWidth, getSlotWidth(item, size, context.toolbarWidth));
      }
      // textSelect 使用传入的width
      if (displayName === 'textSelect') {
        return getSlotWidth(item, size, context.toolbarWidth) || presetItemWidth;
      }
    }
    return presetItemWidth;
  } else {
    // 认为是custom 需要根据slot的width进行计算
    return getSlotWidth(item, size, context.toolbarWidth);
  }
}
function getItemsMargin(item1, item2, size) {
  return size === 'normal' ? itemMargin_s : itemMargin_d;
}
;
function splitGroupItemByLength(items, length, size, context) {
  let restLength = length;
  const res = [];
  const lastIndex = items.length - 1;
  for (let i = 0; i < items.length; i++) {
    let itemLength = getItemLength(items[i], size, context);
    // 拿不到有效宽度的情况下 忽略掉当前的item
    if (itemLength <= 0) {
      continue;
    }
    restLength -= itemLength;
    if (i !== lastIndex) {
      restLength -= getItemsMargin(items[i], items[i + 1], size);
    }
    if (restLength >= 0) {
      res.push(items[i]);
    } else {
      return [0, res, items.slice(i)];
    }
  }
  return [restLength, res];
}
function splitSingleLineItemByLength(items, length) {
  let restLength = length - safeDit;
  const visibleItems = [];
  let isAfterDivider = false;
  for (let i = 0; i < items.length; i++) {
    const itemGroup = items[i];
    if (itemGroup === 'divider') {
      isAfterDivider = true;
      visibleItems.push('divider');
      continue;
    }
    if (isAfterDivider) {
      restLength -= itemGroupPadding;
      isAfterDivider = false;
    }
    const [restLength_, currentItems, resetItems] = splitGroupItemByLength(itemGroup, restLength, 'normal', {
      toolbarWidth: length
    });
    if (currentItems.length > 0) {
      visibleItems.push(currentItems);
    }
    if (resetItems) {
      return [visibleItems, [resetItems].concat(items.slice(i + 1))];
      // items.slice(i + 1)
    }

    restLength = restLength_;
    restLength -= itemGroupPadding;
  }
  return [visibleItems];
}
function splitDoubleLineItemByLength(items, length) {
  let restLength = length - safeDit;
  const visibleItems = [];
  const hideItems = [];
  const size = 'large';
  let isAfterDivider = false;
  for (let i = 0; i < items.length; i++) {
    const itemGroup = items[i];
    if (itemGroup === 'divider') {
      isAfterDivider = true;
      visibleItems.push('divider');
      continue;
    }
    if (isAfterDivider) {
      restLength -= itemGroupPadding;
      isAfterDivider = false;
    }
    if (Array.isArray(itemGroup[0])) {
      const [restLength_1, currentItems1, resetItems1] = splitGroupItemByLength(itemGroup[0], restLength, 'small', {
        toolbarWidth: length
      });
      const [restLength_2, currentItems2, resetItems2] = splitGroupItemByLength(itemGroup[1], restLength, 'small', {
        toolbarWidth: length
      });
      restLength = Math.min(restLength_1, restLength_2);
      if (resetItems1 || resetItems2) {
        hideItems.push([itemGroup[0] || [], itemGroup[1] || []]);
        hideItems.push(...items.slice(i + 1));
        break;
      }
      if (currentItems1.length > 0 && currentItems2.length > 0) {
        visibleItems.push([currentItems1, currentItems2]);
      }
    } else {
      const [restLength_, currentItems, resetItems] = splitGroupItemByLength(itemGroup, restLength, size, {
        toolbarWidth: length
      });
      restLength = restLength_;
      if (currentItems.length > 0) {
        visibleItems.push(currentItems);
      }
      if (resetItems) {
        hideItems.push(resetItems);
        hideItems.push(...items.slice(i + 1));
        break;
      }
    }
    restLength -= itemGroupPadding;
  }
  return hideItems.length > 0 ? [visibleItems, hideItems] : [visibleItems];
}
//# sourceMappingURL=splitItemByLength.js.map