"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TBFontFamilySelect = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _react = _interopRequireWildcard(require("react"));
var _textSelect = require("../../baseItem/textSelect");
var _select = require("../../../../form/select");
var _Tooltip = require("../../../../display/tooltip/Tooltip");
var _getFontFamily = require("./getFontFamily");
var _locale = require("../../../../locale");
var _common = require("../../../../common");
var _FontDetector = require("./FontDetector");
var _DownloadButton = require("./DownloadButton");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const _createElement = /*#__PURE__*/_react.default.createElement;
const fontSet = new Set(_getFontFamily.fontFamilies);
const getFontDetector = (() => {
  let fontDetectorMap = new Map();
  return function (fonts = _getFontFamily.fontFamilies) {
    let fontDetector = fontDetectorMap.get(fonts);
    if (fontDetector) {
      return fontDetector;
    }
    if (typeof fonts === 'string') {}
    fontDetector = new _FontDetector.FontDetector(typeof fonts === 'string' ? [fonts] : fonts);
    return fontDetector;
  };
})();
const useFontFamily = t => {
  // 字体列表选项
  const options = (0, _react.useMemo)(() => {
    const fontFamilies = (0, _getFontFamily.getFontFamily)(s => t(s));
    return fontFamilies;
  }, [t]);
  return options;
};
const temp = {};
const TBFontFamilySelect = /*#__PURE__*/_react.default.memo(props => {
  const {
    value: value_,
    onChange: onChange_,
    overlayVisible: overlayVisible_,
    onVisibleChange: onVisibleChange_,
    downloadFontInfos = temp,
    handleDownload,
    enableUnSupportFont = true,
    ...restProps
  } = props;
  const t = (0, _locale.useTranslate)();
  const [value, setValue] = (0, _common.useDefaultProp)('default', value_, onChange_);
  const [overlayVisible, onVisibleChange] = (0, _common.useDefaultProp)(false, overlayVisible_, onVisibleChange_);
  const [installedRecord, setInstalledRecord] = (0, _react.useState)({
    default: true
  });
  // font detected
  const fontDetectedRef = (0, _react.useRef)({
    fontDetected: false,
    installedRecord
  });
  fontDetectedRef.current.installedRecord = installedRecord;

  // @ts-ignore
  const fontFamiliesInfo = useFontFamily(t);
  const options = (0, _react.useMemo)(() => {
    const res = [];
    fontFamiliesInfo.forEach(t => {
      if (installedRecord[t.value] || t.installable) {
        var _downloadFontInfos$t$;
        res.push({
          key: t.value,
          title: t.title,
          disabled: !installedRecord[t.value] && ((_downloadFontInfos$t$ = downloadFontInfos[t.value]) === null || _downloadFontInfos$t$ === void 0 ? void 0 : _downloadFontInfos$t$.status) !== 'downloaded'
        });
      }
    });
    return res;
  }, [_getFontFamily.fontFamilies, installedRecord, downloadFontInfos]);

  // 单测环境下这里需要依赖浏览器 API 获取已安装字体然后显示，所以只有那些可安装的字体会显示。
  // 这里即使字体不可安装，也应该显示出来，作为列表一项
  const extendOptions = !enableUnSupportFont || options.some(opt => opt.key === value) ? options : [...options, {
    key: value,
    title: value,
    disabled: true
  }];
  const detectFont = (0, _react.useCallback)(font => {
    if (fontDetectedRef.current.fontDetected) {
      return;
    }
    if (font && !fontDetectedRef.current.installedRecord[font]) {
      getFontDetector(font).detect().then(([hasFont]) => {
        const newInstalledRecord = fontDetectedRef.current.installedRecord;
        setInstalledRecord({
          ...newInstalledRecord,
          [font]: hasFont
        });
      });
      return;
    }
    getFontDetector().detect().then(results => {
      const newInstalledRecord = {};
      results.forEach((result, index) => {
        if (index !== 0) {
          newInstalledRecord[_getFontFamily.fontFamilies[index]] = result;
        }
      });
      newInstalledRecord.default = true;
      setInstalledRecord(newInstalledRecord);
      fontDetectedRef.current.fontDetected = true;
    });
  }, []);
  (0, _react.useEffect)(() => {
    if (fontDetectedRef.current.fontDetected) {
      return;
    }
    if (value !== 'default') {
      detectFont(value);
    }
  }, [value]);
  (0, _react.useLayoutEffect)(() => {
    if (overlayVisible) {
      detectFont();
    }
  }, [overlayVisible]);
  const renderOption = (0, _react.useCallback)(({
    key
  }) => {
    const {
      title,
      disabled,
      key: family
    } = extendOptions.find(o => o.key === key) || {
      title: ''
    };
    if (handleDownload && disabled && downloadFontInfos[key]) {
      return /*#__PURE__*/_createElement(_select.Select.Option, {
        key: key,
        children: /*#__PURE__*/_createElement("div", {
          style: {
            display: 'flex',
            justifyContent: 'space-between'
          }
        }, /*#__PURE__*/_createElement(_Tooltip.Tooltip, {
          title: t('wdn_font_UninstallFonts'),
          placement: "top"
        }, /*#__PURE__*/_createElement("div", null, title)), /*#__PURE__*/_createElement(_DownloadButton.DownloadButton, {
          handleDownload: handleDownload,
          status: downloadFontInfos[key].status,
          fontFamily: key
        }))
      });
    }
    const titleNode = /*#__PURE__*/_createElement("div", {
      style: disabled ? undefined : {
        fontFamily: family
      }
    }, title);
    return /*#__PURE__*/_createElement(_select.Select.Option, {
      key: key,
      children: disabled ? /*#__PURE__*/_createElement(_Tooltip.Tooltip, {
        title: t('wdn_font_UninstallFonts'),
        placement: "top"
      }, titleNode) : titleNode
    });
  }, [installedRecord, handleDownload, downloadFontInfos]);
  let fontValue = value;
  if (!enableUnSupportFont) {
    fontValue = fontSet.has(value) ? value : 'default';
  }
  return /*#__PURE__*/_createElement(_textSelect.TBTextSelect, (0, _extends2.default)({}, restProps, {
    value: fontValue,
    overlayVisible: overlayVisible,
    onVisibleChange: onVisibleChange,
    onChange: setValue,
    options: extendOptions,
    renderOption: renderOption
  }));
});
exports.TBFontFamilySelect = TBFontFamilySelect;
TBFontFamilySelect.displayName = 'textSelect';
//# sourceMappingURL=index.js.map