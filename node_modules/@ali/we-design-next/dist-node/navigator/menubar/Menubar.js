"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Menubar = void 0;
var _react = _interopRequireWildcard(require("react"));
var _styled = require("./styled");
var _common = require("../../common");
var _menu = require("../../display/menu");
var _nested = require("../../basic/list/nested");
var _popover = require("../../display/popover");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const _createElement = /*#__PURE__*/_react.default.createElement;
const Menubar = /*#__PURE__*/_react.default.memo(props => {
  const {
    path: _path,
    onPathChange,
    menus = [],
    onSelect
  } = props;
  const [path, setPath] = (0, _common.useDefaultProp)([], _path, onPathChange);
  const ref = (0, _react.useRef)(null);
  const [focusTargetId, focusTarget, focusOwner] = (0, _common.useFocusTarget)(ref);
  const onKeydown = e => {
    const idx = menus.findIndex(m => m.key === path[0]);
    if (idx !== -1) {
      if (e.keyCode === _common.KEY_CODES.RIGHT && idx < menus.length - 1) {
        focusTarget(() => setPath([menus[idx + 1].key, undefined]));
      } else if (e.keyCode === _common.KEY_CODES.LEFT && idx > 0) {
        focusTarget(() => setPath([menus[idx - 1].key, undefined]));
      } else if (e.keyCode === _common.KEY_CODES.DOWN && !path[1]) {
        const menu = menus.find(m => m.key === path[0]);
        if (menu) {
          const its = (0, _nested.flattenNested)(menu.items || []).filter(_nested.isNormalized).filter(_nested.isEnabled);
          const k = its[0].key;
          focusTarget(() => setPath([path[0], k]));
        }
      } else if (e.keyCode === _common.KEY_CODES.ESC) {
        focusOwner(() => {
          setPath([]);
          e.stopPropagation();
        });
      }
    }
  };
  return /*#__PURE__*/_createElement(_styled.MenubarWrap, {
    ref: ref,
    tabIndex: -1,
    onKeyDown: onKeydown
  }, menus.map(it => /*#__PURE__*/_createElement(_popover.Popover, {
    placement: "bottomLeft",
    animation: true,
    content: /*#__PURE__*/_createElement(_menu.Menu, {
      id: focusTargetId,
      items: it.items,
      path: [...path].splice(1),
      onPathChange: p => setPath([it.key, ...p]),
      onSelect: p => onSelect && onSelect([it.key, ...p])
    }),
    visible: path[0] === it.key && path.length > 1,
    trigger: "click",
    onVisibleChange: v => {
      if (v) {
        focusTarget(() => setPath([it.key, undefined]));
      } else {
        if (it.key === path[0]) {
          setPath([path[0]]);
        }
      }
    }
  }, /*#__PURE__*/_createElement(_styled.MenubarItemWrap, {
    active: path[0] === it.key,
    onMouseEnter: () => {
      if (!!path[0] && path[0] !== it.key) {
        focusTarget(() => setPath([it.key, undefined]));
      }
    }
  }, it.title))));
});
exports.Menubar = Menubar;
//# sourceMappingURL=Menubar.js.map