"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SheetTabsProvider = exports.SheetTabs = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _react = _interopRequireWildcard(require("react"));
var _lodash = require("lodash");
var _common = require("../../common");
var _locale = require("../../locale");
var _tooltip = require("../../display/tooltip");
var _icon = require("../../basic/icon");
var _Tab = require("./Tab");
var _InlineTab = require("./InlineTab");
var _SheetSelect = require("./SheetSelect");
var _styled = require("./styled");
var _resizeObserverPolyfill = _interopRequireDefault(require("resize-observer-polyfill"));
var _IconAdd, _IconArrowLeft, _IconArrowRight;
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const _createElement = /*#__PURE__*/_react.default.createElement;
const SheetTabsProvider = /*#__PURE__*/_react.default.createContext({});
exports.SheetTabsProvider = SheetTabsProvider;
const getDraggingTabStyle = (isDragging, draggableStyle) => {
  const {
    transform
  } = draggableStyle;
  if (isDragging && transform) {
    const translateX = transform.slice(transform.indexOf('(') + 1, transform.indexOf(','));
    return {
      ...draggableStyle,
      transform: `translate(${translateX}, 0)`
    };
  }
  return draggableStyle;
};
const SheetTabsRaw = /*#__PURE__*/_react.default.memo( /*#__PURE__*/_react.default.forwardRef((props, ref) => {
  const {
    tabs,
    defaultTab = tabs.length > 0 ? tabs[0].key : '',
    tab: _tab,
    onTabChange,
    onAdd,
    onRename,
    onMove,
    onContextMenu,
    switchable = true,
    movable = true,
    addable = true,
    renamable = false,
    renderTab,
    renderInlineTab,
    renderAddButton,
    ...rest
  } = props;
  const [tab, setTab] = (0, _common.useDefaultProp)(defaultTab, _tab, onTabChange);
  const [editTab, setEditTab] = (0, _react.useState)(null);
  const tabsWithoutHidden = (0, _react.useMemo)(() => tabs.filter(item => !item.hidden), [tabs]);
  const editHandlers = (0, _react.useRef)({});
  const [isDragging, setIsDragging] = (0, _react.useState)(false);
  const contentRef = (0, _react.useRef)(null);
  const [arrowState, setArrowState] = (0, _react.useState)({
    arrowVisible: false,
    canTranslatePrev: false,
    canTranslateNext: false
  });
  const t = (0, _locale.useTranslate)();
  (0, _react.useImperativeHandle)(ref, () => ({
    startEdit: editHandlers.current[tab]
  }));

  // iframe 条件下，鼠标拖出视口外，没有触发 mouseup，因此此处进行 hack
  const handleMouseLeaveWhenDragging = (0, _react.useCallback)(() => {
    if (isDragging && window.self !== window.top) {
      // trigger mouseup
      setTimeout(() => {
        var _contentRef$current;
        const event = document.createEvent('MouseEvents');
        event.initEvent('mouseup', true, true);
        (_contentRef$current = contentRef.current) === null || _contentRef$current === void 0 ? void 0 : _contentRef$current.dispatchEvent(event);
      }, 200);
    }
  }, [isDragging]);
  (0, _react.useEffect)(() => {
    document.body.addEventListener('mouseleave', handleMouseLeaveWhenDragging);
    return () => {
      document.body.removeEventListener('mouseleave', handleMouseLeaveWhenDragging);
    };
  }, [handleMouseLeaveWhenDragging]);
  const sheetTabsContext = (0, _react.useMemo)(() => {
    return {
      editHandlers
    };
  }, [editHandlers]);
  const activeTabScrollIntoView = (0, _react.useCallback)(() => {
    requestAnimationFrame(() => {
      var _document$getElementB;
      (_document$getElementB = document.getElementById(`${_Tab.TAB_ID_PREFIX}${tab}`)) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.scrollIntoView();
    });
  }, [tab]);
  const handleArrow = (0, _react.useCallback)((0, _lodash.debounce)(() => {
    const scrollDom = contentRef === null || contentRef === void 0 ? void 0 : contentRef.current;
    if (!scrollDom) return;
    const newArrowVisible = scrollDom.scrollWidth > scrollDom.clientWidth;
    const newCanTranslatePrev = scrollDom.scrollLeft > 0;
    const newCanTranslateNext = scrollDom.scrollLeft < scrollDom.scrollWidth - scrollDom.clientWidth;
    setArrowState(prevState => {
      if (newArrowVisible !== prevState.arrowVisible || newCanTranslatePrev !== prevState.canTranslatePrev || newCanTranslateNext !== prevState.canTranslateNext) {
        return {
          arrowVisible: newArrowVisible,
          canTranslatePrev: newCanTranslatePrev,
          canTranslateNext: newCanTranslateNext
        };
      }
      return prevState;
    });
    activeTabScrollIntoView();
  }, 0), [activeTabScrollIntoView]);
  const handleScrollToEdge = (0, _react.useCallback)((0, _lodash.debounce)(() => {
    const scrollDom = contentRef === null || contentRef === void 0 ? void 0 : contentRef.current;
    if (!scrollDom) return;
    const newCanTranslatePrev = scrollDom.scrollLeft > 0;
    // ceil消除scrollDom.scrollLeft最大值有时是小数, 小0.5像素
    const newCanTranslateNext = Math.ceil(scrollDom.scrollLeft) < scrollDom.scrollWidth - scrollDom.clientWidth;
    setArrowState(prevState => {
      if (newCanTranslatePrev !== prevState.canTranslatePrev || newCanTranslateNext !== prevState.canTranslateNext) {
        return {
          arrowVisible: prevState.arrowVisible,
          canTranslateNext: newCanTranslateNext,
          canTranslatePrev: newCanTranslatePrev
        };
      }
      return prevState;
    });
  }, 100), []);
  (0, _react.useEffect)(() => {
    handleArrow();
  }, [tabs.length, tab, handleArrow]);
  (0, _react.useEffect)(() => {
    const debouncedResize = (0, _lodash.debounce)(() => {
      handleArrow();
    }, 200);
    const resizeObserver = new _resizeObserverPolyfill.default(debouncedResize);
    resizeObserver.observe(contentRef.current);
    return () => {
      resizeObserver.disconnect();
      if (debouncedResize.cancel) {
        debouncedResize.cancel();
      }
    };
  }, [handleArrow]);
  const handleTranslatePrev = (0, _react.useCallback)(() => {
    const scrollDom = contentRef === null || contentRef === void 0 ? void 0 : contentRef.current;
    if (!scrollDom) return;
    const preLeft = scrollDom.scrollLeft - scrollDom.clientWidth;
    scrollDom.scrollTo({
      left: preLeft < 0 ? 0 : preLeft
    });
  }, []);
  const handleTranslateNext = (0, _react.useCallback)(() => {
    const scrollDom = contentRef === null || contentRef === void 0 ? void 0 : contentRef.current;
    if (!scrollDom) return;
    const preLeft = scrollDom.scrollLeft + scrollDom.clientWidth;
    const maxLeft = scrollDom.scrollWidth - scrollDom.clientWidth;
    scrollDom.scrollTo({
      left: preLeft > maxLeft ? maxLeft : preLeft
    });
  }, []);
  const convertDestinationToAfter = (0, _react.useCallback)((sourceIndex, destinationIndex) => {
    if (destinationIndex === 0) return null;
    if (sourceIndex < destinationIndex) {
      return tabs[destinationIndex].key;
    }
    return tabs[destinationIndex - 1].key;
  }, [tabs]);
  const handleDragStart = (0, _react.useCallback)(() => {
    setIsDragging(true);
  }, []);
  const handleDragEnd = (0, _react.useCallback)(e => {
    setIsDragging(false);
    const {
      destination,
      source,
      draggableId
    } = e;
    if (destination && destination.index !== source.index) {
      const after = convertDestinationToAfter(source.index, destination.index);
      onMove === null || onMove === void 0 ? void 0 : onMove(draggableId, after);
    }
  }, [onMove]);
  const handleEditTab = (0, _react.useCallback)(key => {
    if (editTab !== key) {
      setEditTab(key);
    }
  }, [editTab]);
  const handleQuitEditTab = (0, _react.useCallback)(key => {
    if (editTab === key) {
      setEditTab(null);
    }
  }, [editTab]);
  const addButton = /*#__PURE__*/_createElement(_styled.IconWrapper, {
    className: (0, _common.mergeClassName)(addable === "disabled" ? "disabled" : undefined),
    style: {
      marginLeft: 8
    },
    onClick: () => onAdd === null || onAdd === void 0 ? void 0 : onAdd(tab)
  }, _IconAdd || (_IconAdd = /*#__PURE__*/_createElement(_icon.IconAdd, null)));
  const prevButton = /*#__PURE__*/_createElement(_styled.IconWrapper, {
    className: (0, _common.mergeClassName)(arrowState.canTranslatePrev ? undefined : "disabled"),
    onClick: arrowState.canTranslatePrev ? handleTranslatePrev : undefined
  }, _IconArrowLeft || (_IconArrowLeft = /*#__PURE__*/_createElement(_icon.IconArrowLeft, null)));
  const nextButton = /*#__PURE__*/_createElement(_styled.IconWrapper, {
    className: (0, _common.mergeClassName)(arrowState.canTranslateNext ? undefined : "disabled"),
    onClick: arrowState.canTranslateNext ? handleTranslateNext : undefined
  }, _IconArrowRight || (_IconArrowRight = /*#__PURE__*/_createElement(_icon.IconArrowRight, null)));
  const Handler = DND.Handler;
  return /*#__PURE__*/_createElement(_styled.SheetTabsWrapper, (0, _common.mergeRestProps)(rest, 'wdn-sheet-tabs'), /*#__PURE__*/_createElement(_styled.LeftIcons, null, /*#__PURE__*/_createElement(_SheetSelect.SheetSelect, {
    tabs: tabs,
    tab: tab,
    setActiveTab: setTab,
    disabled: !switchable,
    renderInlineTab: renderInlineTab
  }), addable ? (renderAddButton === null || renderAddButton === void 0 ? void 0 : renderAddButton()) || (addable === "disabled" ? addButton : /*#__PURE__*/_createElement(_tooltip.Tooltip, {
    title: t('wdn_sheet_tabs_add'),
    placement: "top"
  }, addButton)) : null), /*#__PURE__*/_createElement(SheetTabsProvider.Provider, {
    value: sheetTabsContext
  }, movable && Handler ? /*#__PURE__*/_createElement(Handler.DragDropContext, {
    onDragStart: handleDragStart,
    onDragEnd: handleDragEnd
  }, /*#__PURE__*/_createElement(Handler.Droppable, {
    droppableId: "wdn-sheet-tabs",
    direction: "horizontal"
  }, dropProvided => /*#__PURE__*/_createElement(_styled.TabsWrapper, (0, _extends2.default)({
    ref: (0, _common.mergeRef)(dropProvided.innerRef, contentRef)
  }, dropProvided.droppableProps, {
    onScroll: handleScrollToEdge
  }), tabsWithoutHidden.map((tabInfo, index) => {
    const {
      key,
      title
    } = tabInfo;
    return /*#__PURE__*/_createElement(Handler.Draggable, {
      key: key,
      draggableId: key,
      index: index
    }, (dragProvider, dragSnapshot) => (0, _common.renderReactNode)(renderTab, /*#__PURE__*/_createElement(_Tab.Tab, (0, _extends2.default)({}, dragProvider.draggableProps, dragProvider.dragHandleProps, {
      ref: dragProvider.innerRef,
      tab: key,
      title: title,
      active: key === tab,
      editing: key === editTab,
      setActiveTab: setTab,
      onEditingTab: handleEditTab,
      onQuitEditingTab: handleQuitEditTab,
      switchable: switchable,
      renamable: renamable,
      onRename: onRename,
      onContextMenu: onContextMenu,
      style: getDraggingTabStyle(dragSnapshot.isDragging, dragProvider.draggableProps.style)
    })), {
      key
    }));
  })))) : /*#__PURE__*/_createElement(_styled.TabsWrapper, {
    ref: contentRef,
    onScroll: handleScrollToEdge
  }, tabsWithoutHidden.map(tabInfo => {
    const {
      key,
      title
    } = tabInfo;
    return (0, _common.renderReactNode)(renderTab, /*#__PURE__*/_createElement(_Tab.Tab, {
      key: key,
      tab: key,
      title: title,
      active: key === tab,
      editing: key === editTab,
      setActiveTab: setTab,
      onEditingTab: handleEditTab,
      onQuitEditingTab: handleQuitEditTab,
      switchable: switchable,
      renamable: renamable,
      onRename: onRename,
      onContextMenu: onContextMenu
    }), {
      key
    });
  }))), arrowState.arrowVisible ? /*#__PURE__*/_createElement(_styled.RightIcons, null, arrowState.canTranslatePrev ? /*#__PURE__*/_createElement(_tooltip.Tooltip, {
    title: t('wdn_sheet_tabs_scroll_left'),
    placement: "top"
  }, prevButton) : prevButton, arrowState.canTranslateNext ? /*#__PURE__*/_createElement(_tooltip.Tooltip, {
    title: t('wdn_sheet_tabs_scroll_right'),
    placement: "top"
  }, nextButton) : nextButton) : null);
}));
const DND = {};
const SheetTabs = (0, _common.combineReactComponent)(SheetTabsRaw, {
  init: handler => DND.Handler = handler,
  Tab: _Tab.Tab,
  InlineTab: _InlineTab.InlineTab
});
exports.SheetTabs = SheetTabs;
//# sourceMappingURL=SheetTabs.js.map