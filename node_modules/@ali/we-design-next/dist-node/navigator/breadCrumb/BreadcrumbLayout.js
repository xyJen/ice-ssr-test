"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BreadcrumbLayout = void 0;
var _react = _interopRequireWildcard(require("react"));
var _lodash = require("lodash");
var _resizeObserverPolyfill = _interopRequireDefault(require("resize-observer-polyfill"));
var _common = require("../../common");
var _Breadcrumb = require("./Breadcrumb");
var _contexts = require("./contexts");
var _styles = require("./styles");
var _span;
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const _createElement = /*#__PURE__*/_react.default.createElement;
// .../ 的 path
const ELLIPSISPATH = '';
// .../ 的 name
const ELLIPSISNAME = '...';
const BreadcrumbLayout = /*#__PURE__*/(0, _react.memo)(props => {
  const {
    routes,
    onClick,
    renderFilename: renderFileName,
    width: containerWidth = -1,
    maxWidth = -1
  } = props;
  // 组件 测量 ref
  const ref = (0, _react.useRef)(null);
  // ../ 测量 ref
  const liRef = (0, _react.useRef)(null);
  // 分隔符测量 ref
  const spanRef = (0, _react.useRef)(null);
  // 响应式节点
  const [singleLineRoutes, setsingleLineRoutes] = (0, _react.useState)(routes);
  // mirror 上节点的 refs
  const [references] = (0, _react.useState)({});
  // 计算需要 ellipsis 节点的宽度
  const [ellipsisBreadCrumbMaxWidth, setEllipsisBreadCrumbMaxWidth] = (0, _react.useState)(-1);
  // 计算需要 ellipsis 节点的位置 
  const [ellipsisBreadCrumbIndex, setEllipsisBreadCrumbIndex] = (0, _react.useState)(-1);
  const onResize = (0, _common.useEventCallback)(() => {
    if (ref !== null && ref !== void 0 && ref.current && Object.keys(references).length >= routes.length && liRef !== null && liRef !== void 0 && liRef.current && spanRef !== null && spanRef !== void 0 && spanRef.current && containerWidth !== -1) {
      var _liRef$current$getBou, _spanRef$current$getB, _references$current, _references$current$g, _references$0$current, _references$0$current2;
      // .../ 的宽度
      const ELLIPSISWIDTH = (_liRef$current$getBou = liRef.current.getBoundingClientRect()) === null || _liRef$current$getBou === void 0 ? void 0 : _liRef$current$getBou.width;
      // separator 的宽度
      const SEPARATORWIDTH = (_spanRef$current$getB = spanRef.current.getBoundingClientRect()) === null || _spanRef$current$getB === void 0 ? void 0 : _spanRef$current$getB.width;
      // 节点由 ellipsis 变为收起的临界点
      const ELLIPSISMINWIDTH = SEPARATORWIDTH + 10;
      const width = Math.ceil(ref.current.getBoundingClientRect().width) - 1;
      // mirror 最右边的节点
      const lastItemWidth = (_references$current = references[routes.length - 1].current) === null || _references$current === void 0 ? void 0 : (_references$current$g = _references$current.getBoundingClientRect()) === null || _references$current$g === void 0 ? void 0 : _references$current$g.width;
      // mirror 最左边的节点
      const firstItemWidth = (_references$0$current = references[0].current) === null || _references$0$current === void 0 ? void 0 : (_references$0$current2 = _references$0$current.getBoundingClientRect()) === null || _references$0$current2 === void 0 ? void 0 : _references$0$current2.width;
      // mirror 宽度
      const totalWidth = Math.ceil(Object.keys(references).reduce((pre, cur) => {
        var _references$Number, _references$Number2, _references$Number2$c, _references$Number2$c2;
        return (_references$Number = references[Number(cur)]) !== null && _references$Number !== void 0 && _references$Number.current ? pre + ((_references$Number2 = references[Number(cur)]) === null || _references$Number2 === void 0 ? void 0 : (_references$Number2$c = _references$Number2.current) === null || _references$Number2$c === void 0 ? void 0 : (_references$Number2$c2 = _references$Number2$c.getBoundingClientRect()) === null || _references$Number2$c2 === void 0 ? void 0 : _references$Number2$c2.width) : pre;
      }, -1));

      // lastBreadcrumb...
      if (routes.length === 1) {
        setEllipsisBreadCrumbIndex(0);
        setEllipsisBreadCrumbMaxWidth(Math.floor(width));
        return setsingleLineRoutes(routes);
      }
      // ... / lastBreadcrumb
      if (Math.floor(lastItemWidth + ELLIPSISWIDTH + ELLIPSISMINWIDTH) >= width) {
        setEllipsisBreadCrumbIndex(1);
        setEllipsisBreadCrumbMaxWidth(width - Math.floor(ELLIPSISWIDTH));
        return setsingleLineRoutes([{
          path: ELLIPSISPATH,
          name: ELLIPSISNAME,
          children: routes.slice(0, -1)
        }, ...routes.slice(-1)]);
      }
      // firstBreadcrumb... / lastBreadcrumb
      if (routes.length === 2) {
        setEllipsisBreadCrumbIndex(0);
        setEllipsisBreadCrumbMaxWidth(width - Math.floor(lastItemWidth + SEPARATORWIDTH));
        return setsingleLineRoutes(routes);
      }
      // firstBreadcrumb / ... / lastBreadcrumb
      if (Math.floor(firstItemWidth + lastItemWidth + ELLIPSISWIDTH + ELLIPSISMINWIDTH) >= width) {
        setEllipsisBreadCrumbIndex(0);
        setEllipsisBreadCrumbMaxWidth(width - Math.floor(lastItemWidth + ELLIPSISWIDTH + SEPARATORWIDTH));
        return setsingleLineRoutes([...routes.slice(0, 1), {
          path: ELLIPSISPATH,
          name: ELLIPSISNAME,
          children: routes.slice(1, -1)
        }, ...routes.slice(-1)]);
      }

      // firstBreadcrumb / ellipsisBreadcrumb... / lastBreadcrumb 
      if (width < totalWidth && routes.length >= 3) {
        var _references$1$current, _references$1$current2;
        const secontItemWidth = Math.floor((_references$1$current = references[1].current) === null || _references$1$current === void 0 ? void 0 : (_references$1$current2 = _references$1$current.getBoundingClientRect()) === null || _references$1$current2 === void 0 ? void 0 : _references$1$current2.width);
        if (totalWidth - secontItemWidth + ELLIPSISMINWIDTH <= width) {
          var _references$, _references$$current, _references$$current$;
          setEllipsisBreadCrumbIndex(1);
          setEllipsisBreadCrumbMaxWidth(width - totalWidth + Math.floor(((_references$ = references[1]) === null || _references$ === void 0 ? void 0 : (_references$$current = _references$.current) === null || _references$$current === void 0 ? void 0 : (_references$$current$ = _references$$current.getBoundingClientRect()) === null || _references$$current$ === void 0 ? void 0 : _references$$current$.width) - SEPARATORWIDTH));
          return routes;
        }
      }
      // firstBreadcrumb / ... / ellipsisBreadcrumb... / lastBreadcrumb
      if (width < totalWidth && routes.length > 3) {
        var _references$ellipsisI4, _references$ellipsisI5, _references$ellipsisI6;
        // routes 掐头去尾累加宽度，找到 ellipsisBreadcrumb
        const {
          width: ellipsisWidth,
          index: ellipsisIndex
        } = Object.keys(references).slice(1, routes.length - 1).reduceRight((pre, _, index) => {
          var _references, _references$current2, _references$current2$;
          if (pre.width > width) {
            return pre;
          }
          // 从右向左累加下一个 breadcrumb + separator
          const curWidth = pre.width + ((_references = references[index + 1]) === null || _references === void 0 ? void 0 : (_references$current2 = _references.current) === null || _references$current2 === void 0 ? void 0 : (_references$current2$ = _references$current2.getBoundingClientRect()) === null || _references$current2$ === void 0 ? void 0 : _references$current2$.width);
          // 从右向左累加从 ellipsis 到 ... 里面时的临界值 
          const curEllipisisWidth = pre.width + ELLIPSISMINWIDTH;
          // index + 1 所在的位置为 ellipsisBreadcrumb
          if (curEllipisisWidth <= width && curWidth > width) {
            return {
              width: curWidth,
              index: index + 1
            };
          }
          // index + 2 所在的位置为 ellipsisBreadcrumb 
          if (curEllipisisWidth > width && curWidth > width) {
            return {
              width: width + 1,
              index: index + 2
            };
          }
          return {
            width: curWidth,
            index: index
          };
        }, {
          // 初始值为 firstBreadcrumb / ... / lastBreadcrumb 宽度之和
          width: firstItemWidth + lastItemWidth + ELLIPSISWIDTH,
          index: -1
        });

        // firstBreadcrumb / ellipsisBreadcrumb... / lastBreadcrumb 
        if (ellipsisIndex === 1) {
          var _references$ellipsisI, _references$ellipsisI2, _references$ellipsisI3;
          setEllipsisBreadCrumbIndex(1);
          setEllipsisBreadCrumbMaxWidth(width - totalWidth + Math.floor(((_references$ellipsisI = references[ellipsisIndex]) === null || _references$ellipsisI === void 0 ? void 0 : (_references$ellipsisI2 = _references$ellipsisI.current) === null || _references$ellipsisI2 === void 0 ? void 0 : (_references$ellipsisI3 = _references$ellipsisI2.getBoundingClientRect()) === null || _references$ellipsisI3 === void 0 ? void 0 : _references$ellipsisI3.width) - SEPARATORWIDTH + ELLIPSISWIDTH));
          return routes;
        }
        setEllipsisBreadCrumbIndex(2);
        // 总宽度 - 不包含 ellipsisBreadcrumb 总宽度 - 分割线宽度 = ellipsisBreadcrumb 能显示的最大宽度 
        setEllipsisBreadCrumbMaxWidth(width - Math.floor(ellipsisWidth - ((_references$ellipsisI4 = references[ellipsisIndex]) === null || _references$ellipsisI4 === void 0 ? void 0 : (_references$ellipsisI5 = _references$ellipsisI4.current) === null || _references$ellipsisI5 === void 0 ? void 0 : (_references$ellipsisI6 = _references$ellipsisI5.getBoundingClientRect()) === null || _references$ellipsisI6 === void 0 ? void 0 : _references$ellipsisI6.width) + SEPARATORWIDTH));
        return setsingleLineRoutes([...routes.slice(0, 1), {
          path: ELLIPSISPATH,
          name: ELLIPSISNAME,
          children: routes.slice(1, ellipsisIndex)
        }, ...routes.slice(ellipsisIndex)]);
      }
      // default
      setEllipsisBreadCrumbIndex(-1);
      setsingleLineRoutes(routes);
    }
  });
  const throttledOnResize = (0, _react.useMemo)(() => (0, _lodash.debounce)(onResize, 550), [onResize]);

  // routes 更新时 resize
  (0, _react.useEffect)(() => {
    setsingleLineRoutes(routes);
  }, [routes]);

  // 没有 width 时 resize
  (0, _react.useEffect)(() => {
    if (containerWidth === -1) {
      setEllipsisBreadCrumbIndex(-1);
      setsingleLineRoutes(routes);
    }
  }, [routes, containerWidth]);
  (0, _react.useEffect)(() => {
    if (ref.current) {
      const obs = new _resizeObserverPolyfill.default(throttledOnResize);
      obs.observe(ref.current);
      return () => {
        obs.disconnect();
      };
    }
  }, [routes]);

  // mirror 测量 ref
  const getOrCreateRef = (0, _react.useCallback)((id, ref) => {
    references[id] = ref;
  }, []);
  return /*#__PURE__*/_createElement(_contexts.BreadcrumbContext.Provider, {
    value: {
      mode: 'singleLine'
    }
  }, /*#__PURE__*/_createElement(_styles.Container, null, /*#__PURE__*/_createElement(_contexts.SingleLineRowContext.Provider, {
    value: {
      isSingleLine: false
    }
  }, /*#__PURE__*/_createElement("div", {
    className: "mirror-breadcrumb"
  }, /*#__PURE__*/_createElement(_Breadcrumb.Breadcrumb, {
    routes: routes,
    renderLastItem: renderFileName,
    getOrCreateRef: getOrCreateRef
  }), /*#__PURE__*/_createElement("ol", null, /*#__PURE__*/_createElement("li", {
    ref: liRef
  }, _span || (_span = /*#__PURE__*/_createElement("span", {
    className: "mirror-link"
  }, ELLIPSISNAME)), /*#__PURE__*/_createElement("span", {
    className: "mirror-separator",
    ref: spanRef,
    style: {
      padding: 4
    }
  }, "/"))))), /*#__PURE__*/_createElement(_contexts.SingleLineRowContext.Provider, {
    value: {
      isSingleLine: true,
      ellipisisIndex: ellipsisBreadCrumbIndex,
      ellipisisWidth: ellipsisBreadCrumbMaxWidth
    }
  }, /*#__PURE__*/_createElement("div", {
    className: "single-line-breadcrumb",
    ref: ref,
    style: {
      width: containerWidth === -1 ? '100%' : containerWidth,
      maxWidth
    }
  }, /*#__PURE__*/_createElement(_Breadcrumb.Breadcrumb, {
    routes: singleLineRoutes,
    renderLastItem: renderFileName,
    onBreadcrumbItemClick: onClick
  })))));
});
exports.BreadcrumbLayout = BreadcrumbLayout;
//# sourceMappingURL=BreadcrumbLayout.js.map