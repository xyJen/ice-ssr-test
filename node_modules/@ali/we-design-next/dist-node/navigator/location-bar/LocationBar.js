"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LocationBar = void 0;
var _react = _interopRequireWildcard(require("react"));
var _LocationBarSlot = require("./LocationBarSlot");
var _styled = require("./styled");
var _resizeObserverPolyfill = _interopRequireDefault(require("resize-observer-polyfill"));
var _lodash = require("lodash");
var _common = require("../../common");
var _LocationBarGrower;
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const _createElement = /*#__PURE__*/_react.default.createElement;
const isSlotEle = child => /*#__PURE__*/_react.default.isValidElement(child) && child.type === _LocationBarSlot.LocationBarSlot;
const isSlotFixedEle = child => child.props.mode === 'fixed';
const isSlotDiscreteEle = child => child.props.mode === 'discrete';
const isSlotDynamicEle = child => child.props.mode === 'dynamic';
const isSlotNonDynamicEle = child => isSlotFixedEle(child) || isSlotDiscreteEle(child);
const extractAlignedSlots = (children, p, align, mode, widths) => {
  const extractSlot = (child, p) => {
    if (isSlotFixedEle(child)) {
      if (child.props.priority >= p) {
        const key = child.key;
        const width = typeof child.props.width === 'number' ? child.props.width : widths[key];
        if (typeof width === 'number') {
          return [key, width, child.props.children];
        } else {
          return null;
        }
      }
      return null;
    }
    if (isSlotDiscreteEle(child)) {
      const priority = child.props.priority;
      for (let i = 0; i < priority.length; i++) {
        if (priority[i] >= p) {
          const key = child.key;
          const width = typeof child.props.width[i] === 'number' ? child.props.width[i] : widths[key + '_' + priority[i]];
          if (typeof width === 'number') {
            return [key, width, child.props.children[i]];
          } else {
            return null;
          }
        }
      }
      return null;
    }
    return null;
  };
  return children.map((child, i) => {
    if (isSlotEle(child) && child.props.align === align) {
      if (isSlotNonDynamicEle(child)) {
        return mode === 'dynamic' ? null : extractSlot(child, p);
      } else if (isSlotDynamicEle(child)) {
        return mode === 'static' ? null : child.props.align + '-dynamic';
      }
    }
    return null;
  }).filter(Boolean);
};
const extractStaticMeasureEles = children => {
  const res = [];
  for (const child of children) {
    if (isSlotEle(child) && isSlotNonDynamicEle(child)) {
      if (isSlotFixedEle(child)) {
        if (typeof child.props.width !== 'number') {
          res.push([child.key, child.props.width.staticMeasure]);
        }
      } else if (isSlotDiscreteEle(child)) {
        for (let i = 0; i < child.props.priority.length; i++) {
          const p = child.props.priority[i];
          const width = child.props.width[i];
          if (typeof width !== 'number') {
            res.push([child.key + '_' + p, width.staticMeasure]);
          }
        }
      }
    }
  }
  return res;
};
const LocationBar = /*#__PURE__*/_react.default.memo(props => {
  const {
    children: _children
  } = props;
  const children = _children.filter(child => /*#__PURE__*/(0, _react.isValidElement)(child) && child.type === _LocationBarSlot.LocationBarSlot && typeof child.key === 'string');
  const [leftLevel, setLeftLevel] = (0, _react.useState)(_LocationBarSlot.Priority.min());
  const [rightLevel, setRightLevel] = (0, _react.useState)(_LocationBarSlot.Priority.min());
  const [leftDynamicWidth, setLeftDynamicWidth] = (0, _react.useState)(undefined);
  const [rightDynamicWidth, setRightDynamicWidth] = (0, _react.useState)(undefined);
  const widthsRef = (0, _react.useRef)({});
  const leftEles = extractAlignedSlots(children, leftLevel, 'left', 'both', widthsRef.current);
  const rightEles = extractAlignedSlots(children, rightLevel, 'right', 'both', widthsRef.current);
  const leftDynamicEle = children.find(child => isSlotEle(child) && child.props.align === 'left' && isSlotDynamicEle(child));
  const rightDynamicEle = children.find(child => isSlotEle(child) && child.props.align === 'right' && isSlotDynamicEle(child));
  const ref = (0, _react.useRef)(null);
  const leftDynamicMeasureRef = (0, _react.useRef)(null);
  const rightDynamicMeasureRef = (0, _react.useRef)(null);

  // Handle Resize
  const onResize = (0, _common.useEventCallback)(() => {
    if (ref.current) {
      const width = ref.current.getBoundingClientRect().width;
      const leftWidth = Math.floor(width * 0.5);
      const rightWidth = Math.floor(width * 0.4);
      const compute = (maxWidth, dynamicEle, dynamicMeasureRef, getStaticWidth) => {
        let p = _LocationBarSlot.Priority.min();
        let dw = undefined;
        const hasDynamic = dynamicEle && dynamicMeasureRef.current;
        const isControlled = hasDynamic && dynamicEle.props.width === 'controlled';
        const expandedWidth = hasDynamic ? dynamicMeasureRef.current.getBoundingClientRect().width : 0;
        while (p !== _LocationBarSlot.Priority.max()) {
          const staticWidth = getStaticWidth(p);

          // 如果 maxWidth 大于 staticWidth
          // 如果有动态组件
          //    如果 isAutoWidth
          //      动态组件优先级高：尝试全部撑开，失败则升高优先级，continue
          //      动态组件优先级低：计算动态组件宽度，break
          //    如果非 isAutoWidth
          //      尝试全部撑开，失败则升高优先级，continue
          // 如果没有动态组件，break(undefined)

          if (maxWidth > staticWidth) {
            if (hasDynamic) {
              if (isControlled) {
                if (dynamicEle.props.priority >= p) {
                  if (maxWidth > staticWidth + expandedWidth + _styled.SPACE_BWETEEN) {
                    // 全部撑开成功
                    dw = undefined;
                    break;
                  } else {
                    // 全部撑开失败
                    // dont break
                  }
                } else {
                  // 计算动态组件宽度
                  dw = maxWidth - staticWidth - _styled.SPACE_BWETEEN;
                  break;
                }
              } else {
                if (maxWidth > staticWidth + expandedWidth + _styled.SPACE_BWETEEN) {
                  // 全部撑开成功
                  dw = expandedWidth;
                  break;
                } else {
                  // 全部撑开失败
                  // dont break
                }
              }
            } else {
              dw = undefined;
              break;
            }
          }
          p = _LocationBarSlot.Priority.next(p);
        }
        return [p, dw];
      };
      const [lp, ldw] = compute(leftWidth, leftDynamicEle, leftDynamicMeasureRef, p => (0, _lodash.sum)(extractAlignedSlots(children, p, 'left', 'static', widthsRef.current).map(([_, n]) => n)));
      const [rp, rdw] = compute(rightWidth, rightDynamicEle, rightDynamicMeasureRef, p => (0, _lodash.sum)(extractAlignedSlots(children, p, 'right', 'static', widthsRef.current).map(([_, n]) => n)));
      if (lp !== leftLevel) {
        setLeftLevel(lp);
      }
      if (rp !== rightLevel) {
        setRightLevel(rp);
      }
      if (ldw !== leftDynamicWidth) {
        setLeftDynamicWidth(ldw);
      }
      if (rdw !== rightDynamicWidth) {
        setRightDynamicWidth(rdw);
      }
    }
  });
  const throttledOnResize = (0, _react.useMemo)(() => (0, _lodash.throttle)(onResize, 500), [onResize]);
  (0, _react.useEffect)(() => {
    if (ref.current) {
      const obs = new _resizeObserverPolyfill.default(throttledOnResize);
      obs.observe(ref.current);
      if (leftDynamicMeasureRef.current) {
        obs.observe(leftDynamicMeasureRef.current);
      }
      if (rightDynamicMeasureRef.current) {
        obs.observe(rightDynamicMeasureRef.current);
      }
      return () => {
        obs.disconnect();
      };
    }
  }, []);
  const staticMesaureEles = extractStaticMeasureEles(children);
  const staticMeasureIdPrefix = (0, _react.useMemo)(() => (Date.now() % (1000 * 3600 * 24) * 10000 + Math.floor(Math.random() * 10000)).toString(32) + '_', []);
  const [isRenderingStaticEles, setIsRenderingStaticEles] = (0, _react.useState)(staticMesaureEles.length > 0);
  (0, _react.useEffect)(() => {
    if (isRenderingStaticEles) {
      for (const [k] of staticMesaureEles) {
        const div = document.getElementById(staticMeasureIdPrefix + k);
        if (div) {
          const {
            width
          } = div.getBoundingClientRect();
          widthsRef.current[k] = width;
        }
        setIsRenderingStaticEles(false);
      }
    } else {
      const toMeasureSlots = staticMesaureEles.filter(([k]) => widthsRef.current[k] === undefined);
      if (toMeasureSlots.length > 0) {
        setIsRenderingStaticEles(true);
      }
    }
  }, [isRenderingStaticEles, [...staticMesaureEles].sort().map(([k]) => k).join(',')]);
  return /*#__PURE__*/_createElement(_styled.LocationBarWrap, {
    ref: ref
  }, [...leftEles, null, ...rightEles].map((e, i) => {
    if (e === 'left-dynamic') {
      return leftDynamicEle && leftDynamicWidth !== -1 ? /*#__PURE__*/_createElement(_styled.LocationBarItemWrap, {
        key: leftDynamicEle.key,
        align: "left"
      }, leftDynamicEle.props.children(leftDynamicWidth)) : null;
    } else if (e === 'right-dynamic') {
      return rightDynamicEle && rightDynamicWidth !== -1 ? /*#__PURE__*/_createElement(_styled.LocationBarItemWrap, {
        key: rightDynamicEle.key,
        align: "left"
      }, rightDynamicEle.props.children(rightDynamicWidth)) : null;
    } else if (e === null) {
      return _LocationBarGrower || (_LocationBarGrower = /*#__PURE__*/_createElement(_styled.LocationBarGrower, {
        key: "__wdn_locationbar_grower"
      }));
    } else {
      const [key, width, ele] = e;
      const isLeft = i <= leftEles.length;
      return /*#__PURE__*/_createElement(_styled.LocationBarItemWrap, {
        key: key,
        align: isLeft ? 'left' : 'right',
        style: {
          width
        }
      }, ele);
    }
  }), /*#__PURE__*/_createElement("div", {
    key: "__wdn_locationbar_left_dynamic_measure",
    ref: leftDynamicMeasureRef,
    style: {
      position: 'absolute',
      top: -9999
    }
  }, leftDynamicEle ? leftDynamicEle.props.children() : null), /*#__PURE__*/_createElement("div", {
    key: "__wdn_locationbar_right_dynamic_measure",
    ref: rightDynamicMeasureRef,
    style: {
      position: 'absolute',
      top: -9999
    }
  }, rightDynamicEle ? rightDynamicEle.props.children() : null), isRenderingStaticEles ? staticMesaureEles.filter(([k]) => widthsRef.current[k] === undefined).map(([k, fn], p) => /*#__PURE__*/_createElement("div", {
    key: k,
    style: {
      position: 'absolute',
      left: -9999,
      top: -9999
    },
    id: staticMeasureIdPrefix + k
  }, fn())) : null);
});
exports.LocationBar = LocationBar;
//# sourceMappingURL=LocationBar.js.map