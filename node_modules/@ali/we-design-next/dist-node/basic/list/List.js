"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ListItem = exports.List = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _react = _interopRequireWildcard(require("react"));
var _lodash = require("lodash");
var _common = require("../../common");
var _icon = require("../icon");
var _styled = require("./styled");
var _nested = require("./nested");
var _IconSelected;
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const _createElement = /*#__PURE__*/_react.default.createElement;
const List = /*#__PURE__*/(0, _react.memo)( /*#__PURE__*/(0, _react.forwardRef)((props, ref) => {
  const {
    items = [],
    active: _active,
    onActiveChange,
    onSelect = _lodash.noop,
    keyboard = true,
    renderItem,
    ...rest
  } = props;
  const wrapRef = (0, _react.useRef)(null);
  const [focusTargetId, focusTarget, focusOwner] = (0, _common.useFocusTarget)(wrapRef);
  const [active, setActive] = (0, _common.useDefaultProp)(undefined, _active, onActiveChange);
  const onKeyDown = keyboard ? e => {
    const kbKey = e.key.toLowerCase();
    const isArrowUp = kbKey === 'arrowup' || e.keyCode === _common.KEY_CODES.UP;
    const isArrowDown = kbKey === 'arrowdown' || e.keyCode === _common.KEY_CODES.DOWN;
    const isEnter = kbKey === 'enter' || e.keyCode === _common.KEY_CODES.ENTER;
    const flattenedItems = (0, _nested.flattenNested)(items);
    const flattenedEnabledKeys = flattenedItems.filter(_nested.isEnabled).map(it => it.key);

    // 键盘导航到 content 类型的选项，需尝试主动 focus
    const setActiveFromKeyboard = (key, current) => {
      const targetItem = flattenedItems.find(it => it.key === key);
      if (targetItem) {
        const fn = () => setActive(key, {
          from: 'keyboard'
        });
        const currentItem = current ? flattenedItems.find(it => it.key === current) : undefined;
        if ((0, _nested.isCustomized)(targetItem)) {
          focusTarget(fn);
        } else if (currentItem && (0, _nested.isCustomized)(currentItem)) {
          focusOwner(fn);
        } else {
          fn();
        }
      }
    };
    const i = active ? flattenedEnabledKeys.findIndex(key => key === active) : -1;
    if (isArrowDown) {
      const j = i === -1 ? 0 : i + 1;
      if (j < flattenedEnabledKeys.length) {
        const nextKey = flattenedEnabledKeys[j];
        setActiveFromKeyboard(nextKey, active);
        e.stopPropagation();
      }
    } else if (isArrowUp) {
      const j = i === -1 ? flattenedEnabledKeys.length - 1 : i - 1;
      if (j >= 0) {
        const prevKey = flattenedEnabledKeys[j];
        setActiveFromKeyboard(prevKey, active);
        e.stopPropagation();
      }
    } else if (isEnter) {
      if (active !== undefined) {
        onSelect(active);
        e.stopPropagation();
      }
    }
  } : undefined;
  const sourceItems = (0, _react.useMemo)(() => {
    const its = [];
    (0, _nested.loopNested)(items, it => its.push(it), it => its.push(it), s => ({
      key: s,
      title: s
    }));
    return its;
  }, [items]);

  // 列表项中，若有任意一项有前缀/后缀，那么其他的项即使没有前后缀，也应空出前后缀的位置
  const [hasPrefix, hasSuffix] = (0, _react.useMemo)(() => {
    const normalizedItems = (0, _nested.flattenNested)(items).filter(_nested.isNormalized);
    return [normalizedItems.findIndex(it => !!it.prefix) !== -1, normalizedItems.findIndex(it => !!it.suffix || !!it.selected) !== -1];
  }, [items]);
  return /*#__PURE__*/_createElement(_styled.ListWrap, (0, _extends2.default)({
    ref: (0, _common.mergeRef)(ref, wrapRef),
    tabIndex: -1
  }, (0, _common.mergeRestProps)(rest, 'wdn-list', {}, {
    onKeyDown
  })), sourceItems.map(it => {
    if (Array.isArray(it) && it[0] === 'divider') {
      return /*#__PURE__*/_createElement(_styled.ListDivider, {
        key: it[1],
        role: "separator"
      });
    } else if (Array.isArray(it) && it[0] === 'group') {
      return /*#__PURE__*/_createElement(_styled.ListItemGroupTitle, {
        key: it[2]
      }, it[1]);
    } else if ('content' in it) {
      return /*#__PURE__*/_createElement(_react.default.Fragment, {
        key: it.key
      }, (0, _common.cloneReactNode)(it.content, {
        key: it.key,
        id: focusTargetId,
        onMouseEnter: () => setActive(it.key, {
          from: 'mouse'
        }),
        onMouseLeave: () => setActive(undefined, {
          from: 'mouse'
        })
      }));
    } else {
      const prefix = hasPrefix ? p => p || null : p => p;
      const suffix = hasSuffix ? p => p || null : p => p;
      return (0, _common.renderReactNode)(renderItem, /*#__PURE__*/_createElement(ListItem, (0, _extends2.default)({
        key: it.key,
        prefix: prefix(it.prefix),
        suffix: suffix(it.selected ? _IconSelected || (_IconSelected = /*#__PURE__*/_createElement(_icon.IconSelected, null)) : it.suffix),
        active: it.key === active,
        disabled: it.disabled,
        onMouseEnter: it.disabled ? undefined : () => setActive(it.key, {
          from: 'mouse'
        }),
        onMouseLeave: it.disabled ? undefined : () => setActive(undefined, {
          from: 'mouse'
        }),
        onClick: it.disabled ? undefined : () => onSelect(it.key)
      }, (0, _common.spreadRestProps)(rest, it.key)), it.title), {
        key: it.key
      });
    }
  }));
}));
exports.List = List;
List.displayName = 'List';
const ListItem = /*#__PURE__*/(0, _react.memo)( /*#__PURE__*/(0, _react.forwardRef)((props, ref) => {
  const {
    children = '',
    active = false,
    prefix,
    suffix,
    disabled = false,
    ...rest
  } = props;
  return /*#__PURE__*/_createElement(_styled.ListItemWrap, (0, _extends2.default)({
    ref: ref,
    isActive: active,
    disabled: disabled
  }, (0, _common.mergeRestProps)(rest, 'wdn-listitem')), prefix !== undefined ? /*#__PURE__*/_createElement(_styled.ListItemPrefix, null, prefix) : null, /*#__PURE__*/_createElement(_styled.ListItemContent, null, children), suffix !== undefined ? /*#__PURE__*/_createElement(_styled.ListItemSuffix, null, suffix) : null);
}));
exports.ListItem = ListItem;
ListItem.displayName = 'ListItem';
//# sourceMappingURL=List.js.map