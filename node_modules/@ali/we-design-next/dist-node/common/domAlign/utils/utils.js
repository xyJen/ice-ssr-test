"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utils = void 0;
var _getComputedStyle = require("./getComputedStyle");
var _positionUtils = require("./position-utils");
const utils = {
  getWindow: node => {
    if (node && node.document && node.setTimeout) {
      return node;
    }
    const doc = node.ownerDocument || node;
    return doc.defaultView || doc.parentWindow;
  },
  getDocument: node => {
    if (utils.isWindow(node)) {
      return node.document;
    }
    if (utils.isDocument(node)) {
      return node;
    }
    return node.ownerDocument;
  },
  /**
   * A crude way of determining if an object is a window
   * @member util
   */
  isWindow: obj => {
    // must use == for ie8
    /* eslint eqeqeq:0 */
    return obj !== null && obj !== undefined && obj == obj.window;
  },
  isDocument: ele => {
    return ele.nodeType === 9;
  },
  getWindowScrollLeft: w => {
    return (0, _positionUtils.getScrollLeft)(w);
  },
  getWindowScrollTop: w => {
    return (0, _positionUtils.getScrollTop)(w);
  },
  offset: (el, offset, option) => {
    if (typeof offset !== 'undefined') {
      (0, _positionUtils.setOffset)(el, offset, option || {});
    } else {
      return (0, _positionUtils.getOffset)(el);
    }
  },
  css: (el, name, v) => {
    let value = v;
    if (typeof name === 'object') {
      for (const i in name) {
        if (Object.prototype.hasOwnProperty.call(name, i)) {
          utils.css(el, i, name[i]);
        }
      }
      return undefined;
    }
    if (typeof value !== 'undefined') {
      if (typeof value === 'number') {
        value = `${value}px`;
      }
      el.style[name] = value;
      return undefined;
    }
    return (0, _getComputedStyle.getComputedStyleX)(el, name);
  },
  clone: obj => {
    let ret = {};
    // 老的写法
    // for (const i in obj) {
    //   if (obj.hasOwnProperty(i)) {
    //     ret[i] = obj[i as keyof Object];
    //   }
    // }
    Object.assign(ret, obj);
    const overflow = obj.overflow;
    if (overflow) {
      // 老的写法
      // for (const i in obj) {
      //   if (obj.hasOwnProperty(i)) {
      //     (ret.overflow!!)[i] = overflow[i];
      //   }
      // }
      Object.keys(obj).forEach(i => {
        ret.overflow[i] = overflow[i];
      });
    }
    return ret;
  },
  mix: (to, from) => {
    // 老的写法
    // for (const i in from) {
    //   if (from.hasOwnProperty(i)) {
    //     to[i] = from[i as keyof Object];
    //   }
    // }
    Object.assign(to, from);
    return to;
  },
  each: (arr, fn) => {
    for (let i = 0; i < arr.length; i++) {
      fn(arr[i]);
    }
  },
  merge: (...args) => {
    const ret = {};
    for (let i = 0; i < args.length; i++) {
      utils.mix(ret, args[i]);
    }
    return ret;
  }
};
exports.utils = utils;
//# sourceMappingURL=utils.js.map