"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.domUtils = void 0;
var _utils = require("./utils");
var _sizeUtils = require("./size-utils");
const domUtils = {
  getParent(element) {
    let parent = element;
    do {
      if (parent.nodeType === 11 && parent.host) {
        // ShadowRoot
        parent = parent.host;
      } else {
        parent = parent.parentNode;
      }
    } while (parent && parent.nodeType !== 1 && !_utils.utils.isDocument(parent)); // 非Element节点、document节点
    return parent;
  },
  viewportWidth(win) {
    // pc browser includes scrollbar in window.innerWidth
    const prop = `clientWidth`;
    const doc = win.document;
    const body = doc.body;
    const documentElement = doc.documentElement;
    const documentElementProp = documentElement[prop];
    // 标准模式取 documentElement
    // backcompat 取 body
    return doc.compatMode === 'CSS1Compat' && documentElementProp || body && body[prop] || documentElementProp;
  },
  viewportHeight(win) {
    // pc browser includes scrollbar in window.innerWidth
    const prop = `clientHeight`;
    const doc = win.document;
    const body = doc.body;
    const documentElement = doc.documentElement;
    const documentElementProp = documentElement[prop];
    // 标准模式取 documentElement
    // backcompat 取 body
    return doc.compatMode === 'CSS1Compat' && documentElementProp || body && body[prop] || documentElementProp;
  },
  docWidth(refWin) {
    const d = refWin.document;
    return Math.max(d.documentElement.scrollWidth, d.body.scrollWidth, domUtils.viewportWidth(refWin));
  },
  docHeight(refWin) {
    const d = refWin.document;
    return Math.max(
    // firefox chrome documentElement.scrollHeight< body.scrollHeight
    // ie standard mode : documentElement.scrollHeight> body.scrollHeight
    d.documentElement.scrollHeight,
    // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
    d.body.scrollHeight, domUtils.viewportHeight(refWin));
  },
  outerWidth(el, includeMargin) {
    return el && (0, _sizeUtils.getWHIgnoreDisplay)(el, 'width', includeMargin ? _sizeUtils.MARGIN_INDEX : _sizeUtils.BORDER_INDEX);
  },
  outerHeight(el, includeMargin) {
    return el && (0, _sizeUtils.getWHIgnoreDisplay)(el, 'height', includeMargin ? _sizeUtils.MARGIN_INDEX : _sizeUtils.BORDER_INDEX);
  },
  width(elem, v) {
    let val = v;
    if (val !== undefined) {
      if (elem) {
        const isBorderBox = (0, _sizeUtils.isBorderBoxFn)(elem);
        if (isBorderBox) {
          val += (0, _sizeUtils.getPBMWidth)(elem, ['padding', 'border'], ['Left', 'Right']);
        }
        return _utils.utils.css(elem, 'width', val);
      }
      return undefined;
    }
    return elem && (0, _sizeUtils.getWHIgnoreDisplay)(elem, 'width', _sizeUtils.CONTENT_INDEX);
  },
  height(elem, v) {
    let val = v;
    if (val !== undefined) {
      if (elem) {
        const isBorderBox = (0, _sizeUtils.isBorderBoxFn)(elem);
        if (isBorderBox) {
          val += (0, _sizeUtils.getPBMWidth)(elem, ['padding', 'border'], ['Top', 'Bottom']);
        }
        return _utils.utils.css(elem, 'height', val);
      }
      return undefined;
    }
    return elem && (0, _sizeUtils.getWHIgnoreDisplay)(elem, 'height', _sizeUtils.CONTENT_INDEX);
  }
};
exports.domUtils = domUtils;
//# sourceMappingURL=dom-utils.js.map