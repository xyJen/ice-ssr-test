"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MARGIN_INDEX = exports.CONTENT_INDEX = exports.BORDER_INDEX = void 0;
exports.getPBMWidth = getPBMWidth;
exports.getWHIgnoreDisplay = getWHIgnoreDisplay;
exports.isBorderBoxFn = isBorderBoxFn;
var _utils = require("./utils");
var _domUtils = require("./dom-utils");
var _getComputedStyle = require("./getComputedStyle");
const BOX_MODELS = ['margin', 'border', 'padding'];
const CONTENT_INDEX = -1;
exports.CONTENT_INDEX = CONTENT_INDEX;
const MARGIN_INDEX = 0;
exports.MARGIN_INDEX = MARGIN_INDEX;
const BORDER_INDEX = 1;
exports.BORDER_INDEX = BORDER_INDEX;
const PADDING_INDEX = 2;
function isBorderBoxFn(elem) {
  return (0, _getComputedStyle.getComputedStyleX)(elem, 'boxSizing') === 'border-box';
}
function swap(elem, options, callback) {
  const old = {};
  const style = elem.style;

  // Remember the old values, and insert the new ones
  // 老的写法
  // for (const name in options) {
  //   if (options.hasOwnProperty(name)) {
  //     old[name] = style[name];
  //     style[name] = options[name];
  //   }
  // }
  Object.keys(options).forEach(key => {
    old[key] = style[key];
    style[key] = options[key];
  });
  callback.call(elem);

  // Revert the old values
  // 老的写法
  // for (const name in options) {
  //   if (options.hasOwnProperty(name)) {
  //     style[name] = old[name];
  //   }
  // }
  Object.keys(options).forEach(key => {
    style[key] = old[key];
  });
}
function getPBMWidth(elem, props, which) {
  let value = 0;
  let prop;
  let j;
  let i;
  for (j = 0; j < props.length; j++) {
    prop = props[j];
    if (prop) {
      for (i = 0; i < which.length; i++) {
        let cssProp;
        if (prop === 'border') {
          cssProp = `${prop}${which[i]}Width`;
        } else {
          cssProp = prop + which[i];
        }
        value += parseFloat((0, _getComputedStyle.getComputedStyleX)(elem, cssProp)) || 0;
      }
    }
  }
  return value;
}

/*
 得到元素的大小信息
 @param elem
 @param name: width / height
 @param {String} [extra]  'padding' : (css width) + padding
 'border' : (css width) + padding + border
 'margin' : (css width) + padding + border + margin
 */
function getWH(elem, name, ex) {
  let extra = ex;
  if (_utils.utils.isWindow(elem)) {
    return name === 'width' ? _domUtils.domUtils.viewportWidth(elem) : _domUtils.domUtils.viewportHeight(elem);
  } else if (_utils.utils.isDocument(elem)) {
    return name === 'width' ? _domUtils.domUtils.docWidth(elem) : _domUtils.domUtils.docHeight(elem);
  }
  const which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
  // 这里使用clientXX而不是getBoundingClientRect是因为拿到的宽高不准确，比实际小
  let borderBoxValue = name === 'width' ? Math.floor(elem.getBoundingClientRect().width) : Math.floor(elem.getBoundingClientRect().height);
  const isBorderBox = isBorderBoxFn(elem);
  let cssBoxValue = 0;
  if (borderBoxValue === null || borderBoxValue === undefined || borderBoxValue <= 0) {
    borderBoxValue = undefined;
    // Fall back to computed then un computed css if necessary
    cssBoxValue = (0, _getComputedStyle.getComputedStyleX)(elem, name);
    if (cssBoxValue === null || cssBoxValue === undefined || Number(cssBoxValue) < 0) {
      cssBoxValue = elem.style[name] || 0;
    }
    // Normalize '', auto, and prepare for extra
    cssBoxValue = parseFloat(String(cssBoxValue)) || 0;
  }
  if (extra === undefined) {
    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
  }
  const borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
  const val = borderBoxValue || cssBoxValue;
  if (extra === CONTENT_INDEX) {
    if (borderBoxValueOrIsBorderBox) {
      return val - getPBMWidth(elem, ['border', 'padding'], which);
    }
    return cssBoxValue;
  } else if (borderBoxValueOrIsBorderBox) {
    if (extra === BORDER_INDEX) {
      return val;
    }
    return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ['border'], which) : getPBMWidth(elem, ['margin'], which));
  }
  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which);
}
const cssShow = {
  position: 'absolute',
  visibility: 'hidden',
  display: 'block'
};

// fix #119 : https://github.com/kissyteam/kissy/issues/119
function getWHIgnoreDisplay(...args) {
  let val;
  const elem = args[0];
  // in case elem is window
  // elem.offsetWidth === undefined
  if (elem.offsetWidth !== 0) {
    val = getWH.apply(undefined, args);
  } else {
    // 元素设置display：none的时候offsetWidth是0
    // 当display: none时，先让元素display: block, 通过visibility在页面上不可见
    // 但是可以取到该元素的样式信息，之后再还原成display：none
    swap(elem, cssShow, () => {
      val = getWH.apply(undefined, args);
    });
  }
  return val;
}
//# sourceMappingURL=size-utils.js.map