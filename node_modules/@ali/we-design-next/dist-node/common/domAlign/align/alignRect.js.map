{"version":3,"file":"alignRect.js","names":["getRectOfSource","src","align","overflow","elRegion","getRegion","visibleRect","getVisibleRectForElement","alwaysByViewport","width","domUtils","height","getRectOfTarget","tgt","isTargetNotOutOfVisible","isOutOfVisibleRect","getDestinationRect","points","offset","targetOffset","srcRegion","srcWidth","srcHeight","tgtRegion","isTgtRegionVisible","normalizeOffset","elFuturePos","getElFuturePos","newElRegion","utils","merge","fail","hasAdjustedX","hasAdjustedY","alignPoints","alignOffset","alignTgtOffset","newOverflowCfg","adjustX","adjustY","resizeWidth","resizeHeight","isFailX","newPoints","flip","l","r","newOffset","flipOffset","newTargetOffset","newElFuturePos","isCompleteFailX","isFailY","t","b","isCompleteFailY","mix","isStillFailX","isStillFailY","adjustForViewport","newWidth","newHeight","left","top","hasResizedWidth","hasResizedHeight","alignRect","el","rect","useCssRight","useCssBottom","useCssTransform","ignoreShake","css"],"sources":["../../../../../src/common/domAlign/align/alignRect.tsx"],"sourcesContent":["import { utils } from '../utils/utils';\nimport { domUtils } from '../utils/dom-utils';\nimport { flip } from '../utils/flip';\nimport { normalizeOffset, flipOffset } from '../utils/offset-utils';\nimport { isFailX, isFailY, isCompleteFailX, isCompleteFailY } from '../utils/direction-utils';\nimport getRegion from '../calc/getRegion';\nimport getElFuturePos from '../calc/getElFuturePos';\nimport adjustForViewport from '../calc/adjustForViewport';\nimport getVisibleRectForElement from '../calc/getVisibleRectForElement';\nimport isOutOfVisibleRect from '../calc/isOutOfVisibleRect';\nimport type { IAlign, IVisibleRect, IFullRegion, IRect, IOverflowConfig, IPoints, IOffsets } from '../interface';\n\n\nexport type SourceInfo = [IFullRegion, IVisibleRect | null, number, number];\nexport type TargetInfo = [IFullRegion, boolean];\n\n/**\n * 获取内容节点的Rect对象\n * @param el: 内容节点 \n * @returns [当前节点所占的区域, 当前节点可以被放置的显示区域, 节点区域的宽度，节点区域的高度]\n */\nexport const getRectOfSource = (src: HTMLElement, align: IAlign): SourceInfo => {\n  const { overflow } = align;\n  const elRegion = getRegion(src);\n  const visibleRect = getVisibleRectForElement(src, overflow?.alwaysByViewport);\n  const width: number = domUtils.width(src);\n  const height: number = domUtils.height(src);\n  return [elRegion, visibleRect, width, height];\n};\n\n/**\n * 获得触发器节点的Rect对象\n * @param tgt: 触发器节点 \n * @returns [当前节点所占的区域, 当前节点是否部分不可见]\n */\nexport const getRectOfTarget = (tgt: HTMLElement, align: IAlign): TargetInfo => {\n  const { overflow } = align;\n  const elRegion = getRegion(tgt);\n  const isTargetNotOutOfVisible = !isOutOfVisibleRect(tgt, overflow?.alwaysByViewport);\n  return [elRegion, isTargetNotOutOfVisible];\n};\n\n/**\n * 根据内容节点和触发器节点的Rect对象，计算出最终内容节点应该放置的位置\n * \n * 当前视窗放不下目标Rect的情况（目前先维持dom-align原逻辑2）\n * 1. 如果没设置adjustXX，进入步骤3。\n *    如果设置了adjustXX, 翻转对齐方向，此时再次判断翻转后放不放得下\n *      1）放得下，返回翻转后的Rect\n *      2）放不下，重置成原来的对齐方向\n *          a.设置了resizeXX，进入步骤2；\n *          b.没设置resizeXX, 进入步骤3；\n * 2. resize目标Rect的宽/高, 再判断能不能放下\n *    1）放得下，返回resize后的Rect\n *    2）放不下，进入步骤3。\n * 3. 放不下就放不下，return Rect。\n * \n * @param src: 内容节点\n * @param tgt：触发器节点\n */\nexport const getDestinationRect = (src: SourceInfo, tgt: TargetInfo, align: IAlign): IRect => {\n  const { points, offset = [0, 0], targetOffset = [0, 0], overflow = {} } = align;\n  const [srcRegion, visibleRect, srcWidth, srcHeight] = src;\n  const [tgtRegion, isTgtRegionVisible] = tgt;\n\n  // 将 offset 转换成数值，支持百分比\n  normalizeOffset(offset, srcRegion);\n  normalizeOffset(targetOffset, tgtRegion);\n\n  // 当前节点将要被放置的位置，{ left, top }\n  let elFuturePos = getElFuturePos(srcRegion, tgtRegion, points, offset, targetOffset);\n  // 当前节点将要所处的区域，即通过即将被放置的位置计算出即将所处的区域\n  let newElRegion: IFullRegion = utils.merge(srcRegion, elFuturePos);\n\n  let fail = false;\n  let hasAdjustedX = false;\n  let hasAdjustedY = false;\n  let alignPoints: IPoints = [...points];\n  let alignOffset: IOffsets = [...offset];\n  let alignTgtOffset: IOffsets = [...targetOffset];\n  let newOverflowCfg: IOverflowConfig = {};\n  const { adjustX, adjustY, resizeWidth, resizeHeight } = overflow;\n\n  // 如果可视区域不能完全放置当前节点时允许调整\n  if (visibleRect && (adjustX || adjustY) && isTgtRegionVisible) {\n    if (adjustX) {\n      // 如果横向不能放下\n      if (isFailX(elFuturePos, srcRegion, visibleRect)) {\n        hasAdjustedX = true;\n        // 对齐位置反下\n        const newPoints = flip(alignPoints, /[lr]/gi, { l: 'r', r: 'l' });\n        // 偏移量也反下\n        const newOffset = flipOffset(alignOffset, 0);\n        const newTargetOffset = flipOffset(alignTgtOffset, 0);\n        const newElFuturePos = getElFuturePos(srcRegion, tgtRegion, newPoints, newOffset, newTargetOffset);\n\n        alignPoints = [...newPoints];\n        alignOffset = [...newOffset];\n        alignTgtOffset = [...newTargetOffset];\n\n        // 只要不是完全失败，就进行赋值；即完全失败的情况下，不翻转，维持原状\n        if (!isCompleteFailX(newElFuturePos, srcRegion, visibleRect)) {\n          fail = true;\n        }\n      }\n    }\n\n    if (adjustY) {\n      // 如果纵向不能放下\n      if (isFailY(elFuturePos, srcRegion, visibleRect)) {\n        hasAdjustedY = true;\n        // 对齐位置反下\n        const newPoints = flip(alignPoints, /[tb]/gi, { t: 'b', b: 't' });\n        // 偏移量也反下\n        const newOffset = flipOffset(alignOffset, 1);\n        const newTargetOffset = flipOffset(alignTgtOffset, 1);\n        const newElFuturePos = getElFuturePos(srcRegion, tgtRegion, newPoints, newOffset, newTargetOffset);\n\n        alignPoints = [...newPoints];\n        alignOffset = [...newOffset];\n        alignTgtOffset = [...newTargetOffset];\n\n        if (!isCompleteFailY(newElFuturePos, srcRegion, visibleRect)) {\n          fail = true;\n        }\n      }\n    }\n\n    // 如果失败，重新计算当前节点将要被放置的位置\n    if (fail) {\n      elFuturePos = getElFuturePos(srcRegion, tgtRegion, alignPoints, alignOffset, alignTgtOffset);\n      utils.mix(newElRegion, elFuturePos);\n    }\n\n    const isStillFailX = isFailX(elFuturePos, srcRegion, visibleRect);\n    const isStillFailY = isFailY(elFuturePos, srcRegion, visibleRect);\n    // 检查反下后的位置是否可以放下了，如果仍然放不下：\n    // 1. 复原修改过的定位参数\n    if (isStillFailX || isStillFailY) {\n      let newPoints: IPoints = [...alignPoints];\n\n      // 重置对应部分的翻转逻辑\n      if (isStillFailX) {\n        hasAdjustedX = false;\n        newPoints = flip(alignPoints, /[lr]/gi, { l: 'r', r: 'l' });\n        alignPoints = [...newPoints];\n      }\n      if (isStillFailY) {\n        hasAdjustedY = false;\n        newPoints = flip(alignPoints, /[tb]/gi, { t: 'b', b: 't' });\n        alignPoints = [...newPoints];\n      }\n\n      alignOffset = [...offset];\n      alignTgtOffset = [...targetOffset];\n    }\n    // 2. 只有指定了可以调整当前方向才调整\n    newOverflowCfg.adjustX = adjustX && isStillFailX;\n    newOverflowCfg.adjustY = adjustY && isStillFailY;\n    newOverflowCfg.resizeWidth = resizeWidth;\n    newOverflowCfg.resizeHeight = resizeHeight;\n\n    // 确实要调整，甚至可能会调整宽高\n    if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {\n      // 重新根据最开始的信息计算要放置的位置\n      elFuturePos = getElFuturePos(srcRegion, tgtRegion, alignPoints, alignOffset, alignTgtOffset);\n      newElRegion = adjustForViewport(elFuturePos, srcRegion, tgtRegion, visibleRect, {\n        points: alignPoints,\n        offset: alignOffset,\n        targetOffset: alignTgtOffset,\n        overflow: newOverflowCfg,\n      });\n    }\n  }\n\n  const { width, height } = srcRegion;\n  const { width: newWidth, height: newHeight, left, top } = newElRegion;\n  const hasResizedWidth = newWidth !== width;\n  const hasResizedHeight = newHeight !== height;\n\n  return {\n    left,\n    top,\n    width: hasResizedWidth ? srcWidth + newWidth - width : srcWidth,\n    height: hasResizedHeight ? srcHeight + newHeight - height : srcHeight,\n    hasAdjustedX,\n    hasAdjustedY,\n    hasResizedWidth,\n    hasResizedHeight,\n  };\n};\n\n/**\n * 给元素el设置成Rect的样式，完成最终定位\n * @param el \n * @param rect \n */\nexport const alignRect = (el: HTMLElement, rect: IRect, align: IAlign): void => {\n  const { left, top, width, height, hasResizedWidth, hasResizedHeight } = rect;\n  const { useCssRight, useCssBottom, useCssTransform, ignoreShake } = align;\n  hasResizedWidth && utils.css(el, 'width', width);\n  hasResizedHeight && utils.css(el, 'height', height);\n  utils.offset(el, { left, top }, { useCssRight, useCssBottom, useCssTransform, ignoreShake });\n};\n"],"mappings":"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"}