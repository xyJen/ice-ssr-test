"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getRectOfTarget = exports.getRectOfSource = exports.getDestinationRect = exports.alignRect = void 0;
var _utils = require("../utils/utils");
var _domUtils = require("../utils/dom-utils");
var _flip = require("../utils/flip");
var _offsetUtils = require("../utils/offset-utils");
var _directionUtils = require("../utils/direction-utils");
var _getRegion = _interopRequireDefault(require("../calc/getRegion"));
var _getElFuturePos = _interopRequireDefault(require("../calc/getElFuturePos"));
var _adjustForViewport = _interopRequireDefault(require("../calc/adjustForViewport"));
var _getVisibleRectForElement = _interopRequireDefault(require("../calc/getVisibleRectForElement"));
var _isOutOfVisibleRect = _interopRequireDefault(require("../calc/isOutOfVisibleRect"));
/**
 * 获取内容节点的Rect对象
 * @param el: 内容节点 
 * @returns [当前节点所占的区域, 当前节点可以被放置的显示区域, 节点区域的宽度，节点区域的高度]
 */
const getRectOfSource = (src, align) => {
  const {
    overflow
  } = align;
  const elRegion = (0, _getRegion.default)(src);
  const visibleRect = (0, _getVisibleRectForElement.default)(src, overflow === null || overflow === void 0 ? void 0 : overflow.alwaysByViewport);
  const width = _domUtils.domUtils.width(src);
  const height = _domUtils.domUtils.height(src);
  return [elRegion, visibleRect, width, height];
};

/**
 * 获得触发器节点的Rect对象
 * @param tgt: 触发器节点 
 * @returns [当前节点所占的区域, 当前节点是否部分不可见]
 */
exports.getRectOfSource = getRectOfSource;
const getRectOfTarget = (tgt, align) => {
  const {
    overflow
  } = align;
  const elRegion = (0, _getRegion.default)(tgt);
  const isTargetNotOutOfVisible = !(0, _isOutOfVisibleRect.default)(tgt, overflow === null || overflow === void 0 ? void 0 : overflow.alwaysByViewport);
  return [elRegion, isTargetNotOutOfVisible];
};

/**
 * 根据内容节点和触发器节点的Rect对象，计算出最终内容节点应该放置的位置
 * 
 * 当前视窗放不下目标Rect的情况（目前先维持dom-align原逻辑2）
 * 1. 如果没设置adjustXX，进入步骤3。
 *    如果设置了adjustXX, 翻转对齐方向，此时再次判断翻转后放不放得下
 *      1）放得下，返回翻转后的Rect
 *      2）放不下，重置成原来的对齐方向
 *          a.设置了resizeXX，进入步骤2；
 *          b.没设置resizeXX, 进入步骤3；
 * 2. resize目标Rect的宽/高, 再判断能不能放下
 *    1）放得下，返回resize后的Rect
 *    2）放不下，进入步骤3。
 * 3. 放不下就放不下，return Rect。
 * 
 * @param src: 内容节点
 * @param tgt：触发器节点
 */
exports.getRectOfTarget = getRectOfTarget;
const getDestinationRect = (src, tgt, align) => {
  const {
    points,
    offset = [0, 0],
    targetOffset = [0, 0],
    overflow = {}
  } = align;
  const [srcRegion, visibleRect, srcWidth, srcHeight] = src;
  const [tgtRegion, isTgtRegionVisible] = tgt;

  // 将 offset 转换成数值，支持百分比
  (0, _offsetUtils.normalizeOffset)(offset, srcRegion);
  (0, _offsetUtils.normalizeOffset)(targetOffset, tgtRegion);

  // 当前节点将要被放置的位置，{ left, top }
  let elFuturePos = (0, _getElFuturePos.default)(srcRegion, tgtRegion, points, offset, targetOffset);
  // 当前节点将要所处的区域，即通过即将被放置的位置计算出即将所处的区域
  let newElRegion = _utils.utils.merge(srcRegion, elFuturePos);
  let fail = false;
  let hasAdjustedX = false;
  let hasAdjustedY = false;
  let alignPoints = [...points];
  let alignOffset = [...offset];
  let alignTgtOffset = [...targetOffset];
  let newOverflowCfg = {};
  const {
    adjustX,
    adjustY,
    resizeWidth,
    resizeHeight
  } = overflow;

  // 如果可视区域不能完全放置当前节点时允许调整
  if (visibleRect && (adjustX || adjustY) && isTgtRegionVisible) {
    if (adjustX) {
      // 如果横向不能放下
      if ((0, _directionUtils.isFailX)(elFuturePos, srcRegion, visibleRect)) {
        hasAdjustedX = true;
        // 对齐位置反下
        const newPoints = (0, _flip.flip)(alignPoints, /[lr]/gi, {
          l: 'r',
          r: 'l'
        });
        // 偏移量也反下
        const newOffset = (0, _offsetUtils.flipOffset)(alignOffset, 0);
        const newTargetOffset = (0, _offsetUtils.flipOffset)(alignTgtOffset, 0);
        const newElFuturePos = (0, _getElFuturePos.default)(srcRegion, tgtRegion, newPoints, newOffset, newTargetOffset);
        alignPoints = [...newPoints];
        alignOffset = [...newOffset];
        alignTgtOffset = [...newTargetOffset];

        // 只要不是完全失败，就进行赋值；即完全失败的情况下，不翻转，维持原状
        if (!(0, _directionUtils.isCompleteFailX)(newElFuturePos, srcRegion, visibleRect)) {
          fail = true;
        }
      }
    }
    if (adjustY) {
      // 如果纵向不能放下
      if ((0, _directionUtils.isFailY)(elFuturePos, srcRegion, visibleRect)) {
        hasAdjustedY = true;
        // 对齐位置反下
        const newPoints = (0, _flip.flip)(alignPoints, /[tb]/gi, {
          t: 'b',
          b: 't'
        });
        // 偏移量也反下
        const newOffset = (0, _offsetUtils.flipOffset)(alignOffset, 1);
        const newTargetOffset = (0, _offsetUtils.flipOffset)(alignTgtOffset, 1);
        const newElFuturePos = (0, _getElFuturePos.default)(srcRegion, tgtRegion, newPoints, newOffset, newTargetOffset);
        alignPoints = [...newPoints];
        alignOffset = [...newOffset];
        alignTgtOffset = [...newTargetOffset];
        if (!(0, _directionUtils.isCompleteFailY)(newElFuturePos, srcRegion, visibleRect)) {
          fail = true;
        }
      }
    }

    // 如果失败，重新计算当前节点将要被放置的位置
    if (fail) {
      elFuturePos = (0, _getElFuturePos.default)(srcRegion, tgtRegion, alignPoints, alignOffset, alignTgtOffset);
      _utils.utils.mix(newElRegion, elFuturePos);
    }
    const isStillFailX = (0, _directionUtils.isFailX)(elFuturePos, srcRegion, visibleRect);
    const isStillFailY = (0, _directionUtils.isFailY)(elFuturePos, srcRegion, visibleRect);
    // 检查反下后的位置是否可以放下了，如果仍然放不下：
    // 1. 复原修改过的定位参数
    if (isStillFailX || isStillFailY) {
      let newPoints = [...alignPoints];

      // 重置对应部分的翻转逻辑
      if (isStillFailX) {
        hasAdjustedX = false;
        newPoints = (0, _flip.flip)(alignPoints, /[lr]/gi, {
          l: 'r',
          r: 'l'
        });
        alignPoints = [...newPoints];
      }
      if (isStillFailY) {
        hasAdjustedY = false;
        newPoints = (0, _flip.flip)(alignPoints, /[tb]/gi, {
          t: 'b',
          b: 't'
        });
        alignPoints = [...newPoints];
      }
      alignOffset = [...offset];
      alignTgtOffset = [...targetOffset];
    }
    // 2. 只有指定了可以调整当前方向才调整
    newOverflowCfg.adjustX = adjustX && isStillFailX;
    newOverflowCfg.adjustY = adjustY && isStillFailY;
    newOverflowCfg.resizeWidth = resizeWidth;
    newOverflowCfg.resizeHeight = resizeHeight;

    // 确实要调整，甚至可能会调整宽高
    if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
      // 重新根据最开始的信息计算要放置的位置
      elFuturePos = (0, _getElFuturePos.default)(srcRegion, tgtRegion, alignPoints, alignOffset, alignTgtOffset);
      newElRegion = (0, _adjustForViewport.default)(elFuturePos, srcRegion, tgtRegion, visibleRect, {
        points: alignPoints,
        offset: alignOffset,
        targetOffset: alignTgtOffset,
        overflow: newOverflowCfg
      });
    }
  }
  const {
    width,
    height
  } = srcRegion;
  const {
    width: newWidth,
    height: newHeight,
    left,
    top
  } = newElRegion;
  const hasResizedWidth = newWidth !== width;
  const hasResizedHeight = newHeight !== height;
  return {
    left,
    top,
    width: hasResizedWidth ? srcWidth + newWidth - width : srcWidth,
    height: hasResizedHeight ? srcHeight + newHeight - height : srcHeight,
    hasAdjustedX,
    hasAdjustedY,
    hasResizedWidth,
    hasResizedHeight
  };
};

/**
 * 给元素el设置成Rect的样式，完成最终定位
 * @param el 
 * @param rect 
 */
exports.getDestinationRect = getDestinationRect;
const alignRect = (el, rect, align) => {
  const {
    left,
    top,
    width,
    height,
    hasResizedWidth,
    hasResizedHeight
  } = rect;
  const {
    useCssRight,
    useCssBottom,
    useCssTransform,
    ignoreShake
  } = align;
  hasResizedWidth && _utils.utils.css(el, 'width', width);
  hasResizedHeight && _utils.utils.css(el, 'height', height);
  _utils.utils.offset(el, {
    left,
    top
  }, {
    useCssRight,
    useCssBottom,
    useCssTransform,
    ignoreShake
  });
};
exports.alignRect = alignRect;
//# sourceMappingURL=alignRect.js.map