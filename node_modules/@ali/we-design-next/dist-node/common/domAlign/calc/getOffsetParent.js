"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _utils = require("../utils/utils");
var _domUtils = require("../utils/dom-utils");
/**
 * 得到会导致元素显示不全的祖先元素
 */
const {
  getParent
} = _domUtils.domUtils;

/**
 * 获取能影响该元素显示的祖先元素
 * 对于定位元素来说，即使最近的父级定位元素
 * 对于非定位元素来说，则返回直接父元素
 */
function getOffsetParent(element) {
  if (_utils.utils.isWindow(element) || _utils.utils.isDocument(element)) {
    // Window或Document
    return null;
  }
  // ie 这个也不是完全可行
  /*
   <div style="width: 50px;height: 100px;overflow: hidden">
   <div style="width: 50px;height: 100px;position: relative;" id="d6">
   元素 6 高 100px 宽 50px<br/>
   </div>
   </div>
   */
  // element.offsetParent does the right thing in ie7 and below. Return parent with layout!
  //  In other browsers it only includes elements with position absolute, relative or
  // fixed, not elements with overflow set to auto or scroll.
  //        if (UA.ie && ieMode < 8) {
  //            return element.offsetParent;
  //        }
  // 统一的 offsetParent 方法
  const doc = _utils.utils.getDocument(element);
  const body = doc.body;
  let positionStyle = _utils.utils.css(element, 'position');
  const skipStatic = positionStyle === 'fixed' || positionStyle === 'absolute';
  if (!skipStatic) {
    // 当元素本身经过绝对定位或相对定位，且父级元素无经过定位的元素时，IE7-浏览器下，offsetParent是<html>
    return element.nodeName.toLowerCase() === 'html' ? null : getParent(element);
  }
  for (let parent = getParent(element); parent && parent !== body && !_utils.utils.isDocument(parent); parent = getParent(parent)) {
    positionStyle = _utils.utils.css(parent, 'position');
    if (positionStyle !== 'static') {
      return parent;
    }
  }
  return null;
}
var _default = getOffsetParent;
exports.default = _default;
//# sourceMappingURL=getOffsetParent.js.map