"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _utils = require("../utils/utils");
var _getAlignOffset = _interopRequireDefault(require("./getAlignOffset"));
function adjustVertical(elFuturePos, elRegion, tgtRegion, visibleRect, align) {
  const pos = _utils.utils.clone(elFuturePos);
  const {
    points,
    overflow,
    offset = [0, 0]
  } = align;
  const {
    adjustY,
    resizeHeight
  } = overflow;
  const srcAlignType = points[0];
  const srcV = srcAlignType.charAt(0);
  const tgtPos = (0, _getAlignOffset.default)(tgtRegion, points[1]); // 获取target的对齐点的坐标
  const tgtPosTop = tgtPos.top + offset[1];
  const size = {
    height: elRegion.height
  };

  // Top edge outside viewport, try to move it.
  if (adjustY && resizeHeight && pos.top < visibleRect.top) {
    // resizeHeight且对齐方式为c或者b时，需要保证top坐标在可视区域内
    if (srcV === 'c' || srcV === 'b') {
      pos.top = visibleRect.top;
    }
  }

  // Top edge inside and bottom edge outside viewport, try to resize it.
  if (resizeHeight && (pos.top + size.height > visibleRect.bottom || pos.top < visibleRect.top)) {
    if (srcV === "t") {
      size.height = visibleRect.bottom - pos.top;
    } else {
      // 存在对齐点不在可视区域的情况，此时不resize
      size.height = tgtPosTop < visibleRect.top ? elRegion.height : tgtPosTop - visibleRect.top;
    }
  }

  // 还放不下，重置top和height
  if ((adjustY || resizeHeight) && (pos.top + size.height > visibleRect.bottom || pos.top < visibleRect.top)) {
    pos.top = elFuturePos.top;
    size.height = elRegion.height;
  }
  return {
    top: pos.top,
    height: size.height
  };
}
function adjustHorizontal(elFuturePos, elRegion, tgtRegion, visibleRect, align) {
  const pos = _utils.utils.clone(elFuturePos);
  const {
    points,
    overflow,
    offset = [0, 0]
  } = align;
  const {
    adjustX,
    resizeWidth
  } = overflow;
  const srcAlignType = points[0];
  const srcH = srcAlignType.charAt(1);
  const tgtPos = (0, _getAlignOffset.default)(tgtRegion, points[1]); // 获取target的对齐点的坐标
  const tgtPosLeft = tgtPos.left + offset[0];
  const size = {
    width: elRegion.width
  };
  if (adjustX && resizeWidth && pos.left < visibleRect.left) {
    if (srcH === 'c' || srcH === 'r') {
      pos.left = visibleRect.left;
    }
  }

  // Left edge inside and right edge outside viewport, try to resize it.
  if (resizeWidth && (pos.left + size.width > visibleRect.right || pos.left < visibleRect.left)) {
    if (srcH === 'l') {
      size.width = visibleRect.right - pos.left;
    } else {
      size.width = tgtPosLeft < visibleRect.left ? elRegion.width : tgtPosLeft - visibleRect.left;
    }
  }

  // 还放不下，重置left和width
  if (adjustX && resizeWidth && (pos.left + size.width > visibleRect.right || pos.left < visibleRect.left)) {
    pos.left = elFuturePos.left;
    size.width = elRegion.width;
  }
  return {
    left: pos.left,
    width: size.width
  };
}
function adjustForViewport(elFuturePos, elRegion, tgtRegion, visibleRect, align) {
  const horizontalInfo = adjustHorizontal(elFuturePos, elRegion, tgtRegion, visibleRect, align);
  const verticalInfo = adjustVertical(elFuturePos, elRegion, tgtRegion, visibleRect, align);
  return _utils.utils.mix(horizontalInfo, verticalInfo);
}
var _default = adjustForViewport;
exports.default = _default;
//# sourceMappingURL=adjustForViewport.js.map