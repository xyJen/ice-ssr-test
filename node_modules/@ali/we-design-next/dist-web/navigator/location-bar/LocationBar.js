var _LocationBarGrower;
function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
import React, { useEffect, useState, useRef, useMemo, isValidElement } from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import { LocationBarSlot as Slot } from "./LocationBarSlot";
import { Priority } from "./LocationBarSlot";
import { LocationBarWrap, LocationBarItemWrap, LocationBarGrower, SPACE_BWETEEN } from "./styled";
import ResizeObserver from 'resize-observer-polyfill';
import { sum, throttle } from 'lodash-es';
import { useEventCallback } from "../../common";
var isSlotEle = function isSlotEle(child) {
  return /*#__PURE__*/React.isValidElement(child) && child.type === Slot;
};
var isSlotFixedEle = function isSlotFixedEle(child) {
  return child.props.mode === 'fixed';
};
var isSlotDiscreteEle = function isSlotDiscreteEle(child) {
  return child.props.mode === 'discrete';
};
var isSlotDynamicEle = function isSlotDynamicEle(child) {
  return child.props.mode === 'dynamic';
};
var isSlotNonDynamicEle = function isSlotNonDynamicEle(child) {
  return isSlotFixedEle(child) || isSlotDiscreteEle(child);
};
var extractAlignedSlots = function extractAlignedSlots(children, p, align, mode, widths) {
  var extractSlot = function extractSlot(child, p) {
    if (isSlotFixedEle(child)) {
      if (child.props.priority >= p) {
        var key = child.key;
        var width = typeof child.props.width === 'number' ? child.props.width : widths[key];
        if (typeof width === 'number') {
          return [key, width, child.props.children];
        } else {
          return null;
        }
      }
      return null;
    }
    if (isSlotDiscreteEle(child)) {
      var priority = child.props.priority;
      for (var i = 0; i < priority.length; i++) {
        if (priority[i] >= p) {
          var _key = child.key;
          var _width = typeof child.props.width[i] === 'number' ? child.props.width[i] : widths[_key + '_' + priority[i]];
          if (typeof _width === 'number') {
            return [_key, _width, child.props.children[i]];
          } else {
            return null;
          }
        }
      }
      return null;
    }
    return null;
  };
  return children.map(function (child, i) {
    if (isSlotEle(child) && child.props.align === align) {
      if (isSlotNonDynamicEle(child)) {
        return mode === 'dynamic' ? null : extractSlot(child, p);
      } else if (isSlotDynamicEle(child)) {
        return mode === 'static' ? null : child.props.align + '-dynamic';
      }
    }
    return null;
  }).filter(Boolean);
};
var extractStaticMeasureEles = function extractStaticMeasureEles(children) {
  var res = [];
  for (var _iterator = _createForOfIteratorHelperLoose(children), _step; !(_step = _iterator()).done;) {
    var child = _step.value;
    if (isSlotEle(child) && isSlotNonDynamicEle(child)) {
      if (isSlotFixedEle(child)) {
        if (typeof child.props.width !== 'number') {
          res.push([child.key, child.props.width.staticMeasure]);
        }
      } else if (isSlotDiscreteEle(child)) {
        for (var i = 0; i < child.props.priority.length; i++) {
          var p = child.props.priority[i];
          var width = child.props.width[i];
          if (typeof width !== 'number') {
            res.push([child.key + '_' + p, width.staticMeasure]);
          }
        }
      }
    }
  }
  return res;
};
export var LocationBar = /*#__PURE__*/React.memo(function (props) {
  var _children = props.children;
  var children = _children.filter(function (child) {
    return /*#__PURE__*/isValidElement(child) && child.type === Slot && typeof child.key === 'string';
  });
  var _useState = useState(Priority.min()),
    leftLevel = _useState[0],
    setLeftLevel = _useState[1];
  var _useState2 = useState(Priority.min()),
    rightLevel = _useState2[0],
    setRightLevel = _useState2[1];
  var _useState3 = useState(undefined),
    leftDynamicWidth = _useState3[0],
    setLeftDynamicWidth = _useState3[1];
  var _useState4 = useState(undefined),
    rightDynamicWidth = _useState4[0],
    setRightDynamicWidth = _useState4[1];
  var widthsRef = useRef({});
  var leftEles = extractAlignedSlots(children, leftLevel, 'left', 'both', widthsRef.current);
  var rightEles = extractAlignedSlots(children, rightLevel, 'right', 'both', widthsRef.current);
  var leftDynamicEle = children.find(function (child) {
    return isSlotEle(child) && child.props.align === 'left' && isSlotDynamicEle(child);
  });
  var rightDynamicEle = children.find(function (child) {
    return isSlotEle(child) && child.props.align === 'right' && isSlotDynamicEle(child);
  });
  var ref = useRef(null);
  var leftDynamicMeasureRef = useRef(null);
  var rightDynamicMeasureRef = useRef(null);

  // Handle Resize
  var onResize = useEventCallback(function () {
    if (ref.current) {
      var width = ref.current.getBoundingClientRect().width;
      var leftWidth = Math.floor(width * 0.5);
      var rightWidth = Math.floor(width * 0.4);
      var compute = function compute(maxWidth, dynamicEle, dynamicMeasureRef, getStaticWidth) {
        var p = Priority.min();
        var dw = undefined;
        var hasDynamic = dynamicEle && dynamicMeasureRef.current;
        var isControlled = hasDynamic && dynamicEle.props.width === 'controlled';
        var expandedWidth = hasDynamic ? dynamicMeasureRef.current.getBoundingClientRect().width : 0;
        while (p !== Priority.max()) {
          var staticWidth = getStaticWidth(p);

          // 如果 maxWidth 大于 staticWidth
          // 如果有动态组件
          //    如果 isAutoWidth
          //      动态组件优先级高：尝试全部撑开，失败则升高优先级，continue
          //      动态组件优先级低：计算动态组件宽度，break
          //    如果非 isAutoWidth
          //      尝试全部撑开，失败则升高优先级，continue
          // 如果没有动态组件，break(undefined)

          if (maxWidth > staticWidth) {
            if (hasDynamic) {
              if (isControlled) {
                if (dynamicEle.props.priority >= p) {
                  if (maxWidth > staticWidth + expandedWidth + SPACE_BWETEEN) {
                    // 全部撑开成功
                    dw = undefined;
                    break;
                  } else {
                    // 全部撑开失败
                    // dont break
                  }
                } else {
                  // 计算动态组件宽度
                  dw = maxWidth - staticWidth - SPACE_BWETEEN;
                  break;
                }
              } else {
                if (maxWidth > staticWidth + expandedWidth + SPACE_BWETEEN) {
                  // 全部撑开成功
                  dw = expandedWidth;
                  break;
                } else {
                  // 全部撑开失败
                  // dont break
                }
              }
            } else {
              dw = undefined;
              break;
            }
          }
          p = Priority.next(p);
        }
        return [p, dw];
      };
      var _compute = compute(leftWidth, leftDynamicEle, leftDynamicMeasureRef, function (p) {
          return sum(extractAlignedSlots(children, p, 'left', 'static', widthsRef.current).map(function (_ref) {
            var _ = _ref[0],
              n = _ref[1];
            return n;
          }));
        }),
        lp = _compute[0],
        ldw = _compute[1];
      var _compute2 = compute(rightWidth, rightDynamicEle, rightDynamicMeasureRef, function (p) {
          return sum(extractAlignedSlots(children, p, 'right', 'static', widthsRef.current).map(function (_ref2) {
            var _ = _ref2[0],
              n = _ref2[1];
            return n;
          }));
        }),
        rp = _compute2[0],
        rdw = _compute2[1];
      if (lp !== leftLevel) {
        setLeftLevel(lp);
      }
      if (rp !== rightLevel) {
        setRightLevel(rp);
      }
      if (ldw !== leftDynamicWidth) {
        setLeftDynamicWidth(ldw);
      }
      if (rdw !== rightDynamicWidth) {
        setRightDynamicWidth(rdw);
      }
    }
  });
  var throttledOnResize = useMemo(function () {
    return throttle(onResize, 500);
  }, [onResize]);
  useEffect(function () {
    if (ref.current) {
      var obs = new ResizeObserver(throttledOnResize);
      obs.observe(ref.current);
      if (leftDynamicMeasureRef.current) {
        obs.observe(leftDynamicMeasureRef.current);
      }
      if (rightDynamicMeasureRef.current) {
        obs.observe(rightDynamicMeasureRef.current);
      }
      return function () {
        obs.disconnect();
      };
    }
  }, []);
  var staticMesaureEles = extractStaticMeasureEles(children);
  var staticMeasureIdPrefix = useMemo(function () {
    return (Date.now() % (1000 * 3600 * 24) * 10000 + Math.floor(Math.random() * 10000)).toString(32) + '_';
  }, []);
  var _useState5 = useState(staticMesaureEles.length > 0),
    isRenderingStaticEles = _useState5[0],
    setIsRenderingStaticEles = _useState5[1];
  useEffect(function () {
    if (isRenderingStaticEles) {
      for (var _iterator2 = _createForOfIteratorHelperLoose(staticMesaureEles), _step2; !(_step2 = _iterator2()).done;) {
        var _step2$value = _step2.value,
          k = _step2$value[0];
        var div = document.getElementById(staticMeasureIdPrefix + k);
        if (div) {
          var _div$getBoundingClien = div.getBoundingClientRect(),
            width = _div$getBoundingClien.width;
          widthsRef.current[k] = width;
        }
        setIsRenderingStaticEles(false);
      }
    } else {
      var toMeasureSlots = staticMesaureEles.filter(function (_ref3) {
        var k = _ref3[0];
        return widthsRef.current[k] === undefined;
      });
      if (toMeasureSlots.length > 0) {
        setIsRenderingStaticEles(true);
      }
    }
  }, [isRenderingStaticEles, [].concat(staticMesaureEles).sort().map(function (_ref4) {
    var k = _ref4[0];
    return k;
  }).join(',')]);
  return /*#__PURE__*/_createElement(LocationBarWrap, {
    ref: ref
  }, [].concat(leftEles, [null], rightEles).map(function (e, i) {
    if (e === 'left-dynamic') {
      return leftDynamicEle && leftDynamicWidth !== -1 ? /*#__PURE__*/_createElement(LocationBarItemWrap, {
        key: leftDynamicEle.key,
        align: "left"
      }, leftDynamicEle.props.children(leftDynamicWidth)) : null;
    } else if (e === 'right-dynamic') {
      return rightDynamicEle && rightDynamicWidth !== -1 ? /*#__PURE__*/_createElement(LocationBarItemWrap, {
        key: rightDynamicEle.key,
        align: "left"
      }, rightDynamicEle.props.children(rightDynamicWidth)) : null;
    } else if (e === null) {
      return _LocationBarGrower || (_LocationBarGrower = /*#__PURE__*/_createElement(LocationBarGrower, {
        key: "__wdn_locationbar_grower"
      }));
    } else {
      var key = e[0],
        width = e[1],
        ele = e[2];
      var isLeft = i <= leftEles.length;
      return /*#__PURE__*/_createElement(LocationBarItemWrap, {
        key: key,
        align: isLeft ? 'left' : 'right',
        style: {
          width: width
        }
      }, ele);
    }
  }), /*#__PURE__*/_createElement("div", {
    key: "__wdn_locationbar_left_dynamic_measure",
    ref: leftDynamicMeasureRef,
    style: {
      position: 'absolute',
      top: -9999
    }
  }, leftDynamicEle ? leftDynamicEle.props.children() : null), /*#__PURE__*/_createElement("div", {
    key: "__wdn_locationbar_right_dynamic_measure",
    ref: rightDynamicMeasureRef,
    style: {
      position: 'absolute',
      top: -9999
    }
  }, rightDynamicEle ? rightDynamicEle.props.children() : null), isRenderingStaticEles ? staticMesaureEles.filter(function (_ref5) {
    var k = _ref5[0];
    return widthsRef.current[k] === undefined;
  }).map(function (_ref6, p) {
    var k = _ref6[0],
      fn = _ref6[1];
    return /*#__PURE__*/_createElement("div", {
      key: k,
      style: {
        position: 'absolute',
        left: -9999,
        top: -9999
      },
      id: staticMeasureIdPrefix + k
    }, fn());
  }) : null);
});
//# sourceMappingURL=LocationBar.js.map