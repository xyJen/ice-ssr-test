import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
var _div;
var _excluded = ["visible", "trigger", "content", "children", "getContainer", "onVisibleChange", "placement", "placementOffset", "animation", "keepAlign", "keepMounted", "resize"];
import React, { useEffect, useMemo, useRef, isValidElement } from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import ReactDOM from 'react-dom';
import { useDefaultProp, mergeRef, cloneReactNode, mergeRestProps, useEventCallback, mergeClassName } from "../../common";
import { align } from "./align";
import { ContentWrap } from "./styled";
import ResizeObserver from 'resize-observer-polyfill';
var DEFAULT_PROPS = {
  placement: 'bottom',
  placementOffset: [0, 0],
  getContainer: function getContainer() {
    return document.body;
  }
};
var contains = function contains(container, target) {
  var ele = target;
  while (ele !== null) {
    if (ele === container) {
      return true;
    }
    ele = ele.parentElement;
  }
  return false;
};
export var Popover = /*#__PURE__*/React.memo(function (props) {
  var _visible = props.visible,
    trigger = props.trigger,
    _props$content = props.content,
    content = _props$content === void 0 ? _div || (_div = /*#__PURE__*/_createElement("div", null)) : _props$content,
    children = props.children,
    _props$getContainer = props.getContainer,
    getContainer = _props$getContainer === void 0 ? DEFAULT_PROPS.getContainer : _props$getContainer,
    onVisibleChange = props.onVisibleChange,
    _props$placement = props.placement,
    placement = _props$placement === void 0 ? DEFAULT_PROPS.placement : _props$placement,
    _props$placementOffse = props.placementOffset,
    placementOffset = _props$placementOffse === void 0 ? DEFAULT_PROPS.placementOffset : _props$placementOffse,
    animation = props.animation,
    keepAlign = props.keepAlign,
    keepMounted = props.keepMounted,
    resize = props.resize,
    rest = _objectWithoutPropertiesLoose(props, _excluded);
  if (! /*#__PURE__*/isValidElement(children)) {
    return null;
  }
  var _useDefaultProp = useDefaultProp(false, _visible, onVisibleChange),
    visible = _useDefaultProp[0],
    _setVisible = _useDefaultProp[1];
  var setVisible = useEventCallback(function (e) {
    return _setVisible(e);
  });
  var visibleController = useMemo(function () {
    var timeoutId = null;
    var open = function open() {
      cancel();
      setVisible(true);
    };
    var close = function close() {
      if (timeoutId === null) {
        timeoutId = setTimeout(function () {
          timeoutId = null;
          isHoveringContent.current === false && setVisible(false);
        }, 150);
      }
    };
    var cancel = function cancel() {
      if (timeoutId !== null) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
    };
    var closeImmediately = function closeImmediately() {
      cancel();
      setVisible(false);
    };
    return {
      open: open,
      close: close,
      closeImmediately: closeImmediately
    };
  }, []);
  var isHoveringContent = useRef(false);
  var triggerEvents = useMemo(function () {
    if (trigger === 'hover') {
      return {
        onMouseEnter: visibleController.open,
        onMouseLeave: visibleController.closeImmediately
      };
    } else if (trigger === 'mouse-enter') {
      return {
        onMouseEnter: visibleController.open,
        onMouseLeave: visibleController.close
      };
    } else if (trigger === 'click') {
      return {
        onClick: visibleController.open
      };
    } else {
      return {};
    }
  }, [trigger, visibleController]);

  // 监听 document mousedown 事件，触发时关闭 Popover（除非事件在 content 或 trigger 内部触发）
  useEffect(function () {
    if (visible) {
      var hide = function hide(e) {
        if (contentRef.current && triggerRef.current && e.target && !contains(contentRef.current, e.target) && !contains(triggerRef.current, e.target)) {
          visibleController.closeImmediately();
        }
      };
      // 为什么要 raf 后再监听：因为当前也许正处在一次 click 事件中
      var timerId = requestAnimationFrame(function () {
        document.addEventListener('mousedown', hide);
      });
      return function () {
        window.cancelAnimationFrame(timerId);
        document.removeEventListener('mousedown', hide);
      };
    }
  }, [visibleController, visible]);

  // 打开 Popover 后，立刻对齐 content 和 trigger
  useEffect(function () {
    if (visible === true && contentRef.current && triggerRef.current) {
      align(contentRef.current, triggerRef.current, placement, placementOffset);
    }
  }, [visible]);

  // 如果开启了 keepAlign：打开 Popover 后，监听窗口 resize 事件，触发时重新对齐 content 和 trigger
  // 注意：如果开启了 animation，首次重新对齐时需要移除 content 上的动画相关 classname
  useEffect(function () {
    if (visible && keepAlign && contentRef.current && triggerRef.current) {
      // ResizeObserver.observe 会直接触发一次 callback，此时不需要 reAlign
      var flag = false;
      var reAlign = function reAlign() {
        if (flag && contentRef.current && triggerRef.current) {
          if (animation) {
            var regRes = contentRef.current.className.match(/wds-popover-animation-[\w-]+/);
            if (regRes && regRes[0]) {
              contentRef.current.className = contentRef.current.className.replace(regRes[0], '');
            }
          }
          align(contentRef.current, triggerRef.current, placement, placementOffset);
        }
      };
      var resizeObserver = new ResizeObserver(reAlign);
      resizeObserver.observe(document.body);
      var setFlagTimeoutId = setTimeout(function () {
        return flag = true;
      }, 100);
      return function () {
        resizeObserver.disconnect();
        clearTimeout(setFlagTimeoutId);
      };
    }
  }, [visible, keepAlign, animation]);
  var triggerRef = useRef(null);
  var contentRef = useRef(null);
  var ref = mergeRef(children.ref, triggerRef);
  return /*#__PURE__*/_createElement(React.Fragment, null, cloneReactNode(children, _extends({
    ref: ref
  }, triggerEvents)), visible || keepMounted ? /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/_createElement(ContentWrap, _extends({
    hidden: !keepMounted ? false : !visible,
    onMouseEnter: trigger === 'mouse-enter' ? function () {
      isHoveringContent.current = true;
    } : undefined,
    onMouseLeave: trigger === 'mouse-enter' ? function () {
      isHoveringContent.current = false;
      visibleController.close();
    } : undefined,
    ref: contentRef
  }, mergeRestProps(rest, mergeClassName('wdn-popover', animation ? "wds-popover-animation-" + placement : ''))), content), getContainer() || document.body) : null);
});
//# sourceMappingURL=Popover.js.map