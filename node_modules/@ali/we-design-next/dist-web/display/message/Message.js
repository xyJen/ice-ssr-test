import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
var _excluded = ["key", "keepAlive"];
import React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import ReactDOM from 'react-dom';
import { noop } from 'lodash-es';
import CSSTransitionGroup from 'react-transition-group/CSSTransitionGroup';
import { success as _success, info as _info, warning as _warning, error as _error, loading as _loading } from "./icons";
import styled from 'styled-components';
import { MessageBox } from "./MessageBox";
import { showLocalMessage } from "./local";
import { root_style } from "./styled";
var MESSAGE_COMMON_DURATION = 3 * 1000;
var Root = /*#__PURE__*/styled(CSSTransitionGroup)(["", ""], root_style);
var Message = function Message(props) {
  var messages = props.messages;
  return /*#__PURE__*/_createElement(Root, {
    component: "div",
    transitionName: "message",
    transitionEnterTimeout: 300,
    transitionLeaveTimeout: 300
  }, messages.map(function (msg) {
    var key = msg.key,
      icon = msg.icon,
      content = msg.content,
      actionTitle = msg.actionTitle,
      _msg$onAction = msg.onAction,
      _onAction = _msg$onAction === void 0 ? noop : _msg$onAction;
    return /*#__PURE__*/_createElement(MessageBox, {
      key: key,
      icon: icon,
      content: content,
      onAction: function onAction() {
        message.close(key);
        _onAction();
      },
      actionTitle: actionTitle
    });
  }));
};
var hasRendered = false;
export var message = function () {
  var messageIndex = 0;
  var messages = [];
  var renderDom = null;
  function handleUpdate(msgs) {
    if (!renderDom || !window.document.body.contains(renderDom)) {
      var oDiv = document.createElement('div');
      oDiv.style.position = 'absolute';
      oDiv.style.width = '100%';
      oDiv.style.top = '0px';
      oDiv.style.left = '0px';
      document.body.appendChild(oDiv);
      renderDom = oDiv;
    }
    if (!hasRendered) {
      ReactDOM.render( /*#__PURE__*/_createElement(Message, {
        messages: []
      }), renderDom);
      hasRendered = true;
    }
    messages = msgs;
    ReactDOM.render( /*#__PURE__*/_createElement(Message, {
      messages: msgs
    }), renderDom);
  }
  var getKey = function getKey() {
    var key = "wds-msg-id-" + ++messageIndex;
    if (messageIndex > 10000000) {
      messageIndex = 0;
    }
    return key;
  };
  var noopConfig = {};
  var getProps = function getProps(icon, title, config) {
    if (config === void 0) {
      config = noopConfig;
    }
    var _config = config,
      key = _config.key,
      keepAlive = _config.keepAlive,
      restConfig = _objectWithoutPropertiesLoose(_config, _excluded);
    return _extends({
      icon: icon,
      content: title,
      key: key || getKey(),
      keepAlive: keepAlive === undefined ? !!config.actionTitle : keepAlive
    }, restConfig);
  };
  return {
    open: function open(itemProps) {
      var _this = this;
      var getContainer = itemProps.getContainer,
        onClose = itemProps.onClose;
      if (getContainer) {
        var container = getContainer();
        if (container && container !== window.document.body) {
          var closeLocal = showLocalMessage(_extends({
            container: container
          }, itemProps)) || noop;
          if (!itemProps.keepAlive) {
            setTimeout(function () {
              closeLocal();
              onClose && onClose();
            }, MESSAGE_COMMON_DURATION);
          }
          return closeLocal;
        }
      }
      var key = itemProps.key;

      // 保持非恒定的的只有三个
      messages = [].concat(messages);
      var sameKeyIndex = messages.findIndex(function (msg) {
        return msg.key === key;
      });
      if (sameKeyIndex >= 0) {
        messages.splice(sameKeyIndex, 1);
      } else if (messages.length >= 3 && !itemProps.keepAlive) {
        var autoCloseFirstIndex = messages.findIndex(function (msg) {
          return !msg.keepAlive;
        });
        if (autoCloseFirstIndex >= 0) {
          messages.splice(autoCloseFirstIndex, 1);
        }
      }
      messages.push(itemProps);
      handleUpdate(messages);
      if (!itemProps.keepAlive) {
        setTimeout(function () {
          _this.close(key);
          onClose && onClose();
        }, MESSAGE_COMMON_DURATION);
      }
      return function () {
        return _this.close(itemProps.key);
      };
    },
    close: function close(key) {
      messages = messages.filter(function (m) {
        return m.key !== key;
      });
      handleUpdate(messages);
    },
    closeAll: function closeAll() {
      handleUpdate([]);
    },
    info: function info(content, options) {
      return this.open(getProps(_info, content, options));
    },
    success: function success(content, options) {
      return this.open(getProps(_success, content, options));
    },
    warning: function warning(content, options) {
      return this.open(getProps(_warning, content, options));
    },
    error: function error(content, options) {
      return this.open(getProps(_error, content, options));
    },
    loading: function loading(content, options) {
      return this.open(getProps(_loading, content, _extends({
        keepAlive: true
      }, options)));
    },
    message: function message(content, options) {
      return this.open(getProps(null, content, options));
    }
  };
}();
//# sourceMappingURL=Message.js.map