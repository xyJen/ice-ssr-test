import { utils } from "../utils/utils";
import { domUtils } from "../utils/dom-utils";
import { flip } from "../utils/flip";
import { normalizeOffset, flipOffset } from "../utils/offset-utils";
import { isFailX, isFailY, isCompleteFailX, isCompleteFailY } from "../utils/direction-utils";
import getRegion from "../calc/getRegion";
import getElFuturePos from "../calc/getElFuturePos";
import adjustForViewport from "../calc/adjustForViewport";
import getVisibleRectForElement from "../calc/getVisibleRectForElement";
import isOutOfVisibleRect from "../calc/isOutOfVisibleRect";
/**
 * 获取内容节点的Rect对象
 * @param el: 内容节点 
 * @returns [当前节点所占的区域, 当前节点可以被放置的显示区域, 节点区域的宽度，节点区域的高度]
 */
export var getRectOfSource = function getRectOfSource(src, align) {
  var overflow = align.overflow;
  var elRegion = getRegion(src);
  var visibleRect = getVisibleRectForElement(src, overflow == null ? void 0 : overflow.alwaysByViewport);
  var width = domUtils.width(src);
  var height = domUtils.height(src);
  return [elRegion, visibleRect, width, height];
};

/**
 * 获得触发器节点的Rect对象
 * @param tgt: 触发器节点 
 * @returns [当前节点所占的区域, 当前节点是否部分不可见]
 */
export var getRectOfTarget = function getRectOfTarget(tgt, align) {
  var overflow = align.overflow;
  var elRegion = getRegion(tgt);
  var isTargetNotOutOfVisible = !isOutOfVisibleRect(tgt, overflow == null ? void 0 : overflow.alwaysByViewport);
  return [elRegion, isTargetNotOutOfVisible];
};

/**
 * 根据内容节点和触发器节点的Rect对象，计算出最终内容节点应该放置的位置
 * 
 * 当前视窗放不下目标Rect的情况（目前先维持dom-align原逻辑2）
 * 1. 如果没设置adjustXX，进入步骤3。
 *    如果设置了adjustXX, 翻转对齐方向，此时再次判断翻转后放不放得下
 *      1）放得下，返回翻转后的Rect
 *      2）放不下，重置成原来的对齐方向
 *          a.设置了resizeXX，进入步骤2；
 *          b.没设置resizeXX, 进入步骤3；
 * 2. resize目标Rect的宽/高, 再判断能不能放下
 *    1）放得下，返回resize后的Rect
 *    2）放不下，进入步骤3。
 * 3. 放不下就放不下，return Rect。
 * 
 * @param src: 内容节点
 * @param tgt：触发器节点
 */
export var getDestinationRect = function getDestinationRect(src, tgt, align) {
  var points = align.points,
    _align$offset = align.offset,
    offset = _align$offset === void 0 ? [0, 0] : _align$offset,
    _align$targetOffset = align.targetOffset,
    targetOffset = _align$targetOffset === void 0 ? [0, 0] : _align$targetOffset,
    _align$overflow = align.overflow,
    overflow = _align$overflow === void 0 ? {} : _align$overflow;
  var srcRegion = src[0],
    visibleRect = src[1],
    srcWidth = src[2],
    srcHeight = src[3];
  var tgtRegion = tgt[0],
    isTgtRegionVisible = tgt[1];

  // 将 offset 转换成数值，支持百分比
  normalizeOffset(offset, srcRegion);
  normalizeOffset(targetOffset, tgtRegion);

  // 当前节点将要被放置的位置，{ left, top }
  var elFuturePos = getElFuturePos(srcRegion, tgtRegion, points, offset, targetOffset);
  // 当前节点将要所处的区域，即通过即将被放置的位置计算出即将所处的区域
  var newElRegion = utils.merge(srcRegion, elFuturePos);
  var fail = false;
  var hasAdjustedX = false;
  var hasAdjustedY = false;
  var alignPoints = [].concat(points);
  var alignOffset = [].concat(offset);
  var alignTgtOffset = [].concat(targetOffset);
  var newOverflowCfg = {};
  var adjustX = overflow.adjustX,
    adjustY = overflow.adjustY,
    resizeWidth = overflow.resizeWidth,
    resizeHeight = overflow.resizeHeight;

  // 如果可视区域不能完全放置当前节点时允许调整
  if (visibleRect && (adjustX || adjustY) && isTgtRegionVisible) {
    if (adjustX) {
      // 如果横向不能放下
      if (isFailX(elFuturePos, srcRegion, visibleRect)) {
        hasAdjustedX = true;
        // 对齐位置反下
        var newPoints = flip(alignPoints, /[lr]/gi, {
          l: 'r',
          r: 'l'
        });
        // 偏移量也反下
        var newOffset = flipOffset(alignOffset, 0);
        var newTargetOffset = flipOffset(alignTgtOffset, 0);
        var newElFuturePos = getElFuturePos(srcRegion, tgtRegion, newPoints, newOffset, newTargetOffset);
        alignPoints = [].concat(newPoints);
        alignOffset = [].concat(newOffset);
        alignTgtOffset = [].concat(newTargetOffset);

        // 只要不是完全失败，就进行赋值；即完全失败的情况下，不翻转，维持原状
        if (!isCompleteFailX(newElFuturePos, srcRegion, visibleRect)) {
          fail = true;
        }
      }
    }
    if (adjustY) {
      // 如果纵向不能放下
      if (isFailY(elFuturePos, srcRegion, visibleRect)) {
        hasAdjustedY = true;
        // 对齐位置反下
        var _newPoints = flip(alignPoints, /[tb]/gi, {
          t: 'b',
          b: 't'
        });
        // 偏移量也反下
        var _newOffset = flipOffset(alignOffset, 1);
        var _newTargetOffset = flipOffset(alignTgtOffset, 1);
        var _newElFuturePos = getElFuturePos(srcRegion, tgtRegion, _newPoints, _newOffset, _newTargetOffset);
        alignPoints = [].concat(_newPoints);
        alignOffset = [].concat(_newOffset);
        alignTgtOffset = [].concat(_newTargetOffset);
        if (!isCompleteFailY(_newElFuturePos, srcRegion, visibleRect)) {
          fail = true;
        }
      }
    }

    // 如果失败，重新计算当前节点将要被放置的位置
    if (fail) {
      elFuturePos = getElFuturePos(srcRegion, tgtRegion, alignPoints, alignOffset, alignTgtOffset);
      utils.mix(newElRegion, elFuturePos);
    }
    var isStillFailX = isFailX(elFuturePos, srcRegion, visibleRect);
    var isStillFailY = isFailY(elFuturePos, srcRegion, visibleRect);
    // 检查反下后的位置是否可以放下了，如果仍然放不下：
    // 1. 复原修改过的定位参数
    if (isStillFailX || isStillFailY) {
      var _newPoints2 = [].concat(alignPoints);

      // 重置对应部分的翻转逻辑
      if (isStillFailX) {
        hasAdjustedX = false;
        _newPoints2 = flip(alignPoints, /[lr]/gi, {
          l: 'r',
          r: 'l'
        });
        alignPoints = [].concat(_newPoints2);
      }
      if (isStillFailY) {
        hasAdjustedY = false;
        _newPoints2 = flip(alignPoints, /[tb]/gi, {
          t: 'b',
          b: 't'
        });
        alignPoints = [].concat(_newPoints2);
      }
      alignOffset = [].concat(offset);
      alignTgtOffset = [].concat(targetOffset);
    }
    // 2. 只有指定了可以调整当前方向才调整
    newOverflowCfg.adjustX = adjustX && isStillFailX;
    newOverflowCfg.adjustY = adjustY && isStillFailY;
    newOverflowCfg.resizeWidth = resizeWidth;
    newOverflowCfg.resizeHeight = resizeHeight;

    // 确实要调整，甚至可能会调整宽高
    if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
      // 重新根据最开始的信息计算要放置的位置
      elFuturePos = getElFuturePos(srcRegion, tgtRegion, alignPoints, alignOffset, alignTgtOffset);
      newElRegion = adjustForViewport(elFuturePos, srcRegion, tgtRegion, visibleRect, {
        points: alignPoints,
        offset: alignOffset,
        targetOffset: alignTgtOffset,
        overflow: newOverflowCfg
      });
    }
  }
  var width = srcRegion.width,
    height = srcRegion.height;
  var _newElRegion = newElRegion,
    newWidth = _newElRegion.width,
    newHeight = _newElRegion.height,
    left = _newElRegion.left,
    top = _newElRegion.top;
  var hasResizedWidth = newWidth !== width;
  var hasResizedHeight = newHeight !== height;
  return {
    left: left,
    top: top,
    width: hasResizedWidth ? srcWidth + newWidth - width : srcWidth,
    height: hasResizedHeight ? srcHeight + newHeight - height : srcHeight,
    hasAdjustedX: hasAdjustedX,
    hasAdjustedY: hasAdjustedY,
    hasResizedWidth: hasResizedWidth,
    hasResizedHeight: hasResizedHeight
  };
};

/**
 * 给元素el设置成Rect的样式，完成最终定位
 * @param el 
 * @param rect 
 */
export var alignRect = function alignRect(el, rect, align) {
  var left = rect.left,
    top = rect.top,
    width = rect.width,
    height = rect.height,
    hasResizedWidth = rect.hasResizedWidth,
    hasResizedHeight = rect.hasResizedHeight;
  var useCssRight = align.useCssRight,
    useCssBottom = align.useCssBottom,
    useCssTransform = align.useCssTransform,
    ignoreShake = align.ignoreShake;
  hasResizedWidth && utils.css(el, 'width', width);
  hasResizedHeight && utils.css(el, 'height', height);
  utils.offset(el, {
    left: left,
    top: top
  }, {
    useCssRight: useCssRight,
    useCssBottom: useCssBottom,
    useCssTransform: useCssTransform,
    ignoreShake: ignoreShake
  });
};
//# sourceMappingURL=alignRect.js.map