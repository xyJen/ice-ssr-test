import { utils } from "./utils";
import { domUtils } from "./dom-utils";
import { getComputedStyleX } from "./getComputedStyle";
var BOX_MODELS = ['margin', 'border', 'padding'];
export var CONTENT_INDEX = -1;
export var MARGIN_INDEX = 0;
export var BORDER_INDEX = 1;
var PADDING_INDEX = 2;
function isBorderBoxFn(elem) {
  return getComputedStyleX(elem, 'boxSizing') === 'border-box';
}
function swap(elem, options, callback) {
  var old = {};
  var style = elem.style;

  // Remember the old values, and insert the new ones
  // 老的写法
  // for (const name in options) {
  //   if (options.hasOwnProperty(name)) {
  //     old[name] = style[name];
  //     style[name] = options[name];
  //   }
  // }
  Object.keys(options).forEach(function (key) {
    old[key] = style[key];
    style[key] = options[key];
  });
  callback.call(elem);

  // Revert the old values
  // 老的写法
  // for (const name in options) {
  //   if (options.hasOwnProperty(name)) {
  //     style[name] = old[name];
  //   }
  // }
  Object.keys(options).forEach(function (key) {
    style[key] = old[key];
  });
}
function getPBMWidth(elem, props, which) {
  var value = 0;
  var prop;
  var j;
  var i;
  for (j = 0; j < props.length; j++) {
    prop = props[j];
    if (prop) {
      for (i = 0; i < which.length; i++) {
        var cssProp = void 0;
        if (prop === 'border') {
          cssProp = "" + prop + which[i] + "Width";
        } else {
          cssProp = prop + which[i];
        }
        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
      }
    }
  }
  return value;
}

/*
 得到元素的大小信息
 @param elem
 @param name: width / height
 @param {String} [extra]  'padding' : (css width) + padding
 'border' : (css width) + padding + border
 'margin' : (css width) + padding + border + margin
 */
function getWH(elem, name, ex) {
  var extra = ex;
  if (utils.isWindow(elem)) {
    return name === 'width' ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
  } else if (utils.isDocument(elem)) {
    return name === 'width' ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
  }
  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
  // 这里使用clientXX而不是getBoundingClientRect是因为拿到的宽高不准确，比实际小
  var borderBoxValue = name === 'width' ? Math.floor(elem.getBoundingClientRect().width) : Math.floor(elem.getBoundingClientRect().height);
  var isBorderBox = isBorderBoxFn(elem);
  var cssBoxValue = 0;
  if (borderBoxValue === null || borderBoxValue === undefined || borderBoxValue <= 0) {
    borderBoxValue = undefined;
    // Fall back to computed then un computed css if necessary
    cssBoxValue = getComputedStyleX(elem, name);
    if (cssBoxValue === null || cssBoxValue === undefined || Number(cssBoxValue) < 0) {
      cssBoxValue = elem.style[name] || 0;
    }
    // Normalize '', auto, and prepare for extra
    cssBoxValue = parseFloat(String(cssBoxValue)) || 0;
  }
  if (extra === undefined) {
    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
  }
  var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
  var val = borderBoxValue || cssBoxValue;
  if (extra === CONTENT_INDEX) {
    if (borderBoxValueOrIsBorderBox) {
      return val - getPBMWidth(elem, ['border', 'padding'], which);
    }
    return cssBoxValue;
  } else if (borderBoxValueOrIsBorderBox) {
    if (extra === BORDER_INDEX) {
      return val;
    }
    return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ['border'], which) : getPBMWidth(elem, ['margin'], which));
  }
  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which);
}
var cssShow = {
  position: 'absolute',
  visibility: 'hidden',
  display: 'block'
};

// fix #119 : https://github.com/kissyteam/kissy/issues/119
function getWHIgnoreDisplay() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var val;
  var elem = args[0];
  // in case elem is window
  // elem.offsetWidth === undefined
  if (elem.offsetWidth !== 0) {
    val = getWH.apply(undefined, args);
  } else {
    // 元素设置display：none的时候offsetWidth是0
    // 当display: none时，先让元素display: block, 通过visibility在页面上不可见
    // 但是可以取到该元素的样式信息，之后再还原成display：none
    swap(elem, cssShow, function () {
      val = getWH.apply(undefined, args);
    });
  }
  return val;
}
export { isBorderBoxFn, getPBMWidth, getWHIgnoreDisplay };
//# sourceMappingURL=size-utils.js.map