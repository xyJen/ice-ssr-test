import { getComputedStyleX } from "./getComputedStyle";
import { getOffset, setOffset, getScrollLeft, getScrollTop } from "./position-utils";

// typescript 1.5版本从document上移除了parentWindow属性;
// https://stackoverflow.com/questions/38973426/using-documentmode-with-typescript

var utils = {
  getWindow: function getWindow(node) {
    if (node && node.document && node.setTimeout) {
      return node;
    }
    var doc = node.ownerDocument || node;
    return doc.defaultView || doc.parentWindow;
  },
  getDocument: function getDocument(node) {
    if (utils.isWindow(node)) {
      return node.document;
    }
    if (utils.isDocument(node)) {
      return node;
    }
    return node.ownerDocument;
  },
  /**
   * A crude way of determining if an object is a window
   * @member util
   */
  isWindow: function isWindow(obj) {
    // must use == for ie8
    /* eslint eqeqeq:0 */
    return obj !== null && obj !== undefined && obj == obj.window;
  },
  isDocument: function isDocument(ele) {
    return ele.nodeType === 9;
  },
  getWindowScrollLeft: function getWindowScrollLeft(w) {
    return getScrollLeft(w);
  },
  getWindowScrollTop: function getWindowScrollTop(w) {
    return getScrollTop(w);
  },
  offset: function (_offset) {
    function offset(_x, _x2, _x3) {
      return _offset.apply(this, arguments);
    }
    offset.toString = function () {
      return _offset.toString();
    };
    return offset;
  }(function (el, offset, option) {
    if (typeof offset !== 'undefined') {
      setOffset(el, offset, option || {});
    } else {
      return getOffset(el);
    }
  }),
  css: function css(el, name, v) {
    var value = v;
    if (typeof name === 'object') {
      for (var i in name) {
        if (Object.prototype.hasOwnProperty.call(name, i)) {
          utils.css(el, i, name[i]);
        }
      }
      return undefined;
    }
    if (typeof value !== 'undefined') {
      if (typeof value === 'number') {
        value = value + "px";
      }
      el.style[name] = value;
      return undefined;
    }
    return getComputedStyleX(el, name);
  },
  clone: function clone(obj) {
    var ret = {};
    // 老的写法
    // for (const i in obj) {
    //   if (obj.hasOwnProperty(i)) {
    //     ret[i] = obj[i as keyof Object];
    //   }
    // }
    Object.assign(ret, obj);
    var overflow = obj.overflow;
    if (overflow) {
      // 老的写法
      // for (const i in obj) {
      //   if (obj.hasOwnProperty(i)) {
      //     (ret.overflow!!)[i] = overflow[i];
      //   }
      // }
      Object.keys(obj).forEach(function (i) {
        ret.overflow[i] = overflow[i];
      });
    }
    return ret;
  },
  mix: function mix(to, from) {
    // 老的写法
    // for (const i in from) {
    //   if (from.hasOwnProperty(i)) {
    //     to[i] = from[i as keyof Object];
    //   }
    // }
    Object.assign(to, from);
    return to;
  },
  each: function each(arr, fn) {
    for (var i = 0; i < arr.length; i++) {
      fn(arr[i]);
    }
  },
  merge: function merge() {
    var ret = {};
    for (var i = 0; i < arguments.length; i++) {
      utils.mix(ret, i < 0 || arguments.length <= i ? undefined : arguments[i]);
    }
    return ret;
  }
};
export { utils };
//# sourceMappingURL=utils.js.map