import { utils } from "./utils";
import { setTransitionProperty, getTransitionProperty, getTransformXY, setTransformXY, getTransformName } from "./property-utils";

// typescript 1.5版本从document上移除了parentWindow属性;
// https://stackoverflow.com/questions/38973426/using-documentmode-with-typescript

// https://stackoverflow.com/a/3485654/3040605
function forceRelayout(elem) {
  var originalStyle = elem.style.display;
  elem.style.display = 'none';
  elem.offsetHeight; // eslint-disable-line
  elem.style.display = originalStyle;
}

/**
 * 
 * @param elem 
 * @returns 元素相对于文档的left、top信息
 * 元素的getBoundingClientRect()中返回的left, top加上对应window横向和竖向滚动的距离
 * getBoundingClientRect()返回的只是元素对应 浏览器可视区域 的width,height,left,top等值
 */
function getClientPosition(elem) {
  var doc = elem.ownerDocument;
  var body = doc.body;
  var docElem = doc && doc.documentElement;
  // 根据 GBS 最新数据，A-Grade Browsers 都已支持 getBoundingClientRect 方法，不用再考虑传统的实现方式
  var box = elem.getBoundingClientRect();

  // 注：jQuery 还考虑减去 docElem.clientLeft/clientTop
  // 但测试发现，这样反而会导致当 html 和 body 有边距/边框样式时，获取的值不正确
  // 此外，ie6 会忽略 html 的 margin 值，幸运地是没有谁会去设置 html 的 margin

  var x = Math.floor(box.left);
  var y = Math.floor(box.top);

  // In IE, most of the time, 2 extra pixels are added to the top and left
  // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
  // IE6 standards mode, this border can be overridden by setting the
  // document element's border to zero -- thus, we cannot rely on the
  // offset always being 2 pixels.

  // In quirks mode, the offset can be determined by querying the body's
  // clientLeft/clientTop, but in standards mode, it is found by querying
  // the document element's clientLeft/clientTop.  Since we already called
  // getClientBoundingRect we have already forced a reflow, so it is not
  // too expensive just to query them all.

  // ie 下应该减去窗口的边框吧，毕竟默认 absolute 都是相对窗口定位的
  // 窗口边框标准是设 documentElement ,quirks 时设置 body
  // 最好禁止在 body 和 html 上边框 ，但 ie < 9 html 默认有 2px ，减去
  // 但是非 ie 不可能设置窗口边框，body html 也不是窗口 ,ie 可以通过 html,body 设置
  // 标准 ie 下 docElem.clientTop 就是 border-top
  // ie7 html 即窗口边框改变不了。永远为 2
  // 但标准 firefox/chrome/ie9 下 docElem.clientTop 是窗口边框，即使设了 border-top 也为 0

  x -= docElem.clientLeft || body.clientLeft || 0; // 减去竖向滚动条宽度
  y -= docElem.clientTop || body.clientTop || 0; // 减去横向滚动条宽度

  return {
    left: x,
    top: y
  };
}
function getScroll(w, top) {
  var ret = w["page" + (top ? 'Y' : 'X') + "Offset"];
  var method = "scroll" + (top ? 'Top' : 'Left');
  if (typeof ret !== 'number') {
    var d = w.document;
    // ie6,7,8 standard mode
    ret = d.documentElement[method];
    if (typeof ret !== 'number') {
      // quirks mode
      ret = d.body[method];
    }
  }
  return ret;
}
function getScrollLeft(w) {
  return getScroll(w);
}
function getScrollTop(w) {
  return getScroll(w, true);
}
function getOffset(el) {
  var pos = getClientPosition(el);
  var doc = el.ownerDocument;
  var w = doc.defaultView || doc.parentWindow;
  pos.left += getScrollLeft(w);
  pos.top += getScrollTop(w);
  return pos;
}
function getOffsetDirection(dir, option) {
  if (dir === 'left') {
    return option.useCssRight ? 'right' : dir;
  }
  return option.useCssBottom ? 'bottom' : dir;
}
function oppositeOffsetDirection(dir) {
  if (dir === 'left') {
    return 'right';
  } else if (dir === 'right') {
    return 'left';
  } else if (dir === 'top') {
    return 'bottom';
  }
  return 'top';
}

// 根据相对于文档的 {left, top} 值，设置 elem 相对 elem.ownerDocument 的坐标
function setLeftTop(elem, offset, option) {
  // set position first, in-case top/left are set even on static elem
  if (utils.css(elem, 'position') === 'static') {
    elem.style.position = 'relative';
  }
  var presetH = -999;
  var presetV = -999;
  var horizontalProperty = getOffsetDirection('left', option);
  var verticalProperty = getOffsetDirection('top', option);
  var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
  var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);
  if (horizontalProperty !== 'left') {
    presetH = 999;
  }
  if (verticalProperty !== 'top') {
    presetV = 999;
  }
  var originalTransition = '';
  // 记下一开始相对文档的偏移量
  var originalOffset = getOffset(elem);
  if ('left' in offset || 'top' in offset) {
    originalTransition = getTransitionProperty(elem) || '';
    setTransitionProperty(elem, 'none');
    // 保存 transition的值，即当前阶段做 left 和 top 的改变，是没有动画的
    // 因为当前阶段是在做计算，而非真正的设置样式
  }

  if ('left' in offset) {
    elem.style[oppositeHorizontalProperty] = '';
    elem.style[horizontalProperty] = presetH + "px";
  }
  if ('top' in offset) {
    elem.style[oppositeVerticalProperty] = '';
    elem.style[verticalProperty] = presetV + "px";
  }

  // force relayout, 先设置为 -999 
  forceRelayout(elem);
  var old = getOffset(elem); // 记下变为预设之后的偏移量
  var originalStyle = {};
  for (var key in offset) {
    if (Object.prototype.hasOwnProperty.call(offset, key)) {
      var dir = getOffsetDirection(key, option); // 根据 useRight ，当传入left,useRight为true时，返回right
      var preset = key === 'left' ? presetH : presetV;
      // 计算出由于 刚刚设置为预设{ 999, 999 }，导致元素实际移动的 距离
      var off = originalOffset[key] - old[key];

      // 比如元素最初实际的样式值为 { left: 20, top: 20 }
      // 但是 可能相对`文档`的 {left: 0, top: 0}, 因为一个元素最终相对文档的left，top还会受到父元素的影响
      // 后来样式设置为预设值 { left: -999, top: -999 }
      // 此时再计算出相对文档的 {left,top} 值，可以知道元素实际移动的距离
      // 通过预设值与实际移动的距离进行计算，得出最初元素的样式值
      // 大概类似 让你走到 999米的地方，但是你说你只走了990米，说明你一开始就在9米的位置处。进行反推
      if (dir === key) {
        originalStyle[dir] = preset + off;
      } else {
        originalStyle[dir] = preset - off;
      }
    }
  }
  // 复原回原来的样式值，取消掉原来预设的值
  utils.css(elem, originalStyle);

  // force relayout
  forceRelayout(elem);
  if ('left' in offset || 'top' in offset) {
    // 还原 transition的值
    setTransitionProperty(elem, originalTransition);
  }

  // 现在已知 元素相对文档的 {left,top}
  // 还知道 元素最终需要的 相对文档的 {left,top}值
  var ret = {};
  for (var _key in offset) {
    if (Object.prototype.hasOwnProperty.call(offset, _key)) {
      var _dir = getOffsetDirection(_key, option);
      var _off = offset[_key] - originalOffset[_key];
      if (_key === _dir) {
        ret[_dir] = parseFloat(originalStyle[_dir]) + _off;
      } else {
        ret[_dir] = parseFloat(originalStyle[_dir]) - _off;
      }
    }
  }
  utils.css(elem, ret);
}
function setTransform(elem, offset) {
  var originalOffset = getOffset(elem);
  var originalXY = getTransformXY(elem);
  var resultXY = {
    x: originalXY.x,
    y: originalXY.y
  };
  if (offset.left !== undefined) {
    resultXY.x = originalXY.x + offset.left - originalOffset.left;
  }
  if (offset.top !== undefined) {
    resultXY.y = originalXY.y + offset.top - originalOffset.top;
  }
  setTransformXY(elem, resultXY);
}
function setOffset(elem, offset, option) {
  if (option.ignoreShake) {
    var _offset$left, _offset$top;
    var oriOffset = getOffset(elem);
    var oLeft = oriOffset.left.toFixed(0);
    var oTop = oriOffset.top.toFixed(0);
    var tLeft = (_offset$left = offset.left) == null ? void 0 : _offset$left.toFixed(0);
    var tTop = (_offset$top = offset.top) == null ? void 0 : _offset$top.toFixed(0);

    // 如果目标左上和当前左上一致，则直接返回
    if (oLeft === tLeft && oTop === tTop) {
      return;
    }
  }
  if (option.useCssRight || option.useCssBottom) {
    setLeftTop(elem, offset, option);
  } else if (option.useCssTransform && getTransformName() in document.body.style) {
    setTransform(elem, offset);
  } else {
    setLeftTop(elem, offset, option);
  }
}
export { getScrollTop, getScrollLeft, getOffset, setOffset };
//# sourceMappingURL=position-utils.js.map