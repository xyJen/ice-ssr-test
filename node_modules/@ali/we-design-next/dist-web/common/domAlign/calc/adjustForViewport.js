import { utils } from "../utils/utils";
import getAlignOffset from "./getAlignOffset";
function adjustVertical(elFuturePos, elRegion, tgtRegion, visibleRect, align) {
  var pos = utils.clone(elFuturePos);
  var points = align.points,
    overflow = align.overflow,
    _align$offset = align.offset,
    offset = _align$offset === void 0 ? [0, 0] : _align$offset;
  var adjustY = overflow.adjustY,
    resizeHeight = overflow.resizeHeight;
  var srcAlignType = points[0];
  var srcV = srcAlignType.charAt(0);
  var tgtPos = getAlignOffset(tgtRegion, points[1]); // 获取target的对齐点的坐标
  var tgtPosTop = tgtPos.top + offset[1];
  var size = {
    height: elRegion.height
  };

  // Top edge outside viewport, try to move it.
  if (adjustY && resizeHeight && pos.top < visibleRect.top) {
    // resizeHeight且对齐方式为c或者b时，需要保证top坐标在可视区域内
    if (srcV === 'c' || srcV === 'b') {
      pos.top = visibleRect.top;
    }
  }

  // Top edge inside and bottom edge outside viewport, try to resize it.
  if (resizeHeight && (pos.top + size.height > visibleRect.bottom || pos.top < visibleRect.top)) {
    if (srcV === "t") {
      size.height = visibleRect.bottom - pos.top;
    } else {
      // 存在对齐点不在可视区域的情况，此时不resize
      size.height = tgtPosTop < visibleRect.top ? elRegion.height : tgtPosTop - visibleRect.top;
    }
  }

  // 还放不下，重置top和height
  if ((adjustY || resizeHeight) && (pos.top + size.height > visibleRect.bottom || pos.top < visibleRect.top)) {
    pos.top = elFuturePos.top;
    size.height = elRegion.height;
  }
  return {
    top: pos.top,
    height: size.height
  };
}
function adjustHorizontal(elFuturePos, elRegion, tgtRegion, visibleRect, align) {
  var pos = utils.clone(elFuturePos);
  var points = align.points,
    overflow = align.overflow,
    _align$offset2 = align.offset,
    offset = _align$offset2 === void 0 ? [0, 0] : _align$offset2;
  var adjustX = overflow.adjustX,
    resizeWidth = overflow.resizeWidth;
  var srcAlignType = points[0];
  var srcH = srcAlignType.charAt(1);
  var tgtPos = getAlignOffset(tgtRegion, points[1]); // 获取target的对齐点的坐标
  var tgtPosLeft = tgtPos.left + offset[0];
  var size = {
    width: elRegion.width
  };
  if (adjustX && resizeWidth && pos.left < visibleRect.left) {
    if (srcH === 'c' || srcH === 'r') {
      pos.left = visibleRect.left;
    }
  }

  // Left edge inside and right edge outside viewport, try to resize it.
  if (resizeWidth && (pos.left + size.width > visibleRect.right || pos.left < visibleRect.left)) {
    if (srcH === 'l') {
      size.width = visibleRect.right - pos.left;
    } else {
      size.width = tgtPosLeft < visibleRect.left ? elRegion.width : tgtPosLeft - visibleRect.left;
    }
  }

  // 还放不下，重置left和width
  if (adjustX && resizeWidth && (pos.left + size.width > visibleRect.right || pos.left < visibleRect.left)) {
    pos.left = elFuturePos.left;
    size.width = elRegion.width;
  }
  return {
    left: pos.left,
    width: size.width
  };
}
function adjustForViewport(elFuturePos, elRegion, tgtRegion, visibleRect, align) {
  var horizontalInfo = adjustHorizontal(elFuturePos, elRegion, tgtRegion, visibleRect, align);
  var verticalInfo = adjustVertical(elFuturePos, elRegion, tgtRegion, visibleRect, align);
  return utils.mix(horizontalInfo, verticalInfo);
}
export default adjustForViewport;
//# sourceMappingURL=adjustForViewport.js.map