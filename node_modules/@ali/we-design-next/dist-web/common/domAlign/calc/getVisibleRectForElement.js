import { utils } from "../utils/utils";
import { domUtils } from "../utils/dom-utils";
import getOffsetParent from "./getOffsetParent";
import isAncestorFixed from "./isAncestorFixed";
/**
 * 获得元素的显示部分的区域，其实是获取会影响该元素显示区域的祖先元素内容区域的交集
 * http://yiminghe.iteye.com/blog/1124720
 */
function getVisibleRectForElement(element, alwaysByViewport) {
  // 首先可视区域为整个文档
  var visibleRect = {
    left: 0,
    right: Infinity,
    top: 0,
    bottom: Infinity
  };
  var el = getOffsetParent(element);
  var doc = utils.getDocument(element);
  var win = doc.defaultView || doc.parentWindow;
  var body = doc.body;
  var documentElement = doc.documentElement;

  // Determine the size of the visible rect by climbing the dom accounting for
  // all scrollable containers.
  // 即通过依次向 目标元素 的祖先元素递归,查找到会影响该元素显示的祖先元素
  // 得到 目标元素 的相对文档的 { left,right,top,bottom }
  // 简单理解为祖先中每一层父级都会对可视区域进行削减
  // 因此所有`影响显示区域`的祖先元素的区域的交集即为最终的结果
  while (el) {
    // clientWidth is zero for inline block elements in ie.
    if ((navigator.userAgent.indexOf('MSIE') === -1 || el.clientWidth !== 0) &&
    // body may have overflow set on it, yet we still get the entire
    // viewport. In some browsers, el.offsetParent may be
    // document.documentElement, so check for that too.
    el !== body && el !== documentElement && utils.css(el, 'overflow') !== 'visible') {
      var pos = utils.offset(el);
      // add border
      pos.left += el.clientLeft;
      pos.top += el.clientTop;

      // 以下代码即为 做区域的交集,不断的缩小区域, 不考虑滚动条
      visibleRect.top = Math.max(visibleRect.top, pos.top);
      visibleRect.right = Math.min(visibleRect.right,
      // consider area without scrollBar
      pos.left + el.clientWidth);
      visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);
      visibleRect.left = Math.max(visibleRect.left, pos.left);
    } else if (el === body || el === documentElement) {
      break;
    }
    el = getOffsetParent(el);
  }

  // 根据 document，和window 元素对区域进行剪裁
  // ele.style.position 只能返回行内样式 position 中的值，不能返回 css 样式表中的值
  // window.getComputedStyle(ele).position 会返回元素最终的 position 值，不管是style中还是css中的
  // Set element position to fixed
  // make sure absolute element itself don't affect it's visible area
  // https://github.com/ant-design/ant-design/issues/7601
  var originalPosition = null;
  if (!utils.isWindow(element) && !utils.isDocument(element)) {
    originalPosition = element.style.position;
    var position = utils.css(element, 'position');
    if (position === 'absolute') {
      element.style.position = 'fixed';
    }
  }
  var scrollX = utils.getWindowScrollLeft(win);
  var scrollY = utils.getWindowScrollTop(win);
  var viewportWidth = domUtils.viewportWidth(win);
  var viewportHeight = domUtils.viewportHeight(win);
  var documentWidth = documentElement.scrollWidth;
  var documentHeight = documentElement.scrollHeight;

  // scrollXXX on html is sync with body which means overflow: hidden on body gets wrong scrollXXX.
  // We should cut this ourself.
  var bodyStyle = window.getComputedStyle(body);
  if (bodyStyle.overflowX === 'hidden') {
    documentWidth = win.innerWidth;
  }
  if (bodyStyle.overflowY === 'hidden') {
    documentHeight = win.innerHeight;
  }

  // Reset element position after calculate the visible area
  if (element.style && originalPosition) {
    element.style.position = originalPosition;
  }

  // document can be larger than the viewport
  if (alwaysByViewport || isAncestorFixed(element)) {
    // Clip by viewport's size.
    visibleRect.left = Math.max(visibleRect.left, scrollX);
    visibleRect.top = Math.max(visibleRect.top, scrollY);
    visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);
    visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);
  } else {
    // Clip by document's size.
    var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);
    visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);
    var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);
    visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);
  }

  // 最后确保该可视区域是 `正常的` 因为 top 小于 0 是不现实的。内容不可能在文档之外
  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
}
export default getVisibleRectForElement;
//# sourceMappingURL=getVisibleRectForElement.js.map