import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
var _excluded = ["disable", "attachToMarksOnly", "range", "marks", "max", "min", "step", "value", "defaultValue", "onChange", "formatter", "point", "mark", "line", "tip"];
import React, { memo, useCallback, useMemo, useRef, useState } from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import { SliderContainer } from "./styled";
import { mergeRestProps, useDefaultProp, renderReactNode } from "../../common";
import { SliderLine } from "./SliderLine";
import { SliderPoint } from "./SliderPoint";
import { SliderMarks } from "./SliderMarks";
export var Slider = /*#__PURE__*/memo(function (props) {
  var _props$disable = props.disable,
    disable = _props$disable === void 0 ? false : _props$disable,
    _props$attachToMarksO = props.attachToMarksOnly,
    attachToMarksOnly = _props$attachToMarksO === void 0 ? false : _props$attachToMarksO,
    _props$range = props.range,
    range = _props$range === void 0 ? false : _props$range,
    _props$marks = props.marks,
    marks = _props$marks === void 0 ? [] : _props$marks,
    _props$max = props.max,
    max = _props$max === void 0 ? 100 : _props$max,
    _props$min = props.min,
    min = _props$min === void 0 ? 0 : _props$min,
    _props$step = props.step,
    step = _props$step === void 0 ? 1 : _props$step,
    value = props.value,
    defaultValue = props.defaultValue,
    onChange = props.onChange,
    _props$formatter = props.formatter,
    formatter = _props$formatter === void 0 ? function (value) {
      return "" + value;
    } : _props$formatter,
    point = props.point,
    mark = props.mark,
    line = props.line,
    tip = props.tip,
    rest = _objectWithoutPropertiesLoose(props, _excluded);
  var defaultStart = useMemo(function () {
    var _;
    if (!range) return min;
    return (_ = defaultValue == null ? void 0 : defaultValue[0]) != null ? _ : min;
  }, [range, defaultValue, min]);
  var defaultEnd = useMemo(function () {
    var _2, _ref;
    if (range) return (_2 = defaultValue == null ? void 0 : defaultValue[1]) != null ? _2 : min;
    return (_ref = defaultValue) != null ? _ref : min;
  }, [range, defaultValue, min]);
  var propsStart = useMemo(function () {
    if (!range) return min;
    return value == null ? void 0 : value[0];
  }, [value, range]);
  var propsEnd = useMemo(function () {
    if (range) return value == null ? void 0 : value[1];
    return value;
  }, [value, range]);
  var _useDefaultProp = useDefaultProp(defaultStart, propsStart, function () {}),
    start = _useDefaultProp[0],
    setStart = _useDefaultProp[1];
  var _useDefaultProp2 = useDefaultProp(defaultEnd, propsEnd, function () {}),
    end = _useDefaultProp2[0],
    setEnd = _useDefaultProp2[1];
  var sliderRef = useRef(null);
  var moveStart = useRef(false);
  var _useState = useState(false),
    isMove = _useState[0],
    setIsMove = _useState[1];
  var sliderLength = useMemo(function () {
    return max - min;
  }, [max, min]);
  // 计算移动距离
  var calculateDistance = useCallback(function (e) {
    var _sliderRef$current;
    if (!sliderRef.current) return min;
    var x = e.clientX;
    var rect = (_sliderRef$current = sliderRef.current) == null ? void 0 : _sliderRef$current.getBoundingClientRect();
    var _ref2 = rect || {},
      sliderLeft = _ref2.left,
      sliderRight = _ref2.right;
    var result = 0;
    if (sliderLeft && sliderRight) {
      if (x <= sliderLeft) {
        result = min;
      } else if (x >= sliderRight) {
        result = max;
      } else {
        var tmpValue = 0;
        var dist = Number.MAX_SAFE_INTEGER;
        if (!attachToMarksOnly) {
          var spanWidth = (sliderRight - sliderLeft) / ((max - min) / step);
          var order = Math.round((x - sliderLeft) / spanWidth);
          dist = Math.abs(spanWidth * order + sliderLeft - x);
          tmpValue = order * step;
        }
        marks.forEach(function (mark) {
          var newDist = Math.abs(mark / (max - min) * (sliderRight - sliderLeft) + sliderLeft - x);
          if (newDist < dist) {
            dist = newDist;
            tmpValue = mark;
          }
        });
        result = tmpValue;
      }
    }
    if (!Number.isInteger(result)) {
      result = Number(result.toFixed(6));
    }
    return result;
  }, [attachToMarksOnly, marks, max, min, step]);
  var handleChange = useCallback(function (point) {
    var _ref3 = moveStart.current ? [point, end] : [start, point],
      _ref3$ = _ref3[0],
      sValue = _ref3$ === void 0 ? 0 : _ref3$,
      _ref3$2 = _ref3[1],
      eValue = _ref3$2 === void 0 ? 0 : _ref3$2;
    var rangeValue = sValue > eValue ? [eValue, sValue] : [sValue, eValue];
    onChange == null ? void 0 : onChange(range ? rangeValue : point);
  }, [onChange, range, start, end]);
  var handleMouseMove = useCallback(function (e) {
    var result = calculateDistance(e);
    if (moveStart.current) {
      setStart(result);
    } else {
      setEnd(result);
    }
    handleChange(result);
  }, [calculateDistance, handleChange]);
  var handleClickOnMark = useCallback(function (mark) {
    if (disable) return;
    var isNearToStart = Math.abs(mark - (start != null ? start : min)) < Math.abs((end != null ? end : max) - mark);
    if (range && isNearToStart) {
      moveStart.current = true;
      setStart(mark);
    } else {
      moveStart.current = false;
      setEnd(mark);
    }
    handleChange(mark);
  }, [disable, handleChange, start, end, range, min, max]);
  var renderSliderMarks = useMemo(function () {
    var marksProps = {
      marks: marks,
      handleClickOnMark: handleClickOnMark,
      sliderLength: sliderLength,
      disable: disable
    };
    return renderReactNode(mark, /*#__PURE__*/_createElement(SliderMarks, marksProps), undefined);
  }, [marks, handleClickOnMark, sliderLength, mark, disable]);
  var handleMouseDownOnPoint = useCallback(function () {
    if (!disable) {
      setIsMove(true);
      document.addEventListener('mouseup', function () {
        document.removeEventListener('mousemove', handleMouseMove);
        setIsMove(false);
      });
      document.addEventListener('mousemove', handleMouseMove);
    }
  }, [disable, handleMouseMove]);
  var renderStartPoint = useMemo(function () {
    if (!range) return null;
    var pointProps = {
      range: range,
      handleMouseDownOnPoint: handleMouseDownOnPoint,
      point: start,
      sliderLength: sliderLength,
      isMove: isMove,
      formatter: formatter,
      moveStart: moveStart,
      isStart: true,
      disable: disable,
      tip: tip
    };
    return renderReactNode(point, /*#__PURE__*/_createElement(SliderPoint, pointProps), undefined);
  }, [range, handleMouseDownOnPoint, start, sliderLength, isMove, formatter, point, disable, tip]);
  var renderEndPoint = useMemo(function () {
    var pointProps = {
      handleMouseDownOnPoint: handleMouseDownOnPoint,
      point: end,
      sliderLength: sliderLength,
      isMove: isMove,
      formatter: formatter,
      moveStart: moveStart,
      isStart: false,
      disable: disable,
      tip: tip
    };
    return renderReactNode(point, /*#__PURE__*/_createElement(SliderPoint, pointProps), undefined);
  }, [handleMouseDownOnPoint, end, sliderLength, isMove, formatter, point, disable, tip]);
  var renderSliderLine = useMemo(function () {
    var lineProps = {
      start: start,
      end: end,
      sliderLength: sliderLength,
      disable: disable
    };
    return renderReactNode(line, /*#__PURE__*/_createElement(SliderLine, lineProps), undefined);
  }, [start, end, sliderLength, disable, line]);
  return /*#__PURE__*/_createElement(SliderContainer, _extends({
    ref: sliderRef,
    isMove: isMove
  }, mergeRestProps(rest, 'wdn-slider')), renderSliderLine, renderSliderMarks, renderStartPoint, renderEndPoint);
});
//# sourceMappingURL=Slider.js.map