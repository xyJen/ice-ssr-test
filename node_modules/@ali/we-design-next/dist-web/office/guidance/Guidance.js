import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
var _excluded = ["type", "onClose"],
  _excluded2 = ["type", "onClose"];
var _IconClose;
import _regeneratorRuntime from "@babel/runtime/regenerator";
import React, { useState, useRef, useEffect } from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import { noop } from 'lodash-es';
import ReactDOM from 'react-dom';
import { Button } from "../../basic/button";
import { TextSub } from "../../basic/text";
import { Modal } from "../../display/modal";
import { IconClose, IconArrowLeft, IconArrowRight } from "../../basic/icon";
import { IconButton } from "../../basic/icon-button";
import { GuidanceTitle, GuidanceFooter } from "./style";
import { Carousel } from "./carousel";
import { MapAnchor } from "./MapAnchor";
import { align } from "../../display/popover/align";
import { GuidePanel } from "../../office/guide-panel";
import { LocaleContext, useTranslate } from "../../locale";
import { COLORS } from "../../common";
import { globalLang } from "../../locale";
import ResizeObserver from 'resize-observer-polyfill';
var MODAL_FIXED_PLACEMENT = {
  right: 12,
  bottom: 48
};
var MODAL_FIXED_STYLE = {
  padding: 12,
  minWidth: 0,
  zIndex: 99998,
  background: COLORS.WHITE,
  borderRadius: 8
};
var GuideModalFixed = function GuideModalFixed(props) {
  var _props$guides = props.guides,
    guides = _props$guides === void 0 ? [] : _props$guides,
    onAction = props.onAction,
    _props$onCurrentChang = props.onCurrentChange,
    onCurrentChange = _props$onCurrentChang === void 0 ? noop : _props$onCurrentChang,
    onClose = props.onClose;
  var _useState = useState(0),
    currentIndex = _useState[0],
    setCurrentIndex = _useState[1];
  var clamp = function clamp(v, min, max) {
    return v < min ? min : v > max ? max : v;
  };
  var onChange = function onChange(i) {
    setCurrentIndex(i);
    onCurrentChange(guides[i].key);
  };
  var next = function next() {
    var i = clamp(currentIndex + 1, 0, guides.length - 1);
    onChange(i);
  };
  var prev = function prev() {
    var i = clamp(currentIndex - 1, 0, guides.length - 1);
    onChange(i);
  };
  var currentGuide = guides[currentIndex];
  var t = useTranslate();
  return guides.length !== 0 ? /*#__PURE__*/_createElement(Modal, {
    defaultPlacement: MODAL_FIXED_PLACEMENT,
    style: MODAL_FIXED_STYLE,
    header: null,
    footer: null,
    content: /*#__PURE__*/_createElement(React.Fragment, null, /*#__PURE__*/_createElement(GuidanceTitle, null, /*#__PURE__*/_createElement("span", {
      style: {
        flexGrow: 1
      }
    }, guides[currentIndex].title), /*#__PURE__*/_createElement(IconButton, {
      className: "wdn-close-btn",
      icon: _IconClose || (_IconClose = /*#__PURE__*/_createElement(IconClose, null)),
      onClick: onClose
    })), /*#__PURE__*/_createElement(Carousel, {
      itemWidth: 256,
      currentItemIndex: currentIndex,
      onChange: onChange,
      autoPlay: true,
      autoPlayTime: 8000,
      showCarouselDots: false
    }, guides.map(function (_ref) {
      var description = _ref.description,
        image = _ref.image,
        key = _ref.key;
      return /*#__PURE__*/_createElement(GuidePanel, {
        key: key,
        style: {
          width: 256,
          padding: 0
        },
        description: description,
        image: image
      });
    })), /*#__PURE__*/_createElement("div", {
      style: {
        display: 'flex',
        flexDirection: 'row',
        marginTop: 10,
        alignItems: 'center'
      }
    }, guides.length > 1 ? /*#__PURE__*/_createElement(React.Fragment, null, /*#__PURE__*/_createElement(IconArrowLeft, {
      onClick: prev,
      style: currentIndex === 0 ? {
        color: COLORS.LIGHT.LEVEL4_BASE_COLOR,
        cursor: 'disabled'
      } : undefined
    }), /*#__PURE__*/_createElement(TextSub, {
      style: {
        padding: '0 2px'
      }
    }, currentIndex + 1, "/", guides.length), /*#__PURE__*/_createElement(IconArrowRight, {
      onClick: next,
      style: currentIndex === guides.length - 1 ? {
        color: COLORS.LIGHT.LEVEL4_BASE_COLOR,
        cursor: 'disabled'
      } : undefined
    })) : null, /*#__PURE__*/_createElement("div", {
      style: {
        flexGrow: 1
      }
    }), /*#__PURE__*/_createElement(Button, {
      type: "primary",
      size: "small",
      onClick: function onClick() {
        return onAction && onAction(currentGuide.key);
      }
    }, t('wdn_guidance_action')))),
    visible: true
  }) : null;
};
var normalizePlacement = function normalizePlacement(p) {
  if (p === undefined) {
    return ['bottom', [0, 0]];
  }
  if (typeof p === 'string') {
    return [p, [0, 0]];
  }
  var dir = p[0],
    offset = p[1];
  if (typeof offset === 'number') {
    return [dir, [offset, 0]];
  } else {
    return [dir, offset];
  }
};
var isPromise = function isPromise(p) {
  return 'then' in p && typeof p.then === 'function';
};
var MODAL_FOLLOWING_PLACEMENT = {
  left: 0,
  top: 0
};
var MODAL_FOLLOWING_STYLE = {
  transform: 'none',
  left: -9999,
  top: -9999,
  padding: 0,
  minWidth: 0,
  zIndex: 99998,
  background: COLORS.WHITE,
  borderRadius: 8
};
var GuideModalFollowing = function GuideModalFollowing(props) {
  var _useState2 = useState(0),
    currentIndex = _useState2[0],
    setCurrentIndex = _useState2[1];
  var _props$guides2 = props.guides,
    guides = _props$guides2 === void 0 ? [] : _props$guides2,
    _props$onCurrentChang2 = props.onCurrentChange,
    onCurrentChange = _props$onCurrentChang2 === void 0 ? noop : _props$onCurrentChang2,
    onClose = props.onClose;
  var clamp = function clamp(v, min, max) {
    return v < min ? min : v > max ? max : v;
  };
  var _useState3 = useState(false),
    isPerformNext = _useState3[0],
    setIsPerformNext = _useState3[1];
  var next = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var i, _guides$i, anchor, placement, _normalizePlacement, dir, offset, anchorTarget, anchorTargetIsPromise, anchorRes, _ref3, anchorEle, anchoreOffset;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              i = clamp(currentIndex + 1, 0, guides.length - 1);
              _guides$i = guides[i], anchor = _guides$i.anchor, placement = _guides$i.placement;
              _normalizePlacement = normalizePlacement(placement), dir = _normalizePlacement[0], offset = _normalizePlacement[1];
              anchorTarget = anchor();
              anchorTargetIsPromise = isPromise(anchorTarget);
              if (anchorTargetIsPromise) {
                setIsPerformNext(true);
              }
              if (!anchorTargetIsPromise) {
                _context.next = 12;
                break;
              }
              _context.next = 9;
              return anchorTarget;
            case 9:
              _context.t0 = _context.sent;
              _context.next = 13;
              break;
            case 12:
              _context.t0 = anchorTarget;
            case 13:
              anchorRes = _context.t0;
              _ref3 = Array.isArray(anchorRes) ? anchorRes : [anchorRes, [0, 0]], anchorEle = _ref3[0], anchoreOffset = _ref3[1];
              if (anchorEle) {
                setCurrentIndex(i);
                setIsPerformNext(false);
                onCurrentChange(i);
                if (mRef.current) {
                  update(mRef.current, anchorEle, dir, offset, anchoreOffset);
                }
              }
            case 16:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return function next() {
      return _ref2.apply(this, arguments);
    };
  }();
  var observeRef = useRef(false);
  useEffect(function () {
    return function () {
      observeRef.current && observeRef.current.disconnect();
    };
  }, []);
  var update = function update(ele, target, placement, offset, anchoreOffset) {
    requestAnimationFrame(function () {
      var doUpdate = function doUpdate() {
        align(ele, target, placement, [5 + offset[0], offset[1]]);
        var _target$getBoundingCl = target.getBoundingClientRect(),
          left = _target$getBoundingCl.left,
          top = _target$getBoundingCl.top,
          width = _target$getBoundingCl.width,
          height = _target$getBoundingCl.height;
        MapAnchor.place(left + width / 2 + anchoreOffset[0], top + height / 2 + anchoreOffset[1]);
      };
      observeRef.current && observeRef.current.disconnect();
      observeRef.current = new ResizeObserver(doUpdate);
      observeRef.current.observe(document.body);
      doUpdate();
    });
  };
  useEffect(function () {
    if (mRef.current && currentIndex === 0) {
      var fn = /*#__PURE__*/function () {
        var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
          var _guides$, anchor, placement, _normalizePlacement2, dir, offset, anchorTarget, anchorRes, _ref5, anchorEle, anchoreOffset;
          return _regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _guides$ = guides[0], anchor = _guides$.anchor, placement = _guides$.placement;
                  _normalizePlacement2 = normalizePlacement(placement), dir = _normalizePlacement2[0], offset = _normalizePlacement2[1];
                  anchorTarget = anchor();
                  if (!isPromise(anchorTarget)) {
                    _context2.next = 9;
                    break;
                  }
                  _context2.next = 6;
                  return anchorTarget;
                case 6:
                  _context2.t0 = _context2.sent;
                  _context2.next = 10;
                  break;
                case 9:
                  _context2.t0 = anchorTarget;
                case 10:
                  anchorRes = _context2.t0;
                  _ref5 = Array.isArray(anchorRes) ? anchorRes : [anchorRes, [0, 0]], anchorEle = _ref5[0], anchoreOffset = _ref5[1];
                  if (mRef.current) {
                    update(mRef.current, anchorEle, dir, offset, anchoreOffset);
                  }
                case 13:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));
        return function fn() {
          return _ref4.apply(this, arguments);
        };
      }();
      fn();
    }
  }, []);
  var handleClose = function handleClose() {
    MapAnchor.remove();
    onClose && onClose();
  };
  var mRef = useRef(null);
  var guide = guides[currentIndex];
  var t = useTranslate();
  return guides.length !== 0 && guide ? /*#__PURE__*/_createElement(Modal, {
    ref: mRef,
    defaultPlacement: MODAL_FOLLOWING_PLACEMENT,
    header: null,
    style: MODAL_FOLLOWING_STYLE,
    content: /*#__PURE__*/_createElement(React.Fragment, null, /*#__PURE__*/_createElement(GuidePanel, {
      title: guide.title,
      description: guide.description,
      image: guide.image,
      style: {
        width: 200
      }
    }), /*#__PURE__*/_createElement(GuidanceFooter, null, currentIndex !== guides.length - 1 ? /*#__PURE__*/_createElement(TextSub, {
      onClick: handleClose
    }, t('wdn_skip') + " (" + (currentIndex + 1) + "/" + guides.length + ")") : null, /*#__PURE__*/_createElement("div", {
      style: {
        flexGrow: 1
      }
    }), currentIndex === guides.length - 1 ? /*#__PURE__*/_createElement(Button, {
      type: "primary",
      size: "small",
      onClick: handleClose
    }, t('wdn_isee')) : /*#__PURE__*/_createElement(Button, {
      type: "primary",
      size: "small",
      disabled: isPerformNext,
      onClick: next
    }, t('wdn_next_step')))),
    footer: null,
    visible: true
  }) : null;
};
var open = function open(opt) {
  var container = ensureContainer();
  var fn = globalLang.lang ? function (c) {
    return /*#__PURE__*/_createElement(LocaleContext.Provider, {
      value: globalLang.lang,
      children: c
    });
  } : function (c) {
    return c;
  };
  if (opt.type === 'fixed') {
    var type = opt.type,
      onClose = opt.onClose,
      rest = _objectWithoutPropertiesLoose(opt, _excluded);
    ReactDOM.render(fn( /*#__PURE__*/_createElement(GuideModalFixed, _extends({}, rest, {
      onClose: function onClose() {
        close();
        opt.onClose && opt.onClose();
      }
    }))), container);
  } else if (opt.type === 'following') {
    var _type = opt.type,
      _onClose = opt.onClose,
      _rest = _objectWithoutPropertiesLoose(opt, _excluded2);
    ReactDOM.render(fn( /*#__PURE__*/_createElement(GuideModalFollowing, _extends({}, _rest, {
      onClose: function onClose() {
        close();
        opt.onClose && opt.onClose();
      }
    }))), container);
  }
  return {
    container: container
  };
};
var close = function close() {
  ReactDOM.unmountComponentAtNode(ensureContainer());
};
var ensureContainer = function ensureContainer() {
  var id = 'wdn-guidance-root';
  var divEle = document.querySelector("div#" + id);
  if (!divEle) {
    var ele = document.createElement('div');
    ele.id = id;
    ele.style.position = 'absolute';
    ele.style.width = '100%';
    ele.style.top = '0px';
    ele.style.left = '0px';
    document.body.appendChild(ele);
  }
  ;
  return document.querySelector("div#" + id);
};
export var Guidance = {
  open: open,
  close: close
};
//# sourceMappingURL=Guidance.js.map