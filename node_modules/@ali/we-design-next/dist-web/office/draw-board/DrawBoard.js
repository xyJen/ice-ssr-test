import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
var _excluded = ["width", "height", "paintColor", "backgroundColor", "placeholder", "onPaint"];
function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
import React, { useEffect, useImperativeHandle, useRef, useState } from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import { noop } from 'lodash-es';
import { BoardWrapper, BoardPlaceholderWrapper, BoardPlaceholder, Canvas } from "./styled";
import { useEventCallback } from "../../common/react/useEventCallback";
import { mergeRestProps } from "../../common/react/mergeRestProps";
import { isIOS } from "../../common/env/isMobile";
// 获取 canvas 最小有效图像
var getCroppedImage = function getCroppedImage(canvas, vCanvas, padding) {
  if (padding === void 0) {
    padding = 0;
  }
  var getLeftBorder = function getLeftBorder(data, width, height) {
    for (var i = 0; i < width; i++) {
      for (var j = 0; j < height; j++) {
        var index = j * width + i;
        var hasColor = data[index * 4 + 3] > 0;
        if (hasColor) {
          return i + 1;
        }
      }
    }
    return 0;
  };
  var getRightBorder = function getRightBorder(data, width, height) {
    for (var i = width - 1; i >= 0; i--) {
      for (var j = 0; j < height; j++) {
        var index = j * width + i;
        var hasColor = data[index * 4 + 3] > 0;
        if (hasColor) {
          return i + 1;
        }
      }
    }
    return 0;
  };
  var getTopBorder = function getTopBorder(data, width, height) {
    for (var i = 0; i < height; i++) {
      for (var j = 0; j < width; j++) {
        var index = i * width + j;
        var hasColor = data[index * 4 + 3] > 0;
        if (hasColor) {
          return i + 1;
        }
      }
    }
    return 0;
  };
  var getBottomBorder = function getBottomBorder(imageData, width, height) {
    for (var i = height - 1; i >= 0; i--) {
      for (var j = 0; j < width; j++) {
        var index = i * width + j;
        var hasColor = imageData[index * 4 + 3] > 0;
        if (hasColor) {
          return i + 1;
        }
      }
    }
    return 0;
  };
  var ctx = canvas.getContext('2d');
  var width = canvas.width;
  var height = canvas.height;
  var _ctx$getImageData = ctx.getImageData(0, 0, width, height),
    data = _ctx$getImageData.data;
  var fns = [getLeftBorder, getRightBorder, getTopBorder, getBottomBorder];
  var _fns$map = fns.map(function (fn) {
      return fn(data, width, height);
    }),
    left = _fns$map[0],
    right = _fns$map[1],
    top = _fns$map[2],
    bottom = _fns$map[3];
  var w = right - left + 1;
  var h = bottom - top + 1;
  var newImageData = ctx.getImageData(left, top, w, h);
  vCanvas.width = w + padding * 2;
  vCanvas.height = h + padding * 2;
  var vCtx = vCanvas.getContext('2d');
  vCtx.putImageData(newImageData, padding, padding);
  var dataUrl = vCanvas.toDataURL('image/png', 1);
  return {
    dataUrl: dataUrl,
    width: vCanvas.width,
    height: vCanvas.height
  };
};
var BOARD_WIDTH = 500;
var BOARD_HEIGHT = 309;
var PAINT_COLOR = '#000000';
var LINE_CAP = 'round';
var DPR = window.devicePixelRatio;
var MAX_UNDO_STEP = 10;
export var DrawBoard = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _props$width = props.width,
    width = _props$width === void 0 ? BOARD_WIDTH : _props$width,
    _props$height = props.height,
    height = _props$height === void 0 ? BOARD_HEIGHT : _props$height,
    _props$paintColor = props.paintColor,
    paintColor = _props$paintColor === void 0 ? PAINT_COLOR : _props$paintColor,
    backgroundColor = props.backgroundColor,
    placeholder = props.placeholder,
    onPaint = props.onPaint,
    rest = _objectWithoutPropertiesLoose(props, _excluded);
  var _useState = useState(false),
    hasStartedPainting = _useState[0],
    setHasStartedPainting = _useState[1];
  var canvasRef = useRef(null);
  var controllerRef = useRef({
    undo: noop,
    redo: noop,
    clear: noop,
    destroy: noop,
    exportToImage: function exportToImage() {
      return null;
    }
  });
  useEffect(function () {
    if (canvasRef.current) {
      var ele = canvasRef.current;
      var _fn = function _fn() {
        setHasStartedPainting(true);
        ele.removeEventListener('pointerdown', _fn);
      };
      ele.addEventListener('pointerdown', _fn);
    }
  }, [canvasRef.current]);
  var onChangeFnsRef = useRef([]);
  var onPaintCallback = useEventCallback(function () {
    return onPaint && onPaint();
  });
  useEffect(function () {
    if (canvasRef.current) {
      var ele = canvasRef.current;
      ele.style.width = width + 'px';
      ele.style.height = height + 'px';
      ele.width = Math.floor(width * DPR);
      ele.height = Math.floor(height * DPR);
      var controller = createController(canvasRef.current, function (opt) {
        for (var _iterator = _createForOfIteratorHelperLoose(onChangeFnsRef.current), _step; !(_step = _iterator()).done;) {
          var _fn2 = _step.value;
          _fn2(opt);
        }
        onPaintCallback();
      }, {
        paintColor: paintColor,
        backgroundColor: backgroundColor
      });
      controllerRef.current = controller;
      return function () {
        onChangeFnsRef.current = [];
        controller.destroy();
      };
    }
  }, []);
  useImperativeHandle(ref, function () {
    return {
      onChange: function onChange(fn) {
        onChangeFnsRef.current.push(fn);
        return function () {
          var i = onChangeFnsRef.current.indexOf(fn);
          if (i !== -1) {
            onChangeFnsRef.current.splice(i, 1);
          }
        };
      },
      undo: function undo() {
        return controllerRef.current.undo();
      },
      redo: function redo() {
        return controllerRef.current.redo();
      },
      clear: function clear() {
        return controllerRef.current.clear();
      },
      exportToImage: controllerRef.current.exportToImage
    };
  });
  return /*#__PURE__*/_createElement(BoardWrapper, mergeRestProps(rest, 'wdn-drawboard', {
    width: width,
    height: height
  }), !hasStartedPainting && placeholder ? /*#__PURE__*/_createElement(BoardPlaceholderWrapper, {
    style: {
      width: width,
      height: height
    }
  }, /*#__PURE__*/_createElement(BoardPlaceholder, null, placeholder)) : null, /*#__PURE__*/_createElement(Canvas, {
    style: {
      backgroundColor: backgroundColor
    },
    ref: canvasRef
  }));
}));
var createController = function createController(canvas, onChange, options) {
  var paintColor = options.paintColor,
    backgroundColor = options.backgroundColor;
  var ctx = canvas.getContext('2d');
  ctx.scale(DPR, DPR);
  ctx.lineCap = LINE_CAP;
  ctx.strokeStyle = paintColor;
  if (backgroundColor) {
    ctx.fillStyle = backgroundColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
  var isPainting = false;
  var points = [];
  var lastSpeed = 0;
  var lastLineWidth = 5;
  var undoStack = [];
  var redoStack = [];
  var vCanvas = document.createElement('canvas');
  var change = function change() {
    return onChange({
      undoAble: undoStack.length > 1,
      redoAble: redoStack.length > 0,
      clearAble: undoStack[undoStack.length - 1] !== null
    });
  };
  var toPoint = function toPoint(event) {
    var e = 'clientX' in event ? event : event.touches[0];
    var _canvas$getBoundingCl = canvas.getBoundingClientRect(),
      left = _canvas$getBoundingCl.left,
      top = _canvas$getBoundingCl.top;
    return {
      x: e.clientX - left,
      y: e.clientY - top,
      t: Date.now()
    };
  };
  var _clear = function clear() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (backgroundColor) {
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
  };
  var snapshot = function snapshot() {
    return ctx.getImageData(0, 0, canvas.width, canvas.height);
  };
  var restoreSnapshot = function restoreSnapshot(imageData) {
    if (imageData === null) {
      _clear();
    } else {
      _clear();
      ctx.putImageData(imageData, 0, 0);
    }
  };
  var handleStart = function handleStart(event) {
    isPainting = true;
    points.push(toPoint(event));
  };
  var draw = function draw() {
    if (points.length < 3) {
      return;
    }
    var getMidPoint = function getMidPoint(p1, p2) {
      return {
        x: (p1.x + p2.x) / 2,
        y: (p1.y + p2.y) / 2,
        t: (p1.t + p2.t) / 2
      };
    };
    var getTransferredSpeed = function getTransferredSpeed(startPoint, endPoint) {
      var x1 = startPoint.x,
        y1 = startPoint.y,
        t1 = startPoint.t;
      var x2 = endPoint.x,
        y2 = endPoint.y,
        t2 = endPoint.t;
      var trueSpeed = (Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)) / (t2 - t1);
      var transferredSpeed = 0.7 * trueSpeed + (1 - 0.7) * lastSpeed;
      lastSpeed = transferredSpeed;
      return transferredSpeed;
    };
    var getLineWidthBySpeed = function getLineWidthBySpeed(speed) {
      var currLineWidth = Math.max(5 - speed, 2);
      var transferredLineWidth = (lastLineWidth + currLineWidth) / 2;
      lastLineWidth = transferredLineWidth;
      return transferredLineWidth;
    };
    var _points = points,
      p1 = _points[0],
      p2 = _points[1],
      p3 = _points[2];
    var startPoint = getMidPoint(p1, p2);
    var endPoint = getMidPoint(p2, p3);
    var x2 = p2.x,
      y2 = p2.y;
    if (startPoint.x === endPoint.x && startPoint.y === endPoint.y) return;
    var speed = getTransferredSpeed(startPoint, endPoint);
    var currentLineWidth = getLineWidthBySpeed(speed);
    ctx.lineWidth = currentLineWidth;
    ctx.beginPath();
    ctx.moveTo(startPoint.x, startPoint.y);

    // p2 作为控制点, p1 与 p2 的中点作为起始点, p2 与 p3 的中点作为终止点
    ctx.quadraticCurveTo(x2, y2, endPoint.x, endPoint.y);
    ctx.stroke();
    ctx.closePath();
  };
  var handleMove = function handleMove(event) {
    // 解决移动端滚动穿透问题
    event.preventDefault();
    if (isPainting) {
      if (points.length === 3) {
        points.shift();
      }
      points.push(toPoint(event));
      draw();
    }
  };
  var handleEnd = function handleEnd() {
    if (isPainting) {
      isPainting = false;
      points = [];
      lastSpeed = 0;
      lastLineWidth = 5;
      var sh = snapshot();
      if (sh) {
        while (undoStack.length > MAX_UNDO_STEP) {
          undoStack.shift();
        }
        undoStack.push(sh);
        redoStack = [];
        change();
      }
    }
  };
  var attachHandlers = function attachHandlers() {
    if (isIOS) {
      attachHandlersWithTouch();
    } else {
      attachHandlersWithPointer();
    }
  };
  var attachHandlersWithTouch = function attachHandlersWithTouch() {
    canvas.addEventListener('touchstart', handleStart);
    canvas.addEventListener('touchmove', handleMove);
    canvas.addEventListener('touchend', handleEnd);
    canvas.addEventListener('touchcancel', handleEnd);
  };
  var attachHandlersWithPointer = function attachHandlersWithPointer() {
    canvas.addEventListener('pointerdown', handleStart);
    canvas.addEventListener('pointermove', handleMove);
    canvas.addEventListener('pointerup', handleEnd);
    canvas.addEventListener('pointercancel', handleEnd);
  };
  var detachHandlers = function detachHandlers() {
    if (isIOS) {
      detachHandlersWithTouch();
    } else {
      detachHandlersWithPointer();
    }
  };
  var detachHandlersWithTouch = function detachHandlersWithTouch() {
    canvas.removeEventListener('touchstart', handleStart);
    canvas.removeEventListener('touchmove', handleMove);
    canvas.removeEventListener('touchend', handleEnd);
    canvas.removeEventListener('touchcancel', handleEnd);
  };
  var detachHandlersWithPointer = function detachHandlersWithPointer() {
    canvas.removeEventListener('pointerdown', handleStart);
    canvas.removeEventListener('pointermove', handleMove);
    canvas.removeEventListener('pointerup', handleEnd);
    canvas.removeEventListener('pointercancel', handleEnd);
  };
  attachHandlers();
  undoStack.push(null);
  return {
    undo: function undo() {
      if (undoStack.length > 1) {
        var sp = undoStack.pop();
        redoStack.push(sp);
        restoreSnapshot(undoStack[undoStack.length - 1]);
        change();
      }
    },
    redo: function redo() {
      if (redoStack.length > 0) {
        var sp = redoStack.pop();
        restoreSnapshot(sp);
        undoStack.push(sp);
        change();
      }
    },
    clear: function clear() {
      _clear();
      undoStack.push(null);
      redoStack = [];
      change();
    },
    exportToImage: function exportToImage(type, options) {
      if (type === void 0) {
        type = 'dataUrl';
      }
      if (!canvas) return null;
      if (type === 'dataUrl') {
        var _ref = options || {},
          cropPadding = _ref.cropPadding;
        if (cropPadding) {
          return getCroppedImage(canvas, vCanvas, cropPadding);
        }
        return {
          dataUrl: canvas.toDataURL('image/png', 1),
          width: canvas.width,
          height: canvas.height
        };
      }
      return null;
    },
    destroy: function destroy() {
      detachHandlers();
    }
  };
};
//# sourceMappingURL=DrawBoard.js.map