import type { IAlign, IVisibleRect, IFullRegion, IRect } from '../interface';
export declare type SourceInfo = [IFullRegion, IVisibleRect | null, number, number];
export declare type TargetInfo = [IFullRegion, boolean];
/**
 * 获取内容节点的Rect对象
 * @param el: 内容节点
 * @returns [当前节点所占的区域, 当前节点可以被放置的显示区域, 节点区域的宽度，节点区域的高度]
 */
export declare const getRectOfSource: (src: HTMLElement, align: IAlign) => SourceInfo;
/**
 * 获得触发器节点的Rect对象
 * @param tgt: 触发器节点
 * @returns [当前节点所占的区域, 当前节点是否部分不可见]
 */
export declare const getRectOfTarget: (tgt: HTMLElement, align: IAlign) => TargetInfo;
/**
 * 根据内容节点和触发器节点的Rect对象，计算出最终内容节点应该放置的位置
 *
 * 当前视窗放不下目标Rect的情况（目前先维持dom-align原逻辑2）
 * 1. 如果没设置adjustXX，进入步骤3。
 *    如果设置了adjustXX, 翻转对齐方向，此时再次判断翻转后放不放得下
 *      1）放得下，返回翻转后的Rect
 *      2）放不下，重置成原来的对齐方向
 *          a.设置了resizeXX，进入步骤2；
 *          b.没设置resizeXX, 进入步骤3；
 * 2. resize目标Rect的宽/高, 再判断能不能放下
 *    1）放得下，返回resize后的Rect
 *    2）放不下，进入步骤3。
 * 3. 放不下就放不下，return Rect。
 *
 * @param src: 内容节点
 * @param tgt：触发器节点
 */
export declare const getDestinationRect: (src: SourceInfo, tgt: TargetInfo, align: IAlign) => IRect;
/**
 * 给元素el设置成Rect的样式，完成最终定位
 * @param el
 * @param rect
 */
export declare const alignRect: (el: HTMLElement, rect: IRect, align: IAlign) => void;
