"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var React = _interopRequireWildcard(require("react"));

var _reactWindow = require("react-window");

var _reactVirtualizedAutoSizer = _interopRequireDefault(require("react-virtualized-auto-sizer"));

var _lodash = require("lodash");

var _weDesign = require("@ali/we-design");

var _isHotkey = _interopRequireDefault(require("is-hotkey"));

var _actions = require("../actions");

var _suggestionItem = _interopRequireDefault(require("./suggestionItem"));

var _styled = require("./styled");

const _createElement = /*#__PURE__*/React.createElement;
const isUpHotKey = (0, _isHotkey.default)('up');
const isDownHotKey = (0, _isHotkey.default)('down');
const isLeftHotKey = (0, _isHotkey.default)('left');
const isRightHotKey = (0, _isHotkey.default)('right');
const isEnterHotKey = (0, _isHotkey.default)('enter');

var _ref = /*#__PURE__*/_createElement(_weDesign.LoadingBetaNormal, null);

const MentionSuggestion = props => {
  const {
    controller,
    text,
    renderItem,
    renderHeader,
    searching,
    renderFooter,
    renderLoading,
    renderEmpty,
    offsetBottom = 0,
    loadMoreSuggestions,
    suggestions,
    setSuggestions,
    delayedSearching,
    itemHeight = 50
  } = props;
  const [selectedIndex, setSelectedIndex] = React.useState(0);
  const listRef = React.useRef(null);
  const lastItem = React.useRef(null);
  const editorRef = React.useRef(controller);
  const isEmptyText = text.trim().length === 0;
  const isEmptySuggestions = suggestions.length === 0;
  const handleSelect = React.useCallback(index => {
    const suggestion = suggestions[(0, _lodash.isNil)(index) ? selectedIndex : index];
    editorRef.current.run('onAction', (0, _actions.insertMention)(suggestion));
  }, [suggestions, selectedIndex]);
  const handleScroll = React.useCallback(({
    scrollOffset
  }) => {
    if (!loadMoreSuggestions || !listRef.current) {
      return;
    }
    /* 当倒数第 offsetBottom + 1 个元素进入可视区域时触发 loadMoreSuggestions */


    const startOffset = (suggestions.length - offsetBottom - 2) * itemHeight - listRef.current.props.height;

    if (startOffset > 0 && startOffset <= scrollOffset && lastItem.current !== suggestions.length) {
      lastItem.current = suggestions.length;
      loadMoreSuggestions(text, suggestions.length, setSuggestions);
    }
  }, [loadMoreSuggestions, suggestions.length, offsetBottom, itemHeight, text, setSuggestions]);
  const itemData = React.useMemo(() => ({
    suggestions,
    onSelect: handleSelect,
    renderItem,
    selectedIndex,
    onSelectedIndexChange: setSelectedIndex
  }), [suggestions, renderItem, selectedIndex, handleSelect]);
  React.useEffect(() => {
    editorRef.current = controller;
  }, [controller]); // listen up & down

  React.useEffect(() => {
    const handleMove = event => {
      if (event.isComposing || searching.current) {
        return;
      }

      if (isRightHotKey(event) || isDownHotKey(event)) {
        event.preventDefault();
        setSelectedIndex(index => (index + 1) % suggestions.length);
      }

      if (isLeftHotKey(event) || isUpHotKey(event)) {
        event.preventDefault();
        setSelectedIndex(index => index === 0 ? suggestions.length - 1 : index - 1);
      }

      if (isEnterHotKey(event)) {
        event.preventDefault();
        event.stopPropagation();
        handleSelect();
        editorRef.current.run('onAction', (0, _actions.deactiveMention)());
      }
    };

    document.addEventListener('keyup', handleMove);
    return () => {
      document.removeEventListener('keyup', handleMove);
    };
  }, [searching, suggestions, selectedIndex]);
  React.useEffect(() => {
    const handleKeyDown = event => {
      if (!event.key) {
        return;
      }

      const key = event.key.toLowerCase();

      if (event.isComposing || searching.current) {
        return;
      }

      if (key === ' ' && event.keyCode === 32) {
        if (!isEmptyText && !isEmptySuggestions) {
          event.preventDefault();
          event.stopPropagation();
          handleSelect(0);
        } else {
          editorRef.current.run('onAction', (0, _actions.deactiveMention)());
        }
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [handleSelect, isEmptySuggestions, isEmptyText, searching]); // scroll to selected index

  React.useEffect(() => {
    if (listRef.current) {
      listRef.current.scrollToItem(selectedIndex);
    }
  }, [selectedIndex]);

  if (!delayedSearching && suggestions.length === 0 && renderEmpty) {
    return renderEmpty();
  }

  return /*#__PURE__*/_createElement(React.Fragment, null, renderHeader && renderHeader(), /*#__PURE__*/_createElement("div", {
    style: {
      flex: 1
    }
  }, /*#__PURE__*/_createElement(_reactVirtualizedAutoSizer.default, null, ({
    height,
    width
  }) => delayedSearching ? /*#__PURE__*/_createElement(_styled.LoadingWrapper, {
    "data-testid": "mention-suggestion-loading",
    height: height,
    width: width
  }, renderLoading ? renderLoading() : _ref) : /*#__PURE__*/_createElement(React.Fragment, null, /*#__PURE__*/_createElement(_reactWindow.FixedSizeList, {
    className: "mention-suggestion-list",
    ref: listRef,
    height: height,
    itemCount: suggestions.length,
    itemSize: itemHeight,
    itemData: itemData,
    width: width,
    onScroll: handleScroll
  }, _suggestionItem.default)))), renderFooter && renderFooter());
};

var _default = /*#__PURE__*/React.memo(MentionSuggestion);

exports.default = _default;
//# sourceMappingURL=suggestion.js.map