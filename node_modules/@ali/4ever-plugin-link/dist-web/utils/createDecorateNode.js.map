{"version":3,"sources":["../../../src/utils/createDecorateNode.ts"],"names":["Text","Decoration","Block","createLinkify","matchesLink","blocksContainText","paragraph","isContainsText","node","type","isContainsLine","nodes","some","child","isBlock","createDecorateNode","protocolAllowList","linkify","decorateNode","controller","next","others","value","document","linkDecorations","textStr","text","replace","test","texts","getTexts","allText","reduce","prev","t","matches","links","map","match","ak","ao","fk","fo","from","newFrom","length","index","key","lastIndex","anchorKey","anchorOffset","focusKey","focusOffset","fromJSON","start","offset","end","mark","data","href","url","offsetInNode","decorations","isText","leavesWithoutUnlinkMark","i","leaves","leaf","marks","find","push","textWithoutUnlinkMark","join","path","getPath","point"],"mappings":"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","sourcesContent":["/* eslint-disable no-param-reassign */\nimport { Text, Controller, Decoration, Block, Leaf } from '@ali/4ever-cangjie';\nimport { createLinkify, matchesLink } from '@ali/4ever-utils';\n\nconst blocksContainText = {\n  'heading-1': true,\n  'heading-2': true,\n  'heading-3': true,\n  'heading-4': true,\n  'heading-5': true,\n  'heading-6': true,\n  paragraph: true,\n};\nfunction isContainsText(node: Block) {\n  // PERF: 严谨的实现应该是 node.nodes.some(Text.isText)，但这会让断言复杂度变为 O(mn)\n  return blocksContainText[node.type];\n}\n\nfunction isContainsLine(node: Block) {\n  return node.nodes.some(\n    (child) => Block.isBlock(child) && child.type === 'line',\n  );\n}\n\nexport default function createDecorateNode(protocolAllowList: string[]) {\n  const linkify = createLinkify(protocolAllowList);\n\n  return function decorateNode(\n    node: Block,\n    controller: Controller,\n    next: () => void | Decoration[],\n  ) {\n    const others = next() || [];\n    if (!isContainsText(node)) {\n      return others;\n    }\n\n    const { value } = controller;\n    const { document } = value;\n\n    let linkDecorations: Decoration[] = [];\n\n    // 处理分页下的节点装饰\n    if (isContainsLine(node)) {\n      const textStr = node.text.replace(/\\n$/, '');\n      if (!linkify.test(textStr)) {\n        return others;\n      }\n      const texts = node.getTexts();\n      const allText = texts.reduce(\n        (prev, t) => prev + t.text.replace(/\\n$/, ''),\n        '',\n      );\n\n      const matches = matchesLink(linkify, allText);\n      if (matches) {\n        const links = matches.map((match) => {\n          const [\n            anchorKey,\n            anchorOffset,\n            focusKey,\n            focusOffset,\n          ] = texts.reduce<[string | null, number, string | null, number, number]>(\n            ([ak, ao, fk, fo, from], t) => {\n              // stop...\n              if (ak && fk) {\n                return [ak, ao, fk, fo, from];\n              }\n              const newFrom = from + t.text.replace(/\\n$/, '').length;\n              if (!ak && newFrom >= match.index) {\n                ak = t.key;\n                ao = match.index - from;\n              }\n              if (!fk && newFrom >= match.lastIndex) {\n                fk = t.key;\n                fo = match.lastIndex - from;\n              }\n              return [ak, ao, fk, fo, newFrom];\n            },\n            [null, 0, null, 0, 0],\n          );\n\n          return Decoration.fromJSON({\n            start: {\n              key: anchorKey!,\n              offset: anchorOffset,\n            },\n            end: {\n              key: focusKey!,\n              offset: focusOffset,\n            },\n            mark: { type: 'link', data: { href: match.url, offsetInNode: anchorOffset } },\n          });\n        });\n        linkDecorations = [...links];\n      }\n    } else {\n      // @ts-ignore\n      linkDecorations = node.nodes.reduce<Decoration[]>((decorations, text) => {\n        if (!Text.isText(text) || !text.text) {\n          return decorations;\n        }\n        // 不对整个text节点做处理，因为其中可能包含有unlink mark的叶子节点\n        const leavesWithoutUnlinkMark: Leaf[] = [];\n        for (let i = 0; i < text.leaves.length; i++) {\n          const leaf = text.leaves[i];\n          // 存在unlink的mark则后续的leaf都不需要处理\n          if (leaf.marks && leaf.marks.find((mark) => mark.type === 'unlink')) {\n            break;\n          }\n          leavesWithoutUnlinkMark.push(leaf);\n        }\n        const textWithoutUnlinkMark = leavesWithoutUnlinkMark.map((leaf) => leaf.text).join('');\n\n        const matches = matchesLink(linkify, textWithoutUnlinkMark);\n\n        if (!matches) {\n          return decorations;\n        }\n\n        const path = document.getPath(text.key);\n        const point = {\n          key: text.key,\n          path,\n        };\n        const links = matches.map((match) => (Decoration.fromJSON({\n          start: {\n            ...point,\n            offset: match.index,\n          },\n          end: {\n            ...point,\n            offset: match.lastIndex,\n          },\n          mark: { type: 'link', data: { href: match.url, offsetInNode: match.index } },\n        })));\n        return [...decorations, ...links];\n      }, []);\n    }\n\n    return [...others, ...linkDecorations];\n  };\n}\n"],"file":"createDecorateNode.js"}