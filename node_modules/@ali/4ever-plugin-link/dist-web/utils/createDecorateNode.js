import _extends from "@babel/runtime/helpers/extends";

/* eslint-disable no-param-reassign */
import { Text, Decoration, Block } from '@ali/4ever-cangjie';
import { createLinkify, matchesLink } from '@ali/4ever-utils';
var blocksContainText = {
  'heading-1': true,
  'heading-2': true,
  'heading-3': true,
  'heading-4': true,
  'heading-5': true,
  'heading-6': true,
  paragraph: true
};

function isContainsText(node) {
  // PERF: 严谨的实现应该是 node.nodes.some(Text.isText)，但这会让断言复杂度变为 O(mn)
  return blocksContainText[node.type];
}

function isContainsLine(node) {
  return node.nodes.some(function (child) {
    return Block.isBlock(child) && child.type === 'line';
  });
}

export default function createDecorateNode(protocolAllowList) {
  var linkify = createLinkify(protocolAllowList);
  return function decorateNode(node, controller, next) {
    var others = next() || [];

    if (!isContainsText(node)) {
      return others;
    }

    var value = controller.value;
    var document = value.document;
    var linkDecorations = []; // 处理分页下的节点装饰

    if (isContainsLine(node)) {
      var textStr = node.text.replace(/\n$/, '');

      if (!linkify.test(textStr)) {
        return others;
      }

      var texts = node.getTexts();
      var allText = texts.reduce(function (prev, t) {
        return prev + t.text.replace(/\n$/, '');
      }, '');
      var matches = matchesLink(linkify, allText);

      if (matches) {
        var links = matches.map(function (match) {
          var _texts$reduce = texts.reduce(function (_ref, t) {
            var ak = _ref[0],
                ao = _ref[1],
                fk = _ref[2],
                fo = _ref[3],
                from = _ref[4];

            // stop...
            if (ak && fk) {
              return [ak, ao, fk, fo, from];
            }

            var newFrom = from + t.text.replace(/\n$/, '').length;

            if (!ak && newFrom >= match.index) {
              ak = t.key;
              ao = match.index - from;
            }

            if (!fk && newFrom >= match.lastIndex) {
              fk = t.key;
              fo = match.lastIndex - from;
            }

            return [ak, ao, fk, fo, newFrom];
          }, [null, 0, null, 0, 0]),
              anchorKey = _texts$reduce[0],
              anchorOffset = _texts$reduce[1],
              focusKey = _texts$reduce[2],
              focusOffset = _texts$reduce[3];

          return Decoration.fromJSON({
            start: {
              key: anchorKey,
              offset: anchorOffset
            },
            end: {
              key: focusKey,
              offset: focusOffset
            },
            mark: {
              type: 'link',
              data: {
                href: match.url,
                offsetInNode: anchorOffset
              }
            }
          });
        });
        linkDecorations = [].concat(links);
      }
    } else {
      // @ts-ignore
      linkDecorations = node.nodes.reduce(function (decorations, text) {
        if (!Text.isText(text) || !text.text) {
          return decorations;
        } // 不对整个text节点做处理，因为其中可能包含有unlink mark的叶子节点


        var leavesWithoutUnlinkMark = [];

        for (var i = 0; i < text.leaves.length; i++) {
          var leaf = text.leaves[i]; // 存在unlink的mark则后续的leaf都不需要处理

          if (leaf.marks && leaf.marks.find(function (mark) {
            return mark.type === 'unlink';
          })) {
            break;
          }

          leavesWithoutUnlinkMark.push(leaf);
        }

        var textWithoutUnlinkMark = leavesWithoutUnlinkMark.map(function (leaf) {
          return leaf.text;
        }).join('');
        var matches = matchesLink(linkify, textWithoutUnlinkMark);

        if (!matches) {
          return decorations;
        }

        var path = document.getPath(text.key);
        var point = {
          key: text.key,
          path: path
        };
        var links = matches.map(function (match) {
          return Decoration.fromJSON({
            start: _extends({}, point, {
              offset: match.index
            }),
            end: _extends({}, point, {
              offset: match.lastIndex
            }),
            mark: {
              type: 'link',
              data: {
                href: match.url,
                offsetInNode: match.index
              }
            }
          });
        });
        return [].concat(decorations, links);
      }, []);
    }

    return [].concat(others, linkDecorations);
  };
}
//# sourceMappingURL=createDecorateNode.js.map