{"version":3,"sources":["../../../src/utils/createDecorateNode.ts"],"names":["blocksContainText","paragraph","isContainsText","node","type","isContainsLine","nodes","some","child","Block","isBlock","createDecorateNode","protocolAllowList","linkify","decorateNode","controller","next","others","value","document","linkDecorations","textStr","text","replace","test","texts","getTexts","allText","reduce","prev","t","matches","links","map","match","anchorKey","anchorOffset","focusKey","focusOffset","ak","ao","fk","fo","from","newFrom","length","index","key","lastIndex","Decoration","fromJSON","start","offset","end","mark","data","href","url","offsetInNode","decorations","Text","isText","leavesWithoutUnlinkMark","i","leaves","leaf","marks","find","push","textWithoutUnlinkMark","join","path","getPath","point"],"mappings":";;;;;;;AACA;;AACA;;AAFA;AAIA,MAAMA,iBAAiB,GAAG;AACxB,eAAa,IADW;AAExB,eAAa,IAFW;AAGxB,eAAa,IAHW;AAIxB,eAAa,IAJW;AAKxB,eAAa,IALW;AAMxB,eAAa,IANW;AAOxBC,EAAAA,SAAS,EAAE;AAPa,CAA1B;;AASA,SAASC,cAAT,CAAwBC,IAAxB,EAAqC;AACnC;AACA,SAAOH,iBAAiB,CAACG,IAAI,CAACC,IAAN,CAAxB;AACD;;AAED,SAASC,cAAT,CAAwBF,IAAxB,EAAqC;AACnC,SAAOA,IAAI,CAACG,KAAL,CAAWC,IAAX,CACJC,KAAD,IAAWC,mBAAMC,OAAN,CAAcF,KAAd,KAAwBA,KAAK,CAACJ,IAAN,KAAe,MAD7C,CAAP;AAGD;;AAEc,SAASO,kBAAT,CAA4BC,iBAA5B,EAAyD;AACtE,QAAMC,OAAO,GAAG,8BAAcD,iBAAd,CAAhB;AAEA,SAAO,SAASE,YAAT,CACLX,IADK,EAELY,UAFK,EAGLC,IAHK,EAIL;AACA,UAAMC,MAAM,GAAGD,IAAI,MAAM,EAAzB;;AACA,QAAI,CAACd,cAAc,CAACC,IAAD,CAAnB,EAA2B;AACzB,aAAOc,MAAP;AACD;;AAED,UAAM;AAAEC,MAAAA;AAAF,QAAYH,UAAlB;AACA,UAAM;AAAEI,MAAAA;AAAF,QAAeD,KAArB;AAEA,QAAIE,eAA6B,GAAG,EAApC,CATA,CAWA;;AACA,QAAIf,cAAc,CAACF,IAAD,CAAlB,EAA0B;AACxB,YAAMkB,OAAO,GAAGlB,IAAI,CAACmB,IAAL,CAAUC,OAAV,CAAkB,KAAlB,EAAyB,EAAzB,CAAhB;;AACA,UAAI,CAACV,OAAO,CAACW,IAAR,CAAaH,OAAb,CAAL,EAA4B;AAC1B,eAAOJ,MAAP;AACD;;AACD,YAAMQ,KAAK,GAAGtB,IAAI,CAACuB,QAAL,EAAd;AACA,YAAMC,OAAO,GAAGF,KAAK,CAACG,MAAN,CACd,CAACC,IAAD,EAAOC,CAAP,KAAaD,IAAI,GAAGC,CAAC,CAACR,IAAF,CAAOC,OAAP,CAAe,KAAf,EAAsB,EAAtB,CADN,EAEd,EAFc,CAAhB;AAKA,YAAMQ,OAAO,GAAG,4BAAYlB,OAAZ,EAAqBc,OAArB,CAAhB;;AACA,UAAII,OAAJ,EAAa;AACX,cAAMC,KAAK,GAAGD,OAAO,CAACE,GAAR,CAAaC,KAAD,IAAW;AACnC,gBAAM,CACJC,SADI,EAEJC,YAFI,EAGJC,QAHI,EAIJC,WAJI,IAKFb,KAAK,CAACG,MAAN,CACF,CAAC,CAACW,EAAD,EAAKC,EAAL,EAASC,EAAT,EAAaC,EAAb,EAAiBC,IAAjB,CAAD,EAAyBb,CAAzB,KAA+B;AAC7B;AACA,gBAAIS,EAAE,IAAIE,EAAV,EAAc;AACZ,qBAAO,CAACF,EAAD,EAAKC,EAAL,EAASC,EAAT,EAAaC,EAAb,EAAiBC,IAAjB,CAAP;AACD;;AACD,kBAAMC,OAAO,GAAGD,IAAI,GAAGb,CAAC,CAACR,IAAF,CAAOC,OAAP,CAAe,KAAf,EAAsB,EAAtB,EAA0BsB,MAAjD;;AACA,gBAAI,CAACN,EAAD,IAAOK,OAAO,IAAIV,KAAK,CAACY,KAA5B,EAAmC;AACjCP,cAAAA,EAAE,GAAGT,CAAC,CAACiB,GAAP;AACAP,cAAAA,EAAE,GAAGN,KAAK,CAACY,KAAN,GAAcH,IAAnB;AACD;;AACD,gBAAI,CAACF,EAAD,IAAOG,OAAO,IAAIV,KAAK,CAACc,SAA5B,EAAuC;AACrCP,cAAAA,EAAE,GAAGX,CAAC,CAACiB,GAAP;AACAL,cAAAA,EAAE,GAAGR,KAAK,CAACc,SAAN,GAAkBL,IAAvB;AACD;;AACD,mBAAO,CAACJ,EAAD,EAAKC,EAAL,EAASC,EAAT,EAAaC,EAAb,EAAiBE,OAAjB,CAAP;AACD,WAhBC,EAiBF,CAAC,IAAD,EAAO,CAAP,EAAU,IAAV,EAAgB,CAAhB,EAAmB,CAAnB,CAjBE,CALJ;AAyBA,iBAAOK,wBAAWC,QAAX,CAAoB;AACzBC,YAAAA,KAAK,EAAE;AACLJ,cAAAA,GAAG,EAAEZ,SADA;AAELiB,cAAAA,MAAM,EAAEhB;AAFH,aADkB;AAKzBiB,YAAAA,GAAG,EAAE;AACHN,cAAAA,GAAG,EAAEV,QADF;AAEHe,cAAAA,MAAM,EAAEd;AAFL,aALoB;AASzBgB,YAAAA,IAAI,EAAE;AAAElD,cAAAA,IAAI,EAAE,MAAR;AAAgBmD,cAAAA,IAAI,EAAE;AAAEC,gBAAAA,IAAI,EAAEtB,KAAK,CAACuB,GAAd;AAAmBC,gBAAAA,YAAY,EAAEtB;AAAjC;AAAtB;AATmB,WAApB,CAAP;AAWD,SArCa,CAAd;AAsCAhB,QAAAA,eAAe,GAAG,CAAC,GAAGY,KAAJ,CAAlB;AACD;AACF,KArDD,MAqDO;AACL;AACAZ,MAAAA,eAAe,GAAGjB,IAAI,CAACG,KAAL,CAAWsB,MAAX,CAAgC,CAAC+B,WAAD,EAAcrC,IAAd,KAAuB;AACvE,YAAI,CAACsC,kBAAKC,MAAL,CAAYvC,IAAZ,CAAD,IAAsB,CAACA,IAAI,CAACA,IAAhC,EAAsC;AACpC,iBAAOqC,WAAP;AACD,SAHsE,CAIvE;;;AACA,cAAMG,uBAA+B,GAAG,EAAxC;;AACA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGzC,IAAI,CAAC0C,MAAL,CAAYnB,MAAhC,EAAwCkB,CAAC,EAAzC,EAA6C;AAC3C,gBAAME,IAAI,GAAG3C,IAAI,CAAC0C,MAAL,CAAYD,CAAZ,CAAb,CAD2C,CAE3C;;AACA,cAAIE,IAAI,CAACC,KAAL,IAAcD,IAAI,CAACC,KAAL,CAAWC,IAAX,CAAiBb,IAAD,IAAUA,IAAI,CAAClD,IAAL,KAAc,QAAxC,CAAlB,EAAqE;AACnE;AACD;;AACD0D,UAAAA,uBAAuB,CAACM,IAAxB,CAA6BH,IAA7B;AACD;;AACD,cAAMI,qBAAqB,GAAGP,uBAAuB,CAAC7B,GAAxB,CAA6BgC,IAAD,IAAUA,IAAI,CAAC3C,IAA3C,EAAiDgD,IAAjD,CAAsD,EAAtD,CAA9B;AAEA,cAAMvC,OAAO,GAAG,4BAAYlB,OAAZ,EAAqBwD,qBAArB,CAAhB;;AAEA,YAAI,CAACtC,OAAL,EAAc;AACZ,iBAAO4B,WAAP;AACD;;AAED,cAAMY,IAAI,GAAGpD,QAAQ,CAACqD,OAAT,CAAiBlD,IAAI,CAACyB,GAAtB,CAAb;AACA,cAAM0B,KAAK,GAAG;AACZ1B,UAAAA,GAAG,EAAEzB,IAAI,CAACyB,GADE;AAEZwB,UAAAA;AAFY,SAAd;AAIA,cAAMvC,KAAK,GAAGD,OAAO,CAACE,GAAR,CAAaC,KAAD,IAAYe,wBAAWC,QAAX,CAAoB;AACxDC,UAAAA,KAAK,EAAE,EACL,GAAGsB,KADE;AAELrB,YAAAA,MAAM,EAAElB,KAAK,CAACY;AAFT,WADiD;AAKxDO,UAAAA,GAAG,EAAE,EACH,GAAGoB,KADA;AAEHrB,YAAAA,MAAM,EAAElB,KAAK,CAACc;AAFX,WALmD;AASxDM,UAAAA,IAAI,EAAE;AAAElD,YAAAA,IAAI,EAAE,MAAR;AAAgBmD,YAAAA,IAAI,EAAE;AAAEC,cAAAA,IAAI,EAAEtB,KAAK,CAACuB,GAAd;AAAmBC,cAAAA,YAAY,EAAExB,KAAK,CAACY;AAAvC;AAAtB;AATkD,SAApB,CAAxB,CAAd;AAWA,eAAO,CAAC,GAAGa,WAAJ,EAAiB,GAAG3B,KAApB,CAAP;AACD,OAvCiB,EAuCf,EAvCe,CAAlB;AAwCD;;AAED,WAAO,CAAC,GAAGf,MAAJ,EAAY,GAAGG,eAAf,CAAP;AACD,GAlHD;AAmHD","sourcesContent":["/* eslint-disable no-param-reassign */\nimport { Text, Controller, Decoration, Block, Leaf } from '@ali/4ever-cangjie';\nimport { createLinkify, matchesLink } from '@ali/4ever-utils';\n\nconst blocksContainText = {\n  'heading-1': true,\n  'heading-2': true,\n  'heading-3': true,\n  'heading-4': true,\n  'heading-5': true,\n  'heading-6': true,\n  paragraph: true,\n};\nfunction isContainsText(node: Block) {\n  // PERF: 严谨的实现应该是 node.nodes.some(Text.isText)，但这会让断言复杂度变为 O(mn)\n  return blocksContainText[node.type];\n}\n\nfunction isContainsLine(node: Block) {\n  return node.nodes.some(\n    (child) => Block.isBlock(child) && child.type === 'line',\n  );\n}\n\nexport default function createDecorateNode(protocolAllowList: string[]) {\n  const linkify = createLinkify(protocolAllowList);\n\n  return function decorateNode(\n    node: Block,\n    controller: Controller,\n    next: () => void | Decoration[],\n  ) {\n    const others = next() || [];\n    if (!isContainsText(node)) {\n      return others;\n    }\n\n    const { value } = controller;\n    const { document } = value;\n\n    let linkDecorations: Decoration[] = [];\n\n    // 处理分页下的节点装饰\n    if (isContainsLine(node)) {\n      const textStr = node.text.replace(/\\n$/, '');\n      if (!linkify.test(textStr)) {\n        return others;\n      }\n      const texts = node.getTexts();\n      const allText = texts.reduce(\n        (prev, t) => prev + t.text.replace(/\\n$/, ''),\n        '',\n      );\n\n      const matches = matchesLink(linkify, allText);\n      if (matches) {\n        const links = matches.map((match) => {\n          const [\n            anchorKey,\n            anchorOffset,\n            focusKey,\n            focusOffset,\n          ] = texts.reduce<[string | null, number, string | null, number, number]>(\n            ([ak, ao, fk, fo, from], t) => {\n              // stop...\n              if (ak && fk) {\n                return [ak, ao, fk, fo, from];\n              }\n              const newFrom = from + t.text.replace(/\\n$/, '').length;\n              if (!ak && newFrom >= match.index) {\n                ak = t.key;\n                ao = match.index - from;\n              }\n              if (!fk && newFrom >= match.lastIndex) {\n                fk = t.key;\n                fo = match.lastIndex - from;\n              }\n              return [ak, ao, fk, fo, newFrom];\n            },\n            [null, 0, null, 0, 0],\n          );\n\n          return Decoration.fromJSON({\n            start: {\n              key: anchorKey!,\n              offset: anchorOffset,\n            },\n            end: {\n              key: focusKey!,\n              offset: focusOffset,\n            },\n            mark: { type: 'link', data: { href: match.url, offsetInNode: anchorOffset } },\n          });\n        });\n        linkDecorations = [...links];\n      }\n    } else {\n      // @ts-ignore\n      linkDecorations = node.nodes.reduce<Decoration[]>((decorations, text) => {\n        if (!Text.isText(text) || !text.text) {\n          return decorations;\n        }\n        // 不对整个text节点做处理，因为其中可能包含有unlink mark的叶子节点\n        const leavesWithoutUnlinkMark: Leaf[] = [];\n        for (let i = 0; i < text.leaves.length; i++) {\n          const leaf = text.leaves[i];\n          // 存在unlink的mark则后续的leaf都不需要处理\n          if (leaf.marks && leaf.marks.find((mark) => mark.type === 'unlink')) {\n            break;\n          }\n          leavesWithoutUnlinkMark.push(leaf);\n        }\n        const textWithoutUnlinkMark = leavesWithoutUnlinkMark.map((leaf) => leaf.text).join('');\n\n        const matches = matchesLink(linkify, textWithoutUnlinkMark);\n\n        if (!matches) {\n          return decorations;\n        }\n\n        const path = document.getPath(text.key);\n        const point = {\n          key: text.key,\n          path,\n        };\n        const links = matches.map((match) => (Decoration.fromJSON({\n          start: {\n            ...point,\n            offset: match.index,\n          },\n          end: {\n            ...point,\n            offset: match.lastIndex,\n          },\n          mark: { type: 'link', data: { href: match.url, offsetInNode: match.index } },\n        })));\n        return [...decorations, ...links];\n      }, []);\n    }\n\n    return [...others, ...linkDecorations];\n  };\n}\n"],"file":"createDecorateNode.js"}