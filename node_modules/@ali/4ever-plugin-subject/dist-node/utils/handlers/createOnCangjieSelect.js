"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _everCangjie = require("@ali/4ever-cangjie");

var _everUtils = require("@ali/4ever-utils");

var _queries = require("../queries");

var _utils = require("../utils");

const SUBJECT_NORMALIZE = 'subjectNormalize';

function createOnCangjieSelect(options = {}) {
  const {
    inject = false
  } = options;
  return function onCangjieSelect(event, controller, next) {
    const {
      selection,
      trigger
    } = event.detail;
    const {
      document,
      injections
    } = controller.value;
    const {
      focus
    } = selection;
    const block = document.getFurthestAncestor(focus.key);
    /**
     * Effects 1: 若光标 focus 进入到折叠议题区域内，需要自动展开议题
     * @description 此处需求是由于在内容折叠情况下，若用户光标选区进入，则无法看到鼠标聚焦区域，所以需要自动展开
     */
    // TODO: 这里的 query 会在每次 select 时消耗一次 O(N) 的查询性能，后续考虑在 DOM 上做一次 O(h) 的查询来优化

    if (trigger !== SUBJECT_NORMALIZE && _everCangjie.Block.isBlock(block) && !(0, _utils.isSubjectHeading)(block)) {
      let subject = controller.query(_queries.getSubjectStartBlock, block); // 注入 Injection 数据

      if (inject && subject) {
        subject = _everCangjie.Injection.injectIntoNode(injections, subject);
      } // 若议题节点折叠则展开


      if (subject && controller.userData.get(subject, 'fold')) {
        controller.run('onAction', (0, _everUtils.toggleFold)({
          node: subject,
          fold: false
        }));
      }
    }
    /**
     * Effects 2: 若选区跨越议题范围，则需要扩展选区范围至整个议题
     * @description 此处需求源于产品设计，议题标题不能被随意删除，由于标题的特例处理比较困难，因此我们通过扩展选区的方法使得用户
     * 会选择整个议题，这样使得用户在操作时能有明显的预期
     */


    const start = selection.getStart(document);
    const end = selection.getEnd(document);
    const startBlock = document.getFurthsestBlock(start.key);
    const endBlock = document.getFurthsestBlock(end.key); // 若光标的起始和结束不在同一个 Block 上

    if (trigger !== SUBJECT_NORMALIZE && startBlock && endBlock && startBlock !== endBlock) {
      let sel = selection;
      const startSubjectBlock = controller.query(_queries.getSubjectStartBlock, startBlock);
      const endSubjectBlock = controller.query(_queries.getSubjectStartBlock, endBlock); // 若光标的起始和结束不在同一个议题组内，则需要扩展选区

      if (startSubjectBlock !== endSubjectBlock) {
        // start 移动至起始议题的开头
        if (startSubjectBlock && !start.isAtStartOfNode(startSubjectBlock)) {
          sel = sel.moveStartToStartOfNode(startSubjectBlock, controller);
        } // end 移动至结束议题的末尾


        if (endSubjectBlock) {
          const subjectEndBlock = controller.query(_queries.getSubjectEndBlock, endSubjectBlock);

          if (subjectEndBlock && !end.isAtEndOfNode(subjectEndBlock)) {
            sel = sel.moveEndToEndOfNode(subjectEndBlock, controller);
          }
        }
      } // 若光标发生了变化，则更新


      if (sel !== selection) {
        return controller.run('onCangjieSelect', (0, _everCangjie.CangjieSelectEvent)({
          selection: sel,
          trigger: SUBJECT_NORMALIZE
        }));
      }
    }

    return next();
  };
}

var _default = createOnCangjieSelect;
exports.default = _default;
//# sourceMappingURL=createOnCangjieSelect.js.map