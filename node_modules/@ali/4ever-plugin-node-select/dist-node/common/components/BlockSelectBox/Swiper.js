"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Swiper = void 0;

var _constants = require("./constants");

function getStartAndCurrentTouch(changedTouches, touches) {
  const {
    length
  } = changedTouches;

  for (let i = 0; i < length; i++) {
    const {
      identifier
    } = changedTouches[i];

    for (let j = 0; j < touches.length; j++) {
      if (touches.item(j)?.identifier === identifier) {
        return {
          start: touches.item(j),
          current: changedTouches.item(i)
        };
      }
    }
  }

  return {};
} // 子元素是否在水平滚动


function isScrollingHorizontally(elem, scrollRight, root = document.body) {
  const scrollableContainer = elem.closest('[data-plugin-scrollable]');

  if (scrollableContainer && root.contains(scrollableContainer)) {
    const {
      scrollLeft,
      scrollWidth,
      clientWidth
    } = scrollableContainer;
    const isScrolling = !scrollRight ? scrollLeft + clientWidth < scrollWidth : scrollLeft > 0;

    if (isScrolling) {
      return true;
    }

    const {
      parentElement
    } = scrollableContainer;
    return parentElement ? isScrollingHorizontally(parentElement, scrollRight, root) : false;
  }

  return false;
}

class Swiper {
  constructor(getDomRef, handlers) {
    this.getDomRef = void 0;
    this.status = 'init';
    this.isPressingTimer = null;
    this.handlers = void 0;
    this.startTouches = null;
    this.enableClick = false;
    this.canScrollingHorizontally = undefined;
    this.initZIndex = '';

    this.setEnableClick = flag => {
      this.enableClick = flag;
    };

    this.onPress = touch => {
      this.status = 'isPressing';
      this.handlers.onPress?.(touch);
    };

    this.onSwipeEnd = () => {
      const dom = this.getDomRef();

      if (dom) {
        dom.style.transition = 'transform 0.2s';
        dom.style.transform = 'translateX(0)';
        dom.style.zIndex = this.initZIndex;
        this.initZIndex = '';
      }

      this.handlers.onSwipeEnd?.();
    };

    this.onTouchStart = e => {
      const {
        touches
      } = e;
      this.startTouches = touches;
      this.isPressingTimer = setTimeout(() => {
        this.onPress(touches[0]);
      }, _constants.PRESS_TIMEOUT);
      this.canScrollingHorizontally = undefined;
      this.status = 'init';
      const dom = this.getDomRef();
      this.initZIndex = dom ? getComputedStyle(dom).zIndex : '';
      document.body.addEventListener('touchmove', this.onTouchMove, {
        passive: false,
        capture: true
      });
      document.body.addEventListener('touchend', this.onTouchEnd, true);
      document.body.addEventListener('touchcancel', this.onTouchCancel, true);
    };

    this.onTouchMove = e => {
      if (!this.startTouches) {
        return;
      } // 处理阈值
      // 如果已经识别成长按或者垂直方向滚动，则后续的 swipe 不执行


      if (this.status === 'isPressing' || this.status === 'isScroll') {
        return;
      }

      const {
        changedTouches
      } = e;
      const dom = this.getDomRef();
      const {
        start,
        current
      } = getStartAndCurrentTouch(changedTouches, this.startTouches);

      if (start && current && dom && this.startTouches) {
        const swipeX = current.clientX - start.clientX;
        const swipeY = current.clientY - start.clientY; // 纵向滚动忽略不计

        if (Math.abs(swipeY) > Math.abs(swipeX) && this.status === 'init') {
          this.status = 'isScroll';
          this.isPressingTimer && clearTimeout(this.isPressingTimer);
          return;
        }

        if (Math.abs(swipeX) > _constants.SWIPE_THRESHOLD) {
          this.isPressingTimer && clearTimeout(this.isPressingTimer);
          this.canScrollingHorizontally = this.canScrollingHorizontally === undefined ? isScrollingHorizontally(current.target, swipeX > 0, dom) : this.canScrollingHorizontally;

          if (this.canScrollingHorizontally === false) {
            if (e.cancelable) {
              e.preventDefault();
            }

            e.stopPropagation();
            this.status = 'isSwiping'; // TODO @miaomiao! 阻尼感

            const realSwipeX = Math.min(Math.log2(Math.abs(swipeX)) * (swipeX > 0 ? 1 : -1) * 5, _constants.MAX_SWIPE_DISTANCE);
            dom.style.transform = `translateX(${realSwipeX}px)`;
            dom.style.zIndex = '1';
          }

          if (this.canScrollingHorizontally === true) {
            this.status = 'isScroll';
          }
        }
      }
    };

    this.reset = () => {
      this.status = 'init';
      this.startTouches = null;
      this.isPressingTimer && clearTimeout(this.isPressingTimer);
      document.body.removeEventListener('touchmove', this.onTouchMove);
      document.body.removeEventListener('touchcancel', this.onTouchCancel, true);
      document.body.removeEventListener('touchend', this.onTouchEnd, true);
    };

    this.onEnd = () => {
      if (this.status === 'isSwiping') {
        this.onSwipeEnd();
      }

      this.reset();
    };

    this.onTouchEnd = e => {
      if (this.enableClick && this.status === 'init' && this.handlers.onClick) {
        const touch = getStartAndCurrentTouch(e.changedTouches, this.startTouches);

        if (touch && touch.start?.target === touch.current?.target) {
          this.handlers.onClick();
        }
      }

      this.onEnd();
    };

    this.onTouchCancel = () => {
      this.onEnd();
    };

    this.getDomRef = getDomRef;
    this.handlers = handlers;
  }

}

exports.Swiper = Swiper;
//# sourceMappingURL=Swiper.js.map