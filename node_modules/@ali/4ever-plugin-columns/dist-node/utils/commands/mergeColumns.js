"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = mergeColumns;

var _everCangjie = require("@ali/4ever-cangjie");

var _everPluginTable = require("@ali/4ever-plugin-table");

var _everPluginParagraph = require("@ali/4ever-plugin-paragraph");

var _constants = require("../constants");

var _clearAloneTables = _interopRequireDefault(require("./clearAloneTables"));

const {
  Selector
} = _everCangjie.constants;

const isColumnsTable = n => {
  return _everPluginTable.Table.isTable(n) && Boolean(n.data.sr);
};

function afterMerge(node, controller) {
  const anchor = controller.query(_everCangjie.Queries.pointAtStartOfNode, node);

  const selection = _everCangjie.Selection.create({
    anchor,
    focus: anchor
  });

  controller.command(_everCangjie.Commands.select, selection).command(_everCangjie.Commands.focus);
  return (0, _clearAloneTables.default)(controller);
}
/**
 * 处理每一个 node，如果某一个 node 是 TableCell，就换成它的 children
 */


function flattenNodes(nodes) {
  const newNodes = nodes.reduce((arr, node) => {
    if (_everPluginTable.TableCell.isTableCell(node)) {
      return arr.concat(...node.nodes);
    }

    return arr.concat(node);
  }, []);
  return newNodes;
}

function mergeColumns(controller, params) {
  let {
    document
  } = controller.value;
  const {
    keys,
    targetKey,
    rowOffset,
    isCopy,
    isInline
  } = params; // 目标 Node

  const targetNode = document.getNode(targetKey);

  const docDomNode = _everCangjie.domUtils.findDOMNodeSafely(document.key);

  const nodes = keys.map(k => document.getNode(k));

  if (!nodes.length) {
    const newParagraph = _everPluginParagraph.Paragraph.create({
      nodes: [_everCangjie.Text.create()]
    });

    const {
      key: focusKey
    } = controller.value.selection.focus;
    const path = document.getPath(focusKey);

    if (!path || !path.length) {
      return controller;
    }

    nodes.push(newParagraph);
    controller.withoutNormalizing(() => {
      controller.command(_everCangjie.Commands.insertNodeByKey, document.key, path[0], newParagraph);
    });
    ({
      document
    } = controller.value);
  }

  if (!docDomNode || !targetNode || nodes.some(n => !n)) {
    return controller;
  } // 文档的宽度


  const {
    width: parentWidth
  } = docDomNode.getBoundingClientRect();
  let parentTable = null;

  if (isColumnsTable(targetNode)) {
    parentTable = targetNode;
  } else {
    parentTable = document.getClosest(targetKey, isColumnsTable);
  } // 体验优化：如果拖动某个单元格（分栏）里面的元素，添加新的分栏，就优先把背景色也带着


  const firstNodeParentCell = nodes[0] && document.getParent(nodes[0].key);
  const srcColor = _everPluginTable.TableCell.isTableCell(firstNodeParentCell) && firstNodeParentCell.data.fill; // case 1，没有 parentTable。需要创建一个新的 table

  if (!parentTable) {
    let defaultCellData = {
      vAlign: _constants.DEAFULT_VALIGN
    };

    if (srcColor) {
      defaultCellData = { ...defaultCellData,
        fill: srcColor
      };
    }

    const targetCell = _everPluginTable.TableCell.create({
      nodes: [],
      data: { ...defaultCellData
      }
    });

    const firstNode = !isInline ? nodes[0] : _everPluginParagraph.Paragraph.create({
      nodes: [_everCangjie.Inline.fromJSON(nodes[0].toJSON())]
    });
    const newData = _everPluginTable.TableCell.isTableCell(firstNode) ? { ...firstNode.data
    } : { ...defaultCellData
    };

    const newCell = _everPluginTable.TableCell.create({
      nodes: [],
      data: newData
    });

    const newCells = [targetCell];

    if (rowOffset === 0) {
      newCells.unshift(newCell);
    } else {
      newCells.push(newCell);
    }

    const tableRow = _everPluginTable.TableRow.create({
      nodes: newCells
    });

    const colsWidth = [parentWidth / 2, parentWidth / 2];

    const table = _everPluginTable.Table.create({
      nodes: [tableRow],
      data: {
        sr: true,
        colsWidth
      }
    });

    const targetParent = document.getParent(targetKey);
    const nodeIndex = targetParent.nodes.indexOf(targetNode);
    const srcNodes = flattenNodes(nodes);
    const firstSrcNode = !isInline ? srcNodes[0] : firstNode;
    controller.withoutNormalizing(() => {
      // 1. insert the table
      controller.command(_everCangjie.Commands.insertNodeByKey, targetParent.key, nodeIndex, table) // 2. wrap node into the target cell
      .command(_everCangjie.Commands.moveNodeByKey, targetNode.key, targetCell.key, 0);
      const newCellPath = controller.value.document.getPath(newCell.key); // 3. insert nodes info the new cell

      if (!isInline) {
        srcNodes.reverse().forEach(({
          key
        }) => {
          const path = controller.value.document.getPath(key);
          controller.command(_everCangjie.Commands.moveNodeByPath, path, newCellPath, 0);
        });
      } else {
        controller.command(_everCangjie.Commands.insertNodeByPath, newCellPath, 0, firstSrcNode);
      } // 4. clean up table cells


      nodes.forEach(n => {
        if (_everPluginTable.TableCell.isTableCell(n) || isInline) {
          const node = controller.value.document.getNode(n.key);

          if (node) {
            controller.command(_everCangjie.Commands.removeNodeByKey, node.key);
          }
        }
      });
    });
    return afterMerge(firstSrcNode, controller);
  } // case 2，已经有 parentTable 了。需要增加一个 Cell


  const parentRow = parentTable.nodes[0];
  const parentCell = _everPluginTable.TableCell.isTableCell(targetNode) ? targetNode : document.getClosest(targetKey, n => _everPluginTable.TableCell.isTableCell(n));
  let index = 0;

  if (parentCell) {
    // @ts-ignore
    index = parentRow.nodes.indexOf(parentCell);
  }

  if (parentTable === targetNode && rowOffset) {
    index = parentRow.nodes.length - 1;
  }

  index += rowOffset;
  index = Math.max(0, Math.min(index, parentRow.nodes.length));
  const cellCount = parentRow.nodes.length;
  const widths = parentTable.data.colsWidth?.slice(0, cellCount) || new Array(cellCount).fill(parentWidth / cellCount);
  let colsWidth = [...widths];
  const totalWidth = colsWidth.reduce((a, c) => a + c, 0);
  colsWidth.splice(index, 0, totalWidth / cellCount); // 当前的列调整。这里需要移除之前的 colWidth

  if (!isCopy && _everPluginTable.TableCell.isTableCell(nodes[0]) && // @ts-ignore
  parentRow.nodes.indexOf(nodes[0]) >= 0) {
    // @ts-ignore
    const fromIndex = parentRow.nodes.indexOf(nodes[0]);
    colsWidth = [...widths]; // TO-DO： 1 -> 2.3 时候，有问题

    const old = colsWidth.splice(fromIndex, 1)[0];
    colsWidth.splice(index - rowOffset, 0, old);
  }

  const colors = [srcColor, parentRow.nodes[index - 1]?.data?.fill, parentRow.nodes[index]?.data?.fill].map(c => c === 'transparent' ? undefined : c);
  const fill = colors[0] || colors[1] || colors[2];
  const firstNode = !isInline ? nodes[0] : _everPluginParagraph.Paragraph.create({
    nodes: [_everCangjie.Inline.fromJSON(nodes[0].toJSON())]
  });
  const newData = _everPluginTable.TableCell.isTableCell(firstNode) ? { ...firstNode.data
  } : {
    vAlign: _constants.DEAFULT_VALIGN,
    fill
  };

  const newCell = _everPluginTable.TableCell.create({
    nodes: [],
    data: newData
  });

  const srcNodes = flattenNodes(nodes);
  const parentTablePath = document.getPath(parentTable.key);
  const firstSrcNode = !isInline ? srcNodes[0] : firstNode;
  controller.withoutNormalizing(() => {
    // 1. insert the new cell
    controller.command(_everCangjie.Commands.insertNodeByKey, parentRow.key, index, newCell); // 2. set the table data colswith

    controller.command(_everCangjie.Commands.setNodeByPath, parentTablePath, {
      data: { ...parentTable.data,
        colsWidth: [...colsWidth]
      }
    }); // 3. insert nodes into the new cell

    const newCellPath = controller.value.document.getPath(newCell.key);

    if (!isInline) {
      srcNodes.reverse().forEach(({
        key
      }) => {
        const path = controller.value.document.getPath(key);
        controller.command(_everCangjie.Commands.moveNodeByPath, path, newCellPath, 0);
      });
    } else {
      controller.command(_everCangjie.Commands.insertNodeByPath, newCellPath, 0, firstSrcNode);
    } // 4. clean up table cells


    nodes.forEach(n => {
      if (_everPluginTable.TableCell.isTableCell(n) || isInline) {
        const node = controller.value.document.getNode(n.key);

        if (node) {
          controller.command(_everCangjie.Commands.removeNodeByKey, node.key);
        }
      }
    });
  });
  return afterMerge(firstSrcNode, controller);
}
//# sourceMappingURL=mergeColumns.js.map