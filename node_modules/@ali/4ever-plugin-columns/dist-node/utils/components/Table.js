"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = TableView;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var React = _interopRequireWildcard(require("react"));

var _styledComponents = _interopRequireDefault(require("styled-components"));

var _everCangjie = require("@ali/4ever-cangjie");

var _everPluginTable = require("@ali/4ever-plugin-table");

var _ColumnsProvider = require("../utils/ColumnsProvider");

var _useWidth = _interopRequireDefault(require("../utils/useWidth"));

var _constants = require("../constants");

var _actions = require("../actions");

var _useIpadActiveIndex = require("../utils/useIpadActiveIndex");

const _createElement = /*#__PURE__*/React.createElement;
const {
  IS_MOBILE,
  IS_IPAD
} = _everCangjie.environment;
const IS_PC_OR_IPAD = !IS_MOBILE || IS_IPAD;

const Wrapper = /*#__PURE__*/_styledComponents.default.div(["display:flex;align-items:stretch;flex-direction:row;position:relative;touch-action:pan-y pinch-zoom;", ""], IS_MOBILE && !IS_IPAD && `
      @media (max-width: 500px) {
        flex-direction: column;
      }
    `);

function writeToData(items, controller) {
  const {
    document
  } = controller.value;
  const table = document.getClosest(items[0].key, _everPluginTable.Table.isTable);

  if (!table) {
    return;
  }

  controller.command(_everCangjie.Commands.setNodeByKey, table.key, {
    data: { ...table.data,
      colsWidth: items.map(i => i.width)
    }
  });
}

const isFocused = (controller, table) => {
  const {
    selection
  } = controller.value;
  const {
    key: focusKey
  } = selection.focus;
  return focusKey === table.key || table.hasNode(focusKey);
};

function TableView({
  table,
  controller,
  TopBar,
  configs,
  onDragChange,
  children,
  attributes
}) {
  const ref = React.useRef(null);
  const parentRect = React.useRef();
  const isDragging = React.useRef();
  const [, forceRender] = React.useReducer(s => s + 1, 0);
  const [alignKey, setAlignKey] = React.useState('');
  /**
   * iPad 交互
   * 1. 分栏中间的点 常显
   * 2. 分栏中间的插入按钮和拖拽杆，点击后一起显示
   */

  const [activeIndex, setActiveIndex] = React.useState(-1);
  const stateCellsRef = React.useRef();
  const refWidth = (0, _useWidth.default)(ref);
  const propsCells = React.useMemo(() => {
    const colsWidth = table.data.colsWidth || [];
    const row = table.nodes[0];

    if (!_everPluginTable.TableRow.isTableRow(row)) {
      return [];
    }

    return row.nodes.reduce((ws, cell, index) => {
      const width = colsWidth[index] || 100;
      ws.push({
        key: cell.key,
        width
      });
      return ws;
    }, []);
  }, [table, refWidth]);
  const [isHover, setIsHover] = React.useState(false);
  const hasFocus = isFocused(controller, table);
  const handleDraggingChange = React.useCallback(dragging => {
    isDragging.current = dragging;
    onDragChange && onDragChange(dragging, controller);

    if (dragging) {
      parentRect.current = ref.current?.getBoundingClientRect();
      controller.command(_everCangjie.Commands.moveToFocus).command(_everCangjie.Commands.blur);
    } else if (stateCellsRef.current) {
      writeToData(stateCellsRef.current, controller);
      controller.command(_everCangjie.Commands.focus);
    }

    setAlignKey('');
    forceRender();
  }, [controller, onDragChange]);
  React.useEffect(() => {
    const row = table.nodes[0];

    if (!_everPluginTable.TableRow.isTableRow(row)) {
      return;
    }

    if (row && row.nodes.length <= 0) {
      controller.run('onAction', (0, _actions.cleanUpColumns)());
    }
  }, [controller, table]);
  React.useEffect(() => {
    if (!ref.current) {
      return;
    }

    parentRect.current = ref.current?.getBoundingClientRect();
    const totalWidth = parentRect.current.width - (propsCells.length - 1) * _constants.COLUMN_SPACE;
    stateCellsRef.current = (0, _ColumnsProvider.correctWidths)(propsCells, totalWidth);
    forceRender();
  }, [propsCells]);
  const handleDragging = React.useCallback((cellKey, clientX) => {
    if (!parentRect.current || !stateCellsRef.current) {
      return;
    }

    const offsetX = Math.round(clientX - parentRect.current.left - _constants.CURSOR_SIZE);
    const items = stateCellsRef.current;
    const totalWidth = parentRect.current.width - (items.length - 1) * _constants.COLUMN_SPACE;
    const {
      items: newItems,
      isAligned
    } = (0, _ColumnsProvider.moveWidths)({
      offsetX,
      key: cellKey,
      items,
      totalWidth,
      rectWidth: parentRect.current.width
    });
    stateCellsRef.current = newItems;
    setAlignKey(isAligned ? cellKey : '');
    forceRender();
  }, []);
  const dragging = isDragging.current || false;
  const cells = dragging ? stateCellsRef.current : propsCells;
  const providerConfigs = React.useMemo(() => {
    return {
      cells: cells,
      alignKey,
      isDragging: dragging,
      handleDragging,
      handleDraggingChange
    };
  }, [cells, handleDragging, handleDraggingChange, dragging, alignKey]);
  const renderTopBar = Boolean((isHover || hasFocus || IS_IPAD) && !controller.readOnly && IS_PC_OR_IPAD && !dragging);
  const handleMouseEnter = React.useCallback(() => {
    setIsHover(true);
  }, [setIsHover]);
  const handleMousseLeave = React.useCallback(() => {
    setIsHover(false);
  }, [setIsHover]);

  if (!cells?.length) {
    return null;
  }

  return /*#__PURE__*/_createElement(Wrapper, (0, _extends2.default)({}, attributes, {
    "data-columns": true,
    "data-columns-key": table.key,
    "data-cangjie-key": table.key,
    ref: ref,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMousseLeave
  }), /*#__PURE__*/_createElement(_useIpadActiveIndex.IpadActiveBarProvider, {
    value: [activeIndex, setActiveIndex]
  }, renderTopBar && !!TopBar && /*#__PURE__*/_createElement(TopBar, {
    items: cells,
    configs: configs
  }), /*#__PURE__*/_createElement(_ColumnsProvider.ColumnsProvider, {
    value: providerConfigs
  }, children)));
}
//# sourceMappingURL=Table.js.map