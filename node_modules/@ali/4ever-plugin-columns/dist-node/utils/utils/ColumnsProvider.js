"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.correctWidths = correctWidths;
exports.moveWidths = moveWidths;
exports.useCellConfigs = exports.ColumnsProvider = void 0;

var React = _interopRequireWildcard(require("react"));

var _constants = require("../constants");

const context = /*#__PURE__*/React.createContext({
  cells: [],
  alignKey: '',
  isDragging: false,
  handleDragging: () => {},
  handleDraggingChange: () => {}
});
const ColumnsProvider = context.Provider;
exports.ColumnsProvider = ColumnsProvider;

const useCellConfigs = key => {
  const {
    cells,
    alignKey,
    handleDragging,
    handleDraggingChange,
    isDragging
  } = React.useContext(context);
  const index = cells.findIndex(w => w.key === key);
  const item = cells[index];

  if (!item) {
    return null;
  }

  const width = item?.width || 1;
  const totalWidth = cells.reduce((a, w) => a + w.width, 0);
  const percent = width / totalWidth;
  return {
    index,
    isDragging,
    dragBarAligned: alignKey === key,
    percentAligned: _constants.DEFAULT_SPLIT.some(p => Math.abs(totalWidth * p - width) <= 2),
    percent,
    count: cells.length,
    handleDragging,
    handleDraggingChange
  };
};

exports.useCellConfigs = useCellConfigs;

function correctWidths(items, totalWidth) {
  const currentTotal = items.reduce((t, i) => t + i.width, 0);
  const x = totalWidth / currentTotal;
  return items.map(i => ({ ...i,
    width: i.width * x
  }));
}

function moveWidths(params) {
  const {
    offsetX,
    key,
    items,
    totalWidth,
    rectWidth,
    prefPercents = _constants.DEFAULT_SPLIT
  } = params;
  let index = items.findIndex(i => i.key === key);

  if (!items[index]) {
    return {
      items
    };
  } // 前面 index 个，后面 length - index 个
  // 左边界：index * (w + COLUMN_SPACE) - COLUMN_SPACE / 2


  if (offsetX < index * (_constants.MIN_WIDTH + _constants.COLUMN_SPACE) - _constants.COLUMN_SPACE / 2) {
    return {
      items
    };
  } // 右边界长度：[index, items.length) * (w + COLUMN_SPACE) - COLUMN_SPACE / 2


  if (offsetX > rectWidth - (items.length - index) * (_constants.MIN_WIDTH + _constants.COLUMN_SPACE) + _constants.COLUMN_SPACE / 2) {
    return {
      items
    };
  } // 这里可以移动了，移动后，不会导致其他的问题。


  const currentItemOffset = items.reduce((t, item, i) => i >= index - 1 ? t : t + item.width + _constants.COLUMN_SPACE, 0);
  const prefOffsets = prefPercents.map(p => Math.round(currentItemOffset + p * totalWidth + _constants.COLUMN_SPACE / 2)); // [0 - index) * (w + COLUMN_SPACE) - COLUMN_SPACE / 2

  const currentOffset = Math.round(items.reduce((t, item, i) => i >= index ? t : t + item.width + _constants.COLUMN_SPACE, 0) - _constants.COLUMN_SPACE / 2);
  const adjustedOffsetX = prefOffsets.find(o => Math.abs(o - offsetX) < _constants.STICK_WIDTH) || offsetX;
  const isAligned = adjustedOffsetX !== offsetX;
  let offset = Math.round(adjustedOffsetX - currentOffset);

  if (Math.abs(offset) < 1) {
    return {
      items,
      isAligned
    };
  }

  const newItems = [...items]; // 向右侧移动

  if (offset >= 1) {
    const prevItem = newItems[index - 1];

    if (prevItem) {
      newItems[index - 1] = { ...prevItem
      };
      newItems[index - 1].width += offset;
    }

    while (offset >= 1 && newItems[index]) {
      // 尝试缩小当前的宽度
      const item = newItems[index];
      const newWidth = Math.max(item.width - offset, _constants.MIN_WIDTH);
      const moved = item.width - newWidth;
      newItems[index] = { ...item
      };
      newItems[index].width = newWidth;
      index += 1;
      offset -= moved;
    }
  } // 向左侧移动


  if (offset <= -1) {
    newItems[index].width -= offset;
    index -= 1;

    while (offset <= -1 && newItems[index]) {
      // 尝试缩小当前的宽度
      const item = newItems[index];
      const newWidth = Math.max(item.width + offset, _constants.MIN_WIDTH);
      const moved = item.width - newWidth;
      newItems[index] = { ...item
      };
      newItems[index].width = newWidth;
      index -= 1;
      offset += moved;
    }
  }

  return {
    items: newItems,
    isAligned
  };
}
//# sourceMappingURL=ColumnsProvider.js.map