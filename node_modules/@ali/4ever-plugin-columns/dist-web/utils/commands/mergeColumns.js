import _extends from "@babel/runtime/helpers/extends";
import { Commands, Text, Selection, Queries, Inline, domUtils, constants } from '@ali/4ever-cangjie';
import { Table, TableRow, TableCell } from '@ali/4ever-plugin-table';
import { Paragraph } from '@ali/4ever-plugin-paragraph';
import { DEAFULT_VALIGN } from "../constants";
import clearAloneTables from "./clearAloneTables";
var Selector = constants.Selector;

var isColumnsTable = function isColumnsTable(n) {
  return Table.isTable(n) && Boolean(n.data.sr);
};

function afterMerge(node, controller) {
  var anchor = controller.query(Queries.pointAtStartOfNode, node);
  var selection = Selection.create({
    anchor: anchor,
    focus: anchor
  });
  controller.command(Commands.select, selection).command(Commands.focus);
  return clearAloneTables(controller);
}
/**
 * 处理每一个 node，如果某一个 node 是 TableCell，就换成它的 children
 */


function flattenNodes(nodes) {
  var newNodes = nodes.reduce(function (arr, node) {
    if (TableCell.isTableCell(node)) {
      return arr.concat.apply(arr, node.nodes);
    }

    return arr.concat(node);
  }, []);
  return newNodes;
}

export default function mergeColumns(controller, params) {
  var _parentTable$data$col, _parentRow$nodes, _parentRow$nodes$data, _parentRow$nodes$inde, _parentRow$nodes$inde2;

  var document = controller.value.document;
  var keys = params.keys,
      targetKey = params.targetKey,
      rowOffset = params.rowOffset,
      isCopy = params.isCopy,
      isInline = params.isInline; // 目标 Node

  var targetNode = document.getNode(targetKey);
  var docDomNode = domUtils.findDOMNodeSafely(document.key);
  var nodes = keys.map(function (k) {
    return document.getNode(k);
  });

  if (!nodes.length) {
    var newParagraph = Paragraph.create({
      nodes: [Text.create()]
    });
    var focusKey = controller.value.selection.focus.key;
    var path = document.getPath(focusKey);

    if (!path || !path.length) {
      return controller;
    }

    nodes.push(newParagraph);
    controller.withoutNormalizing(function () {
      controller.command(Commands.insertNodeByKey, document.key, path[0], newParagraph);
    });
    document = controller.value.document;
  }

  if (!docDomNode || !targetNode || nodes.some(function (n) {
    return !n;
  })) {
    return controller;
  } // 文档的宽度


  var _docDomNode$getBoundi = docDomNode.getBoundingClientRect(),
      parentWidth = _docDomNode$getBoundi.width;

  var parentTable = null;

  if (isColumnsTable(targetNode)) {
    parentTable = targetNode;
  } else {
    parentTable = document.getClosest(targetKey, isColumnsTable);
  } // 体验优化：如果拖动某个单元格（分栏）里面的元素，添加新的分栏，就优先把背景色也带着


  var firstNodeParentCell = nodes[0] && document.getParent(nodes[0].key);
  var srcColor = TableCell.isTableCell(firstNodeParentCell) && firstNodeParentCell.data.fill; // case 1，没有 parentTable。需要创建一个新的 table

  if (!parentTable) {
    var defaultCellData = {
      vAlign: DEAFULT_VALIGN
    };

    if (srcColor) {
      defaultCellData = _extends({}, defaultCellData, {
        fill: srcColor
      });
    }

    var targetCell = TableCell.create({
      nodes: [],
      data: _extends({}, defaultCellData)
    });

    var _firstNode = !isInline ? nodes[0] : Paragraph.create({
      nodes: [Inline.fromJSON(nodes[0].toJSON())]
    });

    var _newData = TableCell.isTableCell(_firstNode) ? _extends({}, _firstNode.data) : _extends({}, defaultCellData);

    var _newCell = TableCell.create({
      nodes: [],
      data: _newData
    });

    var newCells = [targetCell];

    if (rowOffset === 0) {
      newCells.unshift(_newCell);
    } else {
      newCells.push(_newCell);
    }

    var tableRow = TableRow.create({
      nodes: newCells
    });
    var _colsWidth = [parentWidth / 2, parentWidth / 2];
    var table = Table.create({
      nodes: [tableRow],
      data: {
        sr: true,
        colsWidth: _colsWidth
      }
    });
    var targetParent = document.getParent(targetKey);
    var nodeIndex = targetParent.nodes.indexOf(targetNode);

    var _srcNodes = flattenNodes(nodes);

    var _firstSrcNode = !isInline ? _srcNodes[0] : _firstNode;

    controller.withoutNormalizing(function () {
      // 1. insert the table
      controller.command(Commands.insertNodeByKey, targetParent.key, nodeIndex, table) // 2. wrap node into the target cell
      .command(Commands.moveNodeByKey, targetNode.key, targetCell.key, 0);
      var newCellPath = controller.value.document.getPath(_newCell.key); // 3. insert nodes info the new cell

      if (!isInline) {
        _srcNodes.reverse().forEach(function (_ref) {
          var key = _ref.key;
          var path = controller.value.document.getPath(key);
          controller.command(Commands.moveNodeByPath, path, newCellPath, 0);
        });
      } else {
        controller.command(Commands.insertNodeByPath, newCellPath, 0, _firstSrcNode);
      } // 4. clean up table cells


      nodes.forEach(function (n) {
        if (TableCell.isTableCell(n) || isInline) {
          var node = controller.value.document.getNode(n.key);

          if (node) {
            controller.command(Commands.removeNodeByKey, node.key);
          }
        }
      });
    });
    return afterMerge(_firstSrcNode, controller);
  } // case 2，已经有 parentTable 了。需要增加一个 Cell


  var parentRow = parentTable.nodes[0];
  var parentCell = TableCell.isTableCell(targetNode) ? targetNode : document.getClosest(targetKey, function (n) {
    return TableCell.isTableCell(n);
  });
  var index = 0;

  if (parentCell) {
    // @ts-ignore
    index = parentRow.nodes.indexOf(parentCell);
  }

  if (parentTable === targetNode && rowOffset) {
    index = parentRow.nodes.length - 1;
  }

  index += rowOffset;
  index = Math.max(0, Math.min(index, parentRow.nodes.length));
  var cellCount = parentRow.nodes.length;
  var widths = ((_parentTable$data$col = parentTable.data.colsWidth) == null ? void 0 : _parentTable$data$col.slice(0, cellCount)) || new Array(cellCount).fill(parentWidth / cellCount);
  var colsWidth = [].concat(widths);
  var totalWidth = colsWidth.reduce(function (a, c) {
    return a + c;
  }, 0);
  colsWidth.splice(index, 0, totalWidth / cellCount); // 当前的列调整。这里需要移除之前的 colWidth

  if (!isCopy && TableCell.isTableCell(nodes[0]) && // @ts-ignore
  parentRow.nodes.indexOf(nodes[0]) >= 0) {
    // @ts-ignore
    var fromIndex = parentRow.nodes.indexOf(nodes[0]);
    colsWidth = [].concat(widths); // TO-DO： 1 -> 2.3 时候，有问题

    var old = colsWidth.splice(fromIndex, 1)[0];
    colsWidth.splice(index - rowOffset, 0, old);
  }

  var colors = [srcColor, (_parentRow$nodes = parentRow.nodes[index - 1]) == null ? void 0 : (_parentRow$nodes$data = _parentRow$nodes.data) == null ? void 0 : _parentRow$nodes$data.fill, (_parentRow$nodes$inde = parentRow.nodes[index]) == null ? void 0 : (_parentRow$nodes$inde2 = _parentRow$nodes$inde.data) == null ? void 0 : _parentRow$nodes$inde2.fill].map(function (c) {
    return c === 'transparent' ? undefined : c;
  });
  var fill = colors[0] || colors[1] || colors[2];
  var firstNode = !isInline ? nodes[0] : Paragraph.create({
    nodes: [Inline.fromJSON(nodes[0].toJSON())]
  });
  var newData = TableCell.isTableCell(firstNode) ? _extends({}, firstNode.data) : {
    vAlign: DEAFULT_VALIGN,
    fill: fill
  };
  var newCell = TableCell.create({
    nodes: [],
    data: newData
  });
  var srcNodes = flattenNodes(nodes);
  var parentTablePath = document.getPath(parentTable.key);
  var firstSrcNode = !isInline ? srcNodes[0] : firstNode;
  controller.withoutNormalizing(function () {
    // 1. insert the new cell
    controller.command(Commands.insertNodeByKey, parentRow.key, index, newCell); // 2. set the table data colswith

    controller.command(Commands.setNodeByPath, parentTablePath, {
      data: _extends({}, parentTable.data, {
        colsWidth: [].concat(colsWidth)
      })
    }); // 3. insert nodes into the new cell

    var newCellPath = controller.value.document.getPath(newCell.key);

    if (!isInline) {
      srcNodes.reverse().forEach(function (_ref2) {
        var key = _ref2.key;
        var path = controller.value.document.getPath(key);
        controller.command(Commands.moveNodeByPath, path, newCellPath, 0);
      });
    } else {
      controller.command(Commands.insertNodeByPath, newCellPath, 0, firstSrcNode);
    } // 4. clean up table cells


    nodes.forEach(function (n) {
      if (TableCell.isTableCell(n) || isInline) {
        var node = controller.value.document.getNode(n.key);

        if (node) {
          controller.command(Commands.removeNodeByKey, node.key);
        }
      }
    });
  });
  return afterMerge(firstSrcNode, controller);
}
//# sourceMappingURL=mergeColumns.js.map