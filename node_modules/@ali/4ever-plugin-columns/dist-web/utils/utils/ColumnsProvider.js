import _extends from "@babel/runtime/helpers/extends";
import * as React from 'react';
import { COLUMN_SPACE, DEFAULT_SPLIT, MIN_WIDTH, STICK_WIDTH } from "../constants";
var context = /*#__PURE__*/React.createContext({
  cells: [],
  alignKey: '',
  isDragging: false,
  handleDragging: function handleDragging() {},
  handleDraggingChange: function handleDraggingChange() {}
});
export var ColumnsProvider = context.Provider;
export var useCellConfigs = function useCellConfigs(key) {
  var _React$useContext = React.useContext(context),
      cells = _React$useContext.cells,
      alignKey = _React$useContext.alignKey,
      handleDragging = _React$useContext.handleDragging,
      handleDraggingChange = _React$useContext.handleDraggingChange,
      isDragging = _React$useContext.isDragging;

  var index = cells.findIndex(function (w) {
    return w.key === key;
  });
  var item = cells[index];

  if (!item) {
    return null;
  }

  var width = (item == null ? void 0 : item.width) || 1;
  var totalWidth = cells.reduce(function (a, w) {
    return a + w.width;
  }, 0);
  var percent = width / totalWidth;
  return {
    index: index,
    isDragging: isDragging,
    dragBarAligned: alignKey === key,
    percentAligned: DEFAULT_SPLIT.some(function (p) {
      return Math.abs(totalWidth * p - width) <= 2;
    }),
    percent: percent,
    count: cells.length,
    handleDragging: handleDragging,
    handleDraggingChange: handleDraggingChange
  };
};
export function correctWidths(items, totalWidth) {
  var currentTotal = items.reduce(function (t, i) {
    return t + i.width;
  }, 0);
  var x = totalWidth / currentTotal;
  return items.map(function (i) {
    return _extends({}, i, {
      width: i.width * x
    });
  });
}
export function moveWidths(params) {
  var offsetX = params.offsetX,
      key = params.key,
      items = params.items,
      totalWidth = params.totalWidth,
      rectWidth = params.rectWidth,
      _params$prefPercents = params.prefPercents,
      prefPercents = _params$prefPercents === void 0 ? DEFAULT_SPLIT : _params$prefPercents;
  var index = items.findIndex(function (i) {
    return i.key === key;
  });

  if (!items[index]) {
    return {
      items: items
    };
  } // 前面 index 个，后面 length - index 个
  // 左边界：index * (w + COLUMN_SPACE) - COLUMN_SPACE / 2


  if (offsetX < index * (MIN_WIDTH + COLUMN_SPACE) - COLUMN_SPACE / 2) {
    return {
      items: items
    };
  } // 右边界长度：[index, items.length) * (w + COLUMN_SPACE) - COLUMN_SPACE / 2


  if (offsetX > rectWidth - (items.length - index) * (MIN_WIDTH + COLUMN_SPACE) + COLUMN_SPACE / 2) {
    return {
      items: items
    };
  } // 这里可以移动了，移动后，不会导致其他的问题。


  var currentItemOffset = items.reduce(function (t, item, i) {
    return i >= index - 1 ? t : t + item.width + COLUMN_SPACE;
  }, 0);
  var prefOffsets = prefPercents.map(function (p) {
    return Math.round(currentItemOffset + p * totalWidth + COLUMN_SPACE / 2);
  }); // [0 - index) * (w + COLUMN_SPACE) - COLUMN_SPACE / 2

  var currentOffset = Math.round(items.reduce(function (t, item, i) {
    return i >= index ? t : t + item.width + COLUMN_SPACE;
  }, 0) - COLUMN_SPACE / 2);
  var adjustedOffsetX = prefOffsets.find(function (o) {
    return Math.abs(o - offsetX) < STICK_WIDTH;
  }) || offsetX;
  var isAligned = adjustedOffsetX !== offsetX;
  var offset = Math.round(adjustedOffsetX - currentOffset);

  if (Math.abs(offset) < 1) {
    return {
      items: items,
      isAligned: isAligned
    };
  }

  var newItems = [].concat(items); // 向右侧移动

  if (offset >= 1) {
    var prevItem = newItems[index - 1];

    if (prevItem) {
      newItems[index - 1] = _extends({}, prevItem);
      newItems[index - 1].width += offset;
    }

    while (offset >= 1 && newItems[index]) {
      // 尝试缩小当前的宽度
      var item = newItems[index];
      var newWidth = Math.max(item.width - offset, MIN_WIDTH);
      var moved = item.width - newWidth;
      newItems[index] = _extends({}, item);
      newItems[index].width = newWidth;
      index += 1;
      offset -= moved;
    }
  } // 向左侧移动


  if (offset <= -1) {
    newItems[index].width -= offset;
    index -= 1;

    while (offset <= -1 && newItems[index]) {
      // 尝试缩小当前的宽度
      var _item = newItems[index];

      var _newWidth = Math.max(_item.width + offset, MIN_WIDTH);

      var _moved = _item.width - _newWidth;

      newItems[index] = _extends({}, _item);
      newItems[index].width = _newWidth;
      index -= 1;
      offset += _moved;
    }
  }

  return {
    items: newItems,
    isAligned: isAligned
  };
}
//# sourceMappingURL=ColumnsProvider.js.map