{"version":3,"sources":["../../../../../src/mo/serializer/htmlToJsonML/parseFromWord.ts"],"names":["HR_WIDTH","WORD_HR_REG","parseFromWord","name","onOpenTag","state","attrs","push","test","style","class","borderBottom","msoBorderBottomAlt","borderTop","msoBorderTopAlt","borders","every","bor","includes","border","typeAndSz","split","filter","i","ordered","reverse","type","matchHr","hrLines","find","line","lineType","sz","size","color","width","onCloseTag","hr","pop","append","hrs"],"mappings":"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","sourcesContent":["import { camelCase } from 'lodash-es';\nimport { MoState as State, createEmptyText, toStyleObject, MoAttributes as Attributes, HTMLToJsonMLRule } from '@ali/4ever-cangjie';\nimport { hrLines } from '../../../utils/lineConfig';\n\nconst HR_WIDTH = '100%';\nconst WORD_HR_REG = /mso-border-(bottom|top)-alt/;\n\nfunction parseFromWord(): HTMLToJsonMLRule {\n  return {\n    name: 'hr',\n\n    onOpenTag(state: State, name: string, attrs: Attributes): boolean {\n      if (name === 'hr') {\n        state.push(['hr', createEmptyText()]);\n        return true;\n      }\n      if (!WORD_HR_REG.test(attrs.style || '') || attrs.class !== 'MsoNormal') {\n        return false;\n      }\n      const style = toStyleObject(attrs.style);\n      // @ts-ignore\n      const borderBottom = style.msoBorderBottomAlt || style.borderBottom;\n      // @ts-ignore\n      const borderTop = style.msoBorderTopAlt || style.borderTop;\n      const borders = [borderBottom, borderTop];\n      if (borders.every(bor => !bor || bor.includes('none'))) {\n        return false;\n      }\n\n      for (const border of borders) {\n        if (border) {\n          // eslint-disable-next-line prefer-const\n          const typeAndSz = border.split(' ').filter((i) => i !== 'windowtext');\n          const ordered = /^\\d+/.test(typeAndSz[0])\n            ? typeAndSz.reverse()\n            : typeAndSz;\n          let type = camelCase(ordered[0]);\n          const matchHr = hrLines.find((line) => line.lineType === type);\n          let sz = 1;\n          if (matchHr) {\n            sz = matchHr.size;\n          } else {\n            type = 'solid';\n          }\n          state.push([\n            'hr',\n            { type, sz, color: 'black', width: HR_WIDTH },\n            createEmptyText(),\n          ]);\n        }\n      }\n      return true;\n    },\n\n    onCloseTag(state: State, name: string, attrs: Attributes): boolean {\n      if (name === 'hr') {\n        const hr = state.pop();\n        state.append(hr);\n        return true;\n      }\n      if (!WORD_HR_REG.test(attrs.style || '') || attrs.class !== 'MsoNormal') {\n        return false;\n      }\n      const style = toStyleObject(attrs.style);\n      const hrs = [];\n      // @ts-ignore\n      const borderBottom = style.msoBorderBottomAlt || style.borderBottom;\n      // @ts-ignore\n      const borderTop = style.msoBorderTopAlt || style.borderTop;\n      const borders = [borderBottom, borderTop];\n      if (borders.every(bor => !bor || bor.includes('none'))) {\n        return false;\n      }\n      for (const border of borders) {\n        if (border) {\n          // @ts-ignore\n          hrs.push(state.pop());\n        }\n      }\n      state.append(...hrs.reverse());\n      return true;\n    },\n  };\n}\n\nexport default parseFromWord;\n"],"file":"parseFromWord.js"}