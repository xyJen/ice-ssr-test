"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findNextSz = findNextSz;

var _everUtils = require("@ali/4ever-utils");

var _szList = require("./szList");

const SZ_BIGGER_STEP = 10;

const SZ_MAP = _szList.szList.reduce((pre, cur, index) => {
  const tmp = { ...pre
  };
  tmp[cur] = index;
  return tmp;
}, {});

const {
  MAX,
  MIN
} = _everUtils.fontSize;
const SZ_LIST_MAX = _szList.szList[_szList.szList.length - 1];
const SZ_LIST_MIN = _szList.szList[0];

function findNextSz(target, direction) {
  let sz;

  if (target >= SZ_LIST_MAX) {
    // 超出右边界按step取整，和word一致
    if (direction === 'right') {
      sz = Math.floor((target + SZ_BIGGER_STEP) / SZ_BIGGER_STEP) * SZ_BIGGER_STEP;
      return Math.min(sz, MAX);
    } else if (target > SZ_LIST_MAX) {
      sz = Math.floor((target - SZ_BIGGER_STEP) / SZ_BIGGER_STEP) * SZ_BIGGER_STEP; // 确保能回到 SZ_LIST_MAX

      return Math.max(sz, SZ_LIST_MAX);
    }
  }

  if (target <= SZ_LIST_MIN) {
    // 超出左边界按1加减
    if (direction === 'left') {
      return Math.max(target - 1, MIN);
    } else if (target < SZ_LIST_MIN) {
      return Math.max(target + 1, MIN);
    }
  }

  let targetIndex = SZ_MAP[target];

  if (targetIndex === undefined) {
    // 找到最接近的字号
    let min = Infinity;

    for (let i = 0; i < _szList.szList.length; i++) {
      const newMin = Math.abs(target - _szList.szList[i]);

      if (newMin > min) {
        break;
      }

      targetIndex = i;
      min = newMin;
    }
  } // 默认最接近的字号


  sz = _szList.szList[targetIndex];

  if (direction === 'left' && sz >= target) {
    // next left
    sz = _szList.szList[targetIndex - 1];
  }

  if (direction === 'right' && sz <= target) {
    // next right
    sz = _szList.szList[targetIndex + 1];
  }

  return sz || target;
}
//# sourceMappingURL=findNextSz.js.map