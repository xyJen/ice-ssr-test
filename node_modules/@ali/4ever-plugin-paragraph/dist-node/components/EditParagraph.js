"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var React = _interopRequireWildcard(require("react"));

var _everCangjie = require("@ali/4ever-cangjie");

var _everUtils = require("@ali/4ever-utils");

var _styled = require("./styled");

/* eslint-disable import/no-extraneous-dependencies */
const _createElement = /*#__PURE__*/React.createElement;
const {
  BorderStyleEnum
} = _everCangjie.MoCommon;
const DEFAULT_BORDER_COLOR = '#000000';

class Paragraph extends React.Component {
  render() {
    const {
      Component,
      id,
      node,
      attributes,
      children,
      visible
    } = this.props; // TODO: HACK pi 和 bi 实现缩进机制不一致

    const isPi = !!node.data.pi;
    /* 段落对齐 */

    let alignType = node.data.jc || 'left';
    let textAlignLast;

    if (alignType === 'distribute') {
      alignType = 'justify';
      textAlignLast = 'justify';
    }

    const {
      color,
      spacing,
      shd
    } = node.data;

    const {
      left,
      firstLine = 0,
      right,
      hanging
    } = _everUtils.IndUtil.fromBlock(node);
    /* 列表 */


    const isList = !!node.data.list;
    let paddingLeft = left || 0;

    if (!isPi && hanging) {
      // 悬挂缩进时整体 paddingLeft 增加，靠 text-indent < 0 实现
      paddingLeft += hanging;
    }

    const nodeStyle = attributes?.style ?? {};
    const {
      paddingLeft: nodePaddingLeft = 0,
      paddingRight: nodePaddingRight = 0
    } = nodeStyle; // 缩进

    const style = { ...nodeStyle,
      textAlign: alignType,
      textIndent: isList || isPi ? 0 : hanging ? -hanging : firstLine,
      paddingLeft: isList ? 0 : paddingLeft + nodePaddingLeft,
      paddingRight: right || nodePaddingRight
    };

    if (spacing?.line) {
      style.lineHeight = _everUtils.SpacingUtil.getLineHeightFromSpacing(spacing);
    } // TODO: refactor


    if (textAlignLast) {
      style.textAlignLast = textAlignLast;
    }

    if (visible === false) {
      style.display = 'none';
    }

    if (isPi) {
      // 列表场景下清空上下边距，在列表处渲染，否则采用盒模型中的边距数据
      if (isList) {
        style.marginTop = 0;
        style.marginBottom = 0;
      } else {
        // pi-1.0 中也注入了 pi 信息，但是不全...
        const {
          margin = {}
        } = node.data.pi.box || {};
        const {
          top = 0,
          bottom = 0
        } = margin;
        style.marginTop = top;
        style.marginBottom = bottom;
      } // 排版下没有外部统一的 block div，这里特殊兼容下


      if (shd) {
        style.backgroundColor = _everUtils.ShdUtil.transformShd(shd);
      }
    } // 边框：目前的段落和列表结构不严谨，列表会包裹一层 DOM


    if (!isList) {
      const bdr = node.data.bdr || {};

      if (bdr.top) {
        const {
          val = BorderStyleEnum.Single,
          sz = 1,
          color: bdrColor = DEFAULT_BORDER_COLOR,
          space = 0
        } = bdr.top;
        const borderStyle = val === BorderStyleEnum.Single ? 'solid' : val;
        const borderColor = bdrColor === 'auto' ? DEFAULT_BORDER_COLOR : bdrColor;
        style.borderTop = `${sz}px ${borderStyle} ${borderColor}`;
        style.paddingTop = space;
      }

      if (bdr.bottom) {
        const {
          val = BorderStyleEnum.Single,
          sz = 1,
          color: bdrColor = DEFAULT_BORDER_COLOR,
          space = 0
        } = bdr.bottom;
        const borderStyle = val === BorderStyleEnum.Single ? 'solid' : val;
        const borderColor = bdrColor === 'auto' ? DEFAULT_BORDER_COLOR : bdrColor;
        style.borderBottom = `${sz}px ${borderStyle} ${borderColor}`;
        style.paddingBottom = space;
      }

      if (bdr.left) {
        const {
          val = BorderStyleEnum.Single,
          sz = 1,
          color: bdrColor = DEFAULT_BORDER_COLOR,
          space = 0
        } = bdr.left;
        const borderStyle = val === BorderStyleEnum.Single ? 'solid' : val;
        const borderColor = bdrColor === 'auto' ? DEFAULT_BORDER_COLOR : bdrColor;
        style.borderLeft = `${sz}px ${borderStyle} ${borderColor}`;
        style.paddingLeft = space + (isList ? 0 : paddingLeft);
      }

      if (bdr.right) {
        const {
          val = BorderStyleEnum.Single,
          sz = 1,
          color: bdrColor = DEFAULT_BORDER_COLOR,
          space = 0
        } = bdr.right;
        const borderStyle = val === BorderStyleEnum.Single ? 'solid' : val;
        const borderColor = bdrColor === 'auto' ? DEFAULT_BORDER_COLOR : bdrColor;
        style.borderRight = `${sz}px ${borderStyle} ${borderColor}`;
        style.paddingRight = space;
      }
    }

    if (color) {
      style.color = color;
    }

    return (
      /*#__PURE__*/
      // @ts-ignore
      _createElement(Component, (0, _extends2.default)({}, attributes, {
        "data-type": node.type,
        id: id,
        style: style
      }), children)
    );
  }

}

Paragraph.defaultProps = {
  Component: _styled.Component
};
var _default = Paragraph;
exports.default = _default;
//# sourceMappingURL=EditParagraph.js.map