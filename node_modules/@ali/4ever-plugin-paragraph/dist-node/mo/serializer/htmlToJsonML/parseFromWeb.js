"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parseHtml;

var _everUtils = require("@ali/4ever-utils");

var _everCangjie = require("@ali/4ever-cangjie");

var _models = _interopRequireDefault(require("../../models"));

var _getParagraphTagStyle = _interopRequireDefault(require("../utils/getParagraphTagStyle"));

const validAlign = {
  left: true,
  center: true,
  right: true,
  justify: true,
  distribute: true
};
const spacingAttrs = {
  marginTop: 'before',
  marginBottom: 'after'
};

function isValidAlign(align = '') {
  return !!validAlign[align];
}

function generateAttrsFromStyle(style) {
  const attrs = {};
  const ind = {};

  if (isValidAlign(style.textAlign)) {
    attrs.jc = style.textAlign;
  }

  if (attrs.jc === 'justify' && style.textAlignLast === 'justify') {
    attrs.jc = 'distribute';
  }

  if (style.textIndent) {
    const firstLine = _everUtils.unitsConverter.toPX(style.textIndent);

    if (firstLine) {
      ind.firstLine = firstLine;
    }
  }

  if (style.margin) {
    const margins = (0, _everUtils.parseCSSMargin)(style.margin);
    ind.left = _everUtils.unitsConverter.toPX(margins.marginLeft);
  }

  if (style.padding) {
    const paddings = (0, _everUtils.parseCSSMargin)(style.padding);
    ind.left = (ind.left ? ind.left : 0) + _everUtils.unitsConverter.toPX(paddings.marginLeft);
  }

  if (style.marginLeft && (0, _everUtils.isCSSAbsoluteLength)(style.marginLeft)) {
    const marginLeftNum = _everUtils.unitsConverter.toPX(style.marginLeft);

    ind.left = (ind.left || 0) + marginLeftNum;
  }

  if (style.paddingLeft && (0, _everUtils.isCSSAbsoluteLength)(style.paddingLeft)) {
    const paddingLeftNum = _everUtils.unitsConverter.toPX(style.paddingLeft);

    if (paddingLeftNum) {
      ind.left = (ind.left || 0) + paddingLeftNum;
    }
  }

  if (ind.left) {
    // @ts-ignore 修正负悬挂缩进与预期不一致
    const indentNum = ind.firstLine || 0;

    if (indentNum < 0) {
      ind.left += indentNum;
    }
  }

  if (Object.keys(ind).length) {
    attrs.ind = ind;
  }

  for (const key in spacingAttrs) {
    if (!style[key]) continue;

    const valNum = _everUtils.unitsConverter.toPX(style[key]);

    if (!valNum) continue;

    if (!attrs.spacing) {
      attrs.spacing = {};
    }

    attrs.spacing[spacingAttrs[key]] = valNum;
  }

  if (style.lineHeight) {
    if (!attrs.spacing) {
      attrs.spacing = {};
    }

    attrs.spacing.line = _everUtils.SpacingUtil.fromHtml(style.lineHeight, style.fontSize);
  }

  return attrs;
}

function normalizeAttrs(rawAttrs, tagName, pasteFrom) {
  let attrs = {};

  if (rawAttrs.style) {
    const style = rawAttrs.styleObj;
    attrs = { ...attrs,
      ...generateAttrsFromStyle(style)
    };

    if (attrs && !_everCangjie.REMAIN_STYLE_SOURCES.includes(pasteFrom)) {
      delete attrs.spacing?.before;
      delete attrs.spacing?.after;
      delete attrs.spacing?.line;
      delete attrs.ind?.left;
    }
  }

  const list = {};

  if (rawAttrs['data-listid']) {
    list.listId = rawAttrs['data-listid'];
  }

  if (rawAttrs['data-level']) {
    list.level = parseInt(rawAttrs['data-level'], 10);
  }

  if ('data-isordered' in rawAttrs) {
    list.isOrdered = rawAttrs['data-isordered'] === 'true';
  }

  if ('data-istasklist' in rawAttrs) {
    list.isTaskList = rawAttrs['data-istasklist'] === 'true';
  }

  if ('data-ischecked' in rawAttrs) {
    list.isChecked = rawAttrs['data-ischecked'] === 'true';
  }

  if (rawAttrs['data-format'] || rawAttrs['data-text'] || rawAttrs['data-align']) {
    list.listStyle = {
      format: rawAttrs['data-format'],
      text: rawAttrs['data-text'],
      align: rawAttrs['data-align']
    }; // @ts-ignore to fix list style

    if (!rawAttrs['data-format']) delete list.listStyle.format; // @ts-ignore to fix list style

    if (!rawAttrs['data-text']) delete list.listStyle.text; // @ts-ignore to fix list style

    if (!rawAttrs['data-align']) delete list.listStyle.align;
  }

  if (Object.keys(list).length) {
    attrs.list = list;
  }

  return attrs;
}

function flatAppend(state, node) {
  const tagName = (0, _everUtils.getTagName)(node);
  const attrs = (0, _everUtils.getAttributes)(node);
  const chlidren = (0, _everUtils.getChildren)(node);
  let current = attrs ? [tagName, attrs] : [tagName];
  let isPrevText = false;
  chlidren.forEach(child => {
    const childTagName = (0, _everUtils.getTagName)(child);

    if (_everUtils.paragraphTags[childTagName] || childTagName === 'hr' || childTagName === 'table' || childTagName === 'code') {
      if ((0, _everUtils.getChildren)(current).length) {
        state.append(current);
      }

      if (childTagName === 'p') {
        state.append([tagName, ...child.slice(1)]);
      } else {
        state.append(child);
      }

      current = attrs ? [tagName, attrs] : [tagName];
      isPrevText = false;
      return;
    }

    if (!isPrevText && (0, _everUtils.isJsonMLInline)(child)) {
      current.push((0, _everCangjie.createTextWithString)(''));
    }

    current.push(child);
    isPrevText = (0, _everUtils.isJsonMLText)(child);
  });

  if ((0, _everUtils.getChildren)(current).length) {
    const lastChild = current[current.length - 1];

    if ((0, _everUtils.isJsonMLInline)(lastChild)) {
      current.push((0, _everCangjie.createTextWithString)(''));
    }

    state.append(current);
  }
}

function parseHtml(pasteFrom) {
  return {
    name: _models.default.TYPE,
    onOpenTag: (state, name, rAttrs) => {
      if (!_everUtils.paragraphTags[name]) return false;
      const {
        p,
        rawAttrs
      } = (0, _getParagraphTagStyle.default)(name, rAttrs);
      const attrs = normalizeAttrs(rawAttrs, name, pasteFrom);

      if (Object.keys(attrs).length) {
        p.push(attrs);
      }

      state.push(p);
      return true;
    },
    onCloseTag: (state, name) => {
      if (!_everUtils.paragraphTags[name]) return false;
      const p = state.pop();

      if ((0, _everUtils.getChildren)(p).length === 0) {
        p.push((0, _everCangjie.createTextWithString)(''));
      }

      flatAppend(state, p);
      return true;
    }
  };
}
//# sourceMappingURL=parseFromWeb.js.map