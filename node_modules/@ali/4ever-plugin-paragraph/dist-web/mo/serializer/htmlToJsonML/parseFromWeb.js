import _extends from "@babel/runtime/helpers/extends";
import { getTagName, getAttributes, getChildren, parseCSSMargin, isCSSAbsoluteLength, isJsonMLInline, isJsonMLText, SpacingUtil, unitsConverter, paragraphTags } from '@ali/4ever-utils';
import { createTextWithString, REMAIN_STYLE_SOURCES } from '@ali/4ever-cangjie';
import Paragraph from "../../models";
import getParagraphTagStyle from "../utils/getParagraphTagStyle";
var validAlign = {
  left: true,
  center: true,
  right: true,
  justify: true,
  distribute: true
};
var spacingAttrs = {
  marginTop: 'before',
  marginBottom: 'after'
};

function isValidAlign(align) {
  if (align === void 0) {
    align = '';
  }

  return !!validAlign[align];
}

function generateAttrsFromStyle(style) {
  var attrs = {};
  var ind = {};

  if (isValidAlign(style.textAlign)) {
    attrs.jc = style.textAlign;
  }

  if (attrs.jc === 'justify' && style.textAlignLast === 'justify') {
    attrs.jc = 'distribute';
  }

  if (style.textIndent) {
    var firstLine = unitsConverter.toPX(style.textIndent);

    if (firstLine) {
      ind.firstLine = firstLine;
    }
  }

  if (style.margin) {
    var margins = parseCSSMargin(style.margin);
    ind.left = unitsConverter.toPX(margins.marginLeft);
  }

  if (style.padding) {
    var paddings = parseCSSMargin(style.padding);
    ind.left = (ind.left ? ind.left : 0) + unitsConverter.toPX(paddings.marginLeft);
  }

  if (style.marginLeft && isCSSAbsoluteLength(style.marginLeft)) {
    var marginLeftNum = unitsConverter.toPX(style.marginLeft);
    ind.left = (ind.left || 0) + marginLeftNum;
  }

  if (style.paddingLeft && isCSSAbsoluteLength(style.paddingLeft)) {
    var paddingLeftNum = unitsConverter.toPX(style.paddingLeft);

    if (paddingLeftNum) {
      ind.left = (ind.left || 0) + paddingLeftNum;
    }
  }

  if (ind.left) {
    // @ts-ignore 修正负悬挂缩进与预期不一致
    var indentNum = ind.firstLine || 0;

    if (indentNum < 0) {
      ind.left += indentNum;
    }
  }

  if (Object.keys(ind).length) {
    attrs.ind = ind;
  }

  for (var key in spacingAttrs) {
    if (!style[key]) continue;
    var valNum = unitsConverter.toPX(style[key]);
    if (!valNum) continue;

    if (!attrs.spacing) {
      attrs.spacing = {};
    }

    attrs.spacing[spacingAttrs[key]] = valNum;
  }

  if (style.lineHeight) {
    if (!attrs.spacing) {
      attrs.spacing = {};
    }

    attrs.spacing.line = SpacingUtil.fromHtml(style.lineHeight, style.fontSize);
  }

  return attrs;
}

function normalizeAttrs(rawAttrs, tagName, pasteFrom) {
  var attrs = {};

  if (rawAttrs.style) {
    var style = rawAttrs.styleObj;
    attrs = _extends({}, attrs, generateAttrsFromStyle(style));

    if (attrs && !REMAIN_STYLE_SOURCES.includes(pasteFrom)) {
      var _attrs$spacing, _attrs$spacing2, _attrs$spacing3, _attrs$ind;

      (_attrs$spacing = attrs.spacing) == null ? true : delete _attrs$spacing.before;
      (_attrs$spacing2 = attrs.spacing) == null ? true : delete _attrs$spacing2.after;
      (_attrs$spacing3 = attrs.spacing) == null ? true : delete _attrs$spacing3.line;
      (_attrs$ind = attrs.ind) == null ? true : delete _attrs$ind.left;
    }
  }

  var list = {};

  if (rawAttrs['data-listid']) {
    list.listId = rawAttrs['data-listid'];
  }

  if (rawAttrs['data-level']) {
    list.level = parseInt(rawAttrs['data-level'], 10);
  }

  if ('data-isordered' in rawAttrs) {
    list.isOrdered = rawAttrs['data-isordered'] === 'true';
  }

  if ('data-istasklist' in rawAttrs) {
    list.isTaskList = rawAttrs['data-istasklist'] === 'true';
  }

  if ('data-ischecked' in rawAttrs) {
    list.isChecked = rawAttrs['data-ischecked'] === 'true';
  }

  if (rawAttrs['data-format'] || rawAttrs['data-text'] || rawAttrs['data-align']) {
    list.listStyle = {
      format: rawAttrs['data-format'],
      text: rawAttrs['data-text'],
      align: rawAttrs['data-align']
    }; // @ts-ignore to fix list style

    if (!rawAttrs['data-format']) delete list.listStyle.format; // @ts-ignore to fix list style

    if (!rawAttrs['data-text']) delete list.listStyle.text; // @ts-ignore to fix list style

    if (!rawAttrs['data-align']) delete list.listStyle.align;
  }

  if (Object.keys(list).length) {
    attrs.list = list;
  }

  return attrs;
}

function flatAppend(state, node) {
  var tagName = getTagName(node);
  var attrs = getAttributes(node);
  var chlidren = getChildren(node);
  var current = attrs ? [tagName, attrs] : [tagName];
  var isPrevText = false;
  chlidren.forEach(function (child) {
    var childTagName = getTagName(child);

    if (paragraphTags[childTagName] || childTagName === 'hr' || childTagName === 'table' || childTagName === 'code') {
      if (getChildren(current).length) {
        state.append(current);
      }

      if (childTagName === 'p') {
        state.append([tagName].concat(child.slice(1)));
      } else {
        state.append(child);
      }

      current = attrs ? [tagName, attrs] : [tagName];
      isPrevText = false;
      return;
    }

    if (!isPrevText && isJsonMLInline(child)) {
      current.push(createTextWithString(''));
    }

    current.push(child);
    isPrevText = isJsonMLText(child);
  });

  if (getChildren(current).length) {
    var lastChild = current[current.length - 1];

    if (isJsonMLInline(lastChild)) {
      current.push(createTextWithString(''));
    }

    state.append(current);
  }
}

export default function parseHtml(pasteFrom) {
  return {
    name: Paragraph.TYPE,
    onOpenTag: function onOpenTag(state, name, rAttrs) {
      if (!paragraphTags[name]) return false;

      var _getParagraphTagStyle = getParagraphTagStyle(name, rAttrs),
          p = _getParagraphTagStyle.p,
          rawAttrs = _getParagraphTagStyle.rawAttrs;

      var attrs = normalizeAttrs(rawAttrs, name, pasteFrom);

      if (Object.keys(attrs).length) {
        p.push(attrs);
      }

      state.push(p);
      return true;
    },
    onCloseTag: function onCloseTag(state, name) {
      if (!paragraphTags[name]) return false;
      var p = state.pop();

      if (getChildren(p).length === 0) {
        p.push(createTextWithString(''));
      }

      flatAppend(state, p);
      return true;
    }
  };
}
//# sourceMappingURL=parseFromWeb.js.map