import { Block, Commands, EdgePoint } from '@ali/4ever-cangjie';
import logger from '@ali/4ever-logger';
import { BlockInsertPosition } from "../constants";
/**
 * 统一插入 Block 逻辑
 *
 * * 插入后内容前无空行
 * * 仅当在段尾(包括空段落)或文末的 void 元素上插入内容后有空行
 *
 * @param {Controller} controller
 * @param {Block} newBlock 待插入的 Block
 * @returns
 */

export default function insertBlockWithoutExtraBlank(controller, newBlock) {
  // 删除选区内内容
  if (controller.value.selection.isExpanded) {
    controller.command('deleteAtRange', controller.value.selection);
  } // 删除选区内内容后的 document


  var _getCurrentInfo = getCurrentInfo(controller),
      document = _getCurrentInfo.document,
      start = _getCurrentInfo.start,
      currentBlock = _getCurrentInfo.currentBlock;

  var currentInline = document.getClosestInline(start.key);

  if (!currentBlock) {
    logger.error('Cannot find currentBlock when insert block');
    return controller;
  }

  var nextBlock = document.getNextBlock(currentBlock.key); // 处理 focus 在 void 元素的情况

  if (currentInline && controller.query('isVoid', currentInline)) {
    // 移动光标到下一个 text
    controller.command(Commands.moveToStartOfNextText);
  } else if (controller.query('isVoid', currentBlock)) {
    var focus = controller.value.selection.focus;

    if (nextBlock) {
      // 有下一个 block 时
      if (focus.isEdgePoint()) {
        // 若为 Edge Selection，且 edge 为 after，则将光标设置到下一个 block
        if (focus.edge === EdgePoint.AFTER) {
          controller.command(Commands.moveToStartOfNode, nextBlock);
        }
      } else {
        // 否则移动光标到下一个 block
        controller.command(Commands.moveToStartOfNextBlock);
      }
    } else {
      // 后面无 block 时，直接插入的效果是会在当前元素前插入，所以需要提前在后面插入空行
      // eslint-disable-next-line no-lonely-if
      if (focus.isTextPoint()) {
        // 光标是普通 point 时，插入一个空行
        controller.command(Commands.insertBlock, Block.DEFAULT_TYPE);
      } else if (focus.isEdgePoint() && focus.edge === EdgePoint.AFTER) {
        // 光标在 edge after 时，插入一个空行（插入方式跟 TextPoint 略有区别）
        controller.command(Commands.insertEmptyBlock, focus);
      }
    }
  }

  var _getCurrentInfo2 = getCurrentInfo(controller),
      tempStart = _getCurrentInfo2.start,
      tempBlock = _getCurrentInfo2.currentBlock;

  if (tempBlock && !tempStart.isAtStartOfNode(tempBlock) && !tempStart.isAtEndOfNode(tempBlock)) {
    // 光标在段落中间
    controller.withoutNormalizing(function () {
      controller.command(Commands.splitDescendantsByKey, tempBlock.key, tempStart.key, tempStart.offset);
    });
  }

  var _getCurrentInfo3 = getCurrentInfo(controller),
      newDocument = _getCurrentInfo3.document,
      insertStart = _getCurrentInfo3.start,
      finalAtBlock = _getCurrentInfo3.currentBlock;

  if (!finalAtBlock) {
    logger.error('Cannot find finalAtBlock when insert block');
    return controller;
  }

  var parent = newDocument.getParent(finalAtBlock.key);
  var index = parent.nodes.indexOf(finalAtBlock); // 若不在开头 或是 空标题节点，则在光标所在段落的后面插入内容

  if (!insertStart.isAtStartOfNode(finalAtBlock) || controller.query('getBlockInsertPosition', finalAtBlock) === BlockInsertPosition.After) {
    index += 1;
  }

  controller.command(Commands.insertNodeByKey, parent.key, index, newBlock);
  return controller;
}

function getCurrentInfo(controller) {
  var _controller$value = controller.value,
      document = _controller$value.document,
      selection = _controller$value.selection;

  var _selection$convertToT = selection.convertToTextPoints(document),
      start = _selection$convertToT.start;

  var currentBlock = document.getClosestBlock(start.key);
  return {
    document: document,
    selection: selection,
    currentBlock: currentBlock,
    start: start
  };
}
//# sourceMappingURL=insertBlockWithoutExtraBlank.js.map