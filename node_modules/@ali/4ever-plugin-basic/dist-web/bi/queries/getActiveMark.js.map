{"version":3,"sources":["../../../../src/bi/queries/getActiveMark.ts"],"names":["setUtils","getRangesFromEditor","filterMarksByType","marks","markType","filter","m","type","getTextActiveMarksBetweenOffsets","controller","text","start","end","emptyMarkHandler","textLeaves","leaves","textCursor","firstFound","forEach","leaf","leafStart","leafEnd","length","leafMarks","intersect","getActiveMarksAtRange","range","document","value","activeMarks","convertToTextPoints","startOffset","offset","startKey","key","endOffset","endKey","texts","getTextsBetweenPositions","i","textNode","rangeStart","rangeEnd","Number","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","textMarks","getActiveMarksAtCursor","selection","anchor","startText","getNode","getFirstText","selectionMarks","undefined","isEdgePoint","getMarksAtPosition","getActiveMark","ranges","index","rangeActiveMarks","isCollapsed","getActiveMarkAtRange"],"mappings":"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","sourcesContent":["import { Controller, Mark, Selection, Text, setUtils } from '@ali/4ever-cangjie';\nimport { getRangesFromEditor } from '@ali/4ever-utils';\n\ninterface EmptyMarkHandler {\n  (controller: Controller, text?: Text): Mark[];\n}\n\n/**\n * 过滤出含有指定类型的 marks\n * @param marks\n * @param markType\n */\nfunction filterMarksByType(marks: Mark[], markType?: string) {\n  if (!markType) return marks;\n  return marks.filter((m) => m.type === markType);\n}\n\n/**\n * 获取 text 节点在指定区间、指定类型的公共 marks\n * 返回空数组表示文本不在指定区间内\n * @param controller\n * @param text\n * @param start 起始位置\n * @param end 结束位置\n * @param markType 指定样式类型\n * @param emptyMarkHandler 处理样式为空（指定 markType 不存在）\n */\nfunction getTextActiveMarksBetweenOffsets(\n  controller: Controller,\n  text: Text,\n  start: number,\n  end: number,\n  markType?: string,\n  emptyMarkHandler?: EmptyMarkHandler,\n) {\n  let marks: Mark[] = [];\n  const textLeaves = text.leaves;\n  let textCursor = 0;\n  let firstFound = false;\n\n  textLeaves.forEach((leaf) => {\n    const leafStart = textCursor;\n    const leafEnd = textCursor + leaf.text.length;\n\n    textCursor = leafEnd;\n    // lineA 和 lineB 相交：lineA.end > lineB.start && lineA.start < lineB.end\n    if (\n      leaf.text === '' ||\n      (leafEnd > start && leafStart < end)\n    ) {\n      let leafMarks = filterMarksByType(leaf.marks, markType);\n      if (!leafMarks.length && emptyMarkHandler) {\n        leafMarks = emptyMarkHandler(controller, text);\n      }\n      if (!firstFound) {\n        marks = leafMarks;\n        firstFound = true;\n      } else {\n        marks = setUtils.intersect(marks, leafMarks);\n      }\n    }\n  });\n  return marks;\n}\n\n/**\n * 获取指定选区、指定类型内的公共 marks\n * @param controller\n * @param range\n * @param markType\n * @param emptyMarkHandler 处理指定类型 mark 不存在的情况\n */\nfunction getActiveMarksAtRange(\n  controller: Controller,\n  range: Selection,\n  markType?: string,\n  emptyMarkHandler?: EmptyMarkHandler,\n) {\n  const { document } = controller.value;\n  let activeMarks: Mark[] = [];\n\n  const { start, end } = range.convertToTextPoints(document);\n  const { offset: startOffset, key: startKey } = start;\n  const { offset: endOffset, key: endKey } = end;\n  const texts = document.getTextsBetweenPositions(start.key, end.key);\n  let firstFound = false;\n  for (let i = 0; i < texts.length; i++) {\n    const textNode = texts[i];\n    let rangeStart = startOffset;\n    let rangeEnd = endOffset;\n    if (textNode.key === startKey && textNode.key === endKey) {\n      // 选区和文字处于同一节点\n    } else if (textNode.key === startKey) {\n      // 仅选区开头和文字处于同一节点\n      rangeEnd = Number.MAX_SAFE_INTEGER;\n    } else if (textNode.key === endKey) {\n      // 仅选区结尾和文字处于同一节点\n      rangeStart = Number.MIN_SAFE_INTEGER;\n    } else {\n      // 选区包含文本节点\n      rangeStart = Number.MIN_SAFE_INTEGER;\n      rangeEnd = Number.MAX_SAFE_INTEGER;\n    }\n\n    const textMarks = getTextActiveMarksBetweenOffsets(controller, textNode, rangeStart, rangeEnd, markType, emptyMarkHandler);\n    if (!firstFound) {\n      // 取第一个有效节点的样式\n      activeMarks = textMarks;\n      firstFound = true;\n      // 表情节点也需要取公共样式 (text 为空，marks 不为空)\n    } else if (textNode.text || textNode.marks.length !== 0) {\n      // 仅针对区间内节点取公共样式\n      activeMarks = setUtils.intersect(activeMarks, textMarks);\n    }\n  }\n\n  return activeMarks;\n}\n\n/**\n * 获取当前光标处 marks\n * @param controller\n */\nfunction getActiveMarksAtCursor(\n  controller: Controller,\n  selection: Selection,\n  markType?: string,\n  emptyMarkHandler?: EmptyMarkHandler,\n) {\n  const { document } = controller.value;\n  const { anchor } = selection;\n  const { start } = selection.convertToTextPoints(document);\n  const startText = document.getNode(start.key)?.getFirstText();\n\n  if (selection.marks) {\n    // 优先返回光标处临时 marks\n    let selectionMarks = filterMarksByType(selection.marks, markType);\n    if (!selectionMarks.length && emptyMarkHandler) {\n      selectionMarks = emptyMarkHandler(controller, startText || undefined);\n    }\n    return selectionMarks;\n  }\n\n  if (anchor.isEdgePoint()) {\n    // edge 处返回空\n    return [];\n  }\n\n\n  // 返回光标处 text marks\n  let marks = filterMarksByType(document.getMarksAtPosition(start.key, start.offset), markType);\n  if (!marks.length && emptyMarkHandler) {\n    marks = emptyMarkHandler(controller, startText || undefined);\n  }\n  return marks;\n}\n\n/**\n * 获取当前状态下指定类型的公共 mark\n * @param controller\n * @param markType\n * @param emptyMarkHandler\n */\nexport function getActiveMark(\n  controller: Controller,\n  markType?: string,\n  emptyMarkHandler?: EmptyMarkHandler,\n): Mark | undefined {\n  let activeMarks: Mark[] = [];\n\n  const ranges = getRangesFromEditor(controller);\n\n  ranges.forEach((range, index) => {\n    let rangeActiveMarks: Mark[] = [];\n    if (range.isCollapsed) {\n      // 处理 collapsed 情形\n      rangeActiveMarks = getActiveMarksAtCursor(controller, range, markType, emptyMarkHandler);\n    } else {\n      rangeActiveMarks = getActiveMarksAtRange(controller, range, markType, emptyMarkHandler);\n    }\n\n    if (index === 0) {\n      activeMarks = rangeActiveMarks;\n    } else {\n      // 任意一个选区为空，最终结果都将为空\n      activeMarks = setUtils.intersect(activeMarks, rangeActiveMarks);\n    }\n  });\n\n  return activeMarks[0];\n}\n\n/**\n * 获取指定 range 的指定类型的公共 mark\n * @param controller\n * @param range\n * @param markType\n * @param emptyMarkHandler\n */\n export function getActiveMarkAtRange(\n  controller: Controller,\n  range: Selection,\n  markType?: string,\n  emptyMarkHandler?: EmptyMarkHandler,\n): Mark | undefined {\n  const rangeActiveMarks = getActiveMarksAtRange(controller, range, markType, emptyMarkHandler);\n  return rangeActiveMarks[0];\n}\n"],"file":"getActiveMark.js"}