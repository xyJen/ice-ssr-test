import { setUtils } from '@ali/4ever-cangjie';
import { getRangesFromEditor } from '@ali/4ever-utils';

/**
 * 过滤出含有指定类型的 marks
 * @param marks
 * @param markType
 */
function filterMarksByType(marks, markType) {
  if (!markType) return marks;
  return marks.filter(function (m) {
    return m.type === markType;
  });
}
/**
 * 获取 text 节点在指定区间、指定类型的公共 marks
 * 返回空数组表示文本不在指定区间内
 * @param controller
 * @param text
 * @param start 起始位置
 * @param end 结束位置
 * @param markType 指定样式类型
 * @param emptyMarkHandler 处理样式为空（指定 markType 不存在）
 */


function getTextActiveMarksBetweenOffsets(controller, text, start, end, markType, emptyMarkHandler) {
  var marks = [];
  var textLeaves = text.leaves;
  var textCursor = 0;
  var firstFound = false;
  textLeaves.forEach(function (leaf) {
    var leafStart = textCursor;
    var leafEnd = textCursor + leaf.text.length;
    textCursor = leafEnd; // lineA 和 lineB 相交：lineA.end > lineB.start && lineA.start < lineB.end

    if (leaf.text === '' || leafEnd > start && leafStart < end) {
      var leafMarks = filterMarksByType(leaf.marks, markType);

      if (!leafMarks.length && emptyMarkHandler) {
        leafMarks = emptyMarkHandler(controller, text);
      }

      if (!firstFound) {
        marks = leafMarks;
        firstFound = true;
      } else {
        marks = setUtils.intersect(marks, leafMarks);
      }
    }
  });
  return marks;
}
/**
 * 获取指定选区、指定类型内的公共 marks
 * @param controller
 * @param range
 * @param markType
 * @param emptyMarkHandler 处理指定类型 mark 不存在的情况
 */


function getActiveMarksAtRange(controller, range, markType, emptyMarkHandler) {
  var document = controller.value.document;
  var activeMarks = [];

  var _range$convertToTextP = range.convertToTextPoints(document),
      start = _range$convertToTextP.start,
      end = _range$convertToTextP.end;

  var startOffset = start.offset,
      startKey = start.key;
  var endOffset = end.offset,
      endKey = end.key;
  var texts = document.getTextsBetweenPositions(start.key, end.key);
  var firstFound = false;

  for (var i = 0; i < texts.length; i++) {
    var textNode = texts[i];
    var rangeStart = startOffset;
    var rangeEnd = endOffset;

    if (textNode.key === startKey && textNode.key === endKey) {// 选区和文字处于同一节点
    } else if (textNode.key === startKey) {
      // 仅选区开头和文字处于同一节点
      rangeEnd = Number.MAX_SAFE_INTEGER;
    } else if (textNode.key === endKey) {
      // 仅选区结尾和文字处于同一节点
      rangeStart = Number.MIN_SAFE_INTEGER;
    } else {
      // 选区包含文本节点
      rangeStart = Number.MIN_SAFE_INTEGER;
      rangeEnd = Number.MAX_SAFE_INTEGER;
    }

    var textMarks = getTextActiveMarksBetweenOffsets(controller, textNode, rangeStart, rangeEnd, markType, emptyMarkHandler);

    if (!firstFound) {
      // 取第一个有效节点的样式
      activeMarks = textMarks;
      firstFound = true; // 表情节点也需要取公共样式 (text 为空，marks 不为空)
    } else if (textNode.text || textNode.marks.length !== 0) {
      // 仅针对区间内节点取公共样式
      activeMarks = setUtils.intersect(activeMarks, textMarks);
    }
  }

  return activeMarks;
}
/**
 * 获取当前光标处 marks
 * @param controller
 */


function getActiveMarksAtCursor(controller, selection, markType, emptyMarkHandler) {
  var _document$getNode;

  var document = controller.value.document;
  var anchor = selection.anchor;

  var _selection$convertToT = selection.convertToTextPoints(document),
      start = _selection$convertToT.start;

  var startText = (_document$getNode = document.getNode(start.key)) == null ? void 0 : _document$getNode.getFirstText();

  if (selection.marks) {
    // 优先返回光标处临时 marks
    var selectionMarks = filterMarksByType(selection.marks, markType);

    if (!selectionMarks.length && emptyMarkHandler) {
      selectionMarks = emptyMarkHandler(controller, startText || undefined);
    }

    return selectionMarks;
  }

  if (anchor.isEdgePoint()) {
    // edge 处返回空
    return [];
  } // 返回光标处 text marks


  var marks = filterMarksByType(document.getMarksAtPosition(start.key, start.offset), markType);

  if (!marks.length && emptyMarkHandler) {
    marks = emptyMarkHandler(controller, startText || undefined);
  }

  return marks;
}
/**
 * 获取当前状态下指定类型的公共 mark
 * @param controller
 * @param markType
 * @param emptyMarkHandler
 */


export function getActiveMark(controller, markType, emptyMarkHandler) {
  var activeMarks = [];
  var ranges = getRangesFromEditor(controller);
  ranges.forEach(function (range, index) {
    var rangeActiveMarks = [];

    if (range.isCollapsed) {
      // 处理 collapsed 情形
      rangeActiveMarks = getActiveMarksAtCursor(controller, range, markType, emptyMarkHandler);
    } else {
      rangeActiveMarks = getActiveMarksAtRange(controller, range, markType, emptyMarkHandler);
    }

    if (index === 0) {
      activeMarks = rangeActiveMarks;
    } else {
      // 任意一个选区为空，最终结果都将为空
      activeMarks = setUtils.intersect(activeMarks, rangeActiveMarks);
    }
  });
  return activeMarks[0];
}
/**
 * 获取指定 range 的指定类型的公共 mark
 * @param controller
 * @param range
 * @param markType
 * @param emptyMarkHandler
 */

export function getActiveMarkAtRange(controller, range, markType, emptyMarkHandler) {
  var rangeActiveMarks = getActiveMarksAtRange(controller, range, markType, emptyMarkHandler);
  return rangeActiveMarks[0];
}
//# sourceMappingURL=getActiveMark.js.map