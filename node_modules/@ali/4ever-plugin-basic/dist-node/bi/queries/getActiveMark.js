"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getActiveMark = getActiveMark;
exports.getActiveMarkAtRange = getActiveMarkAtRange;

var _everCangjie = require("@ali/4ever-cangjie");

var _everUtils = require("@ali/4ever-utils");

/**
 * 过滤出含有指定类型的 marks
 * @param marks
 * @param markType
 */
function filterMarksByType(marks, markType) {
  if (!markType) return marks;
  return marks.filter(m => m.type === markType);
}
/**
 * 获取 text 节点在指定区间、指定类型的公共 marks
 * 返回空数组表示文本不在指定区间内
 * @param controller
 * @param text
 * @param start 起始位置
 * @param end 结束位置
 * @param markType 指定样式类型
 * @param emptyMarkHandler 处理样式为空（指定 markType 不存在）
 */


function getTextActiveMarksBetweenOffsets(controller, text, start, end, markType, emptyMarkHandler) {
  let marks = [];
  const textLeaves = text.leaves;
  let textCursor = 0;
  let firstFound = false;
  textLeaves.forEach(leaf => {
    const leafStart = textCursor;
    const leafEnd = textCursor + leaf.text.length;
    textCursor = leafEnd; // lineA 和 lineB 相交：lineA.end > lineB.start && lineA.start < lineB.end

    if (leaf.text === '' || leafEnd > start && leafStart < end) {
      let leafMarks = filterMarksByType(leaf.marks, markType);

      if (!leafMarks.length && emptyMarkHandler) {
        leafMarks = emptyMarkHandler(controller, text);
      }

      if (!firstFound) {
        marks = leafMarks;
        firstFound = true;
      } else {
        marks = _everCangjie.setUtils.intersect(marks, leafMarks);
      }
    }
  });
  return marks;
}
/**
 * 获取指定选区、指定类型内的公共 marks
 * @param controller
 * @param range
 * @param markType
 * @param emptyMarkHandler 处理指定类型 mark 不存在的情况
 */


function getActiveMarksAtRange(controller, range, markType, emptyMarkHandler) {
  const {
    document
  } = controller.value;
  let activeMarks = [];
  const {
    start,
    end
  } = range.convertToTextPoints(document);
  const {
    offset: startOffset,
    key: startKey
  } = start;
  const {
    offset: endOffset,
    key: endKey
  } = end;
  const texts = document.getTextsBetweenPositions(start.key, end.key);
  let firstFound = false;

  for (let i = 0; i < texts.length; i++) {
    const textNode = texts[i];
    let rangeStart = startOffset;
    let rangeEnd = endOffset;

    if (textNode.key === startKey && textNode.key === endKey) {// 选区和文字处于同一节点
    } else if (textNode.key === startKey) {
      // 仅选区开头和文字处于同一节点
      rangeEnd = Number.MAX_SAFE_INTEGER;
    } else if (textNode.key === endKey) {
      // 仅选区结尾和文字处于同一节点
      rangeStart = Number.MIN_SAFE_INTEGER;
    } else {
      // 选区包含文本节点
      rangeStart = Number.MIN_SAFE_INTEGER;
      rangeEnd = Number.MAX_SAFE_INTEGER;
    }

    const textMarks = getTextActiveMarksBetweenOffsets(controller, textNode, rangeStart, rangeEnd, markType, emptyMarkHandler);

    if (!firstFound) {
      // 取第一个有效节点的样式
      activeMarks = textMarks;
      firstFound = true; // 表情节点也需要取公共样式 (text 为空，marks 不为空)
    } else if (textNode.text || textNode.marks.length !== 0) {
      // 仅针对区间内节点取公共样式
      activeMarks = _everCangjie.setUtils.intersect(activeMarks, textMarks);
    }
  }

  return activeMarks;
}
/**
 * 获取当前光标处 marks
 * @param controller
 */


function getActiveMarksAtCursor(controller, selection, markType, emptyMarkHandler) {
  const {
    document
  } = controller.value;
  const {
    anchor
  } = selection;
  const {
    start
  } = selection.convertToTextPoints(document);
  const startText = document.getNode(start.key)?.getFirstText();

  if (selection.marks) {
    // 优先返回光标处临时 marks
    let selectionMarks = filterMarksByType(selection.marks, markType);

    if (!selectionMarks.length && emptyMarkHandler) {
      selectionMarks = emptyMarkHandler(controller, startText || undefined);
    }

    return selectionMarks;
  }

  if (anchor.isEdgePoint()) {
    // edge 处返回空
    return [];
  } // 返回光标处 text marks


  let marks = filterMarksByType(document.getMarksAtPosition(start.key, start.offset), markType);

  if (!marks.length && emptyMarkHandler) {
    marks = emptyMarkHandler(controller, startText || undefined);
  }

  return marks;
}
/**
 * 获取当前状态下指定类型的公共 mark
 * @param controller
 * @param markType
 * @param emptyMarkHandler
 */


function getActiveMark(controller, markType, emptyMarkHandler) {
  let activeMarks = [];
  const ranges = (0, _everUtils.getRangesFromEditor)(controller);
  ranges.forEach((range, index) => {
    let rangeActiveMarks = [];

    if (range.isCollapsed) {
      // 处理 collapsed 情形
      rangeActiveMarks = getActiveMarksAtCursor(controller, range, markType, emptyMarkHandler);
    } else {
      rangeActiveMarks = getActiveMarksAtRange(controller, range, markType, emptyMarkHandler);
    }

    if (index === 0) {
      activeMarks = rangeActiveMarks;
    } else {
      // 任意一个选区为空，最终结果都将为空
      activeMarks = _everCangjie.setUtils.intersect(activeMarks, rangeActiveMarks);
    }
  });
  return activeMarks[0];
}
/**
 * 获取指定 range 的指定类型的公共 mark
 * @param controller
 * @param range
 * @param markType
 * @param emptyMarkHandler
 */


function getActiveMarkAtRange(controller, range, markType, emptyMarkHandler) {
  const rangeActiveMarks = getActiveMarksAtRange(controller, range, markType, emptyMarkHandler);
  return rangeActiveMarks[0];
}
//# sourceMappingURL=getActiveMark.js.map