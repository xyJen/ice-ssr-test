"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = insertBlockWithoutExtraBlank;

var _everCangjie = require("@ali/4ever-cangjie");

var _everLogger = _interopRequireDefault(require("@ali/4ever-logger"));

var _constants = require("../constants");

/**
 * 统一插入 Block 逻辑
 *
 * * 插入后内容前无空行
 * * 仅当在段尾(包括空段落)或文末的 void 元素上插入内容后有空行
 *
 * @param {Controller} controller
 * @param {Block} newBlock 待插入的 Block
 * @returns
 */
function insertBlockWithoutExtraBlank(controller, newBlock) {
  // 删除选区内内容
  if (controller.value.selection.isExpanded) {
    controller.command('deleteAtRange', controller.value.selection);
  } // 删除选区内内容后的 document


  const {
    document,
    start,
    currentBlock
  } = getCurrentInfo(controller);
  const currentInline = document.getClosestInline(start.key);

  if (!currentBlock) {
    _everLogger.default.error('Cannot find currentBlock when insert block');

    return controller;
  }

  const nextBlock = document.getNextBlock(currentBlock.key); // 处理 focus 在 void 元素的情况

  if (currentInline && controller.query('isVoid', currentInline)) {
    // 移动光标到下一个 text
    controller.command(_everCangjie.Commands.moveToStartOfNextText);
  } else if (controller.query('isVoid', currentBlock)) {
    const {
      focus
    } = controller.value.selection;

    if (nextBlock) {
      // 有下一个 block 时
      if (focus.isEdgePoint()) {
        // 若为 Edge Selection，且 edge 为 after，则将光标设置到下一个 block
        if (focus.edge === _everCangjie.EdgePoint.AFTER) {
          controller.command(_everCangjie.Commands.moveToStartOfNode, nextBlock);
        }
      } else {
        // 否则移动光标到下一个 block
        controller.command(_everCangjie.Commands.moveToStartOfNextBlock);
      }
    } else {
      // 后面无 block 时，直接插入的效果是会在当前元素前插入，所以需要提前在后面插入空行
      // eslint-disable-next-line no-lonely-if
      if (focus.isTextPoint()) {
        // 光标是普通 point 时，插入一个空行
        controller.command(_everCangjie.Commands.insertBlock, _everCangjie.Block.DEFAULT_TYPE);
      } else if (focus.isEdgePoint() && focus.edge === _everCangjie.EdgePoint.AFTER) {
        // 光标在 edge after 时，插入一个空行（插入方式跟 TextPoint 略有区别）
        controller.command(_everCangjie.Commands.insertEmptyBlock, focus);
      }
    }
  }

  const {
    start: tempStart,
    currentBlock: tempBlock
  } = getCurrentInfo(controller);

  if (tempBlock && !tempStart.isAtStartOfNode(tempBlock) && !tempStart.isAtEndOfNode(tempBlock)) {
    // 光标在段落中间
    controller.withoutNormalizing(() => {
      controller.command(_everCangjie.Commands.splitDescendantsByKey, tempBlock.key, tempStart.key, tempStart.offset);
    });
  }

  const {
    document: newDocument,
    start: insertStart,
    currentBlock: finalAtBlock
  } = getCurrentInfo(controller);

  if (!finalAtBlock) {
    _everLogger.default.error('Cannot find finalAtBlock when insert block');

    return controller;
  }

  const parent = newDocument.getParent(finalAtBlock.key);
  let index = parent.nodes.indexOf(finalAtBlock); // 若不在开头 或是 空标题节点，则在光标所在段落的后面插入内容

  if (!insertStart.isAtStartOfNode(finalAtBlock) || controller.query('getBlockInsertPosition', finalAtBlock) === _constants.BlockInsertPosition.After) {
    index += 1;
  }

  controller.command(_everCangjie.Commands.insertNodeByKey, parent.key, index, newBlock);
  return controller;
}

function getCurrentInfo(controller) {
  const {
    document,
    selection
  } = controller.value;
  const {
    start
  } = selection.convertToTextPoints(document);
  const currentBlock = document.getClosestBlock(start.key);
  return {
    document,
    selection,
    currentBlock,
    start
  };
}
//# sourceMappingURL=insertBlockWithoutExtraBlank.js.map