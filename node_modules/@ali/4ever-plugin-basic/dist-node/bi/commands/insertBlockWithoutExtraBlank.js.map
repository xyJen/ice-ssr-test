{"version":3,"sources":["../../../../src/bi/commands/insertBlockWithoutExtraBlank.ts"],"names":["insertBlockWithoutExtraBlank","controller","newBlock","value","selection","isExpanded","command","document","start","currentBlock","getCurrentInfo","currentInline","getClosestInline","key","logger","error","nextBlock","getNextBlock","query","Commands","moveToStartOfNextText","focus","isEdgePoint","edge","EdgePoint","AFTER","moveToStartOfNode","moveToStartOfNextBlock","isTextPoint","insertBlock","Block","DEFAULT_TYPE","insertEmptyBlock","tempStart","tempBlock","isAtStartOfNode","isAtEndOfNode","withoutNormalizing","splitDescendantsByKey","offset","newDocument","insertStart","finalAtBlock","parent","getParent","index","nodes","indexOf","BlockInsertPosition","After","insertNodeByKey","convertToTextPoints","getClosestBlock"],"mappings":"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","sourcesContent":["import { Block, Controller, Commands, EdgePoint } from '@ali/4ever-cangjie';\nimport logger from '@ali/4ever-logger';\nimport { BlockInsertPosition } from '../constants';\n\n/**\n * 统一插入 Block 逻辑\n *\n * * 插入后内容前无空行\n * * 仅当在段尾(包括空段落)或文末的 void 元素上插入内容后有空行\n *\n * @param {Controller} controller\n * @param {Block} newBlock 待插入的 Block\n * @returns\n */\nexport default function insertBlockWithoutExtraBlank(controller: Controller, newBlock: Block) {\n  // 删除选区内内容\n  if (controller.value.selection.isExpanded) {\n    controller.command('deleteAtRange', controller.value.selection);\n  }\n\n  // 删除选区内内容后的 document\n  const { document, start, currentBlock } = getCurrentInfo(controller);\n  const currentInline = document.getClosestInline(start.key);\n\n  if (!currentBlock) {\n    logger.error('Cannot find currentBlock when insert block');\n    return controller;\n  }\n\n  const nextBlock = document.getNextBlock(currentBlock.key);\n  // 处理 focus 在 void 元素的情况\n  if (currentInline && controller.query('isVoid', currentInline)) {\n    // 移动光标到下一个 text\n    controller.command(Commands.moveToStartOfNextText);\n  } else if (controller.query('isVoid', currentBlock)) {\n    const { focus } = controller.value.selection;\n    if (nextBlock) { // 有下一个 block 时\n      if (focus.isEdgePoint()) {\n        // 若为 Edge Selection，且 edge 为 after，则将光标设置到下一个 block\n        if (focus.edge === EdgePoint.AFTER) {\n          controller.command(Commands.moveToStartOfNode, nextBlock);\n        }\n      } else {\n        // 否则移动光标到下一个 block\n        controller.command(Commands.moveToStartOfNextBlock);\n      }\n    } else {\n      // 后面无 block 时，直接插入的效果是会在当前元素前插入，所以需要提前在后面插入空行\n      // eslint-disable-next-line no-lonely-if\n      if (focus.isTextPoint()) {\n        // 光标是普通 point 时，插入一个空行\n        controller.command(Commands.insertBlock, Block.DEFAULT_TYPE);\n      } else if (focus.isEdgePoint() && focus.edge === EdgePoint.AFTER) {\n        // 光标在 edge after 时，插入一个空行（插入方式跟 TextPoint 略有区别）\n        controller.command(Commands.insertEmptyBlock, focus);\n      }\n    }\n  }\n\n  const { start: tempStart, currentBlock: tempBlock } = getCurrentInfo(controller);\n  if (tempBlock && !tempStart.isAtStartOfNode(tempBlock) && !tempStart.isAtEndOfNode(tempBlock)) {\n    // 光标在段落中间\n    controller.withoutNormalizing(() => {\n      controller.command(\n        Commands.splitDescendantsByKey,\n        tempBlock.key,\n        tempStart.key,\n        tempStart.offset,\n      );\n    });\n  }\n\n  const { document: newDocument, start: insertStart, currentBlock: finalAtBlock } = getCurrentInfo(controller);\n\n  if (!finalAtBlock) {\n    logger.error('Cannot find finalAtBlock when insert block');\n    return controller;\n  }\n\n  const parent = newDocument.getParent(finalAtBlock.key)!;\n  let index = parent.nodes.indexOf(finalAtBlock);\n\n  // 若不在开头 或是 空标题节点，则在光标所在段落的后面插入内容\n  if (\n    !insertStart.isAtStartOfNode(finalAtBlock)\n    || controller.query('getBlockInsertPosition', finalAtBlock) === BlockInsertPosition.After\n  ) {\n    index += 1;\n  }\n\n  controller.command(Commands.insertNodeByKey, parent.key, index, newBlock);\n\n  return controller;\n}\n\nfunction getCurrentInfo(controller: Controller) {\n  const { document, selection } = controller.value;\n  const { start } = selection.convertToTextPoints(document);\n  const currentBlock = document.getClosestBlock(start.key);\n  return {\n    document,\n    selection,\n    currentBlock,\n    start,\n  };\n}\n"],"file":"insertBlockWithoutExtraBlank.js"}