"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var React = _interopRequireWildcard(require("react"));

var _lodash = require("lodash");

var _everUtils = require("@ali/4ever-utils");

var _HoverBlock = require("../HoverBlock");

var _styled = require("./styled");

var _icon = _interopRequireDefault(require("./icon"));

/* eslint-disable @typescript-eslint/no-use-before-define */
const _createElement = /*#__PURE__*/React.createElement;

const isInRange = (num, range) => {
  return num >= range[0] && num <= range[1];
};

const showHandle = axisName => {
  return axis => {
    return axis === axisName || axis === 'all';
  };
};

const showYHandle = showHandle('y');
const showXHandle = showHandle('x');

const getRelatives = (event, ref) => {
  let mouseEvent;

  if (window.TouchEvent && event instanceof window.TouchEvent) {
    mouseEvent = event.touches[0];
  } else {
    mouseEvent = event;
  }

  return (0, _everUtils.getRelativeMouseEvent)(mouseEvent, ref);
};

var _ref = /*#__PURE__*/_createElement(_icon.default, null);

const Resizable = props => {
  const {
    children,
    axis,
    className = 'resizable',
    onResize,
    onResizeStart = _lodash.noop,
    onResizeStop = _lodash.noop,
    widthRange = [0, Infinity],
    heightRange = [0, Infinity],
    width,
    height,
    visible,
    style = {},
    speed = 1.0,
    zoomContainer,
    innerRef = null,
    handleStyle = {},
    onClick,
    autoHeight,
    isActive,
    enableBorderHighlight
  } = props;
  const dragging = React.useRef(false);
  const startPoint = React.useRef([0, 0, height]);
  const heightRef = React.useRef(height);
  const widthRef = React.useRef(width);
  const [isHover, hoverHandlers] = (0, _HoverBlock.useHover)(enableBorderHighlight);

  function handleDragging(event) {
    if (dragging.current) {
      event.preventDefault();
      event.stopPropagation();
      const {
        relativeX,
        relativeY
      } = getRelatives(event, zoomContainer);
      const [startX, startY, startHeight] = startPoint.current;
      const newWidth = (relativeX - startX) * speed + width;
      const newHeight = (relativeY - startY) * speed + startHeight;

      if (showYHandle(axis) && isInRange(newHeight, heightRange)) {
        heightRef.current = newHeight;
        onResize(event, {
          width,
          height: newHeight
        });
      } else if (showXHandle(axis) && isInRange(newWidth, widthRange)) {
        widthRef.current = newWidth;
        onResize(event, {
          width: newWidth,
          height: startHeight
        });
      }
    }
  }

  function handleDragStop(event) {
    if (dragging.current && isInRange(heightRef.current, heightRange) && isInRange(widthRef.current, widthRange)) {
      dragging.current = false;
      unbindEvents();
      onResizeStop(event, {
        height: heightRef.current,
        width: widthRef.current
      });
    }
  }

  function handleDragStart(event) {
    event.preventDefault();
    event.stopPropagation();
    const {
      relativeX,
      relativeY
    } = getRelatives(event.nativeEvent, zoomContainer);
    dragging.current = true;
    const startHeight = autoHeight && innerRef ? innerRef.current.getBoundingClientRect().height : height;
    heightRef.current = startHeight;
    startPoint.current = [relativeX, relativeY, startHeight];
    bindEvents();
    onResizeStart(event.nativeEvent);
  }

  function unbindEvents() {
    document.removeEventListener('mousemove', handleDragging);
    document.removeEventListener('touchmove', handleDragging);
    document.removeEventListener('mouseup', handleDragStop);
    document.removeEventListener('touchend', handleDragStop);
  }

  function bindEvents() {
    document.addEventListener('mousemove', handleDragging);
    document.addEventListener('touchmove', handleDragging);
    document.addEventListener('mouseup', handleDragStop);
    document.addEventListener('touchend', handleDragStop);
  }

  React.useEffect(() => {
    return unbindEvents;
  }, []);
  const resizableStyle = {
    width: `${width}px`,
    position: 'relative',
    ...style
  }; // autoHeight 模式下，不需要每次换行都重新计算高度，避免产生抖动

  if (!autoHeight) {
    resizableStyle.height = `${height}px`;
  }

  return /*#__PURE__*/_createElement(_styled.ResizableWrapper, (0, _extends2.default)({
    className: className,
    style: resizableStyle,
    ref: innerRef,
    onClick: onClick
  }, hoverHandlers, {
    isHover: isHover,
    isActive: isActive,
    "data-hover-box": "borderBox"
  }), /*#__PURE__*/_createElement(_styled.Mask, {
    visible: dragging.current
  }), children, showYHandle(axis) && visible && /*#__PURE__*/_createElement(_styled.YHandle, {
    style: handleStyle,
    dragging: dragging.current
  }, /*#__PURE__*/_createElement(_icon.default, {
    onMouseDown: handleDragStart,
    onTouchStart: handleDragStart
  })), showXHandle(axis) && visible && /*#__PURE__*/_createElement(_styled.XHandle, {
    onMouseDown: handleDragStart,
    onTouchStart: handleDragStart,
    style: handleStyle,
    dragging: dragging.current
  }, _ref));
};

var _default = Resizable;
exports.default = _default;
//# sourceMappingURL=index.js.map