{"version":3,"sources":["../../../src/HoverBlock/useHover.ts"],"names":["clearerRef","current","useHover","enableHover","callbacks","isHover","setHover","React","useState","onMouseLeave","onMouseOut","onMouseOver","handleMouseOver","useCallback","e","stopPropagation","handleMouseOut","currentTarget","target","Node","contains","handleMouseLeave","useEffect","handlers","useMemo"],"mappings":";;;;;;;;;AAAA;;AAQA,MAAMA,UAA4D,GAAG;AACnEC,EAAAA,OAAO,EAAE;AAD0D,CAArE;;AAIe,SAASC,QAAT,CAAkBC,WAAlB,EAAyCC,SAAzC,EAAyE;AACtF,QAAM,CAACC,OAAD,EAAUC,QAAV,IAAsBC,eAAMC,QAAN,CAAe,KAAf,CAA5B;;AACA,QAAM;AAAEC,IAAAA,YAAF;AAAgBC,IAAAA,UAAhB;AAA4BC,IAAAA;AAA5B,MAA4CP,SAAS,IAAI,EAA/D;;AACA,QAAMQ,eAAe,GAAGL,eAAMM,WAAN,CAAmBC,CAAD,IAAyB;AACjEH,IAAAA,WAAW,IAAIA,WAAW,CAACG,CAAD,CAA1B;;AACA,QAAIX,WAAJ,EAAiB;AACfW,MAAAA,CAAC,CAACC,eAAF,GADe,CAEf;AACA;;AACAf,MAAAA,UAAU,CAACC,OAAX,IAAsBD,UAAU,CAACC,OAAX,CAAmB,KAAnB,CAAtB;AACAK,MAAAA,QAAQ,CAAC,IAAD,CAAR;AACAN,MAAAA,UAAU,CAACC,OAAX,GAAqBK,QAArB;AACD;AACF,GAVuB,EAUrB,CAACK,WAAD,EAAcR,WAAd,CAVqB,CAAxB;;AAYA,QAAMa,cAAc,GAAGT,eAAMM,WAAN,CAAmBC,CAAD,IAAyB;AAChE,UAAM;AAAEG,MAAAA,aAAF;AAAiBC,MAAAA;AAAjB,QAA4BJ,CAAlC;AACAJ,IAAAA,UAAU,IAAIA,UAAU,CAACI,CAAD,CAAxB;;AACA,QAAIX,WAAJ,EAAiB;AACf,UAAIe,MAAM,YAAYC,IAAlB,IAA0BF,aAAa,CAACG,QAAd,CAAuBF,MAAvB,CAA9B,EAA8D;AAC5D;AACD;;AACDZ,MAAAA,QAAQ,CAAC,KAAD,CAAR;AACD;AACF,GATsB,EASpB,CAACI,UAAD,EAAaP,WAAb,CAToB,CAAvB;;AAWA,QAAMkB,gBAAgB,GAAGd,eAAMM,WAAN,CAAmBC,CAAD,IAAyB;AAClEL,IAAAA,YAAY,IAAIA,YAAY,CAACK,CAAD,CAA5B;;AACA,QAAIX,WAAJ,EAAiB;AACfG,MAAAA,QAAQ,CAAC,KAAD,CAAR;AACD;AACF,GALwB,EAKtB,CAACG,YAAD,EAAeN,WAAf,CALsB,CAAzB;;AAOAI,iBAAMe,SAAN,CAAgB,MAAM;AACpB,WAAO,MAAM;AACX,UAAItB,UAAU,CAACC,OAAX,KAAuBK,QAA3B,EAAqC;AACnCN,QAAAA,UAAU,CAACC,OAAX,GAAqB,IAArB;AACD;AACF,KAJD;AAKD,GAND,EAMG,EANH;;AAQA,QAAMsB,QAAQ,GAAIhB,eAAMiB,OAAN,CAAc,OAAO;AACrCd,IAAAA,UAAU,EAAEM,cADyB;AAErCL,IAAAA,WAAW,EAAEC,eAFwB;AAGrCH,IAAAA,YAAY,EAAEY;AAHuB,GAAP,CAAd,EAId,CAACT,eAAD,EAAkBI,cAAlB,EAAkCK,gBAAlC,CAJc,CAAlB;;AAMA,SAAO,CAAChB,OAAD,EAAUkB,QAAV,CAAP;AACD","sourcesContent":["import React from 'react';\n\ntype IHandlers = {\n  onMouseOut: React.MouseEventHandler;\n  onMouseOver: React.MouseEventHandler;\n  onMouseLeave: React.MouseEventHandler;\n}\n\nconst clearerRef: { current: null | ((visible: boolean) => void) } = {\n  current: null,\n};\n\nexport default function useHover(enableHover?: boolean, callbacks?: Partial<IHandlers>) {\n  const [isHover, setHover] = React.useState(false);\n  const { onMouseLeave, onMouseOut, onMouseOver } = callbacks || {};\n  const handleMouseOver = React.useCallback((e: React.MouseEvent) => {\n    onMouseOver && onMouseOver(e);\n    if (enableHover) {\n      e.stopPropagation();\n      // 为避免在具有 hover状态的元素里移动鼠标时hover 边框闪烁，在 mouseOut 里如果是 target 是当前hover 元素的子元素则放行，\n      // 带来新的问题，如果移动到的子元素中也有hover 态，就会出现重复的hover 元素，所以需要主动清理上一次的hover 状态\n      clearerRef.current && clearerRef.current(false);\n      setHover(true);\n      clearerRef.current = setHover;\n    }\n  }, [onMouseOver, enableHover]);\n\n  const handleMouseOut = React.useCallback((e: React.MouseEvent) => {\n    const { currentTarget, target } = e;\n    onMouseOut && onMouseOut(e);\n    if (enableHover) {\n      if (target instanceof Node && currentTarget.contains(target)) {\n        return;\n      }\n      setHover(false);\n    }\n  }, [onMouseOut, enableHover]);\n\n  const handleMouseLeave = React.useCallback((e: React.MouseEvent) => {\n    onMouseLeave && onMouseLeave(e);\n    if (enableHover) {\n      setHover(false);\n    }\n  }, [onMouseLeave, enableHover]);\n\n  React.useEffect(() => {\n    return () => {\n      if (clearerRef.current === setHover) {\n        clearerRef.current = null;\n      }\n    }\n  }, []);\n\n  const handlers =  React.useMemo(() => ({\n    onMouseOut: handleMouseOut,\n    onMouseOver: handleMouseOver,\n    onMouseLeave: handleMouseLeave,\n  }), [handleMouseOver, handleMouseOut, handleMouseLeave]);\n\n  return [isHover, handlers] as [boolean, IHandlers];\n}"],"file":"useHover.js"}