"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useHover;

var _react = _interopRequireDefault(require("react"));

const clearerRef = {
  current: null
};

function useHover(enableHover, callbacks) {
  const [isHover, setHover] = _react.default.useState(false);

  const {
    onMouseLeave,
    onMouseOut,
    onMouseOver
  } = callbacks || {};

  const handleMouseOver = _react.default.useCallback(e => {
    onMouseOver && onMouseOver(e);

    if (enableHover) {
      e.stopPropagation(); // 为避免在具有 hover状态的元素里移动鼠标时hover 边框闪烁，在 mouseOut 里如果是 target 是当前hover 元素的子元素则放行，
      // 带来新的问题，如果移动到的子元素中也有hover 态，就会出现重复的hover 元素，所以需要主动清理上一次的hover 状态

      clearerRef.current && clearerRef.current(false);
      setHover(true);
      clearerRef.current = setHover;
    }
  }, [onMouseOver, enableHover]);

  const handleMouseOut = _react.default.useCallback(e => {
    const {
      currentTarget,
      target
    } = e;
    onMouseOut && onMouseOut(e);

    if (enableHover) {
      if (target instanceof Node && currentTarget.contains(target)) {
        return;
      }

      setHover(false);
    }
  }, [onMouseOut, enableHover]);

  const handleMouseLeave = _react.default.useCallback(e => {
    onMouseLeave && onMouseLeave(e);

    if (enableHover) {
      setHover(false);
    }
  }, [onMouseLeave, enableHover]);

  _react.default.useEffect(() => {
    return () => {
      if (clearerRef.current === setHover) {
        clearerRef.current = null;
      }
    };
  }, []);

  const handlers = _react.default.useMemo(() => ({
    onMouseOut: handleMouseOut,
    onMouseOver: handleMouseOver,
    onMouseLeave: handleMouseLeave
  }), [handleMouseOver, handleMouseOut, handleMouseLeave]);

  return [isHover, handlers];
}
//# sourceMappingURL=useHover.js.map