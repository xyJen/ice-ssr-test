"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useOnClickOutside;

var _react = require("react");

function useOnClickOutside(ref, handler,
/** 是否阻止编辑器以外的 mousedown 行为 */
preventMousedownOutsideEditor = true, // 有一些场景，要忽略的并非内部元素，比如 toolbar 弹框
ignore) {
  (0, _react.useEffect)(() => {
    const listener = event => {
      // 点击自己或者自己的子树，或者 ignore 生效，则忽略
      if (!ref.current || ref.current?.contains(event.target) || ignore?.(event.target)) {
        return;
      } // BACKGROUND
      // 当我们点击外部时，期望能够 focus 回编辑器，此时存在两种情况：
      // 1. 点击到编辑器
      // 2. 点击到其他地方
      // 对于情况 2，其事件流为
      // mousedown -> blur -> mouseup
      // mousedown 时，我们的组件可能会通过 handler 调用 focus 逻辑让编辑器重新聚焦
      // 但后续的 blur 事件又会让编辑器失焦
      // 因此，在情况 2 下，我们需要阻止默认的 mousedown 行为（阻止了 mousedown 引起 blur），来防止编辑器失焦


      if (preventMousedownOutsideEditor && event.target && !event.target.closest('[data-slate-editor]')) {
        event.preventDefault();
      }

      handler(event);
    };

    document.addEventListener('mousedown', listener);
    document.addEventListener('touchstart', listener);
    return () => {
      document.removeEventListener('mousedown', listener);
      document.removeEventListener('touchstart', listener);
    };
  }, [ref, ignore, handler, preventMousedownOutsideEditor]);
}
//# sourceMappingURL=useOnClickOutside.js.map