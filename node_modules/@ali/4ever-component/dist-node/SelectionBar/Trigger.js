"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.BasicPortal = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var React = _interopRequireWildcard(require("react"));

var ReactDOM = _interopRequireWildcard(require("react-dom"));

var _lodash = require("lodash");

var _resizeObserverPolyfill = _interopRequireDefault(require("resize-observer-polyfill"));

var _everCangjie = require("@ali/4ever-cangjie");

var _everUtils = require("@ali/4ever-utils");

var _SelectionBar = _interopRequireWildcard(require("./SelectionBar"));

var _context = require("./context");

var _ActiveInteractionContext = require("../HoverBlock/ActiveInteractionContext");

const _createElement = /*#__PURE__*/React.createElement;

const getTable = controller => {
  const {
    document,
    selection
  } = controller.value;
  return document.getClosest(selection.getStart(document).key, n => {
    return !!controller.query('isTable', n);
  }) || null;
};

const {
  useActiveInteraction
} = _ActiveInteractionContext.ActiveInteractionHooks;

/**
 * 使用 ReactDOM.createPortal 渲染节点
 * @param props
 * @returns
 */
const BasicPortal = props => {
  const {
    children,
    container,
    key
  } = props;
  return /*#__PURE__*/ReactDOM.createPortal(children, container, key);
};

exports.BasicPortal = BasicPortal;
BasicPortal.displayName = 'Portal';
const INITIAL_STATE = {
  visible: false,
  placement: 'top',
  x: 0,
  y: 0
};
/**
 * 工具栏视口边距
 */

const VIEWPORT_GAP = 4;
/**
 * SelectionBar 与文字之间的距离
 */

const SELECTION_BAR_GAP = 8;
/**
 * 判断一组选区是否有换行
 * @param clientRects
 */

function isBreakLine(clientRects) {
  // 如果只有单选区，则一定没有换行
  if (clientRects.length <= 1) {
    return false;
  }

  const firstRect = clientRects[0];

  for (let i = 1; i < clientRects.length; i++) {
    const rect = clientRects[i]; // 如果存在选区块错层，则断定存在换行

    if (rect.top >= firstRect.bottom || rect.bottom <= firstRect.top) {
      return true;
    }
  }

  return false;
}
/**
 * 判断选区是否由表格工具栏操作，注释见下方
 * 解决从表格工具栏点击，表格选区变化时，极简工具栏位置不变的问题
 * 之前花过一些时间尝试从表格选区数据 diff 下手
 * 但无可避免的产生了一些误伤，例如在表格选区下调整字体大小，在一些操作后会使极简工具栏抖动
 * 所以改为从 UI 判定下手
 */


function isTargetFromTableToolbar(target) {
  if (!target) {
    return false;
  }

  return target.getAttribute('data-cangjie-col-toolbar-item') || target.getAttribute('data-cangjie-row-toolbar-item') || target.getAttribute('data-cangjie-cornel-toolbar');
}
/**
 * 由于表格边缘有行列工具栏的存在，因此为了避免toolbar遮挡住工具栏，需要将其往上抬升8个px
 * 满足以下两个条件时需要抬升
 * 1. 选中首行
 * 2. 选中一列或多列
 */


function isSelectedTableFirstRow(tableSelection) {
  const {
    startRowIndex
  } = tableSelection;
  return startRowIndex === 0;
}
/**
 * 判断是否是选中表格行
 * 背景：选中行的时候工具栏位于行头右侧8px处
 * 多行的情况工具栏居于上方中部位置也是更符合用户习惯
 */


function isSelectedSingleTableRow(tableSelection) {
  const {
    startRowIndex,
    endRowIndex
  } = tableSelection;
  return startRowIndex === endRowIndex;
}

const CUSTOM_PANEL_INPUT_FLAG = 'custom-color-input';

const Trigger = props => {
  const {
    controller,
    content,
    container,
    toolbarLayout,
    moreToolbarLayout,
    customToolButtons
  } = props;
  const [context] = (0, _context.useSelectionBarContext)();
  const {
    canHide
  } = context;
  const boxRef = React.useRef(null);
  const tableRef = React.useRef(null);
  const transformRef = React.useRef(true); // 右键呼出菜单的时候需要隐藏工具栏

  const isRightMouseDown = React.useRef(false);
  const {
    value
  } = controller;
  const [state, setState] = React.useState(INITIAL_STATE); // 是否修正定位

  const alignRef = React.useRef(false); // 工具栏可见性

  const visibleRef = React.useRef(state.visible);
  visibleRef.current = state.visible; // 当前鼠标是否按住

  const pressRef = React.useRef(false); // 当前右键菜单是否可见

  const contextMenuVisibleRef = React.useRef(false);
  const activeRef = React.useRef('');
  const [activeType, setActiveType] = useActiveInteraction();
  activeRef.current = activeType; // table constants

  const {
    TOOLBAR_ITEM_SIZE: TABLE_ROW_TOOLBAR_HEIGHT,
    SPACING
  } = React.useMemo(() => {
    return controller.query('getTableConstants') || {
      /**
       * 表格行工具栏高度
       * 为避免toolbar遮挡表格行工具栏，SelectionBar 选中表格首行时需要向上偏移该高度
       */
      TOOLBAR_ITEM_SIZE: 8,
      SPACING: 16
    };
  }, [controller]);
  React.useEffect(() => {
    // 选区工具栏可见时更新当前激活的类型
    if (state.visible) {
      activeRef.current !== 'selectionBar' && setActiveType('selectionBar');
    } else if (activeRef.current === 'selectionBar') {
      setActiveType('');
    }
  }, [state.visible, setActiveType]);
  /**
   * 展示选区工具栏
   * @description 非重叠光标选区渲染工具栏，由于工具栏高度固定，所以挂载时可以订正垂直位置
   */

  const display = React.useCallback(() => {
    const {
      selection: newSelection,
      document
    } = controller.value; // 如果 Range 不存在则不处理
    // TODO: 在 void 元素的场景下和选区的范围不之一，后续考虑使用视图上 range 的大小

    const domRange = _everCangjie.domUtils.findDOMRange(newSelection, controller, content); // 右键菜单显示的情况下不展示工具栏


    if (!domRange || isRightMouseDown.current || contextMenuVisibleRef.current) {
      return;
    }

    const clientRects = Array.from(domRange.getClientRects());

    if (clientRects.length <= 0) {
      return;
    }

    const tableSelection = controller.query('getTableSelection');
    let tableRect = null;
    let tablePos;
    const contentRect = content.getBoundingClientRect();
    const contentContainerDistance = content.offsetTop - container.offsetTop; // 定位方向

    let placement; // x 偏移量

    let x; // y 偏移量

    let y; // 光标落点 Range Rect (Focus Range Rect)

    let clientRect;
    let isSelectWholeRow = false;
    /**
     * 产品要求在表格中选中文字浮动工具栏尽量不要超出表格的左右区域
     * 这里的解决办法是如果在表格中选中文字就把当前表格的dom对象保
     * 存到tableRef中，在进行位置修正的时候如果tableRef不为null
     * 则使用tableRef作为contanier进行位置修正，否则使用传入的contaner
     * 进行位置修正
     */

    if (controller.query('isSelectionInTableCell') || tableSelection) {
      const table = getTable(controller);
      const tableDOMNode = table && (0, _everUtils.findDOMNodeByKey)(table.key);

      if (table && tableDOMNode) {
        tableRef.current = tableDOMNode;
      }
    } else {
      // 不在表格中选区的时候需要初始化tableRef，使其在位置修正的时候使用传入的container进行修正
      tableRef.current = null;
    }

    if (tableSelection && !controller.query('isSelectionInTableCell')) {
      const table = getTable(controller);
      let tableDOMNode = table && (0, _everUtils.findDOMNodeByKey)(table.key);

      if (tableDOMNode && !(tableDOMNode instanceof HTMLTableElement)) {
        tableDOMNode = tableDOMNode.querySelector('table');
      }

      if (table && tableDOMNode) {
        isSelectWholeRow = !!controller.query('isSelectWholeRow', {
          // @ts-ignore
          node: table
        }); // 表格的选区计算逻辑，TODO: scale 计算

        tablePos = controller.query('calcTableSelectionPos', {
          tblSelection: tableSelection,
          // @ts-ignore
          table,
          tableNode: tableDOMNode,
          scale: 1
        });
        tableRect = tableDOMNode.getBoundingClientRect();
      }
    }

    if (tableRect && tableSelection && tablePos) {
      const pos = tablePos;
      clientRect = { ...tableRect,
        width: tablePos.width,
        height: tablePos.height,
        left: tableRect.x + pos.left,
        x: tableRect.x + pos.left,
        top: tableRect.y + pos.top,
        y: tableRect.y + pos.top
      }; // 第一行被选中遮挡工具栏，强制置于下方，其他情况下依据选区方向

      if (newSelection.isForward(document)) {
        placement = 'bottom';
        const isSelectRow = isSelectedSingleTableRow(tableSelection) && isSelectWholeRow;

        if (isSelectRow) {
          // 选中行的时候浮动工具栏位置位于选中行头工具栏右侧
          x = tableRect.x - contentRect.x;
          transformRef.current = false;
          tableRef.current = null;
        } else {
          x = tableRect.x + pos.left + pos.width / 2 - contentRect.x;
          transformRef.current = true;
        }

        y = tableRect.y + pos.top + pos.height - contentRect.y;
        y += SELECTION_BAR_GAP;
      } else {
        placement = 'top';
        const shouldFixOffsetTop = isSelectedTableFirstRow(tableSelection);
        const isSelectRow = isSelectedSingleTableRow(tableSelection) && isSelectWholeRow;

        if (isSelectRow) {
          // 选中行的时候浮动工具栏位置位于选中行头工具栏右侧
          x = tableRect.x - contentRect.x;
          transformRef.current = false;
          tableRef.current = null;
        } else {
          x = tableRect.x + pos.left + pos.width / 2 - contentRect.x;
          transformRef.current = true;
        }

        y = tableRect.y + pos.top - contentRect.y;
        y -= SELECTION_BAR_GAP;

        if (shouldFixOffsetTop) {
          // 选中第一行时不能遮挡表格插入按钮
          y -= TABLE_ROW_TOOLBAR_HEIGHT * 2 + SPACING;
        }
      }
    } else if (newSelection.isForward(document)) {
      clientRect = clientRects[clientRects.length - 1];

      if (isBreakLine(clientRects)) {
        placement = 'bottom';
        x = clientRect.x + clientRect.width - contentRect.x;
        y = clientRect.y + clientRect.height - contentRect.y;
        y += SELECTION_BAR_GAP;
      } else {
        placement = 'top';
        x = clientRect.x + clientRect.width - contentRect.x;
        y = clientRect.y - contentRect.y;
        y -= SELECTION_BAR_GAP;
      }
    } else {
      clientRect = clientRects[0];
      placement = 'top';
      x = clientRect.x - contentRect.x;
      y = clientRect.y - contentRect.y;
      y -= SELECTION_BAR_GAP;
    }
    /**
     * 若定位超出视口上方，则平移至当前 clientRect 下方
     */


    if (placement === 'top' && y + contentContainerDistance - _SelectionBar.SELECTION_BAR_HEIGHT - VIEWPORT_GAP < container.scrollTop) {
      placement = 'bottom';
      y = clientRect.y + clientRect.height - contentRect.y;
      y += SELECTION_BAR_GAP;
    }
    /**
     * 若定位超出视口下方，则平移至当前 clientRect 上方
     */


    if (placement === 'bottom' && y + contentContainerDistance + _SelectionBar.SELECTION_BAR_HEIGHT + VIEWPORT_GAP > container.scrollTop + container.clientHeight) {
      placement = 'top';
      y = clientRect.y - contentRect.y;
      y -= SELECTION_BAR_GAP; // table 不平移，暂时不展示
      // if (tableSelection && tableSelection.startRowIndex === 0) {
      //   return;
      // }
    } // 开启定位偏移修正


    alignRef.current = true;
    setState({
      visible: true,
      placement,
      x,
      y
    });
  }, [container, content, controller]); // value 变化后，修正位置

  React.useEffect(() => {
    if (boxRef?.current) {
      alignRef.current = true;
      handleAnimationInStart(boxRef.current);
    }
  }, [value]);
  const handleMouseDown = React.useCallback(event => {
    const targetFromTableToolbar = isTargetFromTableToolbar(event.target);
    pressRef.current = true; // 需要与右键菜单互斥，因此这里判断鼠标点击事件是否为右键，是的话则不显示工具栏

    isRightMouseDown.current = event.button === 2; // 在点击表格工具栏 mouseDown 时选区消失，mouseUp 时再出现
    // 一定要完整的执行 消失 -> 出现 这个闭环，才能触发选区动画，以及位置校正逻辑
    // 这是最简单有效的做法，其他做法容易让时序乱套，或者把代码改乱

    if (targetFromTableToolbar || isRightMouseDown.current) {
      setState(prevState => ({ ...prevState,
        visible: false
      }));
    }
  }, []);
  const handleMouseUp = React.useCallback(() => {
    pressRef.current = false;
    const {
      selection,
      isBlurred
    } = controller.value;
    const {
      isByTable
    } = selection.data; // 通过工具栏选中仅一个单元格时，selection.isCollapsed 为 true，需要额外处理

    const isCollapsed = selection.isCollapsed && !isByTable; // 选中列表符号，显示工具栏

    if (controller.query('isSelectionInListSymbol')) {
      display();
      return;
    } // 重叠光标选区不处理


    if (isBlurred || isCollapsed || visibleRef.current) {
      return;
    }

    display();
  }, [controller, display]);
  const handleMouseMove = React.useCallback((0, _lodash.throttle)(() => {
    if (pressRef.current) {
      return;
    } // 有其他类型激活时，不触发选区工具栏


    const hasOtherActiveInteraction = activeRef.current && activeRef.current !== 'selectionBar';
    const {
      selection,
      isBlurred
    } = controller.value; // 重叠光标选区不处理

    if (isBlurred || selection.isCollapsed || visibleRef.current || hasOtherActiveInteraction) {
      return;
    }

    display();
  }), [controller, display]);
  /**
   * 工具栏渲染前，订正 X 偏移量
   */

  const handleAnimationInStart = React.useCallback(ref => {
    if (!ref || !alignRef.current) {
      return;
    }

    const Nearesetcontainer = tableRef.current ? tableRef.current : container;
    const containerRect = Nearesetcontainer.getBoundingClientRect();
    const contentRect = content.getBoundingClientRect();
    const rect = ref.getBoundingClientRect(); // 超出左侧

    if (rect.left - VIEWPORT_GAP < containerRect.left) {
      const x = containerRect.left - contentRect.left + rect.width / 2 + VIEWPORT_GAP;
      setState(prevState => ({ ...prevState,
        x
      }));
    } // 超出右侧


    if (rect.right + VIEWPORT_GAP > containerRect.right) {
      const scrollBarWidth = Nearesetcontainer.offsetWidth - Nearesetcontainer.clientWidth;
      setState(prevState => ({ ...prevState,
        x: prevState.x - (rect.right - containerRect.right) - scrollBarWidth - VIEWPORT_GAP
      }));
    } // 禁止定位偏移修正


    alignRef.current = false;
  }, [container, content]);
  /**
   * 处理自定义事件（右键菜单显示隐藏）
   */

  const handleCustomEvent = React.useCallback(e => {
    const {
      visible
    } = e.detail;
    contextMenuVisibleRef.current = visible;
  }, []);
  const {
    visible,
    placement,
    x,
    y
  } = state;

  const hideSelectionBar = () => {
    const {
      selection,
      isBlurred
    } = controller.value; // 通过工具栏选中仅一个单元格时，selection.isCollapsed 为 true，需要额外处理

    const isCollapsed = selection.isCollapsed && !selection.data.isByTable; // 当 focus 到 自定义色板的输入框时, selectionBar 不隐藏

    const isFocusInCustomColorPanel = document.activeElement?.getAttribute('data-testid') === CUSTOM_PANEL_INPUT_FLAG; // fix: https://aone.alibaba-inc.com/v2/bug/36320509# 《选中文字点击空白处无法取消选中

    if (canHide && visible && (isCollapsed || isBlurred) && !controller.query('isSelectionInListSymbol') && !isFocusInCustomColorPanel) {
      setState(prevState => ({ ...prevState,
        visible: false
      }));
    }
  };
  /**
   * 选区折叠则隐藏工具栏
   */


  React.useEffect(hideSelectionBar); // 响应 pending selection 和 普通 selection 变化实时更新

  (0, _everCangjie.useSelectionData)(controller.selectionData$, null, hideSelectionBar, [controller.value.selection]);
  (0, _everCangjie.useSelectingHots)(controller, hideSelectionBar);
  React.useEffect(() => {
    // 监听contextMenuVisible变化需要挂载body上，因为事件源无法绑定到content上
    window.document.body.addEventListener(_everUtils.LEGAL_EVENT.contextMenuVisible, handleCustomEvent, true);
    content.addEventListener('mousedown', handleMouseDown, true);
    content.addEventListener('mouseup', handleMouseUp, true);
    content.addEventListener('mousemove', handleMouseMove, true);
    return () => {
      window.document.body.removeEventListener(_everUtils.LEGAL_EVENT.contextMenuVisible, handleCustomEvent, true);
      content.removeEventListener('mousedown', handleMouseDown, true);
      content.removeEventListener('mouseup', handleMouseUp, true);
      content.removeEventListener('mousemove', handleMouseMove, true);
    };
  }, [content, handleMouseDown, handleMouseMove, handleMouseUp, handleCustomEvent]); // 容器内容高度变化后，需要重新计算工具栏的位置

  React.useEffect(() => {
    let resizeObserver;
    const handleResize = (0, _lodash.throttle)(() => {
      display();
      handleAnimationInStart(boxRef.current);
    }, 50);

    if (visible && content && (0, _lodash.isElement)(content)) {
      resizeObserver = new _resizeObserverPolyfill.default(handleResize);
      resizeObserver.observe(content);
    }

    return () => {
      resizeObserver?.disconnect();
    };
  }, [visible, content, display, handleAnimationInStart]);
  return /*#__PURE__*/_createElement(BasicPortal, {
    container: content
  }, /*#__PURE__*/_createElement(_SelectionBar.default, {
    needTransform: transformRef.current,
    ref: boxRef,
    toolbarLayout: toolbarLayout,
    moreToolbarLayout: moreToolbarLayout,
    onAnimationInStart: handleAnimationInStart,
    controller: controller,
    content: content,
    visible: visible,
    placement: placement,
    x: x,
    y: y,
    customToolButtons: customToolButtons
  }));
};

Trigger.displayName = 'Trigger';

const TriggerContainer = props => {
  const controller = _everCangjie.Controller.useController();

  const {
    getScrollableContainer,
    getScrollableContent,
    ...rest
  } = props;
  const container = getScrollableContainer();
  const content = getScrollableContent();

  if (!container || !content) {
    return null;
  }

  return /*#__PURE__*/_createElement(Trigger, (0, _extends2.default)({}, rest, {
    container: container,
    content: content,
    controller: controller
  }));
};

TriggerContainer.displayName = 'TriggerContainer';
var _default = TriggerContainer;
exports.default = _default;
//# sourceMappingURL=Trigger.js.map