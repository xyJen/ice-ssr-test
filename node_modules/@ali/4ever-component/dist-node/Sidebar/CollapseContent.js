"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var React = _interopRequireWildcard(require("react"));

var _styledComponents = _interopRequireDefault(require("styled-components"));

var _classnames = _interopRequireDefault(require("classnames"));

// 复用的 HeadingGroupPlugin.Content
const _createElement = /*#__PURE__*/React.createElement;

const ContentBox = /*#__PURE__*/_styledComponents.default.div(["&.transition{max-height:", "px;transition:all 0.2s ease-in-out;overflow:hidden;&.fold{display:block;}}&.fold{max-height:0;overflow:hidden;display:none;}"], props => props.maxHeight);

const PocketBox = /*#__PURE__*/_styledComponents.default.div([":first-child > [data-cangjie-leaf-block] > *{margin-top:0 !important;}& >:first-child > [data-name=\"heading-group-title\"] > [data-name=\"heading-group-title-content\"] > [data-cangjie-leaf-block] > *{margin-top:0 !important;}"]);

const Content = props => {
  const {
    fold,
    animate = true,
    style,
    className,
    dataName,
    children
  } = props;
  const foldRef = React.useRef(fold);
  const contentRef = React.useRef(null);
  const pocketRef = React.useRef(null);
  const heightRef = React.useRef(0);
  const [internalFold, setInternalFold] = React.useState(fold);
  const [transition, setTransition] = React.useState(false);
  /**
   * 动画结束后移除动画类名
   */

  const handleTransitionEnd = React.useCallback(() => {
    setTransition(false);
  }, []);
  /**
   * 每次更新后刷新内容高度
   */

  React.useLayoutEffect(() => {
    if (pocketRef.current) {
      const pocket = pocketRef.current;
      heightRef.current = pocket.offsetHeight;
    }
  });
  /**
   * 折叠状态发生变化时，先开启 transition，再变更状态
   */

  React.useLayoutEffect(() => {
    if (fold !== foldRef.current) {
      if (animate) {
        setTransition(true);
      } else {
        setTransition(false);
        setInternalFold(fold);
      }

      foldRef.current = fold;
    }
  }, [animate, fold]);
  /**
   * 开启 transition 后变更 fold 状态
   */

  React.useLayoutEffect(() => {
    if (transition) {
      setInternalFold(fold);
    }
  }, [transition, fold]);
  const classNames = (0, _classnames.default)({
    transition,
    fold: internalFold
  });
  return /*#__PURE__*/_createElement(ContentBox, {
    ref: contentRef,
    className: classNames,
    style: style,
    maxHeight: heightRef.current,
    onTransitionEnd: handleTransitionEnd
  }, /*#__PURE__*/_createElement(PocketBox, {
    ref: pocketRef,
    "data-name": dataName,
    "data-heading-fold": fold,
    className: className
  }, children));
};

Content.displayName = 'Content';
var _default = Content;
exports.default = _default;
//# sourceMappingURL=CollapseContent.js.map