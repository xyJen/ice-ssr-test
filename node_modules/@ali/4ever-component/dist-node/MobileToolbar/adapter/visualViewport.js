"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useVisualboxTransfrom = useVisualboxTransfrom;

var React = _interopRequireWildcard(require("react"));

const DEBOUNCE_TIME = 300;
/**
 * measureNode 用来获取 window 的高度。
 * window.innerHeight 在滚动到键盘靠底部时候，返回的值不稳定[viewport.height - 808]
 * 因此这里参考了 MDN visual box 里面的示例代码，用了一个 fake 元素获取 boundingClient.height
 */

function setStyle(node, measureNode) {
  const {
    height: windowHeight
  } = measureNode.getBoundingClientRect(); // @ts-ignore

  const viewport = window.visualViewport;
  const offsetX = viewport.offsetLeft;
  const offsetY = viewport.height - windowHeight + viewport.offsetTop;
  const newTransform = 'translate3d(' + offsetX + 'px,' + offsetY + 'px, 0) ' + 'scale(' + 1 / viewport.scale + ')';
  node.style.transition = 'opacity 150ms';
  requestAnimationFrame(() => {
    node.style.opacity = '1';
    node.style.transform = newTransform;
    setTimeout(() => {
      node.style.transition = 'none';
    }, 150);
  });
}
/**
 * 处理 iOS 浏览器的键盘弹出问题。
 * 钉钉容器内不需要此部分逻辑
 */


function useVisualboxTransfrom(ref, measureRef, isDiabled) {
  const timerRef = React.useRef(null);
  const viewportHandler = React.useCallback(() => {
    // @ts-ignore
    if (!window.visualViewport || isDiabled) {
      return undefined;
    }

    if (timerRef.current !== null) {
      clearTimeout(timerRef.current);
    } else if (ref.current) {
      ref.current.style.opacity = '0';
    }

    timerRef.current = setTimeout(() => {
      if (ref.current && measureRef.current) {
        setStyle(ref.current, measureRef.current);
      }

      timerRef.current = null;
    }, DEBOUNCE_TIME);
    return () => {
      if (timerRef.current !== null) {
        clearTimeout(timerRef.current);
        timerRef.current = null;
      }
    };
  }, []);
  React.useEffect(() => {
    // @ts-ignore
    if (!window.visualViewport || isDiabled) {
      return undefined;
    } // 往上滑动的时候，会把底部条划走；虽然有实时计算，但是比 UI 更新较晚，用户看到闪烁
    // 这里采用的方式，是滑动的时候先隐藏起来、滑动停止之后再渐变显示


    window.addEventListener('scroll', viewportHandler, {
      passive: false
    });
    window.visualViewport.addEventListener('scroll', viewportHandler);
    window.visualViewport.addEventListener('resize', viewportHandler);
    return () => {
      window.removeEventListener('scroll', viewportHandler);
      window.visualViewport.removeEventListener('scroll', viewportHandler);
      window.visualViewport.removeEventListener('resize', viewportHandler);
    };
  }, [isDiabled, viewportHandler]);
}
//# sourceMappingURL=visualViewport.js.map