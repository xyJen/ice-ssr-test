"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Portal = void 0;

var React = _interopRequireWildcard(require("react"));

var ReactDOM = _interopRequireWildcard(require("react-dom"));

var _lodash = require("lodash");

/* eslint-disable import/no-extraneous-dependencies */
const _createElement = /*#__PURE__*/React.createElement;

class Portal extends React.Component {
  constructor(...args) {
    super(...args);
    this.triggerRef = /*#__PURE__*/React.createRef();
    this.portalRef = /*#__PURE__*/React.createRef();
    this.updatePortalPosition = (0, _lodash.throttle)(() => {
      const {
        visible,
        container,
        portalMatchTrigger,
        portalRef,
        triggerRef,
        getPosition,
        zoom = 1,
        maxWidth
      } = this.props;

      if (!visible) {
        return;
      } // eslint-disable-next-line react/no-find-dom-node


      const trigger = ReactDOM.findDOMNode(triggerRef ? triggerRef.current : this.triggerRef.current); // eslint-disable-next-line react/no-find-dom-node

      const portal = ReactDOM.findDOMNode(portalRef ? portalRef.current : this.portalRef.current);

      if (!trigger || !portal) {
        return;
      }

      const triggerRect = trigger.getBoundingClientRect();

      if (!triggerRect) {
        return;
      }

      const {
        offset,
        position
      } = this.props;
      const [offsetX, offsetY] = offset;
      const containerRect = container.getBoundingClientRect();
      const top = triggerRect.bottom - containerRect.top;
      const left = triggerRect.left - containerRect.left;
      const portalRect = portal.getBoundingClientRect();
      const {
        height,
        width
      } = portalRect;

      if (portalMatchTrigger) {
        const width = maxWidth ? Math.min(maxWidth, triggerRect.width) : triggerRect.width;
        portal.style.minWidth = `${width}px`;
      }
      /**
       * zoom 场景下，left 和 top 需要乘以 zoom
       * ┌────────┬────────────┐                      ┌──────────────┬───────────────┐
       * │        │            │                      │              │               │
       * │        │ left       │        zoom          │              │               │
       * ├────────┘            │  ────────────────►   │              │ left * zoom   │
       * │   top               │                      │              │               │
       * │                     │                      ├──────────────┘               │
       * │                     │                      │  top * zoom                  │
       * └─────────────────────┘                      │                              │
       *                                              │                              │
       *                                              │                              │
       *                                              └──────────────────────────────┘
       * 我们这边使用 getBoundingClientRect 获取的是相对 viewport 的数据
       * 在 zoom 情况下，需要除以 zoom 获得真实的 style 设置
       * 
       * ┌────────┬────────────┐                      ┌──────────────┬───────────────┐
       * │        │            │                      │              │               │
       * │        │left / zoom │          zoom        │              │               │
       * ├────────┘            │  ◄─────────────────  │              │ left          │
       * │ top / zoom          │                      │              │               │
       * │                     │                      ├──────────────┘               │
       * │                     │                      │      top                     │
       * └─────────────────────┘                      │                              │
       *                                              │                              │
       *                                              │                              │
       *                                              └──────────────────────────────┘
       */

      /* 当有外部传入固定position时，优先采用position */


      if (position) {
        // position 的绝对位置，不受 zoom 影响
        portal.style.top = `${position.top}px`;
        portal.style.left = `${position.left}px`;
      } else if (getPosition && typeof getPosition === 'function') {
        const {
          left: computedLeft,
          top: computedTop
        } = getPosition(containerRect, triggerRect, portalRect);
        portal.style.top = `${computedTop / zoom}px`;
        portal.style.left = `${computedLeft / zoom}px`;
      } else {
        // 计算底部剩余空间，若剩余空间能够容纳 portal，则向下展示 portal
        // 如果下方剩余空间无法容纳 portal，还需要判断上方空间能否容纳
        // 若上方也无法容纳(triggerTop < height)，则仍然放到下方
        // 左右则优先放右侧
        const bottomSpace = containerRect.height - top;
        const rightSpace = containerRect.width - left;
        const triggerTop = triggerRect.top - containerRect.top;
        const triggerRight = triggerRect.right - containerRect.left;
        portal.style.top = bottomSpace < height && triggerTop > height ? `${(triggerTop + offsetY - height - 4) / zoom}px` // 放到上方
        : `${(top + offsetY) / zoom}px`;
        portal.style.left = rightSpace < width && triggerRight > width ? `${(left + offsetX - width - 4) / zoom}px` : `${(left + offsetX) / zoom}px`;
      }

      portal.style.zIndex = '999';
    });
  }

  componentDidMount() {
    this.updatePortalPosition();
  }

  componentDidUpdate() {
    this.updatePortalPosition();
  }

  componentWillUnmount() {
    this.updatePortalPosition.cancel();
  }

  render() {
    const {
      children,
      container,
      overlay,
      className,
      visible,
      destroyOverlayOnHide = true,
      portalRef,
      triggerRef
    } = this.props;
    return /*#__PURE__*/_createElement(React.Fragment, null, /*#__PURE__*/React.cloneElement(children, {
      ref: triggerRef || this.triggerRef
    }), visible || !destroyOverlayOnHide ? /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/_createElement("div", {
      className: className
    }, /*#__PURE__*/React.cloneElement(overlay, {
      ref: portalRef || this.portalRef
    })), container) : null);
  }

}

exports.Portal = Portal;
Portal.defaultProps = {
  offset: [0, 0],
  portalMatchTrigger: true,
  className: '',
  visible: false
};
//# sourceMappingURL=index.js.map