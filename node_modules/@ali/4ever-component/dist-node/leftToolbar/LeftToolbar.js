"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _lodash = require("lodash");

var _everCangjie = require("@ali/4ever-cangjie");

var _everLogger = _interopRequireDefault(require("@ali/4ever-logger"));

var _PluginsContext = require("../PluginsContext");

var _findBlockKeyFromEvent = _interopRequireDefault(require("./utils/findBlockKeyFromEvent"));

var _calcCurrentPos = _interopRequireDefault(require("./utils/calcCurrentPos"));

var _styled = require("./styled");

var _leftToolbarContext = require("./leftToolbarContext");

var _everUtils = require("@ali/4ever-utils");

var _isHotkey = require("is-hotkey");

const _createElement = /*#__PURE__*/_react.default.createElement;
const isEnterHotKey = (0, _isHotkey.isKeyHotkey)('enter');

const mouseMoveHandler = (event, container, updateHoverBlock, controller) => {
  if (!container.contains(event.target)) {
    updateHoverBlock();
    return;
  }

  const blockKey = (0, _findBlockKeyFromEvent.default)(event, container, controller);
  let block = controller.value.document.getNode(blockKey); // 如果leftToolbar的findBlockKeyFromEvent没有找到对应block，则再通过hoverBlock的方法进行查找
  // TODO 两套方法各自维护一套findBlockKeyFromEvent方法，后面需要统一

  if (block?.type === 'line') {
    block = controller.value.document.getParent(blockKey);
  }

  if (_everCangjie.Block.isBlock(block)) {
    updateHoverBlock(block);
  }
};

const LeftToolbar = props => {
  const {
    config,
    getScrollableContent,
    controller: initController
  } = props; // eslint-disable-next-line react-hooks/rules-of-hooks

  const controller = initController || _everCangjie.Controller.useController();

  const plugins = (0, _PluginsContext.usePlugins)();
  const container = getScrollableContent() || window.document.body;

  const isMoveDisabled = _react.default.useRef(false);

  const {
    focusBlock,
    selection
  } = controller.value;
  const [state, actions] = (0, _leftToolbarContext.useLeftToolbar)();
  const {
    block,
    preventMouseMove
  } = state;

  const isPreventMouseMove = _react.default.useRef(preventMouseMove);

  const canLeftToolbarVisibleRef = _react.default.useRef(true);

  const zoom = (0, _everCangjie.useZoom)();
  isPreventMouseMove.current = preventMouseMove;
  const disable = controller.query('disableLeftToolbar', {
    node: block
  });
  const position = (0, _react.useMemo)(() => {
    if (!block) return undefined; // 插件检测是否需要偏移

    return (0, _calcCurrentPos.default)(block, container);
  }, [block, container, controller]);
  const offsetWithFocus = (0, _react.useMemo)(() => {
    if (!block) return undefined; // 用于表格的场景，在focus的时候也要精确位置计算
    // query 过程中 controller 可能会变为 undefined

    try {
      return controller.query('getLeftToolbarOffsetWithFocus', {
        node: block
      });
    } catch (error) {
      _everLogger.default.warn(error);
    }

    return undefined;
  }, [block, controller, focusBlock]);
  const offset = (0, _react.useMemo)(() => {
    if (!block) return undefined; // query 过程中 controller 可能会变为 undefined

    try {
      return controller.query('getLeftToolbarOffset', {
        node: block
      });
    } catch (error) {
      _everLogger.default.warn(error);
    }

    return undefined;
  }, [block, controller]);
  const fixedPosition = (0, _react.useMemo)(() => {
    const value = offsetWithFocus || offset;
    return value ? { ...position,
      right: Number(position?.right) - value.x || 0,
      // @ts-ignore
      top: position?.top + value.y || 0
    } : position;
  }, [position, offset, offsetWithFocus]);
  const onKeyDown = (0, _react.useCallback)(event => {
    if (isEnterHotKey(event)) {
      actions.updateHoverBlock();
    }
  }, [actions]);
  const onScroll = (0, _react.useCallback)((0, _lodash.throttle)(() => {
    if (isPreventMouseMove.current) return;
    actions.updateHoverBlock();
  }, 1000), [actions]);
  const handleMouseMove = (0, _react.useCallback)((0, _lodash.throttle)(mouseMoveHandler, 50), []); // 确保依赖是稳定的，不然会频繁监听和卸载事件监听

  const onMouseMove = (0, _react.useCallback)(event => {
    // 如果外部组件比如SelectionBar设置了需要禁用左侧工具栏，则需要将左侧工具栏隐藏
    // 浮动工具栏显示到时候需要隐藏掉左侧工具栏按钮
    const shouldDisabledLeftToolbar = !canLeftToolbarVisibleRef.current;

    if (isPreventMouseMove.current || isMoveDisabled.current || shouldDisabledLeftToolbar) {
      if (shouldDisabledLeftToolbar) {
        actions.updateHoverBlock();
      }

      return;
    }

    handleMouseMove(event, container, actions.updateHoverBlock, controller);
  }, [handleMouseMove, container, actions.updateHoverBlock, controller]); // 提供一个对外的事件，方便操作左侧工具栏的状态，原先leftToolbarHandlers的方式过于复杂

  const handleCustomEvent = _react.default.useCallback(e => {
    const {
      enable,
      clear
    } = e.detail;

    if (clear) {
      actions.updateHoverBlock();
    }

    canLeftToolbarVisibleRef.current = enable;
  }, [actions.updateHoverBlock]);

  (0, _react.useEffect)(() => {
    actions.updateHoverBlock();
  }, [zoom, actions.updateHoverBlock]);
  (0, _react.useEffect)(() => {
    // 新的产品逻辑要求输入的时候左侧工具栏不隐藏
    window.document.addEventListener('mousemove', onMouseMove);
    window.document.addEventListener('keydown', onKeyDown);
    window.document.addEventListener('scroll', onScroll, true);
    window.document.body.addEventListener(_everUtils.LEGAL_EVENT.leftToolbarEnable, handleCustomEvent);
    return () => {
      window.document.removeEventListener('mousemove', onMouseMove);
      window.document.removeEventListener('keydown', onKeyDown);
      window.document.removeEventListener('scroll', onScroll, true);
      window.document.body.removeEventListener(_everUtils.LEGAL_EVENT.leftToolbarEnable, handleCustomEvent);
    };
  }, [onMouseMove, handleCustomEvent, onKeyDown, onScroll]); // 把拖拽的临时启动、禁用，提供给外部使用。
  // 其他可能与拖拽冲突的插件，就可以控制拖拽杆的禁用、隐藏。

  (0, _react.useEffect)(() => {
    const arrays = plugins?.array || [];
    const listenerArrays = arrays.reduce((arr, p) => {
      // @ts-ignore
      const array = p?.leftToolbarHandlers;

      if (array) {
        arr.push(array);
      }

      return arr;
    }, []);
    const handler = {
      disable: () => {
        actions.updateHoverBlock();
        handleMouseMove.cancel();
        isMoveDisabled.current = true;
      },
      enable: () => {
        isMoveDisabled.current = false;
      },
      clear: () => {
        actions.updateHoverBlock();
        isMoveDisabled.current = false;
      }
    };

    const getHandler = () => {
      return handler;
    };

    listenerArrays.forEach(la => la.push(getHandler));
    return () => {
      listenerArrays.forEach(la => la.splice(la.indexOf(getHandler), 1));
    };
  }, [actions, plugins, controller, handleMouseMove]);
  const renderToolBtn = (0, _react.useMemo)(() => {
    if (!plugins || !block || !config) {
      return null;
    }

    return config.map(item => {
      if (item.btn) {
        return item.btn;
      }

      const plugin = plugins?.hash[item.key];

      if (plugin && plugin.leftToolbar) {
        const ToolBtn = plugin.leftToolbar;
        return /*#__PURE__*/_createElement(ToolBtn, {
          key: `${item.key}_${block.key}`,
          controller: controller,
          currentBlock: block
        });
      }

      return null;
    });
  }, [plugins, block, config, controller, selection]);
  if (!renderToolBtn || disable) return null;
  return /*#__PURE__*/_createElement(_styled.LeftToolbarWrapper, {
    style: fixedPosition
  }, renderToolBtn);
};

var _default = props => {
  const {
    getScrollableContent
  } = props;
  const container = getScrollableContent?.() || window.document.body;
  return /*#__PURE__*/_reactDom.default.createPortal( /*#__PURE__*/_createElement(_everCangjie.ScrollableContentContext.Provider, {
    value: container
  }, /*#__PURE__*/_createElement(_leftToolbarContext.LeftToolbarProvider, null, /*#__PURE__*/_createElement(LeftToolbar, props))), container);
};

exports.default = _default;
//# sourceMappingURL=LeftToolbar.js.map