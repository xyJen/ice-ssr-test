"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getParentByAttributes = getParentByAttributes;
exports.default = findBlockKeyFromEvent;

var _everCangjie = require("@ali/4ever-cangjie");

/* eslint-disable @typescript-eslint/ban-ts-comment */
const HOT_AREA = 100;
const {
  leafBlock: leafBlockKey,
  key: cangjieKey,
  edgeSelectable,
  content: contentKey,
  editable
} = _everCangjie.constants.Selector;
const DRAG_BAR_KEY = 'data-drag-handler-key';
const COLUMN_SELECTOR = 'data-columns'; // 如果鼠标在 content 左侧，则往右侧偏移一部分，取新的元素。

const RIGHT_OFFSET = 20;
/** dom getParentByAttributes */

function getParentByAttributes(attribute, target) {
  if (!target || !target.parentElement) return null;
  const attributes = Array.isArray(attribute) ? attribute : [attribute];
  let found = target.parentElement;
  let result = null;

  while (found && !found.getAttribute(contentKey) && found !== window.document.body && found !== window.document.documentElement && !found.getAttribute(COLUMN_SELECTOR) && // 容器节点不再继续往上找
  !found.getAttribute('data-container-block')) {
    for (let i = 0; i < attributes.length; i++) {
      if (found.getAttribute(attributes[i])) {
        result = found;
      }
    }

    found = found.parentElement;
  }

  return result;
}
/**
 * 用于检查那种 data-leaf-block 被一层 wrapper 包裹的段落节点
 * 比如：列表
 */


const checkIsWrapperBlock = target => {
  if (!target) {
    return false;
  }

  return !!(target.querySelector('[data-callout-group]') || target.getAttribute('data-testid') === 'refblock-container');
};

const checkIsListWrapperBlock = target => {
  if (!target) {
    return false;
  }

  return !!(target.getAttribute('data-testid') === 'list');
};
/**
 * 根据鼠标移动事件查找文档 key
 * 策略：一直查找到文档内容根节点或 body/html
 * 优先使用支持
 * 其次使用 列表/leafBlock 节点
 * @param event
 * @param container
 */


function findBlockKeyFromEvent(event, container, controller) {
  let oriTarget = event.target;
  let blockKey = '';
  let edgeKey = ''; // 如果落在了拖拽栏上，直接返回对应的 key

  const parentDragBar = oriTarget?.closest(`[${DRAG_BAR_KEY}]`);
  const selfKey = parentDragBar?.getAttribute(DRAG_BAR_KEY) || oriTarget?.getAttribute(DRAG_BAR_KEY);

  if (selfKey) {
    return selfKey;
  }

  const editableNode = container?.querySelector(`[${editable}]`);

  if (editableNode) {
    const rect = editableNode.getBoundingClientRect();
    const {
      clientX,
      clientY
    } = event; // 兼容在左边 padding 区域也可以识别
    // @ts-ignore

    if (window.document.elementFromPoint && clientX >= rect.left - HOT_AREA && clientX <= rect.left) {
      // @ts-ignore
      oriTarget = window.document.elementFromPoint(rect.left + RIGHT_OFFSET, clientY);
    }
  }

  let target = oriTarget;
  let finnalBlock = null; // 1. 先尝试找 列表 或 leafBlock

  const blockEle = target?.getAttribute(leafBlockKey) ? target : getParentByAttributes([leafBlockKey], target);

  if (blockEle) {
    blockKey = blockEle.getAttribute(cangjieKey) || leafBlockKey;
    finnalBlock = blockEle;
  } else {
    target = oriTarget;
  } // 2. 遍历找到最上层的 edgeBlock（例如表格里的 edge block）


  const edgeEle = getParentByAttributes(edgeSelectable, target);

  if (edgeEle) {
    edgeKey = edgeEle.getAttribute(cangjieKey) || edgeKey;
    finnalBlock = edgeEle;
  }

  const edgeNode = controller.value.document.getNode(edgeKey); // TODO: 这里与 table 耦合，先写死，待改造

  if (_everCangjie.Block.isBlock(edgeNode) && edgeNode.type === 'table') {
    edgeKey = '';
  }

  let groupMapKey = '';

  if (!edgeKey && !blockKey && target && checkIsListWrapperBlock(target)) {
    const mapBlock = target.querySelector(`[${cangjieKey}]`);

    if (mapBlock) {
      groupMapKey = mapBlock.getAttribute(cangjieKey) || '';
      finnalBlock = mapBlock;
    }
  } else if (!edgeKey && !blockKey && target && checkIsWrapperBlock(target)) {
    groupMapKey = target.getAttribute(cangjieKey) || '';
    finnalBlock = target;
  }

  if (finnalBlock && checkIsWrapperBlock(finnalBlock)) {
    // 需要对这里的key进行一次重新定位
    const {
      y: eventY
    } = event;
    const firstBlock = finnalBlock.querySelector(`[${cangjieKey}]`);

    if (firstBlock) {
      const {
        y
      } = firstBlock?.getBoundingClientRect();

      if (eventY - y > 0) {
        return '';
      }
    }
  } // 优先级：edgeKey > leafBlockKey（比如在表格中）


  const finalKey = edgeKey || blockKey || groupMapKey;
  return finalKey || '';
}
//# sourceMappingURL=findBlockKeyFromEvent.js.map