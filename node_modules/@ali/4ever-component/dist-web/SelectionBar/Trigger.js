import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
import _extends from "@babel/runtime/helpers/extends";
import * as React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import * as ReactDOM from 'react-dom';
import { throttle, isElement } from 'lodash-es';
import ResizeObserver from 'resize-observer-polyfill';
import { Controller, domUtils, useSelectionData, useSelectingHots } from '@ali/4ever-cangjie';
import { LEGAL_EVENT, findDOMNodeByKey } from '@ali/4ever-utils';
import { default as SelectionBar, SELECTION_BAR_HEIGHT } from "./SelectionBar";
import { useSelectionBarContext } from "./context";
import { ActiveInteractionHooks } from "../HoverBlock/ActiveInteractionContext";

var getTable = function getTable(controller) {
  var _controller$value = controller.value,
      document = _controller$value.document,
      selection = _controller$value.selection;
  return document.getClosest(selection.getStart(document).key, function (n) {
    return !!controller.query('isTable', n);
  }) || null;
};

var useActiveInteraction = ActiveInteractionHooks.useActiveInteraction;

/**
 * 使用 ReactDOM.createPortal 渲染节点
 * @param props
 * @returns
 */
export var BasicPortal = function BasicPortal(props) {
  var children = props.children,
      container = props.container,
      key = props.key;
  return /*#__PURE__*/ReactDOM.createPortal(children, container, key);
};
BasicPortal.displayName = 'Portal';
var INITIAL_STATE = {
  visible: false,
  placement: 'top',
  x: 0,
  y: 0
};
/**
 * 工具栏视口边距
 */

var VIEWPORT_GAP = 4;
/**
 * SelectionBar 与文字之间的距离
 */

var SELECTION_BAR_GAP = 8;
/**
 * 判断一组选区是否有换行
 * @param clientRects
 */

function isBreakLine(clientRects) {
  // 如果只有单选区，则一定没有换行
  if (clientRects.length <= 1) {
    return false;
  }

  var firstRect = clientRects[0];

  for (var i = 1; i < clientRects.length; i++) {
    var rect = clientRects[i]; // 如果存在选区块错层，则断定存在换行

    if (rect.top >= firstRect.bottom || rect.bottom <= firstRect.top) {
      return true;
    }
  }

  return false;
}
/**
 * 判断选区是否由表格工具栏操作，注释见下方
 * 解决从表格工具栏点击，表格选区变化时，极简工具栏位置不变的问题
 * 之前花过一些时间尝试从表格选区数据 diff 下手
 * 但无可避免的产生了一些误伤，例如在表格选区下调整字体大小，在一些操作后会使极简工具栏抖动
 * 所以改为从 UI 判定下手
 */


function isTargetFromTableToolbar(target) {
  if (!target) {
    return false;
  }

  return target.getAttribute('data-cangjie-col-toolbar-item') || target.getAttribute('data-cangjie-row-toolbar-item') || target.getAttribute('data-cangjie-cornel-toolbar');
}
/**
 * 由于表格边缘有行列工具栏的存在，因此为了避免toolbar遮挡住工具栏，需要将其往上抬升8个px
 * 满足以下两个条件时需要抬升
 * 1. 选中首行
 * 2. 选中一列或多列
 */


function isSelectedTableFirstRow(tableSelection) {
  var startRowIndex = tableSelection.startRowIndex;
  return startRowIndex === 0;
}
/**
 * 判断是否是选中表格行
 * 背景：选中行的时候工具栏位于行头右侧8px处
 * 多行的情况工具栏居于上方中部位置也是更符合用户习惯
 */


function isSelectedSingleTableRow(tableSelection) {
  var startRowIndex = tableSelection.startRowIndex,
      endRowIndex = tableSelection.endRowIndex;
  return startRowIndex === endRowIndex;
}

var CUSTOM_PANEL_INPUT_FLAG = 'custom-color-input';

var Trigger = function Trigger(props) {
  var controller = props.controller,
      content = props.content,
      container = props.container,
      toolbarLayout = props.toolbarLayout,
      moreToolbarLayout = props.moreToolbarLayout,
      customToolButtons = props.customToolButtons;

  var _useSelectionBarConte = useSelectionBarContext(),
      context = _useSelectionBarConte[0];

  var canHide = context.canHide;
  var boxRef = React.useRef(null);
  var tableRef = React.useRef(null);
  var transformRef = React.useRef(true); // 右键呼出菜单的时候需要隐藏工具栏

  var isRightMouseDown = React.useRef(false);
  var value = controller.value;

  var _React$useState = React.useState(INITIAL_STATE),
      state = _React$useState[0],
      setState = _React$useState[1]; // 是否修正定位


  var alignRef = React.useRef(false); // 工具栏可见性

  var visibleRef = React.useRef(state.visible);
  visibleRef.current = state.visible; // 当前鼠标是否按住

  var pressRef = React.useRef(false); // 当前右键菜单是否可见

  var contextMenuVisibleRef = React.useRef(false);
  var activeRef = React.useRef('');

  var _useActiveInteraction = useActiveInteraction(),
      activeType = _useActiveInteraction[0],
      setActiveType = _useActiveInteraction[1];

  activeRef.current = activeType; // table constants

  var _React$useMemo = React.useMemo(function () {
    return controller.query('getTableConstants') || {
      /**
       * 表格行工具栏高度
       * 为避免toolbar遮挡表格行工具栏，SelectionBar 选中表格首行时需要向上偏移该高度
       */
      TOOLBAR_ITEM_SIZE: 8,
      SPACING: 16
    };
  }, [controller]),
      TABLE_ROW_TOOLBAR_HEIGHT = _React$useMemo.TOOLBAR_ITEM_SIZE,
      SPACING = _React$useMemo.SPACING;

  React.useEffect(function () {
    // 选区工具栏可见时更新当前激活的类型
    if (state.visible) {
      activeRef.current !== 'selectionBar' && setActiveType('selectionBar');
    } else if (activeRef.current === 'selectionBar') {
      setActiveType('');
    }
  }, [state.visible, setActiveType]);
  /**
   * 展示选区工具栏
   * @description 非重叠光标选区渲染工具栏，由于工具栏高度固定，所以挂载时可以订正垂直位置
   */

  var display = React.useCallback(function () {
    var _controller$value2 = controller.value,
        newSelection = _controller$value2.selection,
        document = _controller$value2.document; // 如果 Range 不存在则不处理
    // TODO: 在 void 元素的场景下和选区的范围不之一，后续考虑使用视图上 range 的大小

    var domRange = domUtils.findDOMRange(newSelection, controller, content); // 右键菜单显示的情况下不展示工具栏

    if (!domRange || isRightMouseDown.current || contextMenuVisibleRef.current) {
      return;
    }

    var clientRects = Array.from(domRange.getClientRects());

    if (clientRects.length <= 0) {
      return;
    }

    var tableSelection = controller.query('getTableSelection');
    var tableRect = null;
    var tablePos;
    var contentRect = content.getBoundingClientRect();
    var contentContainerDistance = content.offsetTop - container.offsetTop; // 定位方向

    var placement; // x 偏移量

    var x; // y 偏移量

    var y; // 光标落点 Range Rect (Focus Range Rect)

    var clientRect;
    var isSelectWholeRow = false;
    /**
     * 产品要求在表格中选中文字浮动工具栏尽量不要超出表格的左右区域
     * 这里的解决办法是如果在表格中选中文字就把当前表格的dom对象保
     * 存到tableRef中，在进行位置修正的时候如果tableRef不为null
     * 则使用tableRef作为contanier进行位置修正，否则使用传入的contaner
     * 进行位置修正
     */

    if (controller.query('isSelectionInTableCell') || tableSelection) {
      var table = getTable(controller);
      var tableDOMNode = table && findDOMNodeByKey(table.key);

      if (table && tableDOMNode) {
        tableRef.current = tableDOMNode;
      }
    } else {
      // 不在表格中选区的时候需要初始化tableRef，使其在位置修正的时候使用传入的container进行修正
      tableRef.current = null;
    }

    if (tableSelection && !controller.query('isSelectionInTableCell')) {
      var _table = getTable(controller);

      var _tableDOMNode = _table && findDOMNodeByKey(_table.key);

      if (_tableDOMNode && !(_tableDOMNode instanceof HTMLTableElement)) {
        _tableDOMNode = _tableDOMNode.querySelector('table');
      }

      if (_table && _tableDOMNode) {
        isSelectWholeRow = !!controller.query('isSelectWholeRow', {
          // @ts-ignore
          node: _table
        }); // 表格的选区计算逻辑，TODO: scale 计算

        tablePos = controller.query('calcTableSelectionPos', {
          tblSelection: tableSelection,
          // @ts-ignore
          table: _table,
          tableNode: _tableDOMNode,
          scale: 1
        });
        tableRect = _tableDOMNode.getBoundingClientRect();
      }
    }

    if (tableRect && tableSelection && tablePos) {
      var pos = tablePos;
      clientRect = _extends({}, tableRect, {
        width: tablePos.width,
        height: tablePos.height,
        left: tableRect.x + pos.left,
        x: tableRect.x + pos.left,
        top: tableRect.y + pos.top,
        y: tableRect.y + pos.top
      }); // 第一行被选中遮挡工具栏，强制置于下方，其他情况下依据选区方向

      if (newSelection.isForward(document)) {
        placement = 'bottom';
        var isSelectRow = isSelectedSingleTableRow(tableSelection) && isSelectWholeRow;

        if (isSelectRow) {
          // 选中行的时候浮动工具栏位置位于选中行头工具栏右侧
          x = tableRect.x - contentRect.x;
          transformRef.current = false;
          tableRef.current = null;
        } else {
          x = tableRect.x + pos.left + pos.width / 2 - contentRect.x;
          transformRef.current = true;
        }

        y = tableRect.y + pos.top + pos.height - contentRect.y;
        y += SELECTION_BAR_GAP;
      } else {
        placement = 'top';
        var shouldFixOffsetTop = isSelectedTableFirstRow(tableSelection);

        var _isSelectRow = isSelectedSingleTableRow(tableSelection) && isSelectWholeRow;

        if (_isSelectRow) {
          // 选中行的时候浮动工具栏位置位于选中行头工具栏右侧
          x = tableRect.x - contentRect.x;
          transformRef.current = false;
          tableRef.current = null;
        } else {
          x = tableRect.x + pos.left + pos.width / 2 - contentRect.x;
          transformRef.current = true;
        }

        y = tableRect.y + pos.top - contentRect.y;
        y -= SELECTION_BAR_GAP;

        if (shouldFixOffsetTop) {
          // 选中第一行时不能遮挡表格插入按钮
          y -= TABLE_ROW_TOOLBAR_HEIGHT * 2 + SPACING;
        }
      }
    } else if (newSelection.isForward(document)) {
      clientRect = clientRects[clientRects.length - 1];

      if (isBreakLine(clientRects)) {
        placement = 'bottom';
        x = clientRect.x + clientRect.width - contentRect.x;
        y = clientRect.y + clientRect.height - contentRect.y;
        y += SELECTION_BAR_GAP;
      } else {
        placement = 'top';
        x = clientRect.x + clientRect.width - contentRect.x;
        y = clientRect.y - contentRect.y;
        y -= SELECTION_BAR_GAP;
      }
    } else {
      clientRect = clientRects[0];
      placement = 'top';
      x = clientRect.x - contentRect.x;
      y = clientRect.y - contentRect.y;
      y -= SELECTION_BAR_GAP;
    }
    /**
     * 若定位超出视口上方，则平移至当前 clientRect 下方
     */


    if (placement === 'top' && y + contentContainerDistance - SELECTION_BAR_HEIGHT - VIEWPORT_GAP < container.scrollTop) {
      placement = 'bottom';
      y = clientRect.y + clientRect.height - contentRect.y;
      y += SELECTION_BAR_GAP;
    }
    /**
     * 若定位超出视口下方，则平移至当前 clientRect 上方
     */


    if (placement === 'bottom' && y + contentContainerDistance + SELECTION_BAR_HEIGHT + VIEWPORT_GAP > container.scrollTop + container.clientHeight) {
      placement = 'top';
      y = clientRect.y - contentRect.y;
      y -= SELECTION_BAR_GAP; // table 不平移，暂时不展示
      // if (tableSelection && tableSelection.startRowIndex === 0) {
      //   return;
      // }
    } // 开启定位偏移修正


    alignRef.current = true;
    setState({
      visible: true,
      placement: placement,
      x: x,
      y: y
    });
  }, [container, content, controller]); // value 变化后，修正位置

  React.useEffect(function () {
    if (boxRef != null && boxRef.current) {
      alignRef.current = true;
      handleAnimationInStart(boxRef.current);
    }
  }, [value]);
  var handleMouseDown = React.useCallback(function (event) {
    var targetFromTableToolbar = isTargetFromTableToolbar(event.target);
    pressRef.current = true; // 需要与右键菜单互斥，因此这里判断鼠标点击事件是否为右键，是的话则不显示工具栏

    isRightMouseDown.current = event.button === 2; // 在点击表格工具栏 mouseDown 时选区消失，mouseUp 时再出现
    // 一定要完整的执行 消失 -> 出现 这个闭环，才能触发选区动画，以及位置校正逻辑
    // 这是最简单有效的做法，其他做法容易让时序乱套，或者把代码改乱

    if (targetFromTableToolbar || isRightMouseDown.current) {
      setState(function (prevState) {
        return _extends({}, prevState, {
          visible: false
        });
      });
    }
  }, []);
  var handleMouseUp = React.useCallback(function () {
    pressRef.current = false;
    var _controller$value3 = controller.value,
        selection = _controller$value3.selection,
        isBlurred = _controller$value3.isBlurred;
    var isByTable = selection.data.isByTable; // 通过工具栏选中仅一个单元格时，selection.isCollapsed 为 true，需要额外处理

    var isCollapsed = selection.isCollapsed && !isByTable; // 选中列表符号，显示工具栏

    if (controller.query('isSelectionInListSymbol')) {
      display();
      return;
    } // 重叠光标选区不处理


    if (isBlurred || isCollapsed || visibleRef.current) {
      return;
    }

    display();
  }, [controller, display]);
  var handleMouseMove = React.useCallback(throttle(function () {
    if (pressRef.current) {
      return;
    } // 有其他类型激活时，不触发选区工具栏


    var hasOtherActiveInteraction = activeRef.current && activeRef.current !== 'selectionBar';
    var _controller$value4 = controller.value,
        selection = _controller$value4.selection,
        isBlurred = _controller$value4.isBlurred; // 重叠光标选区不处理

    if (isBlurred || selection.isCollapsed || visibleRef.current || hasOtherActiveInteraction) {
      return;
    }

    display();
  }), [controller, display]);
  /**
   * 工具栏渲染前，订正 X 偏移量
   */

  var handleAnimationInStart = React.useCallback(function (ref) {
    if (!ref || !alignRef.current) {
      return;
    }

    var Nearesetcontainer = tableRef.current ? tableRef.current : container;
    var containerRect = Nearesetcontainer.getBoundingClientRect();
    var contentRect = content.getBoundingClientRect();
    var rect = ref.getBoundingClientRect(); // 超出左侧

    if (rect.left - VIEWPORT_GAP < containerRect.left) {
      var _x = containerRect.left - contentRect.left + rect.width / 2 + VIEWPORT_GAP;

      setState(function (prevState) {
        return _extends({}, prevState, {
          x: _x
        });
      });
    } // 超出右侧


    if (rect.right + VIEWPORT_GAP > containerRect.right) {
      var scrollBarWidth = Nearesetcontainer.offsetWidth - Nearesetcontainer.clientWidth;
      setState(function (prevState) {
        return _extends({}, prevState, {
          x: prevState.x - (rect.right - containerRect.right) - scrollBarWidth - VIEWPORT_GAP
        });
      });
    } // 禁止定位偏移修正


    alignRef.current = false;
  }, [container, content]);
  /**
   * 处理自定义事件（右键菜单显示隐藏）
   */

  var handleCustomEvent = React.useCallback(function (e) {
    var visible = e.detail.visible;
    contextMenuVisibleRef.current = visible;
  }, []);
  var visible = state.visible,
      placement = state.placement,
      x = state.x,
      y = state.y;

  var hideSelectionBar = function hideSelectionBar() {
    var _document$activeEleme;

    var _controller$value5 = controller.value,
        selection = _controller$value5.selection,
        isBlurred = _controller$value5.isBlurred; // 通过工具栏选中仅一个单元格时，selection.isCollapsed 为 true，需要额外处理

    var isCollapsed = selection.isCollapsed && !selection.data.isByTable; // 当 focus 到 自定义色板的输入框时, selectionBar 不隐藏

    var isFocusInCustomColorPanel = ((_document$activeEleme = document.activeElement) == null ? void 0 : _document$activeEleme.getAttribute('data-testid')) === CUSTOM_PANEL_INPUT_FLAG; // fix: https://aone.alibaba-inc.com/v2/bug/36320509# 《选中文字点击空白处无法取消选中

    if (canHide && visible && (isCollapsed || isBlurred) && !controller.query('isSelectionInListSymbol') && !isFocusInCustomColorPanel) {
      setState(function (prevState) {
        return _extends({}, prevState, {
          visible: false
        });
      });
    }
  };
  /**
   * 选区折叠则隐藏工具栏
   */


  React.useEffect(hideSelectionBar); // 响应 pending selection 和 普通 selection 变化实时更新

  useSelectionData(controller.selectionData$, null, hideSelectionBar, [controller.value.selection]);
  useSelectingHots(controller, hideSelectionBar);
  React.useEffect(function () {
    // 监听contextMenuVisible变化需要挂载body上，因为事件源无法绑定到content上
    window.document.body.addEventListener(LEGAL_EVENT.contextMenuVisible, handleCustomEvent, true);
    content.addEventListener('mousedown', handleMouseDown, true);
    content.addEventListener('mouseup', handleMouseUp, true);
    content.addEventListener('mousemove', handleMouseMove, true);
    return function () {
      window.document.body.removeEventListener(LEGAL_EVENT.contextMenuVisible, handleCustomEvent, true);
      content.removeEventListener('mousedown', handleMouseDown, true);
      content.removeEventListener('mouseup', handleMouseUp, true);
      content.removeEventListener('mousemove', handleMouseMove, true);
    };
  }, [content, handleMouseDown, handleMouseMove, handleMouseUp, handleCustomEvent]); // 容器内容高度变化后，需要重新计算工具栏的位置

  React.useEffect(function () {
    var resizeObserver;
    var handleResize = throttle(function () {
      display();
      handleAnimationInStart(boxRef.current);
    }, 50);

    if (visible && content && isElement(content)) {
      resizeObserver = new ResizeObserver(handleResize);
      resizeObserver.observe(content);
    }

    return function () {
      var _resizeObserver;

      (_resizeObserver = resizeObserver) == null ? void 0 : _resizeObserver.disconnect();
    };
  }, [visible, content, display, handleAnimationInStart]);
  return /*#__PURE__*/_createElement(BasicPortal, {
    container: content
  }, /*#__PURE__*/_createElement(SelectionBar, {
    needTransform: transformRef.current,
    ref: boxRef,
    toolbarLayout: toolbarLayout,
    moreToolbarLayout: moreToolbarLayout,
    onAnimationInStart: handleAnimationInStart,
    controller: controller,
    content: content,
    visible: visible,
    placement: placement,
    x: x,
    y: y,
    customToolButtons: customToolButtons
  }));
};

Trigger.displayName = 'Trigger';

var TriggerContainer = function TriggerContainer(props) {
  var controller = Controller.useController();

  var getScrollableContainer = props.getScrollableContainer,
      getScrollableContent = props.getScrollableContent,
      rest = _objectWithoutPropertiesLoose(props, ["getScrollableContainer", "getScrollableContent"]);

  var container = getScrollableContainer();
  var content = getScrollableContent();

  if (!container || !content) {
    return null;
  }

  return /*#__PURE__*/_createElement(Trigger, _extends({}, rest, {
    container: container,
    content: content,
    controller: controller
  }));
};

TriggerContainer.displayName = 'TriggerContainer';
export default TriggerContainer;
//# sourceMappingURL=Trigger.js.map