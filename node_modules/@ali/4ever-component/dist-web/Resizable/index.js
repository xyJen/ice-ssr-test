import _extends from "@babel/runtime/helpers/extends";

/* eslint-disable @typescript-eslint/no-use-before-define */
import * as React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import { noop } from 'lodash-es';
import { getRelativeMouseEvent } from '@ali/4ever-utils';
import { useHover } from "../HoverBlock";
import { XHandle, YHandle, Mask, ResizableWrapper } from "./styled";
import HandleIcon from "./icon";

var isInRange = function isInRange(num, range) {
  return num >= range[0] && num <= range[1];
};

var showHandle = function showHandle(axisName) {
  return function (axis) {
    return axis === axisName || axis === 'all';
  };
};

var showYHandle = showHandle('y');
var showXHandle = showHandle('x');

var getRelatives = function getRelatives(event, ref) {
  var mouseEvent;

  if (window.TouchEvent && event instanceof window.TouchEvent) {
    mouseEvent = event.touches[0];
  } else {
    mouseEvent = event;
  }

  return getRelativeMouseEvent(mouseEvent, ref);
};

var _ref = /*#__PURE__*/_createElement(HandleIcon, null);

var Resizable = function Resizable(props) {
  var children = props.children,
      axis = props.axis,
      _props$className = props.className,
      className = _props$className === void 0 ? 'resizable' : _props$className,
      onResize = props.onResize,
      _props$onResizeStart = props.onResizeStart,
      onResizeStart = _props$onResizeStart === void 0 ? noop : _props$onResizeStart,
      _props$onResizeStop = props.onResizeStop,
      onResizeStop = _props$onResizeStop === void 0 ? noop : _props$onResizeStop,
      _props$widthRange = props.widthRange,
      widthRange = _props$widthRange === void 0 ? [0, Infinity] : _props$widthRange,
      _props$heightRange = props.heightRange,
      heightRange = _props$heightRange === void 0 ? [0, Infinity] : _props$heightRange,
      width = props.width,
      height = props.height,
      visible = props.visible,
      _props$style = props.style,
      style = _props$style === void 0 ? {} : _props$style,
      _props$speed = props.speed,
      speed = _props$speed === void 0 ? 1.0 : _props$speed,
      zoomContainer = props.zoomContainer,
      _props$innerRef = props.innerRef,
      innerRef = _props$innerRef === void 0 ? null : _props$innerRef,
      _props$handleStyle = props.handleStyle,
      handleStyle = _props$handleStyle === void 0 ? {} : _props$handleStyle,
      onClick = props.onClick,
      autoHeight = props.autoHeight,
      isActive = props.isActive,
      enableBorderHighlight = props.enableBorderHighlight;
  var dragging = React.useRef(false);
  var startPoint = React.useRef([0, 0, height]);
  var heightRef = React.useRef(height);
  var widthRef = React.useRef(width);

  var _useHover = useHover(enableBorderHighlight),
      isHover = _useHover[0],
      hoverHandlers = _useHover[1];

  function handleDragging(event) {
    if (dragging.current) {
      event.preventDefault();
      event.stopPropagation();

      var _getRelatives = getRelatives(event, zoomContainer),
          relativeX = _getRelatives.relativeX,
          relativeY = _getRelatives.relativeY;

      var _startPoint$current = startPoint.current,
          startX = _startPoint$current[0],
          startY = _startPoint$current[1],
          startHeight = _startPoint$current[2];
      var newWidth = (relativeX - startX) * speed + width;
      var newHeight = (relativeY - startY) * speed + startHeight;

      if (showYHandle(axis) && isInRange(newHeight, heightRange)) {
        heightRef.current = newHeight;
        onResize(event, {
          width: width,
          height: newHeight
        });
      } else if (showXHandle(axis) && isInRange(newWidth, widthRange)) {
        widthRef.current = newWidth;
        onResize(event, {
          width: newWidth,
          height: startHeight
        });
      }
    }
  }

  function handleDragStop(event) {
    if (dragging.current && isInRange(heightRef.current, heightRange) && isInRange(widthRef.current, widthRange)) {
      dragging.current = false;
      unbindEvents();
      onResizeStop(event, {
        height: heightRef.current,
        width: widthRef.current
      });
    }
  }

  function handleDragStart(event) {
    event.preventDefault();
    event.stopPropagation();

    var _getRelatives2 = getRelatives(event.nativeEvent, zoomContainer),
        relativeX = _getRelatives2.relativeX,
        relativeY = _getRelatives2.relativeY;

    dragging.current = true;
    var startHeight = autoHeight && innerRef ? innerRef.current.getBoundingClientRect().height : height;
    heightRef.current = startHeight;
    startPoint.current = [relativeX, relativeY, startHeight];
    bindEvents();
    onResizeStart(event.nativeEvent);
  }

  function unbindEvents() {
    document.removeEventListener('mousemove', handleDragging);
    document.removeEventListener('touchmove', handleDragging);
    document.removeEventListener('mouseup', handleDragStop);
    document.removeEventListener('touchend', handleDragStop);
  }

  function bindEvents() {
    document.addEventListener('mousemove', handleDragging);
    document.addEventListener('touchmove', handleDragging);
    document.addEventListener('mouseup', handleDragStop);
    document.addEventListener('touchend', handleDragStop);
  }

  React.useEffect(function () {
    return unbindEvents;
  }, []);

  var resizableStyle = _extends({
    width: width + "px",
    position: 'relative'
  }, style); // autoHeight 模式下，不需要每次换行都重新计算高度，避免产生抖动


  if (!autoHeight) {
    resizableStyle.height = height + "px";
  }

  return /*#__PURE__*/_createElement(ResizableWrapper, _extends({
    className: className,
    style: resizableStyle,
    ref: innerRef,
    onClick: onClick
  }, hoverHandlers, {
    isHover: isHover,
    isActive: isActive,
    "data-hover-box": "borderBox"
  }), /*#__PURE__*/_createElement(Mask, {
    visible: dragging.current
  }), children, showYHandle(axis) && visible && /*#__PURE__*/_createElement(YHandle, {
    style: handleStyle,
    dragging: dragging.current
  }, /*#__PURE__*/_createElement(HandleIcon, {
    onMouseDown: handleDragStart,
    onTouchStart: handleDragStart
  })), showXHandle(axis) && visible && /*#__PURE__*/_createElement(XHandle, {
    onMouseDown: handleDragStart,
    onTouchStart: handleDragStart,
    style: handleStyle,
    dragging: dragging.current
  }, _ref));
};

export default Resizable;
//# sourceMappingURL=index.js.map