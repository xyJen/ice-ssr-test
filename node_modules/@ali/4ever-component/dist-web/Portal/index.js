import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";

/* eslint-disable import/no-extraneous-dependencies */
import * as React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import * as ReactDOM from 'react-dom';
import { throttle } from 'lodash-es';
export var Portal = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Portal, _React$Component);

  function Portal() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.triggerRef = /*#__PURE__*/React.createRef();
    _this.portalRef = /*#__PURE__*/React.createRef();
    _this.updatePortalPosition = throttle(function () {
      var _this$props = _this.props,
          visible = _this$props.visible,
          container = _this$props.container,
          portalMatchTrigger = _this$props.portalMatchTrigger,
          portalRef = _this$props.portalRef,
          triggerRef = _this$props.triggerRef,
          getPosition = _this$props.getPosition,
          _this$props$zoom = _this$props.zoom,
          zoom = _this$props$zoom === void 0 ? 1 : _this$props$zoom,
          maxWidth = _this$props.maxWidth;

      if (!visible) {
        return;
      } // eslint-disable-next-line react/no-find-dom-node


      var trigger = ReactDOM.findDOMNode(triggerRef ? triggerRef.current : _this.triggerRef.current); // eslint-disable-next-line react/no-find-dom-node

      var portal = ReactDOM.findDOMNode(portalRef ? portalRef.current : _this.portalRef.current);

      if (!trigger || !portal) {
        return;
      }

      var triggerRect = trigger.getBoundingClientRect();

      if (!triggerRect) {
        return;
      }

      var _this$props2 = _this.props,
          offset = _this$props2.offset,
          position = _this$props2.position;
      var offsetX = offset[0],
          offsetY = offset[1];
      var containerRect = container.getBoundingClientRect();
      var top = triggerRect.bottom - containerRect.top;
      var left = triggerRect.left - containerRect.left;
      var portalRect = portal.getBoundingClientRect();
      var height = portalRect.height,
          width = portalRect.width;

      if (portalMatchTrigger) {
        var _width = maxWidth ? Math.min(maxWidth, triggerRect.width) : triggerRect.width;

        portal.style.minWidth = _width + "px";
      }
      /**
       * zoom 场景下，left 和 top 需要乘以 zoom
       * ┌────────┬────────────┐                      ┌──────────────┬───────────────┐
       * │        │            │                      │              │               │
       * │        │ left       │        zoom          │              │               │
       * ├────────┘            │  ────────────────►   │              │ left * zoom   │
       * │   top               │                      │              │               │
       * │                     │                      ├──────────────┘               │
       * │                     │                      │  top * zoom                  │
       * └─────────────────────┘                      │                              │
       *                                              │                              │
       *                                              │                              │
       *                                              └──────────────────────────────┘
       * 我们这边使用 getBoundingClientRect 获取的是相对 viewport 的数据
       * 在 zoom 情况下，需要除以 zoom 获得真实的 style 设置
       * 
       * ┌────────┬────────────┐                      ┌──────────────┬───────────────┐
       * │        │            │                      │              │               │
       * │        │left / zoom │          zoom        │              │               │
       * ├────────┘            │  ◄─────────────────  │              │ left          │
       * │ top / zoom          │                      │              │               │
       * │                     │                      ├──────────────┘               │
       * │                     │                      │      top                     │
       * └─────────────────────┘                      │                              │
       *                                              │                              │
       *                                              │                              │
       *                                              └──────────────────────────────┘
       */

      /* 当有外部传入固定position时，优先采用position */


      if (position) {
        // position 的绝对位置，不受 zoom 影响
        portal.style.top = position.top + "px";
        portal.style.left = position.left + "px";
      } else if (getPosition && typeof getPosition === 'function') {
        var _getPosition = getPosition(containerRect, triggerRect, portalRect),
            computedLeft = _getPosition.left,
            computedTop = _getPosition.top;

        portal.style.top = computedTop / zoom + "px";
        portal.style.left = computedLeft / zoom + "px";
      } else {
        // 计算底部剩余空间，若剩余空间能够容纳 portal，则向下展示 portal
        // 如果下方剩余空间无法容纳 portal，还需要判断上方空间能否容纳
        // 若上方也无法容纳(triggerTop < height)，则仍然放到下方
        // 左右则优先放右侧
        var bottomSpace = containerRect.height - top;
        var rightSpace = containerRect.width - left;
        var triggerTop = triggerRect.top - containerRect.top;
        var triggerRight = triggerRect.right - containerRect.left;
        portal.style.top = bottomSpace < height && triggerTop > height ? (triggerTop + offsetY - height - 4) / zoom + "px" // 放到上方
        : (top + offsetY) / zoom + "px";
        portal.style.left = rightSpace < width && triggerRight > width ? (left + offsetX - width - 4) / zoom + "px" : (left + offsetX) / zoom + "px";
      }

      portal.style.zIndex = '999';
    });
    return _this;
  }

  var _proto = Portal.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.updatePortalPosition();
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    this.updatePortalPosition();
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.updatePortalPosition.cancel();
  };

  _proto.render = function render() {
    var _this$props3 = this.props,
        children = _this$props3.children,
        container = _this$props3.container,
        overlay = _this$props3.overlay,
        className = _this$props3.className,
        visible = _this$props3.visible,
        _this$props3$destroyO = _this$props3.destroyOverlayOnHide,
        destroyOverlayOnHide = _this$props3$destroyO === void 0 ? true : _this$props3$destroyO,
        portalRef = _this$props3.portalRef,
        triggerRef = _this$props3.triggerRef;
    return /*#__PURE__*/_createElement(React.Fragment, null, /*#__PURE__*/React.cloneElement(children, {
      ref: triggerRef || this.triggerRef
    }), visible || !destroyOverlayOnHide ? /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/_createElement("div", {
      className: className
    }, /*#__PURE__*/React.cloneElement(overlay, {
      ref: portalRef || this.portalRef
    })), container) : null);
  };

  return Portal;
}(React.Component);
Portal.defaultProps = {
  offset: [0, 0],
  portalMatchTrigger: true,
  className: '',
  visible: false
};
//# sourceMappingURL=index.js.map