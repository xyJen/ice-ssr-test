import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import { areArraysIntersected } from "./utils";
import { buildToolbarItem } from "./buildToolbarItem";
import React from 'react';
export function convertSingleLayout(layout, context) {
  var toolbarConfig = layout.map(function (line) {
    return convertLine(line, false, context);
  });
  var items = toolbarConfig.filter(function (config) {
    return (config == null ? void 0 : config.length) > 0;
  });
  var result = [];

  for (var index = 0; index < items.length; index++) {
    var item = items[index];
    result.push(item);

    if (index < items.length - 1) {
      result.push('divider');
    }
  }

  return result;
}
export function convertDoubleLayout(layout, context) {
  var toolbarConfig = layout.map(function (group) {
    return convertGroup(group, context);
  });
  var items = toolbarConfig.filter(function (config) {
    return (config == null ? void 0 : config.length) > 0;
  });
  var result = [];

  for (var index = 0; index < items.length; index++) {
    var itemArray = items[index];

    for (var _iterator = _createForOfIteratorHelperLoose(itemArray), _step; !(_step = _iterator()).done;) {
      var item = _step.value;
      result.push(item);
    }

    if (index < items.length - 1) {
      result.push('divider');
    }
  }

  return result;
}
export function convertGroup(group, context) {
  var _group$hideTargets = group.hideTargets,
      hideTargets = _group$hideTargets === void 0 ? [] : _group$hideTargets,
      _group$disableTargets = group.disableTargets,
      disableTargets = _group$disableTargets === void 0 ? [] : _group$disableTargets,
      blocks = group.blocks;
  var targets = context.targets;
  var shouldHide = areArraysIntersected(targets, hideTargets);

  if (shouldHide) {
    return [];
  }

  var shouldDisable = areArraysIntersected(targets, disableTargets);
  var blockConfigs = blocks.map(function (block) {
    if (isDoubleLine(block)) {
      return convertDoubleLine(block, shouldDisable, context);
    }

    return convertLine(block, shouldDisable, context);
  });
  return blockConfigs.filter(function (config) {
    return (config == null ? void 0 : config.length) > 0;
  });
}

function isDoubleLine(lineOrDoubleLine) {
  return Array.isArray(lineOrDoubleLine['lines']);
}

export function convertDoubleLine(block, disable, context) {
  var _block$hideTargets = block.hideTargets,
      hideTargets = _block$hideTargets === void 0 ? [] : _block$hideTargets,
      _block$disableTargets = block.disableTargets,
      disableTargets = _block$disableTargets === void 0 ? [] : _block$disableTargets,
      lines = block.lines;
  var targets = context.targets;
  var shouldHide = disable || areArraysIntersected(targets, hideTargets);

  if (shouldHide) {
    return [];
  }

  var shouldDisable = areArraysIntersected(targets, disableTargets);
  var lineConfigs = lines.map(function (line) {
    return convertLine(line, shouldDisable, context);
  });
  return lineConfigs;
}
export function convertLine(line, disable, context) {
  var targets = context.targets;
  var _line$hideTargets = line.hideTargets,
      hideTargets = _line$hideTargets === void 0 ? [] : _line$hideTargets,
      _line$disableTargets = line.disableTargets,
      disableTargets = _line$disableTargets === void 0 ? [] : _line$disableTargets,
      items = line.items;
  var shouldHide = areArraysIntersected(targets, hideTargets);

  if (shouldHide) {
    return [];
  }

  var shouldDisable = disable || areArraysIntersected(targets, disableTargets);
  var itemConfigs = items.map(function (item) {
    return convertItem(item, shouldDisable, context);
  });
  return itemConfigs.filter(React.isValidElement);
}
export function convertItem(item, disable, context) {
  var targets = context.targets,
      controller = context.controller,
      plugins = context.plugins,
      customButtons = context.customButtons;

  var _item$hideTargets = item.hideTargets,
      hideTargets = _item$hideTargets === void 0 ? [] : _item$hideTargets,
      _item$disableTargets = item.disableTargets,
      disableTargets = _item$disableTargets === void 0 ? [] : _item$disableTargets,
      name = item.name,
      disabledFromConfig = item.disabled,
      rest = _objectWithoutPropertiesLoose(item, ["hideTargets", "disableTargets", "name", "disabled"]);

  var shouldHide = areArraysIntersected(targets, hideTargets);

  if (shouldHide) {
    return null;
  }

  var shouldDisable = disabledFromConfig || disable || areArraysIntersected(targets, disableTargets);
  var extroProps = shouldDisable ? _extends({
    disabled: shouldDisable,
    key: name
  }, rest) : _extends({
    key: name
  }, rest);
  return buildToolbarItem(plugins, controller, name, customButtons, extroProps);
}
//# sourceMappingURL=layoutConverter.js.map