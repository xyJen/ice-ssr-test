import _extends from "@babel/runtime/helpers/extends";
import React, { useEffect, useCallback, useMemo } from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import ReactDOM from 'react-dom';
import { throttle } from 'lodash-es';
import { Controller, Block, useZoom, ScrollableContentContext } from '@ali/4ever-cangjie';
import logger from '@ali/4ever-logger';
import { usePlugins } from "../PluginsContext";
import findBlockKeyFromEvent from "./utils/findBlockKeyFromEvent";
import calcCurrentPos from "./utils/calcCurrentPos";
import { LeftToolbarWrapper } from "./styled";
import { useLeftToolbar, LeftToolbarProvider } from "./leftToolbarContext";
import { LEGAL_EVENT } from '@ali/4ever-utils';
import { isKeyHotkey } from 'is-hotkey';
var isEnterHotKey = isKeyHotkey('enter');

var mouseMoveHandler = function mouseMoveHandler(event, container, updateHoverBlock, controller) {
  var _block;

  if (!container.contains(event.target)) {
    updateHoverBlock();
    return;
  }

  var blockKey = findBlockKeyFromEvent(event, container, controller);
  var block = controller.value.document.getNode(blockKey); // 如果leftToolbar的findBlockKeyFromEvent没有找到对应block，则再通过hoverBlock的方法进行查找
  // TODO 两套方法各自维护一套findBlockKeyFromEvent方法，后面需要统一

  if (((_block = block) == null ? void 0 : _block.type) === 'line') {
    block = controller.value.document.getParent(blockKey);
  }

  if (Block.isBlock(block)) {
    updateHoverBlock(block);
  }
};

var LeftToolbar = function LeftToolbar(props) {
  var config = props.config,
      getScrollableContent = props.getScrollableContent,
      initController = props.controller; // eslint-disable-next-line react-hooks/rules-of-hooks

  var controller = initController || Controller.useController();
  var plugins = usePlugins();
  var container = getScrollableContent() || window.document.body;
  var isMoveDisabled = React.useRef(false);
  var _controller$value = controller.value,
      focusBlock = _controller$value.focusBlock,
      selection = _controller$value.selection;

  var _useLeftToolbar = useLeftToolbar(),
      state = _useLeftToolbar[0],
      actions = _useLeftToolbar[1];

  var block = state.block,
      preventMouseMove = state.preventMouseMove;
  var isPreventMouseMove = React.useRef(preventMouseMove);
  var canLeftToolbarVisibleRef = React.useRef(true);
  var zoom = useZoom();
  isPreventMouseMove.current = preventMouseMove;
  var disable = controller.query('disableLeftToolbar', {
    node: block
  });
  var position = useMemo(function () {
    if (!block) return undefined; // 插件检测是否需要偏移

    return calcCurrentPos(block, container);
  }, [block, container, controller]);
  var offsetWithFocus = useMemo(function () {
    if (!block) return undefined; // 用于表格的场景，在focus的时候也要精确位置计算
    // query 过程中 controller 可能会变为 undefined

    try {
      return controller.query('getLeftToolbarOffsetWithFocus', {
        node: block
      });
    } catch (error) {
      logger.warn(error);
    }

    return undefined;
  }, [block, controller, focusBlock]);
  var offset = useMemo(function () {
    if (!block) return undefined; // query 过程中 controller 可能会变为 undefined

    try {
      return controller.query('getLeftToolbarOffset', {
        node: block
      });
    } catch (error) {
      logger.warn(error);
    }

    return undefined;
  }, [block, controller]);
  var fixedPosition = useMemo(function () {
    var value = offsetWithFocus || offset;
    return value ? _extends({}, position, {
      right: Number(position == null ? void 0 : position.right) - value.x || 0,
      // @ts-ignore
      top: (position == null ? void 0 : position.top) + value.y || 0
    }) : position;
  }, [position, offset, offsetWithFocus]);
  var onKeyDown = useCallback(function (event) {
    if (isEnterHotKey(event)) {
      actions.updateHoverBlock();
    }
  }, [actions]);
  var onScroll = useCallback(throttle(function () {
    if (isPreventMouseMove.current) return;
    actions.updateHoverBlock();
  }, 1000), [actions]);
  var handleMouseMove = useCallback(throttle(mouseMoveHandler, 50), []); // 确保依赖是稳定的，不然会频繁监听和卸载事件监听

  var onMouseMove = useCallback(function (event) {
    // 如果外部组件比如SelectionBar设置了需要禁用左侧工具栏，则需要将左侧工具栏隐藏
    // 浮动工具栏显示到时候需要隐藏掉左侧工具栏按钮
    var shouldDisabledLeftToolbar = !canLeftToolbarVisibleRef.current;

    if (isPreventMouseMove.current || isMoveDisabled.current || shouldDisabledLeftToolbar) {
      if (shouldDisabledLeftToolbar) {
        actions.updateHoverBlock();
      }

      return;
    }

    handleMouseMove(event, container, actions.updateHoverBlock, controller);
  }, [handleMouseMove, container, actions.updateHoverBlock, controller]); // 提供一个对外的事件，方便操作左侧工具栏的状态，原先leftToolbarHandlers的方式过于复杂

  var handleCustomEvent = React.useCallback(function (e) {
    var _e$detail = e.detail,
        enable = _e$detail.enable,
        clear = _e$detail.clear;

    if (clear) {
      actions.updateHoverBlock();
    }

    canLeftToolbarVisibleRef.current = enable;
  }, [actions.updateHoverBlock]);
  useEffect(function () {
    actions.updateHoverBlock();
  }, [zoom, actions.updateHoverBlock]);
  useEffect(function () {
    // 新的产品逻辑要求输入的时候左侧工具栏不隐藏
    window.document.addEventListener('mousemove', onMouseMove);
    window.document.addEventListener('keydown', onKeyDown);
    window.document.addEventListener('scroll', onScroll, true);
    window.document.body.addEventListener(LEGAL_EVENT.leftToolbarEnable, handleCustomEvent);
    return function () {
      window.document.removeEventListener('mousemove', onMouseMove);
      window.document.removeEventListener('keydown', onKeyDown);
      window.document.removeEventListener('scroll', onScroll, true);
      window.document.body.removeEventListener(LEGAL_EVENT.leftToolbarEnable, handleCustomEvent);
    };
  }, [onMouseMove, handleCustomEvent, onKeyDown, onScroll]); // 把拖拽的临时启动、禁用，提供给外部使用。
  // 其他可能与拖拽冲突的插件，就可以控制拖拽杆的禁用、隐藏。

  useEffect(function () {
    var arrays = (plugins == null ? void 0 : plugins.array) || [];
    var listenerArrays = arrays.reduce(function (arr, p) {
      // @ts-ignore
      var array = p == null ? void 0 : p.leftToolbarHandlers;

      if (array) {
        arr.push(array);
      }

      return arr;
    }, []);
    var handler = {
      disable: function disable() {
        actions.updateHoverBlock();
        handleMouseMove.cancel();
        isMoveDisabled.current = true;
      },
      enable: function enable() {
        isMoveDisabled.current = false;
      },
      clear: function clear() {
        actions.updateHoverBlock();
        isMoveDisabled.current = false;
      }
    };

    var getHandler = function getHandler() {
      return handler;
    };

    listenerArrays.forEach(function (la) {
      return la.push(getHandler);
    });
    return function () {
      listenerArrays.forEach(function (la) {
        return la.splice(la.indexOf(getHandler), 1);
      });
    };
  }, [actions, plugins, controller, handleMouseMove]);
  var renderToolBtn = useMemo(function () {
    if (!plugins || !block || !config) {
      return null;
    }

    return config.map(function (item) {
      if (item.btn) {
        return item.btn;
      }

      var plugin = plugins == null ? void 0 : plugins.hash[item.key];

      if (plugin && plugin.leftToolbar) {
        var ToolBtn = plugin.leftToolbar;
        return /*#__PURE__*/_createElement(ToolBtn, {
          key: item.key + "_" + block.key,
          controller: controller,
          currentBlock: block
        });
      }

      return null;
    });
  }, [plugins, block, config, controller, selection]);
  if (!renderToolBtn || disable) return null;
  return /*#__PURE__*/_createElement(LeftToolbarWrapper, {
    style: fixedPosition
  }, renderToolBtn);
};

export default (function (props) {
  var getScrollableContent = props.getScrollableContent;
  var container = (getScrollableContent == null ? void 0 : getScrollableContent()) || window.document.body;
  return /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/_createElement(ScrollableContentContext.Provider, {
    value: container
  }, /*#__PURE__*/_createElement(LeftToolbarProvider, null, /*#__PURE__*/_createElement(LeftToolbar, props))), container);
});
//# sourceMappingURL=LeftToolbar.js.map