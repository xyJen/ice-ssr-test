{"version":3,"sources":["../../../../src/MobileToolbar/adapter/visualViewport.ts"],"names":["React","DEBOUNCE_TIME","setStyle","node","measureNode","getBoundingClientRect","windowHeight","height","viewport","window","visualViewport","offsetX","offsetLeft","offsetY","offsetTop","newTransform","scale","style","transition","requestAnimationFrame","opacity","transform","setTimeout","useVisualboxTransfrom","ref","measureRef","isDiabled","timerRef","useRef","viewportHandler","useCallback","undefined","current","clearTimeout","useEffect","addEventListener","passive","removeEventListener"],"mappings":"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","sourcesContent":["import * as React from 'react';\n\nconst DEBOUNCE_TIME = 300;\n\n/**\n * measureNode 用来获取 window 的高度。\n * window.innerHeight 在滚动到键盘靠底部时候，返回的值不稳定[viewport.height - 808]\n * 因此这里参考了 MDN visual box 里面的示例代码，用了一个 fake 元素获取 boundingClient.height\n */\nfunction setStyle(node: HTMLElement, measureNode: HTMLElement) {\n  const { height: windowHeight } = measureNode.getBoundingClientRect();\n  // @ts-ignore\n  const viewport = window.visualViewport;\n  const offsetX = viewport.offsetLeft;\n  const offsetY = viewport.height - windowHeight + viewport.offsetTop;\n\n  const newTransform =\n    'translate3d(' +\n    offsetX +\n    'px,' +\n    offsetY +\n    'px, 0) ' +\n    'scale(' +\n    1 / viewport.scale +\n    ')';\n  node.style.transition = 'opacity 150ms';\n  requestAnimationFrame(() => {\n    node.style.opacity = '1';\n    node.style.transform = newTransform;\n    setTimeout(() => {\n      node.style.transition = 'none';\n    }, 150);\n  });\n}\n\n/**\n * 处理 iOS 浏览器的键盘弹出问题。\n * 钉钉容器内不需要此部分逻辑\n */\nexport function useVisualboxTransfrom(\n  ref: React.RefObject<HTMLElement>,\n  measureRef: React.RefObject<HTMLElement>,\n  isDiabled: boolean,\n) {\n  const timerRef = React.useRef<ReturnType<typeof setTimeout> | null>(null);\n  const viewportHandler = React.useCallback(() => {\n    // @ts-ignore\n    if (!window.visualViewport || isDiabled) {\n      return undefined;\n    }\n    if (timerRef.current !== null) {\n      clearTimeout(timerRef.current);\n    } else if (ref.current) {\n      ref.current.style.opacity = '0';\n    }\n\n    timerRef.current = setTimeout(() => {\n      if (ref.current && measureRef.current) {\n        setStyle(ref.current, measureRef.current);\n      }\n      timerRef.current = null;\n    }, DEBOUNCE_TIME);\n    return () => {\n      if (timerRef.current !== null) {\n        clearTimeout(timerRef.current);\n        timerRef.current = null;\n      }\n    };\n  }, []);\n  React.useEffect(() => {\n    // @ts-ignore\n    if (!window.visualViewport || isDiabled) {\n      return undefined;\n    }\n    // 往上滑动的时候，会把底部条划走；虽然有实时计算，但是比 UI 更新较晚，用户看到闪烁\n    // 这里采用的方式，是滑动的时候先隐藏起来、滑动停止之后再渐变显示\n    window.addEventListener('scroll', viewportHandler, { passive: false });\n    window.visualViewport.addEventListener('scroll', viewportHandler);\n    window.visualViewport.addEventListener('resize', viewportHandler);\n    return () => {\n      window.removeEventListener('scroll', viewportHandler);\n      window.visualViewport.removeEventListener('scroll', viewportHandler);\n      window.visualViewport.removeEventListener('resize', viewportHandler);\n    };\n  }, [isDiabled, viewportHandler]);\n}\n"],"file":"visualViewport.js"}