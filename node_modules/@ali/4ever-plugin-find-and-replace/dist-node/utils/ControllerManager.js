"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const MAIN_CONTROLLER_ROLE = 'main';

class ControllerManager {
  constructor(controllers) {
    this.ctls = void 0;
    this.mainController = void 0;
    this.ctls = controllers || [];
    this.mainController = null;
  }

  push(c, role) {
    if (!this.ctls.includes(c)) {
      if (this.ctls.length === 0 || role === MAIN_CONTROLLER_ROLE) {
        this.mainController = c;
      }

      if (role === MAIN_CONTROLLER_ROLE) {
        this.ctls.unshift(c);
      } else {
        this.ctls.push(c);
      }
    }
  }

  remove(c) {
    const cIndex = this.ctls.indexOf(c);

    if (cIndex !== -1) {
      this.ctls.splice(cIndex, 1);
    }

    if (c === this.mainController) {
      this.mainController = this.ctls[0];
    }
  }

  isMainController(c) {
    return c === this.mainController;
  }

  run(fn) {
    this.ctls.forEach(fn);
  } // mainController 最后执行


  runWithSchedule(fn, mainController = this.mainController) {
    this.ctls.forEach(ctl => {
      if (ctl !== mainController) {
        fn(ctl);
      } else {
        // mainController 要等所有 controller 更新后再 render , 以获取最新 results
        // 如果不这么处理，mainController 会在自己更新后立刻 render， 此时其他 controller 的 results 是过期的数据，导致定位错误
        Promise.resolve().then(() => fn(mainController));
      }
    });
  }

}

exports.default = ControllerManager;
//# sourceMappingURL=ControllerManager.js.map