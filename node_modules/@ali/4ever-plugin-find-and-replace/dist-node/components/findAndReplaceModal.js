"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _everCangjie = require("@ali/4ever-cangjie");

var _weDesign = require("@ali/we-design");

var _lodash = require("lodash");

var _isHotkey = require("is-hotkey");

var _actions = require("../common/actions");

var _utils = require("../utils");

/* eslint-disable react-hooks/exhaustive-deps */
const _createElement = /*#__PURE__*/_react.default.createElement;
const DEFAULT_TAB_KEY = 'find';
const DEFAULT_REPLACE_TEXT = '';

const FindAndReplaceModal = props => {
  const {
    draggableArea,
    initialPosition,
    isFindOnly,
    mainController,
    locale,
    ctlManager,
    onScrollIntoFocus,
    onFilter,
    onCustomScroll
  } = props;
  const [findText, setFindText] = (0, _react.useState)('');
  const [focused, setFocused] = (0, _react.useState)(true);
  const modalRef = (0, _react.useRef)(null);
  const domRef = (0, _react.useRef)(null);
  let matches = [];
  ctlManager.run(ctl => {
    const {
      data
    } = ctl.query('getDataValue') || ctl.value;
    const {
      searchResult
    } = data;

    if (searchResult?.length > 0) {
      matches.push(...searchResult);
    }
  });

  if (onFilter) {
    matches = onFilter(matches);
  }

  const matchedCount = matches.length;
  const {
    data
  } = mainController.value;
  const visible = data.findAndReplaceVisible || false;
  const {
    findFragment = ''
  } = data;
  let focusIndex = 0;
  let isInit = false;

  if (matches.length > 0) {
    const idx = matches.findIndex(match => match.selected);

    if (idx === -1) {
      // 当存在 「匹配项」 但没有 「选中项」时初始化第一项为选中项
      focusIndex = 1;
      isInit = true;
    } else {
      focusIndex = idx + 1;
    }
  }

  const focusMatch = matches[focusIndex - 1];
  const disableReplace = (0, _utils.isReadonlyMatch)(focusMatch);
  const disableReplaceAll = matches.every(_utils.isReadonlyMatch);
  const container = (0, _everCangjie.useScrollableContainer)() || window;
  const debouncedUpdateFindText = (0, _react.useCallback)((0, _lodash.debounce)(text => {
    ctlManager.runWithSchedule(ctl => {
      ctl.run('onAction', (0, _actions.updateFindText)(text));
    });
  }, 200), [ctlManager]);
  const handleFindInputChange = (0, _react.useCallback)(event => {
    const text = typeof event === 'string' ? event : event.target.value;
    debouncedUpdateFindText(text);

    if (findFragment) {
      mainController.run('onAction', (0, _actions.updateFindFragment)(''));
    }

    setFindText(text);
  }, [debouncedUpdateFindText, findFragment, mainController]); // 新增实例时更新下搜索结果

  (0, _react.useEffect)(() => {
    ctlManager.runWithSchedule(ctl => {
      ctl.run('onAction', (0, _actions.updateFindText)(findText));
    });
  }, [ctlManager.ctls[ctlManager.ctls.length - 1]]); // 绑定监听

  (0, _react.useEffect)(() => {
    const handleKeyDown = event => {
      const isFindHotKey = (0, _isHotkey.isKeyHotkey)('mod+f');

      if (isFindHotKey(event)) {
        event.preventDefault();
        event.stopPropagation();
        const {
          findAndReplaceVisible
        } = mainController.value.data;
        let fragment = '';
        ctlManager.run(ctl => {
          const text = ctl.value.fragment?.text;

          if (text) {
            fragment = text;
          }
        });

        if (!findAndReplaceVisible) {
          mainController.run('onAction', (0, _actions.toggleFindAndReplace)(true));
        } else {
          // 查找替换组件没有提供设置 input focus 的方法，这里临时处理下
          domRef.current?.querySelector('[aria-hidden="false"] input[data-testid="J_findValueInput"]')?.focus();
        }

        if (fragment) {
          mainController.run('onAction', (0, _actions.updateFindFragment)(fragment));
        }
      }
    };

    const handleMouseDown = event => {
      const dom = domRef.current;

      if (!dom) {
        return;
      }

      const isFocus = Boolean(dom.contains(event.target));
      setFocused(isFocus);
    };

    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('mousedown', handleMouseDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('mousedown', handleMouseDown);
    };
  }, [ctlManager, mainController]); // 从选区初始化 findText

  (0, _react.useEffect)(() => {
    if (findFragment) {
      handleFindInputChange(findFragment); // 这里延迟一下，等输入框有内容后再选中

      Promise.resolve().then(() => {
        if (modalRef.current) {
          modalRef.current.selectInput();
        }
      });
      setFocused(true);
    }
  }, [findFragment, handleFindInputChange]);

  const handleFocusIndexChange = index => {
    const newFocusIndex = (matchedCount + index - 1) % matchedCount;
    const newFocusMatch = matches[newFocusIndex];
    ctlManager.runWithSchedule(ctl => {
      ctl.run('onAction', (0, _actions.updateSearchResult)(newFocusMatch));

      if (newFocusMatch) {
        onScrollIntoFocus && onScrollIntoFocus(newFocusMatch.type);
        (0, _utils.scrollIntoFocus)(newFocusMatch.key, ctl, container, findText, onCustomScroll);
      }
    });
  };

  const handleReplaceCurrent = targetText => {
    ctlManager.runWithSchedule(ctl => {
      ctl.run('onAction', (0, _actions.replaceText)(focusMatch, targetText));
    });
    const newFocusIndex = focusIndex === matchedCount ? focusIndex - 2 : focusIndex;
    const newFocusMatch = matches[newFocusIndex];
    ctlManager.runWithSchedule(ctl => {
      ctl.run('onAction', (0, _actions.updateSearchResult)(newFocusMatch));

      if (newFocusMatch) {
        onScrollIntoFocus && onScrollIntoFocus(newFocusMatch.type);
        (0, _utils.scrollIntoFocus)(newFocusMatch.key, ctl, container, findText, onCustomScroll);
      }
    });
  };

  const handleReplaceAll = targetText => {
    const canReplaceMatches = matches.filter(match => !(0, _utils.isReadonlyMatch)(match));
    canReplaceMatches.forEach(m => ctlManager.runWithSchedule(ctl => {
      ctl.run('onAction', (0, _actions.replaceText)(m, targetText));
    })); // 提示不支持替换的元素个数

    const noSupportSearchCount = matchedCount - canReplaceMatches.length;

    if (noSupportSearchCount) {
      const {
        noSupportLeft,
        noSupportRight
      } = locale;

      _weDesign.message.info(`${noSupportLeft} ${noSupportSearchCount} ${noSupportRight}`, 2);
    }
  };

  const handleVisibleChange = v => {
    mainController.run('onAction', (0, _actions.toggleFindAndReplace)(v));
  }; // 关闭时清除搜索


  (0, _react.useEffect)(() => {
    if (!visible) {
      handleFindInputChange('');
    }
  }, [visible, handleFindInputChange]); // 初始化第一个匹配项为选中项

  (0, _react.useEffect)(() => {
    if (isInit) {
      ctlManager.runWithSchedule(ctl => {
        ctl.run('onAction', (0, _actions.updateSearchResult)(focusMatch));
        onScrollIntoFocus && onScrollIntoFocus(focusMatch.type);
        (0, _utils.scrollIntoFocus)(focusMatch.key, ctl, container, findText, onCustomScroll);
      });
    }
  }, [ctlManager, focusMatch, isInit]);
  return /*#__PURE__*/_createElement(_weDesign.FindAndReplacePortal, {
    visible: visible,
    focused: focused,
    isFindOnly: isFindOnly,
    defaultTabKey: DEFAULT_TAB_KEY,
    disableReplace: disableReplace,
    disableReplaceAll: disableReplaceAll,
    zIndex: 1000,
    draggableArea: draggableArea,
    initialPosition: initialPosition,
    testid: "FindAndReplacePortal",
    findText: findText,
    focusIndex: focusIndex,
    matchedCount: matchedCount,
    defaultReplaceText: DEFAULT_REPLACE_TEXT,
    wrappedRef: modalRef,
    domRef: domRef,
    onFindInputChange: handleFindInputChange,
    onFocusIndexChange: handleFocusIndexChange,
    onReplaceCurrent: handleReplaceCurrent,
    onReplaceAll: handleReplaceAll,
    onVisibleChange: handleVisibleChange
  });
};

var _default = FindAndReplaceModal;
exports.default = _default;
//# sourceMappingURL=findAndReplaceModal.js.map