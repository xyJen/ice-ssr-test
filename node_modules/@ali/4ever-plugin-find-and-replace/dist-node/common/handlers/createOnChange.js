"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _everCangjie = require("@ali/4ever-cangjie");

var _fastDeepEqual = _interopRequireDefault(require("fast-deep-equal"));

var _utils = require("../../utils");

var _marks = require("../../mo/marks");

/* eslint-disable no-param-reassign */

/* eslint-disable @typescript-eslint/no-shadow */
const emptyDocument = _everCangjie.Document.create();

const isPathAboveOrSame = (path, target) => {
  return _everCangjie.Path.isAncestor(path, target) || _everCangjie.Path.compare(path, target) === 0;
};

const getFocusIndex = searchResult => searchResult.findIndex(match => match.selected);

const diffNodes = (prevNodes, currentNodes, {
  prevDocument,
  currentDocument
}, controller) => {
  let insert = [];
  let remove = [];
  currentNodes.forEach((currentNode, focusIndex) => {
    const prevNodeAtIndex = prevNodes[focusIndex];

    if (!prevNodeAtIndex || prevNodeAtIndex.key !== currentNode.key) {
      insert.push(currentDocument.getPath(currentNode.key));
      return;
    } // 编辑器中，不存在修改节点类型的行为，所以 key 相等，必然同时(不)为 Text


    const isContentSame = _everCangjie.Text.isText(currentNode) ? // PERFORMANCE: 不使用 node.text 是为了避免遍历 leaves 以生成 text
    // @ts-ignore
    (0, _fastDeepEqual.default)(currentNode.leaves, prevNodeAtIndex.leaves) : // @ts-ignore
    (0, _fastDeepEqual.default)(currentNode.nodes, prevNodeAtIndex.nodes);

    if (isContentSame) {
      return;
    }

    if (_everCangjie.Text.isText(currentNode)) {
      // update = remove + insert
      remove.push(prevDocument.getPath(prevNodeAtIndex.key));
      insert.push(currentDocument.getPath(currentNode.key));
      return;
    }

    const ret = diffNodes( // @ts-ignore
    prevNodeAtIndex.nodes, // @ts-ignore
    currentNode.nodes, {
      prevDocument,
      currentDocument
    }, controller);
    insert = [...insert, ...ret.insert];
    remove = [...remove, ...ret.remove];
  });
  prevNodes.forEach((prevNode, idx) => {
    const currentNodeAtIndex = currentNodes[idx];

    if (!currentNodeAtIndex || currentNodeAtIndex.key !== prevNode.key) {
      remove.push(prevDocument.getPath(prevNode.key));
    }
  });
  return {
    insert,
    remove
  };
};

const diffDocument = (prevDocument, document, controller) => {
  return diffNodes(prevDocument.nodes, document.nodes, {
    prevDocument,
    currentDocument: document
  }, controller);
};

const searchInNodeContent = (node, content, findText, role) => {
  const result = [];
  const keywords = findText.toLowerCase();
  content = content.toLowerCase();

  if (content.indexOf(keywords) === -1) {
    return result;
  }

  let endOffset = 0;

  do {
    const startOffset = content.indexOf(keywords, endOffset);

    if (startOffset === -1) {
      break;
    }

    endOffset = startOffset + keywords.length;
    result.push({
      type: `${role}text`,
      selected: false,
      key: node.key,
      extraData: {
        startOffset,
        endOffset
      }
    });
  } while (endOffset <= content.length);

  return result;
};

const searchInTextNode = (node, findText, role) => {
  const content = node.text;
  const result = searchInNodeContent(node, content, findText, role);
  return result;
};

const createDecorationWithMatch = match => {
  const {
    key,
    selected,
    extraData
  } = match;

  const start = _everCangjie.TextPoint.create({
    key,
    offset: extraData?.startOffset
  });

  const end = _everCangjie.TextPoint.create({
    key,
    offset: extraData?.endOffset
  });

  const mark = _marks.MatchMark.create(selected || false);

  return _everCangjie.Decoration.create({
    start,
    end,
    mark
  });
};

const applyTextMatches = (textMatches, controller) => {
  const {
    decorations
  } = controller.value;
  const matchedDecorations = textMatches.map(createDecorationWithMatch);
  const noMatchedDecorations = (0, _utils.getNoMatchedDecorations)(decorations);
  controller.setDecorations(matchedDecorations.concat(noMatchedDecorations));
};

const dispatchNoTextMatches = (noTextMatches, controller) => {
  const {
    injections
  } = controller.value;
  const matchedInjections = noTextMatches.map(match => {
    const {
      key
    } = match;
    return _everCangjie.Injection.create({
      key,
      data: {
        searchMatch: match
      }
    });
  });
  const otherInjections = injections.filter(({
    data
  }) => !data.searchMatch);
  controller.setInjections([...matchedInjections, ...otherInjections]);
};

const search = (node, controller, role, result = []) => {
  const {
    data: {
      findText
    },
    document
  } = controller.value;

  if (_everCangjie.Text.isText(node)) {
    // 防止修订模式下被替换多次
    if (document.getClosestByPath(document.getPath(node.key), _utils.isDel)) {
      return result;
    }

    result = [...result, ...searchInTextNode(node, findText, role)];
  } else if (controller.query('isSupportSearch', node)) {
    const queryResult = controller.query('getSearchResult', findText, node);

    if (queryResult) {
      result.push({ ...queryResult,
        type: `${role}${queryResult.readonly ? 'readonly_' : ''}${queryResult.type}`
      });
    }
  } else {
    node.forEachDescendant(n => {
      if (_everCangjie.Text.isText(n) || controller.query('isSupportSearch', n)) {
        result = search(n, controller, role, result);
      }
    });
  }

  return result;
};

const patch = (searchResult, patcher, controller, role) => {
  const {
    document
  } = controller.value;
  const {
    remove,
    insert
  } = patcher;
  const appliedRemoveResult = searchResult.filter(({
    key
  }) => {
    const nodePath = document.getPath(key);
    if (!nodePath) return false;
    return !remove.some(path => isPathAboveOrSame(path, nodePath));
  });
  let inserted = [];
  insert.forEach(path => {
    const node = document.getNodeByPath(path);

    if (!node) {
      return;
    }

    inserted = [...inserted, ...search(node, controller, role)];
  });
  inserted = inserted.filter(result => {
    return appliedRemoveResult.findIndex(prevResult => (0, _fastDeepEqual.default)(prevResult, result)) === -1;
  });
  return appliedRemoveResult.concat(inserted).sort((a, b) => {
    if (a.key === b.key) {
      return a.extraData?.endOffset - b.extraData?.endOffset;
    }

    return _everCangjie.Path.isBefore(document.getPath(a.key), document.getPath(b.key)) ? -1 : 1;
  });
}; // 分发统一查找替换结果
// text 类型由查找替换插件处理
// 其他类型通过 injections 注入 globalSearchMatches 到对应节点 data


const dispatchSearchResults = (unifiedSearchResults, controller) => {
  const [textMatches, otherMatches] = unifiedSearchResults.reduce((matches, match) => {
    (0, _utils.isTextMatch)(match) ? matches[0].push(match) : matches[1].push(match);
    return matches;
  }, [[], []]);
  applyTextMatches(textMatches, controller);
  dispatchNoTextMatches(otherMatches, controller);
};

const createOnChange = (config, cache) => {
  const {
    role = '',
    isFindOnly,
    onFilter
  } = config;
  return (controller, next) => {
    const {
      data,
      document
    } = controller.value;
    const {
      findText,
      prevFindText
    } = data;
    let {
      searchResult = []
    } = data; // 不响应非查找替换变更

    if (!prevFindText && !findText) {
      return next();
    }

    if (document.data.pi) {
      return next();
    } // 查找文本为空，清除


    if (!findText) {
      dispatchSearchResults([], controller);
      (0, _utils.mergeData)(controller, {
        searchResult: [],
        prevFindText: undefined
      });
      return next();
    }

    const isFindTextChanged = findText !== prevFindText;
    const focusIndex = getFocusIndex(searchResult);

    if (isFindTextChanged) {
      cache.prevFocusIndex = -1;
    }

    const isFocusIndexChanged = focusIndex !== cache.prevFocusIndex;
    const prevDocument = isFindTextChanged ? emptyDocument : cache.prevDocument || emptyDocument; // 查找文本和文档都没有变化

    if (!isFindTextChanged && (0, _fastDeepEqual.default)(document, prevDocument)) {
      // 只有索引变化
      if (isFocusIndexChanged) {
        dispatchSearchResults(searchResult, controller);
        cache.prevFocusIndex = focusIndex;
      }

      return next();
    }

    if (isFindTextChanged) {
      searchResult = [];
    }

    const patcher = diffDocument(prevDocument, document, controller);
    const roleWithAbility = `${role}_${isFindOnly ? 'readonly_' : ''}`;
    const newSearchResult = patch(searchResult, patcher, controller, roleWithAbility); // 如果之前有选中项，document 变更时维持选中项不变
    // fix: 修改选中项所在行文本, 选中项丢失

    const idx = cache.prevFocusIndex;
    const newIndex = Math.min(idx, newSearchResult.length - 1);
    const newSearchResultWithSelected = newSearchResult.map((s, index) => {
      if (index === newIndex) {
        return { ...s,
          selected: true
        };
      }

      return s;
    });
    const filteredSearchResult = onFilter ? onFilter(newSearchResultWithSelected) : newSearchResultWithSelected;
    dispatchSearchResults(filteredSearchResult, controller);
    (0, _utils.mergeData)(controller, {
      prevFindText: findText,
      searchResult: filteredSearchResult
    });
    cache.prevDocument = document;
    return next();
  };
};

var _default = createOnChange;
exports.default = _default;
//# sourceMappingURL=createOnChange.js.map