var MAIN_CONTROLLER_ROLE = 'main';

var ControllerManager = /*#__PURE__*/function () {
  function ControllerManager(controllers) {
    this.ctls = void 0;
    this.mainController = void 0;
    this.ctls = controllers || [];
    this.mainController = null;
  }

  var _proto = ControllerManager.prototype;

  _proto.push = function push(c, role) {
    if (!this.ctls.includes(c)) {
      if (this.ctls.length === 0 || role === MAIN_CONTROLLER_ROLE) {
        this.mainController = c;
      }

      if (role === MAIN_CONTROLLER_ROLE) {
        this.ctls.unshift(c);
      } else {
        this.ctls.push(c);
      }
    }
  };

  _proto.remove = function remove(c) {
    var cIndex = this.ctls.indexOf(c);

    if (cIndex !== -1) {
      this.ctls.splice(cIndex, 1);
    }

    if (c === this.mainController) {
      this.mainController = this.ctls[0];
    }
  };

  _proto.isMainController = function isMainController(c) {
    return c === this.mainController;
  };

  _proto.run = function run(fn) {
    this.ctls.forEach(fn);
  } // mainController 最后执行
  ;

  _proto.runWithSchedule = function runWithSchedule(fn, mainController) {
    if (mainController === void 0) {
      mainController = this.mainController;
    }

    this.ctls.forEach(function (ctl) {
      if (ctl !== mainController) {
        fn(ctl);
      } else {
        // mainController 要等所有 controller 更新后再 render , 以获取最新 results
        // 如果不这么处理，mainController 会在自己更新后立刻 render， 此时其他 controller 的 results 是过期的数据，导致定位错误
        Promise.resolve().then(function () {
          return fn(mainController);
        });
      }
    });
  };

  return ControllerManager;
}();

export { ControllerManager as default };
//# sourceMappingURL=ControllerManager.js.map