import _extends from "@babel/runtime/helpers/extends";

/* eslint-disable no-param-reassign */

/* eslint-disable @typescript-eslint/no-shadow */
import { Document, Text, Decoration, Path, TextPoint, Injection } from '@ali/4ever-cangjie';
import equal from 'fast-deep-equal';
import { mergeData, isTextMatch, getNoMatchedDecorations, isDel } from "../../utils";
import { MatchMark } from "../../mo/marks";
var emptyDocument = Document.create();

var isPathAboveOrSame = function isPathAboveOrSame(path, target) {
  return Path.isAncestor(path, target) || Path.compare(path, target) === 0;
};

var getFocusIndex = function getFocusIndex(searchResult) {
  return searchResult.findIndex(function (match) {
    return match.selected;
  });
};

var diffNodes = function diffNodes(prevNodes, currentNodes, _ref, controller) {
  var prevDocument = _ref.prevDocument,
      currentDocument = _ref.currentDocument;
  var insert = [];
  var remove = [];
  currentNodes.forEach(function (currentNode, focusIndex) {
    var prevNodeAtIndex = prevNodes[focusIndex];

    if (!prevNodeAtIndex || prevNodeAtIndex.key !== currentNode.key) {
      insert.push(currentDocument.getPath(currentNode.key));
      return;
    } // 编辑器中，不存在修改节点类型的行为，所以 key 相等，必然同时(不)为 Text


    var isContentSame = Text.isText(currentNode) ? // PERFORMANCE: 不使用 node.text 是为了避免遍历 leaves 以生成 text
    // @ts-ignore
    equal(currentNode.leaves, prevNodeAtIndex.leaves) : // @ts-ignore
    equal(currentNode.nodes, prevNodeAtIndex.nodes);

    if (isContentSame) {
      return;
    }

    if (Text.isText(currentNode)) {
      // update = remove + insert
      remove.push(prevDocument.getPath(prevNodeAtIndex.key));
      insert.push(currentDocument.getPath(currentNode.key));
      return;
    }

    var ret = diffNodes( // @ts-ignore
    prevNodeAtIndex.nodes, // @ts-ignore
    currentNode.nodes, {
      prevDocument: prevDocument,
      currentDocument: currentDocument
    }, controller);
    insert = [].concat(insert, ret.insert);
    remove = [].concat(remove, ret.remove);
  });
  prevNodes.forEach(function (prevNode, idx) {
    var currentNodeAtIndex = currentNodes[idx];

    if (!currentNodeAtIndex || currentNodeAtIndex.key !== prevNode.key) {
      remove.push(prevDocument.getPath(prevNode.key));
    }
  });
  return {
    insert: insert,
    remove: remove
  };
};

var diffDocument = function diffDocument(prevDocument, document, controller) {
  return diffNodes(prevDocument.nodes, document.nodes, {
    prevDocument: prevDocument,
    currentDocument: document
  }, controller);
};

var searchInNodeContent = function searchInNodeContent(node, content, findText, role) {
  var result = [];
  var keywords = findText.toLowerCase();
  content = content.toLowerCase();

  if (content.indexOf(keywords) === -1) {
    return result;
  }

  var endOffset = 0;

  do {
    var startOffset = content.indexOf(keywords, endOffset);

    if (startOffset === -1) {
      break;
    }

    endOffset = startOffset + keywords.length;
    result.push({
      type: role + "text",
      selected: false,
      key: node.key,
      extraData: {
        startOffset: startOffset,
        endOffset: endOffset
      }
    });
  } while (endOffset <= content.length);

  return result;
};

var searchInTextNode = function searchInTextNode(node, findText, role) {
  var content = node.text;
  var result = searchInNodeContent(node, content, findText, role);
  return result;
};

var createDecorationWithMatch = function createDecorationWithMatch(match) {
  var key = match.key,
      selected = match.selected,
      extraData = match.extraData;
  var start = TextPoint.create({
    key: key,
    offset: extraData == null ? void 0 : extraData.startOffset
  });
  var end = TextPoint.create({
    key: key,
    offset: extraData == null ? void 0 : extraData.endOffset
  });
  var mark = MatchMark.create(selected || false);
  return Decoration.create({
    start: start,
    end: end,
    mark: mark
  });
};

var applyTextMatches = function applyTextMatches(textMatches, controller) {
  var decorations = controller.value.decorations;
  var matchedDecorations = textMatches.map(createDecorationWithMatch);
  var noMatchedDecorations = getNoMatchedDecorations(decorations);
  controller.setDecorations(matchedDecorations.concat(noMatchedDecorations));
};

var dispatchNoTextMatches = function dispatchNoTextMatches(noTextMatches, controller) {
  var injections = controller.value.injections;
  var matchedInjections = noTextMatches.map(function (match) {
    var key = match.key;
    return Injection.create({
      key: key,
      data: {
        searchMatch: match
      }
    });
  });
  var otherInjections = injections.filter(function (_ref2) {
    var data = _ref2.data;
    return !data.searchMatch;
  });
  controller.setInjections([].concat(matchedInjections, otherInjections));
};

var search = function search(node, controller, role, result) {
  if (result === void 0) {
    result = [];
  }

  var _controller$value = controller.value,
      findText = _controller$value.data.findText,
      document = _controller$value.document;

  if (Text.isText(node)) {
    // 防止修订模式下被替换多次
    if (document.getClosestByPath(document.getPath(node.key), isDel)) {
      return result;
    }

    result = [].concat(result, searchInTextNode(node, findText, role));
  } else if (controller.query('isSupportSearch', node)) {
    var queryResult = controller.query('getSearchResult', findText, node);

    if (queryResult) {
      result.push(_extends({}, queryResult, {
        type: "" + role + (queryResult.readonly ? 'readonly_' : '') + queryResult.type
      }));
    }
  } else {
    node.forEachDescendant(function (n) {
      if (Text.isText(n) || controller.query('isSupportSearch', n)) {
        result = search(n, controller, role, result);
      }
    });
  }

  return result;
};

var patch = function patch(searchResult, patcher, controller, role) {
  var document = controller.value.document;
  var remove = patcher.remove,
      insert = patcher.insert;
  var appliedRemoveResult = searchResult.filter(function (_ref3) {
    var key = _ref3.key;
    var nodePath = document.getPath(key);
    if (!nodePath) return false;
    return !remove.some(function (path) {
      return isPathAboveOrSame(path, nodePath);
    });
  });
  var inserted = [];
  insert.forEach(function (path) {
    var node = document.getNodeByPath(path);

    if (!node) {
      return;
    }

    inserted = [].concat(inserted, search(node, controller, role));
  });
  inserted = inserted.filter(function (result) {
    return appliedRemoveResult.findIndex(function (prevResult) {
      return equal(prevResult, result);
    }) === -1;
  });
  return appliedRemoveResult.concat(inserted).sort(function (a, b) {
    if (a.key === b.key) {
      var _a$extraData, _b$extraData;

      return ((_a$extraData = a.extraData) == null ? void 0 : _a$extraData.endOffset) - ((_b$extraData = b.extraData) == null ? void 0 : _b$extraData.endOffset);
    }

    return Path.isBefore(document.getPath(a.key), document.getPath(b.key)) ? -1 : 1;
  });
}; // 分发统一查找替换结果
// text 类型由查找替换插件处理
// 其他类型通过 injections 注入 globalSearchMatches 到对应节点 data


var dispatchSearchResults = function dispatchSearchResults(unifiedSearchResults, controller) {
  var _unifiedSearchResults = unifiedSearchResults.reduce(function (matches, match) {
    isTextMatch(match) ? matches[0].push(match) : matches[1].push(match);
    return matches;
  }, [[], []]),
      textMatches = _unifiedSearchResults[0],
      otherMatches = _unifiedSearchResults[1];

  applyTextMatches(textMatches, controller);
  dispatchNoTextMatches(otherMatches, controller);
};

var createOnChange = function createOnChange(config, cache) {
  var _config$role = config.role,
      role = _config$role === void 0 ? '' : _config$role,
      isFindOnly = config.isFindOnly,
      onFilter = config.onFilter;
  return function (controller, next) {
    var _controller$value2 = controller.value,
        data = _controller$value2.data,
        document = _controller$value2.document;
    var findText = data.findText,
        prevFindText = data.prevFindText;
    var _data$searchResult = data.searchResult,
        searchResult = _data$searchResult === void 0 ? [] : _data$searchResult; // 不响应非查找替换变更

    if (!prevFindText && !findText) {
      return next();
    }

    if (document.data.pi) {
      return next();
    } // 查找文本为空，清除


    if (!findText) {
      dispatchSearchResults([], controller);
      mergeData(controller, {
        searchResult: [],
        prevFindText: undefined
      });
      return next();
    }

    var isFindTextChanged = findText !== prevFindText;
    var focusIndex = getFocusIndex(searchResult);

    if (isFindTextChanged) {
      cache.prevFocusIndex = -1;
    }

    var isFocusIndexChanged = focusIndex !== cache.prevFocusIndex;
    var prevDocument = isFindTextChanged ? emptyDocument : cache.prevDocument || emptyDocument; // 查找文本和文档都没有变化

    if (!isFindTextChanged && equal(document, prevDocument)) {
      // 只有索引变化
      if (isFocusIndexChanged) {
        dispatchSearchResults(searchResult, controller);
        cache.prevFocusIndex = focusIndex;
      }

      return next();
    }

    if (isFindTextChanged) {
      searchResult = [];
    }

    var patcher = diffDocument(prevDocument, document, controller);
    var roleWithAbility = role + "_" + (isFindOnly ? 'readonly_' : '');
    var newSearchResult = patch(searchResult, patcher, controller, roleWithAbility); // 如果之前有选中项，document 变更时维持选中项不变
    // fix: 修改选中项所在行文本, 选中项丢失

    var idx = cache.prevFocusIndex;
    var newIndex = Math.min(idx, newSearchResult.length - 1);
    var newSearchResultWithSelected = newSearchResult.map(function (s, index) {
      if (index === newIndex) {
        return _extends({}, s, {
          selected: true
        });
      }

      return s;
    });
    var filteredSearchResult = onFilter ? onFilter(newSearchResultWithSelected) : newSearchResultWithSelected;
    dispatchSearchResults(filteredSearchResult, controller);
    mergeData(controller, {
      prevFindText: findText,
      searchResult: filteredSearchResult
    });
    cache.prevDocument = document;
    return next();
  };
};

export default createOnChange;
//# sourceMappingURL=createOnChange.js.map