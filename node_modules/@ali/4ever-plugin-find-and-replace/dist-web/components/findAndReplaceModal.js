/* eslint-disable react-hooks/exhaustive-deps */
import React, { useCallback, useEffect, useRef, useState } from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import { useScrollableContainer } from '@ali/4ever-cangjie';
import { FindAndReplacePortal, message } from '@ali/we-design';
import { debounce } from 'lodash-es';
import { isKeyHotkey } from 'is-hotkey';
import { toggleFindAndReplace, replaceText, updateFindText, updateSearchResult, updateFindFragment } from "../common/actions";
import { isReadonlyMatch, scrollIntoFocus } from "../utils";
var DEFAULT_TAB_KEY = 'find';
var DEFAULT_REPLACE_TEXT = '';

var FindAndReplaceModal = function FindAndReplaceModal(props) {
  var draggableArea = props.draggableArea,
      initialPosition = props.initialPosition,
      isFindOnly = props.isFindOnly,
      mainController = props.mainController,
      locale = props.locale,
      ctlManager = props.ctlManager,
      onScrollIntoFocus = props.onScrollIntoFocus,
      onFilter = props.onFilter,
      onCustomScroll = props.onCustomScroll;

  var _useState = useState(''),
      findText = _useState[0],
      setFindText = _useState[1];

  var _useState2 = useState(true),
      focused = _useState2[0],
      setFocused = _useState2[1];

  var modalRef = useRef(null);
  var domRef = useRef(null);
  var matches = [];
  ctlManager.run(function (ctl) {
    var _ref = ctl.query('getDataValue') || ctl.value,
        data = _ref.data;

    var searchResult = data.searchResult;

    if ((searchResult == null ? void 0 : searchResult.length) > 0) {
      var _matches;

      (_matches = matches).push.apply(_matches, searchResult);
    }
  });

  if (onFilter) {
    matches = onFilter(matches);
  }

  var matchedCount = matches.length;
  var data = mainController.value.data;
  var visible = data.findAndReplaceVisible || false;
  var _data$findFragment = data.findFragment,
      findFragment = _data$findFragment === void 0 ? '' : _data$findFragment;
  var focusIndex = 0;
  var isInit = false;

  if (matches.length > 0) {
    var idx = matches.findIndex(function (match) {
      return match.selected;
    });

    if (idx === -1) {
      // 当存在 「匹配项」 但没有 「选中项」时初始化第一项为选中项
      focusIndex = 1;
      isInit = true;
    } else {
      focusIndex = idx + 1;
    }
  }

  var focusMatch = matches[focusIndex - 1];
  var disableReplace = isReadonlyMatch(focusMatch);
  var disableReplaceAll = matches.every(isReadonlyMatch);
  var container = useScrollableContainer() || window;
  var debouncedUpdateFindText = useCallback(debounce(function (text) {
    ctlManager.runWithSchedule(function (ctl) {
      ctl.run('onAction', updateFindText(text));
    });
  }, 200), [ctlManager]);
  var handleFindInputChange = useCallback(function (event) {
    var text = typeof event === 'string' ? event : event.target.value;
    debouncedUpdateFindText(text);

    if (findFragment) {
      mainController.run('onAction', updateFindFragment(''));
    }

    setFindText(text);
  }, [debouncedUpdateFindText, findFragment, mainController]); // 新增实例时更新下搜索结果

  useEffect(function () {
    ctlManager.runWithSchedule(function (ctl) {
      ctl.run('onAction', updateFindText(findText));
    });
  }, [ctlManager.ctls[ctlManager.ctls.length - 1]]); // 绑定监听

  useEffect(function () {
    var handleKeyDown = function handleKeyDown(event) {
      var isFindHotKey = isKeyHotkey('mod+f');

      if (isFindHotKey(event)) {
        event.preventDefault();
        event.stopPropagation();
        var findAndReplaceVisible = mainController.value.data.findAndReplaceVisible;
        var fragment = '';
        ctlManager.run(function (ctl) {
          var _ctl$value$fragment;

          var text = (_ctl$value$fragment = ctl.value.fragment) == null ? void 0 : _ctl$value$fragment.text;

          if (text) {
            fragment = text;
          }
        });

        if (!findAndReplaceVisible) {
          mainController.run('onAction', toggleFindAndReplace(true));
        } else {
          var _domRef$current, _domRef$current$query;

          // 查找替换组件没有提供设置 input focus 的方法，这里临时处理下
          (_domRef$current = domRef.current) == null ? void 0 : (_domRef$current$query = _domRef$current.querySelector('[aria-hidden="false"] input[data-testid="J_findValueInput"]')) == null ? void 0 : _domRef$current$query.focus();
        }

        if (fragment) {
          mainController.run('onAction', updateFindFragment(fragment));
        }
      }
    };

    var handleMouseDown = function handleMouseDown(event) {
      var dom = domRef.current;

      if (!dom) {
        return;
      }

      var isFocus = Boolean(dom.contains(event.target));
      setFocused(isFocus);
    };

    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('mousedown', handleMouseDown);
    return function () {
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('mousedown', handleMouseDown);
    };
  }, [ctlManager, mainController]); // 从选区初始化 findText

  useEffect(function () {
    if (findFragment) {
      handleFindInputChange(findFragment); // 这里延迟一下，等输入框有内容后再选中

      Promise.resolve().then(function () {
        if (modalRef.current) {
          modalRef.current.selectInput();
        }
      });
      setFocused(true);
    }
  }, [findFragment, handleFindInputChange]);

  var handleFocusIndexChange = function handleFocusIndexChange(index) {
    var newFocusIndex = (matchedCount + index - 1) % matchedCount;
    var newFocusMatch = matches[newFocusIndex];
    ctlManager.runWithSchedule(function (ctl) {
      ctl.run('onAction', updateSearchResult(newFocusMatch));

      if (newFocusMatch) {
        onScrollIntoFocus && onScrollIntoFocus(newFocusMatch.type);
        scrollIntoFocus(newFocusMatch.key, ctl, container, findText, onCustomScroll);
      }
    });
  };

  var handleReplaceCurrent = function handleReplaceCurrent(targetText) {
    ctlManager.runWithSchedule(function (ctl) {
      ctl.run('onAction', replaceText(focusMatch, targetText));
    });
    var newFocusIndex = focusIndex === matchedCount ? focusIndex - 2 : focusIndex;
    var newFocusMatch = matches[newFocusIndex];
    ctlManager.runWithSchedule(function (ctl) {
      ctl.run('onAction', updateSearchResult(newFocusMatch));

      if (newFocusMatch) {
        onScrollIntoFocus && onScrollIntoFocus(newFocusMatch.type);
        scrollIntoFocus(newFocusMatch.key, ctl, container, findText, onCustomScroll);
      }
    });
  };

  var handleReplaceAll = function handleReplaceAll(targetText) {
    var canReplaceMatches = matches.filter(function (match) {
      return !isReadonlyMatch(match);
    });
    canReplaceMatches.forEach(function (m) {
      return ctlManager.runWithSchedule(function (ctl) {
        ctl.run('onAction', replaceText(m, targetText));
      });
    }); // 提示不支持替换的元素个数

    var noSupportSearchCount = matchedCount - canReplaceMatches.length;

    if (noSupportSearchCount) {
      var noSupportLeft = locale.noSupportLeft,
          noSupportRight = locale.noSupportRight;
      message.info(noSupportLeft + " " + noSupportSearchCount + " " + noSupportRight, 2);
    }
  };

  var handleVisibleChange = function handleVisibleChange(v) {
    mainController.run('onAction', toggleFindAndReplace(v));
  }; // 关闭时清除搜索


  useEffect(function () {
    if (!visible) {
      handleFindInputChange('');
    }
  }, [visible, handleFindInputChange]); // 初始化第一个匹配项为选中项

  useEffect(function () {
    if (isInit) {
      ctlManager.runWithSchedule(function (ctl) {
        ctl.run('onAction', updateSearchResult(focusMatch));
        onScrollIntoFocus && onScrollIntoFocus(focusMatch.type);
        scrollIntoFocus(focusMatch.key, ctl, container, findText, onCustomScroll);
      });
    }
  }, [ctlManager, focusMatch, isInit]);
  return /*#__PURE__*/_createElement(FindAndReplacePortal, {
    visible: visible,
    focused: focused,
    isFindOnly: isFindOnly,
    defaultTabKey: DEFAULT_TAB_KEY,
    disableReplace: disableReplace,
    disableReplaceAll: disableReplaceAll,
    zIndex: 1000,
    draggableArea: draggableArea,
    initialPosition: initialPosition,
    testid: "FindAndReplacePortal",
    findText: findText,
    focusIndex: focusIndex,
    matchedCount: matchedCount,
    defaultReplaceText: DEFAULT_REPLACE_TEXT,
    wrappedRef: modalRef,
    domRef: domRef,
    onFindInputChange: handleFindInputChange,
    onFocusIndexChange: handleFocusIndexChange,
    onReplaceCurrent: handleReplaceCurrent,
    onReplaceAll: handleReplaceAll,
    onVisibleChange: handleVisibleChange
  });
};

export default FindAndReplaceModal;
//# sourceMappingURL=findAndReplaceModal.js.map