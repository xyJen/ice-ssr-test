{"version":3,"sources":["../../../src/utils/getHeadings.ts"],"names":["Inline","StickerType","createHeadingId","getSymbolByListOrder","headingTypes","PreventDFSTypes","getHeadings","value","document","originHeadings","existedLevels","itemCountMap","Map","nodes","forEach","node","type","data","listSymbol","typeLevel","parseInt","slice","headingText","forEachDescendant","n","isInline","name","includes","text","code","push","id","key","level","uuid","sort","a","b","map","heading","indexOf"],"mappings":"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","sourcesContent":["import { Block, Value, Inline, Element } from '@ali/4ever-cangjie';\nimport { StickerType } from '@ali/4ever-plugin-sticker';\nimport type { FoldableHeadingData } from '../mo/models/heading1';\nimport { createHeadingId } from './createHeadingId';\nimport { ListCountContext, getSymbolByListOrder } from '@ali/4ever-plugin-list';\n\nconst headingTypes = {\n  'heading-1': true,\n  'heading-2': true,\n  'heading-3': true,\n  'heading-4': true,\n};\nexport interface IHeadingItem {\n  id: string;\n  key: string;\n  text: string;\n  typeLevel: number;\n  level: number;\n  uuid?: string;\n  node: Block<FoldableHeadingData>;\n}\n\n/**\n * 这类节点在进行深度子节点遍历获取text的时候，由于自身text会被获取一遍，leafes节点又会被获取一遍text\n * 会导致文本重复问题，需要禁止继续遍历\n */\nconst PreventDFSTypes = ['link', 'ins', 'del'];\n\nexport function getHeadings(value: Value): IHeadingItem[] {\n  const { document } = value;\n  const originHeadings: IHeadingItem[] = [];\n  let existedLevels: number[] = [];\n  const itemCountMap = new Map<string, ListCountContext>();\n\n  // typeLevel 真实 level\n  // level format 之后的 level\n  // 1. 找到所有的 heading 及 相关 typeLevel 组成的数组；\n  document.nodes.forEach((node) => {\n    // @ts-ignore\n    const { type, data } = node;\n    const listSymbol = getSymbolByListOrder(data, itemCountMap);\n    if (headingTypes[type]) {\n      const typeLevel = parseInt(type.slice(-1), 10);\n      let headingText = listSymbol ? `${listSymbol} ` : '';\n\n      // @ts-ignore\n      node.forEachDescendant((n: Element) => {\n        // 这种写法不算好，依赖 mention 的数据结构且可能还有遗漏\n        if (Inline.isInline(n) && n.type === 'mention') {\n          headingText += `@${n.data.name}`;\n        } else if (Inline.isInline(n) && PreventDFSTypes.includes(n.type)) {\n          // 对于 link 节点，需要阻止继续遍历，否则会出现两遍重复文本\n          headingText += n.text;\n          return false;\n        } else if (Inline.isInline(n) && n.type === StickerType) {\n          headingText += `[${n.data.code}]`;\n        } else {\n          headingText += n.text;\n        }\n      });\n      if (headingText) {\n        originHeadings.push({\n          id: createHeadingId(node),\n          key: node.key,\n          text: headingText,\n          typeLevel,\n          level: typeLevel,\n          uuid: data?.uuid,\n          node: node as Block<FoldableHeadingData>,\n        });\n      }\n      if (!existedLevels.includes(typeLevel)) {\n        existedLevels.push(typeLevel);\n      }\n    }\n  });\n\n  // 2. 排序 level 组成的数组；\n  existedLevels = existedLevels.sort((a, b) => a - b);\n\n  // 3. 将 level 映射为 typeLevel 的 index + 1\n  return originHeadings.map((heading: IHeadingItem) => (\n    {\n      ...heading,\n      level: existedLevels.indexOf(heading.typeLevel) + 1,\n    }\n  ));\n}\n"],"file":"getHeadings.js"}