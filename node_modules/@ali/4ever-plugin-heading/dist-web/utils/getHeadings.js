import _extends from "@babel/runtime/helpers/extends";
import { Inline } from '@ali/4ever-cangjie';
import { StickerType } from '@ali/4ever-plugin-sticker';
import { createHeadingId } from "./createHeadingId";
import { getSymbolByListOrder } from '@ali/4ever-plugin-list';
var headingTypes = {
  'heading-1': true,
  'heading-2': true,
  'heading-3': true,
  'heading-4': true
};

/**
 * 这类节点在进行深度子节点遍历获取text的时候，由于自身text会被获取一遍，leafes节点又会被获取一遍text
 * 会导致文本重复问题，需要禁止继续遍历
 */
var PreventDFSTypes = ['link', 'ins', 'del'];
export function getHeadings(value) {
  var document = value.document;
  var originHeadings = [];
  var existedLevels = [];
  var itemCountMap = new Map(); // typeLevel 真实 level
  // level format 之后的 level
  // 1. 找到所有的 heading 及 相关 typeLevel 组成的数组；

  document.nodes.forEach(function (node) {
    // @ts-ignore
    var type = node.type,
        data = node.data;
    var listSymbol = getSymbolByListOrder(data, itemCountMap);

    if (headingTypes[type]) {
      var typeLevel = parseInt(type.slice(-1), 10);
      var headingText = listSymbol ? listSymbol + " " : ''; // @ts-ignore

      node.forEachDescendant(function (n) {
        // 这种写法不算好，依赖 mention 的数据结构且可能还有遗漏
        if (Inline.isInline(n) && n.type === 'mention') {
          headingText += "@" + n.data.name;
        } else if (Inline.isInline(n) && PreventDFSTypes.includes(n.type)) {
          // 对于 link 节点，需要阻止继续遍历，否则会出现两遍重复文本
          headingText += n.text;
          return false;
        } else if (Inline.isInline(n) && n.type === StickerType) {
          headingText += "[" + n.data.code + "]";
        } else {
          headingText += n.text;
        }
      });

      if (headingText) {
        originHeadings.push({
          id: createHeadingId(node),
          key: node.key,
          text: headingText,
          typeLevel: typeLevel,
          level: typeLevel,
          uuid: data == null ? void 0 : data.uuid,
          node: node
        });
      }

      if (!existedLevels.includes(typeLevel)) {
        existedLevels.push(typeLevel);
      }
    }
  }); // 2. 排序 level 组成的数组；

  existedLevels = existedLevels.sort(function (a, b) {
    return a - b;
  }); // 3. 将 level 映射为 typeLevel 的 index + 1

  return originHeadings.map(function (heading) {
    return _extends({}, heading, {
      level: existedLevels.indexOf(heading.typeLevel) + 1
    });
  });
}
//# sourceMappingURL=getHeadings.js.map