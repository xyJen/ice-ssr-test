{"version":3,"sources":["../../../src/utils/getHeadings.ts"],"names":["headingTypes","PreventDFSTypes","getHeadings","value","document","originHeadings","existedLevels","itemCountMap","Map","nodes","forEach","node","type","data","listSymbol","typeLevel","parseInt","slice","headingText","forEachDescendant","n","Inline","isInline","name","includes","text","StickerType","code","push","id","key","level","uuid","sort","a","b","map","heading","indexOf"],"mappings":"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","sourcesContent":["import { Block, Value, Inline, Element } from '@ali/4ever-cangjie';\nimport { StickerType } from '@ali/4ever-plugin-sticker';\nimport type { FoldableHeadingData } from '../mo/models/heading1';\nimport { createHeadingId } from './createHeadingId';\nimport { ListCountContext, getSymbolByListOrder } from '@ali/4ever-plugin-list';\n\nconst headingTypes = {\n  'heading-1': true,\n  'heading-2': true,\n  'heading-3': true,\n  'heading-4': true,\n};\nexport interface IHeadingItem {\n  id: string;\n  key: string;\n  text: string;\n  typeLevel: number;\n  level: number;\n  uuid?: string;\n  node: Block<FoldableHeadingData>;\n}\n\n/**\n * 这类节点在进行深度子节点遍历获取text的时候，由于自身text会被获取一遍，leafes节点又会被获取一遍text\n * 会导致文本重复问题，需要禁止继续遍历\n */\nconst PreventDFSTypes = ['link', 'ins', 'del'];\n\nexport function getHeadings(value: Value): IHeadingItem[] {\n  const { document } = value;\n  const originHeadings: IHeadingItem[] = [];\n  let existedLevels: number[] = [];\n  const itemCountMap = new Map<string, ListCountContext>();\n\n  // typeLevel 真实 level\n  // level format 之后的 level\n  // 1. 找到所有的 heading 及 相关 typeLevel 组成的数组；\n  document.nodes.forEach((node) => {\n    // @ts-ignore\n    const { type, data } = node;\n    const listSymbol = getSymbolByListOrder(data, itemCountMap);\n    if (headingTypes[type]) {\n      const typeLevel = parseInt(type.slice(-1), 10);\n      let headingText = listSymbol ? `${listSymbol} ` : '';\n\n      // @ts-ignore\n      node.forEachDescendant((n: Element) => {\n        // 这种写法不算好，依赖 mention 的数据结构且可能还有遗漏\n        if (Inline.isInline(n) && n.type === 'mention') {\n          headingText += `@${n.data.name}`;\n        } else if (Inline.isInline(n) && PreventDFSTypes.includes(n.type)) {\n          // 对于 link 节点，需要阻止继续遍历，否则会出现两遍重复文本\n          headingText += n.text;\n          return false;\n        } else if (Inline.isInline(n) && n.type === StickerType) {\n          headingText += `[${n.data.code}]`;\n        } else {\n          headingText += n.text;\n        }\n      });\n      if (headingText) {\n        originHeadings.push({\n          id: createHeadingId(node),\n          key: node.key,\n          text: headingText,\n          typeLevel,\n          level: typeLevel,\n          uuid: data?.uuid,\n          node: node as Block<FoldableHeadingData>,\n        });\n      }\n      if (!existedLevels.includes(typeLevel)) {\n        existedLevels.push(typeLevel);\n      }\n    }\n  });\n\n  // 2. 排序 level 组成的数组；\n  existedLevels = existedLevels.sort((a, b) => a - b);\n\n  // 3. 将 level 映射为 typeLevel 的 index + 1\n  return originHeadings.map((heading: IHeadingItem) => (\n    {\n      ...heading,\n      level: existedLevels.indexOf(heading.typeLevel) + 1,\n    }\n  ));\n}\n"],"file":"getHeadings.js"}