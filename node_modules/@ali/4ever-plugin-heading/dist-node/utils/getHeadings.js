"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getHeadings = getHeadings;

var _everCangjie = require("@ali/4ever-cangjie");

var _everPluginSticker = require("@ali/4ever-plugin-sticker");

var _createHeadingId = require("./createHeadingId");

var _everPluginList = require("@ali/4ever-plugin-list");

const headingTypes = {
  'heading-1': true,
  'heading-2': true,
  'heading-3': true,
  'heading-4': true
};

/**
 * 这类节点在进行深度子节点遍历获取text的时候，由于自身text会被获取一遍，leafes节点又会被获取一遍text
 * 会导致文本重复问题，需要禁止继续遍历
 */
const PreventDFSTypes = ['link', 'ins', 'del'];

function getHeadings(value) {
  const {
    document
  } = value;
  const originHeadings = [];
  let existedLevels = [];
  const itemCountMap = new Map(); // typeLevel 真实 level
  // level format 之后的 level
  // 1. 找到所有的 heading 及 相关 typeLevel 组成的数组；

  document.nodes.forEach(node => {
    // @ts-ignore
    const {
      type,
      data
    } = node;
    const listSymbol = (0, _everPluginList.getSymbolByListOrder)(data, itemCountMap);

    if (headingTypes[type]) {
      const typeLevel = parseInt(type.slice(-1), 10);
      let headingText = listSymbol ? `${listSymbol} ` : ''; // @ts-ignore

      node.forEachDescendant(n => {
        // 这种写法不算好，依赖 mention 的数据结构且可能还有遗漏
        if (_everCangjie.Inline.isInline(n) && n.type === 'mention') {
          headingText += `@${n.data.name}`;
        } else if (_everCangjie.Inline.isInline(n) && PreventDFSTypes.includes(n.type)) {
          // 对于 link 节点，需要阻止继续遍历，否则会出现两遍重复文本
          headingText += n.text;
          return false;
        } else if (_everCangjie.Inline.isInline(n) && n.type === _everPluginSticker.StickerType) {
          headingText += `[${n.data.code}]`;
        } else {
          headingText += n.text;
        }
      });

      if (headingText) {
        originHeadings.push({
          id: (0, _createHeadingId.createHeadingId)(node),
          key: node.key,
          text: headingText,
          typeLevel,
          level: typeLevel,
          uuid: data?.uuid,
          node: node
        });
      }

      if (!existedLevels.includes(typeLevel)) {
        existedLevels.push(typeLevel);
      }
    }
  }); // 2. 排序 level 组成的数组；

  existedLevels = existedLevels.sort((a, b) => a - b); // 3. 将 level 映射为 typeLevel 的 index + 1

  return originHeadings.map(heading => ({ ...heading,
    level: existedLevels.indexOf(heading.typeLevel) + 1
  }));
}
//# sourceMappingURL=getHeadings.js.map