"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.marksToStyle = marksToStyle;
exports.MarksComponent = MarksComponent;
exports.MarksOptionContext = exports.setStyleWithMark = void 0;

var React = _interopRequireWildcard(require("react"));

var _everUtils = require("@ali/4ever-utils");

const _createElement = /*#__PURE__*/React.createElement;
const inlineCodeTheme_BGCOLOR = _everUtils.inlineCodeTheme['background-color'];

const fillStyle = options => (style, mark) => {
  const disableHighlight = options?.disableHighlight;

  if (mark.type === 'bold') {
    if (mark.data.value === false) {
      style.fontWeight = 'normal';
    } else {
      style.fontWeight = 'bold';
    }
  } else if (mark.type === 'color') {
    const {
      value
    } = mark.data;

    if ((0, _everUtils.isGradientColor)(value)) {
      (0, _everUtils.setGradientStyle)(value, style);
    } else {
      style.color = value;
    }
  } else if (mark.type === 'fonts') {
    style.fontFamily = _everUtils.fontRenderFallback.getFontFallback(mark);
  } else if (mark.type === 'highlight') {
    if (!disableHighlight && mark.data.value !== 'transparent') {
      style.backgroundColor = mark.data.value;
    }
  } else if (mark.type === 'shd') {
    if (!disableHighlight) {
      // shd 优先级更低（highlight 直接覆盖）
      style.backgroundColor = style.backgroundColor || _everUtils.ShdUtil.transformShd(mark.data);
    }
  } else if (mark.type === 'italic') {
    style.fontStyle = 'italic';
  } else if (mark.type === 'underline' || mark.type === 'strike' || mark.type === 'dstrike') {
    _everUtils.UnderlineUtil.setTextDecotation(style, mark.type, mark);
  } else if (mark.type === 'sz') {
    // 最终呈现需要在移动端考虑放大sz
    style.fontSize = `${_everUtils.SzUtil.fromMark(mark) * _everUtils.SzUtil.FONTSIZE_BIGGER}pt`;
  } else if (mark.type === 'vertAlign') {
    const vertAlign = mark.data.value; // TODO: 字号较大时与 word 存在较大差异

    if (vertAlign === 'superscript') {
      style.verticalAlign = 'super';
    } else if (vertAlign === 'subscript') {
      style.verticalAlign = 'sub';
    }
  } else if (mark.type === 'inlineCode') {
    style.padding = _everUtils.inlineCodeTheme.padding;
    style.margin = _everUtils.inlineCodeTheme.margin;
    style.border = _everUtils.inlineCodeTheme.border;
    style.borderRadius = _everUtils.inlineCodeTheme['border-radius'];
    style.fontFamily = _everUtils.inlineCodeTheme['font-family'];
    style.wordBreak = _everUtils.inlineCodeTheme['word-break'];
  } else if (mark.type === 'em' && mark.data.value) {
    const isComma = mark.data.value === 'comma';
    style.WebkitTextEmphasisStyle = isComma ? 'sesame' : mark.data.value;
    style.WebkitTextEmphasisPosition = isComma ? 'over' : 'under';
  } else if (mark.type === 'caps') {
    if (mark.data.value) {
      style.textTransform = 'uppercase';
    }
  } else if (mark.type === 'smallCaps') {
    style.fontVariantCaps = 'small-caps';
  }

  if (mark.type === 'spacing' && mark.data.value) {
    style.letterSpacing = `${mark.data.value * 2}pt`;
  }

  return style;
};

function marksToStyle(marks, ops) {
  const style = marks.reduce(fillStyle(ops), {});
  const kernMark = marks.find(m => m.type === 'kern');
  const hasInlineCode = marks.some(m => m.type === 'inlineCode');

  if (hasInlineCode) {
    // 背景色以 行内代码 为准
    style.backgroundColor = inlineCodeTheme_BGCOLOR;
  }

  if (style.verticalAlign || kernMark) {
    const sz = parseFloat(`${style.fontSize}`) || _everUtils.fontSize.DEFAULT;

    if (style.verticalAlign) {
      // 上下标字号减半
      style.fontSize = `${sz / 2}pt`;
    }

    if (kernMark && (kernMark.data.value === 0 || sz < kernMark.data.value)) {
      // 禁止 kerning
      style.fontKerning = 'none';
    }
  }

  if ((0, _everUtils.shouldDegradeGradient)(style)) {
    // 渐变色和删除线有冲突，设置删除线时渐变色退化为第一个颜色
    Object.keys(_everUtils.GRADIENT_COLOR_STYLE).forEach(gradientStyle => delete style[gradientStyle]);
  } // 斜体渐变色右边缘可能被截断, 当斜体和渐变色同时存在时设置右边距


  if (style.fontStyle === 'italic' && _everUtils.GRADIENT_STYLE_FLAG in style) {
    if (!style.paddingRight && !style.marginRight) {
      style.paddingRight = '0.2em';
      style.marginRight = '-0.2em';
    }
  }

  return style;
}

const setStyleWithMark = fillStyle();
exports.setStyleWithMark = setStyleWithMark;
const MarksOptionContext = /*#__PURE__*/React.createContext({
  disableHighlight: false
});
exports.MarksOptionContext = MarksOptionContext;

function MarksComponent(props) {
  const marksOption = React.useContext(MarksOptionContext);
  const {
    marks,
    children
  } = props; // memo style (marks not always change, eg: selection change)

  const style = React.useMemo(() => {
    return marksToStyle(marks, marksOption);
  }, [marks, marksOption]);
  const hasInlineCode = React.useMemo(() => marks.some(mark => mark.type === 'inlineCode'), [marks]);

  if (hasInlineCode) {
    return /*#__PURE__*/_createElement("code", {
      "data-cangjie-mark": true,
      style: style
    }, children());
  }

  const onlyChild = React.Children.only(children());
  return /*#__PURE__*/React.cloneElement(onlyChild, {
    'data-cangjie-mark': true,
    style
  });
}
//# sourceMappingURL=marks.js.map