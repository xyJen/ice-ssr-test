import * as React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import { inlineCodeTheme } from '@ali/4ever-utils';
import { fontSize } from '@ali/4ever-utils';
import { SzUtil, ShdUtil, UnderlineUtil, fontRenderFallback, GRADIENT_COLOR_STYLE, GRADIENT_STYLE_FLAG, isGradientColor, setGradientStyle, shouldDegradeGradient } from '@ali/4ever-utils';
var inlineCodeTheme_BGCOLOR = inlineCodeTheme['background-color'];

var fillStyle = function fillStyle(options) {
  return function (style, mark) {
    var disableHighlight = options == null ? void 0 : options.disableHighlight;

    if (mark.type === 'bold') {
      if (mark.data.value === false) {
        style.fontWeight = 'normal';
      } else {
        style.fontWeight = 'bold';
      }
    } else if (mark.type === 'color') {
      var value = mark.data.value;

      if (isGradientColor(value)) {
        setGradientStyle(value, style);
      } else {
        style.color = value;
      }
    } else if (mark.type === 'fonts') {
      style.fontFamily = fontRenderFallback.getFontFallback(mark);
    } else if (mark.type === 'highlight') {
      if (!disableHighlight && mark.data.value !== 'transparent') {
        style.backgroundColor = mark.data.value;
      }
    } else if (mark.type === 'shd') {
      if (!disableHighlight) {
        // shd 优先级更低（highlight 直接覆盖）
        style.backgroundColor = style.backgroundColor || ShdUtil.transformShd(mark.data);
      }
    } else if (mark.type === 'italic') {
      style.fontStyle = 'italic';
    } else if (mark.type === 'underline' || mark.type === 'strike' || mark.type === 'dstrike') {
      UnderlineUtil.setTextDecotation(style, mark.type, mark);
    } else if (mark.type === 'sz') {
      // 最终呈现需要在移动端考虑放大sz
      style.fontSize = SzUtil.fromMark(mark) * SzUtil.FONTSIZE_BIGGER + "pt";
    } else if (mark.type === 'vertAlign') {
      var vertAlign = mark.data.value; // TODO: 字号较大时与 word 存在较大差异

      if (vertAlign === 'superscript') {
        style.verticalAlign = 'super';
      } else if (vertAlign === 'subscript') {
        style.verticalAlign = 'sub';
      }
    } else if (mark.type === 'inlineCode') {
      style.padding = inlineCodeTheme.padding;
      style.margin = inlineCodeTheme.margin;
      style.border = inlineCodeTheme.border;
      style.borderRadius = inlineCodeTheme['border-radius'];
      style.fontFamily = inlineCodeTheme['font-family'];
      style.wordBreak = inlineCodeTheme['word-break'];
    } else if (mark.type === 'em' && mark.data.value) {
      var isComma = mark.data.value === 'comma';
      style.WebkitTextEmphasisStyle = isComma ? 'sesame' : mark.data.value;
      style.WebkitTextEmphasisPosition = isComma ? 'over' : 'under';
    } else if (mark.type === 'caps') {
      if (mark.data.value) {
        style.textTransform = 'uppercase';
      }
    } else if (mark.type === 'smallCaps') {
      style.fontVariantCaps = 'small-caps';
    }

    if (mark.type === 'spacing' && mark.data.value) {
      style.letterSpacing = mark.data.value * 2 + "pt";
    }

    return style;
  };
};

export function marksToStyle(marks, ops) {
  var style = marks.reduce(fillStyle(ops), {});
  var kernMark = marks.find(function (m) {
    return m.type === 'kern';
  });
  var hasInlineCode = marks.some(function (m) {
    return m.type === 'inlineCode';
  });

  if (hasInlineCode) {
    // 背景色以 行内代码 为准
    style.backgroundColor = inlineCodeTheme_BGCOLOR;
  }

  if (style.verticalAlign || kernMark) {
    var sz = parseFloat("" + style.fontSize) || fontSize.DEFAULT;

    if (style.verticalAlign) {
      // 上下标字号减半
      style.fontSize = sz / 2 + "pt";
    }

    if (kernMark && (kernMark.data.value === 0 || sz < kernMark.data.value)) {
      // 禁止 kerning
      style.fontKerning = 'none';
    }
  }

  if (shouldDegradeGradient(style)) {
    // 渐变色和删除线有冲突，设置删除线时渐变色退化为第一个颜色
    Object.keys(GRADIENT_COLOR_STYLE).forEach(function (gradientStyle) {
      return delete style[gradientStyle];
    });
  } // 斜体渐变色右边缘可能被截断, 当斜体和渐变色同时存在时设置右边距


  if (style.fontStyle === 'italic' && GRADIENT_STYLE_FLAG in style) {
    if (!style.paddingRight && !style.marginRight) {
      style.paddingRight = '0.2em';
      style.marginRight = '-0.2em';
    }
  }

  return style;
}
export var setStyleWithMark = fillStyle();
export var MarksOptionContext = /*#__PURE__*/React.createContext({
  disableHighlight: false
});
export function MarksComponent(props) {
  var marksOption = React.useContext(MarksOptionContext);
  var marks = props.marks,
      children = props.children; // memo style (marks not always change, eg: selection change)

  var style = React.useMemo(function () {
    return marksToStyle(marks, marksOption);
  }, [marks, marksOption]);
  var hasInlineCode = React.useMemo(function () {
    return marks.some(function (mark) {
      return mark.type === 'inlineCode';
    });
  }, [marks]);

  if (hasInlineCode) {
    return /*#__PURE__*/_createElement("code", {
      "data-cangjie-mark": true,
      style: style
    }, children());
  }

  var onlyChild = React.Children.only(children());
  return /*#__PURE__*/React.cloneElement(onlyChild, {
    'data-cangjie-mark': true,
    style: style
  });
}
//# sourceMappingURL=marks.js.map