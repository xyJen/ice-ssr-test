import React from 'react';
export * from './hooks/useDragStyle';
export interface IDragAndDropHOChandlers {
    shouldDragElement?: (event: any) => boolean;
}
export interface IDraggableArea {
    top: number;
    right: number;
    bottom: number;
    left: number;
}
export interface IDragAndDropPosition {
    marginTop: number;
    marginRight: number;
}
export interface IDragAndDropHOCProps {
    /**
     * 对话框可拖拽的区域
     */
    draggableArea: IDraggableArea;
    /**
     * 初始坐标位置
     */
    initialPosition: IDragAndDropPosition;
    /**
     * 是否显示查找框
     */
    visible: boolean;
    /**
     * 是否显示发生变化的回调
     */
    onVisibleChange: (visible: boolean) => void;
    /**
     * 拖拽元素的z-index, 默认为auto
     */
    zIndex?: number;
    /**
     * HOC 内部组件的引用
     */
    wrappedRef?: React.RefObject<any>;
    /**
     * 用于测试
     */
    testid?: string;
}
export interface IDragAndDropHOCState {
    dragging: boolean;
}
export declare const dragAndDropHOC: <P>(WrappedComponent: React.FC<P> | (new (props: P) => React.Component<P, any, any>), handlers: IDragAndDropHOChandlers) => {
    new (props: P & IDragAndDropHOCProps): {
        startPageX: number;
        startPageY: number;
        startMarginTop: number;
        startMarginRight: number;
        maxMarginTop: number;
        maxMarginRight: number;
        modalRef: React.RefObject<HTMLDivElement>;
        componentDidMount(): void;
        componentWillUnmount(): void;
        handleMouseDown: (event: any) => void;
        setMax: () => void;
        handleResize: {
            (...args: any[]): any;
            cancel(): void;
        };
        handleDragStart: (event: any) => void;
        handleDragging: (event: MouseEvent) => void;
        handleDragEnd: () => void;
        renderFindAndReplace: () => JSX.Element;
        render(): React.ReactPortal;
        context: any;
        setState<K extends "dragging">(state: IDragAndDropHOCState | ((prevState: Readonly<IDragAndDropHOCState>, props: Readonly<P & IDragAndDropHOCProps>) => IDragAndDropHOCState | Pick<IDragAndDropHOCState, K> | null) | Pick<IDragAndDropHOCState, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<P & IDragAndDropHOCProps> & Readonly<{
            children?: React.ReactNode;
        }>;
        state: Readonly<IDragAndDropHOCState>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        shouldComponentUpdate?(nextProps: Readonly<P & IDragAndDropHOCProps>, nextState: Readonly<IDragAndDropHOCState>, nextContext: any): boolean;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<P & IDragAndDropHOCProps>, prevState: Readonly<IDragAndDropHOCState>): any;
        componentDidUpdate?(prevProps: Readonly<P & IDragAndDropHOCProps>, prevState: Readonly<IDragAndDropHOCState>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<P & IDragAndDropHOCProps>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<P & IDragAndDropHOCProps>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<P & IDragAndDropHOCProps>, nextState: Readonly<IDragAndDropHOCState>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<P & IDragAndDropHOCProps>, nextState: Readonly<IDragAndDropHOCState>, nextContext: any): void;
    };
    contextType?: React.Context<any> | undefined;
};
