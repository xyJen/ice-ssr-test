import { useCallback, useState, useRef, useMemo, useEffect } from 'react';
import { debounce } from 'lodash-es';

var noop = function noop() {
  return undefined;
};

var getDefaultDragRef = function getDefaultDragRef() {
  return {
    startTop: 0,
    startRight: 0,
    domStartTop: 0,
    domStartRight: 0,
    maxTop: 0,
    maxRight: 0,
    endTop: 0,
    endRight: 0,
    dragging: false
  };
};

export var useDragStyle = function useDragStyle(params) {
  var _params$getDragDom = params.getDragDom,
      getDragDom = _params$getDragDom === void 0 ? noop : _params$getDragDom,
      dragArea = params.dragArea,
      _params$noopOnly = params.noopOnly,
      noopOnly = _params$noopOnly === void 0 ? false : _params$noopOnly,
      _params$autoChangeDom = params.autoChangeDom,
      autoChangeDom = _params$autoChangeDom === void 0 ? false : _params$autoChangeDom;
  var dragRef = useRef(getDefaultDragRef());

  var _useState = useState([undefined, undefined]),
      endPoint = _useState[0],
      setEndPoint = _useState[1];

  var setDragArea = useCallback(function () {
    if (noopOnly) {
      return;
    }

    var dragDom = getDragDom();

    if (!dragDom) {
      return;
    }

    var _ref = dragArea || {},
        _ref$top = _ref.top,
        top = _ref$top === void 0 ? 0 : _ref$top,
        _ref$right = _ref.right,
        right = _ref$right === void 0 ? 0 : _ref$right,
        _ref$bottom = _ref.bottom,
        bottom = _ref$bottom === void 0 ? 0 : _ref$bottom,
        _ref$left = _ref.left,
        left = _ref$left === void 0 ? 0 : _ref$left;

    dragRef.current.maxTop = window.innerHeight - dragDom.offsetHeight - top - bottom;
    dragRef.current.maxRight = window.innerWidth - dragDom.offsetWidth - left - right;
  }, [dragArea, getDragDom, noopOnly]);
  var handleDragging = useCallback(function (event) {
    if (!dragRef.current.dragging || noopOnly) {
      return;
    }

    var _dragRef$current = dragRef.current,
        endTop = _dragRef$current.endTop,
        endRight = _dragRef$current.endRight;
    var pageX = event.pageX,
        pageY = event.pageY;
    var offsetX = pageX - dragRef.current.startRight;
    var offsetY = pageY - dragRef.current.startTop;
    var modalMarginTop = dragRef.current.domStartTop + offsetY;

    if (modalMarginTop >= 0 && modalMarginTop <= dragRef.current.maxTop) {
      endTop = modalMarginTop;
    }

    var modalMarginRight = dragRef.current.domStartRight - offsetX;

    if (modalMarginRight >= 0 && modalMarginRight <= dragRef.current.maxRight) {
      endRight = modalMarginRight;
    }

    setEndPoint([endTop, endRight]);
    dragRef.current.endTop = endTop;
    dragRef.current.endRight = endRight;
  }, [noopOnly]);
  var handleDragEnd = useCallback(function () {
    if (noopOnly) {
      return;
    }

    dragRef.current.endTop = 0;
    dragRef.current.endRight = 0;
    document.removeEventListener('mousemove', handleDragging);
    document.removeEventListener('mouseup', handleDragEnd);
    dragRef.current.dragging = false;
  }, [noopOnly]);
  var handleDragStart = useCallback(function (e) {
    var dragDom = getDragDom();

    if (!dragDom || noopOnly) {
      return;
    }

    var pageX = e.pageX,
        pageY = e.pageY;
    dragRef.current.startTop = pageY;
    dragRef.current.startRight = pageX;
    var domStartTop = dragDom.offsetTop;
    var domStartEnd = window.innerWidth - dragDom.offsetLeft - dragDom.offsetWidth;
    dragRef.current.domStartTop = domStartTop;
    dragRef.current.domStartRight = domStartEnd;
    setEndPoint([domStartTop, domStartEnd]);
    setDragArea();
    dragRef.current.dragging = true;
    document.addEventListener('mousemove', handleDragging);
    document.addEventListener('mouseup', handleDragEnd);
  }, [setDragArea, getDragDom]);
  var handleResize = useCallback(debounce(function () {
    if (noopOnly) {
      return;
    }

    setDragArea();
    var _dragRef$current2 = dragRef.current,
        maxRight = _dragRef$current2.maxRight,
        maxTop = _dragRef$current2.maxTop,
        endRight = _dragRef$current2.endRight,
        endTop = _dragRef$current2.endTop;

    if (endRight >= maxRight) {
      dragRef.current.endRight = Math.max(maxRight, 0);
    }

    if (endTop >= maxTop) {
      dragRef.current.endTop = Math.max(maxTop, 0);
    }

    dragRef.current.endTop = endTop;
    dragRef.current.endRight = endRight;
    setEndPoint([endTop, endRight]);
  }, 300), [setDragArea, noopOnly]);
  var reset = useCallback(function () {
    setEndPoint([undefined, undefined]);
    dragRef.current = getDefaultDragRef();
  }, []);
  useEffect(function () {
    if (noopOnly) {
      return;
    }

    window.addEventListener('resize', handleResize);
    return function () {
      document.removeEventListener('mousemove', handleDragging);
      document.removeEventListener('mouseup', handleDragEnd);
      window.removeEventListener('resize', handleResize);
    };
  }, [noopOnly]);
  var wrapperStyle = useMemo(function () {
    if (noopOnly) {
      return {};
    }

    var dragDom = getDragDom();

    if (dragDom && typeof endPoint[0] === 'number' && typeof endPoint[1] === 'number') {
      var style = {
        position: 'fixed',
        top: endPoint[0],
        right: endPoint[1]
      };

      if (autoChangeDom) {
        dragDom.style.position = style.position;
        dragDom.style.top = style.top + "px";
        dragDom.style.right = style.right + "px";
      }

      return style;
    }

    return {};
  }, [endPoint, getDragDom, noopOnly, autoChangeDom]);
  return {
    reset: reset,
    handleDragStart: handleDragStart,
    wrapperStyle: wrapperStyle
  };
};