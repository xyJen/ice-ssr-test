import _extends from "@babel/runtime/helpers/extends";
import React, { useCallback, useMemo, useState, useEffect } from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import { MenuDivider } from "./MenuDivider";
import { MenuItem } from "./MenuItem";
import { SubMenu } from "./SubMenu";
import { MenuItemGroup } from "./MenuItemGroup";
import { ControllerContext, MenuKeyContext, PathContext, HotkeyPositionContext } from "./contexts";
import { MenuRoot } from "./styled";
import classnames from "../../utils/classnames";
import { useMenuKeyContext, useMousePosition, useRegisterValidNode } from "./hooks";
import { useControlledValue } from "../../hooks";
import { EMenuMode } from "./consts";
import { uuid, throttle } from "../../utils";
import { elementContain } from "../../utils/dom";

/**
 * 获取同层级的所有的 menuKey
 *
 * @param {Record<string, string>} menuKeys
 * @param {string} path
 * @return {string[]}
 */
var getSameLevelMenuKeys = function getSameLevelMenuKeys(menuKeys, path) {
  var paths = path.split('::');
  paths.pop();
  var levelMenuKeys = Object.keys(paths.reduce(function (keys, key) {
    return keys[key];
  }, menuKeys));
  return levelMenuKeys;
};

var noopArr = [];

var noop = function noop() {}; // eslint-disable-next-line max-lines-per-function


export var Menu = /*#__PURE__*/React.memo(function (props) {
  var mode = props.mode,
      children = props.children,
      className = props.className,
      style = props.style,
      selectedKeys = props.selectedKeys,
      defaultSelectedKeys = props.defaultSelectedKeys,
      zIndex = props.zIndex,
      onClick = props.onClick,
      openKeys = props.openKeys,
      _props$defaultOpenKey = props.defaultOpenKeys,
      defaultOpenKeys = _props$defaultOpenKey === void 0 ? noopArr : _props$defaultOpenKey,
      _props$onSubmenuOpene = props.onSubmenuOpenedKeysChange,
      onSubmenuOpenedKeysChange = _props$onSubmenuOpene === void 0 ? noop : _props$onSubmenuOpene,
      autoClose = props.autoClose,
      destroyOverlayWhenInvisible = props.destroyOverlayWhenInvisible,
      shortcutKey = props.shortcutKey,
      shouldSelectFirstItem = props.shouldSelectFirstItem,
      insertSubmenuToMenuRoot = props.insertSubmenuToMenuRoot,
      showSelect = props.showSelect,
      getContainer = props.getContainer,
      _props$capture = props.capture,
      capture = _props$capture === void 0 ? false : _props$capture,
      showSelectOnRight = props.showSelectOnRight,
      onFocusItemChange = props.onFocusItemChange,
      testid = props.testid,
      minWidth = props.minWidth,
      _props$role = props.role,
      role = _props$role === void 0 ? '' : _props$role,
      isPreventKeyEvent = props.isPreventKeyEvent,
      subMenuAutoSelectWithEnter = props.subMenuAutoSelectWithEnter;
  var menuId = useMemo(function () {
    return testid || uuid();
  }, [testid]);
  var menuRootRef = React.useRef(); // 展开的submenu的key

  var _useControlledValue = useControlledValue(openKeys, defaultOpenKeys),
      _useControlledValue$ = _useControlledValue[0],
      openedMenuKeys = _useControlledValue$ === void 0 ? [] : _useControlledValue$,
      setOpenedMenuKeys = _useControlledValue[1]; // 处理menuKeys


  var _useMenuKeyContext = useMenuKeyContext(),
      menuKeyCtxValue = _useMenuKeyContext[0],
      menuKeys = _useMenuKeyContext[2]; // 选中的 key，受控


  var _useControlledValue2 = useControlledValue(selectedKeys, defaultSelectedKeys),
      selectedMenuKeys = _useControlledValue2[0],
      setSelectedMenuKeys = _useControlledValue2[1];

  var _useMousePosition = useMousePosition(),
      setMousePosition = _useMousePosition.setMousePosition;

  var _useState = useState(shortcutKey || false),
      isHotkeyType = _useState[0],
      _setHotkeyType = _useState[1];

  var autoClickRef = React.useRef(false);

  var _useRegisterValidNode = useRegisterValidNode(menuId, !!shouldSelectFirstItem, openedMenuKeys),
      registerValidNode = _useRegisterValidNode.registerValidNode,
      unRegisterValidNode = _useRegisterValidNode.unRegisterValidNode,
      hotkeyPosition = _useRegisterValidNode.hotkeyPosition,
      _setHotkeyPosition = _useRegisterValidNode.setHotkeyPosition,
      validNodes = _useRegisterValidNode.validNodes,
      hotKeyPath = _useRegisterValidNode.hotKeyPath,
      selectFirstItem = _useRegisterValidNode.selectFirstItem; // useEffect(() => {
  //   // eslint-disable-next-line no-console
  //   console.log(
  //     '当前位置',
  //     hotkeyPosition,
  //     JSON.stringify(validNodes),
  //     openedMenuKeys
  //   );
  // }, [hotkeyPosition, validNodes, openedMenuKeys]);


  useEffect(function () {
    onFocusItemChange && onFocusItemChange(hotkeyPosition == null ? void 0 : hotkeyPosition.menuKey);
  }, [hotkeyPosition]);
  /**
   * 绑定快捷键
   */

  useEffect(function () {
    if (shortcutKey) {
      document.addEventListener('keydown', addHotKeys);
      return function () {
        document.removeEventListener('keydown', addHotKeys);
        hotKeyPath.current = undefined;
        _setHotkeyPosition && _setHotkeyPosition(null);
      };
    }

    return;
  }, [shortcutKey, mode]);
  /**
   * 添加快捷方式
   */

  var addHotKeys = useCallback(throttle(function (event) {
    if (isPreventKeyEvent && isPreventKeyEvent(event)) {
      event.preventDefault();
      return;
    }

    var key = event.key.toLowerCase();

    _setHotkeyType(true);

    var isArrowUp = key === 'arrowup' || event.keyCode === 38;
    var isArrowRigt = key === 'arrowright' || event.keyCode === 39;
    var isArrowDown = key === 'arrowdown' || event.keyCode === 40;
    var isArrowLeft = key === 'arrowleft' || event.keyCode === 37;
    var isEnter = key === 'enter' || event.keyCode === 13;
    if (validNodes.current.length === 0) return;

    if (!hotKeyPath.current) {
      (isArrowDown || isArrowRigt) && selectFirstItem();
      return;
    }

    if (isArrowUp) {
      event.preventDefault();

      if (hotKeyPath.current.path.split('::').length === 2 && mode === EMenuMode.horizontal && hotKeyPath.current.index === 0) {
        arrowLeft();
      } else {
        arrowDownOrUp('up');
      }
    } else if (isArrowRigt) {
      event.preventDefault();

      if (hotKeyPath.current.path.split('::').length === 1 && mode === EMenuMode.horizontal) {
        arrowDownOrUp('down');
      } else {
        arrowRight();
      }
    } else if (isArrowDown) {
      event.preventDefault();

      if (hotKeyPath.current.path.split('::').length === 1 && mode === EMenuMode.horizontal) {
        arrowRight();
      } else {
        arrowDownOrUp('down');
      }
    } else if (isArrowLeft) {
      event.preventDefault();

      if (hotKeyPath.current.path.split('::').length === 2 && mode === EMenuMode.horizontal) {
        return;
      } else if (hotKeyPath.current.path.split('::').length === 1 && mode === EMenuMode.horizontal) {
        arrowDownOrUp('up');
      } else {
        arrowLeft();
      }
    } else if (isEnter) {
      event.preventDefault();

      if (subMenuAutoSelectWithEnter && hotKeyPath.current && hotKeyPath.current.children) {
        // 打开二级菜单
        showSubMenu(hotKeyPath.current.path);
        autoClickRef.current = true;
      }

      if (hotKeyPath.current && hotKeyPath.current.onClick) {
        hotKeyPath.current.onClick();
        controller.closeAllMenu();
      }

      return;
    }

    if (_setHotkeyPosition && hotKeyPath.current) _setHotkeyPosition(_extends({}, hotKeyPath.current, {
      eventKey: key
    }));
  }, 150), [openedMenuKeys, mode]);
  useEffect(function () {
    if (subMenuAutoSelectWithEnter && autoClickRef.current) {
      var _hotKeyPath$current;

      (_hotKeyPath$current = hotKeyPath.current) == null ? void 0 : _hotKeyPath$current.onClick == null ? void 0 : _hotKeyPath$current.onClick();
      autoClickRef.current = false;
    }
  }, [hotkeyPosition]);
  /**
   * 快捷键：从有效的结构树中获取节点
   */

  var getActionNode = useCallback(function (key, nodes) {
    var node = null;
    (nodes || validNodes.current).every(function (o) {
      if (o.menuKey === key) {
        node = o;
        return false;
      }

      node = getActionNode(key, o.children || []);
      if (node) return false;
      return true;
    });
    return node;
  }, [validNodes]);
  /**
   * 键盘向右
   */

  var arrowRight = function arrowRight() {
    if (!hotKeyPath.current) return;

    if (hotKeyPath.current.children) {
      // 打开二级菜单
      showSubMenu(hotKeyPath.current.path);

      if (hotKeyPath.current && hotKeyPath.current.children.length > 0) {
        hotKeyPath.current = hotKeyPath.current.children[0];
      }
    } else if (hotKeyPath.current.type === 'inline') {
      var nodes = validNodes.current;
      var index = nodes.findIndex(function (node) {
        var _hotKeyPath$current2;

        return ((_hotKeyPath$current2 = hotKeyPath.current) == null ? void 0 : _hotKeyPath$current2.menuKey) === node.menuKey;
      }); // 存在inlineMenu的情况

      if (index < 0 || index + 1 >= nodes.length) return;

      if (nodes[index + 1].type === 'inline') {
        hotKeyPath.current = nodes[index + 1];
      }
    }
  };
  /**
   * 键盘向坐左
   */


  var arrowLeft = function arrowLeft() {
    if (!hotKeyPath.current) {
      return;
    }

    if (hotKeyPath.current.type === 'inline') {
      var nodes = validNodes.current;
      var index = nodes.findIndex(function (node) {
        var _hotKeyPath$current3;

        return ((_hotKeyPath$current3 = hotKeyPath.current) == null ? void 0 : _hotKeyPath$current3.menuKey) === node.menuKey;
      }); // 存在inlineMenu的情况

      if (index < 0 || index - 1 < 0) return;

      if (nodes[index - 1].type === 'inline') {
        hotKeyPath.current = nodes[index - 1];
      }
    } else {
      var current;

      var findParentNode = function findParentNode(_validNodes) {
        _validNodes.every(function (o) {
          var _hotKeyPath$current4;

          if (!o.children) return true;

          if (((_hotKeyPath$current4 = hotKeyPath.current) == null ? void 0 : _hotKeyPath$current4.parentPath) === o.path) {
            current = o;
            return false;
          }

          current = findParentNode(o.children);
          return true;
        });

        return current;
      };

      var node = findParentNode(validNodes.current);

      if (node) {
        controller.showSubMenu(node.path.split('::').slice(0, -1).join('::'));
        hotKeyPath.current = node;
      }
    }
  };
  /**
   * 键盘向上下
   */


  var arrowDownOrUp = function arrowDownOrUp(key) {
    var _hotKeyPath$current5;

    if (!hotKeyPath.current) return;

    if (((_hotKeyPath$current5 = hotKeyPath.current) == null ? void 0 : _hotKeyPath$current5.type) === 'inline') {
      var _hotKeyPath$current6;

      var nodes = validNodes.current;
      var index = ((_hotKeyPath$current6 = hotKeyPath.current) == null ? void 0 : _hotKeyPath$current6.index) || 0;

      var findInlineNextNode = function findInlineNextNode(_nodes, i) {
        if (key === 'down' && i > _nodes.length - 1) return [];
        if (key === 'up' && i < 0) return [];
        var nextIndex = key === 'down' ? i + 1 : i - 1;

        var inlines = _nodes.filter(function (node) {
          return node.index === nextIndex;
        });

        if (inlines.length === 0) return findInlineNextNode(_nodes, nextIndex);
        return inlines;
      };

      var inlines = findInlineNextNode(nodes, index);
      if (inlines.length === 0) return;
      hotKeyPath.current = inlines.find(function (inline) {
        var _hotKeyPath$current7;

        return inline.offset === ((_hotKeyPath$current7 = hotKeyPath.current) == null ? void 0 : _hotKeyPath$current7.offset);
      }) || inlines[inlines.length - 1];
      return;
    }

    if (hotKeyPath.current.children && hotKeyPath.current.children.length > 0) {
      controller.showSubMenu(hotKeyPath.current.path.split('::').slice(0, -1).join('::'));
    }

    var current;

    var findNextNode = function findNextNode(_validNodes) {
      if (_validNodes.length === 0) return undefined;

      _validNodes.every(function (o, i) {
        var _hotKeyPath$current8;

        var resNode = key === 'down' ? _validNodes[i + 1] : _validNodes[i - 1];

        if (((_hotKeyPath$current8 = hotKeyPath.current) == null ? void 0 : _hotKeyPath$current8.menuKey) === o.menuKey && resNode) {
          current = resNode;
          return false;
        } else {
          findNextNode(o.children || []);
        }

        return true;
      });

      return current;
    };

    var node = findNextNode(validNodes.current);

    if (node) {
      if (node.type === 'inline') {
        hotKeyPath.current = validNodes.current.find(function (item) {
          return item.index === node.index && item.offset === 0;
        });
      } else {
        hotKeyPath.current = node;
      }
    }
  };
  /**
   * 显示二级菜单
   *
   * @param {string} path 要显示的菜单项的key路径
   * @return {void}
   */


  var showSubMenu = useCallback(function (path) {
    onSubmenuOpenedKeysChange(path.split('::'));
    setOpenedMenuKeys(path.split('::'));
  }, [onSubmenuOpenedKeysChange, setOpenedMenuKeys]);
  /**
   * 二级菜单是否展开
   *
   * @param {string} menuKey
   * @return {boolean} isVisible
   */

  var isSubMenuOpened = useCallback(function (menuKey) {
    return openedMenuKeys.includes(menuKey);
  }, [openedMenuKeys]);
  /**
   * 同级的二级菜单是否展开
   *
   * @param {string} path 要显示的菜单项的key路径
   * @return {boolean}
   */

  var isAnySubMenuOpened = useCallback(function (path) {
    var keys = getSameLevelMenuKeys(menuKeys, path);
    return keys.some(function (key) {
      return openedMenuKeys.includes(key);
    });
  }, [openedMenuKeys, menuKeys]);
  /**
   * 菜单项是否被选中
   *
   * @param {string} menuKey
   * @return {boolean}
   */

  var isMenuItemSelected = useCallback(function (menuKey) {
    return selectedMenuKeys.includes(menuKey);
  }, [selectedMenuKeys]);
  /**
   * 关闭所有的展开菜单项
   *
   * @return {void}
   */

  var closeAllMenu = useCallback(function () {
    _setHotkeyPosition(null);

    hotKeyPath.current = null;
    onSubmenuOpenedKeysChange([]);
    setOpenedMenuKeys([]);
  }, [hotKeyPath, onSubmenuOpenedKeysChange, _setHotkeyPosition, setOpenedMenuKeys]);
  /**
   * 选中 MenuItem
   *
   * @param {string} menuKey
   * @return {void}
   */

  var selectMenuItem = useCallback(function (menuKey) {
    if (!selectedMenuKeys.includes(menuKey)) {
      setSelectedMenuKeys([].concat(selectedMenuKeys, [menuKey]));
    }
  }, [selectedMenuKeys, setSelectedMenuKeys]);
  var controller = useMemo(function () {
    return {
      mode: mode,
      zIndex: zIndex,
      autoClose: !!autoClose,
      menuId: menuId,
      isSubMenuOpened: isSubMenuOpened,
      isAnySubMenuOpened: isAnySubMenuOpened,
      showSubMenu: showSubMenu,
      isMenuItemSelected: isMenuItemSelected,
      closeAllMenu: closeAllMenu,
      selectMenuItem: selectMenuItem,
      clickMenuItem: onClick,
      destroyOverlayWhenInvisible: destroyOverlayWhenInvisible,
      showMenuTimer: 0,
      shortcutKey: shortcutKey,
      menuRootRef: insertSubmenuToMenuRoot ? menuRootRef : undefined,
      getContainer: getContainer,
      showSelect: showSelect,
      openedMenuKeys: openedMenuKeys,
      showSelectOnRight: showSelectOnRight,
      minWidth: minWidth
    };
  }, [mode, menuId, zIndex, autoClose, showSubMenu, isSubMenuOpened, isAnySubMenuOpened, isMenuItemSelected, closeAllMenu, selectMenuItem, onClick, destroyOverlayWhenInvisible, shortcutKey, menuRootRef, insertSubmenuToMenuRoot, showSelect, openedMenuKeys, getContainer, showSelectOnRight, minWidth]);
  var hotkeyPositionValue = {
    hotkeyPosition: hotkeyPosition,
    isHotkeyType: isHotkeyType,
    getActionNode: getActionNode,
    registerValidNode: registerValidNode,
    unRegisterValidNode: unRegisterValidNode,
    setHotkeyPosition: function setHotkeyPosition(node) {
      hotKeyPath.current = node;

      _setHotkeyPosition(node);
    },
    setHotkeyType: function setHotkeyType(val) {
      if (val === false) _setHotkeyPosition(null);

      _setHotkeyType(val);
    }
  };
  useEffect(function () {
    var handleMouseDown = function handleMouseDown(e) {
      // 后续寻求更好的办法
      var overlayElements = document.querySelectorAll(".we-ui-submenu-" + menuId + "-overlay"); // 是否点击的是overlay

      var inOverlay = Array.from(overlayElements).some(function (overlayElement) {
        return elementContain(overlayElement, e.target);
      });

      if (!inOverlay) {
        closeAllMenu();
      }
    };

    var length = openedMenuKeys.length;

    if (length) {
      document.addEventListener('mousedown', handleMouseDown, capture);
    }

    return function () {
      if (length) {
        document.removeEventListener('mousedown', handleMouseDown, capture);
      }
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [menuId, openedMenuKeys.length, closeAllMenu]);
  var menuRootMouseMove = useCallback(function (e) {
    setMousePosition(e.clientY);
  }, []);
  return /*#__PURE__*/_createElement(MenuRoot, {
    onMouseMove: shortcutKey ? menuRootMouseMove : null,
    ref: menuRootRef,
    className: classnames("we-ui-submenu-" + menuId + "-overlay", className, mode),
    style: _extends({}, style, {
      minWidth: minWidth
    }),
    "data-testid": menuId + '_root',
    "data-role": role
  }, /*#__PURE__*/_createElement(PathContext.Provider, {
    value: ""
  }, /*#__PURE__*/_createElement(MenuKeyContext.Provider, {
    value: menuKeyCtxValue
  }, /*#__PURE__*/_createElement(ControllerContext.Provider, {
    value: controller
  }, /*#__PURE__*/_createElement(HotkeyPositionContext.Provider, {
    value: hotkeyPositionValue
  }, children)))));
});
Menu.defaultProps = {
  mode: EMenuMode.vertical,
  defaultSelectedKeys: [],
  autoClose: true,
  destroyOverlayWhenInvisible: false,
  shortcutKey: false,
  shouldSelectFirstItem: false,
  showSelect: false
};
Menu.Item = MenuItem;
Menu.ItemGroup = MenuItemGroup;
Menu.Divider = MenuDivider;
Menu.SubMenu = SubMenu;