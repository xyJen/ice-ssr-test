import _extends from "@babel/runtime/helpers/extends";
import { useContext, useMemo, useRef, useLayoutEffect, useState, useCallback, useEffect } from 'react';
import { uuid, debounce } from "../../utils";
import { ControllerContext, MenuKeyContext, PathContext, HotkeyPositionContext } from "./contexts";

/**
 * 获取 Controller
 *
 * @param {String} name Component's name
 * @return {Controller | never}
 */
export var useController = function useController(name) {
  var ctrl = useContext(ControllerContext);

  if (!ctrl) {
    throw new Error(name + " \u7EC4\u4EF6\u5FC5\u987B\u4E3A Menu \u7EC4\u4EF6\u7684\u5B50\u7EC4\u4EF6");
  }

  return ctrl;
};
export var useHotkeyController = function useHotkeyController(name) {
  var ctrl = useContext(HotkeyPositionContext);

  if (!ctrl) {
    throw new Error(name + " \u7EC4\u4EF6\u5FC5\u987B\u4E3A Menu \u7EC4\u4EF6\u7684\u5B50\u7EC4\u4EF6");
  }

  return ctrl;
};
/**
 * 获取当前 key 路径
 * @param {string} key
 * @return {string}
 */

export var usePath = function usePath(key) {
  var parentPath = useContext(PathContext);
  return [].concat(parentPath.split('::'), [key]).filter(function (k) {
    return k;
  }).join('::');
};
/**
 * 处理menukey
 *
 * @param {string} key
 * @return {IUseMenuKeyContext}
 */

export var useMenuKeyContext = function useMenuKeyContext(key) {
  var menuKeys = useRef({});
  var ctx = useContext(MenuKeyContext); // 获取 key，如果没传，自动生成一个uuid

  var id = useMemo(function () {
    return "menu-key-" + uuid();
  }, []);
  var menuKey = key || id; // key的添加和删除方法

  var menuKeyCtxValue = useMemo(function () {
    return {
      addKey: function addKey(k, keys) {
        menuKeys.current[k] = keys || {};
      },
      delKey: function delKey(k) {
        delete menuKeys.current[k];
      }
    };
  }, []);

  if (ctx) {
    ctx.addKey(menuKey, menuKeys.current);
  } // 添加和删除


  useLayoutEffect(function () {
    return function () {
      if (ctx) {
        ctx.delKey(menuKey);
      }
    };
  }, [menuKey, ctx]);
  return [menuKeyCtxValue, menuKey, menuKeys.current];
}; // 获取鼠标最后停留位置

var mousePosition = 0;
export var useMousePosition = function useMousePosition() {
  return {
    getMousePosition: function getMousePosition() {
      return mousePosition;
    },
    mousePosition: mousePosition,
    setMousePosition: function setMousePosition(v) {
      return mousePosition = v;
    }
  };
};
/**
 * 菜单快捷键 有滚动条是 滚动到合适位置
 */

export var useHotKeyScrollRef = function useHotKeyScrollRef(menuKey, isHotkeyType, hotkeyPosition) {
  var ref = useRef();
  var el = ref.current;
  useEffect(function () {
    if (hotkeyPosition && menuKey === hotkeyPosition.menuKey && el && isHotkeyType) {
      if (el.scrollIntoView && typeof el.scrollIntoView === 'function') {
        var _el$style = el.style,
            top = _el$style.top,
            position = _el$style.position;
        el.style.position = 'relative';
        el.style.top = hotkeyPosition.eventKey === 'arrowdown' ? '4px' : '-4px';
        el.scrollIntoView({
          block: 'nearest',
          inline: 'nearest'
        });
        el.style.top = top;
        el.style.position = position;
      }
    }
  }, [hotkeyPosition, menuKey]);
  return ref;
};
export var useRegisterValidNode = function useRegisterValidNode(menuId, shouldSelectFirstItem, openedMenuKeys) {
  var eleMap = useRef({});
  var hotKeyPath = useRef();
  var validNodes = useRef([]);

  var _useState = useState(null),
      hotkeyPosition = _useState[0],
      setHotkeyPosition = _useState[1]; // 获取当前节点挂载的父级节点


  var getParentEle = useCallback(function (nodes, parentPathSteps) {
    var el = nodes.find(function (o) {
      return o.menuKey === parentPathSteps[0];
    });

    if (parentPathSteps.length === 1) {
      return el;
    } else if (el) {
      return getParentEle(el.children || [], parentPathSteps.slice(1));
    }

    return undefined;
  }, []);
  var selectFirstItem = useCallback(function () {
    if (!hotkeyPosition && validNodes.current.length > 0) {
      setHotkeyPosition(validNodes.current[0]);
      hotKeyPath.current = validNodes.current[0];
    }
  }, [hotkeyPosition, setHotkeyPosition]); // 根据dom 实际渲染情况，重绘 menuTree 方便快捷键调用

  var getHotkeyPosition = useCallback(debounce(function (openedKeys) {
    var nodes = [];
    var prevTop;
    var offset = 0;
    var nodeIndex = 0;
    document.querySelectorAll("*[data-menuid=" + menuId + "]").forEach(function (o) {
      var _o$getBoundingClientR = o.getBoundingClientRect(),
          top = _o$getBoundingClientR.top;

      if (prevTop === top) {
        offset += 1;
      } else {
        prevTop = top;
        offset = 0;
        nodeIndex += 1;
      }

      nodes.push({
        path: o.getAttribute('data-path'),
        index: nodeIndex,
        offset: offset
      });
    });
    var nodeTree = [];

    try {
      nodes.sort(function (a, b) {
        if (a.path && b.path) {
          return a.path.split('::').length - b.path.split('::').length || a.index - b.index || a.offset - b.offset;
        }

        return -1;
      }).forEach(function (o) {
        var pathAttr = o.path;

        if (pathAttr) {
          var path = pathAttr.split('::');
          var menuKey = path[path.length - 1];
          if (!eleMap.current[menuKey]) return;
          var el = eleMap.current[menuKey];

          if (path.length === 1) {
            nodeTree = nodeTree.concat(_extends({}, el, {
              index: o.index,
              offset: o.offset
            }));
          } else {
            var parentPathSteps = path.slice(0, -1);
            var parentEle = getParentEle(nodeTree, parentPathSteps);

            if (parentEle) {
              var children = parentEle.children || [];

              var elIndex = _extends({}, el, {
                index: children.length
              });

              parentEle.children = children.concat(elIndex); // 判断节点是否是在开一个新的子层级

              var isOpenSubMenu = hotKeyPath.current && hotKeyPath.current.path.split('::').length !== elIndex.path.split('::').length; // 高亮subMenu 打开时第一个节点

              if (isOpenSubMenu && parentEle.children.length === 1 && parentPathSteps.join('::') === openedKeys.join('::')) {
                setHotkeyPosition(elIndex);
                hotKeyPath.current = elIndex;
              }
            } else {
              throw new Error("\u83DC\u5355\u5B9E\u4F8B " + menuId + " \u5B50\u8282\u70B9 " + path + " \u627E\u4E0D\u5230\u7236\u8282\u70B9 " + parentPathSteps.join('::'));
            }
          }
        } else {
          throw new Error("\u83DC\u5355\u5B9E\u4F8B " + menuId + " \u5B58\u5728\u8282\u70B9\u7F3A\u5C11\u3010data-path\u3011\u5C5E\u6027");
        }
      });
    } catch (error) {
      throw new Error("\u83DC\u5355\u5B9E\u4F8B\u6CE8\u518C\u5931\u8D25\uFF0C" + error);
    }

    validNodes.current = nodeTree; // 默认选中第一个节点

    if (shouldSelectFirstItem) {
      selectFirstItem();
    }
  }, 200), [shouldSelectFirstItem, hotkeyPosition, setHotkeyPosition, selectFirstItem]);
  var registerValidNode = useCallback(function (node) {
    if (eleMap.current[node.menuKey]) return; // 如果是新增节点触发重绘

    eleMap.current[node.menuKey] = node;
    getHotkeyPosition(openedMenuKeys);
  }, [openedMenuKeys]);
  var unRegisterValidNode = useCallback(function (node) {
    delete eleMap.current[node.menuKey];
    getHotkeyPosition(openedMenuKeys);
  }, [openedMenuKeys]);
  return {
    registerValidNode: registerValidNode,
    unRegisterValidNode: unRegisterValidNode,
    hotkeyPosition: hotkeyPosition,
    setHotkeyPosition: setHotkeyPosition,
    selectFirstItem: selectFirstItem,
    validNodes: validNodes,
    hotKeyPath: hotKeyPath
  };
};