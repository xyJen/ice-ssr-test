import React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import BaseImage from "./BaseImage";
import { ImageWrapper, ImageActionWrapper, SAFE_MARGIN } from "./styled";
import { SCALING_MAX_SCALE, SCALING_MIN_SCALE, STOP_MAX_SCALE, STOP_MIN_SCALE, QUICK_SLIDE_TIME, QUICK_SLIDE_DISTANCE } from "./constants";
var START_MOVE_THRESHOLD = 1;

var ActionableImage = function ActionableImage(props) {
  var index = props.index,
      currentIndex = props.currentIndex,
      src = props.src,
      outerHeight = props.outerHeight,
      outerWidth = props.outerWidth,
      total = props.total,
      onCurrentIndexChange = props.onCurrentIndexChange,
      eventEmitter = props.eventEmitter,
      imgStyle = props.imgStyle;
  var dIndex = index - currentIndex;

  var _React$useState = React.useState(outerHeight),
      imageHeight = _React$useState[0],
      setImageHeight = _React$useState[1];

  var imageSize = React.useRef(null); // 单次touch 累计的位移

  var cumulativeTouchX = React.useRef(0);
  var cumulativeTouchY = React.useRef(0); // 图片容器的偏移

  var _React$useState2 = React.useState(function () {
    if (dIndex < 0) {
      return -outerWidth - SAFE_MARGIN;
    }

    if (dIndex > 0) {
      return outerHeight + SAFE_MARGIN;
    }

    return 0;
  }),
      wrapperTransformX = _React$useState2[0],
      setWrapperTransformX = _React$useState2[1]; // 当前图片的位移


  var _React$useState3 = React.useState(1),
      scale = _React$useState3[0],
      setScale = _React$useState3[1];

  var _React$useState4 = React.useState(0),
      transformX = _React$useState4[0],
      setTransformX = _React$useState4[1];

  var _React$useState5 = React.useState(0),
      transformY = _React$useState5[0],
      setTransformY = _React$useState5[1];

  var wrapperRef = React.useRef(null);
  var actionWrapperRef = React.useRef(null);
  var isTopEdgeVisible = React.useRef(true);
  var isBottomEdgeVisible = React.useRef(true);
  var isLeftEdgeVisible = React.useRef(true);
  var isRightEdgeVisible = React.useRef(true); // 应该响应移动的哪个方向

  var shouldMoveX = React.useRef(undefined);
  var timerRef = React.useRef(null);
  var handleLoad = React.useCallback(function (e) {
    var _ref = e.target,
        clientWidth = _ref.clientWidth,
        clientHeight = _ref.clientHeight;
    imageSize.current = {
      w: clientWidth,
      h: clientHeight
    };
    setImageHeight(clientHeight);

    if (clientHeight < outerHeight) {
      var newTransformY = (outerHeight - clientHeight) / 2;
      setTransformY(newTransformY);
    }
  }, [outerHeight]);
  var reset = React.useCallback(function () {
    if (!imageSize.current) return;
    setScale(1);
    setTransformX(0);
    var newY = 0;

    if (imageSize.current.h < outerHeight) {
      newY = (outerHeight - imageSize.current.h) / 2;
    }

    setTransformY(newY);
  }, [dIndex, outerHeight]);
  React.useEffect(function () {
    if (Math.abs(dIndex) < 2) {
      reset();
    }
  }, [dIndex]);
  var getEdgeVisible = React.useCallback(function () {
    if (!imageSize.current) return {
      left: true,
      right: true,
      top: true,
      bottom: true
    };
    var _imageSize$current = imageSize.current,
        w = _imageSize$current.w,
        h = _imageSize$current.h;
    var origin = {
      x: (1 - scale) * imageSize.current.w * 0.5,
      y: (1 - scale) * imageSize.current.h * 0.5
    };
    var l = transformX + origin.x;
    var isLeftEdgeVisible = l >= 0 && l <= outerWidth;
    var r = w * scale + (transformX + origin.x);
    var isRightEdgeVisible = r >= 0 && r <= outerWidth;
    var t = transformY + origin.y;
    var isTopEdgeVisible = t >= 0 && t <= outerHeight;
    var b = h * scale + (transformY + origin.y);
    var isBottomEdgeVisible = b >= 0 && b <= outerHeight;
    return {
      left: isLeftEdgeVisible,
      right: isRightEdgeVisible,
      top: isTopEdgeVisible,
      bottom: isBottomEdgeVisible
    };
  }, [outerWidth, outerHeight, scale, transformX, transformY]); // 当前图片

  React.useEffect(function () {
    var handleTouchStart = function handleTouchStart() {
      shouldMoveX.current = undefined;
      cumulativeTouchX.current = 0;
      cumulativeTouchY.current = 0; // 记录起始状态

      var _getEdgeVisible = getEdgeVisible(),
          left = _getEdgeVisible.left,
          right = _getEdgeVisible.right,
          top = _getEdgeVisible.top,
          bottom = _getEdgeVisible.bottom;

      isLeftEdgeVisible.current = left;
      isRightEdgeVisible.current = right;
      isTopEdgeVisible.current = top;
      isBottomEdgeVisible.current = bottom;
    };

    eventEmitter.on('touchStart', handleTouchStart);
    return function () {
      eventEmitter.off('touchStart', handleTouchStart);
    };
  }, [getEdgeVisible]);
  var getFitWrapperTransformX = React.useCallback(function (x) {
    var maxTransformOffset = outerWidth + SAFE_MARGIN;
    return Math.min(Math.max(-maxTransformOffset, wrapperTransformX + x), maxTransformOffset);
  }, [outerWidth, wrapperTransformX]);
  var getFitImageTransformY = React.useCallback(function (y, scale) {
    if (!imageSize.current) return 0;
    var vHeight = imageSize.current.h * scale;
    var originY = (1 - scale) * imageSize.current.h * 0.5;

    if (vHeight < outerHeight) {
      return (outerHeight - vHeight) / 2 - originY;
    }

    var minTransformOffset = outerHeight - vHeight - originY;
    return Math.max(Math.min(-originY, transformY + y), minTransformOffset);
  }, [outerHeight, scale, transformY]);
  var getFitImageTransformX = React.useCallback(function (x, scale) {
    if (!imageSize.current) return 0;
    var vWidth = imageSize.current.w * scale;
    var originX = (1 - scale) * imageSize.current.w * 0.5;
    var minTransformOffset = outerWidth - vWidth - originX;
    return Math.max(Math.min(-originX, transformX + x), minTransformOffset);
  }, [outerWidth, scale, transformX]);
  React.useEffect(function () {
    var handleMove = function handleMove(pos) {
      if (!wrapperRef.current || !actionWrapperRef.current || actionWrapperRef.current.style.transition) return;
      var singleX = pos.x,
          singleY = pos.y;
      var x = singleX;
      var y = singleY;

      if (shouldMoveX.current === undefined) {
        cumulativeTouchX.current += x;
        cumulativeTouchY.current += y;

        if (Math.abs(cumulativeTouchX.current) > START_MOVE_THRESHOLD || Math.abs(cumulativeTouchY.current) > START_MOVE_THRESHOLD) {
          shouldMoveX.current = Math.abs(cumulativeTouchX.current) > Math.abs(cumulativeTouchY.current);
          x = cumulativeTouchX.current;
          y = cumulativeTouchY.current;
        } else {
          return;
        }
      } // 图片未加载完成时


      if (!imageSize.current) {
        // 只处理x轴的移动
        if (x) {
          // 特殊处理首尾的图片
          if (x < 0 && currentIndex === total - 1 || x > 0 && currentIndex === 0) {
            return;
          }

          var newWrapperTransformX = getFitWrapperTransformX(x);
          setWrapperTransformX(newWrapperTransformX);

          if (newWrapperTransformX < 0) {
            eventEmitter.emit('moveNext', newWrapperTransformX);
          } else if (newWrapperTransformX > 0) {
            eventEmitter.emit('movePrev', newWrapperTransformX);
          } else {
            eventEmitter.emit('movePrev', 0);
            eventEmitter.emit('moveNext', 0);
          }
        }

        return; // TODO: y 轴快速滑动后关闭图片预览组件
      }

      if (scale === 1) {
        if (shouldMoveX.current && x) {
          var _newWrapperTransformX = getFitWrapperTransformX(x);

          if (_newWrapperTransformX === wrapperTransformX) {
            return;
          }

          setWrapperTransformX(_newWrapperTransformX);

          if (_newWrapperTransformX < 0) {
            eventEmitter.emit('moveNext', _newWrapperTransformX);
          } else if (_newWrapperTransformX > 0) {
            eventEmitter.emit('movePrev', _newWrapperTransformX);
          } else {
            eventEmitter.emit('movePrev', 0);
            eventEmitter.emit('moveNext', 0);
          }

          return;
        }

        if (!shouldMoveX.current && y) {
          var newTransformY = getFitImageTransformY(y, scale);

          if (newTransformY === transformY) {
            return;
          }

          setTransformY(newTransformY);
        } // 缩放后滑动

      } else {
        // 滑动时优先改变 wrapper 的位移
        if (wrapperTransformX) {
          var newTransformWrapperX = getFitWrapperTransformX(x);
          setWrapperTransformX(newTransformWrapperX);

          if (newTransformWrapperX < 0) {
            eventEmitter.emit('moveNext', newTransformWrapperX);
          } else if (newTransformWrapperX > 0) {
            eventEmitter.emit('movePrev', newTransformWrapperX);
          } else {
            eventEmitter.emit('movePrev', 0);
            eventEmitter.emit('moveNext', 0);
          }
        } else {
          // 移动图片
          var newTransformX = getFitImageTransformX(x, scale);

          var _newTransformY = getFitImageTransformY(y, scale); // 移动图片


          if (newTransformX !== transformX || _newTransformY !== transformY) {
            setTransformX(newTransformX);
            setTransformY(_newTransformY);
            setScale(scale); // 图片无滑动空间时，可以继续左滑右滑
          } else {
            var _newTransformWrapperX = getFitWrapperTransformX(x);

            if (x > 0 && currentIndex !== 0 || x < 0 && currentIndex !== total - 1) {
              if (_newTransformWrapperX === wrapperTransformX) {
                return;
              }

              setWrapperTransformX(_newTransformWrapperX);

              if (_newTransformWrapperX < 0) {
                eventEmitter.emit('moveNext', _newTransformWrapperX);
              } else if (_newTransformWrapperX > 0) {
                eventEmitter.emit('movePrev', _newTransformWrapperX);
              } else {
                eventEmitter.emit('movePrev', 0);
                eventEmitter.emit('moveNext', 0);
              }
            }
          }
        }
      }
    };

    if (dIndex === 0) {
      eventEmitter.on('move', handleMove);
    }

    return function () {
      eventEmitter.off('move', handleMove);
    };
  }, [dIndex, outerHeight, scale, transformY, transformX, getFitImageTransformY, getFitImageTransformX, getFitWrapperTransformX, wrapperTransformX]);
  React.useEffect(function () {
    var handleScale = function handleScale(params) {
      var _imageSize$current2, _imageSize$current3;

      if (!imageSize.current) return;
      var ratio = params.ratio,
          center = params.center;
      var realRatio = ratio;
      var newScale = scale * ratio;

      if (newScale > SCALING_MAX_SCALE) {
        realRatio = SCALING_MAX_SCALE / scale;
        newScale = SCALING_MAX_SCALE;
      } else if (newScale < SCALING_MIN_SCALE) {
        realRatio = SCALING_MIN_SCALE / scale;
        newScale = SCALING_MIN_SCALE;
      }

      var origin = {
        x: (realRatio - 1) * ((_imageSize$current2 = imageSize.current) == null ? void 0 : _imageSize$current2.w) * 0.5,
        y: (realRatio - 1) * ((_imageSize$current3 = imageSize.current) == null ? void 0 : _imageSize$current3.h) * 0.5
      };
      var newTransformX = transformX - ((realRatio - 1) * (center.x - transformX) - origin.x);
      var newTransformY = transformY - ((realRatio - 1) * (center.y - transformY) - origin.y);
      setTransformX(newTransformX);
      setTransformY(newTransformY);
      setScale(newScale);
    };

    if (dIndex === 0) {
      eventEmitter.on('scale', handleScale);
    }

    return function () {
      eventEmitter.off('scale', handleScale);
    };
  }, [dIndex, eventEmitter, scale, transformX, transformY]);
  var updateScaleTransform = React.useCallback(function (dx, dy, scale) {
    var newTransformX = getFitImageTransformX(dx, scale);
    var newTransformY = getFitImageTransformY(dy, scale);
    setTransformX(newTransformX);
    setTransformY(newTransformY);
    setScale(scale);
  }, [getFitImageTransformX, getFitImageTransformY]);
  var handleScaleEnd = React.useCallback(function (params) {
    var _imageSize$current4, _imageSize$current5;

    if (!imageSize.current) return;
    var center = params.center;
    var realRatio;
    var newScale;

    if (scale > STOP_MAX_SCALE) {
      realRatio = STOP_MAX_SCALE / scale;
      newScale = STOP_MAX_SCALE;
    } else if (scale < STOP_MIN_SCALE) {
      realRatio = STOP_MIN_SCALE / scale;
      newScale = STOP_MIN_SCALE;
    } else {
      return;
    }

    var origin = {
      x: (realRatio - 1) * ((_imageSize$current4 = imageSize.current) == null ? void 0 : _imageSize$current4.w) * 0.5,
      y: (realRatio - 1) * ((_imageSize$current5 = imageSize.current) == null ? void 0 : _imageSize$current5.h) * 0.5
    };
    var dx = -((realRatio - 1) * (center.x - transformX) - origin.x);
    var dy = -((realRatio - 1) * (center.y - transformY) - origin.y);
    updateScaleTransform(dx, dy, newScale);
  }, [scale, transformX, transformY, updateScaleTransform]); // 双击

  React.useEffect(function () {
    var handleDoubleClick = function handleDoubleClick(pos) {
      if (!imageSize.current) return;
      var newScale;
      var realRatio;

      if (scale !== STOP_MIN_SCALE) {
        realRatio = STOP_MIN_SCALE / scale;
        newScale = STOP_MIN_SCALE;
      } else {
        realRatio = STOP_MAX_SCALE / scale;
        newScale = STOP_MAX_SCALE;
      }

      var origin = {
        x: (realRatio - 1) * imageSize.current.w * 0.5,
        y: (realRatio - 1) * imageSize.current.h * 0.5
      };
      var dx = -((realRatio - 1) * (pos.x - transformX) - origin.x);
      var dy = -((realRatio - 1) * (pos.y - transformY) - origin.y);
      updateScaleTransform(dx, dy, newScale);
    };

    if (dIndex === 0) {
      eventEmitter.on('doubleClick', handleDoubleClick);
    }

    return function () {
      eventEmitter.off('doubleClick', handleDoubleClick);
    };
  }, [dIndex, eventEmitter, scale, transformX, transformY, updateScaleTransform]);
  React.useEffect(function () {
    if (dIndex === 0) {
      eventEmitter.on('scaleEnd', handleScaleEnd);
    }

    return function () {
      eventEmitter.off('scaleEnd', handleScaleEnd);
    };
  }, [dIndex, handleScaleEnd]);
  var restoreWrapperTransform = React.useCallback(function () {
    if (!wrapperRef.current) {
      return;
    }

    wrapperRef.current.style.transition = 'transform 0.3s ease';
    setWrapperTransformX(0);
    timerRef.current && clearTimeout(timerRef.current);
    timerRef.current = setTimeout(function () {
      if (wrapperRef.current) {
        wrapperRef.current.style.transition = '';
      }
    }, 300);
    eventEmitter.emit('movePrev', 0, true);
    eventEmitter.emit('moveNext', 0, true);
  }, []);
  React.useEffect(function () {
    var handleTouchEnd = function handleTouchEnd(params) {
      shouldMoveX.current = undefined;
      if (!wrapperRef.current) return;
      var timeConsuming = params.timeConsuming;

      if (wrapperTransformX) {
        // 快速滑动或者慢速滑动超过一半触发切换
        if (Math.abs(wrapperTransformX) > QUICK_SLIDE_DISTANCE && timeConsuming <= QUICK_SLIDE_TIME || Math.abs(wrapperTransformX) >= outerWidth / 2) {
          if (wrapperTransformX < 0) {
            if (currentIndex !== total - 1) {
              if (isRightEdgeVisible.current) {
                wrapperRef.current.style.transition = 'transform 0.3s ease';
                setWrapperTransformX(-outerWidth - SAFE_MARGIN);
                eventEmitter.emit('moveNextEnd');
                timerRef.current = setTimeout(function () {
                  onCurrentIndexChange(currentIndex + 1);

                  if (wrapperRef.current) {
                    wrapperRef.current.style.transition = ''; // setWrapperTransformX(-outerWidth - SAFE_MARGIN);
                  }
                }, 300);
                return;
              } else {
                // touch start 时右边缘不可见，不切换到下一张
                restoreWrapperTransform();
              }
            } else {
              // 最后一张不可切下一张
              restoreWrapperTransform();
            }
          }

          if (wrapperTransformX > 0) {
            if (currentIndex !== 0) {
              if (isLeftEdgeVisible.current) {
                wrapperRef.current.style.transition = 'transform 0.3s ease';
                setWrapperTransformX(outerWidth + SAFE_MARGIN);
                eventEmitter.emit('movePrevEnd');
                timerRef.current && clearTimeout(timerRef.current);
                timerRef.current = setTimeout(function () {
                  onCurrentIndexChange(currentIndex - 1);

                  if (wrapperRef.current) {
                    wrapperRef.current.style.transition = '';
                  }
                }, 300);
                return;
              } else {
                // touch start 时左边缘不可见，不切换到上一张
                restoreWrapperTransform();
              }
            } else {
              // 第一张，不切换到上一张
              restoreWrapperTransform();
            }
          }
        } else {
          // 滑动未超过一半，恢复
          restoreWrapperTransform();
        }
      }
    };

    if (dIndex === 0) {
      eventEmitter.on('touchEnd', handleTouchEnd);
    }

    return function () {
      eventEmitter.off('touchEnd', handleTouchEnd);
    };
  }, [dIndex, outerWidth, currentIndex, onCurrentIndexChange, total, handleScaleEnd, wrapperTransformX]); // current 前一张图片

  React.useEffect(function () {
    var handlePrevMove = function handlePrevMove(x, hasTransition) {
      if (!wrapperRef.current) {
        return;
      }

      setWrapperTransformX(-outerWidth + x - SAFE_MARGIN);

      if (hasTransition) {
        wrapperRef.current.style.transition = 'transform 0.3s ease';
      }
    };

    if (dIndex === -1) {
      eventEmitter.on('movePrev', handlePrevMove);
    }

    return function () {
      eventEmitter.off('movePrev', handlePrevMove);
    };
  }, [dIndex, outerWidth, restoreWrapperTransform]);
  React.useEffect(function () {
    var handlePrevMoveEnd = function handlePrevMoveEnd() {
      if (!wrapperRef.current) {
        return;
      }

      wrapperRef.current.style.transition = "transform 0.3s ease";
      setWrapperTransformX(0);
    };

    if (dIndex === -1) {
      eventEmitter.on('movePrevEnd', handlePrevMoveEnd);
    }

    return function () {
      eventEmitter.off('movePrevEnd', handlePrevMoveEnd);
    };
  }, [dIndex]); // current 后一张图片

  React.useEffect(function () {
    var handleNextMove = function handleNextMove(x) {
      if (!wrapperRef.current) {
        return;
      }

      setWrapperTransformX(outerWidth + x + SAFE_MARGIN);
    };

    if (dIndex === 1) {
      eventEmitter.on('moveNext', handleNextMove);
    }

    return function () {
      eventEmitter.off('moveNext', handleNextMove);
    };
  }, [dIndex, outerWidth]);
  React.useEffect(function () {
    var handleNextMoveEnd = function handleNextMoveEnd() {
      if (!wrapperRef.current) {
        return;
      }

      wrapperRef.current.style.transition = "transform 0.3s ease";
      setWrapperTransformX(0);
    };

    if (dIndex === 1) {
      eventEmitter.on('moveNextEnd', handleNextMoveEnd);
    }

    return function () {
      eventEmitter.off('moveNextEnd', handleNextMoveEnd);
    };
  }, [dIndex]);
  var handleTransitionEnd = React.useCallback(function () {
    if (!wrapperRef.current) return;
    wrapperRef.current.style.transition = '';
  }, [dIndex, onCurrentIndexChange]);
  return /*#__PURE__*/_createElement(ImageWrapper, {
    ref: wrapperRef,
    onTransitionEnd: handleTransitionEnd,
    style: {
      transform: "translate(" + wrapperTransformX + "px, 0)"
    }
  }, /*#__PURE__*/_createElement(ImageActionWrapper, {
    ref: actionWrapperRef,
    style: {
      height: imageHeight,
      transform: "translate(" + transformX + "px, " + transformY + "px) scale(" + scale + ")"
    }
  }, /*#__PURE__*/_createElement(BaseImage, {
    src: src,
    onLoad: handleLoad,
    style: imgStyle
  })));
};

export default ActionableImage;