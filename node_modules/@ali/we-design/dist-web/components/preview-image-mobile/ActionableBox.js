import React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import styled from 'styled-components';
import { DOUBLE_CLICK_INTERVAL, CLICK_INTERVAL } from "./constants";
var ActionableBoxWrapper = /*#__PURE__*/styled.div(["position:absolute;width:100%;height:100%;left:0;top:0;"]);

function getDistance(touch1, touch2) {
  var x1 = touch1.clientX,
      y1 = touch1.clientY;
  var x2 = touch2.clientX,
      y2 = touch2.clientY;
  var deltaX = x1 - x2;
  var deltaY = y1 - y2;
  return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
}

var ActionableBox = function ActionableBox(props) {
  var eventEmitter = props.eventEmitter;
  var touch1Ref = React.useRef(null);
  var touch2Ref = React.useRef(null); // 上一次判定为单击的操作

  var lastClickTimeStamp = React.useRef(0);
  var touchStartTimeStamp = React.useRef(0);
  var clickTimer = React.useRef(null);
  var isMoved = React.useRef(false);
  React.useEffect(function () {
    return function () {
      clickTimer.current && clearTimeout(clickTimer.current);
    };
  }, []);
  var storeTouch = React.useCallback(function (touch1, touch2) {
    touch1Ref.current = touch1;
    touch2Ref.current = touch2 || null;
  }, []);
  var handleTouchStart = React.useCallback(function (e) {
    e.preventDefault();
    e.stopPropagation();
    clickTimer.current && clearTimeout(clickTimer.current);
    isMoved.current = false;
    var touches = e.touches;
    var length = touches.length;

    if (length <= 2) {
      storeTouch(touches[0], touches[1]);
      eventEmitter.emit('touchStart');
    }

    touchStartTimeStamp.current = Date.now();
  }, []);
  var handleMoveAction = React.useCallback(function (touch) {
    var _touch1Ref$current, _touch1Ref$current2;

    if (!touch1Ref.current) return;
    var dx = touch.clientX - ((_touch1Ref$current = touch1Ref.current) == null ? void 0 : _touch1Ref$current.clientX);
    var dy = touch.clientY - ((_touch1Ref$current2 = touch1Ref.current) == null ? void 0 : _touch1Ref$current2.clientY);
    touch1Ref.current = touch;
    eventEmitter.emit('move', {
      x: dx,
      y: dy
    });
  }, []);
  var handleScaleAction = React.useCallback(function (touch1, touch2) {
    if (!touch2Ref.current || !touch1Ref.current) {
      return;
    }

    var prevDistance = getDistance(touch1Ref.current, touch2Ref.current);
    var distance = getDistance(touch1, touch2);
    var ratio = distance / prevDistance;
    eventEmitter.emit('scale', {
      ratio: ratio,
      center: {
        x: (touch1Ref.current.clientX + touch2Ref.current.clientX) / 2,
        y: (touch1Ref.current.clientY + touch2Ref.current.clientY) / 2
      }
    });
  }, []);
  var handleTouchMove = React.useCallback(function (e) {
    e.preventDefault();
    e.stopPropagation();
    isMoved.current = true;
    var touches = e.touches;
    var length = touches.length;

    if (length === 1) {
      handleMoveAction(touches[0]);

      if (touch1Ref.current && touch2Ref.current) {
        eventEmitter.emit('scaleEnd', {
          center: {
            x: (touch1Ref.current.clientX + touch2Ref.current.clientX) / 2,
            y: (touch1Ref.current.clientY + touch2Ref.current.clientY) / 2
          }
        });
      }

      storeTouch(touches[0]);
    }

    if (length === 2) {
      var _touch1Ref$current3;

      var _ref = touches[0].identifier === ((_touch1Ref$current3 = touch1Ref.current) == null ? void 0 : _touch1Ref$current3.identifier) ? [touches[0], touches[1]] : [touches[1], touches[0]],
          touch1 = _ref[0],
          touch2 = _ref[1];

      handleScaleAction(touch1, touch2);
      storeTouch(touch1, touch2);
    }
  }, [handleScaleAction, handleMoveAction]);
  var handleTouchEndAction = React.useCallback(function () {
    var timeConsuming = Date.now() - touchStartTimeStamp.current;
    eventEmitter.emit('touchEnd', {
      timeConsuming: timeConsuming
    });
  }, []);
  var handleScaleEndAction = React.useCallback(function (touch1, touch2) {
    if (!touch2Ref.current || !touch1Ref.current) {
      handleTouchEndAction();
      return;
    }

    var prevDistance = getDistance(touch1Ref.current, touch2Ref.current);
    var distance = getDistance(touch1, touch2);
    var dDistance = distance - prevDistance;
    eventEmitter.emit('scale', {
      dDistance: dDistance,
      touch1Pos: {
        x: touch1.clientX,
        y: touch1.clientY
      },
      touch2Pos: {
        x: touch2.clientX,
        y: touch2.clientY
      }
    });
  }, []);
  var handleTouchEnd = React.useCallback(function (e) {
    e.preventDefault();
    e.stopPropagation();
    var touches = e.touches;
    var length = touches.length;
    var isClick = Date.now() - touchStartTimeStamp.current < CLICK_INTERVAL && !isMoved.current;

    if (isClick && length < 2) {
      if (lastClickTimeStamp.current && Date.now() - lastClickTimeStamp.current < DOUBLE_CLICK_INTERVAL) {
        clickTimer.current && clearTimeout(clickTimer.current);

        if (touch1Ref.current) {
          var _touch1Ref$current4, _touch1Ref$current5;

          eventEmitter.emit('doubleClick', {
            x: (_touch1Ref$current4 = touch1Ref.current) == null ? void 0 : _touch1Ref$current4.clientX,
            y: (_touch1Ref$current5 = touch1Ref.current) == null ? void 0 : _touch1Ref$current5.clientY
          });
          return;
        }
      }

      lastClickTimeStamp.current = Date.now();
      clickTimer.current = setTimeout(function () {
        eventEmitter.emit('click');
      }, DOUBLE_CLICK_INTERVAL);
      return;
    }

    if (touch1Ref.current && touch2Ref.current) {
      eventEmitter.emit('scaleEnd', {
        center: {
          x: (touch1Ref.current.clientX + touch2Ref.current.clientX) / 2,
          y: (touch1Ref.current.clientY + touch2Ref.current.clientY) / 2
        }
      });
      storeTouch(null);
      return;
    }

    storeTouch(null);

    if (length === 1) {
      handleTouchEndAction();
      return;
    }

    if (length === 2) {
      handleScaleEndAction(touches[0], touches[1]);
      return;
    }

    handleTouchEndAction();
  }, []);
  var onRef = React.useCallback(function (ref) {
    if (ref) {
      ref.addEventListener('touchstart', handleTouchStart, {
        passive: false
      });
      ref.addEventListener('touchmove', handleTouchMove, {
        passive: false
      });
      ref.addEventListener('touchend', handleTouchEnd);
    }
  }, [handleTouchStart, handleTouchMove, handleTouchEnd]);
  var handleClick = React.useCallback(function () {
    eventEmitter.emit('click');
  }, [eventEmitter]);
  return /*#__PURE__*/_createElement(ActionableBoxWrapper, {
    ref: onRef,
    onClick: handleClick
  });
};

export default ActionableBox;