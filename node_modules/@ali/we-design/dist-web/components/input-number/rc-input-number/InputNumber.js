import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
import _extends from "@babel/runtime/helpers/extends";
import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";

/* eslint-disable react/prop-types */
// @ts-nocheck
import React from 'react';
var _createElement = /*#__PURE__*/React.createElement;
import classNames from 'classnames';
import KeyCode from 'rc-util/lib/KeyCode';

function noop() {}

function preventDefault(e) {
  e.preventDefault();
}

var defaultParser = function defaultParser(input) {
  return input.replace(/[^\w.-]+/g, '');
};
/**
 * When click and hold on a button - the speed of auto changin the value.
 */


var SPEED = 200;
/**
 * When click and hold on a button - the delay before auto changin the value.
 */

var DELAY = 600;
/**
 * Max Safe Integer -- on IE this is not available, so manually set the number in that case.
 * The reason this is used, instead of Infinity is because numbers above the MSI are unstable
 */

var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;

var isValidProps = function isValidProps(value) {
  return value !== undefined && value !== null;
};

var isEqual = function isEqual(oldValue, newValue) {
  return newValue === oldValue || typeof newValue === 'number' && typeof oldValue === 'number' && isNaN(newValue) && isNaN(oldValue);
};

var InputNumber = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(InputNumber, _React$Component);

  function InputNumber(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.pressingUpOrDown = void 0;
    _this.inputting = void 0;
    _this.rawInput = void 0;
    _this.cursorStart = void 0;
    _this.cursorAfter = void 0;
    _this.input = void 0;
    _this.lastKeyCode = void 0;
    _this.currentValue = void 0;
    _this.cursorEnd = void 0;
    _this.cursorBefore = void 0;
    _this.autoStepTimer = void 0;

    _this.onKeyDown = function (e) {
      var _this$props = _this.props,
          onKeyDown = _this$props.onKeyDown,
          onPressEnter = _this$props.onPressEnter,
          keyboard = _this$props.keyboard;
      var supportKeyCodes = [KeyCode.UP, KeyCode.DOWN];

      if (keyboard !== false && supportKeyCodes.includes(e.keyCode)) {
        // eslint-disable-next-line default-case
        switch (e.keyCode) {
          case KeyCode.UP:
            {
              var ratio = _this.getRatio(e);

              _this.up(e, ratio, null);

              _this.stop();

              break;
            }

          case KeyCode.DOWN:
            {
              var _ratio = _this.getRatio(e);

              _this.down(e, _ratio, null);

              _this.stop();

              break;
            }
        }
      }

      if (e.keyCode === KeyCode.ENTER) {
        onPressEnter == null ? void 0 : onPressEnter(e);
      } // Trigger user key down


      _this.recordCursorPosition();

      _this.lastKeyCode = e.keyCode;
      onKeyDown == null ? void 0 : onKeyDown(e);
    };

    _this.onKeyUp = function (e) {
      var onKeyUp = _this.props.onKeyUp;

      _this.stop();

      _this.recordCursorPosition(); // Trigger user key up


      if (onKeyUp) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        onKeyUp.apply(void 0, [e].concat(args));
      }
    };

    _this.onChange = function (e) {
      var onChange = _this.props.onChange;

      if (_this.state.focused) {
        _this.inputting = true;
      }

      _this.rawInput = _this.props.parser(_this.getValueFromEvent(e));

      _this.setState({
        inputValue: _this.rawInput
      });

      onChange(_this.toNumber(_this.rawInput)); // valid number or invalid string
    };

    _this.onMouseUp = function () {
      var onMouseUp = _this.props.onMouseUp;

      _this.recordCursorPosition();

      if (onMouseUp) {
        onMouseUp.apply(void 0, arguments);
      }
    };

    _this.onFocus = function () {
      var _this$props2;

      _this.setState({
        focused: true
      });

      (_this$props2 = _this.props).onFocus.apply(_this$props2, arguments);
    };

    _this.onBlur = function () {
      var onBlur = _this.props.onBlur;
      _this.inputting = false;

      _this.setState({
        focused: false
      });

      var value = _this.getCurrentValidValue(_this.state.inputValue);

      var newValue = _this.setValue(value, noop);

      if (onBlur) {
        var originValue = _this.input.value;

        var displayValue = _this.getInputDisplayValue({
          focus: false,
          value: newValue
        });

        _this.input.value = displayValue;
        onBlur.apply(void 0, arguments);
        _this.input.value = originValue;
      }
    };

    _this.getRatio = function (e) {
      var ratio = 1;

      if (e.metaKey || e.ctrlKey) {
        ratio = 0.1;
      } else if (e.shiftKey) {
        ratio = 10;
      }

      return ratio;
    };

    _this.getFullNum = function (num) {
      if (isNaN(num)) {
        return num;
      }

      if (!/e/i.test(String(num))) {
        return num;
      }

      return Number(num).toFixed(18).replace(/\.?0+$/, '');
    };

    _this.getPrecision = function (value) {
      if (isValidProps(_this.props.precision)) {
        return _this.props.precision;
      }

      var valueString = String(value);

      if (valueString.indexOf('e-') >= 0) {
        return parseInt(valueString.slice(valueString.indexOf('e-') + 2), 10);
      }

      var precision = 0;

      if (valueString.indexOf('.') >= 0) {
        precision = valueString.length - valueString.indexOf('.') - 1;
      }

      return precision;
    };

    _this.getInputDisplayValue = function (state) {
      var _ref = state || _this.state,
          focused = _ref.focused,
          inputValue = _ref.inputValue,
          value = _ref.value;

      var inputDisplayValue;

      if (focused) {
        inputDisplayValue = inputValue;
      } else {
        inputDisplayValue = _this.toPrecisionAsStep(value);
      }

      if (inputDisplayValue === undefined || inputDisplayValue === null) {
        inputDisplayValue = '';
      }

      var inputDisplayValueFormat = _this.formatWrapper(inputDisplayValue);

      if (isValidProps(_this.props.decimalSeparator)) {
        inputDisplayValueFormat = inputDisplayValueFormat.toString().replace('.', _this.props.decimalSeparator);
      }

      return inputDisplayValueFormat;
    };

    _this.recordCursorPosition = function () {
      // Record position
      try {
        _this.cursorStart = _this.input.selectionStart;
        _this.cursorEnd = _this.input.selectionEnd;
        _this.currentValue = _this.input.value;
        _this.cursorBefore = _this.input.value.substring(0, _this.cursorStart);
        _this.cursorAfter = _this.input.value.substring(_this.cursorEnd);
      } catch (e) {// Fix error in Chrome:
        // Failed to read the 'selectionStart' property from 'HTMLInputElement'
        // http://stackoverflow.com/q/21177489/3040605
      }
    };

    _this.restoreByAfter = function (str) {
      if (str === undefined) return false;
      var fullStr = _this.input.value;
      var index = fullStr.lastIndexOf(str);
      if (index === -1) return false;
      var prevCursorPos = _this.cursorBefore.length;

      if (_this.lastKeyCode === KeyCode.DELETE && _this.cursorBefore.charAt(prevCursorPos - 1) === str[0]) {
        _this.fixCaret(prevCursorPos, prevCursorPos);

        return true;
      }

      if (index + str.length === fullStr.length) {
        _this.fixCaret(index, index);

        return true;
      }

      return false;
    };

    _this.partRestoreByAfter = function (str) {
      if (str === undefined) return false; // For loop from full str to the str with last char to map. e.g. 123
      // -> 123
      // -> 23
      // -> 3

      return Array.prototype.some.call(str, function (_, start) {
        var partStr = str.substring(start);
        return _this.restoreByAfter(partStr);
      });
    };

    _this.isNotCompleteNumber = function (num) {
      return isNaN(num) || num === '' || num === null || num && num.toString().indexOf('.') === num.toString().length - 1;
    };

    _this.stop = function () {
      if (_this.autoStepTimer) {
        clearTimeout(_this.autoStepTimer);
      }
    };

    _this.down = function (e, ratio, recursive) {
      _this.pressingUpOrDown = true;

      _this.step('down', e, ratio, recursive);
    };

    _this.up = function (e, ratio, recursive) {
      _this.pressingUpOrDown = true;

      _this.step('up', e, ratio, recursive);
    };

    _this.saveInput = function (node) {
      _this.input = node;
    };

    var _value = props.value;

    if (_value === undefined) {
      _value = props.defaultValue;
    }

    _this.state = {
      focused: props.autoFocus
    };

    var validValue = _this.getValidValue(_this.toNumber(_value));

    _this.state = _extends({}, _this.state, {
      inputValue: _this.toPrecisionAsStep(validValue),
      value: validValue
    });
    return _this;
  }

  var _proto = InputNumber.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.componentDidUpdate(null);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _this$props3 = this.props,
        value = _this$props3.value,
        onChange = _this$props3.onChange,
        max = _this$props3.max,
        min = _this$props3.min;
    var focused = this.state.focused; // Don't trigger in componentDidMount

    if (prevProps) {
      if (!isEqual(prevProps.value, value) || !isEqual(prevProps.max, max) || !isEqual(prevProps.min, min)) {
        var validValue = focused ? value : this.getValidValue(value);
        var nextInputValue;

        if (this.pressingUpOrDown) {
          nextInputValue = validValue;
        } else if (this.inputting) {
          nextInputValue = this.rawInput;
        } else {
          nextInputValue = this.toPrecisionAsStep(validValue);
        }

        this.setState({
          // eslint-disable-line
          value: validValue,
          inputValue: nextInputValue
        });
      } // Trigger onChange when max or min change
      // https://github.com/ant-design/ant-design/issues/11574


      var nextValue = 'value' in this.props ? value : this.state.value; // ref: null < 20 === true
      // https://github.com/ant-design/ant-design/issues/14277

      if ('max' in this.props && prevProps.max !== max && typeof nextValue === 'number' && nextValue > max && onChange) {
        onChange(max);
      }

      if ('min' in this.props && prevProps.min !== min && typeof nextValue === 'number' && nextValue < min && onChange) {
        onChange(min);
      }
    } // Restore cursor


    try {
      // Firefox set the input cursor after it get focused.
      // This caused that if an input didn't init with the selection,
      // set will cause cursor not correct when first focus.
      // Safari will focus input if set selection. We need skip this.
      if (this.cursorStart !== undefined && this.state.focused) {
        // In most cases, the string after cursor is stable.
        // We can move the cursor before it
        if ( // If not match full str, try to match part of str
        !this.partRestoreByAfter(this.cursorAfter) && this.state.value !== this.props.value) {
          // If not match any of then, let's just keep the position
          // TODO: Logic should not reach here, need check if happens
          var pos = this.getInputDisplayValue(this.state).length; // If not have last string, just position to the end

          if (!this.cursorAfter) {
            pos = this.input.value.length;
          } else if (this.lastKeyCode === KeyCode.BACKSPACE) {
            pos = this.cursorStart - 1;
          } else if (this.lastKeyCode === KeyCode.DELETE) {
            pos = this.cursorStart;
          }

          this.fixCaret(pos, pos);
        } else if (this.currentValue === this.input.value) {
          // Handle some special key code
          switch (this.lastKeyCode) {
            case KeyCode.BACKSPACE:
              this.fixCaret(this.cursorStart - 1, this.cursorStart - 1);
              break;

            case KeyCode.DELETE:
              this.fixCaret(this.cursorStart + 1, this.cursorStart + 1);
              break;

            default: // Do nothing

          }
        }
      }
    } catch (e) {// Do nothing
    } // Reset last key


    this.lastKeyCode = null; // pressingUpOrDown is true means that someone just click up or down button

    if (!this.pressingUpOrDown) {
      return;
    }

    if (this.props.focusOnUpDown && this.state.focused) {
      if (document.activeElement !== this.input) {
        this.focus();
      }
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.stop();
  };

  _proto.getCurrentValidValue = function getCurrentValidValue(value) {
    var val = value;

    if (val === '') {
      val = '';
    } else if (!this.isNotCompleteNumber(parseFloat(val))) {
      val = this.getValidValue(val);
    } else {
      val = this.state.value;
    }

    return this.toNumber(val);
  };

  _proto.getValueFromEvent = function getValueFromEvent(e) {
    // optimize for chinese input expierence
    // https://github.com/ant-design/ant-design/issues/8196
    var value = e.target.value.trim().replace(/。/g, '.');

    if (isValidProps(this.props.decimalSeparator)) {
      value = value.replace(this.props.decimalSeparator, '.');
    }

    return value;
  };

  _proto.getValidValue = function getValidValue(value) {
    var _this$props4 = this.props,
        min = _this$props4.min,
        max = _this$props4.max;
    var val = parseFloat(value); // https://github.com/ant-design/ant-design/issues/7358

    if (isNaN(val)) {
      return value;
    }

    if (val < min) {
      val = min;
    }

    if (val > max) {
      val = max;
    }

    return val;
  };

  _proto.setValue = function setValue(v, callback) {
    // trigger onChange
    var precision = this.props.precision;
    var newValue = this.isNotCompleteNumber(parseFloat(v)) ? null : parseFloat(v);
    var _this$state$value = this.state.value,
        value = _this$state$value === void 0 ? null : _this$state$value;
    var _this$state$inputValu = this.state.inputValue,
        inputValue = _this$state$inputValu === void 0 ? null : _this$state$inputValu; // https://github.com/ant-design/ant-design/issues/7363
    // https://github.com/ant-design/ant-design/issues/16622

    var newValueInString = typeof newValue === 'number' ? newValue.toFixed(precision) : "" + newValue;
    var changed = newValue !== value || newValueInString !== "" + inputValue;

    if (!('value' in this.props)) {
      this.setState({
        value: newValue,
        inputValue: this.toPrecisionAsStep(v)
      }, callback);
    } else {
      // always set input value same as value
      inputValue = this.toPrecisionAsStep(this.state.value);
      this.setState({
        inputValue: inputValue
      }, callback);
    }

    if (changed) {
      this.props.onChange(newValue);
    }

    return newValue;
  };

  // step={1.0} value={1.51}
  // press +
  // then value should be 2.51, rather than 2.5
  // if this.props.precision is undefined
  // https://github.com/react-component/input-number/issues/39
  _proto.getMaxPrecision = function getMaxPrecision(currentValue, ratio) {
    if (ratio === void 0) {
      ratio = 1;
    }

    var _this$props5 = this.props,
        precision = _this$props5.precision,
        step = _this$props5.step;

    if (isValidProps(precision)) {
      return precision;
    }

    var ratioPrecision = this.getPrecision(ratio);
    var stepPrecision = this.getPrecision(step);
    var currentValuePrecision = this.getPrecision(currentValue);

    if (!currentValue) {
      return ratioPrecision + stepPrecision;
    }

    return Math.max(currentValuePrecision, ratioPrecision + stepPrecision);
  };

  _proto.getPrecisionFactor = function getPrecisionFactor(currentValue, ratio) {
    if (ratio === void 0) {
      ratio = 1;
    }

    var precision = this.getMaxPrecision(currentValue, ratio);
    return Math.pow(10, precision);
  };

  _proto.focus = function focus() {
    this.input.focus();
    this.recordCursorPosition();
  };

  _proto.blur = function blur() {
    this.input.blur();
  };

  _proto.select = function select() {
    this.input.select();
  };

  _proto.formatWrapper = function formatWrapper(num) {
    // http://2ality.com/2012/03/signedzero.html
    // https://github.com/ant-design/ant-design/issues/9439
    if (this.props.formatter) {
      return this.props.formatter(num);
    }

    return num;
  };

  _proto.toPrecisionAsStep = function toPrecisionAsStep(num) {
    if (this.isNotCompleteNumber(num) || num === '') {
      return num;
    }

    var precision = Math.abs(this.getMaxPrecision(num));

    if (!isNaN(precision)) {
      return Number(num).toFixed(precision);
    }

    return num.toString();
  } // '1.' '1x' 'xx' '' => are not complete numbers
  ;

  _proto.toNumber = function toNumber(num) {
    var precision = this.props.precision;
    var focused = this.state.focused; // num.length > 16 => This is to prevent input of large numbers

    var numberIsTooLarge = num && num.length > 16 && focused;

    if (this.isNotCompleteNumber(num) || numberIsTooLarge) {
      return num;
    }

    if (isValidProps(precision)) {
      return Math.round(num * Math.pow(10, precision)) / Math.pow(10, precision);
    }

    return Number(num);
  };

  _proto.upStep = function upStep(val, rat) {
    var step = this.props.step;
    var precisionFactor = this.getPrecisionFactor(val, rat);
    var precision = Math.abs(this.getMaxPrecision(val, rat));
    var result = ((precisionFactor * val + precisionFactor * Number(step) * rat) / precisionFactor).toFixed(precision);
    return this.toNumber(result);
  };

  _proto.downStep = function downStep(val, rat) {
    var step = this.props.step;
    var precisionFactor = this.getPrecisionFactor(val, rat);
    var precision = Math.abs(this.getMaxPrecision(val, rat));
    var result = ((precisionFactor * val - precisionFactor * Number(step) * rat) / precisionFactor).toFixed(precision);
    return this.toNumber(result);
  };

  _proto.step = function step(type, e, ratio, recursive) {
    var _this2 = this;

    if (ratio === void 0) {
      ratio = 1;
    }

    this.stop();
    this.recordCursorPosition();

    if (e) {
      e.persist();
      e.preventDefault();
    }

    var props = this.props;

    if (props.disabled) {
      return;
    }

    var value = this.getCurrentValidValue(this.state.inputValue) || 0;

    if (this.isNotCompleteNumber(value)) {
      return;
    }

    var val = this[type + "Step"](value, ratio);
    var outOfRange = val > props.max || val < props.min;

    if (val > props.max) {
      val = props.max;
    } else if (val < props.min) {
      val = props.min;
    }

    this.setValue(val, null);
    if (props.onStep) props.onStep(val, {
      offset: ratio,
      type: type
    });
    this.setState({
      focused: true
    }, function () {
      _this2.pressingUpOrDown = false;
    });

    if (outOfRange) {
      return;
    }

    this.autoStepTimer = setTimeout(function () {
      _this2[type](e, ratio, true);
    }, recursive ? SPEED : DELAY);
  };

  _proto.fixCaret = function fixCaret(start, end) {
    if (start === undefined || end === undefined || !this.input || !this.input.value) {
      return;
    }

    try {
      var currentStart = this.input.selectionStart;
      var currentEnd = this.input.selectionEnd;

      if (start !== currentStart || end !== currentEnd) {
        this.input.setSelectionRange(start, end);
      }
    } catch (e) {// Fix error in Chrome:
      // Failed to read the 'selectionStart' property from 'HTMLInputElement'
      // http://stackoverflow.com/q/21177489/3040605
    }
  };

  _proto.render = function render() {
    var _classNames, _classNames2, _classNames3;

    var _this$props6 = this.props,
        prefixCls = _this$props6.prefixCls,
        disabled = _this$props6.disabled,
        readOnly = _this$props6.readOnly,
        useTouch = _this$props6.useTouch,
        autoComplete = _this$props6.autoComplete,
        upHandler = _this$props6.upHandler,
        downHandler = _this$props6.downHandler,
        className = _this$props6.className,
        max = _this$props6.max,
        min = _this$props6.min,
        style = _this$props6.style,
        title = _this$props6.title,
        onMouseEnter = _this$props6.onMouseEnter,
        onMouseLeave = _this$props6.onMouseLeave,
        onMouseOver = _this$props6.onMouseOver,
        onMouseOut = _this$props6.onMouseOut,
        required = _this$props6.required,
        onClick = _this$props6.onClick,
        tabIndex = _this$props6.tabIndex,
        type = _this$props6.type,
        placeholder = _this$props6.placeholder,
        id = _this$props6.id,
        inputMode = _this$props6.inputMode,
        pattern = _this$props6.pattern,
        step = _this$props6.step,
        maxLength = _this$props6.maxLength,
        autoFocus = _this$props6.autoFocus,
        name = _this$props6.name,
        onPaste = _this$props6.onPaste,
        onInput = _this$props6.onInput,
        testid = _this$props6.testid,
        rest = _objectWithoutPropertiesLoose(_this$props6, ["prefixCls", "disabled", "readOnly", "useTouch", "autoComplete", "upHandler", "downHandler", "className", "max", "min", "style", "title", "onMouseEnter", "onMouseLeave", "onMouseOver", "onMouseOut", "required", "onClick", "tabIndex", "type", "placeholder", "id", "inputMode", "pattern", "step", "maxLength", "autoFocus", "name", "onPaste", "onInput", "testid"]);

    var _this$state = this.state,
        value = _this$state.value,
        focused = _this$state.focused;
    var classes = classNames(prefixCls, (_classNames = {}, _classNames[className] = !!className, _classNames[prefixCls + "-disabled"] = disabled, _classNames[prefixCls + "-focused"] = focused, _classNames));
    var dataOrAriaAttributeProps = {};
    Object.keys(rest).forEach(function (key) {
      if (key.substr(0, 5) === 'data-' || key.substr(0, 5) === 'aria-' || key === 'role') {
        dataOrAriaAttributeProps[key] = rest[key];
      }
    });
    var editable = !readOnly && !disabled; // focus state, show input value
    // unfocus state, show valid value

    var inputDisplayValue = this.getInputDisplayValue(null);
    var upDisabled = (value || value === 0) && (isNaN(value) || Number(value) >= max);
    var downDisabled = (value || value === 0) && (isNaN(value) || Number(value) <= min);
    var isUpDisabled = upDisabled || disabled || readOnly;
    var isDownDisabled = downDisabled || disabled || readOnly;
    var upClassName = classNames(prefixCls + "-handler", prefixCls + "-handler-up", (_classNames2 = {}, _classNames2[prefixCls + "-handler-up-disabled"] = isUpDisabled, _classNames2));
    var downClassName = classNames(prefixCls + "-handler", prefixCls + "-handler-down", (_classNames3 = {}, _classNames3[prefixCls + "-handler-down-disabled"] = isDownDisabled, _classNames3));
    var upEvents = useTouch ? {
      onTouchStart: isUpDisabled ? noop : this.up,
      onTouchEnd: this.stop
    } : {
      onMouseDown: isUpDisabled ? noop : this.up,
      onMouseUp: this.stop,
      onMouseLeave: this.stop
    };
    var downEvents = useTouch ? {
      onTouchStart: isDownDisabled ? noop : this.down,
      onTouchEnd: this.stop
    } : {
      onMouseDown: isDownDisabled ? noop : this.down,
      onMouseUp: this.stop,
      onMouseLeave: this.stop
    };
    return /*#__PURE__*/_createElement("div", {
      className: classes,
      style: style,
      title: title,
      onMouseEnter: onMouseEnter,
      onMouseLeave: onMouseLeave,
      onMouseOver: onMouseOver,
      onMouseOut: onMouseOut,
      onFocus: function onFocus() {
        return null;
      },
      onBlur: function onBlur() {
        return null;
      },
      "data-testid": testid ? "InputNumber_" + testid : undefined
    }, /*#__PURE__*/_createElement("div", {
      className: prefixCls + "-handler-wrap"
    }, /*#__PURE__*/_createElement("span", _extends({
      unselectable: "on"
    }, upEvents, {
      role: "button",
      "aria-label": "Increase Value",
      "aria-disabled": isUpDisabled,
      className: upClassName,
      "data-testid": testid ? "InputNumber_" + testid + "_up" : undefined
    }), upHandler || /*#__PURE__*/_createElement("span", {
      unselectable: "on",
      className: prefixCls + "-handler-up-inner",
      onClick: preventDefault
    })), /*#__PURE__*/_createElement("span", _extends({
      unselectable: "on"
    }, downEvents, {
      role: "button",
      "aria-label": "Decrease Value",
      "aria-disabled": isDownDisabled,
      className: downClassName,
      "data-testid": testid ? "InputNumber_" + testid + "_down" : undefined
    }), downHandler || /*#__PURE__*/_createElement("span", {
      unselectable: "on",
      className: prefixCls + "-handler-down-inner",
      onClick: preventDefault
    }))), /*#__PURE__*/_createElement("div", {
      className: prefixCls + "-input-wrap"
    }, /*#__PURE__*/_createElement("input", _extends({
      "data-testid": testid ? "InputNumber_" + testid + "_input" : undefined,
      role: "spinbutton",
      "aria-valuemin": min,
      "aria-valuemax": max,
      "aria-valuenow": value,
      required: required,
      type: type,
      placeholder: placeholder,
      onPaste: onPaste,
      onClick: onClick,
      onMouseUp: this.onMouseUp,
      className: prefixCls + "-input",
      tabIndex: tabIndex,
      autoComplete: autoComplete,
      onFocus: this.onFocus,
      onBlur: this.onBlur,
      onKeyDown: editable ? this.onKeyDown : noop,
      onKeyUp: editable ? this.onKeyUp : noop,
      autoFocus: autoFocus,
      maxLength: maxLength,
      readOnly: readOnly,
      disabled: disabled,
      max: max,
      min: min,
      step: step,
      name: name,
      title: title,
      id: id,
      onChange: this.onChange,
      ref: this.saveInput,
      value: this.getFullNum(inputDisplayValue),
      pattern: pattern,
      inputMode: inputMode,
      onInput: onInput
    }, dataOrAriaAttributeProps))));
  };

  return InputNumber;
}(React.Component);

InputNumber.defaultProps = {
  focusOnUpDown: true,
  useTouch: false,
  prefixCls: 'rc-input-number',
  max: MAX_SAFE_INTEGER,
  min: -MAX_SAFE_INTEGER,
  step: 1,
  style: {},
  onChange: noop,
  onKeyDown: noop,
  onPressEnter: noop,
  onFocus: noop,
  onBlur: noop,
  parser: defaultParser,
  required: false,
  autoComplete: 'off'
};
export default InputNumber;