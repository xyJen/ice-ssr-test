var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import * as Mermaid from "mermaid";
// Define interface to await readiness of import
export function loadPluginFactory() {
    return __awaiter(this, void 0, void 0, function* () {
        const svgbob = yield import("svgbob-wasm");
        return (md, options) => {
            // Setup Mermaid
            Mermaid.initialize({
                securityLevel: 'loose'
            });
            function getLangName(info) {
                return info.split(/\s+/g)[0];
            }
            // Store reference to original renderer.
            let defaultFenceRenderer = md.renderer.rules.fence;
            // Render custom code types as SVGs, letting the fence parser do all the heavy lifting.
            function customFenceRenderer(tokens, idx, options, env, slf) {
                let token = tokens[idx];
                let info = token.info.trim();
                let langName = info ? getLangName(info) : "";
                let imageHTML = "";
                let imageAttrs = [];
                // Only handle custom token
                switch (langName) {
                    case "bob": // Legacy
                    case "svgbob": {
                        try {
                            imageHTML = svgbob.render(token.content);
                        }
                        catch (e) {
                            console.log(`Error in running svgbob.convert_string: ${e}`);
                        }
                        break;
                    }
                    case "mermaid": {
                        const element = document.createElement("div");
                        document.body.appendChild(element);
                        // Render with Mermaid
                        try {
                            const container_id = "mermaid-container";
                            Mermaid.mermaidAPI.render(container_id, token.content, (html) => {
                                // We need to forcibly extract the max-width/height attributes to set on img tag
                                let svg = document.getElementById(container_id);
                                if (svg !== null) {
                                    imageAttrs.push(["style", `max-width:${svg.style.maxWidth};max-height:${svg.style.maxHeight}`]);
                                }
                                // Store HTML
                                imageHTML = html;
                            }, element);
                        }
                        catch (e) {
                            console.log(`Error in running Mermaid.mermaidAPI.render: ${e}`);
                            return `<div class="alert alert-warning">${e.str}</div>`;
                        }
                        finally {
                            element.remove();
                        }
                        break;
                    }
                    default: {
                        return defaultFenceRenderer(tokens, idx, options, env, slf);
                    }
                }
                // If we have an image, let's render it, otherwise return blank img tag
                if (imageHTML.length) {
                    // Store encoded image data
                    imageAttrs.push(["src", `data:image/svg+xml,${encodeURIComponent(imageHTML)}`]);
                    return `<img ${slf.renderAttrs({ attrs: imageAttrs })}>`;
                }
                return "<img>";
            }
            md.renderer.rules.fence = customFenceRenderer;
        };
    });
}
